/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/support/page"],{

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ wa),\n/* harmony export */   B: () => (/* binding */ Xt),\n/* harmony export */   C: () => (/* binding */ ra),\n/* harmony export */   D: () => (/* binding */ ca),\n/* harmony export */   E: () => (/* binding */ vt),\n/* harmony export */   F: () => (/* binding */ ha),\n/* harmony export */   G: () => (/* binding */ va),\n/* harmony export */   H: () => (/* binding */ ie),\n/* harmony export */   I: () => (/* binding */ Et),\n/* harmony export */   J: () => (/* binding */ pt),\n/* harmony export */   K: () => (/* binding */ wt),\n/* harmony export */   L: () => (/* binding */ pa),\n/* harmony export */   M: () => (/* binding */ ua),\n/* harmony export */   N: () => (/* binding */ kt),\n/* harmony export */   O: () => (/* binding */ Rt),\n/* harmony export */   P: () => (/* binding */ Bt),\n/* harmony export */   Q: () => (/* binding */ Mt),\n/* harmony export */   R: () => (/* binding */ Ra),\n/* harmony export */   S: () => (/* binding */ la),\n/* harmony export */   T: () => (/* binding */ fa),\n/* harmony export */   U: () => (/* binding */ yt),\n/* harmony export */   V: () => (/* binding */ Ft),\n/* harmony export */   W: () => (/* binding */ bt),\n/* harmony export */   X: () => (/* binding */ Me),\n/* harmony export */   Y: () => (/* binding */ St),\n/* harmony export */   Z: () => (/* binding */ oe),\n/* harmony export */   _: () => (/* binding */ Ct),\n/* harmony export */   a: () => (/* binding */ Sa),\n/* harmony export */   b: () => (/* binding */ Pt),\n/* harmony export */   c: () => (/* binding */ sa),\n/* harmony export */   d: () => (/* binding */ ia),\n/* harmony export */   e: () => (/* binding */ oa),\n/* harmony export */   f: () => (/* binding */ ma),\n/* harmony export */   g: () => (/* binding */ Ea),\n/* harmony export */   h: () => (/* binding */ ga),\n/* harmony export */   i: () => (/* binding */ ba),\n/* harmony export */   j: () => (/* binding */ Ie),\n/* harmony export */   k: () => (/* binding */ ya),\n/* harmony export */   l: () => (/* binding */ $t),\n/* harmony export */   m: () => (/* binding */ Ca),\n/* harmony export */   n: () => (/* binding */ aa),\n/* harmony export */   o: () => (/* binding */ na),\n/* harmony export */   p: () => (/* binding */ It),\n/* harmony export */   q: () => (/* binding */ da),\n/* harmony export */   r: () => (/* binding */ be),\n/* harmony export */   s: () => (/* binding */ ne),\n/* harmony export */   t: () => (/* binding */ K),\n/* harmony export */   u: () => (/* binding */ Se),\n/* harmony export */   v: () => (/* binding */ ka),\n/* harmony export */   w: () => (/* binding */ Ma),\n/* harmony export */   x: () => (/* binding */ Zt),\n/* harmony export */   y: () => (/* binding */ Ht),\n/* harmony export */   z: () => (/* binding */ gt)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks-OJtwh4jO.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-OJtwh4jO.mjs\");\n/* harmony import */ var _room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./room-889cObLb.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-889cObLb.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contexts-Cm1aSBTs.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst aa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function(n, a) {\r\n    const { buttonProps: r } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(n);\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...r }, n.children);\r\n  }\r\n), na = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ room: n, ...a }, r) {\r\n    const c = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(n);\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: r, ...a }, c);\r\n  }\r\n), ra = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function(n, a) {\r\n    const { mergedProps: r } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.b)({ props: n });\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...r }, n.children);\r\n  }\r\n), ca = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function(n, a) {\r\n    const { buttonProps: r } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(n);\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: a, ...r }, n.children);\r\n  }\r\n), gt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708L11 10.293V4.5A1.5 1.5 0 0 0 9.5 3H3.707zM0 4.5a1.5 1.5 0 0 1 .943-1.393l9.532 9.533c-.262.224-.603.36-.975.36h-8A1.5 1.5 0 0 1 0 11.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"m15.2 3.6-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z\" })), vt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 4.5A1.5 1.5 0 0 1 1.5 3h8A1.5 1.5 0 0 1 11 4.5v7A1.5 1.5 0 0 1 9.5 13h-8A1.5 1.5 0 0 1 0 11.5zM15.2 3.6l-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z\" })), la = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, viewBox: \"0 0 24 24\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"#FFF\",\r\n    d: \"M4.99 3.99a1 1 0 0 0-.697 1.717L10.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414L12 13.414l6.293 6.293a1 1 0 1 0 1.414-1.414L13.414 12l6.293-6.293a1 1 0 0 0-.727-1.717 1 1 0 0 0-.687.303L12 10.586 5.707 4.293a1 1 0 0 0-.717-.303z\"\r\n  }\r\n)), sa = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 18, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M0 2.75A2.75 2.75 0 0 1 2.75 0h10.5A2.75 2.75 0 0 1 16 2.75v13.594a.75.75 0 0 1-1.234.572l-3.691-3.12a1.25 1.25 0 0 0-.807-.296H2.75A2.75 2.75 0 0 1 0 10.75v-8ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v8c0 .69.56 1.25 1.25 1.25h7.518c.65 0 1.279.23 1.775.65l2.457 2.077V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), ie = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentcolor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M5.293 2.293a1 1 0 0 1 1.414 0l4.823 4.823a1.25 1.25 0 0 1 0 1.768l-4.823 4.823a1 1 0 0 1-1.414-1.414L9.586 8 5.293 3.707a1 1 0 0 1 0-1.414z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), Et = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 1.5 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M10 1.75h4.25m0 0V6m0-4.25L9 7M6 14.25H1.75m0 0V10m0 4.25L7 9\" }))), ia = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentcolor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M8.961.894C8.875-.298 7.125-.298 7.04.894c-.066.912-1.246 1.228-1.76.472-.67-.99-2.186-.115-1.664.96.399.824-.465 1.688-1.288 1.289-1.076-.522-1.95.994-.961 1.665.756.513.44 1.693-.472 1.759-1.192.086-1.192 1.836 0 1.922.912.066 1.228 1.246.472 1.76-.99.67-.115 2.186.96 1.664.824-.399 1.688.465 1.289 1.288-.522 1.076.994 1.95 1.665.961.513-.756 1.693-.44 1.759.472.086 1.192 1.836 1.192 1.922 0 .066-.912 1.246-1.228 1.76-.472.67.99 2.186.115 1.664-.96-.399-.824.465-1.688 1.288-1.289 1.076.522 1.95-.994.961-1.665-.756-.513-.44-1.693.472-1.759 1.192-.086 1.192-1.836 0-1.922-.912-.066-1.228-1.246-.472-1.76.99-.67.115-2.186-.96-1.664-.824.399-1.688-.465-1.289-1.288.522-1.076-.994-1.95-1.665-.961-.513.756-1.693.44-1.759-.472ZM8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), oa = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M2 2.75A2.75 2.75 0 0 1 4.75 0h6.5A2.75 2.75 0 0 1 14 2.75v10.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-.5a.75.75 0 0 1 1.5 0v.5c0 .69.56 1.25 1.25 1.25h6.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25h-6.5c-.69 0-1.25.56-1.25 1.25v.5a.75.75 0 0 1-1.5 0v-.5Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M8.78 7.47a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 1 1-1.06-1.06l.97-.97H1.75a.75.75 0 0 1 0-1.5h4.69l-.97-.97a.75.75 0 0 1 1.06-1.06l2.25 2.25Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), pt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentcolor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M4 6.104V4a4 4 0 1 1 8 0v2.104c1.154.326 2 1.387 2 2.646v4.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-4.5c0-1.259.846-2.32 2-2.646ZM5.5 4a2.5 2.5 0 0 1 5 0v2h-5V4Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), wt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12.227 11.52a5.477 5.477 0 0 0 1.246-2.97.5.5 0 0 0-.995-.1 4.478 4.478 0 0 1-.962 2.359l-1.07-1.07C10.794 9.247 11 8.647 11 8V3a3 3 0 0 0-6 0v1.293L1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708zM8 12.5c.683 0 1.33-.152 1.911-.425l.743.743c-.649.359-1.378.59-2.154.66V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .995-.098A4.5 4.5 0 0 0 8 12.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M8.743 10.907 5 7.164V8a3 3 0 0 0 3.743 2.907z\" })), kt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fillRule: \"evenodd\",\r\n    d: \"M2.975 8.002a.5.5 0 0 1 .547.449 4.5 4.5 0 0 0 8.956 0 .5.5 0 1 1 .995.098A5.502 5.502 0 0 1 8.5 13.478V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .448-.547z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M5 3a3 3 0 1 1 6 0v5a3 3 0 0 1-6 0z\" })), Rt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" })), Mt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }))), yt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentcolor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z\" }))), bt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"currentColor\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { opacity: 0.25 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z\" }))), Me = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 20, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M0 2.75A2.75 2.75 0 0 1 2.75 0h14.5A2.75 2.75 0 0 1 20 2.75v10.5A2.75 2.75 0 0 1 17.25 16H2.75A2.75 2.75 0 0 1 0 13.25V2.75ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h14.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M9.47 4.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1-1.06 1.06l-.97-.97v4.69a.75.75 0 0 1-1.5 0V6.56l-.97.97a.75.75 0 0 1-1.06-1.06l2.25-2.25Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n)), St = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 20, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { fill: \"currentColor\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M7.28 4.22a.75.75 0 0 0-1.06 1.06L8.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L10 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L11.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L10 6.94z\" }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fillRule: \"evenodd\",\r\n    d: \"M2.75 0A2.75 2.75 0 0 0 0 2.75v10.5A2.75 2.75 0 0 0 2.75 16h14.5A2.75 2.75 0 0 0 20 13.25V2.75A2.75 2.75 0 0 0 17.25 0zM1.5 2.75c0-.69.56-1.25 1.25-1.25h14.5c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H2.75c-.69 0-1.25-.56-1.25-1.25z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n))), oe = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M8 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8 0Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M8 12a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 8 12Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.7\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M12 1.072a.75.75 0 0 1 .274 1.024l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 12 1.072Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M6 11.464a.75.75 0 0 1 .274 1.025l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 6 11.464Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.6\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M14.928 4a.75.75 0 0 1-.274 1.025l-2.165 1.25a.75.75 0 1 1-.75-1.3l2.165-1.25A.75.75 0 0 1 14.928 4Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M4.536 10a.75.75 0 0 1-.275 1.024l-2.165 1.25a.75.75 0 0 1-.75-1.298l2.165-1.25A.75.75 0 0 1 4.536 10Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.5\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M16 8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 16 8Z\",\r\n    clipRule: \"evenodd\"\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M4 8a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 8Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.4\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M14.928 12a.75.75 0 0 1-1.024.274l-2.165-1.25a.75.75 0 0 1 .75-1.299l2.165 1.25A.75.75 0 0 1 14.928 12Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.9\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M4.536 6a.75.75 0 0 1-1.025.275l-2.165-1.25a.75.75 0 1 1 .75-1.3l2.165 1.25A.75.75 0 0 1 4.536 6Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.3\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M12 14.928a.75.75 0 0 1-1.024-.274l-1.25-2.165a.75.75 0 0 1 1.298-.75l1.25 2.165A.75.75 0 0 1 12 14.928Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.8\r\n  }\r\n), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"path\",\r\n  {\r\n    fill: \"currentColor\",\r\n    fillRule: \"evenodd\",\r\n    d: \"M6 4.536a.75.75 0 0 1-1.024-.275l-1.25-2.165a.75.75 0 1 1 1.299-.75l1.25 2.165A.75.75 0 0 1 6 4.536Z\",\r\n    clipRule: \"evenodd\",\r\n    opacity: 0.2\r\n  }\r\n)), Ct = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", width: 16, height: 16, fill: \"none\", ...t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: 1.5 }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M13.25 7H9m0 0V2.75M9 7l5.25-5.25M2.75 9H7m0 0v4.25M7 9l-5.25 5.25\" }))), It = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ trackRef: n, ...a }, r) {\r\n    const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ab)(), { mergedProps: s, inFocus: o } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.d)({\r\n      trackRef: n ?? c,\r\n      props: a\r\n    });\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ac.Consumer, null, (l) => l !== void 0 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: r, ...s }, a.children ? a.children : o ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ct, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Et, null)));\r\n  }\r\n), ua = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({\r\n    kind: n,\r\n    initialSelection: a,\r\n    onActiveDeviceChange: r,\r\n    onDeviceListChange: c,\r\n    onDeviceSelectError: s,\r\n    exactMatch: o,\r\n    track: l,\r\n    requestPermissions: i,\r\n    onError: u,\r\n    ...d\r\n  }, g) {\r\n    const f = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.w)(), w = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\r\n      (E) => {\r\n        f && f.emit(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, E), u == null || u(E);\r\n      },\r\n      [f, u]\r\n    ), { devices: p, activeDeviceId: m, setActiveMediaDevice: v, className: b } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.e)({\r\n      kind: n,\r\n      room: f,\r\n      track: l,\r\n      requestPermissions: i,\r\n      onError: w\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      a !== void 0 && v(a);\r\n    }, [v]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      typeof c == \"function\" && c(p);\r\n    }, [c, p]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      m && m !== \"\" && (r == null || r(m));\r\n    }, [m]);\r\n    const C = async (E) => {\r\n      try {\r\n        await v(E, { exact: o ?? !0 });\r\n      } catch (k) {\r\n        if (k instanceof Error)\r\n          s == null || s(k);\r\n        else\r\n          throw k;\r\n      }\r\n    }, T = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n      () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(d, { className: b }, { className: \"lk-list\" }),\r\n      [b, d]\r\n    ), A = !!p.find((E) => E.label.toLowerCase().startsWith(\"default\"));\r\n    function h(E, k, I) {\r\n      return E === k || !A && I === 0 && k === \"default\";\r\n    }\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", { ref: g, ...T }, p.map((E, k) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      \"li\",\r\n      {\r\n        key: E.deviceId,\r\n        id: E.deviceId,\r\n        \"data-lk-active\": h(E.deviceId, m, k),\r\n        \"aria-selected\": h(E.deviceId, m, k),\r\n        role: \"option\"\r\n      },\r\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: () => C(E.deviceId) }, E.label)\r\n    )));\r\n  }\r\n), da = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ label: n = \"Allow Audio\", ...a }, r) {\r\n    const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.f)(), { mergedProps: s } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.f)({ room: c, props: a });\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: r, ...s }, n);\r\n  }\r\n), ma = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ label: n, ...a }, r) {\r\n    const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.f)(), { mergedProps: s, canPlayAudio: o } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.f)({ room: c, props: a }), { mergedProps: l, canPlayVideo: i } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.g)({ room: c, props: s }), { style: u, ...d } = l;\r\n    return u.display = o && i ? \"none\" : \"block\", /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: r, style: u, ...d }, n ?? `Start ${o ? \"Video\" : \"Audio\"}`);\r\n  }\r\n);\r\nfunction ye(t, n) {\r\n  switch (t) {\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone:\r\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(kt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(wt, null);\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera:\r\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(vt, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(gt, null);\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare:\r\n      return n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(St, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Me, null);\r\n    default:\r\n      return;\r\n  }\r\n}\r\nfunction xt(t) {\r\n  switch (t) {\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Excellent:\r\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Rt, null);\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Good:\r\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mt, null);\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Poor:\r\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(yt, null);\r\n    default:\r\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(bt, null);\r\n  }\r\n}\r\nconst fa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ showIcon: n, ...a }, r) {\r\n  const { buttonProps: c, enabled: s } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(a), [o, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    l(!0);\r\n  }, []), o && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { ref: r, ...c }, (n ?? !0) && ye(a.source, s), a.children);\r\n}), be = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(n, a) {\r\n  const { className: r, quality: c } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(n), s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({ ...(0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n, { className: r }), \"data-lk-quality\": c }), [c, n, r]);\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: a, ...s }, n.children ?? xt(c));\r\n}), K = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ participant: n, ...a }, r) {\r\n    const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.c)(n), { className: s, infoObserver: o } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ad)(c), [c]), { identity: l, name: i } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.j)(o, {\r\n      name: c.name,\r\n      identity: c.identity,\r\n      metadata: c.metadata\r\n    }), u = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(a, { className: s, \"data-lk-participant-name\": i }), [a, s, i]);\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { ref: r, ...u }, i !== \"\" ? i : l, a.children);\r\n  }\r\n), Se = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ trackRef: n, show: a = \"always\", ...r }, c) {\r\n    const { className: s, isMuted: o } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.k)(n), l = a === \"always\" || a === \"muted\" && o || a === \"unmuted\" && !o, i = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n      () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(r, {\r\n        className: s\r\n      }),\r\n      [s, r]\r\n    );\r\n    return l ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: c, ...i, \"data-lk-muted\": o }, r.children ?? ye(n.source, !o)) : null;\r\n  }\r\n), Pt = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n  \"svg\",\r\n  {\r\n    width: 320,\r\n    height: 320,\r\n    viewBox: \"0 0 320 320\",\r\n    preserveAspectRatio: \"xMidYMid meet\",\r\n    fill: \"none\",\r\n    xmlns: \"http://www.w3.org/2000/svg\",\r\n    ...t\r\n  },\r\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n    \"path\",\r\n    {\r\n      d: \"M160 180C204.182 180 240 144.183 240 100C240 55.8172 204.182 20 160 20C115.817 20 79.9997 55.8172 79.9997 100C79.9997 144.183 115.817 180 160 180Z\",\r\n      fill: \"white\",\r\n      fillOpacity: 0.25\r\n    }\r\n  ),\r\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n    \"path\",\r\n    {\r\n      d: \"M97.6542 194.614C103.267 191.818 109.841 192.481 115.519 195.141C129.025 201.466 144.1 205 159.999 205C175.899 205 190.973 201.466 204.48 195.141C210.158 192.481 216.732 191.818 222.345 194.614C262.703 214.719 291.985 253.736 298.591 300.062C300.15 310.997 291.045 320 280 320H39.9997C28.954 320 19.8495 310.997 21.4087 300.062C28.014 253.736 57.2966 214.72 97.6542 194.614Z\",\r\n      fill: \"white\",\r\n      fillOpacity: 0.25\r\n    }\r\n  )\r\n);\r\nfunction Ce(t, n = {}) {\r\n  const [a, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState((0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.X)(t)), [c, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.isMuted), [o, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.isSubscribed), [i, u] = react__WEBPACK_IMPORTED_MODULE_0__.useState(a == null ? void 0 : a.track), [d, g] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"landscape\"), f = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), { className: w, trackObserver: p } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.Y)(t), [\r\n    t.participant.sid ?? t.participant.identity,\r\n    t.source,\r\n    (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(t) && t.publication.trackSid\r\n  ]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const m = p.subscribe((v) => {\r\n      _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"update track\", v), r(v), s(v == null ? void 0 : v.isMuted), l(v == null ? void 0 : v.isSubscribed), u(v == null ? void 0 : v.track);\r\n    });\r\n    return () => m == null ? void 0 : m.unsubscribe();\r\n  }, [p]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    var m, v;\r\n    return i && (f.current && i.detach(f.current), (m = n.element) != null && m.current && !(t.participant.isLocal && (i == null ? void 0 : i.kind) === \"audio\") && i.attach(n.element.current)), f.current = (v = n.element) == null ? void 0 : v.current, () => {\r\n      f.current && (i == null || i.detach(f.current));\r\n    };\r\n  }, [i, n.element]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    var m, v;\r\n    if (typeof ((m = a == null ? void 0 : a.dimensions) == null ? void 0 : m.width) == \"number\" && typeof ((v = a == null ? void 0 : a.dimensions) == null ? void 0 : v.height) == \"number\") {\r\n      const b = a.dimensions.width > a.dimensions.height ? \"landscape\" : \"portrait\";\r\n      g(b);\r\n    }\r\n  }, [a]), {\r\n    publication: a,\r\n    isMuted: c,\r\n    isSubscribed: o,\r\n    track: i,\r\n    elementProps: (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n.props, {\r\n      className: w,\r\n      \"data-lk-local-participant\": t.participant.isLocal,\r\n      \"data-lk-source\": a == null ? void 0 : a.source,\r\n      ...(a == null ? void 0 : a.kind) === \"video\" && { \"data-lk-orientation\": d }\r\n    })\r\n  };\r\n}\r\nvar Y, ue;\r\nfunction Tt() {\r\n  if (ue) return Y;\r\n  ue = 1;\r\n  var t = \"Expected a function\", n = NaN, a = \"[object Symbol]\", r = /^\\s+|\\s+$/g, c = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, o = /^0o[0-7]+$/i, l = parseInt, i = typeof _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ae == \"object\" && _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ae && _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ae.Object === Object && _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ae, u = typeof self == \"object\" && self && self.Object === Object && self, d = i || u || Function(\"return this\")(), g = Object.prototype, f = g.toString, w = Math.max, p = Math.min, m = function() {\r\n    return d.Date.now();\r\n  };\r\n  function v(h, E, k) {\r\n    var I, V, O, N, M, P, F = 0, re = !1, Z = !1, D = !0;\r\n    if (typeof h != \"function\")\r\n      throw new TypeError(t);\r\n    E = A(E) || 0, b(k) && (re = !!k.leading, Z = \"maxWait\" in k, O = Z ? w(A(k.maxWait) || 0, E) : O, D = \"trailing\" in k ? !!k.trailing : D);\r\n    function U(R) {\r\n      var x = I, H = V;\r\n      return I = V = void 0, F = R, N = h.apply(H, x), N;\r\n    }\r\n    function Pe(R) {\r\n      return F = R, M = setTimeout(W, E), re ? U(R) : N;\r\n    }\r\n    function Te(R) {\r\n      var x = R - P, H = R - F, se = E - x;\r\n      return Z ? p(se, O - H) : se;\r\n    }\r\n    function ce(R) {\r\n      var x = R - P, H = R - F;\r\n      return P === void 0 || x >= E || x < 0 || Z && H >= O;\r\n    }\r\n    function W() {\r\n      var R = m();\r\n      if (ce(R))\r\n        return le(R);\r\n      M = setTimeout(W, Te(R));\r\n    }\r\n    function le(R) {\r\n      return M = void 0, D && I ? U(R) : (I = V = void 0, N);\r\n    }\r\n    function Ae() {\r\n      M !== void 0 && clearTimeout(M), F = 0, I = P = V = M = void 0;\r\n    }\r\n    function Ne() {\r\n      return M === void 0 ? N : le(m());\r\n    }\r\n    function G() {\r\n      var R = m(), x = ce(R);\r\n      if (I = arguments, V = this, P = R, x) {\r\n        if (M === void 0)\r\n          return Pe(P);\r\n        if (Z)\r\n          return M = setTimeout(W, E), U(P);\r\n      }\r\n      return M === void 0 && (M = setTimeout(W, E)), N;\r\n    }\r\n    return G.cancel = Ae, G.flush = Ne, G;\r\n  }\r\n  function b(h) {\r\n    var E = typeof h;\r\n    return !!h && (E == \"object\" || E == \"function\");\r\n  }\r\n  function C(h) {\r\n    return !!h && typeof h == \"object\";\r\n  }\r\n  function T(h) {\r\n    return typeof h == \"symbol\" || C(h) && f.call(h) == a;\r\n  }\r\n  function A(h) {\r\n    if (typeof h == \"number\")\r\n      return h;\r\n    if (T(h))\r\n      return n;\r\n    if (b(h)) {\r\n      var E = typeof h.valueOf == \"function\" ? h.valueOf() : h;\r\n      h = b(E) ? E + \"\" : E;\r\n    }\r\n    if (typeof h != \"string\")\r\n      return h === 0 ? h : +h;\r\n    h = h.replace(r, \"\");\r\n    var k = s.test(h);\r\n    return k || o.test(h) ? l(h.slice(2), k ? 2 : 8) : c.test(h) ? n : +h;\r\n  }\r\n  return Y = v, Y;\r\n}\r\nvar At = Tt();\r\nconst de = /* @__PURE__ */ (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.af)(At);\r\nfunction Nt(t) {\r\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t);\r\n  n.current = t, (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\r\n    () => () => {\r\n      n.current();\r\n    },\r\n    []\r\n  );\r\n}\r\nfunction Lt(t, n = 500, a) {\r\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\r\n  Nt(() => {\r\n    r.current && r.current.cancel();\r\n  });\r\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\r\n    const s = de(t, n, a), o = (...l) => s(...l);\r\n    return o.cancel = () => {\r\n      s.cancel();\r\n    }, o.isPending = () => !!r.current, o.flush = () => s.flush(), o;\r\n  }, [t, n, a]);\r\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    r.current = de(t, n, a);\r\n  }, [t, n, a]), c;\r\n}\r\nfunction zt(t, n, a) {\r\n  const r = (u, d) => u === d, c = t instanceof Function ? t() : t, [s, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(c), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(c), i = Lt(\r\n    o,\r\n    n,\r\n    a\r\n  );\r\n  return r(l.current, c) || (i(c), l.current = c), [s, i];\r\n}\r\nfunction Vt({\r\n  threshold: t = 0,\r\n  root: n = null,\r\n  rootMargin: a = \"0%\",\r\n  freezeOnceVisible: r = !1,\r\n  initialIsIntersecting: c = !1,\r\n  onChange: s\r\n} = {}) {\r\n  var o;\r\n  const [l, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [u, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({\r\n    isIntersecting: c,\r\n    entry: void 0\r\n  })), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\r\n  g.current = s;\r\n  const f = ((o = u.entry) == null ? void 0 : o.isIntersecting) && r;\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (!l || !(\"IntersectionObserver\" in window) || f)\r\n      return;\r\n    const m = new IntersectionObserver(\r\n      (v) => {\r\n        const b = Array.isArray(m.thresholds) ? m.thresholds : [m.thresholds];\r\n        v.forEach((C) => {\r\n          const T = C.isIntersecting && b.some((A) => C.intersectionRatio >= A);\r\n          d({ isIntersecting: T, entry: C }), g.current && g.current(T, C);\r\n        });\r\n      },\r\n      { threshold: t, root: n, rootMargin: a }\r\n    );\r\n    return m.observe(l), () => {\r\n      m.disconnect();\r\n    };\r\n  }, [\r\n    l,\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    JSON.stringify(t),\r\n    n,\r\n    a,\r\n    f,\r\n    r\r\n  ]);\r\n  const w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    var m;\r\n    !l && ((m = u.entry) != null && m.target) && !r && !f && w.current !== u.entry.target && (w.current = u.entry.target, d({ isIntersecting: c, entry: void 0 }));\r\n  }, [l, u.entry, r, f, c]);\r\n  const p = [\r\n    i,\r\n    !!u.isIntersecting,\r\n    u.entry\r\n  ];\r\n  return p.ref = p[0], p.isIntersecting = p[1], p.entry = p[2], p;\r\n}\r\nconst Ft = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({\r\n    onTrackClick: n,\r\n    onClick: a,\r\n    onSubscriptionStatusChanged: r,\r\n    trackRef: c,\r\n    manageSubscription: s,\r\n    ...o\r\n  }, l) {\r\n    const i = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(c), u = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(l, () => u.current);\r\n    const d = Vt({ root: u.current }), [g] = zt(d, 3e3);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      s && i.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication && (g == null ? void 0 : g.isIntersecting) === !1 && (d == null ? void 0 : d.isIntersecting) === !1 && i.publication.setSubscribed(!1);\r\n    }, [g, i, s]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      s && i.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication && (d == null ? void 0 : d.isIntersecting) === !0 && i.publication.setSubscribed(!0);\r\n    }, [d, i, s]);\r\n    const {\r\n      elementProps: f,\r\n      publication: w,\r\n      isSubscribed: p\r\n    } = Ce(i, {\r\n      element: u,\r\n      props: o\r\n    });\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      r == null || r(!!p);\r\n    }, [p, r]);\r\n    const m = (v) => {\r\n      a == null || a(v), n == null || n({ participant: i == null ? void 0 : i.participant, track: w });\r\n    };\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"video\", { ref: u, ...f, muted: !0, onClick: m });\r\n  }\r\n), ne = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ trackRef: n, onSubscriptionStatusChanged: a, volume: r, ...c }, s) {\r\n    const o = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), l = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(s, () => l.current);\r\n    const {\r\n      elementProps: i,\r\n      isSubscribed: u,\r\n      track: d,\r\n      publication: g\r\n    } = Ce(o, {\r\n      element: l,\r\n      props: c\r\n    });\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      a == null || a(!!u);\r\n    }, [u, a]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      d === void 0 || r === void 0 || (d instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteAudioTrack ? d.setVolume(r) : _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.l.warn(\"Volume can only be set on remote audio tracks.\"));\r\n    }, [r, d]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n      g === void 0 || c.muted === void 0 || (g instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.RemoteTrackPublication ? g.setEnabled(!c.muted) : _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.l.warn(\"Can only call setEnabled on remote track publications.\"));\r\n    }, [c.muted, g, d]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"audio\", { ref: l, ...i });\r\n  }\r\n);\r\nfunction Zt(t) {\r\n  const n = !!(0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.B)();\r\n  return t.participant && !n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ag.Provider, { value: t.participant }, t.children) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.children);\r\n}\r\nfunction Ht(t) {\r\n  const n = !!(0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ab)();\r\n  return t.trackRef && !n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ah.Provider, { value: t.trackRef }, t.children) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.children);\r\n}\r\nconst Bt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({\r\n    trackRef: n,\r\n    children: a,\r\n    onParticipantClick: r,\r\n    disableSpeakingIndicator: c,\r\n    ...s\r\n  }, o) {\r\n    var w, p;\r\n    const l = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), { elementProps: i } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.l)({\r\n      htmlProps: s,\r\n      disableSpeakingIndicator: c,\r\n      onParticipantClick: r,\r\n      trackRef: l\r\n    }), u = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(l.participant), d = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.j)(), g = (w = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ai)()) == null ? void 0 : w.autoSubscription, f = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\r\n      (m) => {\r\n        l.source && !m && d && d.pin.dispatch && (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(l, d.pin.state) && d.pin.dispatch({ msg: \"clear_pin\" });\r\n      },\r\n      [l, d]\r\n    );\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, style: { position: \"relative\" }, ...i }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ht, { trackRef: l }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Zt, { participant: l.participant }, a ?? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && (((p = l.publication) == null ? void 0 : p.kind) === \"video\" || l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera || l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      Ft,\r\n      {\r\n        trackRef: l,\r\n        onSubscriptionStatusChanged: f,\r\n        manageSubscription: g\r\n      }\r\n    ) : (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      ne,\r\n      {\r\n        trackRef: l,\r\n        onSubscriptionStatusChanged: f\r\n      }\r\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-placeholder\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Pt, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata-item\" }, l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, u && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(pt, { style: { marginRight: \"0.25rem\" } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      Se,\r\n      {\r\n        trackRef: {\r\n          participant: l.participant,\r\n          source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone\r\n        },\r\n        show: \"muted\"\r\n      }\r\n    ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null)) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Me, { style: { marginRight: \"0.25rem\" } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null, \"'s screen\"))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(be, { className: \"lk-participant-metadata-item\" }))), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(It, { trackRef: l }))));\r\n  }\r\n);\r\nfunction ha(t) {\r\n  const n = (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(t, { className: \"lk-focus-layout\" });\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...n }, t.children);\r\n}\r\nfunction ga({ trackRef: t, ...n }) {\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Bt, { trackRef: t, ...n });\r\n}\r\nfunction Ie({ tracks: t, ...n }) {\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.map((a) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n    _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ah.Provider,\r\n    {\r\n      value: a,\r\n      key: (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.p)(a)\r\n    },\r\n    (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(n.children)\r\n  )));\r\n}\r\nfunction jt({\r\n  totalPageCount: t,\r\n  nextPage: n,\r\n  prevPage: a,\r\n  currentPage: r,\r\n  pagesContainer: c\r\n}) {\r\n  const [s, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!1);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    let l;\r\n    return c && (l = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.aj)(c.current, 2e3).subscribe(\r\n      o\r\n    )), () => {\r\n      l && l.unsubscribe();\r\n    };\r\n  }, [c]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-pagination-control\", \"data-lk-user-interaction\": s }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: a }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ie, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-pagination-count\" }, `${r} of ${t}`), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"lk-button\", onClick: n }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ie, null)));\r\n}\r\nconst _t = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ totalPageCount: n, currentPage: a }, r) {\r\n    const c = new Array(n).fill(\"\").map((s, o) => o + 1 === a ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { \"data-lk-active\": !0, key: o }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { key: o }));\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: r, className: \"lk-pagination-indicator\" }, c);\r\n  }\r\n);\r\nfunction va({ tracks: t, ...n }) {\r\n  const a = react__WEBPACK_IMPORTED_MODULE_0__.createRef(), r = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(n, { className: \"lk-grid-layout\" }),\r\n    [n]\r\n  ), { layout: c } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.n)(a, t.length), s = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.o)(c.maxTiles, t);\r\n  return (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(a, {\r\n    onLeftSwipe: s.nextPage,\r\n    onRightSwipe: s.prevPage\r\n  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: a, \"data-lk-pagination\": s.totalPageCount > 1, ...r }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ie, { tracks: s.tracks }, n.children), t.length > c.maxTiles && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n    _t,\r\n    {\r\n      totalPageCount: s.totalPageCount,\r\n      currentPage: s.currentPage\r\n    }\r\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(jt, { pagesContainer: a, ...s })));\r\n}\r\nconst Ot = 130, Wt = 140, me = 1, xe = 16 / 10, qt = (1 - xe) * -1;\r\nfunction Ea({ tracks: t, orientation: n, ...a }) {\r\n  const r = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), [c, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0), { width: o, height: l } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(r), i = n || (l >= o ? \"vertical\" : \"horizontal\"), u = i === \"vertical\" ? Math.max(o * qt, Ot) : Math.max(l * xe, Wt), d = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ak)(), g = Math.max(i === \"vertical\" ? (l - d) / u : (o - d) / u, me);\r\n  let f = Math.round(g);\r\n  Math.abs(g - c) < 0.5 ? f = Math.round(c) : c !== g && s(g);\r\n  const w = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(t, f);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n    r.current && (r.current.dataset.lkOrientation = i, r.current.style.setProperty(\"--lk-max-visible-tiles\", f.toString()));\r\n  }, [f, i]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"aside\", { key: i, className: \"lk-carousel\", ref: r, ...a }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Ie, { tracks: w }, a.children));\r\n}\r\nfunction pa({\r\n  value: t,\r\n  onPinChange: n,\r\n  onWidgetChange: a,\r\n  children: r\r\n}) {\r\n  const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.al)(t);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"PinState Updated\", { state: c.pin.state }), n && c.pin.state && n(c.pin.state);\r\n  }, [c.pin.state, n]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.l.debug(\"Widget Updated\", { widgetState: c.widget.state }), a && c.widget.state && a(c.widget.state);\r\n  }, [a, c.widget.state]), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ac.Provider, { value: c }, r);\r\n}\r\nconst wa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ trackRef: n, ...a }, r) {\r\n    const d = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(n), g = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(d, { bands: 7, loPass: 300 });\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      \"svg\",\r\n      {\r\n        ref: r,\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        viewBox: \"0 0 200 90\",\r\n        ...a,\r\n        className: \"lk-audio-visualizer\"\r\n      },\r\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\" }),\r\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n        \"g\",\r\n        {\r\n          style: {\r\n            transform: `translate(${(200 - 7 * 10) / 2}px, 0)`\r\n          }\r\n        },\r\n        g.map((f, w) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n          \"rect\",\r\n          {\r\n            key: w,\r\n            x: w * 10,\r\n            y: 90 / 2 - f * 50 / 2,\r\n            width: 6,\r\n            height: f * 50\r\n          }\r\n        ))\r\n      )\r\n    );\r\n  }\r\n);\r\nfunction ka({ participants: t, ...n }) {\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, t.map((a) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ag.Provider, { value: a, key: a.identity }, (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(n.children))));\r\n}\r\nfunction Ra({ volume: t, muted: n }) {\r\n  const a = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(\r\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShareAudio, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown],\r\n    {\r\n      updateOnlyOn: [],\r\n      onlySubscribed: !0\r\n    }\r\n  ).filter((r) => !r.participant.isLocal && r.publication.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Kind.Audio);\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { display: \"none\" } }, a.map((r) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n    ne,\r\n    {\r\n      key: (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.p)(r),\r\n      trackRef: r,\r\n      volume: t,\r\n      muted: n\r\n    }\r\n  )));\r\n}\r\nconst Ma = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function({ childrenPosition: n = \"before\", children: a, ...r }, c) {\r\n  const { name: s } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.v)();\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { ref: c, ...r }, n === \"before\" && a, s, n === \"after\" && a);\r\n});\r\nfunction $t(t) {\r\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(t, { className: \"lk-toast\" }), [t]);\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...n }, t.children);\r\n}\r\nconst Dt = (t) => {\r\n  const n = [];\r\n  for (let a = 0; a < t; a++)\r\n    n.push([a, t - 1 - a]);\r\n  return n;\r\n}, fe = (t) => [[Math.floor(t / 2)], [-1]], Ut = (t, n, a) => {\r\n  const [r, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), [s, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([[]]);\r\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    if (t === \"thinking\")\r\n      o(fe(n));\r\n    else if (t === \"connecting\" || t === \"initializing\") {\r\n      const i = [...Dt(n)];\r\n      o(i);\r\n    } else o(t === \"listening\" ? fe(n) : t === void 0 || t === \"speaking\" ? [new Array(n).fill(0).map((i, u) => u)] : [[]]);\r\n    c(0);\r\n  }, [t, n]);\r\n  const l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\r\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\r\n    let i = performance.now();\r\n    const u = (d) => {\r\n      d - i >= a && (c((f) => f + 1), i = d), l.current = requestAnimationFrame(u);\r\n    };\r\n    return l.current = requestAnimationFrame(u), () => {\r\n      l.current !== null && cancelAnimationFrame(l.current);\r\n    };\r\n  }, [a, n, t, s.length]), s[r % s.length];\r\n}, Gt = /* @__PURE__ */ new Map([\r\n  [\"connecting\", 2e3],\r\n  [\"initializing\", 2e3],\r\n  [\"listening\", 500],\r\n  [\"thinking\", 150]\r\n]), Qt = (t, n) => {\r\n  if (t === void 0)\r\n    return 1e3;\r\n  let a = Gt.get(t);\r\n  if (a)\r\n    switch (t) {\r\n      case \"connecting\":\r\n        a /= n;\r\n        break;\r\n    }\r\n  return a;\r\n}, Xt = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ state: n, options: a, barCount: r = 15, trackRef: c, children: s, ...o }, l) {\r\n    const i = (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.a)(o, { className: \"lk-audio-bar-visualizer\" });\r\n    let u = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ab)();\r\n    c && (u = c);\r\n    const d = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.s)(u, {\r\n      bands: r,\r\n      loPass: 100,\r\n      hiPass: 200\r\n    }), g = (a == null ? void 0 : a.minHeight) ?? 20, f = (a == null ? void 0 : a.maxHeight) ?? 100, w = Ut(\r\n      n,\r\n      r,\r\n      Qt(n, r) ?? 100\r\n    );\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: l, ...i, \"data-lk-va-state\": n }, d.map(\r\n      (p, m) => s ? (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_4__.c)(s, {\r\n        \"data-lk-highlighted\": w.includes(m),\r\n        \"data-lk-bar-index\": m,\r\n        className: \"lk-audio-bar\",\r\n        style: { height: `${Math.min(f, Math.max(g, p * 100 + 5))}%` }\r\n      }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n        \"span\",\r\n        {\r\n          key: m,\r\n          \"data-lk-highlighted\": w.includes(m),\r\n          \"data-lk-bar-index\": m,\r\n          className: `lk-audio-bar ${w.includes(m) && \"lk-highlighted\"}`,\r\n          style: {\r\n            // TODO transform animations would be more performant, however the border-radius gets distorted when using scale transforms. a 9-slice approach (or 3 in this case) could work\r\n            // transform: `scale(1, ${Math.min(maxHeight, Math.max(minHeight, volume))}`,\r\n            height: `${Math.min(f, Math.max(g, p * 100 + 5))}%`\r\n          }\r\n        }\r\n      )\r\n    ));\r\n  }\r\n), ya = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({\r\n    children: n,\r\n    disableSpeakingIndicator: a,\r\n    onParticipantClick: r,\r\n    trackRef: c,\r\n    ...s\r\n  }, o) {\r\n    const l = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.i)(c), { elementProps: i } = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.l)({\r\n      trackRef: l,\r\n      htmlProps: s,\r\n      disableSpeakingIndicator: a,\r\n      onParticipantClick: r\r\n    });\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, style: { position: \"relative\", minHeight: \"160px\" }, ...i }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.ah.Provider, { value: l }, n ?? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.a1)(l) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ne, { trackRef: l }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Xt, { barCount: 7, options: { minHeight: 8 } }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"lk-participant-metadata-item\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Se, { trackRef: l }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(K, null)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(be, { className: \"lk-participant-metadata-item\" })))));\r\n  }\r\n);\r\nfunction ba(t) {\r\n  const [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0), r = (0,_hooks_OJtwh4jO_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(t.room);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    switch (r) {\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Reconnecting:\r\n        a(\r\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(oe, { className: \"lk-spinner\" }), \" Reconnecting\")\r\n        );\r\n        break;\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting:\r\n        a(\r\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(oe, { className: \"lk-spinner\" }), \" Connecting\")\r\n        );\r\n        break;\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected:\r\n        a(/* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, \"Disconnected\"));\r\n        break;\r\n      default:\r\n        a(void 0);\r\n        break;\r\n    }\r\n  }, [r]), n ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement($t, { className: \"lk-toast-connection-state\" }, n) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\r\n}\r\nconst Sa = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n  function({ entry: n, hideName: a = !1, hideTimestamp: r = !1, messageFormatter: c, ...s }, o) {\r\n    var f, w, p, m;\r\n    const l = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => c ? c(n.message) : n.message, [n.message, c]), i = !!n.editTimestamp, u = new Date(n.timestamp), d = typeof navigator < \"u\" ? navigator.language : \"en-US\", g = ((f = n.from) == null ? void 0 : f.name) ?? ((w = n.from) == null ? void 0 : w.identity);\r\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n      \"li\",\r\n      {\r\n        ref: o,\r\n        className: \"lk-chat-entry\",\r\n        title: u.toLocaleTimeString(d, { timeStyle: \"full\" }),\r\n        \"data-lk-message-origin\": (p = n.from) != null && p.isLocal ? \"local\" : \"remote\",\r\n        ...s\r\n      },\r\n      (!r || !a || i) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-meta-data\" }, !a && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"strong\", { className: \"lk-participant-name\" }, g), (!r || i) && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-timestamp\" }, i && \"edited \", u.toLocaleTimeString(d, { timeStyle: \"short\" }))),\r\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-message-body\" }, l),\r\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", { className: \"lk-message-attachements\" }, (m = n.attachedFiles) == null ? void 0 : m.map(\r\n        (v) => v.type.startsWith(\"image/\") && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n          \"img\",\r\n          {\r\n            style: { maxWidth: \"300px\", maxHeight: \"300px\" },\r\n            key: v.name,\r\n            src: URL.createObjectURL(v),\r\n            alt: v.name\r\n          }\r\n        )\r\n      ))\r\n    );\r\n  }\r\n);\r\nfunction Ca(t) {\r\n  return (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.am)(t, (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_3__.an)()).map((n, a) => {\r\n    if (typeof n == \"string\")\r\n      return n;\r\n    {\r\n      const r = n.content.toString(), c = n.type === \"url\" ? /^http(s?):\\/\\//.test(r) ? r : `https://${r}` : `mailto:${r}`;\r\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { className: \"lk-chat-link\", key: a, href: c, target: \"_blank\", rel: \"noreferrer\" }, r);\r\n    }\r\n  });\r\n}\r\n\r\n//# sourceMappingURL=components-BeK2vIib.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy1CZUsydklpYi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUN1RDtBQUMwSjtBQUN0TDtBQUMwRztBQUNvSDtBQUNwUiwyQkFBMkIsNkNBQVk7QUFDdkM7QUFDQSxZQUFZLGlCQUFpQixFQUFFLHNEQUFFO0FBQ2pDLDJCQUEyQixnREFBZSxhQUFhLGNBQWM7QUFDckU7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEMsYUFBYSxlQUFlO0FBQzVCLGNBQWMsc0RBQUU7QUFDaEIsMkJBQTJCLGdEQUFlLFVBQVUsY0FBYztBQUNsRTtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQztBQUNBLFlBQVksaUJBQWlCLEVBQUUsc0RBQUUsR0FBRyxVQUFVO0FBQzlDLDJCQUEyQixnREFBZSxhQUFhLGNBQWM7QUFDckU7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEM7QUFDQSxZQUFZLGlCQUFpQixFQUFFLHNEQUFFO0FBQ2pDLDJCQUEyQixnREFBZSxhQUFhLGNBQWM7QUFDckU7QUFDQSwrQkFBK0IsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlLFdBQVcsdU1BQXVNLG1CQUFtQixnREFBZSxXQUFXLHFHQUFxRyxnQ0FBZ0MsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlLFdBQVcsdU1BQXVNLGdDQUFnQyxnREFBZSxVQUFVLHdGQUF3RixrQkFBa0IsZ0RBQWU7QUFDM2tDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLFVBQVUsZ0ZBQWdGLGtCQUFrQixnREFBZTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWUsUUFBUSwyRkFBMkYsa0JBQWtCLGdEQUFlLFdBQVcsb0VBQW9FLGlDQUFpQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWU7QUFDeGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLFVBQVUsZ0ZBQWdGLGtCQUFrQixnREFBZTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlLFdBQVcscVpBQXFaLG1CQUFtQixnREFBZSxXQUFXLHFEQUFxRCxnQ0FBZ0MsZ0RBQWUsVUFBVSx3RkFBd0Ysa0JBQWtCLGdEQUFlO0FBQ3QyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWUsV0FBVywwQ0FBMEMsZ0NBQWdDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxXQUFXLHFQQUFxUCxtQkFBbUIsZ0RBQWUsV0FBVyxxUEFBcVAsZ0NBQWdDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxXQUFXLHNLQUFzSyxtQkFBbUIsZ0RBQWUsV0FBVyxzS0FBc0ssbUJBQW1CLGdEQUFlLFFBQVEsZUFBZSxrQkFBa0IsZ0RBQWUsV0FBVyx3RkFBd0YsbUJBQW1CLGdEQUFlLFdBQVcsd0ZBQXdGLGlDQUFpQyxnREFBZSxVQUFVLHdGQUF3RixrQkFBa0IsZ0RBQWUsV0FBVyx3RkFBd0YsbUJBQW1CLGdEQUFlLFdBQVcsd0ZBQXdGLG1CQUFtQixnREFBZSxRQUFRLGVBQWUsa0JBQWtCLGdEQUFlLFdBQVcsdUZBQXVGLG1CQUFtQixnREFBZSxXQUFXLHNLQUFzSyxtQkFBbUIsZ0RBQWUsV0FBVyx3RkFBd0YsaUNBQWlDLGdEQUFlLFVBQVUsd0ZBQXdGLGtCQUFrQixnREFBZSxRQUFRLGVBQWUsa0JBQWtCLGdEQUFlLFdBQVcsOFBBQThQLG1CQUFtQixnREFBZSxXQUFXLDhQQUE4UCxpQ0FBaUMsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlO0FBQzVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWUsUUFBUSxzQkFBc0Isa0JBQWtCLGdEQUFlLFdBQVcsNEtBQTRLLG1CQUFtQixnREFBZTtBQUNsYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQWUsVUFBVSxnRkFBZ0Ysa0JBQWtCLGdEQUFlO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnREFBZSxVQUFVLGdGQUFnRixrQkFBa0IsZ0RBQWUsUUFBUSwyRkFBMkYsa0JBQWtCLGdEQUFlLFdBQVcseUVBQXlFLDBCQUEwQiw2Q0FBWTtBQUN4YSxhQUFhLG1CQUFtQjtBQUNoQyxjQUFjLDBEQUFFLE1BQU0sNkJBQTZCLEVBQUUsc0RBQUU7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsZ0RBQWUsQ0FBQyxzREFBRSx3REFBd0QsZ0RBQWUsYUFBYSxjQUFjLGdEQUFnRCxnREFBZSw2QkFBNkIsZ0RBQWU7QUFDMVA7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLHlEQUFFLFFBQVEsOENBQWE7QUFDckM7QUFDQSxvQkFBb0IscURBQUU7QUFDdEIsT0FBTztBQUNQO0FBQ0EsU0FBUyx1RUFBdUUsRUFBRSxzREFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQVc7QUFDZjtBQUNBLEtBQUssUUFBUSw0Q0FBVztBQUN4QjtBQUNBLEtBQUssV0FBVyw0Q0FBVztBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssTUFBTSwwQ0FBUztBQUNwQixZQUFZLHFEQUFDLE1BQU0sY0FBYyxJQUFJLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFlLFNBQVMsY0FBYyxrQ0FBa0MsZ0RBQWU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asc0JBQXNCLGdEQUFlLGFBQWEsc0RBQXNEO0FBQ3hHO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEMsYUFBYSxnQ0FBZ0M7QUFDN0MsY0FBYyx5REFBRSxNQUFNLGlCQUFpQixFQUFFLHNEQUFFLEdBQUcsbUJBQW1CO0FBQ2pFLDJCQUEyQixnREFBZSxhQUFhLGNBQWM7QUFDckU7QUFDQSx3QkFBd0IsNkNBQVk7QUFDcEMsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYyx5REFBRSxNQUFNLGtDQUFrQyxFQUFFLHNEQUFFLEdBQUcsbUJBQW1CLEtBQUssa0NBQWtDLEVBQUUsc0RBQUUsR0FBRyxtQkFBbUIsS0FBSyxpQkFBaUI7QUFDekssa0VBQWtFLGdEQUFlLGFBQWEsd0JBQXdCLGdCQUFnQixzQkFBc0I7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFDO0FBQ1YsaUNBQWlDLGdEQUFlLDZCQUE2QixnREFBZTtBQUM1RixTQUFTLGlEQUFDO0FBQ1YsaUNBQWlDLGdEQUFlLDZCQUE2QixnREFBZTtBQUM1RixTQUFTLGlEQUFDO0FBQ1YsaUNBQWlDLGdEQUFlLDZCQUE2QixnREFBZTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFDO0FBQ1YsNkJBQTZCLGdEQUFlO0FBQzVDLFNBQVMsNkRBQUM7QUFDViw2QkFBNkIsZ0RBQWU7QUFDNUMsU0FBUyw2REFBQztBQUNWLDZCQUE2QixnREFBZTtBQUM1QztBQUNBLDZCQUE2QixnREFBZTtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLDZDQUFZLFlBQVksbUJBQW1CO0FBQ3RFLFVBQVUsNkJBQTZCLEVBQUUsc0RBQUUsY0FBYywyQ0FBVTtBQUNuRSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsR0FBRyw0QkFBNEIsZ0RBQWUsYUFBYSxjQUFjO0FBQ3pFLENBQUMsd0JBQXdCLDZDQUFZO0FBQ3JDLFVBQVUsMkJBQTJCLEVBQUUsc0RBQUUsU0FBUywwQ0FBUyxVQUFVLEdBQUcscURBQUMsTUFBTSxjQUFjLHlCQUF5QjtBQUN0SCx5QkFBeUIsZ0RBQWUsVUFBVSxjQUFjO0FBQ2hFLENBQUMsdUJBQXVCLDZDQUFZO0FBQ3BDLGFBQWEsc0JBQXNCO0FBQ25DLGNBQWMseURBQUUsT0FBTyxnQ0FBZ0MsRUFBRSwwQ0FBUyxPQUFPLDBEQUFFLGFBQWEsdUJBQXVCLEVBQUUsc0RBQUU7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPLDBDQUFTLE9BQU8scURBQUMsTUFBTSw2Q0FBNkM7QUFDaEYsMkJBQTJCLGdEQUFlLFdBQVcsY0FBYztBQUNuRTtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQyxhQUFhLHVDQUF1QztBQUNwRCxZQUFZLDJCQUEyQixFQUFFLHNEQUFFLDRFQUE0RSwwQ0FBUztBQUNoSSxZQUFZLHFEQUFDO0FBQ2I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQixnREFBZSxVQUFVLGtDQUFrQztBQUMxRjtBQUNBLCtCQUErQixnREFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLGdEQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLDJDQUFVLENBQUMseURBQUUsZUFBZSwyQ0FBVSwyQ0FBMkMsMkNBQVUsZ0RBQWdELDJDQUFVLHlDQUF5QywyQ0FBVSxtQkFBbUIseUNBQVEsTUFBTSxpQ0FBaUMsRUFBRSwwQ0FBUyxPQUFPLHlEQUFFO0FBQy9TO0FBQ0E7QUFDQSxJQUFJLDBEQUFDO0FBQ0w7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsTUFBTSxxREFBQztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUcsUUFBUSw0Q0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLDRDQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyS0FBMkssc0RBQUMsZ0JBQWdCLHNEQUFDLElBQUksc0RBQUMsc0JBQXNCLHNEQUFDO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMERBQUU7QUFDN0I7QUFDQSxZQUFZLDZDQUFDO0FBQ2IsaUJBQWlCLGdEQUFDO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFDO0FBQ2I7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDhDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxTQUFTLGdEQUFDO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZFQUE2RSwrQ0FBQyxTQUFTLDZDQUFDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQSxpQkFBaUIsK0NBQUMsaUJBQWlCLCtDQUFDO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHLFFBQVEsNkNBQUM7QUFDWjtBQUNBO0FBQ0EsRUFBRSxnREFBQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0MsU0FBUztBQUNULE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQUM7QUFDYixFQUFFLGdEQUFDO0FBQ0g7QUFDQSw4SEFBOEgsa0NBQWtDO0FBQ2hLLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLHlEQUFDLFNBQVMseUNBQVE7QUFDaEMsSUFBSSxzREFBcUI7QUFDekIsbUJBQW1CLGlCQUFpQjtBQUNwQyxJQUFJLDRDQUFXO0FBQ2Ysb0NBQW9DLGtFQUFDO0FBQ3JDLEtBQUssY0FBYyw0Q0FBVztBQUM5QixvQ0FBb0Msa0VBQUM7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBVztBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMENBQTBDLDJEQUEyRDtBQUNyRztBQUNBLDJCQUEyQixnREFBZSxZQUFZLHFDQUFxQztBQUMzRjtBQUNBLHdCQUF3Qiw2Q0FBWTtBQUNwQyxhQUFhLDhEQUE4RDtBQUMzRSxjQUFjLHlEQUFDLFNBQVMseUNBQVE7QUFDaEMsSUFBSSxzREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsNENBQVc7QUFDdEI7QUFDQSxLQUFLLFdBQVcsNENBQVc7QUFDM0Isb0RBQW9ELDREQUFFLG9CQUFvQixxREFBQztBQUMzRSxLQUFLLFdBQVcsNENBQVc7QUFDM0IsMERBQTBELGtFQUFDLDRCQUE0QixxREFBQztBQUN4RixLQUFLLG9DQUFvQyxnREFBZSxZQUFZLGNBQWM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBRTtBQUNoQiwrQ0FBK0MsZ0RBQWUsQ0FBQyxzREFBRSxhQUFhLHNCQUFzQixnQ0FBZ0MsZ0RBQWUsQ0FBQywyQ0FBVTtBQUM5SjtBQUNBO0FBQ0EsY0FBYywwREFBRTtBQUNoQiw0Q0FBNEMsZ0RBQWUsQ0FBQyxzREFBRSxhQUFhLG1CQUFtQixnQ0FBZ0MsZ0RBQWUsQ0FBQywyQ0FBVTtBQUN4SjtBQUNBLDJCQUEyQiw2Q0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLHlEQUFDLE9BQU8sa0JBQWtCLEVBQUUsc0RBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sc0RBQUUscUJBQXFCLHlEQUFFLGFBQWEsMERBQUUsK0NBQStDLDhDQUFhO0FBQ2hIO0FBQ0EsaURBQWlELHlEQUFFLHFDQUFxQyxrQkFBa0I7QUFDMUcsT0FBTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsZ0RBQWUsVUFBVSxpQkFBaUIsc0JBQXNCLFFBQVEsa0JBQWtCLGdEQUFlLE9BQU8sYUFBYSxrQkFBa0IsZ0RBQWUsT0FBTyw0QkFBNEIsdUJBQXVCLGdEQUFlLENBQUMsMkNBQVUsUUFBUSwwREFBQyxvRkFBb0YsaURBQUMsK0JBQStCLGlEQUFDLHVDQUF1QyxnREFBZTtBQUNqYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFDLHVCQUF1QixnREFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFlLFVBQVUseUNBQXlDLGtCQUFrQixnREFBZSw2QkFBNkIsZ0RBQWUsVUFBVSxzQ0FBc0Msa0JBQWtCLGdEQUFlLFVBQVUsMkNBQTJDLGVBQWUsaURBQUMsaUNBQWlDLGdEQUFlLENBQUMsMkNBQVUsNkJBQTZCLGdEQUFlLE9BQU8sU0FBUywwQkFBMEIsbUJBQW1CLGdEQUFlO0FBQy9lO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFDO0FBQ25CLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFlLDZCQUE2QixnREFBZSxDQUFDLDJDQUFVLHdCQUF3QixnREFBZSxPQUFPLFNBQVMsMEJBQTBCLG1CQUFtQixnREFBZSwwQ0FBMEMsZ0RBQWUsT0FBTywyQ0FBMkMscUJBQXFCLGdEQUFlLE9BQU8sYUFBYTtBQUNuWDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFDLE1BQU0sOEJBQThCO0FBQ2pELHlCQUF5QixnREFBZSxVQUFVLE1BQU07QUFDeEQ7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQyx5QkFBeUIsZ0RBQWUsT0FBTyxtQkFBbUI7QUFDbEU7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQix5QkFBeUIsZ0RBQWUsQ0FBQywyQ0FBVSxxQ0FBcUMsZ0RBQWU7QUFDdkcsSUFBSSxzREFBRTtBQUNOO0FBQ0E7QUFDQSxXQUFXLHlEQUFFO0FBQ2IsS0FBSztBQUNMLElBQUkscURBQUU7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQiwyQ0FBVTtBQUMzQixTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EscUJBQXFCLDBEQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0IsZ0RBQWUsVUFBVSxtRUFBbUUsa0JBQWtCLGdEQUFlLGFBQWEsb0NBQW9DLGtCQUFrQixnREFBZSw2QkFBNkIsZ0RBQWUsV0FBVyxrQ0FBa0MsS0FBSyxHQUFHLEtBQUssRUFBRSxvQkFBb0IsZ0RBQWUsYUFBYSxvQ0FBb0Msa0JBQWtCLGdEQUFlO0FBQ3ZjO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDLGFBQWEsbUNBQW1DO0FBQ2hELGdGQUFnRixnREFBZSxXQUFXLDhCQUE4QixvQkFBb0IsZ0RBQWUsV0FBVyxRQUFRO0FBQzlMLDJCQUEyQixnREFBZSxVQUFVLDhDQUE4QztBQUNsRztBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsWUFBWSw0Q0FBVyxRQUFRLDBDQUFTO0FBQ3hDLFVBQVUscURBQUMsTUFBTSw2QkFBNkI7QUFDOUM7QUFDQSxPQUFPLFlBQVksRUFBRSxzREFBRSxtQkFBbUIsc0RBQUU7QUFDNUMsU0FBUyxzREFBRTtBQUNYO0FBQ0E7QUFDQSxHQUFHLG1CQUFtQixnREFBZSxVQUFVLDBEQUEwRCxrQkFBa0IsZ0RBQWUsT0FBTyxrQkFBa0Isd0RBQXdELGdEQUFlLENBQUMsMkNBQVUsd0JBQXdCLGdEQUFlO0FBQzVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQWUsT0FBTyx5QkFBeUI7QUFDcEU7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DLFlBQVkseUNBQVEsaUJBQWlCLDJDQUFVLE9BQU8sc0JBQXNCLEVBQUUsc0RBQUUsNEhBQTRILDBEQUFFO0FBQzlNO0FBQ0E7QUFDQSxZQUFZLHNEQUFFO0FBQ2QsU0FBUyxrREFBaUI7QUFDMUI7QUFDQSxHQUFHLDJCQUEyQixnREFBZSxZQUFZLGdEQUFnRCxrQkFBa0IsZ0RBQWUsT0FBTyxXQUFXO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLDBEQUFFO0FBQ2QsU0FBUyw0Q0FBVztBQUNwQixJQUFJLHFEQUFDLDZCQUE2QixvQkFBb0I7QUFDdEQsR0FBRyxxQkFBcUIsNENBQVc7QUFDbkMsSUFBSSxxREFBQywyQkFBMkIsNkJBQTZCO0FBQzdELEdBQUcsd0NBQXdDLGdEQUFlLENBQUMsc0RBQUUsYUFBYSxVQUFVO0FBQ3BGO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDLGFBQWEsbUJBQW1CO0FBQ2hDLGNBQWMseURBQUMsU0FBUyxzREFBRSxNQUFNLHVCQUF1QjtBQUN2RCwyQkFBMkIsZ0RBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IsZ0RBQWUsV0FBVywrQ0FBK0M7QUFDL0Ysc0JBQXNCLGdEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGdEQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMseUJBQXlCLGdEQUFlLENBQUMsMkNBQVUscUNBQXFDLGdEQUFlLENBQUMsc0RBQUUsYUFBYSwyQkFBMkIsRUFBRSxxREFBRTtBQUN0SjtBQUNBLGNBQWMscUJBQXFCO0FBQ25DLFlBQVksc0RBQUU7QUFDZCxLQUFLLGlEQUFDLG9CQUFvQixpREFBQywwQkFBMEIsaURBQUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaURBQUM7QUFDcEUseUJBQXlCLGdEQUFlLFVBQVUsU0FBUyxtQkFBbUIsK0JBQStCLGdEQUFlO0FBQzVIO0FBQ0E7QUFDQSxXQUFXLHlEQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFZLFlBQVksbURBQW1EO0FBQ3RHLFVBQVUsVUFBVSxFQUFFLHNEQUFFO0FBQ3hCLHlCQUF5QixnREFBZSxXQUFXLGNBQWM7QUFDakUsQ0FBQztBQUNEO0FBQ0EsWUFBWSwwQ0FBUyxPQUFPLHFEQUFDLE1BQU0sdUJBQXVCO0FBQzFELHlCQUF5QixnREFBZSxVQUFVLE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsK0NBQUMsY0FBYywrQ0FBQztBQUNqQyxFQUFFLGdEQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSCxZQUFZLDZDQUFDO0FBQ2IsU0FBUyxnREFBQztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qiw2Q0FBWTtBQUNwQyxhQUFhLHdFQUF3RTtBQUNyRixjQUFjLHFEQUFDLE1BQU0sc0NBQXNDO0FBQzNELFlBQVksMERBQUU7QUFDZDtBQUNBLGNBQWMsc0RBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFlLFVBQVUscUNBQXFDO0FBQ3pGLG9CQUFvQixxREFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVyxzQ0FBc0M7QUFDbEUsT0FBTyxvQkFBb0IsZ0RBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQ0FBa0M7QUFDdkU7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQ7QUFDdkYsdUJBQXVCLHNDQUFzQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLHlEQUFDLE9BQU8sa0JBQWtCLEVBQUUsc0RBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLGdEQUFlLFVBQVUsaUJBQWlCLDBDQUEwQyxRQUFRLGtCQUFrQixnREFBZSxDQUFDLHNEQUFFLGFBQWEsVUFBVSx1QkFBdUIsZ0RBQWUsQ0FBQywyQ0FBVSxRQUFRLDBEQUFDLHVCQUF1QixnREFBZSxPQUFPLGFBQWEsbUJBQW1CLGdEQUFlLE9BQU8sd0JBQXdCLGdCQUFnQixtQkFBbUIsZ0RBQWUsVUFBVSxzQ0FBc0Msa0JBQWtCLGdEQUFlLFVBQVUsMkNBQTJDLGtCQUFrQixnREFBZSxPQUFPLGFBQWEsbUJBQW1CLGdEQUFlLDRCQUE0QixnREFBZSxPQUFPLDJDQUEyQztBQUNudEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVLGNBQWMsc0RBQUU7QUFDM0MsU0FBUyw0Q0FBVztBQUNwQjtBQUNBLFdBQVcsMkRBQUM7QUFDWjtBQUNBLDBCQUEwQixnREFBZSxDQUFDLDJDQUFVLHdCQUF3QixnREFBZSxPQUFPLHlCQUF5QjtBQUMzSDtBQUNBO0FBQ0EsV0FBVywyREFBQztBQUNaO0FBQ0EsMEJBQTBCLGdEQUFlLENBQUMsMkNBQVUsd0JBQXdCLGdEQUFlLE9BQU8seUJBQXlCO0FBQzNIO0FBQ0E7QUFDQSxXQUFXLDJEQUFDO0FBQ1osMEJBQTBCLGdEQUFlLENBQUMsMkNBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLGdEQUFlLE9BQU8sd0NBQXdDLHVCQUF1QixnREFBZSxDQUFDLDJDQUFVO0FBQzlJO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDLGFBQWEsOEVBQThFO0FBQzNGO0FBQ0EsY0FBYywwQ0FBUztBQUN2QiwyQkFBMkIsZ0RBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUNBQXlDLGdEQUFlLFdBQVcsMkJBQTJCLHdCQUF3QixnREFBZSxhQUFhLGtDQUFrQyxtQ0FBbUMsZ0RBQWUsV0FBVywyQkFBMkIsNENBQTRDLG9CQUFvQjtBQUM1VSxzQkFBc0IsZ0RBQWUsV0FBVyw4QkFBOEI7QUFDOUUsc0JBQXNCLGdEQUFlLFdBQVcsc0NBQXNDO0FBQ3RGLDhEQUE4RCxnREFBZTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQUUsSUFBSSwwREFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsRUFBRSxjQUFjLEVBQUU7QUFDekgsNkJBQTZCLGdEQUFlLFFBQVEsaUZBQWlGO0FBQ3JJO0FBQ0EsR0FBRztBQUNIO0FBdURFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGxpdmVraXRcXGNvbXBvbmVudHMtcmVhY3RcXGRpc3RcXGNvbXBvbmVudHMtQmVLMnZJaWIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGUgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIGFzIEIsIHVzZVJlZiBhcyBMLCB1c2VFZmZlY3QgYXMgeiwgdXNlTWVtbyBhcyBMZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1IGFzIHplLCBhIGFzIGhlLCBiIGFzIFZlLCBjIGFzIEZlLCBkIGFzIFplLCBlIGFzIEhlLCBmIGFzIGdlLCBnIGFzIEJlLCBoIGFzIGplLCBpIGFzIF9lLCBqIGFzIE9lLCBrIGFzIFdlLCBsIGFzIHZlLCBtIGFzIHFlLCBuIGFzICRlLCBvIGFzIERlLCBwIGFzIFVlLCBxIGFzIEdlLCByIGFzIFFlLCBzIGFzIEVlLCB0IGFzIFhlLCB2IGFzIFllIH0gZnJvbSBcIi4vaG9va3MtT0p0d2g0ak8ubWpzXCI7XHJcbmltcG9ydCB7IGEgYXMgUywgYyBhcyBlZSB9IGZyb20gXCIuL3Jvb20tODg5Y09iTGIubWpzXCI7XHJcbmltcG9ydCB7IFJvb21FdmVudCBhcyBKZSwgVHJhY2sgYXMgeSwgQ29ubmVjdGlvblF1YWxpdHkgYXMgUSwgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBhcyBKLCBSZW1vdGVBdWRpb1RyYWNrIGFzIEtlLCBDb25uZWN0aW9uU3RhdGUgYXMgWCB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xyXG5pbXBvcnQgeyBhYiBhcyB0ZSwgYWMgYXMgcGUsIHcgYXMgZXQsIGYgYXMgd2UsIGMgYXMgdHQsIGFkIGFzIGF0LCBYIGFzIG50LCBZIGFzIHJ0LCBhMSBhcyAkLCBsIGFzIGosIGFlIGFzIHEsIGFmIGFzIGN0LCBpIGFzIF8sIEIgYXMgbHQsIGFnIGFzIGtlLCBhaCBhcyBhZSwgaiBhcyBzdCwgYWkgYXMgaXQsIG0gYXMgb3QsIHAgYXMgUmUsIGFqIGFzIHV0LCBhayBhcyBkdCwgYWwgYXMgbXQsIGFtIGFzIGZ0LCBhbiBhcyBodCB9IGZyb20gXCIuL2NvbnRleHRzLUNtMWFTQlRzLm1qc1wiO1xyXG5jb25zdCBhYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24obiwgYSkge1xyXG4gICAgY29uc3QgeyBidXR0b25Qcm9wczogciB9ID0gemUobik7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYSwgLi4uciB9LCBuLmNoaWxkcmVuKTtcclxuICB9XHJcbiksIG5hID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcclxuICBmdW5jdGlvbih7IHJvb206IG4sIC4uLmEgfSwgcikge1xyXG4gICAgY29uc3QgYyA9IGhlKG4pO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHIsIC4uLmEgfSwgYyk7XHJcbiAgfVxyXG4pLCByYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24obiwgYSkge1xyXG4gICAgY29uc3QgeyBtZXJnZWRQcm9wczogciB9ID0gVmUoeyBwcm9wczogbiB9KTtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcmVmOiBhLCAuLi5yIH0sIG4uY2hpbGRyZW4pO1xyXG4gIH1cclxuKSwgY2EgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxyXG4gIGZ1bmN0aW9uKG4sIGEpIHtcclxuICAgIGNvbnN0IHsgYnV0dG9uUHJvcHM6IHIgfSA9IEZlKG4pO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGEsIC4uLnIgfSwgbi5jaGlsZHJlbik7XHJcbiAgfVxyXG4pLCBndCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMS4zNTQuNjQ2YS41LjUgMCAxIDAtLjcwOC43MDhsMTQgMTRhLjUuNSAwIDAgMCAuNzA4LS43MDhMMTEgMTAuMjkzVjQuNUExLjUgMS41IDAgMCAwIDkuNSAzSDMuNzA3ek0wIDQuNWExLjUgMS41IDAgMCAxIC45NDMtMS4zOTNsOS41MzIgOS41MzNjLS4yNjIuMjI0LS42MDMuMzYtLjk3NS4zNmgtOEExLjUgMS41IDAgMCAxIDAgMTEuNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIm0xNS4yIDMuNi0yLjggMi4xYTEgMSAwIDAgMC0uNC44djNhMSAxIDAgMCAwIC40LjhsMi44IDIuMWEuNS41IDAgMCAwIC44LS40VjRhLjUuNSAwIDAgMC0uOC0uNHpcIiB9KSksIHZ0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDQuNUExLjUgMS41IDAgMCAxIDEuNSAzaDhBMS41IDEuNSAwIDAgMSAxMSA0LjV2N0ExLjUgMS41IDAgMCAxIDkuNSAxM2gtOEExLjUgMS41IDAgMCAxIDAgMTEuNXpNMTUuMiAzLjZsLTIuOCAyLjFhMSAxIDAgMCAwLS40Ljh2M2ExIDEgMCAwIDAgLjQuOGwyLjggMi4xYS41LjUgMCAwIDAgLjgtLjRWNGEuNS41IDAgMCAwLS44LS40elwiIH0pKSwgbGEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiI0ZGRlwiLFxyXG4gICAgZDogXCJNNC45OSAzLjk5YTEgMSAwIDAgMC0uNjk3IDEuNzE3TDEwLjU4NiAxMmwtNi4yOTMgNi4yOTNhMSAxIDAgMSAwIDEuNDE0IDEuNDE0TDEyIDEzLjQxNGw2LjI5MyA2LjI5M2ExIDEgMCAxIDAgMS40MTQtMS40MTRMMTMuNDE0IDEybDYuMjkzLTYuMjkzYTEgMSAwIDAgMC0uNzI3LTEuNzE3IDEgMSAwIDAgMC0uNjg3LjMwM0wxMiAxMC41ODYgNS43MDcgNC4yOTNhMSAxIDAgMCAwLS43MTctLjMwM3pcIlxyXG4gIH1cclxuKSksIHNhID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTgsIGZpbGw6IFwibm9uZVwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcclxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIGQ6IFwiTTAgMi43NUEyLjc1IDIuNzUgMCAwIDEgMi43NSAwaDEwLjVBMi43NSAyLjc1IDAgMCAxIDE2IDIuNzV2MTMuNTk0YS43NS43NSAwIDAgMS0xLjIzNC41NzJsLTMuNjkxLTMuMTJhMS4yNSAxLjI1IDAgMCAwLS44MDctLjI5NkgyLjc1QTIuNzUgMi43NSAwIDAgMSAwIDEwLjc1di04Wk0yLjc1IDEuNWMtLjY5IDAtMS4yNS41Ni0xLjI1IDEuMjV2OGMwIC42OS41NiAxLjI1IDEuMjUgMS4yNWg3LjUxOGMuNjUgMCAxLjI3OS4yMyAxLjc3NS42NWwyLjQ1NyAyLjA3N1YyLjc1YzAtLjY5LS41Ni0xLjI1LTEuMjUtMS4yNUgyLjc1WlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk0zIDQuNWEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlhLjUuNSAwIDAgMS0uNS0uNVptMCAyYS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOWEuNS41IDAgMCAxLS41LS41Wm0wIDJhLjUuNSAwIDAgMSAuNS0uNWg1YS41LjUgMCAwIDEgMCAxaC01YS41LjUgMCAwIDEtLjUtLjVaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcclxuICB9XHJcbikpLCBpZSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk01LjI5MyAyLjI5M2ExIDEgMCAwIDEgMS40MTQgMGw0LjgyMyA0LjgyM2ExLjI1IDEuMjUgMCAwIDEgMCAxLjc2OGwtNC44MjMgNC44MjNhMSAxIDAgMCAxLTEuNDE0LTEuNDE0TDkuNTg2IDggNS4yOTMgMy43MDdhMSAxIDAgMCAxIDAtMS40MTR6XCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcclxuICB9XHJcbikpLCBFdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBzdHJva2VXaWR0aDogMS41IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTAgMS43NWg0LjI1bTAgMFY2bTAtNC4yNUw5IDdNNiAxNC4yNUgxLjc1bTAgMFYxMG0wIDQuMjVMNyA5XCIgfSkpKSwgaWEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRjb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNOC45NjEuODk0QzguODc1LS4yOTggNy4xMjUtLjI5OCA3LjA0Ljg5NGMtLjA2Ni45MTItMS4yNDYgMS4yMjgtMS43Ni40NzItLjY3LS45OS0yLjE4Ni0uMTE1LTEuNjY0Ljk2LjM5OS44MjQtLjQ2NSAxLjY4OC0xLjI4OCAxLjI4OS0xLjA3Ni0uNTIyLTEuOTUuOTk0LS45NjEgMS42NjUuNzU2LjUxMy40NCAxLjY5My0uNDcyIDEuNzU5LTEuMTkyLjA4Ni0xLjE5MiAxLjgzNiAwIDEuOTIyLjkxMi4wNjYgMS4yMjggMS4yNDYuNDcyIDEuNzYtLjk5LjY3LS4xMTUgMi4xODYuOTYgMS42NjQuODI0LS4zOTkgMS42ODguNDY1IDEuMjg5IDEuMjg4LS41MjIgMS4wNzYuOTk0IDEuOTUgMS42NjUuOTYxLjUxMy0uNzU2IDEuNjkzLS40NCAxLjc1OS40NzIuMDg2IDEuMTkyIDEuODM2IDEuMTkyIDEuOTIyIDAgLjA2Ni0uOTEyIDEuMjQ2LTEuMjI4IDEuNzYtLjQ3Mi42Ny45OSAyLjE4Ni4xMTUgMS42NjQtLjk2LS4zOTktLjgyNC40NjUtMS42ODggMS4yODgtMS4yODkgMS4wNzYuNTIyIDEuOTUtLjk5NC45NjEtMS42NjUtLjc1Ni0uNTEzLS40NC0xLjY5My40NzItMS43NTkgMS4xOTItLjA4NiAxLjE5Mi0xLjgzNiAwLTEuOTIyLS45MTItLjA2Ni0xLjIyOC0xLjI0Ni0uNDcyLTEuNzYuOTktLjY3LjExNS0yLjE4Ni0uOTYtMS42NjQtLjgyNC4zOTktMS42ODgtLjQ2NS0xLjI4OS0xLjI4OC41MjItMS4wNzYtLjk5NC0xLjk1LTEuNjY1LS45NjEtLjUxMy43NTYtMS42OTMuNDQtMS43NTktLjQ3MlpNOCAxM0E1IDUgMCAxIDAgOCAzYTUgNSAwIDAgMCAwIDEwWlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pKSwgb2EgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNMiAyLjc1QTIuNzUgMi43NSAwIDAgMSA0Ljc1IDBoNi41QTIuNzUgMi43NSAwIDAgMSAxNCAyLjc1djEwLjVBMi43NSAyLjc1IDAgMCAxIDExLjI1IDE2aC02LjVBMi43NSAyLjc1IDAgMCAxIDIgMTMuMjV2LS41YS43NS43NSAwIDAgMSAxLjUgMHYuNWMwIC42OS41NiAxLjI1IDEuMjUgMS4yNWg2LjVjLjY5IDAgMS4yNS0uNTYgMS4yNS0xLjI1VjIuNzVjMC0uNjktLjU2LTEuMjUtMS4yNS0xLjI1aC02LjVjLS42OSAwLTEuMjUuNTYtMS4yNSAxLjI1di41YS43NS43NSAwIDAgMS0xLjUgMHYtLjVaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcclxuICB9XHJcbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcclxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIGQ6IFwiTTguNzggNy40N2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0yLjI1IDIuMjVhLjc1Ljc1IDAgMSAxLTEuMDYtMS4wNmwuOTctLjk3SDEuNzVhLjc1Ljc1IDAgMCAxIDAtMS41aDQuNjlsLS45Ny0uOTdhLjc1Ljc1IDAgMCAxIDEuMDYtMS4wNmwyLjI1IDIuMjVaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcclxuICB9XHJcbikpLCBwdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk00IDYuMTA0VjRhNCA0IDAgMSAxIDggMHYyLjEwNGMxLjE1NC4zMjYgMiAxLjM4NyAyIDIuNjQ2djQuNUEyLjc1IDIuNzUgMCAwIDEgMTEuMjUgMTZoLTYuNUEyLjc1IDIuNzUgMCAwIDEgMiAxMy4yNXYtNC41YzAtMS4yNTkuODQ2LTIuMzIgMi0yLjY0NlpNNS41IDRhMi41IDIuNSAwIDAgMSA1IDB2MmgtNVY0WlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pKSwgd3QgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEyLjIyNyAxMS41MmE1LjQ3NyA1LjQ3NyAwIDAgMCAxLjI0Ni0yLjk3LjUuNSAwIDAgMC0uOTk1LS4xIDQuNDc4IDQuNDc4IDAgMCAxLS45NjIgMi4zNTlsLTEuMDctMS4wN0MxMC43OTQgOS4yNDcgMTEgOC42NDcgMTEgOFYzYTMgMyAwIDAgMC02IDB2MS4yOTNMMS4zNTQuNjQ2YS41LjUgMCAxIDAtLjcwOC43MDhsMTQgMTRhLjUuNSAwIDAgMCAuNzA4LS43MDh6TTggMTIuNWMuNjgzIDAgMS4zMy0uMTUyIDEuOTExLS40MjVsLjc0My43NDNjLS42NDkuMzU5LTEuMzc4LjU5LTIuMTU0LjY2VjE1aDJhLjUuNSAwIDAgMSAwIDFoLTVhLjUuNSAwIDAgMSAwLTFoMnYtMS41MjJhNS41MDIgNS41MDIgMCAwIDEtNC45NzMtNC45MjkuNS41IDAgMCAxIC45OTUtLjA5OEE0LjUgNC41IDAgMCAwIDggMTIuNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk04Ljc0MyAxMC45MDcgNSA3LjE2NFY4YTMgMyAwIDAgMCAzLjc0MyAyLjkwN3pcIiB9KSksIGt0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk0yLjk3NSA4LjAwMmEuNS41IDAgMCAxIC41NDcuNDQ5IDQuNSA0LjUgMCAwIDAgOC45NTYgMCAuNS41IDAgMSAxIC45OTUuMDk4QTUuNTAyIDUuNTAyIDAgMCAxIDguNSAxMy40NzhWMTVoMmEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxIDAtMWgydi0xLjUyMmE1LjUwMiA1LjUwMiAwIDAgMS00Ljk3My00LjkyOS41LjUgMCAwIDEgLjQ0OC0uNTQ3elwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTUgM2EzIDMgMCAxIDEgNiAwdjVhMyAzIDAgMCAxLTYgMHpcIiB9KSksIFJ0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSksIE10ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudGNvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAgMTEuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djRhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6bTYtNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djlhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgb3BhY2l0eTogMC4yNSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEyIC41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTIgLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSkpLCB5dCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcImN1cnJlbnRjb2xvclwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0wIDExLjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY0YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IG9wYWNpdHk6IDAuMjUgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02IDYuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djlhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjV6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2LjVhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXY5YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41em02LTZhLjUuNSAwIDAgMSAuNS0uNWgzYS41LjUgMCAwIDEgLjUuNXYxNWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXpcIiB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMiAuNWEuNS41IDAgMCAxIC41LS41aDNhLjUuNSAwIDAgMSAuNS41djE1YS41LjUgMCAwIDEtLjUuNWgtM2EuNS41IDAgMCAxLS41LS41elwiIH0pKSksIGJ0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGZpbGw6IFwiY3VycmVudENvbG9yXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImdcIiwgeyBvcGFjaXR5OiAwLjI1IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtNFptNi01YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2OWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtOVptNi02YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjVWLjVaXCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMCAxMS41YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2NGEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtNFptNi01YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2OWEuNS41IDAgMCAxLS41LjVoLTNhLjUuNSAwIDAgMS0uNS0uNXYtOVptNi02YS41LjUgMCAwIDEgLjUtLjVoM2EuNS41IDAgMCAxIC41LjV2MTVhLjUuNSAwIDAgMS0uNS41aC0zYS41LjUgMCAwIDEtLjUtLjVWLjVaXCIgfSkpKSwgTWUgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAyMCwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNMCAyLjc1QTIuNzUgMi43NSAwIDAgMSAyLjc1IDBoMTQuNUEyLjc1IDIuNzUgMCAwIDEgMjAgMi43NXYxMC41QTIuNzUgMi43NSAwIDAgMSAxNy4yNSAxNkgyLjc1QTIuNzUgMi43NSAwIDAgMSAwIDEzLjI1VjIuNzVaTTIuNzUgMS41Yy0uNjkgMC0xLjI1LjU2LTEuMjUgMS4yNXYxMC41YzAgLjY5LjU2IDEuMjUgMS4yNSAxLjI1aDE0LjVjLjY5IDAgMS4yNS0uNTYgMS4yNS0xLjI1VjIuNzVjMC0uNjktLjU2LTEuMjUtMS4yNS0xLjI1SDIuNzVaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcclxuICB9XHJcbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcclxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIGQ6IFwiTTkuNDcgNC4yMmEuNzUuNzUgMCAwIDEgMS4wNiAwbDIuMjUgMi4yNWEuNzUuNzUgMCAwIDEtMS4wNiAxLjA2bC0uOTctLjk3djQuNjlhLjc1Ljc1IDAgMCAxLTEuNSAwVjYuNTZsLS45Ny45N2EuNzUuNzUgMCAwIDEtMS4wNi0xLjA2bDIuMjUtMi4yNVpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxyXG4gIH1cclxuKSksIFN0ID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB3aWR0aDogMjAsIGhlaWdodDogMTYsIGZpbGw6IFwibm9uZVwiLCAuLi50IH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgZmlsbDogXCJjdXJyZW50Q29sb3JcIiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTcuMjggNC4yMmEuNzUuNzUgMCAwIDAtMS4wNiAxLjA2TDguOTQgOGwtMi43MiAyLjcyYS43NS43NSAwIDEgMCAxLjA2IDEuMDZMMTAgOS4wNmwyLjcyIDIuNzJhLjc1Ljc1IDAgMSAwIDEuMDYtMS4wNkwxMS4wNiA4bDIuNzItMi43MmEuNzUuNzUgMCAwIDAtMS4wNi0xLjA2TDEwIDYuOTR6XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNMi43NSAwQTIuNzUgMi43NSAwIDAgMCAwIDIuNzV2MTAuNUEyLjc1IDIuNzUgMCAwIDAgMi43NSAxNmgxNC41QTIuNzUgMi43NSAwIDAgMCAyMCAxMy4yNVYyLjc1QTIuNzUgMi43NSAwIDAgMCAxNy4yNSAwek0xLjUgMi43NWMwLS42OS41Ni0xLjI1IDEuMjUtMS4yNWgxNC41Yy42OSAwIDEuMjUuNTYgMS4yNSAxLjI1djEwLjVjMCAuNjktLjU2IDEuMjUtMS4yNSAxLjI1SDIuNzVjLS42OSAwLTEuMjUtLjU2LTEuMjUtMS4yNXpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxyXG4gIH1cclxuKSkpLCBvZSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IDE2LCBoZWlnaHQ6IDE2LCBmaWxsOiBcIm5vbmVcIiwgLi4udCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk04IDBhLjc1Ljc1IDAgMCAxIC43NS43NXYyLjVhLjc1Ljc1IDAgMCAxLTEuNSAwVi43NUEuNzUuNzUgMCAwIDEgOCAwWlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk04IDEyYS43NS43NSAwIDAgMSAuNzUuNzV2Mi41YS43NS43NSAwIDAgMS0xLjUgMHYtMi41QS43NS43NSAwIDAgMSA4IDEyWlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgb3BhY2l0eTogMC43XHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk0xMiAxLjA3MmEuNzUuNzUgMCAwIDEgLjI3NCAxLjAyNGwtMS4yNSAyLjE2NWEuNzUuNzUgMCAwIDEtMS4yOTktLjc1bDEuMjUtMi4xNjVBLjc1Ljc1IDAgMCAxIDEyIDEuMDcyWlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk02IDExLjQ2NGEuNzUuNzUgMCAwIDEgLjI3NCAxLjAyNWwtMS4yNSAyLjE2NWEuNzUuNzUgMCAwIDEtMS4yOTktLjc1bDEuMjUtMi4xNjVBLjc1Ljc1IDAgMCAxIDYgMTEuNDY0WlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgb3BhY2l0eTogMC42XHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk0xNC45MjggNGEuNzUuNzUgMCAwIDEtLjI3NCAxLjAyNWwtMi4xNjUgMS4yNWEuNzUuNzUgMCAxIDEtLjc1LTEuM2wyLjE2NS0xLjI1QS43NS43NSAwIDAgMSAxNC45MjggNFpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxyXG4gIH1cclxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNNC41MzYgMTBhLjc1Ljc1IDAgMCAxLS4yNzUgMS4wMjRsLTIuMTY1IDEuMjVhLjc1Ljc1IDAgMCAxLS43NS0xLjI5OGwyLjE2NS0xLjI1QS43NS43NSAwIDAgMSA0LjUzNiAxMFpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIG9wYWNpdHk6IDAuNVxyXG4gIH1cclxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNMTYgOGEuNzUuNzUgMCAwIDEtLjc1Ljc1aC0yLjVhLjc1Ljc1IDAgMCAxIDAtMS41aDIuNUEuNzUuNzUgMCAwIDEgMTYgOFpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxyXG4gIH1cclxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNNCA4YS43NS43NSAwIDAgMS0uNzUuNzVILjc1YS43NS43NSAwIDAgMSAwLTEuNWgyLjVBLjc1Ljc1IDAgMCAxIDQgOFpcIixcclxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIG9wYWNpdHk6IDAuNFxyXG4gIH1cclxuKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICBcInBhdGhcIixcclxuICB7XHJcbiAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxyXG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgZDogXCJNMTQuOTI4IDEyYS43NS43NSAwIDAgMS0xLjAyNC4yNzRsLTIuMTY1LTEuMjVhLjc1Ljc1IDAgMCAxIC43NS0xLjI5OWwyLjE2NSAxLjI1QS43NS43NSAwIDAgMSAxNC45MjggMTJaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBvcGFjaXR5OiAwLjlcclxuICB9XHJcbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcclxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIGQ6IFwiTTQuNTM2IDZhLjc1Ljc1IDAgMCAxLTEuMDI1LjI3NWwtMi4xNjUtMS4yNWEuNzUuNzUgMCAxIDEgLjc1LTEuM2wyLjE2NSAxLjI1QS43NS43NSAwIDAgMSA0LjUzNiA2WlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgb3BhY2l0eTogMC4zXHJcbiAgfVxyXG4pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwicGF0aFwiLFxyXG4gIHtcclxuICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXHJcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBkOiBcIk0xMiAxNC45MjhhLjc1Ljc1IDAgMCAxLTEuMDI0LS4yNzRsLTEuMjUtMi4xNjVhLjc1Ljc1IDAgMCAxIDEuMjk4LS43NWwxLjI1IDIuMTY1QS43NS43NSAwIDAgMSAxMiAxNC45MjhaXCIsXHJcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXHJcbiAgICBvcGFjaXR5OiAwLjhcclxuICB9XHJcbiksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgXCJwYXRoXCIsXHJcbiAge1xyXG4gICAgZmlsbDogXCJjdXJyZW50Q29sb3JcIixcclxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcclxuICAgIGQ6IFwiTTYgNC41MzZhLjc1Ljc1IDAgMCAxLTEuMDI0LS4yNzVsLTEuMjUtMi4xNjVhLjc1Ljc1IDAgMSAxIDEuMjk5LS43NWwxLjI1IDIuMTY1QS43NS43NSAwIDAgMSA2IDQuNTM2WlwiLFxyXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxyXG4gICAgb3BhY2l0eTogMC4yXHJcbiAgfVxyXG4pKSwgQ3QgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHdpZHRoOiAxNiwgaGVpZ2h0OiAxNiwgZmlsbDogXCJub25lXCIsIC4uLnQgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImdcIiwgeyBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgc3Ryb2tlV2lkdGg6IDEuNSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEzLjI1IDdIOW0wIDBWMi43NU05IDdsNS4yNS01LjI1TTIuNzUgOUg3bTAgMHY0LjI1TTcgOWwtNS4yNSA1LjI1XCIgfSkpKSwgSXQgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxyXG4gIGZ1bmN0aW9uKHsgdHJhY2tSZWY6IG4sIC4uLmEgfSwgcikge1xyXG4gICAgY29uc3QgYyA9IHRlKCksIHsgbWVyZ2VkUHJvcHM6IHMsIGluRm9jdXM6IG8gfSA9IFplKHtcclxuICAgICAgdHJhY2tSZWY6IG4gPz8gYyxcclxuICAgICAgcHJvcHM6IGFcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQocGUuQ29uc3VtZXIsIG51bGwsIChsKSA9PiBsICE9PSB2b2lkIDAgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogciwgLi4ucyB9LCBhLmNoaWxkcmVuID8gYS5jaGlsZHJlbiA6IG8gPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEN0LCBudWxsKSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoRXQsIG51bGwpKSk7XHJcbiAgfVxyXG4pLCB1YSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oe1xyXG4gICAga2luZDogbixcclxuICAgIGluaXRpYWxTZWxlY3Rpb246IGEsXHJcbiAgICBvbkFjdGl2ZURldmljZUNoYW5nZTogcixcclxuICAgIG9uRGV2aWNlTGlzdENoYW5nZTogYyxcclxuICAgIG9uRGV2aWNlU2VsZWN0RXJyb3I6IHMsXHJcbiAgICBleGFjdE1hdGNoOiBvLFxyXG4gICAgdHJhY2s6IGwsXHJcbiAgICByZXF1ZXN0UGVybWlzc2lvbnM6IGksXHJcbiAgICBvbkVycm9yOiB1LFxyXG4gICAgLi4uZFxyXG4gIH0sIGcpIHtcclxuICAgIGNvbnN0IGYgPSBldCgpLCB3ID0gZS51c2VDYWxsYmFjayhcclxuICAgICAgKEUpID0+IHtcclxuICAgICAgICBmICYmIGYuZW1pdChKZS5NZWRpYURldmljZXNFcnJvciwgRSksIHUgPT0gbnVsbCB8fCB1KEUpO1xyXG4gICAgICB9LFxyXG4gICAgICBbZiwgdV1cclxuICAgICksIHsgZGV2aWNlczogcCwgYWN0aXZlRGV2aWNlSWQ6IG0sIHNldEFjdGl2ZU1lZGlhRGV2aWNlOiB2LCBjbGFzc05hbWU6IGIgfSA9IEhlKHtcclxuICAgICAga2luZDogbixcclxuICAgICAgcm9vbTogZixcclxuICAgICAgdHJhY2s6IGwsXHJcbiAgICAgIHJlcXVlc3RQZXJtaXNzaW9uczogaSxcclxuICAgICAgb25FcnJvcjogd1xyXG4gICAgfSk7XHJcbiAgICBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIGEgIT09IHZvaWQgMCAmJiB2KGEpO1xyXG4gICAgfSwgW3ZdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgJiYgYyhwKTtcclxuICAgIH0sIFtjLCBwXSksIGUudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgbSAmJiBtICE9PSBcIlwiICYmIChyID09IG51bGwgfHwgcihtKSk7XHJcbiAgICB9LCBbbV0pO1xyXG4gICAgY29uc3QgQyA9IGFzeW5jIChFKSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgdihFLCB7IGV4YWN0OiBvID8/ICEwIH0pO1xyXG4gICAgICB9IGNhdGNoIChrKSB7XHJcbiAgICAgICAgaWYgKGsgaW5zdGFuY2VvZiBFcnJvcilcclxuICAgICAgICAgIHMgPT0gbnVsbCB8fCBzKGspO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93IGs7XHJcbiAgICAgIH1cclxuICAgIH0sIFQgPSBlLnVzZU1lbW8oXHJcbiAgICAgICgpID0+IFMoZCwgeyBjbGFzc05hbWU6IGIgfSwgeyBjbGFzc05hbWU6IFwibGstbGlzdFwiIH0pLFxyXG4gICAgICBbYiwgZF1cclxuICAgICksIEEgPSAhIXAuZmluZCgoRSkgPT4gRS5sYWJlbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJkZWZhdWx0XCIpKTtcclxuICAgIGZ1bmN0aW9uIGgoRSwgaywgSSkge1xyXG4gICAgICByZXR1cm4gRSA9PT0gayB8fCAhQSAmJiBJID09PSAwICYmIGsgPT09IFwiZGVmYXVsdFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IHJlZjogZywgLi4uVCB9LCBwLm1hcCgoRSwgaykgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgICAgXCJsaVwiLFxyXG4gICAgICB7XHJcbiAgICAgICAga2V5OiBFLmRldmljZUlkLFxyXG4gICAgICAgIGlkOiBFLmRldmljZUlkLFxyXG4gICAgICAgIFwiZGF0YS1say1hY3RpdmVcIjogaChFLmRldmljZUlkLCBtLCBrKSxcclxuICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogaChFLmRldmljZUlkLCBtLCBrKSxcclxuICAgICAgICByb2xlOiBcIm9wdGlvblwiXHJcbiAgICAgIH0sXHJcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwibGstYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IEMoRS5kZXZpY2VJZCkgfSwgRS5sYWJlbClcclxuICAgICkpKTtcclxuICB9XHJcbiksIGRhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcclxuICBmdW5jdGlvbih7IGxhYmVsOiBuID0gXCJBbGxvdyBBdWRpb1wiLCAuLi5hIH0sIHIpIHtcclxuICAgIGNvbnN0IGMgPSB3ZSgpLCB7IG1lcmdlZFByb3BzOiBzIH0gPSBnZSh7IHJvb206IGMsIHByb3BzOiBhIH0pO1xyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IHIsIC4uLnMgfSwgbik7XHJcbiAgfVxyXG4pLCBtYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oeyBsYWJlbDogbiwgLi4uYSB9LCByKSB7XHJcbiAgICBjb25zdCBjID0gd2UoKSwgeyBtZXJnZWRQcm9wczogcywgY2FuUGxheUF1ZGlvOiBvIH0gPSBnZSh7IHJvb206IGMsIHByb3BzOiBhIH0pLCB7IG1lcmdlZFByb3BzOiBsLCBjYW5QbGF5VmlkZW86IGkgfSA9IEJlKHsgcm9vbTogYywgcHJvcHM6IHMgfSksIHsgc3R5bGU6IHUsIC4uLmQgfSA9IGw7XHJcbiAgICByZXR1cm4gdS5kaXNwbGF5ID0gbyAmJiBpID8gXCJub25lXCIgOiBcImJsb2NrXCIsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IHIsIHN0eWxlOiB1LCAuLi5kIH0sIG4gPz8gYFN0YXJ0ICR7byA/IFwiVmlkZW9cIiA6IFwiQXVkaW9cIn1gKTtcclxuICB9XHJcbik7XHJcbmZ1bmN0aW9uIHllKHQsIG4pIHtcclxuICBzd2l0Y2ggKHQpIHtcclxuICAgIGNhc2UgeS5Tb3VyY2UuTWljcm9waG9uZTpcclxuICAgICAgcmV0dXJuIG4gPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGt0LCBudWxsKSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQod3QsIG51bGwpO1xyXG4gICAgY2FzZSB5LlNvdXJjZS5DYW1lcmE6XHJcbiAgICAgIHJldHVybiBuID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh2dCwgbnVsbCkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGd0LCBudWxsKTtcclxuICAgIGNhc2UgeS5Tb3VyY2UuU2NyZWVuU2hhcmU6XHJcbiAgICAgIHJldHVybiBuID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChTdCwgbnVsbCkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE1lLCBudWxsKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybjtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24geHQodCkge1xyXG4gIHN3aXRjaCAodCkge1xyXG4gICAgY2FzZSBRLkV4Y2VsbGVudDpcclxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoUnQsIG51bGwpO1xyXG4gICAgY2FzZSBRLkdvb2Q6XHJcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE10LCBudWxsKTtcclxuICAgIGNhc2UgUS5Qb29yOlxyXG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh5dCwgbnVsbCk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChidCwgbnVsbCk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IGZhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihmdW5jdGlvbih7IHNob3dJY29uOiBuLCAuLi5hIH0sIHIpIHtcclxuICBjb25zdCB7IGJ1dHRvblByb3BzOiBjLCBlbmFibGVkOiBzIH0gPSBqZShhKSwgW28sIGxdID0gZS51c2VTdGF0ZSghMSk7XHJcbiAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGwoITApO1xyXG4gIH0sIFtdKSwgbyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcmVmOiByLCAuLi5jIH0sIChuID8/ICEwKSAmJiB5ZShhLnNvdXJjZSwgcyksIGEuY2hpbGRyZW4pO1xyXG59KSwgYmUgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKGZ1bmN0aW9uKG4sIGEpIHtcclxuICBjb25zdCB7IGNsYXNzTmFtZTogciwgcXVhbGl0eTogYyB9ID0gX2UobiksIHMgPSBlLnVzZU1lbW8oKCkgPT4gKHsgLi4uUyhuLCB7IGNsYXNzTmFtZTogciB9KSwgXCJkYXRhLWxrLXF1YWxpdHlcIjogYyB9KSwgW2MsIG4sIHJdKTtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYSwgLi4ucyB9LCBuLmNoaWxkcmVuID8/IHh0KGMpKTtcclxufSksIEsgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxyXG4gIGZ1bmN0aW9uKHsgcGFydGljaXBhbnQ6IG4sIC4uLmEgfSwgcikge1xyXG4gICAgY29uc3QgYyA9IHR0KG4pLCB7IGNsYXNzTmFtZTogcywgaW5mb09ic2VydmVyOiBvIH0gPSBlLnVzZU1lbW8oKCkgPT4gYXQoYyksIFtjXSksIHsgaWRlbnRpdHk6IGwsIG5hbWU6IGkgfSA9IE9lKG8sIHtcclxuICAgICAgbmFtZTogYy5uYW1lLFxyXG4gICAgICBpZGVudGl0eTogYy5pZGVudGl0eSxcclxuICAgICAgbWV0YWRhdGE6IGMubWV0YWRhdGFcclxuICAgIH0pLCB1ID0gZS51c2VNZW1vKCgpID0+IFMoYSwgeyBjbGFzc05hbWU6IHMsIFwiZGF0YS1say1wYXJ0aWNpcGFudC1uYW1lXCI6IGkgfSksIFthLCBzLCBpXSk7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyByZWY6IHIsIC4uLnUgfSwgaSAhPT0gXCJcIiA/IGkgOiBsLCBhLmNoaWxkcmVuKTtcclxuICB9XHJcbiksIFNlID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcclxuICBmdW5jdGlvbih7IHRyYWNrUmVmOiBuLCBzaG93OiBhID0gXCJhbHdheXNcIiwgLi4uciB9LCBjKSB7XHJcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogcywgaXNNdXRlZDogbyB9ID0gV2UobiksIGwgPSBhID09PSBcImFsd2F5c1wiIHx8IGEgPT09IFwibXV0ZWRcIiAmJiBvIHx8IGEgPT09IFwidW5tdXRlZFwiICYmICFvLCBpID0gZS51c2VNZW1vKFxyXG4gICAgICAoKSA9PiBTKHIsIHtcclxuICAgICAgICBjbGFzc05hbWU6IHNcclxuICAgICAgfSksXHJcbiAgICAgIFtzLCByXVxyXG4gICAgKTtcclxuICAgIHJldHVybiBsID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYywgLi4uaSwgXCJkYXRhLWxrLW11dGVkXCI6IG8gfSwgci5jaGlsZHJlbiA/PyB5ZShuLnNvdXJjZSwgIW8pKSA6IG51bGw7XHJcbiAgfVxyXG4pLCBQdCA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gIFwic3ZnXCIsXHJcbiAge1xyXG4gICAgd2lkdGg6IDMyMCxcclxuICAgIGhlaWdodDogMzIwLFxyXG4gICAgdmlld0JveDogXCIwIDAgMzIwIDMyMFwiLFxyXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZCBtZWV0XCIsXHJcbiAgICBmaWxsOiBcIm5vbmVcIixcclxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXHJcbiAgICAuLi50XHJcbiAgfSxcclxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gICAgXCJwYXRoXCIsXHJcbiAgICB7XHJcbiAgICAgIGQ6IFwiTTE2MCAxODBDMjA0LjE4MiAxODAgMjQwIDE0NC4xODMgMjQwIDEwMEMyNDAgNTUuODE3MiAyMDQuMTgyIDIwIDE2MCAyMEMxMTUuODE3IDIwIDc5Ljk5OTcgNTUuODE3MiA3OS45OTk3IDEwMEM3OS45OTk3IDE0NC4xODMgMTE1LjgxNyAxODAgMTYwIDE4MFpcIixcclxuICAgICAgZmlsbDogXCJ3aGl0ZVwiLFxyXG4gICAgICBmaWxsT3BhY2l0eTogMC4yNVxyXG4gICAgfVxyXG4gICksXHJcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgIFwicGF0aFwiLFxyXG4gICAge1xyXG4gICAgICBkOiBcIk05Ny42NTQyIDE5NC42MTRDMTAzLjI2NyAxOTEuODE4IDEwOS44NDEgMTkyLjQ4MSAxMTUuNTE5IDE5NS4xNDFDMTI5LjAyNSAyMDEuNDY2IDE0NC4xIDIwNSAxNTkuOTk5IDIwNUMxNzUuODk5IDIwNSAxOTAuOTczIDIwMS40NjYgMjA0LjQ4IDE5NS4xNDFDMjEwLjE1OCAxOTIuNDgxIDIxNi43MzIgMTkxLjgxOCAyMjIuMzQ1IDE5NC42MTRDMjYyLjcwMyAyMTQuNzE5IDI5MS45ODUgMjUzLjczNiAyOTguNTkxIDMwMC4wNjJDMzAwLjE1IDMxMC45OTcgMjkxLjA0NSAzMjAgMjgwIDMyMEgzOS45OTk3QzI4Ljk1NCAzMjAgMTkuODQ5NSAzMTAuOTk3IDIxLjQwODcgMzAwLjA2MkMyOC4wMTQgMjUzLjczNiA1Ny4yOTY2IDIxNC43MiA5Ny42NTQyIDE5NC42MTRaXCIsXHJcbiAgICAgIGZpbGw6IFwid2hpdGVcIixcclxuICAgICAgZmlsbE9wYWNpdHk6IDAuMjVcclxuICAgIH1cclxuICApXHJcbik7XHJcbmZ1bmN0aW9uIENlKHQsIG4gPSB7fSkge1xyXG4gIGNvbnN0IFthLCByXSA9IGUudXNlU3RhdGUobnQodCkpLCBbYywgc10gPSBlLnVzZVN0YXRlKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuaXNNdXRlZCksIFtvLCBsXSA9IGUudXNlU3RhdGUoYSA9PSBudWxsID8gdm9pZCAwIDogYS5pc1N1YnNjcmliZWQpLCBbaSwgdV0gPSBlLnVzZVN0YXRlKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEudHJhY2spLCBbZCwgZ10gPSBlLnVzZVN0YXRlKFwibGFuZHNjYXBlXCIpLCBmID0gZS51c2VSZWYoKSwgeyBjbGFzc05hbWU6IHcsIHRyYWNrT2JzZXJ2ZXI6IHAgfSA9IGUudXNlTWVtbygoKSA9PiBydCh0KSwgW1xyXG4gICAgdC5wYXJ0aWNpcGFudC5zaWQgPz8gdC5wYXJ0aWNpcGFudC5pZGVudGl0eSxcclxuICAgIHQuc291cmNlLFxyXG4gICAgJCh0KSAmJiB0LnB1YmxpY2F0aW9uLnRyYWNrU2lkXHJcbiAgXSk7XHJcbiAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IG0gPSBwLnN1YnNjcmliZSgodikgPT4ge1xyXG4gICAgICBqLmRlYnVnKFwidXBkYXRlIHRyYWNrXCIsIHYpLCByKHYpLCBzKHYgPT0gbnVsbCA/IHZvaWQgMCA6IHYuaXNNdXRlZCksIGwodiA9PSBudWxsID8gdm9pZCAwIDogdi5pc1N1YnNjcmliZWQpLCB1KHYgPT0gbnVsbCA/IHZvaWQgMCA6IHYudHJhY2spO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4gbSA9PSBudWxsID8gdm9pZCAwIDogbS51bnN1YnNjcmliZSgpO1xyXG4gIH0sIFtwXSksIGUudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHZhciBtLCB2O1xyXG4gICAgcmV0dXJuIGkgJiYgKGYuY3VycmVudCAmJiBpLmRldGFjaChmLmN1cnJlbnQpLCAobSA9IG4uZWxlbWVudCkgIT0gbnVsbCAmJiBtLmN1cnJlbnQgJiYgISh0LnBhcnRpY2lwYW50LmlzTG9jYWwgJiYgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkua2luZCkgPT09IFwiYXVkaW9cIikgJiYgaS5hdHRhY2gobi5lbGVtZW50LmN1cnJlbnQpKSwgZi5jdXJyZW50ID0gKHYgPSBuLmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiB2LmN1cnJlbnQsICgpID0+IHtcclxuICAgICAgZi5jdXJyZW50ICYmIChpID09IG51bGwgfHwgaS5kZXRhY2goZi5jdXJyZW50KSk7XHJcbiAgICB9O1xyXG4gIH0sIFtpLCBuLmVsZW1lbnRdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdmFyIG0sIHY7XHJcbiAgICBpZiAodHlwZW9mICgobSA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGltZW5zaW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IG0ud2lkdGgpID09IFwibnVtYmVyXCIgJiYgdHlwZW9mICgodiA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZGltZW5zaW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IHYuaGVpZ2h0KSA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIGNvbnN0IGIgPSBhLmRpbWVuc2lvbnMud2lkdGggPiBhLmRpbWVuc2lvbnMuaGVpZ2h0ID8gXCJsYW5kc2NhcGVcIiA6IFwicG9ydHJhaXRcIjtcclxuICAgICAgZyhiKTtcclxuICAgIH1cclxuICB9LCBbYV0pLCB7XHJcbiAgICBwdWJsaWNhdGlvbjogYSxcclxuICAgIGlzTXV0ZWQ6IGMsXHJcbiAgICBpc1N1YnNjcmliZWQ6IG8sXHJcbiAgICB0cmFjazogaSxcclxuICAgIGVsZW1lbnRQcm9wczogUyhuLnByb3BzLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogdyxcclxuICAgICAgXCJkYXRhLWxrLWxvY2FsLXBhcnRpY2lwYW50XCI6IHQucGFydGljaXBhbnQuaXNMb2NhbCxcclxuICAgICAgXCJkYXRhLWxrLXNvdXJjZVwiOiBhID09IG51bGwgPyB2b2lkIDAgOiBhLnNvdXJjZSxcclxuICAgICAgLi4uKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEua2luZCkgPT09IFwidmlkZW9cIiAmJiB7IFwiZGF0YS1say1vcmllbnRhdGlvblwiOiBkIH1cclxuICAgIH0pXHJcbiAgfTtcclxufVxyXG52YXIgWSwgdWU7XHJcbmZ1bmN0aW9uIFR0KCkge1xyXG4gIGlmICh1ZSkgcmV0dXJuIFk7XHJcbiAgdWUgPSAxO1xyXG4gIHZhciB0ID0gXCJFeHBlY3RlZCBhIGZ1bmN0aW9uXCIsIG4gPSBOYU4sIGEgPSBcIltvYmplY3QgU3ltYm9sXVwiLCByID0gL15cXHMrfFxccyskL2csIGMgPSAvXlstK10weFswLTlhLWZdKyQvaSwgcyA9IC9eMGJbMDFdKyQvaSwgbyA9IC9eMG9bMC03XSskL2ksIGwgPSBwYXJzZUludCwgaSA9IHR5cGVvZiBxID09IFwib2JqZWN0XCIgJiYgcSAmJiBxLk9iamVjdCA9PT0gT2JqZWN0ICYmIHEsIHUgPSB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmLCBkID0gaSB8fCB1IHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSwgZyA9IE9iamVjdC5wcm90b3R5cGUsIGYgPSBnLnRvU3RyaW5nLCB3ID0gTWF0aC5tYXgsIHAgPSBNYXRoLm1pbiwgbSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGQuRGF0ZS5ub3coKTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIHYoaCwgRSwgaykge1xyXG4gICAgdmFyIEksIFYsIE8sIE4sIE0sIFAsIEYgPSAwLCByZSA9ICExLCBaID0gITEsIEQgPSAhMDtcclxuICAgIGlmICh0eXBlb2YgaCAhPSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodCk7XHJcbiAgICBFID0gQShFKSB8fCAwLCBiKGspICYmIChyZSA9ICEhay5sZWFkaW5nLCBaID0gXCJtYXhXYWl0XCIgaW4gaywgTyA9IFogPyB3KEEoay5tYXhXYWl0KSB8fCAwLCBFKSA6IE8sIEQgPSBcInRyYWlsaW5nXCIgaW4gayA/ICEhay50cmFpbGluZyA6IEQpO1xyXG4gICAgZnVuY3Rpb24gVShSKSB7XHJcbiAgICAgIHZhciB4ID0gSSwgSCA9IFY7XHJcbiAgICAgIHJldHVybiBJID0gViA9IHZvaWQgMCwgRiA9IFIsIE4gPSBoLmFwcGx5KEgsIHgpLCBOO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gUGUoUikge1xyXG4gICAgICByZXR1cm4gRiA9IFIsIE0gPSBzZXRUaW1lb3V0KFcsIEUpLCByZSA/IFUoUikgOiBOO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gVGUoUikge1xyXG4gICAgICB2YXIgeCA9IFIgLSBQLCBIID0gUiAtIEYsIHNlID0gRSAtIHg7XHJcbiAgICAgIHJldHVybiBaID8gcChzZSwgTyAtIEgpIDogc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjZShSKSB7XHJcbiAgICAgIHZhciB4ID0gUiAtIFAsIEggPSBSIC0gRjtcclxuICAgICAgcmV0dXJuIFAgPT09IHZvaWQgMCB8fCB4ID49IEUgfHwgeCA8IDAgfHwgWiAmJiBIID49IE87XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBXKCkge1xyXG4gICAgICB2YXIgUiA9IG0oKTtcclxuICAgICAgaWYgKGNlKFIpKVxyXG4gICAgICAgIHJldHVybiBsZShSKTtcclxuICAgICAgTSA9IHNldFRpbWVvdXQoVywgVGUoUikpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGUoUikge1xyXG4gICAgICByZXR1cm4gTSA9IHZvaWQgMCwgRCAmJiBJID8gVShSKSA6IChJID0gViA9IHZvaWQgMCwgTik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBBZSgpIHtcclxuICAgICAgTSAhPT0gdm9pZCAwICYmIGNsZWFyVGltZW91dChNKSwgRiA9IDAsIEkgPSBQID0gViA9IE0gPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBOZSgpIHtcclxuICAgICAgcmV0dXJuIE0gPT09IHZvaWQgMCA/IE4gOiBsZShtKCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gRygpIHtcclxuICAgICAgdmFyIFIgPSBtKCksIHggPSBjZShSKTtcclxuICAgICAgaWYgKEkgPSBhcmd1bWVudHMsIFYgPSB0aGlzLCBQID0gUiwgeCkge1xyXG4gICAgICAgIGlmIChNID09PSB2b2lkIDApXHJcbiAgICAgICAgICByZXR1cm4gUGUoUCk7XHJcbiAgICAgICAgaWYgKFopXHJcbiAgICAgICAgICByZXR1cm4gTSA9IHNldFRpbWVvdXQoVywgRSksIFUoUCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE0gPT09IHZvaWQgMCAmJiAoTSA9IHNldFRpbWVvdXQoVywgRSkpLCBOO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEcuY2FuY2VsID0gQWUsIEcuZmx1c2ggPSBOZSwgRztcclxuICB9XHJcbiAgZnVuY3Rpb24gYihoKSB7XHJcbiAgICB2YXIgRSA9IHR5cGVvZiBoO1xyXG4gICAgcmV0dXJuICEhaCAmJiAoRSA9PSBcIm9iamVjdFwiIHx8IEUgPT0gXCJmdW5jdGlvblwiKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gQyhoKSB7XHJcbiAgICByZXR1cm4gISFoICYmIHR5cGVvZiBoID09IFwib2JqZWN0XCI7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIFQoaCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBoID09IFwic3ltYm9sXCIgfHwgQyhoKSAmJiBmLmNhbGwoaCkgPT0gYTtcclxuICB9XHJcbiAgZnVuY3Rpb24gQShoKSB7XHJcbiAgICBpZiAodHlwZW9mIGggPT0gXCJudW1iZXJcIilcclxuICAgICAgcmV0dXJuIGg7XHJcbiAgICBpZiAoVChoKSlcclxuICAgICAgcmV0dXJuIG47XHJcbiAgICBpZiAoYihoKSkge1xyXG4gICAgICB2YXIgRSA9IHR5cGVvZiBoLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gaC52YWx1ZU9mKCkgOiBoO1xyXG4gICAgICBoID0gYihFKSA/IEUgKyBcIlwiIDogRTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgaCAhPSBcInN0cmluZ1wiKVxyXG4gICAgICByZXR1cm4gaCA9PT0gMCA/IGggOiAraDtcclxuICAgIGggPSBoLnJlcGxhY2UociwgXCJcIik7XHJcbiAgICB2YXIgayA9IHMudGVzdChoKTtcclxuICAgIHJldHVybiBrIHx8IG8udGVzdChoKSA/IGwoaC5zbGljZSgyKSwgayA/IDIgOiA4KSA6IGMudGVzdChoKSA/IG4gOiAraDtcclxuICB9XHJcbiAgcmV0dXJuIFkgPSB2LCBZO1xyXG59XHJcbnZhciBBdCA9IFR0KCk7XHJcbmNvbnN0IGRlID0gLyogQF9fUFVSRV9fICovIGN0KEF0KTtcclxuZnVuY3Rpb24gTnQodCkge1xyXG4gIGNvbnN0IG4gPSBMKHQpO1xyXG4gIG4uY3VycmVudCA9IHQsIHooXHJcbiAgICAoKSA9PiAoKSA9PiB7XHJcbiAgICAgIG4uY3VycmVudCgpO1xyXG4gICAgfSxcclxuICAgIFtdXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBMdCh0LCBuID0gNTAwLCBhKSB7XHJcbiAgY29uc3QgciA9IEwoKTtcclxuICBOdCgoKSA9PiB7XHJcbiAgICByLmN1cnJlbnQgJiYgci5jdXJyZW50LmNhbmNlbCgpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGMgPSBMZSgoKSA9PiB7XHJcbiAgICBjb25zdCBzID0gZGUodCwgbiwgYSksIG8gPSAoLi4ubCkgPT4gcyguLi5sKTtcclxuICAgIHJldHVybiBvLmNhbmNlbCA9ICgpID0+IHtcclxuICAgICAgcy5jYW5jZWwoKTtcclxuICAgIH0sIG8uaXNQZW5kaW5nID0gKCkgPT4gISFyLmN1cnJlbnQsIG8uZmx1c2ggPSAoKSA9PiBzLmZsdXNoKCksIG87XHJcbiAgfSwgW3QsIG4sIGFdKTtcclxuICByZXR1cm4geigoKSA9PiB7XHJcbiAgICByLmN1cnJlbnQgPSBkZSh0LCBuLCBhKTtcclxuICB9LCBbdCwgbiwgYV0pLCBjO1xyXG59XHJcbmZ1bmN0aW9uIHp0KHQsIG4sIGEpIHtcclxuICBjb25zdCByID0gKHUsIGQpID0+IHUgPT09IGQsIGMgPSB0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyB0KCkgOiB0LCBbcywgb10gPSBCKGMpLCBsID0gTChjKSwgaSA9IEx0KFxyXG4gICAgbyxcclxuICAgIG4sXHJcbiAgICBhXHJcbiAgKTtcclxuICByZXR1cm4gcihsLmN1cnJlbnQsIGMpIHx8IChpKGMpLCBsLmN1cnJlbnQgPSBjKSwgW3MsIGldO1xyXG59XHJcbmZ1bmN0aW9uIFZ0KHtcclxuICB0aHJlc2hvbGQ6IHQgPSAwLFxyXG4gIHJvb3Q6IG4gPSBudWxsLFxyXG4gIHJvb3RNYXJnaW46IGEgPSBcIjAlXCIsXHJcbiAgZnJlZXplT25jZVZpc2libGU6IHIgPSAhMSxcclxuICBpbml0aWFsSXNJbnRlcnNlY3Rpbmc6IGMgPSAhMSxcclxuICBvbkNoYW5nZTogc1xyXG59ID0ge30pIHtcclxuICB2YXIgbztcclxuICBjb25zdCBbbCwgaV0gPSBCKG51bGwpLCBbdSwgZF0gPSBCKCgpID0+ICh7XHJcbiAgICBpc0ludGVyc2VjdGluZzogYyxcclxuICAgIGVudHJ5OiB2b2lkIDBcclxuICB9KSksIGcgPSBMKCk7XHJcbiAgZy5jdXJyZW50ID0gcztcclxuICBjb25zdCBmID0gKChvID0gdS5lbnRyeSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaXNJbnRlcnNlY3RpbmcpICYmIHI7XHJcbiAgeigoKSA9PiB7XHJcbiAgICBpZiAoIWwgfHwgIShcIkludGVyc2VjdGlvbk9ic2VydmVyXCIgaW4gd2luZG93KSB8fCBmKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBtID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxyXG4gICAgICAodikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGIgPSBBcnJheS5pc0FycmF5KG0udGhyZXNob2xkcykgPyBtLnRocmVzaG9sZHMgOiBbbS50aHJlc2hvbGRzXTtcclxuICAgICAgICB2LmZvckVhY2goKEMpID0+IHtcclxuICAgICAgICAgIGNvbnN0IFQgPSBDLmlzSW50ZXJzZWN0aW5nICYmIGIuc29tZSgoQSkgPT4gQy5pbnRlcnNlY3Rpb25SYXRpbyA+PSBBKTtcclxuICAgICAgICAgIGQoeyBpc0ludGVyc2VjdGluZzogVCwgZW50cnk6IEMgfSksIGcuY3VycmVudCAmJiBnLmN1cnJlbnQoVCwgQyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHsgdGhyZXNob2xkOiB0LCByb290OiBuLCByb290TWFyZ2luOiBhIH1cclxuICAgICk7XHJcbiAgICByZXR1cm4gbS5vYnNlcnZlKGwpLCAoKSA9PiB7XHJcbiAgICAgIG0uZGlzY29ubmVjdCgpO1xyXG4gICAgfTtcclxuICB9LCBbXHJcbiAgICBsLFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgSlNPTi5zdHJpbmdpZnkodCksXHJcbiAgICBuLFxyXG4gICAgYSxcclxuICAgIGYsXHJcbiAgICByXHJcbiAgXSk7XHJcbiAgY29uc3QgdyA9IEwobnVsbCk7XHJcbiAgeigoKSA9PiB7XHJcbiAgICB2YXIgbTtcclxuICAgICFsICYmICgobSA9IHUuZW50cnkpICE9IG51bGwgJiYgbS50YXJnZXQpICYmICFyICYmICFmICYmIHcuY3VycmVudCAhPT0gdS5lbnRyeS50YXJnZXQgJiYgKHcuY3VycmVudCA9IHUuZW50cnkudGFyZ2V0LCBkKHsgaXNJbnRlcnNlY3Rpbmc6IGMsIGVudHJ5OiB2b2lkIDAgfSkpO1xyXG4gIH0sIFtsLCB1LmVudHJ5LCByLCBmLCBjXSk7XHJcbiAgY29uc3QgcCA9IFtcclxuICAgIGksXHJcbiAgICAhIXUuaXNJbnRlcnNlY3RpbmcsXHJcbiAgICB1LmVudHJ5XHJcbiAgXTtcclxuICByZXR1cm4gcC5yZWYgPSBwWzBdLCBwLmlzSW50ZXJzZWN0aW5nID0gcFsxXSwgcC5lbnRyeSA9IHBbMl0sIHA7XHJcbn1cclxuY29uc3QgRnQgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxyXG4gIGZ1bmN0aW9uKHtcclxuICAgIG9uVHJhY2tDbGljazogbixcclxuICAgIG9uQ2xpY2s6IGEsXHJcbiAgICBvblN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQ6IHIsXHJcbiAgICB0cmFja1JlZjogYyxcclxuICAgIG1hbmFnZVN1YnNjcmlwdGlvbjogcyxcclxuICAgIC4uLm9cclxuICB9LCBsKSB7XHJcbiAgICBjb25zdCBpID0gXyhjKSwgdSA9IGUudXNlUmVmKG51bGwpO1xyXG4gICAgZS51c2VJbXBlcmF0aXZlSGFuZGxlKGwsICgpID0+IHUuY3VycmVudCk7XHJcbiAgICBjb25zdCBkID0gVnQoeyByb290OiB1LmN1cnJlbnQgfSksIFtnXSA9IHp0KGQsIDNlMyk7XHJcbiAgICBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIHMgJiYgaS5wdWJsaWNhdGlvbiBpbnN0YW5jZW9mIEogJiYgKGcgPT0gbnVsbCA/IHZvaWQgMCA6IGcuaXNJbnRlcnNlY3RpbmcpID09PSAhMSAmJiAoZCA9PSBudWxsID8gdm9pZCAwIDogZC5pc0ludGVyc2VjdGluZykgPT09ICExICYmIGkucHVibGljYXRpb24uc2V0U3Vic2NyaWJlZCghMSk7XHJcbiAgICB9LCBbZywgaSwgc10pLCBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIHMgJiYgaS5wdWJsaWNhdGlvbiBpbnN0YW5jZW9mIEogJiYgKGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQuaXNJbnRlcnNlY3RpbmcpID09PSAhMCAmJiBpLnB1YmxpY2F0aW9uLnNldFN1YnNjcmliZWQoITApO1xyXG4gICAgfSwgW2QsIGksIHNdKTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgZWxlbWVudFByb3BzOiBmLFxyXG4gICAgICBwdWJsaWNhdGlvbjogdyxcclxuICAgICAgaXNTdWJzY3JpYmVkOiBwXHJcbiAgICB9ID0gQ2UoaSwge1xyXG4gICAgICBlbGVtZW50OiB1LFxyXG4gICAgICBwcm9wczogb1xyXG4gICAgfSk7XHJcbiAgICBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIHIgPT0gbnVsbCB8fCByKCEhcCk7XHJcbiAgICB9LCBbcCwgcl0pO1xyXG4gICAgY29uc3QgbSA9ICh2KSA9PiB7XHJcbiAgICAgIGEgPT0gbnVsbCB8fCBhKHYpLCBuID09IG51bGwgfHwgbih7IHBhcnRpY2lwYW50OiBpID09IG51bGwgPyB2b2lkIDAgOiBpLnBhcnRpY2lwYW50LCB0cmFjazogdyB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInZpZGVvXCIsIHsgcmVmOiB1LCAuLi5mLCBtdXRlZDogITAsIG9uQ2xpY2s6IG0gfSk7XHJcbiAgfVxyXG4pLCBuZSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oeyB0cmFja1JlZjogbiwgb25TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiBhLCB2b2x1bWU6IHIsIC4uLmMgfSwgcykge1xyXG4gICAgY29uc3QgbyA9IF8obiksIGwgPSBlLnVzZVJlZihudWxsKTtcclxuICAgIGUudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCAoKSA9PiBsLmN1cnJlbnQpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBlbGVtZW50UHJvcHM6IGksXHJcbiAgICAgIGlzU3Vic2NyaWJlZDogdSxcclxuICAgICAgdHJhY2s6IGQsXHJcbiAgICAgIHB1YmxpY2F0aW9uOiBnXHJcbiAgICB9ID0gQ2Uobywge1xyXG4gICAgICBlbGVtZW50OiBsLFxyXG4gICAgICBwcm9wczogY1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBhID09IG51bGwgfHwgYSghIXUpO1xyXG4gICAgfSwgW3UsIGFdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBkID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwIHx8IChkIGluc3RhbmNlb2YgS2UgPyBkLnNldFZvbHVtZShyKSA6IGoud2FybihcIlZvbHVtZSBjYW4gb25seSBiZSBzZXQgb24gcmVtb3RlIGF1ZGlvIHRyYWNrcy5cIikpO1xyXG4gICAgfSwgW3IsIGRdKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICBnID09PSB2b2lkIDAgfHwgYy5tdXRlZCA9PT0gdm9pZCAwIHx8IChnIGluc3RhbmNlb2YgSiA/IGcuc2V0RW5hYmxlZCghYy5tdXRlZCkgOiBqLndhcm4oXCJDYW4gb25seSBjYWxsIHNldEVuYWJsZWQgb24gcmVtb3RlIHRyYWNrIHB1YmxpY2F0aW9ucy5cIikpO1xyXG4gICAgfSwgW2MubXV0ZWQsIGcsIGRdKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIsIHsgcmVmOiBsLCAuLi5pIH0pO1xyXG4gIH1cclxuKTtcclxuZnVuY3Rpb24gWnQodCkge1xyXG4gIGNvbnN0IG4gPSAhIWx0KCk7XHJcbiAgcmV0dXJuIHQucGFydGljaXBhbnQgJiYgIW4gPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGtlLlByb3ZpZGVyLCB7IHZhbHVlOiB0LnBhcnRpY2lwYW50IH0sIHQuY2hpbGRyZW4pIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCB0LmNoaWxkcmVuKTtcclxufVxyXG5mdW5jdGlvbiBIdCh0KSB7XHJcbiAgY29uc3QgbiA9ICEhdGUoKTtcclxuICByZXR1cm4gdC50cmFja1JlZiAmJiAhbiA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoYWUuUHJvdmlkZXIsIHsgdmFsdWU6IHQudHJhY2tSZWYgfSwgdC5jaGlsZHJlbikgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsIHQuY2hpbGRyZW4pO1xyXG59XHJcbmNvbnN0IEJ0ID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcclxuICBmdW5jdGlvbih7XHJcbiAgICB0cmFja1JlZjogbixcclxuICAgIGNoaWxkcmVuOiBhLFxyXG4gICAgb25QYXJ0aWNpcGFudENsaWNrOiByLFxyXG4gICAgZGlzYWJsZVNwZWFraW5nSW5kaWNhdG9yOiBjLFxyXG4gICAgLi4uc1xyXG4gIH0sIG8pIHtcclxuICAgIHZhciB3LCBwO1xyXG4gICAgY29uc3QgbCA9IF8obiksIHsgZWxlbWVudFByb3BzOiBpIH0gPSB2ZSh7XHJcbiAgICAgIGh0bWxQcm9wczogcyxcclxuICAgICAgZGlzYWJsZVNwZWFraW5nSW5kaWNhdG9yOiBjLFxyXG4gICAgICBvblBhcnRpY2lwYW50Q2xpY2s6IHIsXHJcbiAgICAgIHRyYWNrUmVmOiBsXHJcbiAgICB9KSwgdSA9IHFlKGwucGFydGljaXBhbnQpLCBkID0gc3QoKSwgZyA9ICh3ID0gaXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHcuYXV0b1N1YnNjcmlwdGlvbiwgZiA9IGUudXNlQ2FsbGJhY2soXHJcbiAgICAgIChtKSA9PiB7XHJcbiAgICAgICAgbC5zb3VyY2UgJiYgIW0gJiYgZCAmJiBkLnBpbi5kaXNwYXRjaCAmJiBvdChsLCBkLnBpbi5zdGF0ZSkgJiYgZC5waW4uZGlzcGF0Y2goeyBtc2c6IFwiY2xlYXJfcGluXCIgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFtsLCBkXVxyXG4gICAgKTtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBvLCBzdHlsZTogeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0sIC4uLmkgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChIdCwgeyB0cmFja1JlZjogbCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFp0LCB7IHBhcnRpY2lwYW50OiBsLnBhcnRpY2lwYW50IH0sIGEgPz8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAkKGwpICYmICgoKHAgPSBsLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogcC5raW5kKSA9PT0gXCJ2aWRlb1wiIHx8IGwuc291cmNlID09PSB5LlNvdXJjZS5DYW1lcmEgfHwgbC5zb3VyY2UgPT09IHkuU291cmNlLlNjcmVlblNoYXJlKSA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgICAgIEZ0LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHJhY2tSZWY6IGwsXHJcbiAgICAgICAgb25TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiBmLFxyXG4gICAgICAgIG1hbmFnZVN1YnNjcmlwdGlvbjogZ1xyXG4gICAgICB9XHJcbiAgICApIDogJChsKSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gICAgICBuZSxcclxuICAgICAge1xyXG4gICAgICAgIHRyYWNrUmVmOiBsLFxyXG4gICAgICAgIG9uU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZDogZlxyXG4gICAgICB9XHJcbiAgICApLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LXBsYWNlaG9sZGVyXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChQdCwgbnVsbCkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW1ldGFkYXRhXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1tZXRhZGF0YS1pdGVtXCIgfSwgbC5zb3VyY2UgPT09IHkuU291cmNlLkNhbWVyYSA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgdSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHB0LCB7IHN0eWxlOiB7IG1hcmdpblJpZ2h0OiBcIjAuMjVyZW1cIiB9IH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gICAgICBTZSxcclxuICAgICAge1xyXG4gICAgICAgIHRyYWNrUmVmOiB7XHJcbiAgICAgICAgICBwYXJ0aWNpcGFudDogbC5wYXJ0aWNpcGFudCxcclxuICAgICAgICAgIHNvdXJjZTogeS5Tb3VyY2UuTWljcm9waG9uZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdzogXCJtdXRlZFwiXHJcbiAgICAgIH1cclxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSywgbnVsbCkpIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE1lLCB7IHN0eWxlOiB7IG1hcmdpblJpZ2h0OiBcIjAuMjVyZW1cIiB9IH0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEssIG51bGwsIFwiJ3Mgc2NyZWVuXCIpKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoYmUsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW1ldGFkYXRhLWl0ZW1cIiB9KSkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEl0LCB7IHRyYWNrUmVmOiBsIH0pKSkpO1xyXG4gIH1cclxuKTtcclxuZnVuY3Rpb24gaGEodCkge1xyXG4gIGNvbnN0IG4gPSBTKHQsIHsgY2xhc3NOYW1lOiBcImxrLWZvY3VzLWxheW91dFwiIH0pO1xyXG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4ubiB9LCB0LmNoaWxkcmVuKTtcclxufVxyXG5mdW5jdGlvbiBnYSh7IHRyYWNrUmVmOiB0LCAuLi5uIH0pIHtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChCdCwgeyB0cmFja1JlZjogdCwgLi4ubiB9KTtcclxufVxyXG5mdW5jdGlvbiBJZSh7IHRyYWNrczogdCwgLi4ubiB9KSB7XHJcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgdC5tYXAoKGEpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgICBhZS5Qcm92aWRlcixcclxuICAgIHtcclxuICAgICAgdmFsdWU6IGEsXHJcbiAgICAgIGtleTogUmUoYSlcclxuICAgIH0sXHJcbiAgICBlZShuLmNoaWxkcmVuKVxyXG4gICkpKTtcclxufVxyXG5mdW5jdGlvbiBqdCh7XHJcbiAgdG90YWxQYWdlQ291bnQ6IHQsXHJcbiAgbmV4dFBhZ2U6IG4sXHJcbiAgcHJldlBhZ2U6IGEsXHJcbiAgY3VycmVudFBhZ2U6IHIsXHJcbiAgcGFnZXNDb250YWluZXI6IGNcclxufSkge1xyXG4gIGNvbnN0IFtzLCBvXSA9IGUudXNlU3RhdGUoITEpO1xyXG4gIHJldHVybiBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBsZXQgbDtcclxuICAgIHJldHVybiBjICYmIChsID0gdXQoYy5jdXJyZW50LCAyZTMpLnN1YnNjcmliZShcclxuICAgICAgb1xyXG4gICAgKSksICgpID0+IHtcclxuICAgICAgbCAmJiBsLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9O1xyXG4gIH0sIFtjXSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibGstcGFnaW5hdGlvbi1jb250cm9sXCIsIFwiZGF0YS1say11c2VyLWludGVyYWN0aW9uXCI6IHMgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJsay1idXR0b25cIiwgb25DbGljazogYSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGllLCBudWxsKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhZ2luYXRpb24tY291bnRcIiB9LCBgJHtyfSBvZiAke3R9YCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwibGstYnV0dG9uXCIsIG9uQ2xpY2s6IG4gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChpZSwgbnVsbCkpKTtcclxufVxyXG5jb25zdCBfdCA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oeyB0b3RhbFBhZ2VDb3VudDogbiwgY3VycmVudFBhZ2U6IGEgfSwgcikge1xyXG4gICAgY29uc3QgYyA9IG5ldyBBcnJheShuKS5maWxsKFwiXCIpLm1hcCgocywgbykgPT4gbyArIDEgPT09IGEgPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiZGF0YS1say1hY3RpdmVcIjogITAsIGtleTogbyB9KSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBvIH0pKTtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiByLCBjbGFzc05hbWU6IFwibGstcGFnaW5hdGlvbi1pbmRpY2F0b3JcIiB9LCBjKTtcclxuICB9XHJcbik7XHJcbmZ1bmN0aW9uIHZhKHsgdHJhY2tzOiB0LCAuLi5uIH0pIHtcclxuICBjb25zdCBhID0gZS5jcmVhdGVSZWYoKSwgciA9IGUudXNlTWVtbyhcclxuICAgICgpID0+IFMobiwgeyBjbGFzc05hbWU6IFwibGstZ3JpZC1sYXlvdXRcIiB9KSxcclxuICAgIFtuXVxyXG4gICksIHsgbGF5b3V0OiBjIH0gPSAkZShhLCB0Lmxlbmd0aCksIHMgPSBEZShjLm1heFRpbGVzLCB0KTtcclxuICByZXR1cm4gVWUoYSwge1xyXG4gICAgb25MZWZ0U3dpcGU6IHMubmV4dFBhZ2UsXHJcbiAgICBvblJpZ2h0U3dpcGU6IHMucHJldlBhZ2VcclxuICB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogYSwgXCJkYXRhLWxrLXBhZ2luYXRpb25cIjogcy50b3RhbFBhZ2VDb3VudCA+IDEsIC4uLnIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChJZSwgeyB0cmFja3M6IHMudHJhY2tzIH0sIG4uY2hpbGRyZW4pLCB0Lmxlbmd0aCA+IGMubWF4VGlsZXMgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gICAgX3QsXHJcbiAgICB7XHJcbiAgICAgIHRvdGFsUGFnZUNvdW50OiBzLnRvdGFsUGFnZUNvdW50LFxyXG4gICAgICBjdXJyZW50UGFnZTogcy5jdXJyZW50UGFnZVxyXG4gICAgfVxyXG4gICksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoanQsIHsgcGFnZXNDb250YWluZXI6IGEsIC4uLnMgfSkpKTtcclxufVxyXG5jb25zdCBPdCA9IDEzMCwgV3QgPSAxNDAsIG1lID0gMSwgeGUgPSAxNiAvIDEwLCBxdCA9ICgxIC0geGUpICogLTE7XHJcbmZ1bmN0aW9uIEVhKHsgdHJhY2tzOiB0LCBvcmllbnRhdGlvbjogbiwgLi4uYSB9KSB7XHJcbiAgY29uc3QgciA9IGUudXNlUmVmKG51bGwpLCBbYywgc10gPSBlLnVzZVN0YXRlKDApLCB7IHdpZHRoOiBvLCBoZWlnaHQ6IGwgfSA9IEdlKHIpLCBpID0gbiB8fCAobCA+PSBvID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpLCB1ID0gaSA9PT0gXCJ2ZXJ0aWNhbFwiID8gTWF0aC5tYXgobyAqIHF0LCBPdCkgOiBNYXRoLm1heChsICogeGUsIFd0KSwgZCA9IGR0KCksIGcgPSBNYXRoLm1heChpID09PSBcInZlcnRpY2FsXCIgPyAobCAtIGQpIC8gdSA6IChvIC0gZCkgLyB1LCBtZSk7XHJcbiAgbGV0IGYgPSBNYXRoLnJvdW5kKGcpO1xyXG4gIE1hdGguYWJzKGcgLSBjKSA8IDAuNSA/IGYgPSBNYXRoLnJvdW5kKGMpIDogYyAhPT0gZyAmJiBzKGcpO1xyXG4gIGNvbnN0IHcgPSBRZSh0LCBmKTtcclxuICByZXR1cm4gZS51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgci5jdXJyZW50ICYmIChyLmN1cnJlbnQuZGF0YXNldC5sa09yaWVudGF0aW9uID0gaSwgci5jdXJyZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1say1tYXgtdmlzaWJsZS10aWxlc1wiLCBmLnRvU3RyaW5nKCkpKTtcclxuICB9LCBbZiwgaV0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiYXNpZGVcIiwgeyBrZXk6IGksIGNsYXNzTmFtZTogXCJsay1jYXJvdXNlbFwiLCByZWY6IHIsIC4uLmEgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChJZSwgeyB0cmFja3M6IHcgfSwgYS5jaGlsZHJlbikpO1xyXG59XHJcbmZ1bmN0aW9uIHBhKHtcclxuICB2YWx1ZTogdCxcclxuICBvblBpbkNoYW5nZTogbixcclxuICBvbldpZGdldENoYW5nZTogYSxcclxuICBjaGlsZHJlbjogclxyXG59KSB7XHJcbiAgY29uc3QgYyA9IG10KHQpO1xyXG4gIHJldHVybiBlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBqLmRlYnVnKFwiUGluU3RhdGUgVXBkYXRlZFwiLCB7IHN0YXRlOiBjLnBpbi5zdGF0ZSB9KSwgbiAmJiBjLnBpbi5zdGF0ZSAmJiBuKGMucGluLnN0YXRlKTtcclxuICB9LCBbYy5waW4uc3RhdGUsIG5dKSwgZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgai5kZWJ1ZyhcIldpZGdldCBVcGRhdGVkXCIsIHsgd2lkZ2V0U3RhdGU6IGMud2lkZ2V0LnN0YXRlIH0pLCBhICYmIGMud2lkZ2V0LnN0YXRlICYmIGEoYy53aWRnZXQuc3RhdGUpO1xyXG4gIH0sIFthLCBjLndpZGdldC5zdGF0ZV0pLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHBlLlByb3ZpZGVyLCB7IHZhbHVlOiBjIH0sIHIpO1xyXG59XHJcbmNvbnN0IHdhID0gLyogQF9fUFVSRV9fICovIGUuZm9yd2FyZFJlZihcclxuICBmdW5jdGlvbih7IHRyYWNrUmVmOiBuLCAuLi5hIH0sIHIpIHtcclxuICAgIGNvbnN0IGQgPSBfKG4pLCBnID0gRWUoZCwgeyBiYW5kczogNywgbG9QYXNzOiAzMDAgfSk7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgICAgXCJzdmdcIixcclxuICAgICAge1xyXG4gICAgICAgIHJlZjogcixcclxuICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgICAgICB2aWV3Qm94OiBcIjAgMCAyMDAgOTBcIixcclxuICAgICAgICAuLi5hLFxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJsay1hdWRpby12aXN1YWxpemVyXCJcclxuICAgICAgfSxcclxuICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgeyB4OiBcIjBcIiwgeTogXCIwXCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9KSxcclxuICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgICAgICBcImdcIixcclxuICAgICAgICB7XHJcbiAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoMjAwIC0gNyAqIDEwKSAvIDJ9cHgsIDApYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZy5tYXAoKGYsIHcpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXHJcbiAgICAgICAgICBcInJlY3RcIixcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAga2V5OiB3LFxyXG4gICAgICAgICAgICB4OiB3ICogMTAsXHJcbiAgICAgICAgICAgIHk6IDkwIC8gMiAtIGYgKiA1MCAvIDIsXHJcbiAgICAgICAgICAgIHdpZHRoOiA2LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGYgKiA1MFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICkpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxyXG4pO1xyXG5mdW5jdGlvbiBrYSh7IHBhcnRpY2lwYW50czogdCwgLi4ubiB9KSB7XHJcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgdC5tYXAoKGEpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoa2UuUHJvdmlkZXIsIHsgdmFsdWU6IGEsIGtleTogYS5pZGVudGl0eSB9LCBlZShuLmNoaWxkcmVuKSkpKTtcclxufVxyXG5mdW5jdGlvbiBSYSh7IHZvbHVtZTogdCwgbXV0ZWQ6IG4gfSkge1xyXG4gIGNvbnN0IGEgPSBYZShcclxuICAgIFt5LlNvdXJjZS5NaWNyb3Bob25lLCB5LlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvLCB5LlNvdXJjZS5Vbmtub3duXSxcclxuICAgIHtcclxuICAgICAgdXBkYXRlT25seU9uOiBbXSxcclxuICAgICAgb25seVN1YnNjcmliZWQ6ICEwXHJcbiAgICB9XHJcbiAgKS5maWx0ZXIoKHIpID0+ICFyLnBhcnRpY2lwYW50LmlzTG9jYWwgJiYgci5wdWJsaWNhdGlvbi5raW5kID09PSB5LktpbmQuQXVkaW8pO1xyXG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9LCBhLm1hcCgocikgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgIG5lLFxyXG4gICAge1xyXG4gICAgICBrZXk6IFJlKHIpLFxyXG4gICAgICB0cmFja1JlZjogcixcclxuICAgICAgdm9sdW1lOiB0LFxyXG4gICAgICBtdXRlZDogblxyXG4gICAgfVxyXG4gICkpKTtcclxufVxyXG5jb25zdCBNYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoZnVuY3Rpb24oeyBjaGlsZHJlblBvc2l0aW9uOiBuID0gXCJiZWZvcmVcIiwgY2hpbGRyZW46IGEsIC4uLnIgfSwgYykge1xyXG4gIGNvbnN0IHsgbmFtZTogcyB9ID0gWWUoKTtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyByZWY6IGMsIC4uLnIgfSwgbiA9PT0gXCJiZWZvcmVcIiAmJiBhLCBzLCBuID09PSBcImFmdGVyXCIgJiYgYSk7XHJcbn0pO1xyXG5mdW5jdGlvbiAkdCh0KSB7XHJcbiAgY29uc3QgbiA9IGUudXNlTWVtbygoKSA9PiBTKHQsIHsgY2xhc3NOYW1lOiBcImxrLXRvYXN0XCIgfSksIFt0XSk7XHJcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5uIH0sIHQuY2hpbGRyZW4pO1xyXG59XHJcbmNvbnN0IER0ID0gKHQpID0+IHtcclxuICBjb25zdCBuID0gW107XHJcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCB0OyBhKyspXHJcbiAgICBuLnB1c2goW2EsIHQgLSAxIC0gYV0pO1xyXG4gIHJldHVybiBuO1xyXG59LCBmZSA9ICh0KSA9PiBbW01hdGguZmxvb3IodCAvIDIpXSwgWy0xXV0sIFV0ID0gKHQsIG4sIGEpID0+IHtcclxuICBjb25zdCBbciwgY10gPSBCKDApLCBbcywgb10gPSBCKFtbXV0pO1xyXG4gIHooKCkgPT4ge1xyXG4gICAgaWYgKHQgPT09IFwidGhpbmtpbmdcIilcclxuICAgICAgbyhmZShuKSk7XHJcbiAgICBlbHNlIGlmICh0ID09PSBcImNvbm5lY3RpbmdcIiB8fCB0ID09PSBcImluaXRpYWxpemluZ1wiKSB7XHJcbiAgICAgIGNvbnN0IGkgPSBbLi4uRHQobildO1xyXG4gICAgICBvKGkpO1xyXG4gICAgfSBlbHNlIG8odCA9PT0gXCJsaXN0ZW5pbmdcIiA/IGZlKG4pIDogdCA9PT0gdm9pZCAwIHx8IHQgPT09IFwic3BlYWtpbmdcIiA/IFtuZXcgQXJyYXkobikuZmlsbCgwKS5tYXAoKGksIHUpID0+IHUpXSA6IFtbXV0pO1xyXG4gICAgYygwKTtcclxuICB9LCBbdCwgbl0pO1xyXG4gIGNvbnN0IGwgPSBMKG51bGwpO1xyXG4gIHJldHVybiB6KCgpID0+IHtcclxuICAgIGxldCBpID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zdCB1ID0gKGQpID0+IHtcclxuICAgICAgZCAtIGkgPj0gYSAmJiAoYygoZikgPT4gZiArIDEpLCBpID0gZCksIGwuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gbC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpLCAoKSA9PiB7XHJcbiAgICAgIGwuY3VycmVudCAhPT0gbnVsbCAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShsLmN1cnJlbnQpO1xyXG4gICAgfTtcclxuICB9LCBbYSwgbiwgdCwgcy5sZW5ndGhdKSwgc1tyICUgcy5sZW5ndGhdO1xyXG59LCBHdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcclxuICBbXCJjb25uZWN0aW5nXCIsIDJlM10sXHJcbiAgW1wiaW5pdGlhbGl6aW5nXCIsIDJlM10sXHJcbiAgW1wibGlzdGVuaW5nXCIsIDUwMF0sXHJcbiAgW1widGhpbmtpbmdcIiwgMTUwXVxyXG5dKSwgUXQgPSAodCwgbikgPT4ge1xyXG4gIGlmICh0ID09PSB2b2lkIDApXHJcbiAgICByZXR1cm4gMWUzO1xyXG4gIGxldCBhID0gR3QuZ2V0KHQpO1xyXG4gIGlmIChhKVxyXG4gICAgc3dpdGNoICh0KSB7XHJcbiAgICAgIGNhc2UgXCJjb25uZWN0aW5nXCI6XHJcbiAgICAgICAgYSAvPSBuO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIHJldHVybiBhO1xyXG59LCBYdCA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oeyBzdGF0ZTogbiwgb3B0aW9uczogYSwgYmFyQ291bnQ6IHIgPSAxNSwgdHJhY2tSZWY6IGMsIGNoaWxkcmVuOiBzLCAuLi5vIH0sIGwpIHtcclxuICAgIGNvbnN0IGkgPSBTKG8sIHsgY2xhc3NOYW1lOiBcImxrLWF1ZGlvLWJhci12aXN1YWxpemVyXCIgfSk7XHJcbiAgICBsZXQgdSA9IHRlKCk7XHJcbiAgICBjICYmICh1ID0gYyk7XHJcbiAgICBjb25zdCBkID0gRWUodSwge1xyXG4gICAgICBiYW5kczogcixcclxuICAgICAgbG9QYXNzOiAxMDAsXHJcbiAgICAgIGhpUGFzczogMjAwXHJcbiAgICB9KSwgZyA9IChhID09IG51bGwgPyB2b2lkIDAgOiBhLm1pbkhlaWdodCkgPz8gMjAsIGYgPSAoYSA9PSBudWxsID8gdm9pZCAwIDogYS5tYXhIZWlnaHQpID8/IDEwMCwgdyA9IFV0KFxyXG4gICAgICBuLFxyXG4gICAgICByLFxyXG4gICAgICBRdChuLCByKSA/PyAxMDBcclxuICAgICk7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogbCwgLi4uaSwgXCJkYXRhLWxrLXZhLXN0YXRlXCI6IG4gfSwgZC5tYXAoXHJcbiAgICAgIChwLCBtKSA9PiBzID8gZWUocywge1xyXG4gICAgICAgIFwiZGF0YS1say1oaWdobGlnaHRlZFwiOiB3LmluY2x1ZGVzKG0pLFxyXG4gICAgICAgIFwiZGF0YS1say1iYXItaW5kZXhcIjogbSxcclxuICAgICAgICBjbGFzc05hbWU6IFwibGstYXVkaW8tYmFyXCIsXHJcbiAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiBgJHtNYXRoLm1pbihmLCBNYXRoLm1heChnLCBwICogMTAwICsgNSkpfSVgIH1cclxuICAgICAgfSkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxyXG4gICAgICAgIFwic3BhblwiLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGtleTogbSxcclxuICAgICAgICAgIFwiZGF0YS1say1oaWdobGlnaHRlZFwiOiB3LmluY2x1ZGVzKG0pLFxyXG4gICAgICAgICAgXCJkYXRhLWxrLWJhci1pbmRleFwiOiBtLFxyXG4gICAgICAgICAgY2xhc3NOYW1lOiBgbGstYXVkaW8tYmFyICR7dy5pbmNsdWRlcyhtKSAmJiBcImxrLWhpZ2hsaWdodGVkXCJ9YCxcclxuICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdHJhbnNmb3JtIGFuaW1hdGlvbnMgd291bGQgYmUgbW9yZSBwZXJmb3JtYW50LCBob3dldmVyIHRoZSBib3JkZXItcmFkaXVzIGdldHMgZGlzdG9ydGVkIHdoZW4gdXNpbmcgc2NhbGUgdHJhbnNmb3Jtcy4gYSA5LXNsaWNlIGFwcHJvYWNoIChvciAzIGluIHRoaXMgY2FzZSkgY291bGQgd29ya1xyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm06IGBzY2FsZSgxLCAke01hdGgubWluKG1heEhlaWdodCwgTWF0aC5tYXgobWluSGVpZ2h0LCB2b2x1bWUpKX1gLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGAke01hdGgubWluKGYsIE1hdGgubWF4KGcsIHAgKiAxMDAgKyA1KSl9JWBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIClcclxuICAgICkpO1xyXG4gIH1cclxuKSwgeWEgPSAvKiBAX19QVVJFX18gKi8gZS5mb3J3YXJkUmVmKFxyXG4gIGZ1bmN0aW9uKHtcclxuICAgIGNoaWxkcmVuOiBuLFxyXG4gICAgZGlzYWJsZVNwZWFraW5nSW5kaWNhdG9yOiBhLFxyXG4gICAgb25QYXJ0aWNpcGFudENsaWNrOiByLFxyXG4gICAgdHJhY2tSZWY6IGMsXHJcbiAgICAuLi5zXHJcbiAgfSwgbykge1xyXG4gICAgY29uc3QgbCA9IF8oYyksIHsgZWxlbWVudFByb3BzOiBpIH0gPSB2ZSh7XHJcbiAgICAgIHRyYWNrUmVmOiBsLFxyXG4gICAgICBodG1sUHJvcHM6IHMsXHJcbiAgICAgIGRpc2FibGVTcGVha2luZ0luZGljYXRvcjogYSxcclxuICAgICAgb25QYXJ0aWNpcGFudENsaWNrOiByXHJcbiAgICB9KTtcclxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBvLCBzdHlsZTogeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCBtaW5IZWlnaHQ6IFwiMTYwcHhcIiB9LCAuLi5pIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoYWUuUHJvdmlkZXIsIHsgdmFsdWU6IGwgfSwgbiA/PyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsICQobCkgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChuZSwgeyB0cmFja1JlZjogbCB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChYdCwgeyBiYXJDb3VudDogNywgb3B0aW9uczogeyBtaW5IZWlnaHQ6IDggfSB9KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1tZXRhZGF0YVwiIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibGstcGFydGljaXBhbnQtbWV0YWRhdGEtaXRlbVwiIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoU2UsIHsgdHJhY2tSZWY6IGwgfSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSywgbnVsbCkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGJlLCB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1tZXRhZGF0YS1pdGVtXCIgfSkpKSkpO1xyXG4gIH1cclxuKTtcclxuZnVuY3Rpb24gYmEodCkge1xyXG4gIGNvbnN0IFtuLCBhXSA9IGUudXNlU3RhdGUodm9pZCAwKSwgciA9IGhlKHQucm9vbSk7XHJcbiAgcmV0dXJuIGUudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHN3aXRjaCAocikge1xyXG4gICAgICBjYXNlIFguUmVjb25uZWN0aW5nOlxyXG4gICAgICAgIGEoXHJcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQob2UsIHsgY2xhc3NOYW1lOiBcImxrLXNwaW5uZXJcIiB9KSwgXCIgUmVjb25uZWN0aW5nXCIpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBYLkNvbm5lY3Rpbmc6XHJcbiAgICAgICAgYShcclxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChvZSwgeyBjbGFzc05hbWU6IFwibGstc3Bpbm5lclwiIH0pLCBcIiBDb25uZWN0aW5nXCIpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBYLkRpc2Nvbm5lY3RlZDpcclxuICAgICAgICBhKC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgXCJEaXNjb25uZWN0ZWRcIikpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGEodm9pZCAwKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9LCBbcl0pLCBuID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCgkdCwgeyBjbGFzc05hbWU6IFwibGstdG9hc3QtY29ubmVjdGlvbi1zdGF0ZVwiIH0sIG4pIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChlLkZyYWdtZW50LCBudWxsKTtcclxufVxyXG5jb25zdCBTYSA9IC8qIEBfX1BVUkVfXyAqLyBlLmZvcndhcmRSZWYoXHJcbiAgZnVuY3Rpb24oeyBlbnRyeTogbiwgaGlkZU5hbWU6IGEgPSAhMSwgaGlkZVRpbWVzdGFtcDogciA9ICExLCBtZXNzYWdlRm9ybWF0dGVyOiBjLCAuLi5zIH0sIG8pIHtcclxuICAgIHZhciBmLCB3LCBwLCBtO1xyXG4gICAgY29uc3QgbCA9IGUudXNlTWVtbygoKSA9PiBjID8gYyhuLm1lc3NhZ2UpIDogbi5tZXNzYWdlLCBbbi5tZXNzYWdlLCBjXSksIGkgPSAhIW4uZWRpdFRpbWVzdGFtcCwgdSA9IG5ldyBEYXRlKG4udGltZXN0YW1wKSwgZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiA/IG5hdmlnYXRvci5sYW5ndWFnZSA6IFwiZW4tVVNcIiwgZyA9ICgoZiA9IG4uZnJvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYubmFtZSkgPz8gKCh3ID0gbi5mcm9tKSA9PSBudWxsID8gdm9pZCAwIDogdy5pZGVudGl0eSk7XHJcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgICAgXCJsaVwiLFxyXG4gICAgICB7XHJcbiAgICAgICAgcmVmOiBvLFxyXG4gICAgICAgIGNsYXNzTmFtZTogXCJsay1jaGF0LWVudHJ5XCIsXHJcbiAgICAgICAgdGl0bGU6IHUudG9Mb2NhbGVUaW1lU3RyaW5nKGQsIHsgdGltZVN0eWxlOiBcImZ1bGxcIiB9KSxcclxuICAgICAgICBcImRhdGEtbGstbWVzc2FnZS1vcmlnaW5cIjogKHAgPSBuLmZyb20pICE9IG51bGwgJiYgcC5pc0xvY2FsID8gXCJsb2NhbFwiIDogXCJyZW1vdGVcIixcclxuICAgICAgICAuLi5zXHJcbiAgICAgIH0sXHJcbiAgICAgICghciB8fCAhYSB8fCBpKSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJsay1tZXRhLWRhdGFcIiB9LCAhYSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3Ryb25nXCIsIHsgY2xhc3NOYW1lOiBcImxrLXBhcnRpY2lwYW50LW5hbWVcIiB9LCBnKSwgKCFyIHx8IGkpICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImxrLXRpbWVzdGFtcFwiIH0sIGkgJiYgXCJlZGl0ZWQgXCIsIHUudG9Mb2NhbGVUaW1lU3RyaW5nKGQsIHsgdGltZVN0eWxlOiBcInNob3J0XCIgfSkpKSxcclxuICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwibGstbWVzc2FnZS1ib2R5XCIgfSwgbCksXHJcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImxrLW1lc3NhZ2UtYXR0YWNoZW1lbnRzXCIgfSwgKG0gPSBuLmF0dGFjaGVkRmlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBtLm1hcChcclxuICAgICAgICAodikgPT4gdi50eXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcclxuICAgICAgICAgIFwiaW1nXCIsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0eWxlOiB7IG1heFdpZHRoOiBcIjMwMHB4XCIsIG1heEhlaWdodDogXCIzMDBweFwiIH0sXHJcbiAgICAgICAgICAgIGtleTogdi5uYW1lLFxyXG4gICAgICAgICAgICBzcmM6IFVSTC5jcmVhdGVPYmplY3RVUkwodiksXHJcbiAgICAgICAgICAgIGFsdDogdi5uYW1lXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKVxyXG4gICAgICApKVxyXG4gICAgKTtcclxuICB9XHJcbik7XHJcbmZ1bmN0aW9uIENhKHQpIHtcclxuICByZXR1cm4gZnQodCwgaHQoKSkubWFwKChuLCBhKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB7XHJcbiAgICAgIGNvbnN0IHIgPSBuLmNvbnRlbnQudG9TdHJpbmcoKSwgYyA9IG4udHlwZSA9PT0gXCJ1cmxcIiA/IC9eaHR0cChzPyk6XFwvXFwvLy50ZXN0KHIpID8gciA6IGBodHRwczovLyR7cn1gIDogYG1haWx0bzoke3J9YDtcclxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcImxrLWNoYXQtbGlua1wiLCBrZXk6IGEsIGhyZWY6IGMsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vcmVmZXJyZXJcIiB9LCByKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5leHBvcnQge1xyXG4gIHdhIGFzIEEsXHJcbiAgWHQgYXMgQixcclxuICByYSBhcyBDLFxyXG4gIGNhIGFzIEQsXHJcbiAgdnQgYXMgRSxcclxuICBoYSBhcyBGLFxyXG4gIHZhIGFzIEcsXHJcbiAgaWUgYXMgSCxcclxuICBFdCBhcyBJLFxyXG4gIHB0IGFzIEosXHJcbiAgd3QgYXMgSyxcclxuICBwYSBhcyBMLFxyXG4gIHVhIGFzIE0sXHJcbiAga3QgYXMgTixcclxuICBSdCBhcyBPLFxyXG4gIEJ0IGFzIFAsXHJcbiAgTXQgYXMgUSxcclxuICBSYSBhcyBSLFxyXG4gIGxhIGFzIFMsXHJcbiAgZmEgYXMgVCxcclxuICB5dCBhcyBVLFxyXG4gIEZ0IGFzIFYsXHJcbiAgYnQgYXMgVyxcclxuICBNZSBhcyBYLFxyXG4gIFN0IGFzIFksXHJcbiAgb2UgYXMgWixcclxuICBDdCBhcyBfLFxyXG4gIFNhIGFzIGEsXHJcbiAgUHQgYXMgYixcclxuICBzYSBhcyBjLFxyXG4gIGlhIGFzIGQsXHJcbiAgb2EgYXMgZSxcclxuICBtYSBhcyBmLFxyXG4gIEVhIGFzIGcsXHJcbiAgZ2EgYXMgaCxcclxuICBiYSBhcyBpLFxyXG4gIEllIGFzIGosXHJcbiAgeWEgYXMgayxcclxuICAkdCBhcyBsLFxyXG4gIENhIGFzIG0sXHJcbiAgYWEgYXMgbixcclxuICBuYSBhcyBvLFxyXG4gIEl0IGFzIHAsXHJcbiAgZGEgYXMgcSxcclxuICBiZSBhcyByLFxyXG4gIG5lIGFzIHMsXHJcbiAgSyBhcyB0LFxyXG4gIFNlIGFzIHUsXHJcbiAga2EgYXMgdixcclxuICBNYSBhcyB3LFxyXG4gIFp0IGFzIHgsXHJcbiAgSHQgYXMgeSxcclxuICBndCBhcyB6XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMtQmVLMnZJaWIubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ Is),\n/* harmony export */   A: () => (/* binding */ Xo),\n/* harmony export */   B: () => (/* binding */ Lo),\n/* harmony export */   C: () => (/* binding */ lo),\n/* harmony export */   D: () => (/* binding */ ys),\n/* harmony export */   E: () => (/* binding */ as),\n/* harmony export */   F: () => (/* binding */ $s),\n/* harmony export */   G: () => (/* binding */ zo),\n/* harmony export */   H: () => (/* binding */ cs),\n/* harmony export */   I: () => (/* binding */ ls),\n/* harmony export */   J: () => (/* binding */ ts),\n/* harmony export */   K: () => (/* binding */ ns),\n/* harmony export */   L: () => (/* binding */ Io),\n/* harmony export */   M: () => (/* binding */ Jo),\n/* harmony export */   N: () => (/* binding */ xs),\n/* harmony export */   O: () => (/* binding */ Ss),\n/* harmony export */   P: () => (/* binding */ Ts),\n/* harmony export */   Q: () => (/* binding */ gs),\n/* harmony export */   R: () => (/* binding */ Wn),\n/* harmony export */   S: () => (/* binding */ ds),\n/* harmony export */   T: () => (/* binding */ ps),\n/* harmony export */   U: () => (/* binding */ Ki),\n/* harmony export */   V: () => (/* binding */ As),\n/* harmony export */   W: () => (/* binding */ Go),\n/* harmony export */   X: () => (/* binding */ Bt),\n/* harmony export */   Y: () => (/* binding */ Zo),\n/* harmony export */   Z: () => (/* binding */ ws),\n/* harmony export */   _: () => (/* binding */ Rs),\n/* harmony export */   a: () => (/* binding */ Ds),\n/* harmony export */   a0: () => (/* binding */ is),\n/* harmony export */   a1: () => (/* binding */ j),\n/* harmony export */   a2: () => (/* binding */ Os),\n/* harmony export */   a3: () => (/* binding */ Ls),\n/* harmony export */   a4: () => (/* binding */ ks),\n/* harmony export */   a5: () => (/* binding */ Ko),\n/* harmony export */   a6: () => (/* binding */ qo),\n/* harmony export */   a7: () => (/* binding */ fs),\n/* harmony export */   a8: () => (/* binding */ os),\n/* harmony export */   a9: () => (/* binding */ Ms),\n/* harmony export */   aa: () => (/* binding */ ho),\n/* harmony export */   ab: () => (/* binding */ Un),\n/* harmony export */   ac: () => (/* binding */ Nn),\n/* harmony export */   ad: () => (/* binding */ bs),\n/* harmony export */   ae: () => (/* binding */ Mo),\n/* harmony export */   af: () => (/* binding */ Ar),\n/* harmony export */   ag: () => (/* binding */ jn),\n/* harmony export */   ah: () => (/* binding */ Fn),\n/* harmony export */   ai: () => (/* binding */ zs),\n/* harmony export */   aj: () => (/* binding */ _s),\n/* harmony export */   ak: () => (/* binding */ No),\n/* harmony export */   al: () => (/* binding */ Fs),\n/* harmony export */   am: () => (/* binding */ Bo),\n/* harmony export */   an: () => (/* binding */ Wo),\n/* harmony export */   ao: () => (/* binding */ Uo),\n/* harmony export */   ap: () => (/* binding */ jo),\n/* harmony export */   aq: () => (/* binding */ Yo),\n/* harmony export */   ar: () => (/* binding */ Ns),\n/* harmony export */   as: () => (/* binding */ Do),\n/* harmony export */   at: () => (/* binding */ Fo),\n/* harmony export */   au: () => (/* binding */ Vo),\n/* harmony export */   av: () => (/* binding */ Ho),\n/* harmony export */   aw: () => (/* binding */ Ws),\n/* harmony export */   ax: () => (/* binding */ Us),\n/* harmony export */   b: () => (/* binding */ Cs),\n/* harmony export */   c: () => (/* binding */ Bs),\n/* harmony export */   d: () => (/* binding */ ms),\n/* harmony export */   e: () => (/* binding */ es),\n/* harmony export */   f: () => (/* binding */ Vs),\n/* harmony export */   g: () => (/* binding */ mo),\n/* harmony export */   h: () => (/* binding */ vs),\n/* harmony export */   i: () => (/* binding */ js),\n/* harmony export */   j: () => (/* binding */ ko),\n/* harmony export */   k: () => (/* binding */ Es),\n/* harmony export */   l: () => (/* binding */ _),\n/* harmony export */   m: () => (/* binding */ $o),\n/* harmony export */   n: () => (/* binding */ Yi),\n/* harmony export */   o: () => (/* binding */ po),\n/* harmony export */   p: () => (/* binding */ N),\n/* harmony export */   q: () => (/* binding */ ss),\n/* harmony export */   r: () => (/* binding */ ao),\n/* harmony export */   s: () => (/* binding */ Ps),\n/* harmony export */   t: () => (/* binding */ In),\n/* harmony export */   u: () => (/* binding */ Hs),\n/* harmony export */   v: () => (/* binding */ us),\n/* harmony export */   w: () => (/* binding */ _o),\n/* harmony export */   x: () => (/* binding */ rs),\n/* harmony export */   y: () => (/* binding */ hs),\n/* harmony export */   z: () => (/* binding */ Qo)\n/* harmony export */ });\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\r\n\r\nconst De = Math.min, se = Math.max, $e = Math.round, Le = Math.floor, G = (e) => ({\r\n  x: e,\r\n  y: e\r\n}), Yn = {\r\n  left: \"right\",\r\n  right: \"left\",\r\n  bottom: \"top\",\r\n  top: \"bottom\"\r\n}, qn = {\r\n  start: \"end\",\r\n  end: \"start\"\r\n};\r\nfunction Et(e, t, n) {\r\n  return se(e, De(t, n));\r\n}\r\nfunction He(e, t) {\r\n  return typeof e == \"function\" ? e(t) : e;\r\n}\r\nfunction ae(e) {\r\n  return e.split(\"-\")[0];\r\n}\r\nfunction ze(e) {\r\n  return e.split(\"-\")[1];\r\n}\r\nfunction qt(e) {\r\n  return e === \"x\" ? \"y\" : \"x\";\r\n}\r\nfunction Kt(e) {\r\n  return e === \"y\" ? \"height\" : \"width\";\r\n}\r\nfunction he(e) {\r\n  return [\"top\", \"bottom\"].includes(ae(e)) ? \"y\" : \"x\";\r\n}\r\nfunction Gt(e) {\r\n  return qt(he(e));\r\n}\r\nfunction Kn(e, t, n) {\r\n  n === void 0 && (n = !1);\r\n  const r = ze(e), i = Gt(e), o = Kt(i);\r\n  let s = i === \"x\" ? r === (n ? \"end\" : \"start\") ? \"right\" : \"left\" : r === \"start\" ? \"bottom\" : \"top\";\r\n  return t.reference[o] > t.floating[o] && (s = Ne(s)), [s, Ne(s)];\r\n}\r\nfunction Gn(e) {\r\n  const t = Ne(e);\r\n  return [it(e), t, it(t)];\r\n}\r\nfunction it(e) {\r\n  return e.replace(/start|end/g, (t) => qn[t]);\r\n}\r\nfunction Qn(e, t, n) {\r\n  const r = [\"left\", \"right\"], i = [\"right\", \"left\"], o = [\"top\", \"bottom\"], s = [\"bottom\", \"top\"];\r\n  switch (e) {\r\n    case \"top\":\r\n    case \"bottom\":\r\n      return n ? t ? i : r : t ? r : i;\r\n    case \"left\":\r\n    case \"right\":\r\n      return t ? o : s;\r\n    default:\r\n      return [];\r\n  }\r\n}\r\nfunction Jn(e, t, n, r) {\r\n  const i = ze(e);\r\n  let o = Qn(ae(e), n === \"start\", r);\r\n  return i && (o = o.map((s) => s + \"-\" + i), t && (o = o.concat(o.map(it)))), o;\r\n}\r\nfunction Ne(e) {\r\n  return e.replace(/left|right|bottom|top/g, (t) => Yn[t]);\r\n}\r\nfunction Xn(e) {\r\n  return {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n    ...e\r\n  };\r\n}\r\nfunction Zn(e) {\r\n  return typeof e != \"number\" ? Xn(e) : {\r\n    top: e,\r\n    right: e,\r\n    bottom: e,\r\n    left: e\r\n  };\r\n}\r\nfunction Fe(e) {\r\n  const {\r\n    x: t,\r\n    y: n,\r\n    width: r,\r\n    height: i\r\n  } = e;\r\n  return {\r\n    width: r,\r\n    height: i,\r\n    top: n,\r\n    left: t,\r\n    right: t + r,\r\n    bottom: n + i,\r\n    x: t,\r\n    y: n\r\n  };\r\n}\r\nfunction Ct(e, t, n) {\r\n  let {\r\n    reference: r,\r\n    floating: i\r\n  } = e;\r\n  const o = he(t), s = Gt(t), a = Kt(s), c = ae(t), u = o === \"y\", l = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, v = r[a] / 2 - i[a] / 2;\r\n  let d;\r\n  switch (c) {\r\n    case \"top\":\r\n      d = {\r\n        x: l,\r\n        y: r.y - i.height\r\n      };\r\n      break;\r\n    case \"bottom\":\r\n      d = {\r\n        x: l,\r\n        y: r.y + r.height\r\n      };\r\n      break;\r\n    case \"right\":\r\n      d = {\r\n        x: r.x + r.width,\r\n        y: f\r\n      };\r\n      break;\r\n    case \"left\":\r\n      d = {\r\n        x: r.x - i.width,\r\n        y: f\r\n      };\r\n      break;\r\n    default:\r\n      d = {\r\n        x: r.x,\r\n        y: r.y\r\n      };\r\n  }\r\n  switch (ze(t)) {\r\n    case \"start\":\r\n      d[s] -= v * (n && u ? -1 : 1);\r\n      break;\r\n    case \"end\":\r\n      d[s] += v * (n && u ? -1 : 1);\r\n      break;\r\n  }\r\n  return d;\r\n}\r\nconst er = async (e, t, n) => {\r\n  const {\r\n    placement: r = \"bottom\",\r\n    strategy: i = \"absolute\",\r\n    middleware: o = [],\r\n    platform: s\r\n  } = n, a = o.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));\r\n  let u = await s.getElementRects({\r\n    reference: e,\r\n    floating: t,\r\n    strategy: i\r\n  }), {\r\n    x: l,\r\n    y: f\r\n  } = Ct(u, r, c), v = r, d = {}, m = 0;\r\n  for (let p = 0; p < a.length; p++) {\r\n    const {\r\n      name: g,\r\n      fn: h\r\n    } = a[p], {\r\n      x,\r\n      y: E,\r\n      data: P,\r\n      reset: b\r\n    } = await h({\r\n      x: l,\r\n      y: f,\r\n      initialPlacement: r,\r\n      placement: v,\r\n      strategy: i,\r\n      middlewareData: d,\r\n      rects: u,\r\n      platform: s,\r\n      elements: {\r\n        reference: e,\r\n        floating: t\r\n      }\r\n    });\r\n    l = x ?? l, f = E ?? f, d = {\r\n      ...d,\r\n      [g]: {\r\n        ...d[g],\r\n        ...P\r\n      }\r\n    }, b && m <= 50 && (m++, typeof b == \"object\" && (b.placement && (v = b.placement), b.rects && (u = b.rects === !0 ? await s.getElementRects({\r\n      reference: e,\r\n      floating: t,\r\n      strategy: i\r\n    }) : b.rects), {\r\n      x: l,\r\n      y: f\r\n    } = Ct(u, v, c)), p = -1);\r\n  }\r\n  return {\r\n    x: l,\r\n    y: f,\r\n    placement: v,\r\n    strategy: i,\r\n    middlewareData: d\r\n  };\r\n};\r\nasync function Qt(e, t) {\r\n  var n;\r\n  t === void 0 && (t = {});\r\n  const {\r\n    x: r,\r\n    y: i,\r\n    platform: o,\r\n    rects: s,\r\n    elements: a,\r\n    strategy: c\r\n  } = e, {\r\n    boundary: u = \"clippingAncestors\",\r\n    rootBoundary: l = \"viewport\",\r\n    elementContext: f = \"floating\",\r\n    altBoundary: v = !1,\r\n    padding: d = 0\r\n  } = He(t, e), m = Zn(d), g = a[v ? f === \"floating\" ? \"reference\" : \"floating\" : f], h = Fe(await o.getClippingRect({\r\n    element: (n = await (o.isElement == null ? void 0 : o.isElement(g))) == null || n ? g : g.contextElement || await (o.getDocumentElement == null ? void 0 : o.getDocumentElement(a.floating)),\r\n    boundary: u,\r\n    rootBoundary: l,\r\n    strategy: c\r\n  })), x = f === \"floating\" ? {\r\n    x: r,\r\n    y: i,\r\n    width: s.floating.width,\r\n    height: s.floating.height\r\n  } : s.reference, E = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(a.floating)), P = await (o.isElement == null ? void 0 : o.isElement(E)) ? await (o.getScale == null ? void 0 : o.getScale(E)) || {\r\n    x: 1,\r\n    y: 1\r\n  } : {\r\n    x: 1,\r\n    y: 1\r\n  }, b = Fe(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({\r\n    elements: a,\r\n    rect: x,\r\n    offsetParent: E,\r\n    strategy: c\r\n  }) : x);\r\n  return {\r\n    top: (h.top - b.top + m.top) / P.y,\r\n    bottom: (b.bottom - h.bottom + m.bottom) / P.y,\r\n    left: (h.left - b.left + m.left) / P.x,\r\n    right: (b.right - h.right + m.right) / P.x\r\n  };\r\n}\r\nconst tr = function(e) {\r\n  return e === void 0 && (e = {}), {\r\n    name: \"flip\",\r\n    options: e,\r\n    async fn(t) {\r\n      var n, r;\r\n      const {\r\n        placement: i,\r\n        middlewareData: o,\r\n        rects: s,\r\n        initialPlacement: a,\r\n        platform: c,\r\n        elements: u\r\n      } = t, {\r\n        mainAxis: l = !0,\r\n        crossAxis: f = !0,\r\n        fallbackPlacements: v,\r\n        fallbackStrategy: d = \"bestFit\",\r\n        fallbackAxisSideDirection: m = \"none\",\r\n        flipAlignment: p = !0,\r\n        ...g\r\n      } = He(e, t);\r\n      if ((n = o.arrow) != null && n.alignmentOffset)\r\n        return {};\r\n      const h = ae(i), x = he(a), E = ae(a) === a, P = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), b = v || (E || !p ? [Ne(a)] : Gn(a)), S = m !== \"none\";\r\n      !v && S && b.push(...Jn(a, p, m, P));\r\n      const C = [a, ...b], $ = await Qt(t, g), I = [];\r\n      let z = ((r = o.flip) == null ? void 0 : r.overflows) || [];\r\n      if (l && I.push($[h]), f) {\r\n        const K = Kn(i, s, P);\r\n        I.push($[K[0]], $[K[1]]);\r\n      }\r\n      if (z = [...z, {\r\n        placement: i,\r\n        overflows: I\r\n      }], !I.every((K) => K <= 0)) {\r\n        var T, L;\r\n        const K = (((T = o.flip) == null ? void 0 : T.index) || 0) + 1, ke = C[K];\r\n        if (ke)\r\n          return {\r\n            data: {\r\n              index: K,\r\n              overflows: z\r\n            },\r\n            reset: {\r\n              placement: ke\r\n            }\r\n          };\r\n        let xe = (L = z.filter((fe) => fe.overflows[0] <= 0).sort((fe, te) => fe.overflows[1] - te.overflows[1])[0]) == null ? void 0 : L.placement;\r\n        if (!xe)\r\n          switch (d) {\r\n            case \"bestFit\": {\r\n              var oe;\r\n              const fe = (oe = z.filter((te) => {\r\n                if (S) {\r\n                  const ne = he(te.placement);\r\n                  return ne === x || // Create a bias to the `y` side axis due to horizontal\r\n                  // reading directions favoring greater width.\r\n                  ne === \"y\";\r\n                }\r\n                return !0;\r\n              }).map((te) => [te.placement, te.overflows.filter((ne) => ne > 0).reduce((ne, Bn) => ne + Bn, 0)]).sort((te, ne) => te[1] - ne[1])[0]) == null ? void 0 : oe[0];\r\n              fe && (xe = fe);\r\n              break;\r\n            }\r\n            case \"initialPlacement\":\r\n              xe = a;\r\n              break;\r\n          }\r\n        if (i !== xe)\r\n          return {\r\n            reset: {\r\n              placement: xe\r\n            }\r\n          };\r\n      }\r\n      return {};\r\n    }\r\n  };\r\n};\r\nasync function nr(e, t) {\r\n  const {\r\n    placement: n,\r\n    platform: r,\r\n    elements: i\r\n  } = e, o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = ae(n), a = ze(n), c = he(n) === \"y\", u = [\"left\", \"top\"].includes(s) ? -1 : 1, l = o && c ? -1 : 1, f = He(t, e);\r\n  let {\r\n    mainAxis: v,\r\n    crossAxis: d,\r\n    alignmentAxis: m\r\n  } = typeof f == \"number\" ? {\r\n    mainAxis: f,\r\n    crossAxis: 0,\r\n    alignmentAxis: null\r\n  } : {\r\n    mainAxis: f.mainAxis || 0,\r\n    crossAxis: f.crossAxis || 0,\r\n    alignmentAxis: f.alignmentAxis\r\n  };\r\n  return a && typeof m == \"number\" && (d = a === \"end\" ? m * -1 : m), c ? {\r\n    x: d * l,\r\n    y: v * u\r\n  } : {\r\n    x: v * u,\r\n    y: d * l\r\n  };\r\n}\r\nconst rr = function(e) {\r\n  return e === void 0 && (e = 0), {\r\n    name: \"offset\",\r\n    options: e,\r\n    async fn(t) {\r\n      var n, r;\r\n      const {\r\n        x: i,\r\n        y: o,\r\n        placement: s,\r\n        middlewareData: a\r\n      } = t, c = await nr(t, e);\r\n      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {\r\n        x: i + c.x,\r\n        y: o + c.y,\r\n        data: {\r\n          ...c,\r\n          placement: s\r\n        }\r\n      };\r\n    }\r\n  };\r\n}, ir = function(e) {\r\n  return e === void 0 && (e = {}), {\r\n    name: \"shift\",\r\n    options: e,\r\n    async fn(t) {\r\n      const {\r\n        x: n,\r\n        y: r,\r\n        placement: i\r\n      } = t, {\r\n        mainAxis: o = !0,\r\n        crossAxis: s = !1,\r\n        limiter: a = {\r\n          fn: (g) => {\r\n            let {\r\n              x: h,\r\n              y: x\r\n            } = g;\r\n            return {\r\n              x: h,\r\n              y: x\r\n            };\r\n          }\r\n        },\r\n        ...c\r\n      } = He(e, t), u = {\r\n        x: n,\r\n        y: r\r\n      }, l = await Qt(t, c), f = he(ae(i)), v = qt(f);\r\n      let d = u[v], m = u[f];\r\n      if (o) {\r\n        const g = v === \"y\" ? \"top\" : \"left\", h = v === \"y\" ? \"bottom\" : \"right\", x = d + l[g], E = d - l[h];\r\n        d = Et(x, d, E);\r\n      }\r\n      if (s) {\r\n        const g = f === \"y\" ? \"top\" : \"left\", h = f === \"y\" ? \"bottom\" : \"right\", x = m + l[g], E = m - l[h];\r\n        m = Et(x, m, E);\r\n      }\r\n      const p = a.fn({\r\n        ...t,\r\n        [v]: d,\r\n        [f]: m\r\n      });\r\n      return {\r\n        ...p,\r\n        data: {\r\n          x: p.x - n,\r\n          y: p.y - r,\r\n          enabled: {\r\n            [v]: o,\r\n            [f]: s\r\n          }\r\n        }\r\n      };\r\n    }\r\n  };\r\n};\r\nfunction Ye() {\r\n  return typeof window < \"u\";\r\n}\r\nfunction be(e) {\r\n  return Jt(e) ? (e.nodeName || \"\").toLowerCase() : \"#document\";\r\n}\r\nfunction U(e) {\r\n  var t;\r\n  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\r\n}\r\nfunction J(e) {\r\n  var t;\r\n  return (t = (Jt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;\r\n}\r\nfunction Jt(e) {\r\n  return Ye() ? e instanceof Node || e instanceof U(e).Node : !1;\r\n}\r\nfunction Y(e) {\r\n  return Ye() ? e instanceof Element || e instanceof U(e).Element : !1;\r\n}\r\nfunction Q(e) {\r\n  return Ye() ? e instanceof HTMLElement || e instanceof U(e).HTMLElement : !1;\r\n}\r\nfunction Pt(e) {\r\n  return !Ye() || typeof ShadowRoot > \"u\" ? !1 : e instanceof ShadowRoot || e instanceof U(e).ShadowRoot;\r\n}\r\nfunction Ae(e) {\r\n  const {\r\n    overflow: t,\r\n    overflowX: n,\r\n    overflowY: r,\r\n    display: i\r\n  } = q(e);\r\n  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && ![\"inline\", \"contents\"].includes(i);\r\n}\r\nfunction or(e) {\r\n  return [\"table\", \"td\", \"th\"].includes(be(e));\r\n}\r\nfunction qe(e) {\r\n  return [\":popover-open\", \":modal\"].some((t) => {\r\n    try {\r\n      return e.matches(t);\r\n    } catch {\r\n      return !1;\r\n    }\r\n  });\r\n}\r\nfunction ft(e) {\r\n  const t = dt(), n = Y(e) ? q(e) : e;\r\n  return [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"].some((r) => n[r] ? n[r] !== \"none\" : !1) || (n.containerType ? n.containerType !== \"normal\" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !t && (n.filter ? n.filter !== \"none\" : !1) || [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"].some((r) => (n.willChange || \"\").includes(r)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((r) => (n.contain || \"\").includes(r));\r\n}\r\nfunction sr(e) {\r\n  let t = ie(e);\r\n  for (; Q(t) && !ve(t); ) {\r\n    if (ft(t))\r\n      return t;\r\n    if (qe(t))\r\n      return null;\r\n    t = ie(t);\r\n  }\r\n  return null;\r\n}\r\nfunction dt() {\r\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\r\n}\r\nfunction ve(e) {\r\n  return [\"html\", \"body\", \"#document\"].includes(be(e));\r\n}\r\nfunction q(e) {\r\n  return U(e).getComputedStyle(e);\r\n}\r\nfunction Ke(e) {\r\n  return Y(e) ? {\r\n    scrollLeft: e.scrollLeft,\r\n    scrollTop: e.scrollTop\r\n  } : {\r\n    scrollLeft: e.scrollX,\r\n    scrollTop: e.scrollY\r\n  };\r\n}\r\nfunction ie(e) {\r\n  if (be(e) === \"html\")\r\n    return e;\r\n  const t = (\r\n    // Step into the shadow DOM of the parent of a slotted node.\r\n    e.assignedSlot || // DOM Element detected.\r\n    e.parentNode || // ShadowRoot detected.\r\n    Pt(e) && e.host || // Fallback.\r\n    J(e)\r\n  );\r\n  return Pt(t) ? t.host : t;\r\n}\r\nfunction Xt(e) {\r\n  const t = ie(e);\r\n  return ve(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Q(t) && Ae(t) ? t : Xt(t);\r\n}\r\nfunction Ee(e, t, n) {\r\n  var r;\r\n  t === void 0 && (t = []), n === void 0 && (n = !0);\r\n  const i = Xt(e), o = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = U(i);\r\n  if (o) {\r\n    const a = ot(s);\r\n    return t.concat(s, s.visualViewport || [], Ae(i) ? i : [], a && n ? Ee(a) : []);\r\n  }\r\n  return t.concat(i, Ee(i, [], n));\r\n}\r\nfunction ot(e) {\r\n  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;\r\n}\r\nfunction Zt(e) {\r\n  const t = q(e);\r\n  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;\r\n  const i = Q(e), o = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, a = $e(n) !== o || $e(r) !== s;\r\n  return a && (n = o, r = s), {\r\n    width: n,\r\n    height: r,\r\n    $: a\r\n  };\r\n}\r\nfunction pt(e) {\r\n  return Y(e) ? e : e.contextElement;\r\n}\r\nfunction de(e) {\r\n  const t = pt(e);\r\n  if (!Q(t))\r\n    return G(1);\r\n  const n = t.getBoundingClientRect(), {\r\n    width: r,\r\n    height: i,\r\n    $: o\r\n  } = Zt(t);\r\n  let s = (o ? $e(n.width) : n.width) / r, a = (o ? $e(n.height) : n.height) / i;\r\n  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {\r\n    x: s,\r\n    y: a\r\n  };\r\n}\r\nconst ar = /* @__PURE__ */ G(0);\r\nfunction en(e) {\r\n  const t = U(e);\r\n  return !dt() || !t.visualViewport ? ar : {\r\n    x: t.visualViewport.offsetLeft,\r\n    y: t.visualViewport.offsetTop\r\n  };\r\n}\r\nfunction cr(e, t, n) {\r\n  return t === void 0 && (t = !1), !n || t && n !== U(e) ? !1 : t;\r\n}\r\nfunction ce(e, t, n, r) {\r\n  t === void 0 && (t = !1), n === void 0 && (n = !1);\r\n  const i = e.getBoundingClientRect(), o = pt(e);\r\n  let s = G(1);\r\n  t && (r ? Y(r) && (s = de(r)) : s = de(e));\r\n  const a = cr(o, n, r) ? en(o) : G(0);\r\n  let c = (i.left + a.x) / s.x, u = (i.top + a.y) / s.y, l = i.width / s.x, f = i.height / s.y;\r\n  if (o) {\r\n    const v = U(o), d = r && Y(r) ? U(r) : r;\r\n    let m = v, p = ot(m);\r\n    for (; p && r && d !== m; ) {\r\n      const g = de(p), h = p.getBoundingClientRect(), x = q(p), E = h.left + (p.clientLeft + parseFloat(x.paddingLeft)) * g.x, P = h.top + (p.clientTop + parseFloat(x.paddingTop)) * g.y;\r\n      c *= g.x, u *= g.y, l *= g.x, f *= g.y, c += E, u += P, m = U(p), p = ot(m);\r\n    }\r\n  }\r\n  return Fe({\r\n    width: l,\r\n    height: f,\r\n    x: c,\r\n    y: u\r\n  });\r\n}\r\nfunction ht(e, t) {\r\n  const n = Ke(e).scrollLeft;\r\n  return t ? t.left + n : ce(J(e)).left + n;\r\n}\r\nfunction tn(e, t, n) {\r\n  n === void 0 && (n = !1);\r\n  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (\r\n    // RTL <body> scrollbar.\r\n    ht(e, r)\r\n  )), o = r.top + t.scrollTop;\r\n  return {\r\n    x: i,\r\n    y: o\r\n  };\r\n}\r\nfunction ur(e) {\r\n  let {\r\n    elements: t,\r\n    rect: n,\r\n    offsetParent: r,\r\n    strategy: i\r\n  } = e;\r\n  const o = i === \"fixed\", s = J(r), a = t ? qe(t.floating) : !1;\r\n  if (r === s || a && o)\r\n    return n;\r\n  let c = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  }, u = G(1);\r\n  const l = G(0), f = Q(r);\r\n  if ((f || !f && !o) && ((be(r) !== \"body\" || Ae(s)) && (c = Ke(r)), Q(r))) {\r\n    const d = ce(r);\r\n    u = de(r), l.x = d.x + r.clientLeft, l.y = d.y + r.clientTop;\r\n  }\r\n  const v = s && !f && !o ? tn(s, c, !0) : G(0);\r\n  return {\r\n    width: n.width * u.x,\r\n    height: n.height * u.y,\r\n    x: n.x * u.x - c.scrollLeft * u.x + l.x + v.x,\r\n    y: n.y * u.y - c.scrollTop * u.y + l.y + v.y\r\n  };\r\n}\r\nfunction lr(e) {\r\n  return Array.from(e.getClientRects());\r\n}\r\nfunction fr(e) {\r\n  const t = J(e), n = Ke(e), r = e.ownerDocument.body, i = se(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = se(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);\r\n  let s = -n.scrollLeft + ht(e);\r\n  const a = -n.scrollTop;\r\n  return q(r).direction === \"rtl\" && (s += se(t.clientWidth, r.clientWidth) - i), {\r\n    width: i,\r\n    height: o,\r\n    x: s,\r\n    y: a\r\n  };\r\n}\r\nfunction dr(e, t) {\r\n  const n = U(e), r = J(e), i = n.visualViewport;\r\n  let o = r.clientWidth, s = r.clientHeight, a = 0, c = 0;\r\n  if (i) {\r\n    o = i.width, s = i.height;\r\n    const u = dt();\r\n    (!u || u && t === \"fixed\") && (a = i.offsetLeft, c = i.offsetTop);\r\n  }\r\n  return {\r\n    width: o,\r\n    height: s,\r\n    x: a,\r\n    y: c\r\n  };\r\n}\r\nfunction pr(e, t) {\r\n  const n = ce(e, !0, t === \"fixed\"), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Q(e) ? de(e) : G(1), s = e.clientWidth * o.x, a = e.clientHeight * o.y, c = i * o.x, u = r * o.y;\r\n  return {\r\n    width: s,\r\n    height: a,\r\n    x: c,\r\n    y: u\r\n  };\r\n}\r\nfunction At(e, t, n) {\r\n  let r;\r\n  if (t === \"viewport\")\r\n    r = dr(e, n);\r\n  else if (t === \"document\")\r\n    r = fr(J(e));\r\n  else if (Y(t))\r\n    r = pr(t, n);\r\n  else {\r\n    const i = en(e);\r\n    r = {\r\n      x: t.x - i.x,\r\n      y: t.y - i.y,\r\n      width: t.width,\r\n      height: t.height\r\n    };\r\n  }\r\n  return Fe(r);\r\n}\r\nfunction nn(e, t) {\r\n  const n = ie(e);\r\n  return n === t || !Y(n) || ve(n) ? !1 : q(n).position === \"fixed\" || nn(n, t);\r\n}\r\nfunction hr(e, t) {\r\n  const n = t.get(e);\r\n  if (n)\r\n    return n;\r\n  let r = Ee(e, [], !1).filter((a) => Y(a) && be(a) !== \"body\"), i = null;\r\n  const o = q(e).position === \"fixed\";\r\n  let s = o ? ie(e) : e;\r\n  for (; Y(s) && !ve(s); ) {\r\n    const a = q(s), c = ft(s);\r\n    !c && a.position === \"fixed\" && (i = null), (o ? !c && !i : !c && a.position === \"static\" && !!i && [\"absolute\", \"fixed\"].includes(i.position) || Ae(s) && !c && nn(e, s)) ? r = r.filter((l) => l !== s) : i = a, s = ie(s);\r\n  }\r\n  return t.set(e, r), r;\r\n}\r\nfunction vr(e) {\r\n  let {\r\n    element: t,\r\n    boundary: n,\r\n    rootBoundary: r,\r\n    strategy: i\r\n  } = e;\r\n  const s = [...n === \"clippingAncestors\" ? qe(t) ? [] : hr(t, this._c) : [].concat(n), r], a = s[0], c = s.reduce((u, l) => {\r\n    const f = At(t, l, i);\r\n    return u.top = se(f.top, u.top), u.right = De(f.right, u.right), u.bottom = De(f.bottom, u.bottom), u.left = se(f.left, u.left), u;\r\n  }, At(t, a, i));\r\n  return {\r\n    width: c.right - c.left,\r\n    height: c.bottom - c.top,\r\n    x: c.left,\r\n    y: c.top\r\n  };\r\n}\r\nfunction mr(e) {\r\n  const {\r\n    width: t,\r\n    height: n\r\n  } = Zt(e);\r\n  return {\r\n    width: t,\r\n    height: n\r\n  };\r\n}\r\nfunction gr(e, t, n) {\r\n  const r = Q(t), i = J(t), o = n === \"fixed\", s = ce(e, !0, o, t);\r\n  let a = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  };\r\n  const c = G(0);\r\n  if (r || !r && !o)\r\n    if ((be(t) !== \"body\" || Ae(i)) && (a = Ke(t)), r) {\r\n      const v = ce(t, !0, o, t);\r\n      c.x = v.x + t.clientLeft, c.y = v.y + t.clientTop;\r\n    } else i && (c.x = ht(i));\r\n  const u = i && !r && !o ? tn(i, a) : G(0), l = s.left + a.scrollLeft - c.x - u.x, f = s.top + a.scrollTop - c.y - u.y;\r\n  return {\r\n    x: l,\r\n    y: f,\r\n    width: s.width,\r\n    height: s.height\r\n  };\r\n}\r\nfunction Xe(e) {\r\n  return q(e).position === \"static\";\r\n}\r\nfunction Ot(e, t) {\r\n  if (!Q(e) || q(e).position === \"fixed\")\r\n    return null;\r\n  if (t)\r\n    return t(e);\r\n  let n = e.offsetParent;\r\n  return J(e) === n && (n = n.ownerDocument.body), n;\r\n}\r\nfunction rn(e, t) {\r\n  const n = U(e);\r\n  if (qe(e))\r\n    return n;\r\n  if (!Q(e)) {\r\n    let i = ie(e);\r\n    for (; i && !ve(i); ) {\r\n      if (Y(i) && !Xe(i))\r\n        return i;\r\n      i = ie(i);\r\n    }\r\n    return n;\r\n  }\r\n  let r = Ot(e, t);\r\n  for (; r && or(r) && Xe(r); )\r\n    r = Ot(r, t);\r\n  return r && ve(r) && Xe(r) && !ft(r) ? n : r || sr(e) || n;\r\n}\r\nconst br = async function(e) {\r\n  const t = this.getOffsetParent || rn, n = this.getDimensions, r = await n(e.floating);\r\n  return {\r\n    reference: gr(e.reference, await t(e.floating), e.strategy),\r\n    floating: {\r\n      x: 0,\r\n      y: 0,\r\n      width: r.width,\r\n      height: r.height\r\n    }\r\n  };\r\n};\r\nfunction yr(e) {\r\n  return q(e).direction === \"rtl\";\r\n}\r\nconst wr = {\r\n  convertOffsetParentRelativeRectToViewportRelativeRect: ur,\r\n  getDocumentElement: J,\r\n  getClippingRect: vr,\r\n  getOffsetParent: rn,\r\n  getElementRects: br,\r\n  getClientRects: lr,\r\n  getDimensions: mr,\r\n  getScale: de,\r\n  isElement: Y,\r\n  isRTL: yr\r\n};\r\nfunction on(e, t) {\r\n  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;\r\n}\r\nfunction xr(e, t) {\r\n  let n = null, r;\r\n  const i = J(e);\r\n  function o() {\r\n    var a;\r\n    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;\r\n  }\r\n  function s(a, c) {\r\n    a === void 0 && (a = !1), c === void 0 && (c = 1), o();\r\n    const u = e.getBoundingClientRect(), {\r\n      left: l,\r\n      top: f,\r\n      width: v,\r\n      height: d\r\n    } = u;\r\n    if (a || t(), !v || !d)\r\n      return;\r\n    const m = Le(f), p = Le(i.clientWidth - (l + v)), g = Le(i.clientHeight - (f + d)), h = Le(l), E = {\r\n      rootMargin: -m + \"px \" + -p + \"px \" + -g + \"px \" + -h + \"px\",\r\n      threshold: se(0, De(1, c)) || 1\r\n    };\r\n    let P = !0;\r\n    function b(S) {\r\n      const C = S[0].intersectionRatio;\r\n      if (C !== c) {\r\n        if (!P)\r\n          return s();\r\n        C ? s(!1, C) : r = setTimeout(() => {\r\n          s(!1, 1e-7);\r\n        }, 1e3);\r\n      }\r\n      C === 1 && !on(u, e.getBoundingClientRect()) && s(), P = !1;\r\n    }\r\n    try {\r\n      n = new IntersectionObserver(b, {\r\n        ...E,\r\n        // Handle <iframe>s\r\n        root: i.ownerDocument\r\n      });\r\n    } catch {\r\n      n = new IntersectionObserver(b, E);\r\n    }\r\n    n.observe(e);\r\n  }\r\n  return s(!0), o;\r\n}\r\nfunction Sr(e, t, n, r) {\r\n  r === void 0 && (r = {});\r\n  const {\r\n    ancestorScroll: i = !0,\r\n    ancestorResize: o = !0,\r\n    elementResize: s = typeof ResizeObserver == \"function\",\r\n    layoutShift: a = typeof IntersectionObserver == \"function\",\r\n    animationFrame: c = !1\r\n  } = r, u = pt(e), l = i || o ? [...u ? Ee(u) : [], ...Ee(t)] : [];\r\n  l.forEach((h) => {\r\n    i && h.addEventListener(\"scroll\", n, {\r\n      passive: !0\r\n    }), o && h.addEventListener(\"resize\", n);\r\n  });\r\n  const f = u && a ? xr(u, n) : null;\r\n  let v = -1, d = null;\r\n  s && (d = new ResizeObserver((h) => {\r\n    let [x] = h;\r\n    x && x.target === u && d && (d.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {\r\n      var E;\r\n      (E = d) == null || E.observe(t);\r\n    })), n();\r\n  }), u && !c && d.observe(u), d.observe(t));\r\n  let m, p = c ? ce(e) : null;\r\n  c && g();\r\n  function g() {\r\n    const h = ce(e);\r\n    p && !on(p, h) && n(), p = h, m = requestAnimationFrame(g);\r\n  }\r\n  return n(), () => {\r\n    var h;\r\n    l.forEach((x) => {\r\n      i && x.removeEventListener(\"scroll\", n), o && x.removeEventListener(\"resize\", n);\r\n    }), f == null || f(), (h = d) == null || h.disconnect(), d = null, c && cancelAnimationFrame(m);\r\n  };\r\n}\r\nconst Tr = rr, Er = ir, Cr = tr, Pr = (e, t, n) => {\r\n  const r = /* @__PURE__ */ new Map(), i = {\r\n    platform: wr,\r\n    ...n\r\n  }, o = {\r\n    ...i.platform,\r\n    _c: r\r\n  };\r\n  return er(e, t, {\r\n    ...i,\r\n    platform: o\r\n  });\r\n};\r\nvar Mo = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\r\nfunction Ar(e) {\r\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\r\n}\r\nvar Re = { exports: {} }, Or = Re.exports, kt;\r\nfunction kr() {\r\n  return kt || (kt = 1, function(e) {\r\n    (function(t, n) {\r\n      e.exports ? e.exports = n() : t.log = n();\r\n    })(Or, function() {\r\n      var t = function() {\r\n      }, n = \"undefined\", r = typeof window !== n && typeof window.navigator !== n && /Trident\\/|MSIE /.test(window.navigator.userAgent), i = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n      ], o = {}, s = null;\r\n      function a(p, g) {\r\n        var h = p[g];\r\n        if (typeof h.bind == \"function\")\r\n          return h.bind(p);\r\n        try {\r\n          return Function.prototype.bind.call(h, p);\r\n        } catch {\r\n          return function() {\r\n            return Function.prototype.apply.apply(h, [p, arguments]);\r\n          };\r\n        }\r\n      }\r\n      function c() {\r\n        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();\r\n      }\r\n      function u(p) {\r\n        return p === \"debug\" && (p = \"log\"), typeof console === n ? !1 : p === \"trace\" && r ? c : console[p] !== void 0 ? a(console, p) : console.log !== void 0 ? a(console, \"log\") : t;\r\n      }\r\n      function l() {\r\n        for (var p = this.getLevel(), g = 0; g < i.length; g++) {\r\n          var h = i[g];\r\n          this[h] = g < p ? t : this.methodFactory(h, p, this.name);\r\n        }\r\n        if (this.log = this.debug, typeof console === n && p < this.levels.SILENT)\r\n          return \"No console available for logging\";\r\n      }\r\n      function f(p) {\r\n        return function() {\r\n          typeof console !== n && (l.call(this), this[p].apply(this, arguments));\r\n        };\r\n      }\r\n      function v(p, g, h) {\r\n        return u(p) || f.apply(this, arguments);\r\n      }\r\n      function d(p, g) {\r\n        var h = this, x, E, P, b = \"loglevel\";\r\n        typeof p == \"string\" ? b += \":\" + p : typeof p == \"symbol\" && (b = void 0);\r\n        function S(T) {\r\n          var L = (i[T] || \"silent\").toUpperCase();\r\n          if (!(typeof window === n || !b)) {\r\n            try {\r\n              window.localStorage[b] = L;\r\n              return;\r\n            } catch {\r\n            }\r\n            try {\r\n              window.document.cookie = encodeURIComponent(b) + \"=\" + L + \";\";\r\n            } catch {\r\n            }\r\n          }\r\n        }\r\n        function C() {\r\n          var T;\r\n          if (!(typeof window === n || !b)) {\r\n            try {\r\n              T = window.localStorage[b];\r\n            } catch {\r\n            }\r\n            if (typeof T === n)\r\n              try {\r\n                var L = window.document.cookie, oe = encodeURIComponent(b), K = L.indexOf(oe + \"=\");\r\n                K !== -1 && (T = /^([^;]+)/.exec(\r\n                  L.slice(K + oe.length + 1)\r\n                )[1]);\r\n              } catch {\r\n              }\r\n            return h.levels[T] === void 0 && (T = void 0), T;\r\n          }\r\n        }\r\n        function $() {\r\n          if (!(typeof window === n || !b)) {\r\n            try {\r\n              window.localStorage.removeItem(b);\r\n            } catch {\r\n            }\r\n            try {\r\n              window.document.cookie = encodeURIComponent(b) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\r\n            } catch {\r\n            }\r\n          }\r\n        }\r\n        function I(T) {\r\n          var L = T;\r\n          if (typeof L == \"string\" && h.levels[L.toUpperCase()] !== void 0 && (L = h.levels[L.toUpperCase()]), typeof L == \"number\" && L >= 0 && L <= h.levels.SILENT)\r\n            return L;\r\n          throw new TypeError(\"log.setLevel() called with invalid level: \" + T);\r\n        }\r\n        h.name = p, h.levels = {\r\n          TRACE: 0,\r\n          DEBUG: 1,\r\n          INFO: 2,\r\n          WARN: 3,\r\n          ERROR: 4,\r\n          SILENT: 5\r\n        }, h.methodFactory = g || v, h.getLevel = function() {\r\n          return P ?? E ?? x;\r\n        }, h.setLevel = function(T, L) {\r\n          return P = I(T), L !== !1 && S(P), l.call(h);\r\n        }, h.setDefaultLevel = function(T) {\r\n          E = I(T), C() || h.setLevel(T, !1);\r\n        }, h.resetLevel = function() {\r\n          P = null, $(), l.call(h);\r\n        }, h.enableAll = function(T) {\r\n          h.setLevel(h.levels.TRACE, T);\r\n        }, h.disableAll = function(T) {\r\n          h.setLevel(h.levels.SILENT, T);\r\n        }, h.rebuild = function() {\r\n          if (s !== h && (x = I(s.getLevel())), l.call(h), s === h)\r\n            for (var T in o)\r\n              o[T].rebuild();\r\n        }, x = I(\r\n          s ? s.getLevel() : \"WARN\"\r\n        );\r\n        var z = C();\r\n        z != null && (P = I(z)), l.call(h);\r\n      }\r\n      s = new d(), s.getLogger = function(g) {\r\n        if (typeof g != \"symbol\" && typeof g != \"string\" || g === \"\")\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        var h = o[g];\r\n        return h || (h = o[g] = new d(\r\n          g,\r\n          s.methodFactory\r\n        )), h;\r\n      };\r\n      var m = typeof window !== n ? window.log : void 0;\r\n      return s.noConflict = function() {\r\n        return typeof window !== n && window.log === s && (window.log = m), s;\r\n      }, s.getLoggers = function() {\r\n        return o;\r\n      }, s.default = s, s;\r\n    });\r\n  }(Re)), Re.exports;\r\n}\r\nvar Lr = kr();\r\nconst _r = /* @__PURE__ */ Ar(Lr);\r\nvar st = function(e, t) {\r\n  return st = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {\r\n    n.__proto__ = r;\r\n  } || function(n, r) {\r\n    for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);\r\n  }, st(e, t);\r\n};\r\nfunction ee(e, t) {\r\n  if (typeof t != \"function\" && t !== null)\r\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\r\n  st(e, t);\r\n  function n() {\r\n    this.constructor = e;\r\n  }\r\n  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());\r\n}\r\nfunction Ir(e, t, n, r) {\r\n  function i(o) {\r\n    return o instanceof n ? o : new n(function(s) {\r\n      s(o);\r\n    });\r\n  }\r\n  return new (n || (n = Promise))(function(o, s) {\r\n    function a(l) {\r\n      try {\r\n        u(r.next(l));\r\n      } catch (f) {\r\n        s(f);\r\n      }\r\n    }\r\n    function c(l) {\r\n      try {\r\n        u(r.throw(l));\r\n      } catch (f) {\r\n        s(f);\r\n      }\r\n    }\r\n    function u(l) {\r\n      l.done ? o(l.value) : i(l.value).then(a, c);\r\n    }\r\n    u((r = r.apply(e, t || [])).next());\r\n  });\r\n}\r\nfunction sn(e, t) {\r\n  var n = { label: 0, sent: function() {\r\n    if (o[0] & 1) throw o[1];\r\n    return o[1];\r\n  }, trys: [], ops: [] }, r, i, o, s = Object.create((typeof Iterator == \"function\" ? Iterator : Object).prototype);\r\n  return s.next = a(0), s.throw = a(1), s.return = a(2), typeof Symbol == \"function\" && (s[Symbol.iterator] = function() {\r\n    return this;\r\n  }), s;\r\n  function a(u) {\r\n    return function(l) {\r\n      return c([u, l]);\r\n    };\r\n  }\r\n  function c(u) {\r\n    if (r) throw new TypeError(\"Generator is already executing.\");\r\n    for (; s && (s = 0, u[0] && (n = 0)), n; ) try {\r\n      if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done) return o;\r\n      switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {\r\n        case 0:\r\n        case 1:\r\n          o = u;\r\n          break;\r\n        case 4:\r\n          return n.label++, { value: u[1], done: !1 };\r\n        case 5:\r\n          n.label++, i = u[1], u = [0];\r\n          continue;\r\n        case 7:\r\n          u = n.ops.pop(), n.trys.pop();\r\n          continue;\r\n        default:\r\n          if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {\r\n            n = 0;\r\n            continue;\r\n          }\r\n          if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {\r\n            n.label = u[1];\r\n            break;\r\n          }\r\n          if (u[0] === 6 && n.label < o[1]) {\r\n            n.label = o[1], o = u;\r\n            break;\r\n          }\r\n          if (o && n.label < o[2]) {\r\n            n.label = o[2], n.ops.push(u);\r\n            break;\r\n          }\r\n          o[2] && n.ops.pop(), n.trys.pop();\r\n          continue;\r\n      }\r\n      u = t.call(e, n);\r\n    } catch (l) {\r\n      u = [6, l], i = 0;\r\n    } finally {\r\n      r = o = 0;\r\n    }\r\n    if (u[0] & 5) throw u[1];\r\n    return { value: u[0] ? u[1] : void 0, done: !0 };\r\n  }\r\n}\r\nfunction me(e) {\r\n  var t = typeof Symbol == \"function\" && Symbol.iterator, n = t && e[t], r = 0;\r\n  if (n) return n.call(e);\r\n  if (e && typeof e.length == \"number\") return {\r\n    next: function() {\r\n      return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };\r\n    }\r\n  };\r\n  throw new TypeError(t ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\nfunction ue(e, t) {\r\n  var n = typeof Symbol == \"function\" && e[Symbol.iterator];\r\n  if (!n) return e;\r\n  var r = n.call(e), i, o = [], s;\r\n  try {\r\n    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) o.push(i.value);\r\n  } catch (a) {\r\n    s = { error: a };\r\n  } finally {\r\n    try {\r\n      i && !i.done && (n = r.return) && n.call(r);\r\n    } finally {\r\n      if (s) throw s.error;\r\n    }\r\n  }\r\n  return o;\r\n}\r\nfunction ge(e, t, n) {\r\n  if (n || arguments.length === 2) for (var r = 0, i = t.length, o; r < i; r++)\r\n    (o || !(r in t)) && (o || (o = Array.prototype.slice.call(t, 0, r)), o[r] = t[r]);\r\n  return e.concat(o || Array.prototype.slice.call(t));\r\n}\r\nfunction pe(e) {\r\n  return this instanceof pe ? (this.v = e, this) : new pe(e);\r\n}\r\nfunction Rr(e, t, n) {\r\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n  var r = n.apply(e, t || []), i, o = [];\r\n  return i = Object.create((typeof AsyncIterator == \"function\" ? AsyncIterator : Object).prototype), a(\"next\"), a(\"throw\"), a(\"return\", s), i[Symbol.asyncIterator] = function() {\r\n    return this;\r\n  }, i;\r\n  function s(d) {\r\n    return function(m) {\r\n      return Promise.resolve(m).then(d, f);\r\n    };\r\n  }\r\n  function a(d, m) {\r\n    r[d] && (i[d] = function(p) {\r\n      return new Promise(function(g, h) {\r\n        o.push([d, p, g, h]) > 1 || c(d, p);\r\n      });\r\n    }, m && (i[d] = m(i[d])));\r\n  }\r\n  function c(d, m) {\r\n    try {\r\n      u(r[d](m));\r\n    } catch (p) {\r\n      v(o[0][3], p);\r\n    }\r\n  }\r\n  function u(d) {\r\n    d.value instanceof pe ? Promise.resolve(d.value.v).then(l, f) : v(o[0][2], d);\r\n  }\r\n  function l(d) {\r\n    c(\"next\", d);\r\n  }\r\n  function f(d) {\r\n    c(\"throw\", d);\r\n  }\r\n  function v(d, m) {\r\n    d(m), o.shift(), o.length && c(o[0][0], o[0][1]);\r\n  }\r\n}\r\nfunction Mr(e) {\r\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n  var t = e[Symbol.asyncIterator], n;\r\n  return t ? t.call(e) : (e = typeof me == \"function\" ? me(e) : e[Symbol.iterator](), n = {}, r(\"next\"), r(\"throw\"), r(\"return\"), n[Symbol.asyncIterator] = function() {\r\n    return this;\r\n  }, n);\r\n  function r(o) {\r\n    n[o] = e[o] && function(s) {\r\n      return new Promise(function(a, c) {\r\n        s = e[o](s), i(a, c, s.done, s.value);\r\n      });\r\n    };\r\n  }\r\n  function i(o, s, a, c) {\r\n    Promise.resolve(c).then(function(u) {\r\n      o({ value: u, done: a });\r\n    }, s);\r\n  }\r\n}\r\nfunction A(e) {\r\n  return typeof e == \"function\";\r\n}\r\nfunction vt(e) {\r\n  var t = function(r) {\r\n    Error.call(r), r.stack = new Error().stack;\r\n  }, n = e(t);\r\n  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;\r\n}\r\nvar Ze = vt(function(e) {\r\n  return function(n) {\r\n    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:\r\n` + n.map(function(r, i) {\r\n      return i + 1 + \") \" + r.toString();\r\n    }).join(`\r\n  `) : \"\", this.name = \"UnsubscriptionError\", this.errors = n;\r\n  };\r\n});\r\nfunction Ue(e, t) {\r\n  if (e) {\r\n    var n = e.indexOf(t);\r\n    0 <= n && e.splice(n, 1);\r\n  }\r\n}\r\nvar Oe = function() {\r\n  function e(t) {\r\n    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;\r\n  }\r\n  return e.prototype.unsubscribe = function() {\r\n    var t, n, r, i, o;\r\n    if (!this.closed) {\r\n      this.closed = !0;\r\n      var s = this._parentage;\r\n      if (s)\r\n        if (this._parentage = null, Array.isArray(s))\r\n          try {\r\n            for (var a = me(s), c = a.next(); !c.done; c = a.next()) {\r\n              var u = c.value;\r\n              u.remove(this);\r\n            }\r\n          } catch (p) {\r\n            t = { error: p };\r\n          } finally {\r\n            try {\r\n              c && !c.done && (n = a.return) && n.call(a);\r\n            } finally {\r\n              if (t) throw t.error;\r\n            }\r\n          }\r\n        else\r\n          s.remove(this);\r\n      var l = this.initialTeardown;\r\n      if (A(l))\r\n        try {\r\n          l();\r\n        } catch (p) {\r\n          o = p instanceof Ze ? p.errors : [p];\r\n        }\r\n      var f = this._finalizers;\r\n      if (f) {\r\n        this._finalizers = null;\r\n        try {\r\n          for (var v = me(f), d = v.next(); !d.done; d = v.next()) {\r\n            var m = d.value;\r\n            try {\r\n              Lt(m);\r\n            } catch (p) {\r\n              o = o ?? [], p instanceof Ze ? o = ge(ge([], ue(o)), ue(p.errors)) : o.push(p);\r\n            }\r\n          }\r\n        } catch (p) {\r\n          r = { error: p };\r\n        } finally {\r\n          try {\r\n            d && !d.done && (i = v.return) && i.call(v);\r\n          } finally {\r\n            if (r) throw r.error;\r\n          }\r\n        }\r\n      }\r\n      if (o)\r\n        throw new Ze(o);\r\n    }\r\n  }, e.prototype.add = function(t) {\r\n    var n;\r\n    if (t && t !== this)\r\n      if (this.closed)\r\n        Lt(t);\r\n      else {\r\n        if (t instanceof e) {\r\n          if (t.closed || t._hasParent(this))\r\n            return;\r\n          t._addParent(this);\r\n        }\r\n        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);\r\n      }\r\n  }, e.prototype._hasParent = function(t) {\r\n    var n = this._parentage;\r\n    return n === t || Array.isArray(n) && n.includes(t);\r\n  }, e.prototype._addParent = function(t) {\r\n    var n = this._parentage;\r\n    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;\r\n  }, e.prototype._removeParent = function(t) {\r\n    var n = this._parentage;\r\n    n === t ? this._parentage = null : Array.isArray(n) && Ue(n, t);\r\n  }, e.prototype.remove = function(t) {\r\n    var n = this._finalizers;\r\n    n && Ue(n, t), t instanceof e && t._removeParent(this);\r\n  }, e.EMPTY = function() {\r\n    var t = new e();\r\n    return t.closed = !0, t;\r\n  }(), e;\r\n}(), an = Oe.EMPTY;\r\nfunction cn(e) {\r\n  return e instanceof Oe || e && \"closed\" in e && A(e.remove) && A(e.add) && A(e.unsubscribe);\r\n}\r\nfunction Lt(e) {\r\n  A(e) ? e() : e.unsubscribe();\r\n}\r\nvar Dr = {\r\n  Promise: void 0\r\n}, $r = {\r\n  setTimeout: function(e, t) {\r\n    for (var n = [], r = 2; r < arguments.length; r++)\r\n      n[r - 2] = arguments[r];\r\n    return setTimeout.apply(void 0, ge([e, t], ue(n)));\r\n  },\r\n  clearTimeout: function(e) {\r\n    return clearTimeout(e);\r\n  },\r\n  delegate: void 0\r\n};\r\nfunction un(e) {\r\n  $r.setTimeout(function() {\r\n    throw e;\r\n  });\r\n}\r\nfunction je() {\r\n}\r\nfunction Me(e) {\r\n  e();\r\n}\r\nvar mt = function(e) {\r\n  ee(t, e);\r\n  function t(n) {\r\n    var r = e.call(this) || this;\r\n    return r.isStopped = !1, n ? (r.destination = n, cn(n) && n.add(r)) : r.destination = Ur, r;\r\n  }\r\n  return t.create = function(n, r, i) {\r\n    return new Ce(n, r, i);\r\n  }, t.prototype.next = function(n) {\r\n    this.isStopped || this._next(n);\r\n  }, t.prototype.error = function(n) {\r\n    this.isStopped || (this.isStopped = !0, this._error(n));\r\n  }, t.prototype.complete = function() {\r\n    this.isStopped || (this.isStopped = !0, this._complete());\r\n  }, t.prototype.unsubscribe = function() {\r\n    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);\r\n  }, t.prototype._next = function(n) {\r\n    this.destination.next(n);\r\n  }, t.prototype._error = function(n) {\r\n    try {\r\n      this.destination.error(n);\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }, t.prototype._complete = function() {\r\n    try {\r\n      this.destination.complete();\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }, t;\r\n}(Oe), Nr = function() {\r\n  function e(t) {\r\n    this.partialObserver = t;\r\n  }\r\n  return e.prototype.next = function(t) {\r\n    var n = this.partialObserver;\r\n    if (n.next)\r\n      try {\r\n        n.next(t);\r\n      } catch (r) {\r\n        _e(r);\r\n      }\r\n  }, e.prototype.error = function(t) {\r\n    var n = this.partialObserver;\r\n    if (n.error)\r\n      try {\r\n        n.error(t);\r\n      } catch (r) {\r\n        _e(r);\r\n      }\r\n    else\r\n      _e(t);\r\n  }, e.prototype.complete = function() {\r\n    var t = this.partialObserver;\r\n    if (t.complete)\r\n      try {\r\n        t.complete();\r\n      } catch (n) {\r\n        _e(n);\r\n      }\r\n  }, e;\r\n}(), Ce = function(e) {\r\n  ee(t, e);\r\n  function t(n, r, i) {\r\n    var o = e.call(this) || this, s;\r\n    return A(n) || !n ? s = {\r\n      next: n ?? void 0,\r\n      error: r ?? void 0,\r\n      complete: i ?? void 0\r\n    } : s = n, o.destination = new Nr(s), o;\r\n  }\r\n  return t;\r\n}(mt);\r\nfunction _e(e) {\r\n  un(e);\r\n}\r\nfunction Fr(e) {\r\n  throw e;\r\n}\r\nvar Ur = {\r\n  closed: !0,\r\n  next: je,\r\n  error: Fr,\r\n  complete: je\r\n}, gt = function() {\r\n  return typeof Symbol == \"function\" && Symbol.observable || \"@@observable\";\r\n}();\r\nfunction bt(e) {\r\n  return e;\r\n}\r\nfunction jr(e) {\r\n  return e.length === 0 ? bt : e.length === 1 ? e[0] : function(n) {\r\n    return e.reduce(function(r, i) {\r\n      return i(r);\r\n    }, n);\r\n  };\r\n}\r\nvar k = function() {\r\n  function e(t) {\r\n    t && (this._subscribe = t);\r\n  }\r\n  return e.prototype.lift = function(t) {\r\n    var n = new e();\r\n    return n.source = this, n.operator = t, n;\r\n  }, e.prototype.subscribe = function(t, n, r) {\r\n    var i = this, o = Br(t) ? t : new Ce(t, n, r);\r\n    return Me(function() {\r\n      var s = i, a = s.operator, c = s.source;\r\n      o.add(a ? a.call(o, c) : c ? i._subscribe(o) : i._trySubscribe(o));\r\n    }), o;\r\n  }, e.prototype._trySubscribe = function(t) {\r\n    try {\r\n      return this._subscribe(t);\r\n    } catch (n) {\r\n      t.error(n);\r\n    }\r\n  }, e.prototype.forEach = function(t, n) {\r\n    var r = this;\r\n    return n = _t(n), new n(function(i, o) {\r\n      var s = new Ce({\r\n        next: function(a) {\r\n          try {\r\n            t(a);\r\n          } catch (c) {\r\n            o(c), s.unsubscribe();\r\n          }\r\n        },\r\n        error: o,\r\n        complete: i\r\n      });\r\n      r.subscribe(s);\r\n    });\r\n  }, e.prototype._subscribe = function(t) {\r\n    var n;\r\n    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);\r\n  }, e.prototype[gt] = function() {\r\n    return this;\r\n  }, e.prototype.pipe = function() {\r\n    for (var t = [], n = 0; n < arguments.length; n++)\r\n      t[n] = arguments[n];\r\n    return jr(t)(this);\r\n  }, e.prototype.toPromise = function(t) {\r\n    var n = this;\r\n    return t = _t(t), new t(function(r, i) {\r\n      var o;\r\n      n.subscribe(function(s) {\r\n        return o = s;\r\n      }, function(s) {\r\n        return i(s);\r\n      }, function() {\r\n        return r(o);\r\n      });\r\n    });\r\n  }, e.create = function(t) {\r\n    return new e(t);\r\n  }, e;\r\n}();\r\nfunction _t(e) {\r\n  var t;\r\n  return (t = e ?? Dr.Promise) !== null && t !== void 0 ? t : Promise;\r\n}\r\nfunction Wr(e) {\r\n  return e && A(e.next) && A(e.error) && A(e.complete);\r\n}\r\nfunction Br(e) {\r\n  return e && e instanceof mt || Wr(e) && cn(e);\r\n}\r\nfunction Vr(e) {\r\n  return A(e == null ? void 0 : e.lift);\r\n}\r\nfunction B(e) {\r\n  return function(t) {\r\n    if (Vr(t))\r\n      return t.lift(function(n) {\r\n        try {\r\n          return e(n, this);\r\n        } catch (r) {\r\n          this.error(r);\r\n        }\r\n      });\r\n    throw new TypeError(\"Unable to lift unknown Observable type\");\r\n  };\r\n}\r\nfunction W(e, t, n, r, i) {\r\n  return new Hr(e, t, n, r, i);\r\n}\r\nvar Hr = function(e) {\r\n  ee(t, e);\r\n  function t(n, r, i, o, s, a) {\r\n    var c = e.call(this, n) || this;\r\n    return c.onFinalize = s, c.shouldUnsubscribe = a, c._next = r ? function(u) {\r\n      try {\r\n        r(u);\r\n      } catch (l) {\r\n        n.error(l);\r\n      }\r\n    } : e.prototype._next, c._error = o ? function(u) {\r\n      try {\r\n        o(u);\r\n      } catch (l) {\r\n        n.error(l);\r\n      } finally {\r\n        this.unsubscribe();\r\n      }\r\n    } : e.prototype._error, c._complete = i ? function() {\r\n      try {\r\n        i();\r\n      } catch (u) {\r\n        n.error(u);\r\n      } finally {\r\n        this.unsubscribe();\r\n      }\r\n    } : e.prototype._complete, c;\r\n  }\r\n  return t.prototype.unsubscribe = function() {\r\n    var n;\r\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\r\n      var r = this.closed;\r\n      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));\r\n    }\r\n  }, t;\r\n}(mt), zr = vt(function(e) {\r\n  return function() {\r\n    e(this), this.name = \"ObjectUnsubscribedError\", this.message = \"object unsubscribed\";\r\n  };\r\n}), Z = function(e) {\r\n  ee(t, e);\r\n  function t() {\r\n    var n = e.call(this) || this;\r\n    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;\r\n  }\r\n  return t.prototype.lift = function(n) {\r\n    var r = new It(this, this);\r\n    return r.operator = n, r;\r\n  }, t.prototype._throwIfClosed = function() {\r\n    if (this.closed)\r\n      throw new zr();\r\n  }, t.prototype.next = function(n) {\r\n    var r = this;\r\n    Me(function() {\r\n      var i, o;\r\n      if (r._throwIfClosed(), !r.isStopped) {\r\n        r.currentObservers || (r.currentObservers = Array.from(r.observers));\r\n        try {\r\n          for (var s = me(r.currentObservers), a = s.next(); !a.done; a = s.next()) {\r\n            var c = a.value;\r\n            c.next(n);\r\n          }\r\n        } catch (u) {\r\n          i = { error: u };\r\n        } finally {\r\n          try {\r\n            a && !a.done && (o = s.return) && o.call(s);\r\n          } finally {\r\n            if (i) throw i.error;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }, t.prototype.error = function(n) {\r\n    var r = this;\r\n    Me(function() {\r\n      if (r._throwIfClosed(), !r.isStopped) {\r\n        r.hasError = r.isStopped = !0, r.thrownError = n;\r\n        for (var i = r.observers; i.length; )\r\n          i.shift().error(n);\r\n      }\r\n    });\r\n  }, t.prototype.complete = function() {\r\n    var n = this;\r\n    Me(function() {\r\n      if (n._throwIfClosed(), !n.isStopped) {\r\n        n.isStopped = !0;\r\n        for (var r = n.observers; r.length; )\r\n          r.shift().complete();\r\n      }\r\n    });\r\n  }, t.prototype.unsubscribe = function() {\r\n    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;\r\n  }, Object.defineProperty(t.prototype, \"observed\", {\r\n    get: function() {\r\n      var n;\r\n      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;\r\n    },\r\n    enumerable: !1,\r\n    configurable: !0\r\n  }), t.prototype._trySubscribe = function(n) {\r\n    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);\r\n  }, t.prototype._subscribe = function(n) {\r\n    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);\r\n  }, t.prototype._innerSubscribe = function(n) {\r\n    var r = this, i = this, o = i.hasError, s = i.isStopped, a = i.observers;\r\n    return o || s ? an : (this.currentObservers = null, a.push(n), new Oe(function() {\r\n      r.currentObservers = null, Ue(a, n);\r\n    }));\r\n  }, t.prototype._checkFinalizedStatuses = function(n) {\r\n    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;\r\n    i ? n.error(o) : s && n.complete();\r\n  }, t.prototype.asObservable = function() {\r\n    var n = new k();\r\n    return n.source = this, n;\r\n  }, t.create = function(n, r) {\r\n    return new It(n, r);\r\n  }, t;\r\n}(k), It = function(e) {\r\n  ee(t, e);\r\n  function t(n, r) {\r\n    var i = e.call(this) || this;\r\n    return i.destination = n, i.source = r, i;\r\n  }\r\n  return t.prototype.next = function(n) {\r\n    var r, i;\r\n    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);\r\n  }, t.prototype.error = function(n) {\r\n    var r, i;\r\n    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);\r\n  }, t.prototype.complete = function() {\r\n    var n, r;\r\n    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);\r\n  }, t.prototype._subscribe = function(n) {\r\n    var r, i;\r\n    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : an;\r\n  }, t;\r\n}(Z), ln = function(e) {\r\n  ee(t, e);\r\n  function t(n) {\r\n    var r = e.call(this) || this;\r\n    return r._value = n, r;\r\n  }\r\n  return Object.defineProperty(t.prototype, \"value\", {\r\n    get: function() {\r\n      return this.getValue();\r\n    },\r\n    enumerable: !1,\r\n    configurable: !0\r\n  }), t.prototype._subscribe = function(n) {\r\n    var r = e.prototype._subscribe.call(this, n);\r\n    return !r.closed && n.next(this._value), r;\r\n  }, t.prototype.getValue = function() {\r\n    var n = this, r = n.hasError, i = n.thrownError, o = n._value;\r\n    if (r)\r\n      throw i;\r\n    return this._throwIfClosed(), o;\r\n  }, t.prototype.next = function(n) {\r\n    e.prototype.next.call(this, this._value = n);\r\n  }, t;\r\n}(Z), Yr = {\r\n  now: function() {\r\n    return Date.now();\r\n  }\r\n}, qr = function(e) {\r\n  ee(t, e);\r\n  function t(n, r) {\r\n    return e.call(this) || this;\r\n  }\r\n  return t.prototype.schedule = function(n, r) {\r\n    return this;\r\n  }, t;\r\n}(Oe), Rt = {\r\n  setInterval: function(e, t) {\r\n    for (var n = [], r = 2; r < arguments.length; r++)\r\n      n[r - 2] = arguments[r];\r\n    return setInterval.apply(void 0, ge([e, t], ue(n)));\r\n  },\r\n  clearInterval: function(e) {\r\n    return clearInterval(e);\r\n  },\r\n  delegate: void 0\r\n}, Kr = function(e) {\r\n  ee(t, e);\r\n  function t(n, r) {\r\n    var i = e.call(this, n, r) || this;\r\n    return i.scheduler = n, i.work = r, i.pending = !1, i;\r\n  }\r\n  return t.prototype.schedule = function(n, r) {\r\n    var i;\r\n    if (r === void 0 && (r = 0), this.closed)\r\n      return this;\r\n    this.state = n;\r\n    var o = this.id, s = this.scheduler;\r\n    return o != null && (this.id = this.recycleAsyncId(s, o, r)), this.pending = !0, this.delay = r, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(s, this.id, r), this;\r\n  }, t.prototype.requestAsyncId = function(n, r, i) {\r\n    return i === void 0 && (i = 0), Rt.setInterval(n.flush.bind(n, this), i);\r\n  }, t.prototype.recycleAsyncId = function(n, r, i) {\r\n    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)\r\n      return r;\r\n    r != null && Rt.clearInterval(r);\r\n  }, t.prototype.execute = function(n, r) {\r\n    if (this.closed)\r\n      return new Error(\"executing a cancelled action\");\r\n    this.pending = !1;\r\n    var i = this._execute(n, r);\r\n    if (i)\r\n      return i;\r\n    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));\r\n  }, t.prototype._execute = function(n, r) {\r\n    var i = !1, o;\r\n    try {\r\n      this.work(n);\r\n    } catch (s) {\r\n      i = !0, o = s || new Error(\"Scheduled action threw falsy error\");\r\n    }\r\n    if (i)\r\n      return this.unsubscribe(), o;\r\n  }, t.prototype.unsubscribe = function() {\r\n    if (!this.closed) {\r\n      var n = this, r = n.id, i = n.scheduler, o = i.actions;\r\n      this.work = this.state = this.scheduler = null, this.pending = !1, Ue(o, this), r != null && (this.id = this.recycleAsyncId(i, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);\r\n    }\r\n  }, t;\r\n}(qr), Mt = function() {\r\n  function e(t, n) {\r\n    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;\r\n  }\r\n  return e.prototype.schedule = function(t, n, r) {\r\n    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);\r\n  }, e.now = Yr.now, e;\r\n}(), Gr = function(e) {\r\n  ee(t, e);\r\n  function t(n, r) {\r\n    r === void 0 && (r = Mt.now);\r\n    var i = e.call(this, n, r) || this;\r\n    return i.actions = [], i._active = !1, i;\r\n  }\r\n  return t.prototype.flush = function(n) {\r\n    var r = this.actions;\r\n    if (this._active) {\r\n      r.push(n);\r\n      return;\r\n    }\r\n    var i;\r\n    this._active = !0;\r\n    do\r\n      if (i = n.execute(n.state, n.delay))\r\n        break;\r\n    while (n = r.shift());\r\n    if (this._active = !1, i) {\r\n      for (; n = r.shift(); )\r\n        n.unsubscribe();\r\n      throw i;\r\n    }\r\n  }, t;\r\n}(Mt), Qr = new Gr(Kr);\r\nfunction Jr(e) {\r\n  return e && A(e.schedule);\r\n}\r\nfunction Xr(e) {\r\n  return e[e.length - 1];\r\n}\r\nfunction yt(e) {\r\n  return Jr(Xr(e)) ? e.pop() : void 0;\r\n}\r\nvar wt = function(e) {\r\n  return e && typeof e.length == \"number\" && typeof e != \"function\";\r\n};\r\nfunction fn(e) {\r\n  return A(e == null ? void 0 : e.then);\r\n}\r\nfunction dn(e) {\r\n  return A(e[gt]);\r\n}\r\nfunction pn(e) {\r\n  return Symbol.asyncIterator && A(e == null ? void 0 : e[Symbol.asyncIterator]);\r\n}\r\nfunction hn(e) {\r\n  return new TypeError(\"You provided \" + (e !== null && typeof e == \"object\" ? \"an invalid object\" : \"'\" + e + \"'\") + \" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.\");\r\n}\r\nfunction Zr() {\r\n  return typeof Symbol != \"function\" || !Symbol.iterator ? \"@@iterator\" : Symbol.iterator;\r\n}\r\nvar vn = Zr();\r\nfunction mn(e) {\r\n  return A(e == null ? void 0 : e[vn]);\r\n}\r\nfunction gn(e) {\r\n  return Rr(this, arguments, function() {\r\n    var n, r, i, o;\r\n    return sn(this, function(s) {\r\n      switch (s.label) {\r\n        case 0:\r\n          n = e.getReader(), s.label = 1;\r\n        case 1:\r\n          s.trys.push([1, , 9, 10]), s.label = 2;\r\n        case 2:\r\n          return [4, pe(n.read())];\r\n        case 3:\r\n          return r = s.sent(), i = r.value, o = r.done, o ? [4, pe(void 0)] : [3, 5];\r\n        case 4:\r\n          return [2, s.sent()];\r\n        case 5:\r\n          return [4, pe(i)];\r\n        case 6:\r\n          return [4, s.sent()];\r\n        case 7:\r\n          return s.sent(), [3, 2];\r\n        case 8:\r\n          return [3, 10];\r\n        case 9:\r\n          return n.releaseLock(), [7];\r\n        case 10:\r\n          return [2];\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction bn(e) {\r\n  return A(e == null ? void 0 : e.getReader);\r\n}\r\nfunction H(e) {\r\n  if (e instanceof k)\r\n    return e;\r\n  if (e != null) {\r\n    if (dn(e))\r\n      return ei(e);\r\n    if (wt(e))\r\n      return ti(e);\r\n    if (fn(e))\r\n      return ni(e);\r\n    if (pn(e))\r\n      return yn(e);\r\n    if (mn(e))\r\n      return ri(e);\r\n    if (bn(e))\r\n      return ii(e);\r\n  }\r\n  throw hn(e);\r\n}\r\nfunction ei(e) {\r\n  return new k(function(t) {\r\n    var n = e[gt]();\r\n    if (A(n.subscribe))\r\n      return n.subscribe(t);\r\n    throw new TypeError(\"Provided object does not correctly implement Symbol.observable\");\r\n  });\r\n}\r\nfunction ti(e) {\r\n  return new k(function(t) {\r\n    for (var n = 0; n < e.length && !t.closed; n++)\r\n      t.next(e[n]);\r\n    t.complete();\r\n  });\r\n}\r\nfunction ni(e) {\r\n  return new k(function(t) {\r\n    e.then(function(n) {\r\n      t.closed || (t.next(n), t.complete());\r\n    }, function(n) {\r\n      return t.error(n);\r\n    }).then(null, un);\r\n  });\r\n}\r\nfunction ri(e) {\r\n  return new k(function(t) {\r\n    var n, r;\r\n    try {\r\n      for (var i = me(e), o = i.next(); !o.done; o = i.next()) {\r\n        var s = o.value;\r\n        if (t.next(s), t.closed)\r\n          return;\r\n      }\r\n    } catch (a) {\r\n      n = { error: a };\r\n    } finally {\r\n      try {\r\n        o && !o.done && (r = i.return) && r.call(i);\r\n      } finally {\r\n        if (n) throw n.error;\r\n      }\r\n    }\r\n    t.complete();\r\n  });\r\n}\r\nfunction yn(e) {\r\n  return new k(function(t) {\r\n    oi(e, t).catch(function(n) {\r\n      return t.error(n);\r\n    });\r\n  });\r\n}\r\nfunction ii(e) {\r\n  return yn(gn(e));\r\n}\r\nfunction oi(e, t) {\r\n  var n, r, i, o;\r\n  return Ir(this, void 0, void 0, function() {\r\n    var s, a;\r\n    return sn(this, function(c) {\r\n      switch (c.label) {\r\n        case 0:\r\n          c.trys.push([0, 5, 6, 11]), n = Mr(e), c.label = 1;\r\n        case 1:\r\n          return [4, n.next()];\r\n        case 2:\r\n          if (r = c.sent(), !!r.done) return [3, 4];\r\n          if (s = r.value, t.next(s), t.closed)\r\n            return [2];\r\n          c.label = 3;\r\n        case 3:\r\n          return [3, 1];\r\n        case 4:\r\n          return [3, 11];\r\n        case 5:\r\n          return a = c.sent(), i = { error: a }, [3, 11];\r\n        case 6:\r\n          return c.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8];\r\n        case 7:\r\n          c.sent(), c.label = 8;\r\n        case 8:\r\n          return [3, 10];\r\n        case 9:\r\n          if (i) throw i.error;\r\n          return [7];\r\n        case 10:\r\n          return [7];\r\n        case 11:\r\n          return t.complete(), [2];\r\n      }\r\n    });\r\n  });\r\n}\r\nfunction re(e, t, n, r, i) {\r\n  r === void 0 && (r = 0), i === void 0 && (i = !1);\r\n  var o = t.schedule(function() {\r\n    n(), i ? e.add(this.schedule(null, r)) : this.unsubscribe();\r\n  }, r);\r\n  if (e.add(o), !i)\r\n    return o;\r\n}\r\nfunction wn(e, t) {\r\n  return t === void 0 && (t = 0), B(function(n, r) {\r\n    n.subscribe(W(r, function(i) {\r\n      return re(r, e, function() {\r\n        return r.next(i);\r\n      }, t);\r\n    }, function() {\r\n      return re(r, e, function() {\r\n        return r.complete();\r\n      }, t);\r\n    }, function(i) {\r\n      return re(r, e, function() {\r\n        return r.error(i);\r\n      }, t);\r\n    }));\r\n  });\r\n}\r\nfunction xn(e, t) {\r\n  return t === void 0 && (t = 0), B(function(n, r) {\r\n    r.add(e.schedule(function() {\r\n      return n.subscribe(r);\r\n    }, t));\r\n  });\r\n}\r\nfunction si(e, t) {\r\n  return H(e).pipe(xn(t), wn(t));\r\n}\r\nfunction ai(e, t) {\r\n  return H(e).pipe(xn(t), wn(t));\r\n}\r\nfunction ci(e, t) {\r\n  return new k(function(n) {\r\n    var r = 0;\r\n    return t.schedule(function() {\r\n      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());\r\n    });\r\n  });\r\n}\r\nfunction ui(e, t) {\r\n  return new k(function(n) {\r\n    var r;\r\n    return re(n, t, function() {\r\n      r = e[vn](), re(n, t, function() {\r\n        var i, o, s;\r\n        try {\r\n          i = r.next(), o = i.value, s = i.done;\r\n        } catch (a) {\r\n          n.error(a);\r\n          return;\r\n        }\r\n        s ? n.complete() : n.next(o);\r\n      }, 0, !0);\r\n    }), function() {\r\n      return A(r == null ? void 0 : r.return) && r.return();\r\n    };\r\n  });\r\n}\r\nfunction Sn(e, t) {\r\n  if (!e)\r\n    throw new Error(\"Iterable cannot be null\");\r\n  return new k(function(n) {\r\n    re(n, t, function() {\r\n      var r = e[Symbol.asyncIterator]();\r\n      re(n, t, function() {\r\n        r.next().then(function(i) {\r\n          i.done ? n.complete() : n.next(i.value);\r\n        });\r\n      }, 0, !0);\r\n    });\r\n  });\r\n}\r\nfunction li(e, t) {\r\n  return Sn(gn(e), t);\r\n}\r\nfunction fi(e, t) {\r\n  if (e != null) {\r\n    if (dn(e))\r\n      return si(e, t);\r\n    if (wt(e))\r\n      return ci(e, t);\r\n    if (fn(e))\r\n      return ai(e, t);\r\n    if (pn(e))\r\n      return Sn(e, t);\r\n    if (mn(e))\r\n      return ui(e, t);\r\n    if (bn(e))\r\n      return li(e, t);\r\n  }\r\n  throw hn(e);\r\n}\r\nfunction Ge(e, t) {\r\n  return t ? fi(e, t) : H(e);\r\n}\r\nfunction Dt() {\r\n  for (var e = [], t = 0; t < arguments.length; t++)\r\n    e[t] = arguments[t];\r\n  var n = yt(e);\r\n  return Ge(e, n);\r\n}\r\nfunction di(e) {\r\n  return e instanceof Date && !isNaN(e);\r\n}\r\nvar pi = vt(function(e) {\r\n  return function(n) {\r\n    n === void 0 && (n = null), e(this), this.message = \"Timeout has occurred\", this.name = \"TimeoutError\", this.info = n;\r\n  };\r\n});\r\nfunction hi(e, t) {\r\n  var n = di(e) ? { first: e } : typeof e == \"number\" ? { each: e } : e, r = n.first, i = n.each, o = n.with, s = o === void 0 ? vi : o, a = n.scheduler, c = a === void 0 ? Qr : a, u = n.meta, l = u === void 0 ? null : u;\r\n  if (r == null && i == null)\r\n    throw new TypeError(\"No timeout provided.\");\r\n  return B(function(f, v) {\r\n    var d, m, p = null, g = 0, h = function(x) {\r\n      m = re(v, c, function() {\r\n        try {\r\n          d.unsubscribe(), H(s({\r\n            meta: l,\r\n            lastValue: p,\r\n            seen: g\r\n          })).subscribe(v);\r\n        } catch (E) {\r\n          v.error(E);\r\n        }\r\n      }, x);\r\n    };\r\n    d = f.subscribe(W(v, function(x) {\r\n      m == null || m.unsubscribe(), g++, v.next(p = x), i > 0 && h(i);\r\n    }, void 0, void 0, function() {\r\n      m != null && m.closed || m == null || m.unsubscribe(), p = null;\r\n    })), !g && h(r != null ? typeof r == \"number\" ? r : +r - c.now() : i);\r\n  });\r\n}\r\nfunction vi(e) {\r\n  throw new pi(e);\r\n}\r\nfunction O(e, t) {\r\n  return B(function(n, r) {\r\n    var i = 0;\r\n    n.subscribe(W(r, function(o) {\r\n      r.next(e.call(t, o, i++));\r\n    }));\r\n  });\r\n}\r\nvar mi = Array.isArray;\r\nfunction gi(e, t) {\r\n  return mi(t) ? e.apply(void 0, ge([], ue(t))) : e(t);\r\n}\r\nfunction bi(e) {\r\n  return O(function(t) {\r\n    return gi(e, t);\r\n  });\r\n}\r\nfunction yi(e, t, n, r, i, o, s, a) {\r\n  var c = [], u = 0, l = 0, f = !1, v = function() {\r\n    f && !c.length && !u && t.complete();\r\n  }, d = function(p) {\r\n    return u < r ? m(p) : c.push(p);\r\n  }, m = function(p) {\r\n    u++;\r\n    var g = !1;\r\n    H(n(p, l++)).subscribe(W(t, function(h) {\r\n      t.next(h);\r\n    }, function() {\r\n      g = !0;\r\n    }, void 0, function() {\r\n      if (g)\r\n        try {\r\n          u--;\r\n          for (var h = function() {\r\n            var x = c.shift();\r\n            s || m(x);\r\n          }; c.length && u < r; )\r\n            h();\r\n          v();\r\n        } catch (x) {\r\n          t.error(x);\r\n        }\r\n    }));\r\n  };\r\n  return e.subscribe(W(t, d, function() {\r\n    f = !0, v();\r\n  })), function() {\r\n  };\r\n}\r\nfunction xt(e, t, n) {\r\n  return n === void 0 && (n = 1 / 0), A(t) ? xt(function(r, i) {\r\n    return O(function(o, s) {\r\n      return t(r, o, i, s);\r\n    })(H(e(r, i)));\r\n  }, n) : (typeof t == \"number\" && (n = t), B(function(r, i) {\r\n    return yi(r, i, e, n);\r\n  }));\r\n}\r\nfunction wi(e) {\r\n  return xt(bt, e);\r\n}\r\nfunction xi() {\r\n  return wi(1);\r\n}\r\nfunction We() {\r\n  for (var e = [], t = 0; t < arguments.length; t++)\r\n    e[t] = arguments[t];\r\n  return xi()(Ge(e, yt(e)));\r\n}\r\nvar Si = [\"addListener\", \"removeListener\"], Ti = [\"addEventListener\", \"removeEventListener\"], Ei = [\"on\", \"off\"];\r\nfunction at(e, t, n, r) {\r\n  if (A(n) && (r = n, n = void 0), r)\r\n    return at(e, t, n).pipe(bi(r));\r\n  var i = ue(Ai(e) ? Ti.map(function(a) {\r\n    return function(c) {\r\n      return e[a](t, c, n);\r\n    };\r\n  }) : Ci(e) ? Si.map($t(e, t)) : Pi(e) ? Ei.map($t(e, t)) : [], 2), o = i[0], s = i[1];\r\n  if (!o && wt(e))\r\n    return xt(function(a) {\r\n      return at(a, t, n);\r\n    })(H(e));\r\n  if (!o)\r\n    throw new TypeError(\"Invalid event target\");\r\n  return new k(function(a) {\r\n    var c = function() {\r\n      for (var u = [], l = 0; l < arguments.length; l++)\r\n        u[l] = arguments[l];\r\n      return a.next(1 < u.length ? u : u[0]);\r\n    };\r\n    return o(c), function() {\r\n      return s(c);\r\n    };\r\n  });\r\n}\r\nfunction $t(e, t) {\r\n  return function(n) {\r\n    return function(r) {\r\n      return e[n](t, r);\r\n    };\r\n  };\r\n}\r\nfunction Ci(e) {\r\n  return A(e.addListener) && A(e.removeListener);\r\n}\r\nfunction Pi(e) {\r\n  return A(e.on) && A(e.off);\r\n}\r\nfunction Ai(e) {\r\n  return A(e.addEventListener) && A(e.removeEventListener);\r\n}\r\nfunction Qe(e, t) {\r\n  return B(function(n, r) {\r\n    var i = 0;\r\n    n.subscribe(W(r, function(o) {\r\n      return e.call(t, o, i++) && r.next(o);\r\n    }));\r\n  });\r\n}\r\nfunction Oi(e, t, n, r, i) {\r\n  return function(o, s) {\r\n    var a = n, c = t, u = 0;\r\n    o.subscribe(W(s, function(l) {\r\n      var f = u++;\r\n      c = a ? e(c, l, f) : (a = !0, l), s.next(c);\r\n    }, i));\r\n  };\r\n}\r\nfunction ki(e, t) {\r\n  return t === void 0 && (t = bt), e = e ?? Li, B(function(n, r) {\r\n    var i, o = !0;\r\n    n.subscribe(W(r, function(s) {\r\n      var a = t(s);\r\n      (o || !e(i, a)) && (o = !1, i = a, r.next(s));\r\n    }));\r\n  });\r\n}\r\nfunction Li(e, t) {\r\n  return e === t;\r\n}\r\nfunction ct(e, t) {\r\n  return B(Oi(e, t, arguments.length >= 2, !0));\r\n}\r\nfunction _i(e) {\r\n  e === void 0 && (e = {});\r\n  var t = e.connector, n = t === void 0 ? function() {\r\n    return new Z();\r\n  } : t, r = e.resetOnError, i = r === void 0 ? !0 : r, o = e.resetOnComplete, s = o === void 0 ? !0 : o, a = e.resetOnRefCountZero, c = a === void 0 ? !0 : a;\r\n  return function(u) {\r\n    var l, f, v, d = 0, m = !1, p = !1, g = function() {\r\n      f == null || f.unsubscribe(), f = void 0;\r\n    }, h = function() {\r\n      g(), l = v = void 0, m = p = !1;\r\n    }, x = function() {\r\n      var E = l;\r\n      h(), E == null || E.unsubscribe();\r\n    };\r\n    return B(function(E, P) {\r\n      d++, !p && !m && g();\r\n      var b = v = v ?? n();\r\n      P.add(function() {\r\n        d--, d === 0 && !p && !m && (f = et(x, c));\r\n      }), b.subscribe(P), !l && d > 0 && (l = new Ce({\r\n        next: function(S) {\r\n          return b.next(S);\r\n        },\r\n        error: function(S) {\r\n          p = !0, g(), f = et(h, i, S), b.error(S);\r\n        },\r\n        complete: function() {\r\n          m = !0, g(), f = et(h, s), b.complete();\r\n        }\r\n      }), H(E).subscribe(l));\r\n    })(u);\r\n  };\r\n}\r\nfunction et(e, t) {\r\n  for (var n = [], r = 2; r < arguments.length; r++)\r\n    n[r - 2] = arguments[r];\r\n  if (t === !0) {\r\n    e();\r\n    return;\r\n  }\r\n  if (t !== !1) {\r\n    var i = new Ce({\r\n      next: function() {\r\n        i.unsubscribe(), e();\r\n      }\r\n    });\r\n    return H(t.apply(void 0, ge([], ue(n)))).subscribe(i);\r\n  }\r\n}\r\nfunction Ii(e) {\r\n  return B(function(t, n) {\r\n    var r = !1, i = W(n, function() {\r\n      i == null || i.unsubscribe(), r = !0;\r\n    }, je);\r\n    H(e).subscribe(i), t.subscribe(W(n, function(o) {\r\n      return r && n.next(o);\r\n    }));\r\n  });\r\n}\r\nfunction D() {\r\n  for (var e = [], t = 0; t < arguments.length; t++)\r\n    e[t] = arguments[t];\r\n  var n = yt(e);\r\n  return B(function(r, i) {\r\n    (n ? We(e, r, n) : We(e, r)).subscribe(i);\r\n  });\r\n}\r\nfunction Tn(e, t) {\r\n  return B(function(n, r) {\r\n    var i = null, o = 0, s = !1, a = function() {\r\n      return s && !i && r.complete();\r\n    };\r\n    n.subscribe(W(r, function(c) {\r\n      i == null || i.unsubscribe();\r\n      var u = 0, l = o++;\r\n      H(e(c, l)).subscribe(i = W(r, function(f) {\r\n        return r.next(t ? t(c, f, l, u++) : f);\r\n      }, function() {\r\n        i = null, a();\r\n      }));\r\n    }, function() {\r\n      s = !0, a();\r\n    }));\r\n  });\r\n}\r\nfunction Nt(e) {\r\n  return B(function(t, n) {\r\n    H(e).subscribe(W(n, function() {\r\n      return n.complete();\r\n    }, je)), !n.closed && t.subscribe(n);\r\n  });\r\n}\r\nvar Ri = Object.defineProperty, Mi = Object.defineProperties, Di = Object.getOwnPropertyDescriptors, Ft = Object.getOwnPropertySymbols, $i = Object.prototype.hasOwnProperty, Ni = Object.prototype.propertyIsEnumerable, Ut = (e, t, n) => t in e ? Ri(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, X = (e, t) => {\r\n  for (var n in t || (t = {}))\r\n    $i.call(t, n) && Ut(e, n, t[n]);\r\n  if (Ft)\r\n    for (var n of Ft(t))\r\n      Ni.call(t, n) && Ut(e, n, t[n]);\r\n  return e;\r\n}, Te = (e, t) => Mi(e, Di(t)), V = (e, t, n) => new Promise((r, i) => {\r\n  var o = (c) => {\r\n    try {\r\n      a(n.next(c));\r\n    } catch (u) {\r\n      i(u);\r\n    }\r\n  }, s = (c) => {\r\n    try {\r\n      a(n.throw(c));\r\n    } catch (u) {\r\n      i(u);\r\n    }\r\n  }, a = (c) => c.done ? r(c.value) : Promise.resolve(c.value).then(o, s);\r\n  a((n = n.apply(e, t)).next());\r\n}), En = \"lk\";\r\nfunction j(e) {\r\n  return typeof e > \"u\" ? !1 : Fi(e) || Ui(e);\r\n}\r\nfunction Fi(e) {\r\n  var t;\r\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && e.hasOwnProperty(\"track\") && typeof ((t = e.publication) == null ? void 0 : t.track) < \"u\" : !1;\r\n}\r\nfunction Ui(e) {\r\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && e.hasOwnProperty(\"publication\") && typeof e.publication < \"u\" : !1;\r\n}\r\nfunction Pe(e) {\r\n  return e ? e.hasOwnProperty(\"participant\") && e.hasOwnProperty(\"source\") && typeof e.publication > \"u\" : !1;\r\n}\r\nfunction N(e) {\r\n  if (typeof e == \"string\" || typeof e == \"number\")\r\n    return `${e}`;\r\n  if (Pe(e))\r\n    return `${e.participant.identity}_${e.source}_placeholder`;\r\n  if (j(e))\r\n    return `${e.participant.identity}_${e.publication.source}_${e.publication.trackSid}`;\r\n  throw new Error(`Can't generate a id for the given track reference: ${e}`);\r\n}\r\nfunction Do(e, t) {\r\n  return e === void 0 || t === void 0 ? !1 : j(e) && j(t) ? e.publication.trackSid === t.publication.trackSid : N(e) === N(t);\r\n}\r\nfunction $o(e, t) {\r\n  return typeof t > \"u\" ? !1 : j(e) ? t.some(\r\n    (n) => n.participant.identity === e.participant.identity && j(n) && n.publication.trackSid === e.publication.trackSid\r\n  ) : Pe(e) ? t.some(\r\n    (n) => n.participant.identity === e.participant.identity && Pe(n) && n.source === e.source\r\n  ) : !1;\r\n}\r\nfunction ji(e, t) {\r\n  return Pe(e) && j(t) && t.participant.identity === e.participant.identity && t.source === e.source;\r\n}\r\nfunction No() {\r\n  const e = document.createElement(\"p\");\r\n  e.style.width = \"100%\", e.style.height = \"200px\";\r\n  const t = document.createElement(\"div\");\r\n  t.style.position = \"absolute\", t.style.top = \"0px\", t.style.left = \"0px\", t.style.visibility = \"hidden\", t.style.width = \"200px\", t.style.height = \"150px\", t.style.overflow = \"hidden\", t.appendChild(e), document.body.appendChild(t);\r\n  const n = e.offsetWidth;\r\n  t.style.overflow = \"scroll\";\r\n  let r = e.offsetWidth;\r\n  return n === r && (r = t.clientWidth), document.body.removeChild(t), n - r;\r\n}\r\nfunction Fo() {\r\n  return typeof document < \"u\";\r\n}\r\nfunction Wi(e) {\r\n  e = X({}, e);\r\n  const t = \"(?:(?:[a-z]+:)?//)?\", n = \"(?:\\\\S+(?::\\\\S*)?@)?\", r = new RegExp(\r\n    \"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\",\r\n    \"g\"\r\n  ).source, u = `(?:${t}|www\\\\.)${n}(?:localhost|${r}|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?)(?::\\\\d{2,5})?(?:[/?#][^\\\\s\"]*)?`;\r\n  return e.exact ? new RegExp(`(?:^${u}$)`, \"i\") : new RegExp(u, \"ig\");\r\n}\r\nvar jt = \"[^\\\\.\\\\s@:](?:[^\\\\s@:]*[^\\\\s@:\\\\.])?@[^\\\\.\\\\s@]+(?:\\\\.[^\\\\.\\\\s@]+)*\";\r\nfunction Bi({ exact: e } = {}) {\r\n  return e ? new RegExp(`^${jt}$`) : new RegExp(jt, \"g\");\r\n}\r\nfunction Uo(e, t, n) {\r\n  return Sr(e, t, () => V(this, null, function* () {\r\n    const { x: i, y: o } = yield Pr(e, t, {\r\n      placement: \"top\",\r\n      middleware: [Tr(6), Cr(), Er({ padding: 5 })]\r\n    });\r\n    n == null || n(i, o);\r\n  }));\r\n}\r\nfunction jo(e, t) {\r\n  return !e.contains(t.target);\r\n}\r\nvar Wo = () => ({\r\n  email: Bi(),\r\n  url: Wi({})\r\n});\r\nfunction Bo(e, t) {\r\n  const n = Object.entries(t).map(\r\n    ([o, s], a) => Array.from(e.matchAll(s)).map(({ index: c, 0: u }) => ({\r\n      type: o,\r\n      weight: a,\r\n      content: u,\r\n      index: c ?? 0\r\n    }))\r\n  ).flat().sort((o, s) => {\r\n    const a = o.index - s.index;\r\n    return a !== 0 ? a : o.weight - s.weight;\r\n  }).filter(({ index: o }, s, a) => {\r\n    if (s === 0) return !0;\r\n    const c = a[s - 1];\r\n    return c.index + c.content.length <= o;\r\n  }), r = [];\r\n  let i = 0;\r\n  for (const { type: o, content: s, index: a } of n)\r\n    a > i && r.push(e.substring(i, a)), r.push({ type: o, content: s }), i = a + s.length;\r\n  return e.length > i && r.push(e.substring(i)), r;\r\n}\r\nvar Vi = [\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RoomMetadataChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveSpeakersChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionQualityChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantPermissionsChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantMetadataChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantNameChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantAttributesChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackMuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnmuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnpublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackStreamStateChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionFailed,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionPermissionChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionStatusChanged\r\n], Cn = [\r\n  ...Vi,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackUnpublished\r\n], Hi = [\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackStreamStateChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscribed,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnsubscribed,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionPermissionChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionFailed,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\r\n], zi = [\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ConnectionQualityChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.IsSpeakingChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantMetadataChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackStreamStateChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionFailed,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionPermissionChanged,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionStatusChanged\r\n], Pn = [\r\n  ...zi,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\r\n], _ = _r.getLogger(\"lk-components-js\");\r\n_.setDefaultLevel(\"WARN\");\r\nfunction Vo(e, t = {}) {\r\n  var n;\r\n  _.setLevel(e), (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.setLogLevel)((n = t.liveKitClientLogLevel) != null ? n : e);\r\n}\r\nfunction Ho(e, t = {}) {\r\n  var n;\r\n  const r = _.methodFactory;\r\n  _.methodFactory = (i, o, s) => {\r\n    const a = r(i, o, s), c = livekit_client__WEBPACK_IMPORTED_MODULE_0__.LogLevel[i], u = c >= o && c < livekit_client__WEBPACK_IMPORTED_MODULE_0__.LogLevel.silent;\r\n    return (l, f) => {\r\n      f ? a(l, f) : a(l), u && e(c, l, f);\r\n    };\r\n  }, _.setLevel(_.getLevel()), (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.setLogExtension)((n = t.liveKitClientLogExtension) != null ? n : e);\r\n}\r\nvar zo = [\r\n  {\r\n    columns: 1,\r\n    rows: 1\r\n  },\r\n  {\r\n    columns: 1,\r\n    rows: 2,\r\n    orientation: \"portrait\"\r\n  },\r\n  {\r\n    columns: 2,\r\n    rows: 1,\r\n    orientation: \"landscape\"\r\n  },\r\n  {\r\n    columns: 2,\r\n    rows: 2,\r\n    minWidth: 560\r\n  },\r\n  {\r\n    columns: 3,\r\n    rows: 3,\r\n    minWidth: 700\r\n  },\r\n  {\r\n    columns: 4,\r\n    rows: 4,\r\n    minWidth: 960\r\n  },\r\n  {\r\n    columns: 5,\r\n    rows: 5,\r\n    minWidth: 1100\r\n  }\r\n];\r\nfunction Yi(e, t, n, r) {\r\n  if (e.length < 1)\r\n    throw new Error(\"At least one grid layout definition must be provided.\");\r\n  const i = qi(e);\r\n  if (n <= 0 || r <= 0)\r\n    return i[0];\r\n  let o = 0;\r\n  const s = n / r > 1 ? \"landscape\" : \"portrait\";\r\n  let a = i.find((c, u, l) => {\r\n    o = u;\r\n    const f = l.findIndex((v, d) => {\r\n      const m = !v.orientation || v.orientation === s, p = d > u, g = v.maxTiles === c.maxTiles;\r\n      return p && g && m;\r\n    }) !== -1;\r\n    return c.maxTiles >= t && !f;\r\n  });\r\n  if (a === void 0)\r\n    if (a = i[i.length - 1], a)\r\n      _.warn(\r\n        `No layout found for: participantCount: ${t}, width/height: ${n}/${r} fallback to biggest available layout (${a}).`\r\n      );\r\n    else\r\n      throw new Error(\"No layout or fallback layout found.\");\r\n  if ((n < a.minWidth || r < a.minHeight) && o > 0) {\r\n    const c = i[o - 1];\r\n    a = Yi(\r\n      i.slice(0, o),\r\n      c.maxTiles,\r\n      n,\r\n      r\r\n    );\r\n  }\r\n  return a;\r\n}\r\nfunction qi(e) {\r\n  return [...e].map((t) => {\r\n    var n, r;\r\n    return {\r\n      name: `${t.columns}x${t.rows}`,\r\n      columns: t.columns,\r\n      rows: t.rows,\r\n      maxTiles: t.columns * t.rows,\r\n      minWidth: (n = t.minWidth) != null ? n : 0,\r\n      minHeight: (r = t.minHeight) != null ? r : 0,\r\n      orientation: t.orientation\r\n    };\r\n  }).sort((t, n) => t.maxTiles !== n.maxTiles ? t.maxTiles - n.maxTiles : t.minWidth !== 0 || n.minWidth !== 0 ? t.minWidth - n.minWidth : t.minHeight !== 0 || n.minHeight !== 0 ? t.minHeight - n.minHeight : 0);\r\n}\r\nfunction Yo() {\r\n  return typeof navigator < \"u\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\r\n}\r\nfunction qo(e, t) {\r\n  var n;\r\n  return Te(X({}, e), {\r\n    receivedAtMediaTimestamp: (n = t.rtpTimestamp) != null ? n : 0,\r\n    receivedAt: t.timestamp\r\n  });\r\n}\r\nfunction Ko(e, t, n) {\r\n  return [...e, ...t].reduceRight((r, i) => (r.find((o) => o.id === i.id) || r.unshift(i), r), []).slice(0 - n);\r\n}\r\nvar An = [], On = {\r\n  showChat: !1,\r\n  unreadMessages: 0,\r\n  showSettings: !1\r\n};\r\nfunction Ki(e) {\r\n  return typeof e == \"object\";\r\n}\r\nfunction Go(e) {\r\n  return Array.isArray(e) && e.filter(Ki).length > 0;\r\n}\r\nfunction kn(e, t) {\r\n  return t.audioLevel - e.audioLevel;\r\n}\r\nfunction Ln(e, t) {\r\n  return e.isSpeaking === t.isSpeaking ? 0 : e.isSpeaking ? -1 : 1;\r\n}\r\nfunction _n(e, t) {\r\n  var n, r, i, o;\r\n  return e.lastSpokeAt !== void 0 || t.lastSpokeAt !== void 0 ? ((r = (n = t.lastSpokeAt) == null ? void 0 : n.getTime()) != null ? r : 0) - ((o = (i = e.lastSpokeAt) == null ? void 0 : i.getTime()) != null ? o : 0) : 0;\r\n}\r\nfunction Be(e, t) {\r\n  var n, r, i, o;\r\n  return ((r = (n = e.joinedAt) == null ? void 0 : n.getTime()) != null ? r : 0) - ((o = (i = t.joinedAt) == null ? void 0 : i.getTime()) != null ? o : 0);\r\n}\r\nfunction Gi(e, t) {\r\n  return j(e) ? j(t) ? 0 : -1 : j(t) ? 1 : 0;\r\n}\r\nfunction Qi(e, t) {\r\n  const n = e.participant.isCameraEnabled, r = t.participant.isCameraEnabled;\r\n  return n !== r ? n ? -1 : 1 : 0;\r\n}\r\nfunction Qo(e) {\r\n  const t = [], n = [], r = [], i = [];\r\n  e.forEach((a) => {\r\n    a.participant.isLocal && a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera ? t.push(a) : a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare ? n.push(a) : a.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera ? r.push(a) : i.push(a);\r\n  });\r\n  const o = Ji(n), s = Xi(r);\r\n  return [...t, ...o, ...s, ...i];\r\n}\r\nfunction Ji(e) {\r\n  const t = [], n = [];\r\n  return e.forEach((i) => {\r\n    i.participant.isLocal ? t.push(i) : n.push(i);\r\n  }), t.sort((i, o) => Be(i.participant, o.participant)), n.sort((i, o) => Be(i.participant, o.participant)), [...n, ...t];\r\n}\r\nfunction Xi(e) {\r\n  const t = [], n = [];\r\n  return e.forEach((r) => {\r\n    r.participant.isLocal ? t.push(r) : n.push(r);\r\n  }), n.sort((r, i) => r.participant.isSpeaking && i.participant.isSpeaking ? kn(r.participant, i.participant) : r.participant.isSpeaking !== i.participant.isSpeaking ? Ln(r.participant, i.participant) : r.participant.lastSpokeAt !== i.participant.lastSpokeAt ? _n(r.participant, i.participant) : j(r) !== j(i) ? Gi(r, i) : r.participant.isCameraEnabled !== i.participant.isCameraEnabled ? Qi(r, i) : Be(r.participant, i.participant)), [...t, ...n];\r\n}\r\nfunction Jo(e) {\r\n  const t = [...e];\r\n  t.sort((r, i) => {\r\n    if (r.isSpeaking && i.isSpeaking)\r\n      return kn(r, i);\r\n    if (r.isSpeaking !== i.isSpeaking)\r\n      return Ln(r, i);\r\n    if (r.lastSpokeAt !== i.lastSpokeAt)\r\n      return _n(r, i);\r\n    const o = r.videoTrackPublications.size > 0, s = i.videoTrackPublications.size > 0;\r\n    return o !== s ? o ? -1 : 1 : Be(r, i);\r\n  });\r\n  const n = t.find((r) => r.isLocal);\r\n  if (n) {\r\n    const r = t.indexOf(n);\r\n    r >= 0 && (t.splice(r, 1), t.length > 0 ? t.splice(0, 0, n) : t.push(n));\r\n  }\r\n  return t;\r\n}\r\nfunction Zi(e, t) {\r\n  return e.reduce(\r\n    (n, r, i) => i % t === 0 ? [...n, [r]] : [...n.slice(0, -1), [...n.slice(-1)[0], r]],\r\n    []\r\n  );\r\n}\r\nfunction Wt(e, t) {\r\n  const n = Math.max(e.length, t.length);\r\n  return new Array(n).fill([]).map((r, i) => [e[i], t[i]]);\r\n}\r\nfunction Ve(e, t, n) {\r\n  return e.filter((r) => !t.map((i) => n(i)).includes(n(r)));\r\n}\r\nfunction ut(e) {\r\n  return e.map((t) => typeof t == \"string\" || typeof t == \"number\" ? `${t}` : N(t));\r\n}\r\nfunction eo(e, t) {\r\n  return {\r\n    dropped: Ve(e, t, N),\r\n    added: Ve(t, e, N)\r\n  };\r\n}\r\nfunction to(e) {\r\n  return e.added.length !== 0 || e.dropped.length !== 0;\r\n}\r\nfunction lt(e, t) {\r\n  const n = t.findIndex(\r\n    (r) => N(r) === N(e)\r\n  );\r\n  if (n === -1)\r\n    throw new Error(\r\n      `Element not part of the array: ${N(\r\n        e\r\n      )} not in ${ut(t)}`\r\n    );\r\n  return n;\r\n}\r\nfunction no(e, t, n) {\r\n  const r = lt(e, n), i = lt(t, n);\r\n  return n.splice(r, 1, t), n.splice(i, 1, e), n;\r\n}\r\nfunction ro(e, t) {\r\n  const n = lt(e, t);\r\n  return t.splice(n, 1), t;\r\n}\r\nfunction io(e, t) {\r\n  return [...t, e];\r\n}\r\nfunction tt(e, t) {\r\n  return Zi(e, t);\r\n}\r\nfunction Xo(e, t, n) {\r\n  let r = oo(e, t);\r\n  if (r.length < t.length) {\r\n    const s = Ve(t, r, N);\r\n    r = [...r, ...s];\r\n  }\r\n  const i = tt(r, n), o = tt(t, n);\r\n  if (Wt(i, o).forEach(([s, a], c) => {\r\n    if (s && a) {\r\n      const u = tt(r, n)[c], l = eo(u, a);\r\n      to(l) && (_.debug(\r\n        `Detected visual changes on page: ${c}, current: ${ut(\r\n          s\r\n        )}, next: ${ut(a)}`,\r\n        { changes: l }\r\n      ), l.added.length === l.dropped.length && Wt(l.added, l.dropped).forEach(([f, v]) => {\r\n        if (f && v)\r\n          r = no(f, v, r);\r\n        else\r\n          throw new Error(\r\n            `For a swap action we need a addition and a removal one is missing: ${f}, ${v}`\r\n          );\r\n      }), l.added.length === 0 && l.dropped.length > 0 && l.dropped.forEach((f) => {\r\n        r = ro(f, r);\r\n      }), l.added.length > 0 && l.dropped.length === 0 && l.added.forEach((f) => {\r\n        r = io(f, r);\r\n      }));\r\n    }\r\n  }), r.length > t.length) {\r\n    const s = Ve(r, t, N);\r\n    r = r.filter(\r\n      (a) => !s.map(N).includes(N(a))\r\n    );\r\n  }\r\n  return r;\r\n}\r\nfunction oo(e, t) {\r\n  return e.map((n) => {\r\n    const r = t.find(\r\n      (i) => (\r\n        // If the IDs match or ..\r\n        N(n) === N(i) || // ... if the current item is a placeholder and the new item is the track reference can replace it.\r\n        typeof n != \"number\" && Pe(n) && j(i) && ji(n, i)\r\n      )\r\n    );\r\n    return r ?? n;\r\n  });\r\n}\r\nfunction F(e) {\r\n  return `${En}-${e}`;\r\n}\r\nfunction Zo(e) {\r\n  const t = Bt(e), n = In(e.participant).pipe(\r\n    O(() => Bt(e)),\r\n    D(t)\r\n  );\r\n  return { className: F(\r\n    e.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera || e.source === livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\"\r\n  ), trackObserver: n };\r\n}\r\nfunction Bt(e) {\r\n  if (j(e))\r\n    return e.publication;\r\n  {\r\n    const { source: t, name: n, participant: r } = e;\r\n    if (t && n)\r\n      return r.getTrackPublications().find((i) => i.source === t && i.trackName === n);\r\n    if (n)\r\n      return r.getTrackPublicationByName(n);\r\n    if (t)\r\n      return r.getTrackPublication(t);\r\n    throw new Error(\"At least one of source and name needs to be defined\");\r\n  }\r\n}\r\nfunction le(e, ...t) {\r\n  return new k((r) => {\r\n    const i = () => {\r\n      r.next(e);\r\n    };\r\n    return t.forEach((s) => {\r\n      e.on(s, i);\r\n    }), () => {\r\n      t.forEach((s) => {\r\n        e.off(s, i);\r\n      });\r\n    };\r\n  }).pipe(D(e));\r\n}\r\nfunction ye(e, t) {\r\n  return new k((r) => {\r\n    const i = (...s) => {\r\n      r.next(s);\r\n    };\r\n    return e.on(t, i), () => {\r\n      e.off(t, i);\r\n    };\r\n  });\r\n}\r\nfunction es(e) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged).pipe(\r\n    O(([t]) => t),\r\n    D(e.state)\r\n  );\r\n}\r\nfunction ts(e) {\r\n  return le(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RoomMetadataChanged,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\r\n  ).pipe(\r\n    O((n) => ({ name: n.name, metadata: n.metadata }))\r\n  );\r\n}\r\nfunction ns(e) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveSpeakersChanged).pipe(\r\n    O(([t]) => t)\r\n  );\r\n}\r\nfunction rs(e, t, n = !0) {\r\n  const r = new k((o) => {\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room.getLocalDevices(e, n).then((s) => {\r\n      o.next(s), o.complete();\r\n    }).catch((s) => {\r\n      t == null || t(s), o.next([]), o.complete();\r\n    });\r\n  }), i = new k((o) => {\r\n    var s;\r\n    const a = () => V(this, null, function* () {\r\n      try {\r\n        const c = yield livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room.getLocalDevices(e, n);\r\n        o.next(c);\r\n      } catch (c) {\r\n        t == null || t(c);\r\n      }\r\n    });\r\n    if (typeof window < \"u\") {\r\n      if (!window.isSecureContext)\r\n        throw new Error(\r\n          \"Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices\"\r\n        );\r\n      (s = navigator == null ? void 0 : navigator.mediaDevices) == null || s.addEventListener(\"devicechange\", a);\r\n    }\r\n    return () => {\r\n      var c;\r\n      (c = navigator == null ? void 0 : navigator.mediaDevices) == null || c.removeEventListener(\"devicechange\", a);\r\n    };\r\n  });\r\n  return We(r, i);\r\n}\r\nfunction so(e) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.DataReceived);\r\n}\r\nfunction ao(e) {\r\n  return le(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.AudioPlaybackStatusChanged).pipe(\r\n    O((n) => ({ canPlayAudio: n.canPlaybackAudio }))\r\n  );\r\n}\r\nfunction co(e) {\r\n  return le(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.VideoPlaybackStatusChanged).pipe(\r\n    O((n) => ({ canPlayVideo: n.canPlaybackVideo }))\r\n  );\r\n}\r\nfunction uo(e, t) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ActiveDeviceChanged).pipe(\r\n    Qe(([n]) => n === t),\r\n    O(([n, r]) => (_.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", { kind: n, deviceId: r }), r))\r\n  );\r\n}\r\nfunction is(e, t) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantEncryptionStatusChanged).pipe(\r\n    Qe(\r\n      ([, n]) => (t == null ? void 0 : t.identity) === (n == null ? void 0 : n.identity) || !n && (t == null ? void 0 : t.identity) === e.localParticipant.identity\r\n    ),\r\n    O(([n]) => n),\r\n    D(\r\n      t != null && t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)\r\n    )\r\n  );\r\n}\r\nfunction os(e) {\r\n  return ye(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.RecordingStatusChanged).pipe(\r\n    O(([t]) => t),\r\n    D(e.isRecording)\r\n  );\r\n}\r\nfunction we(e, ...t) {\r\n  return new k((r) => {\r\n    const i = () => {\r\n      r.next(e);\r\n    };\r\n    return t.forEach((s) => {\r\n      e.on(s, i);\r\n    }), () => {\r\n      t.forEach((s) => {\r\n        e.off(s, i);\r\n      });\r\n    };\r\n  }).pipe(D(e));\r\n}\r\nfunction In(e) {\r\n  return we(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged,\r\n    // ParticipantEvent.IsSpeakingChanged,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackPublished,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnpublished,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.MediaDevicesError,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscriptionStatusChanged\r\n    // ParticipantEvent.ConnectionQualityChanged,\r\n  ).pipe(\r\n    O((n) => {\r\n      const { isMicrophoneEnabled: r, isCameraEnabled: i, isScreenShareEnabled: o } = n, s = n.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone), a = n.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera);\r\n      return {\r\n        isCameraEnabled: i,\r\n        isMicrophoneEnabled: r,\r\n        isScreenShareEnabled: o,\r\n        cameraTrack: a,\r\n        microphoneTrack: s,\r\n        participant: n\r\n      };\r\n    })\r\n  );\r\n}\r\nfunction lo(e) {\r\n  return e ? we(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantMetadataChanged,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantNameChanged\r\n  ).pipe(\r\n    O(({ name: n, identity: r, metadata: i }) => ({\r\n      name: n,\r\n      identity: r,\r\n      metadata: i\r\n    })),\r\n    D({\r\n      name: e.name,\r\n      identity: e.identity,\r\n      metadata: e.metadata\r\n    })\r\n  ) : void 0;\r\n}\r\nfunction fo(e) {\r\n  return Je(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ConnectionQualityChanged\r\n  ).pipe(\r\n    O(([n]) => n),\r\n    D(e.connectionQuality)\r\n  );\r\n}\r\nfunction Je(e, t) {\r\n  return new k((r) => {\r\n    const i = (...s) => {\r\n      r.next(s);\r\n    };\r\n    return e.on(t, i), () => {\r\n      e.off(t, i);\r\n    };\r\n  });\r\n}\r\nfunction po(e) {\r\n  var t, n, r, i;\r\n  return we(\r\n    e.participant,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackMuted,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnmuted,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackSubscribed,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.TrackUnsubscribed,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackPublished,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.LocalTrackUnpublished\r\n  ).pipe(\r\n    O((o) => {\r\n      var s, a;\r\n      const c = (s = e.publication) != null ? s : o.getTrackPublication(e.source);\r\n      return (a = c == null ? void 0 : c.isMuted) != null ? a : !0;\r\n    }),\r\n    D(\r\n      (i = (r = (t = e.publication) == null ? void 0 : t.isMuted) != null ? r : (n = e.participant.getTrackPublication(e.source)) == null ? void 0 : n.isMuted) != null ? i : !0\r\n    )\r\n  );\r\n}\r\nfunction ss(e) {\r\n  return Je(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.IsSpeakingChanged).pipe(\r\n    O(([t]) => t)\r\n  );\r\n}\r\nfunction as(e, t = {}) {\r\n  var n;\r\n  let r;\r\n  const i = new k((c) => (r = c, () => a.unsubscribe())).pipe(D(Array.from(e.remoteParticipants.values()))), o = (n = t.additionalRoomEvents) != null ? n : Cn, s = Array.from(\r\n    /* @__PURE__ */ new Set([\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\r\n      ...o\r\n    ])\r\n  ), a = le(e, ...s).subscribe(\r\n    (c) => r == null ? void 0 : r.next(Array.from(c.remoteParticipants.values()))\r\n  );\r\n  return e.remoteParticipants.size > 0 && (r == null || r.next(Array.from(e.remoteParticipants.values()))), i;\r\n}\r\nfunction cs(e, t, n = {}) {\r\n  var r;\r\n  const i = (r = n.additionalEvents) != null ? r : Pn;\r\n  return le(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\r\n  ).pipe(\r\n    Tn((s) => {\r\n      const a = s.getParticipantByIdentity(t);\r\n      return a ? we(a, ...i) : new k((c) => c.next(void 0));\r\n    }),\r\n    D(e.getParticipantByIdentity(t))\r\n  );\r\n}\r\nfunction us(e) {\r\n  return Je(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.ParticipantPermissionsChanged\r\n  ).pipe(\r\n    O(() => e.permissions),\r\n    D(e.permissions)\r\n  );\r\n}\r\nfunction ls(e, { kind: t, identity: n }, r = {}) {\r\n  var i;\r\n  const o = (i = r.additionalEvents) != null ? i : Pn, s = (c) => {\r\n    let u = !0;\r\n    return t && (u = u && c.kind === t), n && (u = u && c.identity === n), u;\r\n  };\r\n  return le(\r\n    e,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\r\n    livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged\r\n  ).pipe(\r\n    Tn((c) => {\r\n      const u = Array.from(c.remoteParticipants.values()).find(\r\n        (l) => s(l)\r\n      );\r\n      return u ? we(u, ...o) : new k((l) => l.next(void 0));\r\n    }),\r\n    D(Array.from(e.remoteParticipants.values()).find((c) => s(c)))\r\n  );\r\n}\r\nfunction fs(e) {\r\n  return typeof e > \"u\" ? new k() : Je(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.ParticipantEvent.AttributesChanged).pipe(\r\n    O(([t]) => ({\r\n      changed: t,\r\n      attributes: e.attributes\r\n    })),\r\n    D({ changed: e.attributes, attributes: e.attributes })\r\n  );\r\n}\r\nfunction ds(e, t, n, r, i) {\r\n  const { localParticipant: o } = t, s = (f, v) => {\r\n    let d = !1;\r\n    switch (f) {\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\r\n        d = v.isCameraEnabled;\r\n        break;\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\r\n        d = v.isMicrophoneEnabled;\r\n        break;\r\n      case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare:\r\n        d = v.isScreenShareEnabled;\r\n        break;\r\n    }\r\n    return d;\r\n  }, a = In(o).pipe(\r\n    O((f) => s(e, f.participant)),\r\n    D(s(e, o))\r\n  ), c = new Z(), u = (f, v) => V(this, null, function* () {\r\n    try {\r\n      switch (v ?? (v = n), c.next(!0), e) {\r\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\r\n          return yield o.setCameraEnabled(\r\n            f ?? !o.isCameraEnabled,\r\n            v,\r\n            r\r\n          ), o.isCameraEnabled;\r\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\r\n          return yield o.setMicrophoneEnabled(\r\n            f ?? !o.isMicrophoneEnabled,\r\n            v,\r\n            r\r\n          ), o.isMicrophoneEnabled;\r\n        case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.ScreenShare:\r\n          return yield o.setScreenShareEnabled(\r\n            f ?? !o.isScreenShareEnabled,\r\n            v,\r\n            r\r\n          ), o.isScreenShareEnabled;\r\n        default:\r\n          throw new TypeError(\"Tried to toggle unsupported source\");\r\n      }\r\n    } catch (d) {\r\n      if (i && d instanceof Error) {\r\n        i == null || i(d);\r\n        return;\r\n      } else\r\n        throw d;\r\n    } finally {\r\n      c.next(!1);\r\n    }\r\n  });\r\n  return {\r\n    className: F(\"button\"),\r\n    toggle: u,\r\n    enabledObserver: a,\r\n    pendingObserver: c.asObservable()\r\n  };\r\n}\r\nfunction ps() {\r\n  let e = !1;\r\n  const t = new Z(), n = new Z(), r = (o) => V(this, null, function* () {\r\n    n.next(!0), e = o ?? !e, t.next(e), n.next(!1);\r\n  });\r\n  return {\r\n    className: F(\"button\"),\r\n    toggle: r,\r\n    enabledObserver: t.asObservable(),\r\n    pendingObserver: n.asObservable()\r\n  };\r\n}\r\nfunction hs(e, t, n) {\r\n  const r = new ln(void 0), i = uo(t, e), o = (a, ...c) => V(this, [a, ...c], function* (u, l = {}) {\r\n    var f, v, d;\r\n    if (t) {\r\n      _.debug(`Switching active device of kind \"${e}\" with id ${u}.`), yield t.switchActiveDevice(e, u, l.exact);\r\n      const m = (f = t.getActiveDevice(e)) != null ? f : u;\r\n      m !== u && u !== \"default\" && _.info(\r\n        `We tried to select the device with id (${u}), but the browser decided to select the device with id (${m}) instead.`\r\n      );\r\n      let p;\r\n      e === \"audioinput\" ? p = (v = t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone)) == null ? void 0 : v.track : e === \"videoinput\" && (p = (d = t.localParticipant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera)) == null ? void 0 : d.track);\r\n      const g = u === \"default\" && !p || u === \"default\" && (p == null ? void 0 : p.mediaStreamTrack.label.startsWith(\"Default\"));\r\n      r.next(g ? u : m);\r\n    }\r\n  });\r\n  return {\r\n    className: F(\"media-device-select\"),\r\n    activeDeviceObservable: i,\r\n    setActiveMediaDevice: o\r\n  };\r\n}\r\nfunction vs(e) {\r\n  const t = (r) => {\r\n    e.disconnect(r);\r\n  };\r\n  return { className: F(\"disconnect-button\"), disconnect: t };\r\n}\r\nfunction ms(e) {\r\n  const t = F(\"connection-quality\"), n = fo(e);\r\n  return { className: t, connectionQualityObserver: n };\r\n}\r\nfunction gs(e) {\r\n  let t = \"track-muted-indicator-camera\";\r\n  switch (e.source) {\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Camera:\r\n      t = \"track-muted-indicator-camera\";\r\n      break;\r\n    case livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone:\r\n      t = \"track-muted-indicator-microphone\";\r\n      break;\r\n  }\r\n  const n = F(t), r = po(e);\r\n  return { className: n, mediaMutedObserver: r };\r\n}\r\nfunction bs(e) {\r\n  return { className: \"lk-participant-name\", infoObserver: lo(e) };\r\n}\r\nfunction ys() {\r\n  return {\r\n    className: F(\"participant-tile\")\r\n  };\r\n}\r\nvar ho = {\r\n  CHAT: \"lk.chat\",\r\n  TRANSCRIPTION: \"lk.transcription\"\r\n}, vo = {\r\n  CHAT: \"lk-chat-topic\"\r\n};\r\nfunction Rn(e, t) {\r\n  return V(this, arguments, function* (n, r, i = {}) {\r\n    const { reliable: o, destinationIdentities: s, topic: a } = i;\r\n    yield n.publishData(r, {\r\n      destinationIdentities: s,\r\n      topic: a,\r\n      reliable: o\r\n    });\r\n  });\r\n}\r\nfunction mo(e, t, n) {\r\n  const r = Array.isArray(t) ? t : [t], i = so(e).pipe(\r\n    Qe(\r\n      ([, , , c]) => t === void 0 || c !== void 0 && r.includes(c)\r\n    ),\r\n    O(([c, u, , l]) => {\r\n      const f = {\r\n        payload: c,\r\n        topic: l,\r\n        from: u\r\n      };\r\n      return n == null || n(f), f;\r\n    })\r\n  );\r\n  let o;\r\n  const s = new k((c) => {\r\n    o = c;\r\n  });\r\n  return { messageObservable: i, isSendingObservable: s, send: (c, ...u) => V(this, [c, ...u], function* (l, f = {}) {\r\n    o.next(!0);\r\n    try {\r\n      yield Rn(e.localParticipant, l, X({ topic: r[0] }, f));\r\n    } finally {\r\n      o.next(!1);\r\n    }\r\n  }) };\r\n}\r\nvar Ie = /* @__PURE__ */ new WeakMap();\r\nfunction go(e) {\r\n  return e.ignoreLegacy == !0;\r\n}\r\nvar bo = (e) => JSON.parse(new TextDecoder().decode(e)), yo = (e) => new TextEncoder().encode(JSON.stringify(e));\r\nfunction ws(e, t) {\r\n  var n, r, i, o, s, a;\r\n  const c = () => {\r\n    var b, S, C;\r\n    return ((b = e.serverInfo) == null ? void 0 : b.edition) === 1 || !!((S = e.serverInfo) != null && S.version) && (0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.compareVersions)((C = e.serverInfo) == null ? void 0 : C.version, \"1.8.2\") > 0;\r\n  }, u = new Z(), l = (n = t == null ? void 0 : t.channelTopic) != null ? n : ho.CHAT, f = (r = t == null ? void 0 : t.channelTopic) != null ? r : vo.CHAT;\r\n  let v = !1;\r\n  Ie.has(e) || (v = !0);\r\n  const d = (i = Ie.get(e)) != null ? i : /* @__PURE__ */ new Map(), m = (o = d.get(l)) != null ? o : new Z();\r\n  d.set(l, m), Ie.set(e, d);\r\n  const p = (s = t == null ? void 0 : t.messageDecoder) != null ? s : bo;\r\n  if (v) {\r\n    e.registerTextStreamHandler(l, (S, C) => V(this, null, function* () {\r\n      const { id: $, timestamp: I } = S.info;\r\n      Ge(S).pipe(\r\n        ct((T, L) => T + L),\r\n        O((T) => ({\r\n          id: $,\r\n          timestamp: I,\r\n          message: T,\r\n          from: e.getParticipantByIdentity(C.identity)\r\n          // editTimestamp: type === 'update' ? timestamp : undefined,\r\n        }))\r\n      ).subscribe({\r\n        next: (T) => m.next(T)\r\n      });\r\n    }));\r\n    const { messageObservable: b } = mo(e, [f]);\r\n    b.pipe(\r\n      O((S) => {\r\n        const C = p(S.payload);\r\n        return go(C) ? void 0 : Te(X({}, C), { from: S.from });\r\n      }),\r\n      Qe((S) => !!S),\r\n      Nt(u)\r\n    ).subscribe(m);\r\n  }\r\n  const g = m.pipe(\r\n    ct((b, S) => {\r\n      if (\"id\" in S && b.find((C) => {\r\n        var $, I;\r\n        return (($ = C.from) == null ? void 0 : $.identity) === ((I = S.from) == null ? void 0 : I.identity) && C.id === S.id;\r\n      })) {\r\n        const C = b.findIndex(($) => $.id === S.id);\r\n        if (C > -1) {\r\n          const $ = b[C];\r\n          b[C] = Te(X({}, S), {\r\n            timestamp: $.timestamp,\r\n            editTimestamp: S.timestamp\r\n          });\r\n        }\r\n        return [...b];\r\n      }\r\n      return [...b, S];\r\n    }, []),\r\n    Nt(u)\r\n  ), h = new ln(!1), x = (a = t == null ? void 0 : t.messageEncoder) != null ? a : yo, E = (b, S) => V(this, null, function* () {\r\n    var C;\r\n    S || (S = {}), (C = S.topic) != null || (S.topic = l), h.next(!0);\r\n    try {\r\n      const I = {\r\n        id: (yield e.localParticipant.sendText(b, S)).id,\r\n        timestamp: Date.now(),\r\n        message: b,\r\n        from: e.localParticipant,\r\n        attachedFiles: S.attachments\r\n      };\r\n      m.next(I);\r\n      const z = x(Te(X({}, I), {\r\n        ignoreLegacy: c()\r\n      }));\r\n      try {\r\n        yield Rn(e.localParticipant, z, {\r\n          reliable: !0,\r\n          topic: f\r\n        });\r\n      } catch (T) {\r\n        _.info(\"could not send message in legacy chat format\", T);\r\n      }\r\n      return I;\r\n    } finally {\r\n      h.next(!1);\r\n    }\r\n  });\r\n  function P() {\r\n    u.next(), u.complete(), m.complete(), Ie.delete(e), e.unregisterTextStreamHandler(l);\r\n  }\r\n  return e.once(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.Disconnected, P), {\r\n    messageObservable: g,\r\n    isSendingObservable: h,\r\n    send: E\r\n  };\r\n}\r\nfunction xs() {\r\n  const e = (n) => V(this, null, function* () {\r\n    _.info(\"Start Audio for room: \", n), yield n.startAudio();\r\n  });\r\n  return { className: F(\"start-audio-button\"), roomAudioPlaybackAllowedObservable: ao, handleStartAudioPlayback: e };\r\n}\r\nfunction Ss() {\r\n  const e = (n) => V(this, null, function* () {\r\n    _.info(\"Start Video for room: \", n), yield n.startVideo();\r\n  });\r\n  return { className: F(\"start-audio-button\"), roomVideoPlaybackAllowedObservable: co, handleStartVideoPlayback: e };\r\n}\r\nfunction Ts() {\r\n  return { className: [F(\"button\"), F(\"chat-toggle\")].join(\" \") };\r\n}\r\nfunction Es() {\r\n  return { className: [F(\"button\"), F(\"focus-toggle-button\")].join(\" \") };\r\n}\r\nfunction Cs() {\r\n  return { className: \"lk-clear-pin-button lk-button\" };\r\n}\r\nfunction Ps() {\r\n  return { className: \"lk-room-container\" };\r\n}\r\nfunction Vt(e, t, n = !0) {\r\n  const i = [e.localParticipant, ...Array.from(e.remoteParticipants.values())], o = [];\r\n  return i.forEach((s) => {\r\n    t.forEach((a) => {\r\n      const c = Array.from(\r\n        s.trackPublications.values()\r\n      ).filter(\r\n        (u) => u.source === a && // either return all or only the ones that are subscribed\r\n        (!n || u.track)\r\n      ).map((u) => ({\r\n        participant: s,\r\n        publication: u,\r\n        source: u.source\r\n      }));\r\n      o.push(...c);\r\n    });\r\n  }), { trackReferences: o, participants: i };\r\n}\r\nfunction Ht(e, t, n = !1) {\r\n  const { sources: r, kind: i, name: o } = t;\r\n  return Array.from(e.trackPublications.values()).filter(\r\n    (a) => (!r || r.includes(a.source)) && (!i || a.kind === i) && (!o || a.trackName === o) && // either return all or only the ones that are subscribed\r\n    (!n || a.track)\r\n  ).map((a) => ({\r\n    participant: e,\r\n    publication: a,\r\n    source: a.source\r\n  }));\r\n}\r\nfunction As(e, t, n) {\r\n  var r, i;\r\n  const o = (r = n.additionalRoomEvents) != null ? r : Cn, s = (i = n.onlySubscribed) != null ? i : !0, a = Array.from(\r\n    (/* @__PURE__ */ new Set([\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantConnected,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ParticipantDisconnected,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.ConnectionStateChanged,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackPublished,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.LocalTrackUnpublished,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackPublished,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackUnpublished,\r\n      livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscriptionStatusChanged,\r\n      ...o\r\n    ])).values()\r\n  );\r\n  return le(e, ...a).pipe(\r\n    O((u) => {\r\n      const l = Vt(u, t, s);\r\n      return _.debug(`TrackReference[] was updated. (length ${l.trackReferences.length})`, l), l;\r\n    }),\r\n    D(Vt(e, t, s))\r\n  );\r\n}\r\nfunction Os(e, t) {\r\n  return we(e, ...Hi).pipe(\r\n    O((r) => {\r\n      const i = Ht(r, t);\r\n      return _.debug(`TrackReference[] was updated. (length ${i.length})`, i), i;\r\n    }),\r\n    D(Ht(e, t))\r\n  );\r\n}\r\nfunction Mn(e, t) {\r\n  return new k((r) => {\r\n    const i = (...s) => {\r\n      r.next(s);\r\n    };\r\n    return e.on(t, i), () => {\r\n      e.off(t, i);\r\n    };\r\n  });\r\n}\r\nfunction ks(e) {\r\n  return Mn(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.TrackEvent.TranscriptionReceived);\r\n}\r\nfunction Ls(e) {\r\n  return Mn(e, livekit_client__WEBPACK_IMPORTED_MODULE_0__.TrackEvent.TimeSyncUpdate).pipe(\r\n    O(([t]) => t)\r\n  );\r\n}\r\nfunction _s(e, t = 1e3) {\r\n  if (e === null) return Dt(!1);\r\n  const n = at(e, \"mousemove\", { passive: !0 }).pipe(O(() => !0)), r = n.pipe(\r\n    hi({\r\n      each: t,\r\n      with: () => We(Dt(!1), r.pipe(Ii(n)))\r\n    }),\r\n    ki()\r\n  );\r\n  return r;\r\n}\r\nfunction wo(e, t) {\r\n  if (typeof localStorage > \"u\") {\r\n    _.error(\"Local storage is not available.\");\r\n    return;\r\n  }\r\n  try {\r\n    if (t) {\r\n      const n = Object.fromEntries(\r\n        Object.entries(t).filter(([, r]) => r !== \"\")\r\n      );\r\n      localStorage.setItem(e, JSON.stringify(n));\r\n    }\r\n  } catch (n) {\r\n    _.error(`Error setting item to local storage: ${n}`);\r\n  }\r\n}\r\nfunction xo(e) {\r\n  if (typeof localStorage > \"u\") {\r\n    _.error(\"Local storage is not available.\");\r\n    return;\r\n  }\r\n  try {\r\n    const t = localStorage.getItem(e);\r\n    if (!t) {\r\n      _.warn(`Item with key ${e} does not exist in local storage.`);\r\n      return;\r\n    }\r\n    return JSON.parse(t);\r\n  } catch (t) {\r\n    _.error(`Error getting item from local storage: ${t}`);\r\n    return;\r\n  }\r\n}\r\nfunction So(e) {\r\n  return {\r\n    load: () => xo(e),\r\n    save: (t) => wo(e, t)\r\n  };\r\n}\r\nvar To = `${En}-user-choices`, Se = {\r\n  videoEnabled: !0,\r\n  audioEnabled: !0,\r\n  videoDeviceId: \"default\",\r\n  audioDeviceId: \"default\",\r\n  username: \"\"\r\n}, { load: Eo, save: Co } = So(To);\r\nfunction Is(e, t = !1) {\r\n  t !== !0 && Co(e);\r\n}\r\nfunction Rs(e, t = !1) {\r\n  var n, r, i, o, s;\r\n  const a = {\r\n    videoEnabled: (n = e == null ? void 0 : e.videoEnabled) != null ? n : Se.videoEnabled,\r\n    audioEnabled: (r = e == null ? void 0 : e.audioEnabled) != null ? r : Se.audioEnabled,\r\n    videoDeviceId: (i = e == null ? void 0 : e.videoDeviceId) != null ? i : Se.videoDeviceId,\r\n    audioDeviceId: (o = e == null ? void 0 : e.audioDeviceId) != null ? o : Se.audioDeviceId,\r\n    username: (s = e == null ? void 0 : e.username) != null ? s : Se.username\r\n  };\r\n  if (t)\r\n    return a;\r\n  {\r\n    const c = Eo();\r\n    return X(X({}, a), c ?? {});\r\n  }\r\n}\r\nvar nt = null, rt = null, Po = 0;\r\nfunction zt() {\r\n  return nt || (nt = /* @__PURE__ */ new Map()), nt;\r\n}\r\nfunction Ao() {\r\n  return rt || (rt = /* @__PURE__ */ new WeakMap()), rt;\r\n}\r\nfunction Oo(e, t) {\r\n  const n = Ao();\r\n  let r = n.get(e);\r\n  return r || (r = `room_${Po++}`, n.set(e, r)), `${r}:${t}`;\r\n}\r\nfunction Ms(e, t) {\r\n  const n = Oo(e, t), r = zt(), i = r.get(n);\r\n  if (i)\r\n    return i;\r\n  const o = new Z(), s = [], a = \"lk.segment_id\";\r\n  e.registerTextStreamHandler(t, (u, l) => V(this, null, function* () {\r\n    var f;\r\n    const v = Ge(u).pipe(\r\n      ct((m, p) => m + p, \"\")\r\n    ), d = !!((f = u.info.attributes) != null && f[a]);\r\n    v.subscribe((m) => {\r\n      const p = s.findIndex(\r\n        (g) => {\r\n          var h, x;\r\n          return g.streamInfo.id === u.info.id || d && ((h = g.streamInfo.attributes) == null ? void 0 : h[a]) === ((x = u.info.attributes) == null ? void 0 : x[a]);\r\n        }\r\n      );\r\n      p !== -1 ? (s[p] = Te(X({}, s[p]), {\r\n        text: m\r\n      }), o.next([...s])) : (s.push({\r\n        text: m,\r\n        participantInfo: l,\r\n        streamInfo: u.info\r\n      }), o.next([...s]));\r\n    });\r\n  }));\r\n  const c = o.asObservable().pipe(_i());\r\n  return r.set(n, c), e.once(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.Disconnected, () => {\r\n    e.unregisterTextStreamHandler(t), o.complete(), zt().delete(n);\r\n  }), c;\r\n}\r\nfunction Dn(e, t) {\r\n  if (t.msg === \"show_chat\")\r\n    return { ...e, showChat: !0, unreadMessages: 0 };\r\n  if (t.msg === \"hide_chat\")\r\n    return { ...e, showChat: !1 };\r\n  if (t.msg === \"toggle_chat\") {\r\n    const n = { ...e, showChat: !e.showChat };\r\n    return n.showChat === !0 && (n.unreadMessages = 0), n;\r\n  } else return t.msg === \"unread_msg\" ? { ...e, unreadMessages: t.count } : t.msg === \"toggle_settings\" ? { ...e, showSettings: !e.showSettings } : { ...e };\r\n}\r\nfunction $n(e, t) {\r\n  return t.msg === \"set_pin\" ? [t.trackReference] : t.msg === \"clear_pin\" ? [] : { ...e };\r\n}\r\nconst Nn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\r\nfunction Ds() {\r\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Nn);\r\n  if (!e)\r\n    throw Error(\"Tried to access LayoutContext context outside a LayoutContextProvider provider.\");\r\n  return e;\r\n}\r\nfunction $s(e) {\r\n  const t = ko();\r\n  if (e ?? (e = t), !e)\r\n    throw Error(\"Tried to access LayoutContext context outside a LayoutContextProvider provider.\");\r\n  return e;\r\n}\r\nfunction Ns() {\r\n  const [e, t] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer($n, An), [n, r] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Dn, On);\r\n  return {\r\n    pin: { dispatch: t, state: e },\r\n    widget: { dispatch: r, state: n }\r\n  };\r\n}\r\nfunction Fs(e) {\r\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer($n, An), [r, i] = react__WEBPACK_IMPORTED_MODULE_1__.useReducer(Dn, On);\r\n  return e ?? {\r\n    pin: { dispatch: n, state: t },\r\n    widget: { dispatch: i, state: r }\r\n  };\r\n}\r\nfunction ko() {\r\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Nn);\r\n}\r\nconst Fn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(\r\n  void 0\r\n);\r\nfunction Us() {\r\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Fn);\r\n  if (!e)\r\n    throw Error(\"tried to access track context outside of track context provider\");\r\n  return e;\r\n}\r\nfunction Un() {\r\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Fn);\r\n}\r\nfunction js(e) {\r\n  const t = Un(), n = e ?? t;\r\n  if (!n)\r\n    throw new Error(\r\n      \"No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly\"\r\n    );\r\n  return n;\r\n}\r\nconst jn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\r\nfunction Ws() {\r\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(jn);\r\n  if (!e)\r\n    throw Error(\"tried to access participant context outside of participant context provider\");\r\n  return e;\r\n}\r\nfunction Lo() {\r\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(jn);\r\n}\r\nfunction Bs(e) {\r\n  const t = Lo(), n = Un(), r = e ?? t ?? (n == null ? void 0 : n.participant);\r\n  if (!r)\r\n    throw new Error(\r\n      \"No participant provided, make sure you are inside a participant context or pass the participant explicitly\"\r\n    );\r\n  return r;\r\n}\r\nconst Wn = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\r\nfunction Vs() {\r\n  const e = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Wn);\r\n  if (!e)\r\n    throw Error(\"tried to access room context outside of livekit room component\");\r\n  return e;\r\n}\r\nfunction _o() {\r\n  return react__WEBPACK_IMPORTED_MODULE_1__.useContext(Wn);\r\n}\r\nfunction Hs(e) {\r\n  const t = _o(), n = e ?? t;\r\n  if (!n)\r\n    throw new Error(\r\n      \"No room provided, make sure you are inside a Room context or pass the room explicitly\"\r\n    );\r\n  return n;\r\n}\r\nconst Io = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\r\nfunction zs(e) {\r\n  const t = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Io);\r\n  if (e === !0) {\r\n    if (t)\r\n      return t;\r\n    throw Error(\"tried to access feature context, but none is present\");\r\n  }\r\n  return t;\r\n}\r\n\r\n//# sourceMappingURL=contexts-Cm1aSBTs.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvY29udGV4dHMtQ20xYVNCVHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrTTtBQUN2SztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEMsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsR0FBRyxxQkFBcUI7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQsSUFBSTtBQUNKLFVBQVU7QUFDVixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCO0FBQ2hCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQkFBZ0I7QUFDaEIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQixXQUFXLDJCQUEyQixVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxnUUFBZ1EsMERBQTBEO0FBQzFULDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQSxjQUFjLHVCQUF1QixHQUFHLFNBQVM7QUFDakQ7QUFDQSxjQUFjLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QjtBQUN2Rix3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlHQUFpRyxFQUFFO0FBQ25HO0FBQ0Esc0JBQXNCLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSwwSkFBMEosR0FBRyxlQUFlLElBQUk7QUFDck8scUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBLGNBQWMsV0FBVyxJQUFJO0FBQzdCLDRCQUE0QixHQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pELEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0gsRUFBRSxxREFBQztBQUNILEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0g7QUFDQTtBQUNBLEVBQUUscURBQUM7QUFDSCxFQUFFLHFEQUFDO0FBQ0g7QUFDQSxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNIO0FBQ0EsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0gsRUFBRSw0REFBQztBQUNILEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0g7QUFDQTtBQUNBLEVBQUUsNERBQUM7QUFDSCxFQUFFLDREQUFDO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQiwyREFBRTtBQUNuQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQUUsdUJBQXVCLG9EQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLCtEQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxHQUFHLHdDQUF3QyxFQUFFO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxHQUFHLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFDLDBDQUEwQyxpREFBQywrQ0FBK0MsaURBQUM7QUFDdEksR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsU0FBUyxTQUFTLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxhQUFhO0FBQzNEO0FBQ0EsVUFBVSxVQUFVLE1BQU07QUFDMUIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsRUFBRSxJQUFJLEVBQUU7QUFDMUY7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSxHQUFHLEdBQUcsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCLGlEQUFDLCtCQUErQixpREFBQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSxxREFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTCxJQUFJLHFEQUFDO0FBQ0w7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQUU7QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFFO0FBQzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFDO0FBQ2hCO0FBQ0E7QUFDQSxlQUFlLHFEQUFDO0FBQ2hCLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBQztBQUNoQixnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQSx1RkFBdUYsc0JBQXNCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFDO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMO0FBQ0EsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzRUFBc0UsK0JBQStCLGlEQUFDLCtDQUErQyxpREFBQztBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMO0FBQ0EsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMLElBQUksNERBQUM7QUFDTCxJQUFJLDREQUFDO0FBQ0wsSUFBSSw0REFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscURBQUM7QUFDTCxJQUFJLHFEQUFDO0FBQ0wsSUFBSSxxREFBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQixRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxREFBQztBQUNMLElBQUkscURBQUM7QUFDTCxJQUFJLHFEQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDREQUFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxRQUFRLGlEQUFpRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0EsV0FBVyxpREFBQztBQUNaO0FBQ0E7QUFDQSxXQUFXLGlEQUFDO0FBQ1o7QUFDQTtBQUNBLFdBQVcsaURBQUM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0Esa0RBQWtELEVBQUUsWUFBWSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQSxrREFBa0QsRUFBRSwyREFBMkQsRUFBRTtBQUNqSDtBQUNBO0FBQ0EsMkVBQTJFLGlEQUFDLHlIQUF5SCxpREFBQztBQUN0TTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBQztBQUNWO0FBQ0E7QUFDQSxTQUFTLGlEQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksa0RBQWtEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLHdHQUF3RztBQUNuSDtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUgsK0RBQUU7QUFDdkgsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUSxjQUFjO0FBQzdELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBLFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUCxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQLE1BQU0scURBQUM7QUFDUCxNQUFNLHFEQUFDO0FBQ1AsTUFBTSxxREFBQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx5QkFBeUI7QUFDdkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsc0RBQUU7QUFDakI7QUFDQTtBQUNBLGVBQWUsc0RBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixHQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLHFCQUFxQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLLG9CQUFvQixFQUFFLEdBQUcsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSw2QkFBNkIscURBQUM7QUFDOUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSSx1Q0FBdUMsZ0NBQWdDLGtDQUFrQyxzQ0FBc0MsSUFBSTtBQUN2SjtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0EsV0FBVyxnREFBZTtBQUMxQjtBQUNBLFlBQVksNkNBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBWSxtQkFBbUIsNkNBQVk7QUFDNUQ7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFZLG1CQUFtQiw2Q0FBWTtBQUM1RDtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFZO0FBQ3JCO0FBQ0EsV0FBVyxnREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0RBQWU7QUFDMUI7QUFDQSxZQUFZLDZDQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMEZFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGxpdmVraXRcXGNvbXBvbmVudHMtcmVhY3RcXGRpc3RcXGNvbnRleHRzLUNtMWFTQlRzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXRMb2dMZXZlbCBhcyBWbiwgTG9nTGV2ZWwgYXMgU3QsIHNldExvZ0V4dGVuc2lvbiBhcyBIbiwgUm9vbUV2ZW50IGFzIHksIFBhcnRpY2lwYW50RXZlbnQgYXMgdywgVHJhY2sgYXMgTSwgVHJhY2tFdmVudCBhcyBZdCwgY29tcGFyZVZlcnNpb25zIGFzIHpuLCBSb29tIGFzIFR0IH0gZnJvbSBcImxpdmVraXQtY2xpZW50XCI7XHJcbmltcG9ydCAqIGFzIFIgZnJvbSBcInJlYWN0XCI7XHJcbmNvbnN0IERlID0gTWF0aC5taW4sIHNlID0gTWF0aC5tYXgsICRlID0gTWF0aC5yb3VuZCwgTGUgPSBNYXRoLmZsb29yLCBHID0gKGUpID0+ICh7XHJcbiAgeDogZSxcclxuICB5OiBlXHJcbn0pLCBZbiA9IHtcclxuICBsZWZ0OiBcInJpZ2h0XCIsXHJcbiAgcmlnaHQ6IFwibGVmdFwiLFxyXG4gIGJvdHRvbTogXCJ0b3BcIixcclxuICB0b3A6IFwiYm90dG9tXCJcclxufSwgcW4gPSB7XHJcbiAgc3RhcnQ6IFwiZW5kXCIsXHJcbiAgZW5kOiBcInN0YXJ0XCJcclxufTtcclxuZnVuY3Rpb24gRXQoZSwgdCwgbikge1xyXG4gIHJldHVybiBzZShlLCBEZSh0LCBuKSk7XHJcbn1cclxuZnVuY3Rpb24gSGUoZSwgdCkge1xyXG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKHQpIDogZTtcclxufVxyXG5mdW5jdGlvbiBhZShlKSB7XHJcbiAgcmV0dXJuIGUuc3BsaXQoXCItXCIpWzBdO1xyXG59XHJcbmZ1bmN0aW9uIHplKGUpIHtcclxuICByZXR1cm4gZS5zcGxpdChcIi1cIilbMV07XHJcbn1cclxuZnVuY3Rpb24gcXQoZSkge1xyXG4gIHJldHVybiBlID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XHJcbn1cclxuZnVuY3Rpb24gS3QoZSkge1xyXG4gIHJldHVybiBlID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XHJcbn1cclxuZnVuY3Rpb24gaGUoZSkge1xyXG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5jbHVkZXMoYWUoZSkpID8gXCJ5XCIgOiBcInhcIjtcclxufVxyXG5mdW5jdGlvbiBHdChlKSB7XHJcbiAgcmV0dXJuIHF0KGhlKGUpKTtcclxufVxyXG5mdW5jdGlvbiBLbihlLCB0LCBuKSB7XHJcbiAgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xyXG4gIGNvbnN0IHIgPSB6ZShlKSwgaSA9IEd0KGUpLCBvID0gS3QoaSk7XHJcbiAgbGV0IHMgPSBpID09PSBcInhcIiA/IHIgPT09IChuID8gXCJlbmRcIiA6IFwic3RhcnRcIikgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiA6IHIgPT09IFwic3RhcnRcIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xyXG4gIHJldHVybiB0LnJlZmVyZW5jZVtvXSA+IHQuZmxvYXRpbmdbb10gJiYgKHMgPSBOZShzKSksIFtzLCBOZShzKV07XHJcbn1cclxuZnVuY3Rpb24gR24oZSkge1xyXG4gIGNvbnN0IHQgPSBOZShlKTtcclxuICByZXR1cm4gW2l0KGUpLCB0LCBpdCh0KV07XHJcbn1cclxuZnVuY3Rpb24gaXQoZSkge1xyXG4gIHJldHVybiBlLnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCAodCkgPT4gcW5bdF0pO1xyXG59XHJcbmZ1bmN0aW9uIFFuKGUsIHQsIG4pIHtcclxuICBjb25zdCByID0gW1wibGVmdFwiLCBcInJpZ2h0XCJdLCBpID0gW1wicmlnaHRcIiwgXCJsZWZ0XCJdLCBvID0gW1widG9wXCIsIFwiYm90dG9tXCJdLCBzID0gW1wiYm90dG9tXCIsIFwidG9wXCJdO1xyXG4gIHN3aXRjaCAoZSkge1xyXG4gICAgY2FzZSBcInRvcFwiOlxyXG4gICAgY2FzZSBcImJvdHRvbVwiOlxyXG4gICAgICByZXR1cm4gbiA/IHQgPyBpIDogciA6IHQgPyByIDogaTtcclxuICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgcmV0dXJuIHQgPyBvIDogcztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gSm4oZSwgdCwgbiwgcikge1xyXG4gIGNvbnN0IGkgPSB6ZShlKTtcclxuICBsZXQgbyA9IFFuKGFlKGUpLCBuID09PSBcInN0YXJ0XCIsIHIpO1xyXG4gIHJldHVybiBpICYmIChvID0gby5tYXAoKHMpID0+IHMgKyBcIi1cIiArIGkpLCB0ICYmIChvID0gby5jb25jYXQoby5tYXAoaXQpKSkpLCBvO1xyXG59XHJcbmZ1bmN0aW9uIE5lKGUpIHtcclxuICByZXR1cm4gZS5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgKHQpID0+IFluW3RdKTtcclxufVxyXG5mdW5jdGlvbiBYbihlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvcDogMCxcclxuICAgIHJpZ2h0OiAwLFxyXG4gICAgYm90dG9tOiAwLFxyXG4gICAgbGVmdDogMCxcclxuICAgIC4uLmVcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIFpuKGUpIHtcclxuICByZXR1cm4gdHlwZW9mIGUgIT0gXCJudW1iZXJcIiA/IFhuKGUpIDoge1xyXG4gICAgdG9wOiBlLFxyXG4gICAgcmlnaHQ6IGUsXHJcbiAgICBib3R0b206IGUsXHJcbiAgICBsZWZ0OiBlXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBGZShlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgeDogdCxcclxuICAgIHk6IG4sXHJcbiAgICB3aWR0aDogcixcclxuICAgIGhlaWdodDogaVxyXG4gIH0gPSBlO1xyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogcixcclxuICAgIGhlaWdodDogaSxcclxuICAgIHRvcDogbixcclxuICAgIGxlZnQ6IHQsXHJcbiAgICByaWdodDogdCArIHIsXHJcbiAgICBib3R0b206IG4gKyBpLFxyXG4gICAgeDogdCxcclxuICAgIHk6IG5cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIEN0KGUsIHQsIG4pIHtcclxuICBsZXQge1xyXG4gICAgcmVmZXJlbmNlOiByLFxyXG4gICAgZmxvYXRpbmc6IGlcclxuICB9ID0gZTtcclxuICBjb25zdCBvID0gaGUodCksIHMgPSBHdCh0KSwgYSA9IEt0KHMpLCBjID0gYWUodCksIHUgPSBvID09PSBcInlcIiwgbCA9IHIueCArIHIud2lkdGggLyAyIC0gaS53aWR0aCAvIDIsIGYgPSByLnkgKyByLmhlaWdodCAvIDIgLSBpLmhlaWdodCAvIDIsIHYgPSByW2FdIC8gMiAtIGlbYV0gLyAyO1xyXG4gIGxldCBkO1xyXG4gIHN3aXRjaCAoYykge1xyXG4gICAgY2FzZSBcInRvcFwiOlxyXG4gICAgICBkID0ge1xyXG4gICAgICAgIHg6IGwsXHJcbiAgICAgICAgeTogci55IC0gaS5oZWlnaHRcclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiYm90dG9tXCI6XHJcbiAgICAgIGQgPSB7XHJcbiAgICAgICAgeDogbCxcclxuICAgICAgICB5OiByLnkgKyByLmhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJyaWdodFwiOlxyXG4gICAgICBkID0ge1xyXG4gICAgICAgIHg6IHIueCArIHIud2lkdGgsXHJcbiAgICAgICAgeTogZlxyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICAgIGQgPSB7XHJcbiAgICAgICAgeDogci54IC0gaS53aWR0aCxcclxuICAgICAgICB5OiBmXHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgZCA9IHtcclxuICAgICAgICB4OiByLngsXHJcbiAgICAgICAgeTogci55XHJcbiAgICAgIH07XHJcbiAgfVxyXG4gIHN3aXRjaCAoemUodCkpIHtcclxuICAgIGNhc2UgXCJzdGFydFwiOlxyXG4gICAgICBkW3NdIC09IHYgKiAobiAmJiB1ID8gLTEgOiAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiZW5kXCI6XHJcbiAgICAgIGRbc10gKz0gdiAqIChuICYmIHUgPyAtMSA6IDEpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIGQ7XHJcbn1cclxuY29uc3QgZXIgPSBhc3luYyAoZSwgdCwgbikgPT4ge1xyXG4gIGNvbnN0IHtcclxuICAgIHBsYWNlbWVudDogciA9IFwiYm90dG9tXCIsXHJcbiAgICBzdHJhdGVneTogaSA9IFwiYWJzb2x1dGVcIixcclxuICAgIG1pZGRsZXdhcmU6IG8gPSBbXSxcclxuICAgIHBsYXRmb3JtOiBzXHJcbiAgfSA9IG4sIGEgPSBvLmZpbHRlcihCb29sZWFuKSwgYyA9IGF3YWl0IChzLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBzLmlzUlRMKHQpKTtcclxuICBsZXQgdSA9IGF3YWl0IHMuZ2V0RWxlbWVudFJlY3RzKHtcclxuICAgIHJlZmVyZW5jZTogZSxcclxuICAgIGZsb2F0aW5nOiB0LFxyXG4gICAgc3RyYXRlZ3k6IGlcclxuICB9KSwge1xyXG4gICAgeDogbCxcclxuICAgIHk6IGZcclxuICB9ID0gQ3QodSwgciwgYyksIHYgPSByLCBkID0ge30sIG0gPSAwO1xyXG4gIGZvciAobGV0IHAgPSAwOyBwIDwgYS5sZW5ndGg7IHArKykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lOiBnLFxyXG4gICAgICBmbjogaFxyXG4gICAgfSA9IGFbcF0sIHtcclxuICAgICAgeCxcclxuICAgICAgeTogRSxcclxuICAgICAgZGF0YTogUCxcclxuICAgICAgcmVzZXQ6IGJcclxuICAgIH0gPSBhd2FpdCBoKHtcclxuICAgICAgeDogbCxcclxuICAgICAgeTogZixcclxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcixcclxuICAgICAgcGxhY2VtZW50OiB2LFxyXG4gICAgICBzdHJhdGVneTogaSxcclxuICAgICAgbWlkZGxld2FyZURhdGE6IGQsXHJcbiAgICAgIHJlY3RzOiB1LFxyXG4gICAgICBwbGF0Zm9ybTogcyxcclxuICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICByZWZlcmVuY2U6IGUsXHJcbiAgICAgICAgZmxvYXRpbmc6IHRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBsID0geCA/PyBsLCBmID0gRSA/PyBmLCBkID0ge1xyXG4gICAgICAuLi5kLFxyXG4gICAgICBbZ106IHtcclxuICAgICAgICAuLi5kW2ddLFxyXG4gICAgICAgIC4uLlBcclxuICAgICAgfVxyXG4gICAgfSwgYiAmJiBtIDw9IDUwICYmIChtKyssIHR5cGVvZiBiID09IFwib2JqZWN0XCIgJiYgKGIucGxhY2VtZW50ICYmICh2ID0gYi5wbGFjZW1lbnQpLCBiLnJlY3RzICYmICh1ID0gYi5yZWN0cyA9PT0gITAgPyBhd2FpdCBzLmdldEVsZW1lbnRSZWN0cyh7XHJcbiAgICAgIHJlZmVyZW5jZTogZSxcclxuICAgICAgZmxvYXRpbmc6IHQsXHJcbiAgICAgIHN0cmF0ZWd5OiBpXHJcbiAgICB9KSA6IGIucmVjdHMpLCB7XHJcbiAgICAgIHg6IGwsXHJcbiAgICAgIHk6IGZcclxuICAgIH0gPSBDdCh1LCB2LCBjKSksIHAgPSAtMSk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBsLFxyXG4gICAgeTogZixcclxuICAgIHBsYWNlbWVudDogdixcclxuICAgIHN0cmF0ZWd5OiBpLFxyXG4gICAgbWlkZGxld2FyZURhdGE6IGRcclxuICB9O1xyXG59O1xyXG5hc3luYyBmdW5jdGlvbiBRdChlLCB0KSB7XHJcbiAgdmFyIG47XHJcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0ge30pO1xyXG4gIGNvbnN0IHtcclxuICAgIHg6IHIsXHJcbiAgICB5OiBpLFxyXG4gICAgcGxhdGZvcm06IG8sXHJcbiAgICByZWN0czogcyxcclxuICAgIGVsZW1lbnRzOiBhLFxyXG4gICAgc3RyYXRlZ3k6IGNcclxuICB9ID0gZSwge1xyXG4gICAgYm91bmRhcnk6IHUgPSBcImNsaXBwaW5nQW5jZXN0b3JzXCIsXHJcbiAgICByb290Qm91bmRhcnk6IGwgPSBcInZpZXdwb3J0XCIsXHJcbiAgICBlbGVtZW50Q29udGV4dDogZiA9IFwiZmxvYXRpbmdcIixcclxuICAgIGFsdEJvdW5kYXJ5OiB2ID0gITEsXHJcbiAgICBwYWRkaW5nOiBkID0gMFxyXG4gIH0gPSBIZSh0LCBlKSwgbSA9IFpuKGQpLCBnID0gYVt2ID8gZiA9PT0gXCJmbG9hdGluZ1wiID8gXCJyZWZlcmVuY2VcIiA6IFwiZmxvYXRpbmdcIiA6IGZdLCBoID0gRmUoYXdhaXQgby5nZXRDbGlwcGluZ1JlY3Qoe1xyXG4gICAgZWxlbWVudDogKG4gPSBhd2FpdCAoby5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaXNFbGVtZW50KGcpKSkgPT0gbnVsbCB8fCBuID8gZyA6IGcuY29udGV4dEVsZW1lbnQgfHwgYXdhaXQgKG8uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBvLmdldERvY3VtZW50RWxlbWVudChhLmZsb2F0aW5nKSksXHJcbiAgICBib3VuZGFyeTogdSxcclxuICAgIHJvb3RCb3VuZGFyeTogbCxcclxuICAgIHN0cmF0ZWd5OiBjXHJcbiAgfSkpLCB4ID0gZiA9PT0gXCJmbG9hdGluZ1wiID8ge1xyXG4gICAgeDogcixcclxuICAgIHk6IGksXHJcbiAgICB3aWR0aDogcy5mbG9hdGluZy53aWR0aCxcclxuICAgIGhlaWdodDogcy5mbG9hdGluZy5oZWlnaHRcclxuICB9IDogcy5yZWZlcmVuY2UsIEUgPSBhd2FpdCAoby5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0T2Zmc2V0UGFyZW50KGEuZmxvYXRpbmcpKSwgUCA9IGF3YWl0IChvLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogby5pc0VsZW1lbnQoRSkpID8gYXdhaXQgKG8uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0U2NhbGUoRSkpIHx8IHtcclxuICAgIHg6IDEsXHJcbiAgICB5OiAxXHJcbiAgfSA6IHtcclxuICAgIHg6IDEsXHJcbiAgICB5OiAxXHJcbiAgfSwgYiA9IEZlKG8uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBvLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcclxuICAgIGVsZW1lbnRzOiBhLFxyXG4gICAgcmVjdDogeCxcclxuICAgIG9mZnNldFBhcmVudDogRSxcclxuICAgIHN0cmF0ZWd5OiBjXHJcbiAgfSkgOiB4KTtcclxuICByZXR1cm4ge1xyXG4gICAgdG9wOiAoaC50b3AgLSBiLnRvcCArIG0udG9wKSAvIFAueSxcclxuICAgIGJvdHRvbTogKGIuYm90dG9tIC0gaC5ib3R0b20gKyBtLmJvdHRvbSkgLyBQLnksXHJcbiAgICBsZWZ0OiAoaC5sZWZ0IC0gYi5sZWZ0ICsgbS5sZWZ0KSAvIFAueCxcclxuICAgIHJpZ2h0OiAoYi5yaWdodCAtIGgucmlnaHQgKyBtLnJpZ2h0KSAvIFAueFxyXG4gIH07XHJcbn1cclxuY29uc3QgdHIgPSBmdW5jdGlvbihlKSB7XHJcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwge1xyXG4gICAgbmFtZTogXCJmbGlwXCIsXHJcbiAgICBvcHRpb25zOiBlLFxyXG4gICAgYXN5bmMgZm4odCkge1xyXG4gICAgICB2YXIgbiwgcjtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHBsYWNlbWVudDogaSxcclxuICAgICAgICBtaWRkbGV3YXJlRGF0YTogbyxcclxuICAgICAgICByZWN0czogcyxcclxuICAgICAgICBpbml0aWFsUGxhY2VtZW50OiBhLFxyXG4gICAgICAgIHBsYXRmb3JtOiBjLFxyXG4gICAgICAgIGVsZW1lbnRzOiB1XHJcbiAgICAgIH0gPSB0LCB7XHJcbiAgICAgICAgbWFpbkF4aXM6IGwgPSAhMCxcclxuICAgICAgICBjcm9zc0F4aXM6IGYgPSAhMCxcclxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHYsXHJcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneTogZCA9IFwiYmVzdEZpdFwiLFxyXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb246IG0gPSBcIm5vbmVcIixcclxuICAgICAgICBmbGlwQWxpZ25tZW50OiBwID0gITAsXHJcbiAgICAgICAgLi4uZ1xyXG4gICAgICB9ID0gSGUoZSwgdCk7XHJcbiAgICAgIGlmICgobiA9IG8uYXJyb3cpICE9IG51bGwgJiYgbi5hbGlnbm1lbnRPZmZzZXQpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICBjb25zdCBoID0gYWUoaSksIHggPSBoZShhKSwgRSA9IGFlKGEpID09PSBhLCBQID0gYXdhaXQgKGMuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IGMuaXNSVEwodS5mbG9hdGluZykpLCBiID0gdiB8fCAoRSB8fCAhcCA/IFtOZShhKV0gOiBHbihhKSksIFMgPSBtICE9PSBcIm5vbmVcIjtcclxuICAgICAgIXYgJiYgUyAmJiBiLnB1c2goLi4uSm4oYSwgcCwgbSwgUCkpO1xyXG4gICAgICBjb25zdCBDID0gW2EsIC4uLmJdLCAkID0gYXdhaXQgUXQodCwgZyksIEkgPSBbXTtcclxuICAgICAgbGV0IHogPSAoKHIgPSBvLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiByLm92ZXJmbG93cykgfHwgW107XHJcbiAgICAgIGlmIChsICYmIEkucHVzaCgkW2hdKSwgZikge1xyXG4gICAgICAgIGNvbnN0IEsgPSBLbihpLCBzLCBQKTtcclxuICAgICAgICBJLnB1c2goJFtLWzBdXSwgJFtLWzFdXSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHogPSBbLi4ueiwge1xyXG4gICAgICAgIHBsYWNlbWVudDogaSxcclxuICAgICAgICBvdmVyZmxvd3M6IElcclxuICAgICAgfV0sICFJLmV2ZXJ5KChLKSA9PiBLIDw9IDApKSB7XHJcbiAgICAgICAgdmFyIFQsIEw7XHJcbiAgICAgICAgY29uc3QgSyA9ICgoKFQgPSBvLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBULmluZGV4KSB8fCAwKSArIDEsIGtlID0gQ1tLXTtcclxuICAgICAgICBpZiAoa2UpXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgaW5kZXg6IEssXHJcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiB6XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlc2V0OiB7XHJcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBrZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIGxldCB4ZSA9IChMID0gei5maWx0ZXIoKGZlKSA9PiBmZS5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoZmUsIHRlKSA9PiBmZS5vdmVyZmxvd3NbMV0gLSB0ZS5vdmVyZmxvd3NbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogTC5wbGFjZW1lbnQ7XHJcbiAgICAgICAgaWYgKCF4ZSlcclxuICAgICAgICAgIHN3aXRjaCAoZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYmVzdEZpdFwiOiB7XHJcbiAgICAgICAgICAgICAgdmFyIG9lO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGZlID0gKG9lID0gei5maWx0ZXIoKHRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUykge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZSA9IGhlKHRlLnBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZSA9PT0geCB8fCAvLyBDcmVhdGUgYSBiaWFzIHRvIHRoZSBgeWAgc2lkZSBheGlzIGR1ZSB0byBob3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgZGlyZWN0aW9ucyBmYXZvcmluZyBncmVhdGVyIHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgICBuZSA9PT0gXCJ5XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgfSkubWFwKCh0ZSkgPT4gW3RlLnBsYWNlbWVudCwgdGUub3ZlcmZsb3dzLmZpbHRlcigobmUpID0+IG5lID4gMCkucmVkdWNlKChuZSwgQm4pID0+IG5lICsgQm4sIDApXSkuc29ydCgodGUsIG5lKSA9PiB0ZVsxXSAtIG5lWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG9lWzBdO1xyXG4gICAgICAgICAgICAgIGZlICYmICh4ZSA9IGZlKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiaW5pdGlhbFBsYWNlbWVudFwiOlxyXG4gICAgICAgICAgICAgIHhlID0gYTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICBpZiAoaSAhPT0geGUpXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXNldDoge1xyXG4gICAgICAgICAgICAgIHBsYWNlbWVudDogeGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuYXN5bmMgZnVuY3Rpb24gbnIoZSwgdCkge1xyXG4gIGNvbnN0IHtcclxuICAgIHBsYWNlbWVudDogbixcclxuICAgIHBsYXRmb3JtOiByLFxyXG4gICAgZWxlbWVudHM6IGlcclxuICB9ID0gZSwgbyA9IGF3YWl0IChyLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiByLmlzUlRMKGkuZmxvYXRpbmcpKSwgcyA9IGFlKG4pLCBhID0gemUobiksIGMgPSBoZShuKSA9PT0gXCJ5XCIsIHUgPSBbXCJsZWZ0XCIsIFwidG9wXCJdLmluY2x1ZGVzKHMpID8gLTEgOiAxLCBsID0gbyAmJiBjID8gLTEgOiAxLCBmID0gSGUodCwgZSk7XHJcbiAgbGV0IHtcclxuICAgIG1haW5BeGlzOiB2LFxyXG4gICAgY3Jvc3NBeGlzOiBkLFxyXG4gICAgYWxpZ25tZW50QXhpczogbVxyXG4gIH0gPSB0eXBlb2YgZiA9PSBcIm51bWJlclwiID8ge1xyXG4gICAgbWFpbkF4aXM6IGYsXHJcbiAgICBjcm9zc0F4aXM6IDAsXHJcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXHJcbiAgfSA6IHtcclxuICAgIG1haW5BeGlzOiBmLm1haW5BeGlzIHx8IDAsXHJcbiAgICBjcm9zc0F4aXM6IGYuY3Jvc3NBeGlzIHx8IDAsXHJcbiAgICBhbGlnbm1lbnRBeGlzOiBmLmFsaWdubWVudEF4aXNcclxuICB9O1xyXG4gIHJldHVybiBhICYmIHR5cGVvZiBtID09IFwibnVtYmVyXCIgJiYgKGQgPSBhID09PSBcImVuZFwiID8gbSAqIC0xIDogbSksIGMgPyB7XHJcbiAgICB4OiBkICogbCxcclxuICAgIHk6IHYgKiB1XHJcbiAgfSA6IHtcclxuICAgIHg6IHYgKiB1LFxyXG4gICAgeTogZCAqIGxcclxuICB9O1xyXG59XHJcbmNvbnN0IHJyID0gZnVuY3Rpb24oZSkge1xyXG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAwKSwge1xyXG4gICAgbmFtZTogXCJvZmZzZXRcIixcclxuICAgIG9wdGlvbnM6IGUsXHJcbiAgICBhc3luYyBmbih0KSB7XHJcbiAgICAgIHZhciBuLCByO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgeDogaSxcclxuICAgICAgICB5OiBvLFxyXG4gICAgICAgIHBsYWNlbWVudDogcyxcclxuICAgICAgICBtaWRkbGV3YXJlRGF0YTogYVxyXG4gICAgICB9ID0gdCwgYyA9IGF3YWl0IG5yKHQsIGUpO1xyXG4gICAgICByZXR1cm4gcyA9PT0gKChuID0gYS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBuLnBsYWNlbWVudCkgJiYgKHIgPSBhLmFycm93KSAhPSBudWxsICYmIHIuYWxpZ25tZW50T2Zmc2V0ID8ge30gOiB7XHJcbiAgICAgICAgeDogaSArIGMueCxcclxuICAgICAgICB5OiBvICsgYy55LFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIC4uLmMsXHJcbiAgICAgICAgICBwbGFjZW1lbnQ6IHNcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufSwgaXIgPSBmdW5jdGlvbihlKSB7XHJcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KSwge1xyXG4gICAgbmFtZTogXCJzaGlmdFwiLFxyXG4gICAgb3B0aW9uczogZSxcclxuICAgIGFzeW5jIGZuKHQpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHg6IG4sXHJcbiAgICAgICAgeTogcixcclxuICAgICAgICBwbGFjZW1lbnQ6IGlcclxuICAgICAgfSA9IHQsIHtcclxuICAgICAgICBtYWluQXhpczogbyA9ICEwLFxyXG4gICAgICAgIGNyb3NzQXhpczogcyA9ICExLFxyXG4gICAgICAgIGxpbWl0ZXI6IGEgPSB7XHJcbiAgICAgICAgICBmbjogKGcpID0+IHtcclxuICAgICAgICAgICAgbGV0IHtcclxuICAgICAgICAgICAgICB4OiBoLFxyXG4gICAgICAgICAgICAgIHk6IHhcclxuICAgICAgICAgICAgfSA9IGc7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgeDogaCxcclxuICAgICAgICAgICAgICB5OiB4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAuLi5jXHJcbiAgICAgIH0gPSBIZShlLCB0KSwgdSA9IHtcclxuICAgICAgICB4OiBuLFxyXG4gICAgICAgIHk6IHJcclxuICAgICAgfSwgbCA9IGF3YWl0IFF0KHQsIGMpLCBmID0gaGUoYWUoaSkpLCB2ID0gcXQoZik7XHJcbiAgICAgIGxldCBkID0gdVt2XSwgbSA9IHVbZl07XHJcbiAgICAgIGlmIChvKSB7XHJcbiAgICAgICAgY29uc3QgZyA9IHYgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiLCBoID0gdiA9PT0gXCJ5XCIgPyBcImJvdHRvbVwiIDogXCJyaWdodFwiLCB4ID0gZCArIGxbZ10sIEUgPSBkIC0gbFtoXTtcclxuICAgICAgICBkID0gRXQoeCwgZCwgRSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHMpIHtcclxuICAgICAgICBjb25zdCBnID0gZiA9PT0gXCJ5XCIgPyBcInRvcFwiIDogXCJsZWZ0XCIsIGggPSBmID09PSBcInlcIiA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIsIHggPSBtICsgbFtnXSwgRSA9IG0gLSBsW2hdO1xyXG4gICAgICAgIG0gPSBFdCh4LCBtLCBFKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwID0gYS5mbih7XHJcbiAgICAgICAgLi4udCxcclxuICAgICAgICBbdl06IGQsXHJcbiAgICAgICAgW2ZdOiBtXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnAsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgeDogcC54IC0gbixcclxuICAgICAgICAgIHk6IHAueSAtIHIsXHJcbiAgICAgICAgICBlbmFibGVkOiB7XHJcbiAgICAgICAgICAgIFt2XTogbyxcclxuICAgICAgICAgICAgW2ZdOiBzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcbmZ1bmN0aW9uIFllKCkge1xyXG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCI7XHJcbn1cclxuZnVuY3Rpb24gYmUoZSkge1xyXG4gIHJldHVybiBKdChlKSA/IChlLm5vZGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBcIiNkb2N1bWVudFwiO1xyXG59XHJcbmZ1bmN0aW9uIFUoZSkge1xyXG4gIHZhciB0O1xyXG4gIHJldHVybiAoZSA9PSBudWxsIHx8ICh0ID0gZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xyXG59XHJcbmZ1bmN0aW9uIEooZSkge1xyXG4gIHZhciB0O1xyXG4gIHJldHVybiAodCA9IChKdChlKSA/IGUub3duZXJEb2N1bWVudCA6IGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIEp0KGUpIHtcclxuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBOb2RlIHx8IGUgaW5zdGFuY2VvZiBVKGUpLk5vZGUgOiAhMTtcclxufVxyXG5mdW5jdGlvbiBZKGUpIHtcclxuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGUgaW5zdGFuY2VvZiBVKGUpLkVsZW1lbnQgOiAhMTtcclxufVxyXG5mdW5jdGlvbiBRKGUpIHtcclxuICByZXR1cm4gWWUoKSA/IGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlIGluc3RhbmNlb2YgVShlKS5IVE1MRWxlbWVudCA6ICExO1xyXG59XHJcbmZ1bmN0aW9uIFB0KGUpIHtcclxuICByZXR1cm4gIVllKCkgfHwgdHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIiA/ICExIDogZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgZSBpbnN0YW5jZW9mIFUoZSkuU2hhZG93Um9vdDtcclxufVxyXG5mdW5jdGlvbiBBZShlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgb3ZlcmZsb3c6IHQsXHJcbiAgICBvdmVyZmxvd1g6IG4sXHJcbiAgICBvdmVyZmxvd1k6IHIsXHJcbiAgICBkaXNwbGF5OiBpXHJcbiAgfSA9IHEoZSk7XHJcbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbnxjbGlwLy50ZXN0KHQgKyByICsgbikgJiYgIVtcImlubGluZVwiLCBcImNvbnRlbnRzXCJdLmluY2x1ZGVzKGkpO1xyXG59XHJcbmZ1bmN0aW9uIG9yKGUpIHtcclxuICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluY2x1ZGVzKGJlKGUpKTtcclxufVxyXG5mdW5jdGlvbiBxZShlKSB7XHJcbiAgcmV0dXJuIFtcIjpwb3BvdmVyLW9wZW5cIiwgXCI6bW9kYWxcIl0uc29tZSgodCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIGUubWF0Y2hlcyh0KTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gITE7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZnQoZSkge1xyXG4gIGNvbnN0IHQgPSBkdCgpLCBuID0gWShlKSA/IHEoZSkgOiBlO1xyXG4gIHJldHVybiBbXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInBlcnNwZWN0aXZlXCJdLnNvbWUoKHIpID0+IG5bcl0gPyBuW3JdICE9PSBcIm5vbmVcIiA6ICExKSB8fCAobi5jb250YWluZXJUeXBlID8gbi5jb250YWluZXJUeXBlICE9PSBcIm5vcm1hbFwiIDogITEpIHx8ICF0ICYmIChuLmJhY2tkcm9wRmlsdGVyID8gbi5iYWNrZHJvcEZpbHRlciAhPT0gXCJub25lXCIgOiAhMSkgfHwgIXQgJiYgKG4uZmlsdGVyID8gbi5maWx0ZXIgIT09IFwibm9uZVwiIDogITEpIHx8IFtcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZVwiLCBcInNjYWxlXCIsIFwicm90YXRlXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJmaWx0ZXJcIl0uc29tZSgocikgPT4gKG4ud2lsbENoYW5nZSB8fCBcIlwiKS5pbmNsdWRlcyhyKSkgfHwgW1wicGFpbnRcIiwgXCJsYXlvdXRcIiwgXCJzdHJpY3RcIiwgXCJjb250ZW50XCJdLnNvbWUoKHIpID0+IChuLmNvbnRhaW4gfHwgXCJcIikuaW5jbHVkZXMocikpO1xyXG59XHJcbmZ1bmN0aW9uIHNyKGUpIHtcclxuICBsZXQgdCA9IGllKGUpO1xyXG4gIGZvciAoOyBRKHQpICYmICF2ZSh0KTsgKSB7XHJcbiAgICBpZiAoZnQodCkpXHJcbiAgICAgIHJldHVybiB0O1xyXG4gICAgaWYgKHFlKHQpKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIHQgPSBpZSh0KTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZHQoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBDU1MgPiBcInVcIiB8fCAhQ1NTLnN1cHBvcnRzID8gITEgOiBDU1Muc3VwcG9ydHMoXCItd2Via2l0LWJhY2tkcm9wLWZpbHRlclwiLCBcIm5vbmVcIik7XHJcbn1cclxuZnVuY3Rpb24gdmUoZSkge1xyXG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmNsdWRlcyhiZShlKSk7XHJcbn1cclxuZnVuY3Rpb24gcShlKSB7XHJcbiAgcmV0dXJuIFUoZSkuZ2V0Q29tcHV0ZWRTdHlsZShlKTtcclxufVxyXG5mdW5jdGlvbiBLZShlKSB7XHJcbiAgcmV0dXJuIFkoZSkgPyB7XHJcbiAgICBzY3JvbGxMZWZ0OiBlLnNjcm9sbExlZnQsXHJcbiAgICBzY3JvbGxUb3A6IGUuc2Nyb2xsVG9wXHJcbiAgfSA6IHtcclxuICAgIHNjcm9sbExlZnQ6IGUuc2Nyb2xsWCxcclxuICAgIHNjcm9sbFRvcDogZS5zY3JvbGxZXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBpZShlKSB7XHJcbiAgaWYgKGJlKGUpID09PSBcImh0bWxcIilcclxuICAgIHJldHVybiBlO1xyXG4gIGNvbnN0IHQgPSAoXHJcbiAgICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cclxuICAgIGUuYXNzaWduZWRTbG90IHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxyXG4gICAgZS5wYXJlbnROb2RlIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXHJcbiAgICBQdChlKSAmJiBlLmhvc3QgfHwgLy8gRmFsbGJhY2suXHJcbiAgICBKKGUpXHJcbiAgKTtcclxuICByZXR1cm4gUHQodCkgPyB0Lmhvc3QgOiB0O1xyXG59XHJcbmZ1bmN0aW9uIFh0KGUpIHtcclxuICBjb25zdCB0ID0gaWUoZSk7XHJcbiAgcmV0dXJuIHZlKHQpID8gZS5vd25lckRvY3VtZW50ID8gZS5vd25lckRvY3VtZW50LmJvZHkgOiBlLmJvZHkgOiBRKHQpICYmIEFlKHQpID8gdCA6IFh0KHQpO1xyXG59XHJcbmZ1bmN0aW9uIEVlKGUsIHQsIG4pIHtcclxuICB2YXIgcjtcclxuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBbXSksIG4gPT09IHZvaWQgMCAmJiAobiA9ICEwKTtcclxuICBjb25zdCBpID0gWHQoZSksIG8gPSBpID09PSAoKHIgPSBlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiByLmJvZHkpLCBzID0gVShpKTtcclxuICBpZiAobykge1xyXG4gICAgY29uc3QgYSA9IG90KHMpO1xyXG4gICAgcmV0dXJuIHQuY29uY2F0KHMsIHMudmlzdWFsVmlld3BvcnQgfHwgW10sIEFlKGkpID8gaSA6IFtdLCBhICYmIG4gPyBFZShhKSA6IFtdKTtcclxuICB9XHJcbiAgcmV0dXJuIHQuY29uY2F0KGksIEVlKGksIFtdLCBuKSk7XHJcbn1cclxuZnVuY3Rpb24gb3QoZSkge1xyXG4gIHJldHVybiBlLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5wYXJlbnQpID8gZS5mcmFtZUVsZW1lbnQgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIFp0KGUpIHtcclxuICBjb25zdCB0ID0gcShlKTtcclxuICBsZXQgbiA9IHBhcnNlRmxvYXQodC53aWR0aCkgfHwgMCwgciA9IHBhcnNlRmxvYXQodC5oZWlnaHQpIHx8IDA7XHJcbiAgY29uc3QgaSA9IFEoZSksIG8gPSBpID8gZS5vZmZzZXRXaWR0aCA6IG4sIHMgPSBpID8gZS5vZmZzZXRIZWlnaHQgOiByLCBhID0gJGUobikgIT09IG8gfHwgJGUocikgIT09IHM7XHJcbiAgcmV0dXJuIGEgJiYgKG4gPSBvLCByID0gcyksIHtcclxuICAgIHdpZHRoOiBuLFxyXG4gICAgaGVpZ2h0OiByLFxyXG4gICAgJDogYVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcHQoZSkge1xyXG4gIHJldHVybiBZKGUpID8gZSA6IGUuY29udGV4dEVsZW1lbnQ7XHJcbn1cclxuZnVuY3Rpb24gZGUoZSkge1xyXG4gIGNvbnN0IHQgPSBwdChlKTtcclxuICBpZiAoIVEodCkpXHJcbiAgICByZXR1cm4gRygxKTtcclxuICBjb25zdCBuID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwge1xyXG4gICAgd2lkdGg6IHIsXHJcbiAgICBoZWlnaHQ6IGksXHJcbiAgICAkOiBvXHJcbiAgfSA9IFp0KHQpO1xyXG4gIGxldCBzID0gKG8gPyAkZShuLndpZHRoKSA6IG4ud2lkdGgpIC8gciwgYSA9IChvID8gJGUobi5oZWlnaHQpIDogbi5oZWlnaHQpIC8gaTtcclxuICByZXR1cm4gKCFzIHx8ICFOdW1iZXIuaXNGaW5pdGUocykpICYmIChzID0gMSksICghYSB8fCAhTnVtYmVyLmlzRmluaXRlKGEpKSAmJiAoYSA9IDEpLCB7XHJcbiAgICB4OiBzLFxyXG4gICAgeTogYVxyXG4gIH07XHJcbn1cclxuY29uc3QgYXIgPSAvKiBAX19QVVJFX18gKi8gRygwKTtcclxuZnVuY3Rpb24gZW4oZSkge1xyXG4gIGNvbnN0IHQgPSBVKGUpO1xyXG4gIHJldHVybiAhZHQoKSB8fCAhdC52aXN1YWxWaWV3cG9ydCA/IGFyIDoge1xyXG4gICAgeDogdC52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxyXG4gICAgeTogdC52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyKGUsIHQsIG4pIHtcclxuICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gITEpLCAhbiB8fCB0ICYmIG4gIT09IFUoZSkgPyAhMSA6IHQ7XHJcbn1cclxuZnVuY3Rpb24gY2UoZSwgdCwgbiwgcikge1xyXG4gIHQgPT09IHZvaWQgMCAmJiAodCA9ICExKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xyXG4gIGNvbnN0IGkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0gcHQoZSk7XHJcbiAgbGV0IHMgPSBHKDEpO1xyXG4gIHQgJiYgKHIgPyBZKHIpICYmIChzID0gZGUocikpIDogcyA9IGRlKGUpKTtcclxuICBjb25zdCBhID0gY3IobywgbiwgcikgPyBlbihvKSA6IEcoMCk7XHJcbiAgbGV0IGMgPSAoaS5sZWZ0ICsgYS54KSAvIHMueCwgdSA9IChpLnRvcCArIGEueSkgLyBzLnksIGwgPSBpLndpZHRoIC8gcy54LCBmID0gaS5oZWlnaHQgLyBzLnk7XHJcbiAgaWYgKG8pIHtcclxuICAgIGNvbnN0IHYgPSBVKG8pLCBkID0gciAmJiBZKHIpID8gVShyKSA6IHI7XHJcbiAgICBsZXQgbSA9IHYsIHAgPSBvdChtKTtcclxuICAgIGZvciAoOyBwICYmIHIgJiYgZCAhPT0gbTsgKSB7XHJcbiAgICAgIGNvbnN0IGcgPSBkZShwKSwgaCA9IHAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSBxKHApLCBFID0gaC5sZWZ0ICsgKHAuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoeC5wYWRkaW5nTGVmdCkpICogZy54LCBQID0gaC50b3AgKyAocC5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KHgucGFkZGluZ1RvcCkpICogZy55O1xyXG4gICAgICBjICo9IGcueCwgdSAqPSBnLnksIGwgKj0gZy54LCBmICo9IGcueSwgYyArPSBFLCB1ICs9IFAsIG0gPSBVKHApLCBwID0gb3QobSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBGZSh7XHJcbiAgICB3aWR0aDogbCxcclxuICAgIGhlaWdodDogZixcclxuICAgIHg6IGMsXHJcbiAgICB5OiB1XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaHQoZSwgdCkge1xyXG4gIGNvbnN0IG4gPSBLZShlKS5zY3JvbGxMZWZ0O1xyXG4gIHJldHVybiB0ID8gdC5sZWZ0ICsgbiA6IGNlKEooZSkpLmxlZnQgKyBuO1xyXG59XHJcbmZ1bmN0aW9uIHRuKGUsIHQsIG4pIHtcclxuICBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XHJcbiAgY29uc3QgciA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSByLmxlZnQgKyB0LnNjcm9sbExlZnQgLSAobiA/IDAgOiAoXHJcbiAgICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhci5cclxuICAgIGh0KGUsIHIpXHJcbiAgKSksIG8gPSByLnRvcCArIHQuc2Nyb2xsVG9wO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBpLFxyXG4gICAgeTogb1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gdXIoZSkge1xyXG4gIGxldCB7XHJcbiAgICBlbGVtZW50czogdCxcclxuICAgIHJlY3Q6IG4sXHJcbiAgICBvZmZzZXRQYXJlbnQ6IHIsXHJcbiAgICBzdHJhdGVneTogaVxyXG4gIH0gPSBlO1xyXG4gIGNvbnN0IG8gPSBpID09PSBcImZpeGVkXCIsIHMgPSBKKHIpLCBhID0gdCA/IHFlKHQuZmxvYXRpbmcpIDogITE7XHJcbiAgaWYgKHIgPT09IHMgfHwgYSAmJiBvKVxyXG4gICAgcmV0dXJuIG47XHJcbiAgbGV0IGMgPSB7XHJcbiAgICBzY3JvbGxMZWZ0OiAwLFxyXG4gICAgc2Nyb2xsVG9wOiAwXHJcbiAgfSwgdSA9IEcoMSk7XHJcbiAgY29uc3QgbCA9IEcoMCksIGYgPSBRKHIpO1xyXG4gIGlmICgoZiB8fCAhZiAmJiAhbykgJiYgKChiZShyKSAhPT0gXCJib2R5XCIgfHwgQWUocykpICYmIChjID0gS2UocikpLCBRKHIpKSkge1xyXG4gICAgY29uc3QgZCA9IGNlKHIpO1xyXG4gICAgdSA9IGRlKHIpLCBsLnggPSBkLnggKyByLmNsaWVudExlZnQsIGwueSA9IGQueSArIHIuY2xpZW50VG9wO1xyXG4gIH1cclxuICBjb25zdCB2ID0gcyAmJiAhZiAmJiAhbyA/IHRuKHMsIGMsICEwKSA6IEcoMCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoOiBuLndpZHRoICogdS54LFxyXG4gICAgaGVpZ2h0OiBuLmhlaWdodCAqIHUueSxcclxuICAgIHg6IG4ueCAqIHUueCAtIGMuc2Nyb2xsTGVmdCAqIHUueCArIGwueCArIHYueCxcclxuICAgIHk6IG4ueSAqIHUueSAtIGMuc2Nyb2xsVG9wICogdS55ICsgbC55ICsgdi55XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBscihlKSB7XHJcbiAgcmV0dXJuIEFycmF5LmZyb20oZS5nZXRDbGllbnRSZWN0cygpKTtcclxufVxyXG5mdW5jdGlvbiBmcihlKSB7XHJcbiAgY29uc3QgdCA9IEooZSksIG4gPSBLZShlKSwgciA9IGUub3duZXJEb2N1bWVudC5ib2R5LCBpID0gc2UodC5zY3JvbGxXaWR0aCwgdC5jbGllbnRXaWR0aCwgci5zY3JvbGxXaWR0aCwgci5jbGllbnRXaWR0aCksIG8gPSBzZSh0LnNjcm9sbEhlaWdodCwgdC5jbGllbnRIZWlnaHQsIHIuc2Nyb2xsSGVpZ2h0LCByLmNsaWVudEhlaWdodCk7XHJcbiAgbGV0IHMgPSAtbi5zY3JvbGxMZWZ0ICsgaHQoZSk7XHJcbiAgY29uc3QgYSA9IC1uLnNjcm9sbFRvcDtcclxuICByZXR1cm4gcShyKS5kaXJlY3Rpb24gPT09IFwicnRsXCIgJiYgKHMgKz0gc2UodC5jbGllbnRXaWR0aCwgci5jbGllbnRXaWR0aCkgLSBpKSwge1xyXG4gICAgd2lkdGg6IGksXHJcbiAgICBoZWlnaHQ6IG8sXHJcbiAgICB4OiBzLFxyXG4gICAgeTogYVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZHIoZSwgdCkge1xyXG4gIGNvbnN0IG4gPSBVKGUpLCByID0gSihlKSwgaSA9IG4udmlzdWFsVmlld3BvcnQ7XHJcbiAgbGV0IG8gPSByLmNsaWVudFdpZHRoLCBzID0gci5jbGllbnRIZWlnaHQsIGEgPSAwLCBjID0gMDtcclxuICBpZiAoaSkge1xyXG4gICAgbyA9IGkud2lkdGgsIHMgPSBpLmhlaWdodDtcclxuICAgIGNvbnN0IHUgPSBkdCgpO1xyXG4gICAgKCF1IHx8IHUgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAoYSA9IGkub2Zmc2V0TGVmdCwgYyA9IGkub2Zmc2V0VG9wKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoOiBvLFxyXG4gICAgaGVpZ2h0OiBzLFxyXG4gICAgeDogYSxcclxuICAgIHk6IGNcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHByKGUsIHQpIHtcclxuICBjb25zdCBuID0gY2UoZSwgITAsIHQgPT09IFwiZml4ZWRcIiksIHIgPSBuLnRvcCArIGUuY2xpZW50VG9wLCBpID0gbi5sZWZ0ICsgZS5jbGllbnRMZWZ0LCBvID0gUShlKSA/IGRlKGUpIDogRygxKSwgcyA9IGUuY2xpZW50V2lkdGggKiBvLngsIGEgPSBlLmNsaWVudEhlaWdodCAqIG8ueSwgYyA9IGkgKiBvLngsIHUgPSByICogby55O1xyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogcyxcclxuICAgIGhlaWdodDogYSxcclxuICAgIHg6IGMsXHJcbiAgICB5OiB1XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBBdChlLCB0LCBuKSB7XHJcbiAgbGV0IHI7XHJcbiAgaWYgKHQgPT09IFwidmlld3BvcnRcIilcclxuICAgIHIgPSBkcihlLCBuKTtcclxuICBlbHNlIGlmICh0ID09PSBcImRvY3VtZW50XCIpXHJcbiAgICByID0gZnIoSihlKSk7XHJcbiAgZWxzZSBpZiAoWSh0KSlcclxuICAgIHIgPSBwcih0LCBuKTtcclxuICBlbHNlIHtcclxuICAgIGNvbnN0IGkgPSBlbihlKTtcclxuICAgIHIgPSB7XHJcbiAgICAgIHg6IHQueCAtIGkueCxcclxuICAgICAgeTogdC55IC0gaS55LFxyXG4gICAgICB3aWR0aDogdC53aWR0aCxcclxuICAgICAgaGVpZ2h0OiB0LmhlaWdodFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIEZlKHIpO1xyXG59XHJcbmZ1bmN0aW9uIG5uKGUsIHQpIHtcclxuICBjb25zdCBuID0gaWUoZSk7XHJcbiAgcmV0dXJuIG4gPT09IHQgfHwgIVkobikgfHwgdmUobikgPyAhMSA6IHEobikucG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCBubihuLCB0KTtcclxufVxyXG5mdW5jdGlvbiBocihlLCB0KSB7XHJcbiAgY29uc3QgbiA9IHQuZ2V0KGUpO1xyXG4gIGlmIChuKVxyXG4gICAgcmV0dXJuIG47XHJcbiAgbGV0IHIgPSBFZShlLCBbXSwgITEpLmZpbHRlcigoYSkgPT4gWShhKSAmJiBiZShhKSAhPT0gXCJib2R5XCIpLCBpID0gbnVsbDtcclxuICBjb25zdCBvID0gcShlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiO1xyXG4gIGxldCBzID0gbyA/IGllKGUpIDogZTtcclxuICBmb3IgKDsgWShzKSAmJiAhdmUocyk7ICkge1xyXG4gICAgY29uc3QgYSA9IHEocyksIGMgPSBmdChzKTtcclxuICAgICFjICYmIGEucG9zaXRpb24gPT09IFwiZml4ZWRcIiAmJiAoaSA9IG51bGwpLCAobyA/ICFjICYmICFpIDogIWMgJiYgYS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiAmJiAhIWkgJiYgW1wiYWJzb2x1dGVcIiwgXCJmaXhlZFwiXS5pbmNsdWRlcyhpLnBvc2l0aW9uKSB8fCBBZShzKSAmJiAhYyAmJiBubihlLCBzKSkgPyByID0gci5maWx0ZXIoKGwpID0+IGwgIT09IHMpIDogaSA9IGEsIHMgPSBpZShzKTtcclxuICB9XHJcbiAgcmV0dXJuIHQuc2V0KGUsIHIpLCByO1xyXG59XHJcbmZ1bmN0aW9uIHZyKGUpIHtcclxuICBsZXQge1xyXG4gICAgZWxlbWVudDogdCxcclxuICAgIGJvdW5kYXJ5OiBuLFxyXG4gICAgcm9vdEJvdW5kYXJ5OiByLFxyXG4gICAgc3RyYXRlZ3k6IGlcclxuICB9ID0gZTtcclxuICBjb25zdCBzID0gWy4uLm4gPT09IFwiY2xpcHBpbmdBbmNlc3RvcnNcIiA/IHFlKHQpID8gW10gOiBocih0LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChuKSwgcl0sIGEgPSBzWzBdLCBjID0gcy5yZWR1Y2UoKHUsIGwpID0+IHtcclxuICAgIGNvbnN0IGYgPSBBdCh0LCBsLCBpKTtcclxuICAgIHJldHVybiB1LnRvcCA9IHNlKGYudG9wLCB1LnRvcCksIHUucmlnaHQgPSBEZShmLnJpZ2h0LCB1LnJpZ2h0KSwgdS5ib3R0b20gPSBEZShmLmJvdHRvbSwgdS5ib3R0b20pLCB1LmxlZnQgPSBzZShmLmxlZnQsIHUubGVmdCksIHU7XHJcbiAgfSwgQXQodCwgYSwgaSkpO1xyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogYy5yaWdodCAtIGMubGVmdCxcclxuICAgIGhlaWdodDogYy5ib3R0b20gLSBjLnRvcCxcclxuICAgIHg6IGMubGVmdCxcclxuICAgIHk6IGMudG9wXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBtcihlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgd2lkdGg6IHQsXHJcbiAgICBoZWlnaHQ6IG5cclxuICB9ID0gWnQoZSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoOiB0LFxyXG4gICAgaGVpZ2h0OiBuXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBncihlLCB0LCBuKSB7XHJcbiAgY29uc3QgciA9IFEodCksIGkgPSBKKHQpLCBvID0gbiA9PT0gXCJmaXhlZFwiLCBzID0gY2UoZSwgITAsIG8sIHQpO1xyXG4gIGxldCBhID0ge1xyXG4gICAgc2Nyb2xsTGVmdDogMCxcclxuICAgIHNjcm9sbFRvcDogMFxyXG4gIH07XHJcbiAgY29uc3QgYyA9IEcoMCk7XHJcbiAgaWYgKHIgfHwgIXIgJiYgIW8pXHJcbiAgICBpZiAoKGJlKHQpICE9PSBcImJvZHlcIiB8fCBBZShpKSkgJiYgKGEgPSBLZSh0KSksIHIpIHtcclxuICAgICAgY29uc3QgdiA9IGNlKHQsICEwLCBvLCB0KTtcclxuICAgICAgYy54ID0gdi54ICsgdC5jbGllbnRMZWZ0LCBjLnkgPSB2LnkgKyB0LmNsaWVudFRvcDtcclxuICAgIH0gZWxzZSBpICYmIChjLnggPSBodChpKSk7XHJcbiAgY29uc3QgdSA9IGkgJiYgIXIgJiYgIW8gPyB0bihpLCBhKSA6IEcoMCksIGwgPSBzLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBjLnggLSB1LngsIGYgPSBzLnRvcCArIGEuc2Nyb2xsVG9wIC0gYy55IC0gdS55O1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBsLFxyXG4gICAgeTogZixcclxuICAgIHdpZHRoOiBzLndpZHRoLFxyXG4gICAgaGVpZ2h0OiBzLmhlaWdodFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gWGUoZSkge1xyXG4gIHJldHVybiBxKGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiO1xyXG59XHJcbmZ1bmN0aW9uIE90KGUsIHQpIHtcclxuICBpZiAoIVEoZSkgfHwgcShlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgaWYgKHQpXHJcbiAgICByZXR1cm4gdChlKTtcclxuICBsZXQgbiA9IGUub2Zmc2V0UGFyZW50O1xyXG4gIHJldHVybiBKKGUpID09PSBuICYmIChuID0gbi5vd25lckRvY3VtZW50LmJvZHkpLCBuO1xyXG59XHJcbmZ1bmN0aW9uIHJuKGUsIHQpIHtcclxuICBjb25zdCBuID0gVShlKTtcclxuICBpZiAocWUoZSkpXHJcbiAgICByZXR1cm4gbjtcclxuICBpZiAoIVEoZSkpIHtcclxuICAgIGxldCBpID0gaWUoZSk7XHJcbiAgICBmb3IgKDsgaSAmJiAhdmUoaSk7ICkge1xyXG4gICAgICBpZiAoWShpKSAmJiAhWGUoaSkpXHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgIGkgPSBpZShpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuO1xyXG4gIH1cclxuICBsZXQgciA9IE90KGUsIHQpO1xyXG4gIGZvciAoOyByICYmIG9yKHIpICYmIFhlKHIpOyApXHJcbiAgICByID0gT3QociwgdCk7XHJcbiAgcmV0dXJuIHIgJiYgdmUocikgJiYgWGUocikgJiYgIWZ0KHIpID8gbiA6IHIgfHwgc3IoZSkgfHwgbjtcclxufVxyXG5jb25zdCBiciA9IGFzeW5jIGZ1bmN0aW9uKGUpIHtcclxuICBjb25zdCB0ID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgcm4sIG4gPSB0aGlzLmdldERpbWVuc2lvbnMsIHIgPSBhd2FpdCBuKGUuZmxvYXRpbmcpO1xyXG4gIHJldHVybiB7XHJcbiAgICByZWZlcmVuY2U6IGdyKGUucmVmZXJlbmNlLCBhd2FpdCB0KGUuZmxvYXRpbmcpLCBlLnN0cmF0ZWd5KSxcclxuICAgIGZsb2F0aW5nOiB7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHdpZHRoOiByLndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHIuaGVpZ2h0XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuZnVuY3Rpb24geXIoZSkge1xyXG4gIHJldHVybiBxKGUpLmRpcmVjdGlvbiA9PT0gXCJydGxcIjtcclxufVxyXG5jb25zdCB3ciA9IHtcclxuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdDogdXIsXHJcbiAgZ2V0RG9jdW1lbnRFbGVtZW50OiBKLFxyXG4gIGdldENsaXBwaW5nUmVjdDogdnIsXHJcbiAgZ2V0T2Zmc2V0UGFyZW50OiBybixcclxuICBnZXRFbGVtZW50UmVjdHM6IGJyLFxyXG4gIGdldENsaWVudFJlY3RzOiBscixcclxuICBnZXREaW1lbnNpb25zOiBtcixcclxuICBnZXRTY2FsZTogZGUsXHJcbiAgaXNFbGVtZW50OiBZLFxyXG4gIGlzUlRMOiB5clxyXG59O1xyXG5mdW5jdGlvbiBvbihlLCB0KSB7XHJcbiAgcmV0dXJuIGUueCA9PT0gdC54ICYmIGUueSA9PT0gdC55ICYmIGUud2lkdGggPT09IHQud2lkdGggJiYgZS5oZWlnaHQgPT09IHQuaGVpZ2h0O1xyXG59XHJcbmZ1bmN0aW9uIHhyKGUsIHQpIHtcclxuICBsZXQgbiA9IG51bGwsIHI7XHJcbiAgY29uc3QgaSA9IEooZSk7XHJcbiAgZnVuY3Rpb24gbygpIHtcclxuICAgIHZhciBhO1xyXG4gICAgY2xlYXJUaW1lb3V0KHIpLCAoYSA9IG4pID09IG51bGwgfHwgYS5kaXNjb25uZWN0KCksIG4gPSBudWxsO1xyXG4gIH1cclxuICBmdW5jdGlvbiBzKGEsIGMpIHtcclxuICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9ICExKSwgYyA9PT0gdm9pZCAwICYmIChjID0gMSksIG8oKTtcclxuICAgIGNvbnN0IHUgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XHJcbiAgICAgIGxlZnQ6IGwsXHJcbiAgICAgIHRvcDogZixcclxuICAgICAgd2lkdGg6IHYsXHJcbiAgICAgIGhlaWdodDogZFxyXG4gICAgfSA9IHU7XHJcbiAgICBpZiAoYSB8fCB0KCksICF2IHx8ICFkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBtID0gTGUoZiksIHAgPSBMZShpLmNsaWVudFdpZHRoIC0gKGwgKyB2KSksIGcgPSBMZShpLmNsaWVudEhlaWdodCAtIChmICsgZCkpLCBoID0gTGUobCksIEUgPSB7XHJcbiAgICAgIHJvb3RNYXJnaW46IC1tICsgXCJweCBcIiArIC1wICsgXCJweCBcIiArIC1nICsgXCJweCBcIiArIC1oICsgXCJweFwiLFxyXG4gICAgICB0aHJlc2hvbGQ6IHNlKDAsIERlKDEsIGMpKSB8fCAxXHJcbiAgICB9O1xyXG4gICAgbGV0IFAgPSAhMDtcclxuICAgIGZ1bmN0aW9uIGIoUykge1xyXG4gICAgICBjb25zdCBDID0gU1swXS5pbnRlcnNlY3Rpb25SYXRpbztcclxuICAgICAgaWYgKEMgIT09IGMpIHtcclxuICAgICAgICBpZiAoIVApXHJcbiAgICAgICAgICByZXR1cm4gcygpO1xyXG4gICAgICAgIEMgPyBzKCExLCBDKSA6IHIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHMoITEsIDFlLTcpO1xyXG4gICAgICAgIH0sIDFlMyk7XHJcbiAgICAgIH1cclxuICAgICAgQyA9PT0gMSAmJiAhb24odSwgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgJiYgcygpLCBQID0gITE7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBuID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGIsIHtcclxuICAgICAgICAuLi5FLFxyXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcclxuICAgICAgICByb290OiBpLm93bmVyRG9jdW1lbnRcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihiLCBFKTtcclxuICAgIH1cclxuICAgIG4ub2JzZXJ2ZShlKTtcclxuICB9XHJcbiAgcmV0dXJuIHMoITApLCBvO1xyXG59XHJcbmZ1bmN0aW9uIFNyKGUsIHQsIG4sIHIpIHtcclxuICByID09PSB2b2lkIDAgJiYgKHIgPSB7fSk7XHJcbiAgY29uc3Qge1xyXG4gICAgYW5jZXN0b3JTY3JvbGw6IGkgPSAhMCxcclxuICAgIGFuY2VzdG9yUmVzaXplOiBvID0gITAsXHJcbiAgICBlbGVtZW50UmVzaXplOiBzID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIixcclxuICAgIGxheW91dFNoaWZ0OiBhID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIixcclxuICAgIGFuaW1hdGlvbkZyYW1lOiBjID0gITFcclxuICB9ID0gciwgdSA9IHB0KGUpLCBsID0gaSB8fCBvID8gWy4uLnUgPyBFZSh1KSA6IFtdLCAuLi5FZSh0KV0gOiBbXTtcclxuICBsLmZvckVhY2goKGgpID0+IHtcclxuICAgIGkgJiYgaC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG4sIHtcclxuICAgICAgcGFzc2l2ZTogITBcclxuICAgIH0pLCBvICYmIGguYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBuKTtcclxuICB9KTtcclxuICBjb25zdCBmID0gdSAmJiBhID8geHIodSwgbikgOiBudWxsO1xyXG4gIGxldCB2ID0gLTEsIGQgPSBudWxsO1xyXG4gIHMgJiYgKGQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGgpID0+IHtcclxuICAgIGxldCBbeF0gPSBoO1xyXG4gICAgeCAmJiB4LnRhcmdldCA9PT0gdSAmJiBkICYmIChkLnVub2JzZXJ2ZSh0KSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUodiksIHYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB2YXIgRTtcclxuICAgICAgKEUgPSBkKSA9PSBudWxsIHx8IEUub2JzZXJ2ZSh0KTtcclxuICAgIH0pKSwgbigpO1xyXG4gIH0pLCB1ICYmICFjICYmIGQub2JzZXJ2ZSh1KSwgZC5vYnNlcnZlKHQpKTtcclxuICBsZXQgbSwgcCA9IGMgPyBjZShlKSA6IG51bGw7XHJcbiAgYyAmJiBnKCk7XHJcbiAgZnVuY3Rpb24gZygpIHtcclxuICAgIGNvbnN0IGggPSBjZShlKTtcclxuICAgIHAgJiYgIW9uKHAsIGgpICYmIG4oKSwgcCA9IGgsIG0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZyk7XHJcbiAgfVxyXG4gIHJldHVybiBuKCksICgpID0+IHtcclxuICAgIHZhciBoO1xyXG4gICAgbC5mb3JFYWNoKCh4KSA9PiB7XHJcbiAgICAgIGkgJiYgeC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG4pLCBvICYmIHgucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBuKTtcclxuICAgIH0pLCBmID09IG51bGwgfHwgZigpLCAoaCA9IGQpID09IG51bGwgfHwgaC5kaXNjb25uZWN0KCksIGQgPSBudWxsLCBjICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG0pO1xyXG4gIH07XHJcbn1cclxuY29uc3QgVHIgPSByciwgRXIgPSBpciwgQ3IgPSB0ciwgUHIgPSAoZSwgdCwgbikgPT4ge1xyXG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBpID0ge1xyXG4gICAgcGxhdGZvcm06IHdyLFxyXG4gICAgLi4ublxyXG4gIH0sIG8gPSB7XHJcbiAgICAuLi5pLnBsYXRmb3JtLFxyXG4gICAgX2M6IHJcclxuICB9O1xyXG4gIHJldHVybiBlcihlLCB0LCB7XHJcbiAgICAuLi5pLFxyXG4gICAgcGxhdGZvcm06IG9cclxuICB9KTtcclxufTtcclxudmFyIE1vID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xyXG5mdW5jdGlvbiBBcihlKSB7XHJcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImRlZmF1bHRcIikgPyBlLmRlZmF1bHQgOiBlO1xyXG59XHJcbnZhciBSZSA9IHsgZXhwb3J0czoge30gfSwgT3IgPSBSZS5leHBvcnRzLCBrdDtcclxuZnVuY3Rpb24ga3IoKSB7XHJcbiAgcmV0dXJuIGt0IHx8IChrdCA9IDEsIGZ1bmN0aW9uKGUpIHtcclxuICAgIChmdW5jdGlvbih0LCBuKSB7XHJcbiAgICAgIGUuZXhwb3J0cyA/IGUuZXhwb3J0cyA9IG4oKSA6IHQubG9nID0gbigpO1xyXG4gICAgfSkoT3IsIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB9LCBuID0gXCJ1bmRlZmluZWRcIiwgciA9IHR5cGVvZiB3aW5kb3cgIT09IG4gJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IG4gJiYgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLCBpID0gW1xyXG4gICAgICAgIFwidHJhY2VcIixcclxuICAgICAgICBcImRlYnVnXCIsXHJcbiAgICAgICAgXCJpbmZvXCIsXHJcbiAgICAgICAgXCJ3YXJuXCIsXHJcbiAgICAgICAgXCJlcnJvclwiXHJcbiAgICAgIF0sIG8gPSB7fSwgcyA9IG51bGw7XHJcbiAgICAgIGZ1bmN0aW9uIGEocCwgZykge1xyXG4gICAgICAgIHZhciBoID0gcFtnXTtcclxuICAgICAgICBpZiAodHlwZW9mIGguYmluZCA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICByZXR1cm4gaC5iaW5kKHApO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChoLCBwKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShoLCBbcCwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBjKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nICYmIChjb25zb2xlLmxvZy5hcHBseSA/IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cykgOiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKSksIGNvbnNvbGUudHJhY2UgJiYgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHUocCkge1xyXG4gICAgICAgIHJldHVybiBwID09PSBcImRlYnVnXCIgJiYgKHAgPSBcImxvZ1wiKSwgdHlwZW9mIGNvbnNvbGUgPT09IG4gPyAhMSA6IHAgPT09IFwidHJhY2VcIiAmJiByID8gYyA6IGNvbnNvbGVbcF0gIT09IHZvaWQgMCA/IGEoY29uc29sZSwgcCkgOiBjb25zb2xlLmxvZyAhPT0gdm9pZCAwID8gYShjb25zb2xlLCBcImxvZ1wiKSA6IHQ7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gbCgpIHtcclxuICAgICAgICBmb3IgKHZhciBwID0gdGhpcy5nZXRMZXZlbCgpLCBnID0gMDsgZyA8IGkubGVuZ3RoOyBnKyspIHtcclxuICAgICAgICAgIHZhciBoID0gaVtnXTtcclxuICAgICAgICAgIHRoaXNbaF0gPSBnIDwgcCA/IHQgOiB0aGlzLm1ldGhvZEZhY3RvcnkoaCwgcCwgdGhpcy5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubG9nID0gdGhpcy5kZWJ1ZywgdHlwZW9mIGNvbnNvbGUgPT09IG4gJiYgcCA8IHRoaXMubGV2ZWxzLlNJTEVOVClcclxuICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gZihwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IG4gJiYgKGwuY2FsbCh0aGlzKSwgdGhpc1twXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHYocCwgZywgaCkge1xyXG4gICAgICAgIHJldHVybiB1KHApIHx8IGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBkKHAsIGcpIHtcclxuICAgICAgICB2YXIgaCA9IHRoaXMsIHgsIEUsIFAsIGIgPSBcImxvZ2xldmVsXCI7XHJcbiAgICAgICAgdHlwZW9mIHAgPT0gXCJzdHJpbmdcIiA/IGIgKz0gXCI6XCIgKyBwIDogdHlwZW9mIHAgPT0gXCJzeW1ib2xcIiAmJiAoYiA9IHZvaWQgMCk7XHJcbiAgICAgICAgZnVuY3Rpb24gUyhUKSB7XHJcbiAgICAgICAgICB2YXIgTCA9IChpW1RdIHx8IFwic2lsZW50XCIpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSBuIHx8ICFiKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbYl0gPSBMO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KGIpICsgXCI9XCIgKyBMICsgXCI7XCI7XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEMoKSB7XHJcbiAgICAgICAgICB2YXIgVDtcclxuICAgICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT09IG4gfHwgIWIpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgVCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbYl07XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gbilcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIEwgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llLCBvZSA9IGVuY29kZVVSSUNvbXBvbmVudChiKSwgSyA9IEwuaW5kZXhPZihvZSArIFwiPVwiKTtcclxuICAgICAgICAgICAgICAgIEsgIT09IC0xICYmIChUID0gL14oW147XSspLy5leGVjKFxyXG4gICAgICAgICAgICAgICAgICBMLnNsaWNlKEsgKyBvZS5sZW5ndGggKyAxKVxyXG4gICAgICAgICAgICAgICAgKVsxXSk7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaC5sZXZlbHNbVF0gPT09IHZvaWQgMCAmJiAoVCA9IHZvaWQgMCksIFQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uICQoKSB7XHJcbiAgICAgICAgICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSBuIHx8ICFiKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiKTtcclxuICAgICAgICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KGIpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XHJcbiAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEkoVCkge1xyXG4gICAgICAgICAgdmFyIEwgPSBUO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBMID09IFwic3RyaW5nXCIgJiYgaC5sZXZlbHNbTC50b1VwcGVyQ2FzZSgpXSAhPT0gdm9pZCAwICYmIChMID0gaC5sZXZlbHNbTC50b1VwcGVyQ2FzZSgpXSksIHR5cGVvZiBMID09IFwibnVtYmVyXCIgJiYgTCA+PSAwICYmIEwgPD0gaC5sZXZlbHMuU0lMRU5UKVxyXG4gICAgICAgICAgICByZXR1cm4gTDtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIFQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoLm5hbWUgPSBwLCBoLmxldmVscyA9IHtcclxuICAgICAgICAgIFRSQUNFOiAwLFxyXG4gICAgICAgICAgREVCVUc6IDEsXHJcbiAgICAgICAgICBJTkZPOiAyLFxyXG4gICAgICAgICAgV0FSTjogMyxcclxuICAgICAgICAgIEVSUk9SOiA0LFxyXG4gICAgICAgICAgU0lMRU5UOiA1XHJcbiAgICAgICAgfSwgaC5tZXRob2RGYWN0b3J5ID0gZyB8fCB2LCBoLmdldExldmVsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gUCA/PyBFID8/IHg7XHJcbiAgICAgICAgfSwgaC5zZXRMZXZlbCA9IGZ1bmN0aW9uKFQsIEwpIHtcclxuICAgICAgICAgIHJldHVybiBQID0gSShUKSwgTCAhPT0gITEgJiYgUyhQKSwgbC5jYWxsKGgpO1xyXG4gICAgICAgIH0sIGguc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24oVCkge1xyXG4gICAgICAgICAgRSA9IEkoVCksIEMoKSB8fCBoLnNldExldmVsKFQsICExKTtcclxuICAgICAgICB9LCBoLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIFAgPSBudWxsLCAkKCksIGwuY2FsbChoKTtcclxuICAgICAgICB9LCBoLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKFQpIHtcclxuICAgICAgICAgIGguc2V0TGV2ZWwoaC5sZXZlbHMuVFJBQ0UsIFQpO1xyXG4gICAgICAgIH0sIGguZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKFQpIHtcclxuICAgICAgICAgIGguc2V0TGV2ZWwoaC5sZXZlbHMuU0lMRU5ULCBUKTtcclxuICAgICAgICB9LCBoLnJlYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChzICE9PSBoICYmICh4ID0gSShzLmdldExldmVsKCkpKSwgbC5jYWxsKGgpLCBzID09PSBoKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBUIGluIG8pXHJcbiAgICAgICAgICAgICAgb1tUXS5yZWJ1aWxkKCk7XHJcbiAgICAgICAgfSwgeCA9IEkoXHJcbiAgICAgICAgICBzID8gcy5nZXRMZXZlbCgpIDogXCJXQVJOXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciB6ID0gQygpO1xyXG4gICAgICAgIHogIT0gbnVsbCAmJiAoUCA9IEkoeikpLCBsLmNhbGwoaCk7XHJcbiAgICAgIH1cclxuICAgICAgcyA9IG5ldyBkKCksIHMuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oZykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZyAhPSBcInN5bWJvbFwiICYmIHR5cGVvZiBnICE9IFwic3RyaW5nXCIgfHwgZyA9PT0gXCJcIilcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xyXG4gICAgICAgIHZhciBoID0gb1tnXTtcclxuICAgICAgICByZXR1cm4gaCB8fCAoaCA9IG9bZ10gPSBuZXcgZChcclxuICAgICAgICAgIGcsXHJcbiAgICAgICAgICBzLm1ldGhvZEZhY3RvcnlcclxuICAgICAgICApKSwgaDtcclxuICAgICAgfTtcclxuICAgICAgdmFyIG0gPSB0eXBlb2Ygd2luZG93ICE9PSBuID8gd2luZG93LmxvZyA6IHZvaWQgMDtcclxuICAgICAgcmV0dXJuIHMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBuICYmIHdpbmRvdy5sb2cgPT09IHMgJiYgKHdpbmRvdy5sb2cgPSBtKSwgcztcclxuICAgICAgfSwgcy5nZXRMb2dnZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgIH0sIHMuZGVmYXVsdCA9IHMsIHM7XHJcbiAgICB9KTtcclxuICB9KFJlKSksIFJlLmV4cG9ydHM7XHJcbn1cclxudmFyIExyID0ga3IoKTtcclxuY29uc3QgX3IgPSAvKiBAX19QVVJFX18gKi8gQXIoTHIpO1xyXG52YXIgc3QgPSBmdW5jdGlvbihlLCB0KSB7XHJcbiAgcmV0dXJuIHN0ID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obiwgcikge1xyXG4gICAgbi5fX3Byb3RvX18gPSByO1xyXG4gIH0gfHwgZnVuY3Rpb24obiwgcikge1xyXG4gICAgZm9yICh2YXIgaSBpbiByKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgaSkgJiYgKG5baV0gPSByW2ldKTtcclxuICB9LCBzdChlLCB0KTtcclxufTtcclxuZnVuY3Rpb24gZWUoZSwgdCkge1xyXG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgdCAhPT0gbnVsbClcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHQpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICBzdChlLCB0KTtcclxuICBmdW5jdGlvbiBuKCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGU7XHJcbiAgfVxyXG4gIGUucHJvdG90eXBlID0gdCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUodCkgOiAobi5wcm90b3R5cGUgPSB0LnByb3RvdHlwZSwgbmV3IG4oKSk7XHJcbn1cclxuZnVuY3Rpb24gSXIoZSwgdCwgbiwgcikge1xyXG4gIGZ1bmN0aW9uIGkobykge1xyXG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBuID8gbyA6IG5ldyBuKGZ1bmN0aW9uKHMpIHtcclxuICAgICAgcyhvKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IChuIHx8IChuID0gUHJvbWlzZSkpKGZ1bmN0aW9uKG8sIHMpIHtcclxuICAgIGZ1bmN0aW9uIGEobCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHUoci5uZXh0KGwpKTtcclxuICAgICAgfSBjYXRjaCAoZikge1xyXG4gICAgICAgIHMoZik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGMobCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHUoci50aHJvdyhsKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGYpIHtcclxuICAgICAgICBzKGYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1KGwpIHtcclxuICAgICAgbC5kb25lID8gbyhsLnZhbHVlKSA6IGkobC52YWx1ZSkudGhlbihhLCBjKTtcclxuICAgIH1cclxuICAgIHUoKHIgPSByLmFwcGx5KGUsIHQgfHwgW10pKS5uZXh0KCkpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNuKGUsIHQpIHtcclxuICB2YXIgbiA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKG9bMF0gJiAxKSB0aHJvdyBvWzFdO1xyXG4gICAgcmV0dXJuIG9bMV07XHJcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgciwgaSwgbywgcyA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBJdGVyYXRvciA9PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcclxuICByZXR1cm4gcy5uZXh0ID0gYSgwKSwgcy50aHJvdyA9IGEoMSksIHMucmV0dXJuID0gYSgyKSwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgKHNbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSksIHM7XHJcbiAgZnVuY3Rpb24gYSh1KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24obCkge1xyXG4gICAgICByZXR1cm4gYyhbdSwgbF0pO1xyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYyh1KSB7XHJcbiAgICBpZiAocikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICBmb3IgKDsgcyAmJiAocyA9IDAsIHVbMF0gJiYgKG4gPSAwKSksIG47ICkgdHJ5IHtcclxuICAgICAgaWYgKHIgPSAxLCBpICYmIChvID0gdVswXSAmIDIgPyBpLnJldHVybiA6IHVbMF0gPyBpLnRocm93IHx8ICgobyA9IGkucmV0dXJuKSAmJiBvLmNhbGwoaSksIDApIDogaS5uZXh0KSAmJiAhKG8gPSBvLmNhbGwoaSwgdVsxXSkpLmRvbmUpIHJldHVybiBvO1xyXG4gICAgICBzd2l0Y2ggKGkgPSAwLCBvICYmICh1ID0gW3VbMF0gJiAyLCBvLnZhbHVlXSksIHVbMF0pIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgbyA9IHU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gbi5sYWJlbCsrLCB7IHZhbHVlOiB1WzFdLCBkb25lOiAhMSB9O1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIG4ubGFiZWwrKywgaSA9IHVbMV0sIHUgPSBbMF07XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICB1ID0gbi5vcHMucG9wKCksIG4udHJ5cy5wb3AoKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBpZiAobyA9IG4udHJ5cywgIShvID0gby5sZW5ndGggPiAwICYmIG9bby5sZW5ndGggLSAxXSkgJiYgKHVbMF0gPT09IDYgfHwgdVswXSA9PT0gMikpIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHVbMF0gPT09IDMgJiYgKCFvIHx8IHVbMV0gPiBvWzBdICYmIHVbMV0gPCBvWzNdKSkge1xyXG4gICAgICAgICAgICBuLmxhYmVsID0gdVsxXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodVswXSA9PT0gNiAmJiBuLmxhYmVsIDwgb1sxXSkge1xyXG4gICAgICAgICAgICBuLmxhYmVsID0gb1sxXSwgbyA9IHU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG8gJiYgbi5sYWJlbCA8IG9bMl0pIHtcclxuICAgICAgICAgICAgbi5sYWJlbCA9IG9bMl0sIG4ub3BzLnB1c2godSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb1syXSAmJiBuLm9wcy5wb3AoKSwgbi50cnlzLnBvcCgpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgdSA9IHQuY2FsbChlLCBuKTtcclxuICAgIH0gY2F0Y2ggKGwpIHtcclxuICAgICAgdSA9IFs2LCBsXSwgaSA9IDA7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICByID0gbyA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAodVswXSAmIDUpIHRocm93IHVbMV07XHJcbiAgICByZXR1cm4geyB2YWx1ZTogdVswXSA/IHVbMV0gOiB2b2lkIDAsIGRvbmU6ICEwIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG1lKGUpIHtcclxuICB2YXIgdCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbiA9IHQgJiYgZVt0XSwgciA9IDA7XHJcbiAgaWYgKG4pIHJldHVybiBuLmNhbGwoZSk7XHJcbiAgaWYgKGUgJiYgdHlwZW9mIGUubGVuZ3RoID09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGUgJiYgciA+PSBlLmxlbmd0aCAmJiAoZSA9IHZvaWQgMCksIHsgdmFsdWU6IGUgJiYgZVtyKytdLCBkb25lOiAhZSB9O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcih0ID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHVlKGUsIHQpIHtcclxuICB2YXIgbiA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGVbU3ltYm9sLml0ZXJhdG9yXTtcclxuICBpZiAoIW4pIHJldHVybiBlO1xyXG4gIHZhciByID0gbi5jYWxsKGUpLCBpLCBvID0gW10sIHM7XHJcbiAgdHJ5IHtcclxuICAgIGZvciAoOyAodCA9PT0gdm9pZCAwIHx8IHQtLSA+IDApICYmICEoaSA9IHIubmV4dCgpKS5kb25lOyApIG8ucHVzaChpLnZhbHVlKTtcclxuICB9IGNhdGNoIChhKSB7XHJcbiAgICBzID0geyBlcnJvcjogYSB9O1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpICYmICFpLmRvbmUgJiYgKG4gPSByLnJldHVybikgJiYgbi5jYWxsKHIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKHMpIHRocm93IHMuZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvO1xyXG59XHJcbmZ1bmN0aW9uIGdlKGUsIHQsIG4pIHtcclxuICBpZiAobiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciByID0gMCwgaSA9IHQubGVuZ3RoLCBvOyByIDwgaTsgcisrKVxyXG4gICAgKG8gfHwgIShyIGluIHQpKSAmJiAobyB8fCAobyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsIDAsIHIpKSwgb1tyXSA9IHRbcl0pO1xyXG4gIHJldHVybiBlLmNvbmNhdChvIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQpKTtcclxufVxyXG5mdW5jdGlvbiBwZShlKSB7XHJcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBwZSA/ICh0aGlzLnYgPSBlLCB0aGlzKSA6IG5ldyBwZShlKTtcclxufVxyXG5mdW5jdGlvbiBScihlLCB0LCBuKSB7XHJcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICB2YXIgciA9IG4uYXBwbHkoZSwgdCB8fCBbXSksIGksIG8gPSBbXTtcclxuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIGEoXCJuZXh0XCIpLCBhKFwidGhyb3dcIiksIGEoXCJyZXR1cm5cIiwgcyksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LCBpO1xyXG4gIGZ1bmN0aW9uIHMoZCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG0pIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtKS50aGVuKGQsIGYpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYShkLCBtKSB7XHJcbiAgICByW2RdICYmIChpW2RdID0gZnVuY3Rpb24ocCkge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZywgaCkge1xyXG4gICAgICAgIG8ucHVzaChbZCwgcCwgZywgaF0pID4gMSB8fCBjKGQsIHApO1xyXG4gICAgICB9KTtcclxuICAgIH0sIG0gJiYgKGlbZF0gPSBtKGlbZF0pKSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGMoZCwgbSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdShyW2RdKG0pKTtcclxuICAgIH0gY2F0Y2ggKHApIHtcclxuICAgICAgdihvWzBdWzNdLCBwKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gdShkKSB7XHJcbiAgICBkLnZhbHVlIGluc3RhbmNlb2YgcGUgPyBQcm9taXNlLnJlc29sdmUoZC52YWx1ZS52KS50aGVuKGwsIGYpIDogdihvWzBdWzJdLCBkKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbChkKSB7XHJcbiAgICBjKFwibmV4dFwiLCBkKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gZihkKSB7XHJcbiAgICBjKFwidGhyb3dcIiwgZCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHYoZCwgbSkge1xyXG4gICAgZChtKSwgby5zaGlmdCgpLCBvLmxlbmd0aCAmJiBjKG9bMF1bMF0sIG9bMF1bMV0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBNcihlKSB7XHJcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICB2YXIgdCA9IGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBuO1xyXG4gIHJldHVybiB0ID8gdC5jYWxsKGUpIDogKGUgPSB0eXBlb2YgbWUgPT0gXCJmdW5jdGlvblwiID8gbWUoZSkgOiBlW1N5bWJvbC5pdGVyYXRvcl0oKSwgbiA9IHt9LCByKFwibmV4dFwiKSwgcihcInRocm93XCIpLCByKFwicmV0dXJuXCIpLCBuW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSwgbik7XHJcbiAgZnVuY3Rpb24gcihvKSB7XHJcbiAgICBuW29dID0gZVtvXSAmJiBmdW5jdGlvbihzKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihhLCBjKSB7XHJcbiAgICAgICAgcyA9IGVbb10ocyksIGkoYSwgYywgcy5kb25lLCBzLnZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBpKG8sIHMsIGEsIGMpIHtcclxuICAgIFByb21pc2UucmVzb2x2ZShjKS50aGVuKGZ1bmN0aW9uKHUpIHtcclxuICAgICAgbyh7IHZhbHVlOiB1LCBkb25lOiBhIH0pO1xyXG4gICAgfSwgcyk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIEEoZSkge1xyXG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZnVuY3Rpb24gdnQoZSkge1xyXG4gIHZhciB0ID0gZnVuY3Rpb24ocikge1xyXG4gICAgRXJyb3IuY2FsbChyKSwgci5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gIH0sIG4gPSBlKHQpO1xyXG4gIHJldHVybiBuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSwgbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBuLCBuO1xyXG59XHJcbnZhciBaZSA9IHZ0KGZ1bmN0aW9uKGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obikge1xyXG4gICAgZSh0aGlzKSwgdGhpcy5tZXNzYWdlID0gbiA/IG4ubGVuZ3RoICsgYCBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxyXG5gICsgbi5tYXAoZnVuY3Rpb24ociwgaSkge1xyXG4gICAgICByZXR1cm4gaSArIDEgKyBcIikgXCIgKyByLnRvU3RyaW5nKCk7XHJcbiAgICB9KS5qb2luKGBcclxuICBgKSA6IFwiXCIsIHRoaXMubmFtZSA9IFwiVW5zdWJzY3JpcHRpb25FcnJvclwiLCB0aGlzLmVycm9ycyA9IG47XHJcbiAgfTtcclxufSk7XHJcbmZ1bmN0aW9uIFVlKGUsIHQpIHtcclxuICBpZiAoZSkge1xyXG4gICAgdmFyIG4gPSBlLmluZGV4T2YodCk7XHJcbiAgICAwIDw9IG4gJiYgZS5zcGxpY2UobiwgMSk7XHJcbiAgfVxyXG59XHJcbnZhciBPZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGZ1bmN0aW9uIGUodCkge1xyXG4gICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSB0LCB0aGlzLmNsb3NlZCA9ICExLCB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsLCB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdCwgbiwgciwgaSwgbztcclxuICAgIGlmICghdGhpcy5jbG9zZWQpIHtcclxuICAgICAgdGhpcy5jbG9zZWQgPSAhMDtcclxuICAgICAgdmFyIHMgPSB0aGlzLl9wYXJlbnRhZ2U7XHJcbiAgICAgIGlmIChzKVxyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRhZ2UgPSBudWxsLCBBcnJheS5pc0FycmF5KHMpKVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IG1lKHMpLCBjID0gYS5uZXh0KCk7ICFjLmRvbmU7IGMgPSBhLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgIHZhciB1ID0gYy52YWx1ZTtcclxuICAgICAgICAgICAgICB1LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAocCkge1xyXG4gICAgICAgICAgICB0ID0geyBlcnJvcjogcCB9O1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjICYmICFjLmRvbmUgJiYgKG4gPSBhLnJldHVybikgJiYgbi5jYWxsKGEpO1xyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgIGlmICh0KSB0aHJvdyB0LmVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgcy5yZW1vdmUodGhpcyk7XHJcbiAgICAgIHZhciBsID0gdGhpcy5pbml0aWFsVGVhcmRvd247XHJcbiAgICAgIGlmIChBKGwpKVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBsKCk7XHJcbiAgICAgICAgfSBjYXRjaCAocCkge1xyXG4gICAgICAgICAgbyA9IHAgaW5zdGFuY2VvZiBaZSA/IHAuZXJyb3JzIDogW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgdmFyIGYgPSB0aGlzLl9maW5hbGl6ZXJzO1xyXG4gICAgICBpZiAoZikge1xyXG4gICAgICAgIHRoaXMuX2ZpbmFsaXplcnMgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBmb3IgKHZhciB2ID0gbWUoZiksIGQgPSB2Lm5leHQoKTsgIWQuZG9uZTsgZCA9IHYubmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gZC52YWx1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBMdChtKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAocCkge1xyXG4gICAgICAgICAgICAgIG8gPSBvID8/IFtdLCBwIGluc3RhbmNlb2YgWmUgPyBvID0gZ2UoZ2UoW10sIHVlKG8pKSwgdWUocC5lcnJvcnMpKSA6IG8ucHVzaChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKHApIHtcclxuICAgICAgICAgIHIgPSB7IGVycm9yOiBwIH07XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGQgJiYgIWQuZG9uZSAmJiAoaSA9IHYucmV0dXJuKSAmJiBpLmNhbGwodik7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpZiAocikgdGhyb3cgci5lcnJvcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG8pXHJcbiAgICAgICAgdGhyb3cgbmV3IFplKG8pO1xyXG4gICAgfVxyXG4gIH0sIGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHQpIHtcclxuICAgIHZhciBuO1xyXG4gICAgaWYgKHQgJiYgdCAhPT0gdGhpcylcclxuICAgICAgaWYgKHRoaXMuY2xvc2VkKVxyXG4gICAgICAgIEx0KHQpO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIGUpIHtcclxuICAgICAgICAgIGlmICh0LmNsb3NlZCB8fCB0Ll9oYXNQYXJlbnQodGhpcykpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIHQuX2FkZFBhcmVudCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKHRoaXMuX2ZpbmFsaXplcnMgPSAobiA9IHRoaXMuX2ZpbmFsaXplcnMpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiBbXSkucHVzaCh0KTtcclxuICAgICAgfVxyXG4gIH0sIGUucHJvdG90eXBlLl9oYXNQYXJlbnQgPSBmdW5jdGlvbih0KSB7XHJcbiAgICB2YXIgbiA9IHRoaXMuX3BhcmVudGFnZTtcclxuICAgIHJldHVybiBuID09PSB0IHx8IEFycmF5LmlzQXJyYXkobikgJiYgbi5pbmNsdWRlcyh0KTtcclxuICB9LCBlLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSB0aGlzLl9wYXJlbnRhZ2U7XHJcbiAgICB0aGlzLl9wYXJlbnRhZ2UgPSBBcnJheS5pc0FycmF5KG4pID8gKG4ucHVzaCh0KSwgbikgOiBuID8gW24sIHRdIDogdDtcclxuICB9LCBlLnByb3RvdHlwZS5fcmVtb3ZlUGFyZW50ID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSB0aGlzLl9wYXJlbnRhZ2U7XHJcbiAgICBuID09PSB0ID8gdGhpcy5fcGFyZW50YWdlID0gbnVsbCA6IEFycmF5LmlzQXJyYXkobikgJiYgVWUobiwgdCk7XHJcbiAgfSwgZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSB0aGlzLl9maW5hbGl6ZXJzO1xyXG4gICAgbiAmJiBVZShuLCB0KSwgdCBpbnN0YW5jZW9mIGUgJiYgdC5fcmVtb3ZlUGFyZW50KHRoaXMpO1xyXG4gIH0sIGUuRU1QVFkgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB0ID0gbmV3IGUoKTtcclxuICAgIHJldHVybiB0LmNsb3NlZCA9ICEwLCB0O1xyXG4gIH0oKSwgZTtcclxufSgpLCBhbiA9IE9lLkVNUFRZO1xyXG5mdW5jdGlvbiBjbihlKSB7XHJcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBPZSB8fCBlICYmIFwiY2xvc2VkXCIgaW4gZSAmJiBBKGUucmVtb3ZlKSAmJiBBKGUuYWRkKSAmJiBBKGUudW5zdWJzY3JpYmUpO1xyXG59XHJcbmZ1bmN0aW9uIEx0KGUpIHtcclxuICBBKGUpID8gZSgpIDogZS51bnN1YnNjcmliZSgpO1xyXG59XHJcbnZhciBEciA9IHtcclxuICBQcm9taXNlOiB2b2lkIDBcclxufSwgJHIgPSB7XHJcbiAgc2V0VGltZW91dDogZnVuY3Rpb24oZSwgdCkge1xyXG4gICAgZm9yICh2YXIgbiA9IFtdLCByID0gMjsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKylcclxuICAgICAgbltyIC0gMl0gPSBhcmd1bWVudHNbcl07XHJcbiAgICByZXR1cm4gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIGdlKFtlLCB0XSwgdWUobikpKTtcclxuICB9LFxyXG4gIGNsZWFyVGltZW91dDogZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChlKTtcclxuICB9LFxyXG4gIGRlbGVnYXRlOiB2b2lkIDBcclxufTtcclxuZnVuY3Rpb24gdW4oZSkge1xyXG4gICRyLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICB0aHJvdyBlO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGplKCkge1xyXG59XHJcbmZ1bmN0aW9uIE1lKGUpIHtcclxuICBlKCk7XHJcbn1cclxudmFyIG10ID0gZnVuY3Rpb24oZSkge1xyXG4gIGVlKHQsIGUpO1xyXG4gIGZ1bmN0aW9uIHQobikge1xyXG4gICAgdmFyIHIgPSBlLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIHJldHVybiByLmlzU3RvcHBlZCA9ICExLCBuID8gKHIuZGVzdGluYXRpb24gPSBuLCBjbihuKSAmJiBuLmFkZChyKSkgOiByLmRlc3RpbmF0aW9uID0gVXIsIHI7XHJcbiAgfVxyXG4gIHJldHVybiB0LmNyZWF0ZSA9IGZ1bmN0aW9uKG4sIHIsIGkpIHtcclxuICAgIHJldHVybiBuZXcgQ2UobiwgciwgaSk7XHJcbiAgfSwgdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHRoaXMuaXNTdG9wcGVkIHx8IHRoaXMuX25leHQobik7XHJcbiAgfSwgdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihuKSB7XHJcbiAgICB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5pc1N0b3BwZWQgPSAhMCwgdGhpcy5fZXJyb3IobikpO1xyXG4gIH0sIHQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmlzU3RvcHBlZCB8fCAodGhpcy5pc1N0b3BwZWQgPSAhMCwgdGhpcy5fY29tcGxldGUoKSk7XHJcbiAgfSwgdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuY2xvc2VkIHx8ICh0aGlzLmlzU3RvcHBlZCA9ICEwLCBlLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpLCB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbCk7XHJcbiAgfSwgdC5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbihuKSB7XHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQobik7XHJcbiAgfSwgdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24obikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihuKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9LCB0LnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9LCB0O1xyXG59KE9lKSwgTnIgPSBmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBlKHQpIHtcclxuICAgIHRoaXMucGFydGlhbE9ic2VydmVyID0gdDtcclxuICB9XHJcbiAgcmV0dXJuIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih0KSB7XHJcbiAgICB2YXIgbiA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xyXG4gICAgaWYgKG4ubmV4dClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBuLm5leHQodCk7XHJcbiAgICAgIH0gY2F0Y2ggKHIpIHtcclxuICAgICAgICBfZShyKTtcclxuICAgICAgfVxyXG4gIH0sIGUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcclxuICAgIGlmIChuLmVycm9yKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG4uZXJyb3IodCk7XHJcbiAgICAgIH0gY2F0Y2ggKHIpIHtcclxuICAgICAgICBfZShyKTtcclxuICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICBfZSh0KTtcclxuICB9LCBlLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHQgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcclxuICAgIGlmICh0LmNvbXBsZXRlKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHQuY29tcGxldGUoKTtcclxuICAgICAgfSBjYXRjaCAobikge1xyXG4gICAgICAgIF9lKG4pO1xyXG4gICAgICB9XHJcbiAgfSwgZTtcclxufSgpLCBDZSA9IGZ1bmN0aW9uKGUpIHtcclxuICBlZSh0LCBlKTtcclxuICBmdW5jdGlvbiB0KG4sIHIsIGkpIHtcclxuICAgIHZhciBvID0gZS5jYWxsKHRoaXMpIHx8IHRoaXMsIHM7XHJcbiAgICByZXR1cm4gQShuKSB8fCAhbiA/IHMgPSB7XHJcbiAgICAgIG5leHQ6IG4gPz8gdm9pZCAwLFxyXG4gICAgICBlcnJvcjogciA/PyB2b2lkIDAsXHJcbiAgICAgIGNvbXBsZXRlOiBpID8/IHZvaWQgMFxyXG4gICAgfSA6IHMgPSBuLCBvLmRlc3RpbmF0aW9uID0gbmV3IE5yKHMpLCBvO1xyXG4gIH1cclxuICByZXR1cm4gdDtcclxufShtdCk7XHJcbmZ1bmN0aW9uIF9lKGUpIHtcclxuICB1bihlKTtcclxufVxyXG5mdW5jdGlvbiBGcihlKSB7XHJcbiAgdGhyb3cgZTtcclxufVxyXG52YXIgVXIgPSB7XHJcbiAgY2xvc2VkOiAhMCxcclxuICBuZXh0OiBqZSxcclxuICBlcnJvcjogRnIsXHJcbiAgY29tcGxldGU6IGplXHJcbn0sIGd0ID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8IFwiQEBvYnNlcnZhYmxlXCI7XHJcbn0oKTtcclxuZnVuY3Rpb24gYnQoZSkge1xyXG4gIHJldHVybiBlO1xyXG59XHJcbmZ1bmN0aW9uIGpyKGUpIHtcclxuICByZXR1cm4gZS5sZW5ndGggPT09IDAgPyBidCA6IGUubGVuZ3RoID09PSAxID8gZVswXSA6IGZ1bmN0aW9uKG4pIHtcclxuICAgIHJldHVybiBlLnJlZHVjZShmdW5jdGlvbihyLCBpKSB7XHJcbiAgICAgIHJldHVybiBpKHIpO1xyXG4gICAgfSwgbik7XHJcbiAgfTtcclxufVxyXG52YXIgayA9IGZ1bmN0aW9uKCkge1xyXG4gIGZ1bmN0aW9uIGUodCkge1xyXG4gICAgdCAmJiAodGhpcy5fc3Vic2NyaWJlID0gdCk7XHJcbiAgfVxyXG4gIHJldHVybiBlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSBuZXcgZSgpO1xyXG4gICAgcmV0dXJuIG4uc291cmNlID0gdGhpcywgbi5vcGVyYXRvciA9IHQsIG47XHJcbiAgfSwgZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24odCwgbiwgcikge1xyXG4gICAgdmFyIGkgPSB0aGlzLCBvID0gQnIodCkgPyB0IDogbmV3IENlKHQsIG4sIHIpO1xyXG4gICAgcmV0dXJuIE1lKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcyA9IGksIGEgPSBzLm9wZXJhdG9yLCBjID0gcy5zb3VyY2U7XHJcbiAgICAgIG8uYWRkKGEgPyBhLmNhbGwobywgYykgOiBjID8gaS5fc3Vic2NyaWJlKG8pIDogaS5fdHJ5U3Vic2NyaWJlKG8pKTtcclxuICAgIH0pLCBvO1xyXG4gIH0sIGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbih0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHQpO1xyXG4gICAgfSBjYXRjaCAobikge1xyXG4gICAgICB0LmVycm9yKG4pO1xyXG4gICAgfVxyXG4gIH0sIGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbih0LCBuKSB7XHJcbiAgICB2YXIgciA9IHRoaXM7XHJcbiAgICByZXR1cm4gbiA9IF90KG4pLCBuZXcgbihmdW5jdGlvbihpLCBvKSB7XHJcbiAgICAgIHZhciBzID0gbmV3IENlKHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbihhKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0KGEpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoYykge1xyXG4gICAgICAgICAgICBvKGMpLCBzLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogbyxcclxuICAgICAgICBjb21wbGV0ZTogaVxyXG4gICAgICB9KTtcclxuICAgICAgci5zdWJzY3JpYmUocyk7XHJcbiAgICB9KTtcclxuICB9LCBlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG47XHJcbiAgICByZXR1cm4gKG4gPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5zdWJzY3JpYmUodCk7XHJcbiAgfSwgZS5wcm90b3R5cGVbZ3RdID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LCBlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmb3IgKHZhciB0ID0gW10sIG4gPSAwOyBuIDwgYXJndW1lbnRzLmxlbmd0aDsgbisrKVxyXG4gICAgICB0W25dID0gYXJndW1lbnRzW25dO1xyXG4gICAgcmV0dXJuIGpyKHQpKHRoaXMpO1xyXG4gIH0sIGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uKHQpIHtcclxuICAgIHZhciBuID0gdGhpcztcclxuICAgIHJldHVybiB0ID0gX3QodCksIG5ldyB0KGZ1bmN0aW9uKHIsIGkpIHtcclxuICAgICAgdmFyIG87XHJcbiAgICAgIG4uc3Vic2NyaWJlKGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICByZXR1cm4gbyA9IHM7XHJcbiAgICAgIH0sIGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICByZXR1cm4gaShzKTtcclxuICAgICAgfSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHIobyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSwgZS5jcmVhdGUgPSBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gbmV3IGUodCk7XHJcbiAgfSwgZTtcclxufSgpO1xyXG5mdW5jdGlvbiBfdChlKSB7XHJcbiAgdmFyIHQ7XHJcbiAgcmV0dXJuICh0ID0gZSA/PyBEci5Qcm9taXNlKSAhPT0gbnVsbCAmJiB0ICE9PSB2b2lkIDAgPyB0IDogUHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBXcihlKSB7XHJcbiAgcmV0dXJuIGUgJiYgQShlLm5leHQpICYmIEEoZS5lcnJvcikgJiYgQShlLmNvbXBsZXRlKTtcclxufVxyXG5mdW5jdGlvbiBCcihlKSB7XHJcbiAgcmV0dXJuIGUgJiYgZSBpbnN0YW5jZW9mIG10IHx8IFdyKGUpICYmIGNuKGUpO1xyXG59XHJcbmZ1bmN0aW9uIFZyKGUpIHtcclxuICByZXR1cm4gQShlID09IG51bGwgPyB2b2lkIDAgOiBlLmxpZnQpO1xyXG59XHJcbmZ1bmN0aW9uIEIoZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XHJcbiAgICBpZiAoVnIodCkpXHJcbiAgICAgIHJldHVybiB0LmxpZnQoZnVuY3Rpb24obikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gZShuLCB0aGlzKTtcclxuICAgICAgICB9IGNhdGNoIChyKSB7XHJcbiAgICAgICAgICB0aGlzLmVycm9yKHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5hYmxlIHRvIGxpZnQgdW5rbm93biBPYnNlcnZhYmxlIHR5cGVcIik7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBXKGUsIHQsIG4sIHIsIGkpIHtcclxuICByZXR1cm4gbmV3IEhyKGUsIHQsIG4sIHIsIGkpO1xyXG59XHJcbnZhciBIciA9IGZ1bmN0aW9uKGUpIHtcclxuICBlZSh0LCBlKTtcclxuICBmdW5jdGlvbiB0KG4sIHIsIGksIG8sIHMsIGEpIHtcclxuICAgIHZhciBjID0gZS5jYWxsKHRoaXMsIG4pIHx8IHRoaXM7XHJcbiAgICByZXR1cm4gYy5vbkZpbmFsaXplID0gcywgYy5zaG91bGRVbnN1YnNjcmliZSA9IGEsIGMuX25leHQgPSByID8gZnVuY3Rpb24odSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHIodSk7XHJcbiAgICAgIH0gY2F0Y2ggKGwpIHtcclxuICAgICAgICBuLmVycm9yKGwpO1xyXG4gICAgICB9XHJcbiAgICB9IDogZS5wcm90b3R5cGUuX25leHQsIGMuX2Vycm9yID0gbyA/IGZ1bmN0aW9uKHUpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBvKHUpO1xyXG4gICAgICB9IGNhdGNoIChsKSB7XHJcbiAgICAgICAgbi5lcnJvcihsKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gOiBlLnByb3RvdHlwZS5fZXJyb3IsIGMuX2NvbXBsZXRlID0gaSA/IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGkoKTtcclxuICAgICAgfSBjYXRjaCAodSkge1xyXG4gICAgICAgIG4uZXJyb3IodSk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xyXG4gICAgICB9XHJcbiAgICB9IDogZS5wcm90b3R5cGUuX2NvbXBsZXRlLCBjO1xyXG4gIH1cclxuICByZXR1cm4gdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuO1xyXG4gICAgaWYgKCF0aGlzLnNob3VsZFVuc3Vic2NyaWJlIHx8IHRoaXMuc2hvdWxkVW5zdWJzY3JpYmUoKSkge1xyXG4gICAgICB2YXIgciA9IHRoaXMuY2xvc2VkO1xyXG4gICAgICBlLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpLCAhciAmJiAoKG4gPSB0aGlzLm9uRmluYWxpemUpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCB8fCBuLmNhbGwodGhpcykpO1xyXG4gICAgfVxyXG4gIH0sIHQ7XHJcbn0obXQpLCB6ciA9IHZ0KGZ1bmN0aW9uKGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICBlKHRoaXMpLCB0aGlzLm5hbWUgPSBcIk9iamVjdFVuc3Vic2NyaWJlZEVycm9yXCIsIHRoaXMubWVzc2FnZSA9IFwib2JqZWN0IHVuc3Vic2NyaWJlZFwiO1xyXG4gIH07XHJcbn0pLCBaID0gZnVuY3Rpb24oZSkge1xyXG4gIGVlKHQsIGUpO1xyXG4gIGZ1bmN0aW9uIHQoKSB7XHJcbiAgICB2YXIgbiA9IGUuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgcmV0dXJuIG4uY2xvc2VkID0gITEsIG4uY3VycmVudE9ic2VydmVycyA9IG51bGwsIG4ub2JzZXJ2ZXJzID0gW10sIG4uaXNTdG9wcGVkID0gITEsIG4uaGFzRXJyb3IgPSAhMSwgbi50aHJvd25FcnJvciA9IG51bGwsIG47XHJcbiAgfVxyXG4gIHJldHVybiB0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIgPSBuZXcgSXQodGhpcywgdGhpcyk7XHJcbiAgICByZXR1cm4gci5vcGVyYXRvciA9IG4sIHI7XHJcbiAgfSwgdC5wcm90b3R5cGUuX3Rocm93SWZDbG9zZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmNsb3NlZClcclxuICAgICAgdGhyb3cgbmV3IHpyKCk7XHJcbiAgfSwgdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciByID0gdGhpcztcclxuICAgIE1lKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgaSwgbztcclxuICAgICAgaWYgKHIuX3Rocm93SWZDbG9zZWQoKSwgIXIuaXNTdG9wcGVkKSB7XHJcbiAgICAgICAgci5jdXJyZW50T2JzZXJ2ZXJzIHx8IChyLmN1cnJlbnRPYnNlcnZlcnMgPSBBcnJheS5mcm9tKHIub2JzZXJ2ZXJzKSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGZvciAodmFyIHMgPSBtZShyLmN1cnJlbnRPYnNlcnZlcnMpLCBhID0gcy5uZXh0KCk7ICFhLmRvbmU7IGEgPSBzLm5leHQoKSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGEudmFsdWU7XHJcbiAgICAgICAgICAgIGMubmV4dChuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoICh1KSB7XHJcbiAgICAgICAgICBpID0geyBlcnJvcjogdSB9O1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhICYmICFhLmRvbmUgJiYgKG8gPSBzLnJldHVybikgJiYgby5jYWxsKHMpO1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaWYgKGkpIHRocm93IGkuZXJyb3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LCB0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciByID0gdGhpcztcclxuICAgIE1lKGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoci5fdGhyb3dJZkNsb3NlZCgpLCAhci5pc1N0b3BwZWQpIHtcclxuICAgICAgICByLmhhc0Vycm9yID0gci5pc1N0b3BwZWQgPSAhMCwgci50aHJvd25FcnJvciA9IG47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHIub2JzZXJ2ZXJzOyBpLmxlbmd0aDsgKVxyXG4gICAgICAgICAgaS5zaGlmdCgpLmVycm9yKG4pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LCB0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG4gPSB0aGlzO1xyXG4gICAgTWUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChuLl90aHJvd0lmQ2xvc2VkKCksICFuLmlzU3RvcHBlZCkge1xyXG4gICAgICAgIG4uaXNTdG9wcGVkID0gITA7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IG4ub2JzZXJ2ZXJzOyByLmxlbmd0aDsgKVxyXG4gICAgICAgICAgci5zaGlmdCgpLmNvbXBsZXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sIHQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRoaXMuY2xvc2VkID0gITAsIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcclxuICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsIFwib2JzZXJ2ZWRcIiwge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG47XHJcbiAgICAgIHJldHVybiAoKG4gPSB0aGlzLm9ic2VydmVycykgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5sZW5ndGgpID4gMDtcclxuICAgIH0sXHJcbiAgICBlbnVtZXJhYmxlOiAhMSxcclxuICAgIGNvbmZpZ3VyYWJsZTogITBcclxuICB9KSwgdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHJldHVybiB0aGlzLl90aHJvd0lmQ2xvc2VkKCksIGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBuKTtcclxuICB9LCB0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24obikge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Rocm93SWZDbG9zZWQoKSwgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhuKSwgdGhpcy5faW5uZXJTdWJzY3JpYmUobik7XHJcbiAgfSwgdC5wcm90b3R5cGUuX2lubmVyU3Vic2NyaWJlID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIgPSB0aGlzLCBpID0gdGhpcywgbyA9IGkuaGFzRXJyb3IsIHMgPSBpLmlzU3RvcHBlZCwgYSA9IGkub2JzZXJ2ZXJzO1xyXG4gICAgcmV0dXJuIG8gfHwgcyA/IGFuIDogKHRoaXMuY3VycmVudE9ic2VydmVycyA9IG51bGwsIGEucHVzaChuKSwgbmV3IE9lKGZ1bmN0aW9uKCkge1xyXG4gICAgICByLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsLCBVZShhLCBuKTtcclxuICAgIH0pKTtcclxuICB9LCB0LnByb3RvdHlwZS5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciByID0gdGhpcywgaSA9IHIuaGFzRXJyb3IsIG8gPSByLnRocm93bkVycm9yLCBzID0gci5pc1N0b3BwZWQ7XHJcbiAgICBpID8gbi5lcnJvcihvKSA6IHMgJiYgbi5jb21wbGV0ZSgpO1xyXG4gIH0sIHQucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG4gPSBuZXcgaygpO1xyXG4gICAgcmV0dXJuIG4uc291cmNlID0gdGhpcywgbjtcclxuICB9LCB0LmNyZWF0ZSA9IGZ1bmN0aW9uKG4sIHIpIHtcclxuICAgIHJldHVybiBuZXcgSXQobiwgcik7XHJcbiAgfSwgdDtcclxufShrKSwgSXQgPSBmdW5jdGlvbihlKSB7XHJcbiAgZWUodCwgZSk7XHJcbiAgZnVuY3Rpb24gdChuLCByKSB7XHJcbiAgICB2YXIgaSA9IGUuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgcmV0dXJuIGkuZGVzdGluYXRpb24gPSBuLCBpLnNvdXJjZSA9IHIsIGk7XHJcbiAgfVxyXG4gIHJldHVybiB0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIsIGk7XHJcbiAgICAoaSA9IChyID0gdGhpcy5kZXN0aW5hdGlvbikgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5uZXh0KSA9PT0gbnVsbCB8fCBpID09PSB2b2lkIDAgfHwgaS5jYWxsKHIsIG4pO1xyXG4gIH0sIHQucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIsIGk7XHJcbiAgICAoaSA9IChyID0gdGhpcy5kZXN0aW5hdGlvbikgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5lcnJvcikgPT09IG51bGwgfHwgaSA9PT0gdm9pZCAwIHx8IGkuY2FsbChyLCBuKTtcclxuICB9LCB0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG4sIHI7XHJcbiAgICAociA9IChuID0gdGhpcy5kZXN0aW5hdGlvbikgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5jb21wbGV0ZSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwIHx8IHIuY2FsbChuKTtcclxuICB9LCB0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIsIGk7XHJcbiAgICByZXR1cm4gKGkgPSAociA9IHRoaXMuc291cmNlKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLnN1YnNjcmliZShuKSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IGFuO1xyXG4gIH0sIHQ7XHJcbn0oWiksIGxuID0gZnVuY3Rpb24oZSkge1xyXG4gIGVlKHQsIGUpO1xyXG4gIGZ1bmN0aW9uIHQobikge1xyXG4gICAgdmFyIHIgPSBlLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgIHJldHVybiByLl92YWx1ZSA9IG4sIHI7XHJcbiAgfVxyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcclxuICAgIH0sXHJcbiAgICBlbnVtZXJhYmxlOiAhMSxcclxuICAgIGNvbmZpZ3VyYWJsZTogITBcclxuICB9KSwgdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciByID0gZS5wcm90b3R5cGUuX3N1YnNjcmliZS5jYWxsKHRoaXMsIG4pO1xyXG4gICAgcmV0dXJuICFyLmNsb3NlZCAmJiBuLm5leHQodGhpcy5fdmFsdWUpLCByO1xyXG4gIH0sIHQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbiA9IHRoaXMsIHIgPSBuLmhhc0Vycm9yLCBpID0gbi50aHJvd25FcnJvciwgbyA9IG4uX3ZhbHVlO1xyXG4gICAgaWYgKHIpXHJcbiAgICAgIHRocm93IGk7XHJcbiAgICByZXR1cm4gdGhpcy5fdGhyb3dJZkNsb3NlZCgpLCBvO1xyXG4gIH0sIHQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihuKSB7XHJcbiAgICBlLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdGhpcy5fdmFsdWUgPSBuKTtcclxuICB9LCB0O1xyXG59KFopLCBZciA9IHtcclxuICBub3c6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCk7XHJcbiAgfVxyXG59LCBxciA9IGZ1bmN0aW9uKGUpIHtcclxuICBlZSh0LCBlKTtcclxuICBmdW5jdGlvbiB0KG4sIHIpIHtcclxuICAgIHJldHVybiBlLmNhbGwodGhpcykgfHwgdGhpcztcclxuICB9XHJcbiAgcmV0dXJuIHQucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24obiwgcikge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSwgdDtcclxufShPZSksIFJ0ID0ge1xyXG4gIHNldEludGVydmFsOiBmdW5jdGlvbihlLCB0KSB7XHJcbiAgICBmb3IgKHZhciBuID0gW10sIHIgPSAyOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKVxyXG4gICAgICBuW3IgLSAyXSA9IGFyZ3VtZW50c1tyXTtcclxuICAgIHJldHVybiBzZXRJbnRlcnZhbC5hcHBseSh2b2lkIDAsIGdlKFtlLCB0XSwgdWUobikpKTtcclxuICB9LFxyXG4gIGNsZWFySW50ZXJ2YWw6IGZ1bmN0aW9uKGUpIHtcclxuICAgIHJldHVybiBjbGVhckludGVydmFsKGUpO1xyXG4gIH0sXHJcbiAgZGVsZWdhdGU6IHZvaWQgMFxyXG59LCBLciA9IGZ1bmN0aW9uKGUpIHtcclxuICBlZSh0LCBlKTtcclxuICBmdW5jdGlvbiB0KG4sIHIpIHtcclxuICAgIHZhciBpID0gZS5jYWxsKHRoaXMsIG4sIHIpIHx8IHRoaXM7XHJcbiAgICByZXR1cm4gaS5zY2hlZHVsZXIgPSBuLCBpLndvcmsgPSByLCBpLnBlbmRpbmcgPSAhMSwgaTtcclxuICB9XHJcbiAgcmV0dXJuIHQucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24obiwgcikge1xyXG4gICAgdmFyIGk7XHJcbiAgICBpZiAociA9PT0gdm9pZCAwICYmIChyID0gMCksIHRoaXMuY2xvc2VkKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIHRoaXMuc3RhdGUgPSBuO1xyXG4gICAgdmFyIG8gPSB0aGlzLmlkLCBzID0gdGhpcy5zY2hlZHVsZXI7XHJcbiAgICByZXR1cm4gbyAhPSBudWxsICYmICh0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzLCBvLCByKSksIHRoaXMucGVuZGluZyA9ICEwLCB0aGlzLmRlbGF5ID0gciwgdGhpcy5pZCA9IChpID0gdGhpcy5pZCkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IHRoaXMucmVxdWVzdEFzeW5jSWQocywgdGhpcy5pZCwgciksIHRoaXM7XHJcbiAgfSwgdC5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbihuLCByLCBpKSB7XHJcbiAgICByZXR1cm4gaSA9PT0gdm9pZCAwICYmIChpID0gMCksIFJ0LnNldEludGVydmFsKG4uZmx1c2guYmluZChuLCB0aGlzKSwgaSk7XHJcbiAgfSwgdC5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbihuLCByLCBpKSB7XHJcbiAgICBpZiAoaSA9PT0gdm9pZCAwICYmIChpID0gMCksIGkgIT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBpICYmIHRoaXMucGVuZGluZyA9PT0gITEpXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgciAhPSBudWxsICYmIFJ0LmNsZWFySW50ZXJ2YWwocik7XHJcbiAgfSwgdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG4sIHIpIHtcclxuICAgIGlmICh0aGlzLmNsb3NlZClcclxuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcImV4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb25cIik7XHJcbiAgICB0aGlzLnBlbmRpbmcgPSAhMTtcclxuICAgIHZhciBpID0gdGhpcy5fZXhlY3V0ZShuLCByKTtcclxuICAgIGlmIChpKVxyXG4gICAgICByZXR1cm4gaTtcclxuICAgIHRoaXMucGVuZGluZyA9PT0gITEgJiYgdGhpcy5pZCAhPSBudWxsICYmICh0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCkpO1xyXG4gIH0sIHQucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24obiwgcikge1xyXG4gICAgdmFyIGkgPSAhMSwgbztcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMud29yayhuKTtcclxuICAgIH0gY2F0Y2ggKHMpIHtcclxuICAgICAgaSA9ICEwLCBvID0gcyB8fCBuZXcgRXJyb3IoXCJTY2hlZHVsZWQgYWN0aW9uIHRocmV3IGZhbHN5IGVycm9yXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGkpXHJcbiAgICAgIHJldHVybiB0aGlzLnVuc3Vic2NyaWJlKCksIG87XHJcbiAgfSwgdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5jbG9zZWQpIHtcclxuICAgICAgdmFyIG4gPSB0aGlzLCByID0gbi5pZCwgaSA9IG4uc2NoZWR1bGVyLCBvID0gaS5hY3Rpb25zO1xyXG4gICAgICB0aGlzLndvcmsgPSB0aGlzLnN0YXRlID0gdGhpcy5zY2hlZHVsZXIgPSBudWxsLCB0aGlzLnBlbmRpbmcgPSAhMSwgVWUobywgdGhpcyksIHIgIT0gbnVsbCAmJiAodGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoaSwgciwgbnVsbCkpLCB0aGlzLmRlbGF5ID0gbnVsbCwgZS5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICB9LCB0O1xyXG59KHFyKSwgTXQgPSBmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBlKHQsIG4pIHtcclxuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IGUubm93KSwgdGhpcy5zY2hlZHVsZXJBY3Rpb25DdG9yID0gdCwgdGhpcy5ub3cgPSBuO1xyXG4gIH1cclxuICByZXR1cm4gZS5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbih0LCBuLCByKSB7XHJcbiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gMCksIG5ldyB0aGlzLnNjaGVkdWxlckFjdGlvbkN0b3IodGhpcywgdCkuc2NoZWR1bGUociwgbik7XHJcbiAgfSwgZS5ub3cgPSBZci5ub3csIGU7XHJcbn0oKSwgR3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgZWUodCwgZSk7XHJcbiAgZnVuY3Rpb24gdChuLCByKSB7XHJcbiAgICByID09PSB2b2lkIDAgJiYgKHIgPSBNdC5ub3cpO1xyXG4gICAgdmFyIGkgPSBlLmNhbGwodGhpcywgbiwgcikgfHwgdGhpcztcclxuICAgIHJldHVybiBpLmFjdGlvbnMgPSBbXSwgaS5fYWN0aXZlID0gITEsIGk7XHJcbiAgfVxyXG4gIHJldHVybiB0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKG4pIHtcclxuICAgIHZhciByID0gdGhpcy5hY3Rpb25zO1xyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xyXG4gICAgICByLnB1c2gobik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBpO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gITA7XHJcbiAgICBkb1xyXG4gICAgICBpZiAoaSA9IG4uZXhlY3V0ZShuLnN0YXRlLCBuLmRlbGF5KSlcclxuICAgICAgICBicmVhaztcclxuICAgIHdoaWxlIChuID0gci5zaGlmdCgpKTtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUgPSAhMSwgaSkge1xyXG4gICAgICBmb3IgKDsgbiA9IHIuc2hpZnQoKTsgKVxyXG4gICAgICAgIG4udW5zdWJzY3JpYmUoKTtcclxuICAgICAgdGhyb3cgaTtcclxuICAgIH1cclxuICB9LCB0O1xyXG59KE10KSwgUXIgPSBuZXcgR3IoS3IpO1xyXG5mdW5jdGlvbiBKcihlKSB7XHJcbiAgcmV0dXJuIGUgJiYgQShlLnNjaGVkdWxlKTtcclxufVxyXG5mdW5jdGlvbiBYcihlKSB7XHJcbiAgcmV0dXJuIGVbZS5sZW5ndGggLSAxXTtcclxufVxyXG5mdW5jdGlvbiB5dChlKSB7XHJcbiAgcmV0dXJuIEpyKFhyKGUpKSA/IGUucG9wKCkgOiB2b2lkIDA7XHJcbn1cclxudmFyIHd0ID0gZnVuY3Rpb24oZSkge1xyXG4gIHJldHVybiBlICYmIHR5cGVvZiBlLmxlbmd0aCA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIjtcclxufTtcclxuZnVuY3Rpb24gZm4oZSkge1xyXG4gIHJldHVybiBBKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudGhlbik7XHJcbn1cclxuZnVuY3Rpb24gZG4oZSkge1xyXG4gIHJldHVybiBBKGVbZ3RdKTtcclxufVxyXG5mdW5jdGlvbiBwbihlKSB7XHJcbiAgcmV0dXJuIFN5bWJvbC5hc3luY0l0ZXJhdG9yICYmIEEoZSA9PSBudWxsID8gdm9pZCAwIDogZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pO1xyXG59XHJcbmZ1bmN0aW9uIGhuKGUpIHtcclxuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBwcm92aWRlZCBcIiArIChlICE9PSBudWxsICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBcImFuIGludmFsaWQgb2JqZWN0XCIgOiBcIidcIiArIGUgKyBcIidcIikgKyBcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBSZWFkYWJsZVN0cmVhbSwgQXJyYXksIEFzeW5jSXRlcmFibGUsIG9yIEl0ZXJhYmxlLlwiKTtcclxufVxyXG5mdW5jdGlvbiBacigpIHtcclxuICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPSBcImZ1bmN0aW9uXCIgfHwgIVN5bWJvbC5pdGVyYXRvciA/IFwiQEBpdGVyYXRvclwiIDogU3ltYm9sLml0ZXJhdG9yO1xyXG59XHJcbnZhciB2biA9IFpyKCk7XHJcbmZ1bmN0aW9uIG1uKGUpIHtcclxuICByZXR1cm4gQShlID09IG51bGwgPyB2b2lkIDAgOiBlW3ZuXSk7XHJcbn1cclxuZnVuY3Rpb24gZ24oZSkge1xyXG4gIHJldHVybiBScih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG4sIHIsIGksIG87XHJcbiAgICByZXR1cm4gc24odGhpcywgZnVuY3Rpb24ocykge1xyXG4gICAgICBzd2l0Y2ggKHMubGFiZWwpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBuID0gZS5nZXRSZWFkZXIoKSwgcy5sYWJlbCA9IDE7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcy50cnlzLnB1c2goWzEsICwgOSwgMTBdKSwgcy5sYWJlbCA9IDI7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcmV0dXJuIFs0LCBwZShuLnJlYWQoKSldO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIHJldHVybiByID0gcy5zZW50KCksIGkgPSByLnZhbHVlLCBvID0gci5kb25lLCBvID8gWzQsIHBlKHZvaWQgMCldIDogWzMsIDVdO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBbMiwgcy5zZW50KCldO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIHJldHVybiBbNCwgcGUoaSldO1xyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgIHJldHVybiBbNCwgcy5zZW50KCldO1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgIHJldHVybiBzLnNlbnQoKSwgWzMsIDJdO1xyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgIHJldHVybiBbMywgMTBdO1xyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgIHJldHVybiBuLnJlbGVhc2VMb2NrKCksIFs3XTtcclxuICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgcmV0dXJuIFsyXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYm4oZSkge1xyXG4gIHJldHVybiBBKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZ2V0UmVhZGVyKTtcclxufVxyXG5mdW5jdGlvbiBIKGUpIHtcclxuICBpZiAoZSBpbnN0YW5jZW9mIGspXHJcbiAgICByZXR1cm4gZTtcclxuICBpZiAoZSAhPSBudWxsKSB7XHJcbiAgICBpZiAoZG4oZSkpXHJcbiAgICAgIHJldHVybiBlaShlKTtcclxuICAgIGlmICh3dChlKSlcclxuICAgICAgcmV0dXJuIHRpKGUpO1xyXG4gICAgaWYgKGZuKGUpKVxyXG4gICAgICByZXR1cm4gbmkoZSk7XHJcbiAgICBpZiAocG4oZSkpXHJcbiAgICAgIHJldHVybiB5bihlKTtcclxuICAgIGlmIChtbihlKSlcclxuICAgICAgcmV0dXJuIHJpKGUpO1xyXG4gICAgaWYgKGJuKGUpKVxyXG4gICAgICByZXR1cm4gaWkoZSk7XHJcbiAgfVxyXG4gIHRocm93IGhuKGUpO1xyXG59XHJcbmZ1bmN0aW9uIGVpKGUpIHtcclxuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4gPSBlW2d0XSgpO1xyXG4gICAgaWYgKEEobi5zdWJzY3JpYmUpKVxyXG4gICAgICByZXR1cm4gbi5zdWJzY3JpYmUodCk7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGVcIik7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdGkoZSkge1xyXG4gIHJldHVybiBuZXcgayhmdW5jdGlvbih0KSB7XHJcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoICYmICF0LmNsb3NlZDsgbisrKVxyXG4gICAgICB0Lm5leHQoZVtuXSk7XHJcbiAgICB0LmNvbXBsZXRlKCk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbmkoZSkge1xyXG4gIHJldHVybiBuZXcgayhmdW5jdGlvbih0KSB7XHJcbiAgICBlLnRoZW4oZnVuY3Rpb24obikge1xyXG4gICAgICB0LmNsb3NlZCB8fCAodC5uZXh0KG4pLCB0LmNvbXBsZXRlKCkpO1xyXG4gICAgfSwgZnVuY3Rpb24obikge1xyXG4gICAgICByZXR1cm4gdC5lcnJvcihuKTtcclxuICAgIH0pLnRoZW4obnVsbCwgdW4pO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJpKGUpIHtcclxuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24odCkge1xyXG4gICAgdmFyIG4sIHI7XHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKHZhciBpID0gbWUoZSksIG8gPSBpLm5leHQoKTsgIW8uZG9uZTsgbyA9IGkubmV4dCgpKSB7XHJcbiAgICAgICAgdmFyIHMgPSBvLnZhbHVlO1xyXG4gICAgICAgIGlmICh0Lm5leHQocyksIHQuY2xvc2VkKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChhKSB7XHJcbiAgICAgIG4gPSB7IGVycm9yOiBhIH07XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG8gJiYgIW8uZG9uZSAmJiAociA9IGkucmV0dXJuKSAmJiByLmNhbGwoaSk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgaWYgKG4pIHRocm93IG4uZXJyb3I7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHQuY29tcGxldGUoKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiB5bihlKSB7XHJcbiAgcmV0dXJuIG5ldyBrKGZ1bmN0aW9uKHQpIHtcclxuICAgIG9pKGUsIHQpLmNhdGNoKGZ1bmN0aW9uKG4pIHtcclxuICAgICAgcmV0dXJuIHQuZXJyb3Iobik7XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBpaShlKSB7XHJcbiAgcmV0dXJuIHluKGduKGUpKTtcclxufVxyXG5mdW5jdGlvbiBvaShlLCB0KSB7XHJcbiAgdmFyIG4sIHIsIGksIG87XHJcbiAgcmV0dXJuIElyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzLCBhO1xyXG4gICAgcmV0dXJuIHNuKHRoaXMsIGZ1bmN0aW9uKGMpIHtcclxuICAgICAgc3dpdGNoIChjLmxhYmVsKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgYy50cnlzLnB1c2goWzAsIDUsIDYsIDExXSksIG4gPSBNcihlKSwgYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcmV0dXJuIFs0LCBuLm5leHQoKV07XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaWYgKHIgPSBjLnNlbnQoKSwgISFyLmRvbmUpIHJldHVybiBbMywgNF07XHJcbiAgICAgICAgICBpZiAocyA9IHIudmFsdWUsIHQubmV4dChzKSwgdC5jbG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBbMl07XHJcbiAgICAgICAgICBjLmxhYmVsID0gMztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICByZXR1cm4gWzMsIDFdO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgIHJldHVybiBbMywgMTFdO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIHJldHVybiBhID0gYy5zZW50KCksIGkgPSB7IGVycm9yOiBhIH0sIFszLCAxMV07XHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgcmV0dXJuIGMudHJ5cy5wdXNoKFs2LCAsIDksIDEwXSksIHIgJiYgIXIuZG9uZSAmJiAobyA9IG4ucmV0dXJuKSA/IFs0LCBvLmNhbGwobildIDogWzMsIDhdO1xyXG4gICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgIGMuc2VudCgpLCBjLmxhYmVsID0gODtcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICByZXR1cm4gWzMsIDEwXTtcclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICBpZiAoaSkgdGhyb3cgaS5lcnJvcjtcclxuICAgICAgICAgIHJldHVybiBbN107XHJcbiAgICAgICAgY2FzZSAxMDpcclxuICAgICAgICAgIHJldHVybiBbN107XHJcbiAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgIHJldHVybiB0LmNvbXBsZXRlKCksIFsyXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmUoZSwgdCwgbiwgciwgaSkge1xyXG4gIHIgPT09IHZvaWQgMCAmJiAociA9IDApLCBpID09PSB2b2lkIDAgJiYgKGkgPSAhMSk7XHJcbiAgdmFyIG8gPSB0LnNjaGVkdWxlKGZ1bmN0aW9uKCkge1xyXG4gICAgbigpLCBpID8gZS5hZGQodGhpcy5zY2hlZHVsZShudWxsLCByKSkgOiB0aGlzLnVuc3Vic2NyaWJlKCk7XHJcbiAgfSwgcik7XHJcbiAgaWYgKGUuYWRkKG8pLCAhaSlcclxuICAgIHJldHVybiBvO1xyXG59XHJcbmZ1bmN0aW9uIHduKGUsIHQpIHtcclxuICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gMCksIEIoZnVuY3Rpb24obiwgcikge1xyXG4gICAgbi5zdWJzY3JpYmUoVyhyLCBmdW5jdGlvbihpKSB7XHJcbiAgICAgIHJldHVybiByZShyLCBlLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gci5uZXh0KGkpO1xyXG4gICAgICB9LCB0KTtcclxuICAgIH0sIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcmUociwgZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHIuY29tcGxldGUoKTtcclxuICAgICAgfSwgdCk7XHJcbiAgICB9LCBmdW5jdGlvbihpKSB7XHJcbiAgICAgIHJldHVybiByZShyLCBlLCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gci5lcnJvcihpKTtcclxuICAgICAgfSwgdCk7XHJcbiAgICB9KSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24geG4oZSwgdCkge1xyXG4gIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwgQihmdW5jdGlvbihuLCByKSB7XHJcbiAgICByLmFkZChlLnNjaGVkdWxlKGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbi5zdWJzY3JpYmUocik7XHJcbiAgICB9LCB0KSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2koZSwgdCkge1xyXG4gIHJldHVybiBIKGUpLnBpcGUoeG4odCksIHduKHQpKTtcclxufVxyXG5mdW5jdGlvbiBhaShlLCB0KSB7XHJcbiAgcmV0dXJuIEgoZSkucGlwZSh4bih0KSwgd24odCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNpKGUsIHQpIHtcclxuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24obikge1xyXG4gICAgdmFyIHIgPSAwO1xyXG4gICAgcmV0dXJuIHQuc2NoZWR1bGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHIgPT09IGUubGVuZ3RoID8gbi5jb21wbGV0ZSgpIDogKG4ubmV4dChlW3IrK10pLCBuLmNsb3NlZCB8fCB0aGlzLnNjaGVkdWxlKCkpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdWkoZSwgdCkge1xyXG4gIHJldHVybiBuZXcgayhmdW5jdGlvbihuKSB7XHJcbiAgICB2YXIgcjtcclxuICAgIHJldHVybiByZShuLCB0LCBmdW5jdGlvbigpIHtcclxuICAgICAgciA9IGVbdm5dKCksIHJlKG4sIHQsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBpLCBvLCBzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpID0gci5uZXh0KCksIG8gPSBpLnZhbHVlLCBzID0gaS5kb25lO1xyXG4gICAgICAgIH0gY2F0Y2ggKGEpIHtcclxuICAgICAgICAgIG4uZXJyb3IoYSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPyBuLmNvbXBsZXRlKCkgOiBuLm5leHQobyk7XHJcbiAgICAgIH0sIDAsICEwKTtcclxuICAgIH0pLCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIEEociA9PSBudWxsID8gdm9pZCAwIDogci5yZXR1cm4pICYmIHIucmV0dXJuKCk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIFNuKGUsIHQpIHtcclxuICBpZiAoIWUpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdGVyYWJsZSBjYW5ub3QgYmUgbnVsbFwiKTtcclxuICByZXR1cm4gbmV3IGsoZnVuY3Rpb24obikge1xyXG4gICAgcmUobiwgdCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciByID0gZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcclxuICAgICAgcmUobiwgdCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgci5uZXh0KCkudGhlbihmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICBpLmRvbmUgPyBuLmNvbXBsZXRlKCkgOiBuLm5leHQoaS52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIDAsICEwKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGxpKGUsIHQpIHtcclxuICByZXR1cm4gU24oZ24oZSksIHQpO1xyXG59XHJcbmZ1bmN0aW9uIGZpKGUsIHQpIHtcclxuICBpZiAoZSAhPSBudWxsKSB7XHJcbiAgICBpZiAoZG4oZSkpXHJcbiAgICAgIHJldHVybiBzaShlLCB0KTtcclxuICAgIGlmICh3dChlKSlcclxuICAgICAgcmV0dXJuIGNpKGUsIHQpO1xyXG4gICAgaWYgKGZuKGUpKVxyXG4gICAgICByZXR1cm4gYWkoZSwgdCk7XHJcbiAgICBpZiAocG4oZSkpXHJcbiAgICAgIHJldHVybiBTbihlLCB0KTtcclxuICAgIGlmIChtbihlKSlcclxuICAgICAgcmV0dXJuIHVpKGUsIHQpO1xyXG4gICAgaWYgKGJuKGUpKVxyXG4gICAgICByZXR1cm4gbGkoZSwgdCk7XHJcbiAgfVxyXG4gIHRocm93IGhuKGUpO1xyXG59XHJcbmZ1bmN0aW9uIEdlKGUsIHQpIHtcclxuICByZXR1cm4gdCA/IGZpKGUsIHQpIDogSChlKTtcclxufVxyXG5mdW5jdGlvbiBEdCgpIHtcclxuICBmb3IgKHZhciBlID0gW10sIHQgPSAwOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKVxyXG4gICAgZVt0XSA9IGFyZ3VtZW50c1t0XTtcclxuICB2YXIgbiA9IHl0KGUpO1xyXG4gIHJldHVybiBHZShlLCBuKTtcclxufVxyXG5mdW5jdGlvbiBkaShlKSB7XHJcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihlKTtcclxufVxyXG52YXIgcGkgPSB2dChmdW5jdGlvbihlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcclxuICAgIG4gPT09IHZvaWQgMCAmJiAobiA9IG51bGwpLCBlKHRoaXMpLCB0aGlzLm1lc3NhZ2UgPSBcIlRpbWVvdXQgaGFzIG9jY3VycmVkXCIsIHRoaXMubmFtZSA9IFwiVGltZW91dEVycm9yXCIsIHRoaXMuaW5mbyA9IG47XHJcbiAgfTtcclxufSk7XHJcbmZ1bmN0aW9uIGhpKGUsIHQpIHtcclxuICB2YXIgbiA9IGRpKGUpID8geyBmaXJzdDogZSB9IDogdHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IHsgZWFjaDogZSB9IDogZSwgciA9IG4uZmlyc3QsIGkgPSBuLmVhY2gsIG8gPSBuLndpdGgsIHMgPSBvID09PSB2b2lkIDAgPyB2aSA6IG8sIGEgPSBuLnNjaGVkdWxlciwgYyA9IGEgPT09IHZvaWQgMCA/IFFyIDogYSwgdSA9IG4ubWV0YSwgbCA9IHUgPT09IHZvaWQgMCA/IG51bGwgOiB1O1xyXG4gIGlmIChyID09IG51bGwgJiYgaSA9PSBudWxsKVxyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIHRpbWVvdXQgcHJvdmlkZWQuXCIpO1xyXG4gIHJldHVybiBCKGZ1bmN0aW9uKGYsIHYpIHtcclxuICAgIHZhciBkLCBtLCBwID0gbnVsbCwgZyA9IDAsIGggPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgIG0gPSByZSh2LCBjLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZC51bnN1YnNjcmliZSgpLCBIKHMoe1xyXG4gICAgICAgICAgICBtZXRhOiBsLFxyXG4gICAgICAgICAgICBsYXN0VmFsdWU6IHAsXHJcbiAgICAgICAgICAgIHNlZW46IGdcclxuICAgICAgICAgIH0pKS5zdWJzY3JpYmUodik7XHJcbiAgICAgICAgfSBjYXRjaCAoRSkge1xyXG4gICAgICAgICAgdi5lcnJvcihFKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHgpO1xyXG4gICAgfTtcclxuICAgIGQgPSBmLnN1YnNjcmliZShXKHYsIGZ1bmN0aW9uKHgpIHtcclxuICAgICAgbSA9PSBudWxsIHx8IG0udW5zdWJzY3JpYmUoKSwgZysrLCB2Lm5leHQocCA9IHgpLCBpID4gMCAmJiBoKGkpO1xyXG4gICAgfSwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBtICE9IG51bGwgJiYgbS5jbG9zZWQgfHwgbSA9PSBudWxsIHx8IG0udW5zdWJzY3JpYmUoKSwgcCA9IG51bGw7XHJcbiAgICB9KSksICFnICYmIGgociAhPSBudWxsID8gdHlwZW9mIHIgPT0gXCJudW1iZXJcIiA/IHIgOiArciAtIGMubm93KCkgOiBpKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiB2aShlKSB7XHJcbiAgdGhyb3cgbmV3IHBpKGUpO1xyXG59XHJcbmZ1bmN0aW9uIE8oZSwgdCkge1xyXG4gIHJldHVybiBCKGZ1bmN0aW9uKG4sIHIpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIG4uc3Vic2NyaWJlKFcociwgZnVuY3Rpb24obykge1xyXG4gICAgICByLm5leHQoZS5jYWxsKHQsIG8sIGkrKykpO1xyXG4gICAgfSkpO1xyXG4gIH0pO1xyXG59XHJcbnZhciBtaSA9IEFycmF5LmlzQXJyYXk7XHJcbmZ1bmN0aW9uIGdpKGUsIHQpIHtcclxuICByZXR1cm4gbWkodCkgPyBlLmFwcGx5KHZvaWQgMCwgZ2UoW10sIHVlKHQpKSkgOiBlKHQpO1xyXG59XHJcbmZ1bmN0aW9uIGJpKGUpIHtcclxuICByZXR1cm4gTyhmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gZ2koZSwgdCk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24geWkoZSwgdCwgbiwgciwgaSwgbywgcywgYSkge1xyXG4gIHZhciBjID0gW10sIHUgPSAwLCBsID0gMCwgZiA9ICExLCB2ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBmICYmICFjLmxlbmd0aCAmJiAhdSAmJiB0LmNvbXBsZXRlKCk7XHJcbiAgfSwgZCA9IGZ1bmN0aW9uKHApIHtcclxuICAgIHJldHVybiB1IDwgciA/IG0ocCkgOiBjLnB1c2gocCk7XHJcbiAgfSwgbSA9IGZ1bmN0aW9uKHApIHtcclxuICAgIHUrKztcclxuICAgIHZhciBnID0gITE7XHJcbiAgICBIKG4ocCwgbCsrKSkuc3Vic2NyaWJlKFcodCwgZnVuY3Rpb24oaCkge1xyXG4gICAgICB0Lm5leHQoaCk7XHJcbiAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgZyA9ICEwO1xyXG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGcpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHUtLTtcclxuICAgICAgICAgIGZvciAodmFyIGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHMgfHwgbSh4KTtcclxuICAgICAgICAgIH07IGMubGVuZ3RoICYmIHUgPCByOyApXHJcbiAgICAgICAgICAgIGgoKTtcclxuICAgICAgICAgIHYoKTtcclxuICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICB0LmVycm9yKHgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKTtcclxuICB9O1xyXG4gIHJldHVybiBlLnN1YnNjcmliZShXKHQsIGQsIGZ1bmN0aW9uKCkge1xyXG4gICAgZiA9ICEwLCB2KCk7XHJcbiAgfSkpLCBmdW5jdGlvbigpIHtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHh0KGUsIHQsIG4pIHtcclxuICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gMSAvIDApLCBBKHQpID8geHQoZnVuY3Rpb24ociwgaSkge1xyXG4gICAgcmV0dXJuIE8oZnVuY3Rpb24obywgcykge1xyXG4gICAgICByZXR1cm4gdChyLCBvLCBpLCBzKTtcclxuICAgIH0pKEgoZShyLCBpKSkpO1xyXG4gIH0sIG4pIDogKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgJiYgKG4gPSB0KSwgQihmdW5jdGlvbihyLCBpKSB7XHJcbiAgICByZXR1cm4geWkociwgaSwgZSwgbik7XHJcbiAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdpKGUpIHtcclxuICByZXR1cm4geHQoYnQsIGUpO1xyXG59XHJcbmZ1bmN0aW9uIHhpKCkge1xyXG4gIHJldHVybiB3aSgxKTtcclxufVxyXG5mdW5jdGlvbiBXZSgpIHtcclxuICBmb3IgKHZhciBlID0gW10sIHQgPSAwOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKVxyXG4gICAgZVt0XSA9IGFyZ3VtZW50c1t0XTtcclxuICByZXR1cm4geGkoKShHZShlLCB5dChlKSkpO1xyXG59XHJcbnZhciBTaSA9IFtcImFkZExpc3RlbmVyXCIsIFwicmVtb3ZlTGlzdGVuZXJcIl0sIFRpID0gW1wiYWRkRXZlbnRMaXN0ZW5lclwiLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIl0sIEVpID0gW1wib25cIiwgXCJvZmZcIl07XHJcbmZ1bmN0aW9uIGF0KGUsIHQsIG4sIHIpIHtcclxuICBpZiAoQShuKSAmJiAociA9IG4sIG4gPSB2b2lkIDApLCByKVxyXG4gICAgcmV0dXJuIGF0KGUsIHQsIG4pLnBpcGUoYmkocikpO1xyXG4gIHZhciBpID0gdWUoQWkoZSkgPyBUaS5tYXAoZnVuY3Rpb24oYSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcclxuICAgICAgcmV0dXJuIGVbYV0odCwgYywgbik7XHJcbiAgICB9O1xyXG4gIH0pIDogQ2koZSkgPyBTaS5tYXAoJHQoZSwgdCkpIDogUGkoZSkgPyBFaS5tYXAoJHQoZSwgdCkpIDogW10sIDIpLCBvID0gaVswXSwgcyA9IGlbMV07XHJcbiAgaWYgKCFvICYmIHd0KGUpKVxyXG4gICAgcmV0dXJuIHh0KGZ1bmN0aW9uKGEpIHtcclxuICAgICAgcmV0dXJuIGF0KGEsIHQsIG4pO1xyXG4gICAgfSkoSChlKSk7XHJcbiAgaWYgKCFvKVxyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZXZlbnQgdGFyZ2V0XCIpO1xyXG4gIHJldHVybiBuZXcgayhmdW5jdGlvbihhKSB7XHJcbiAgICB2YXIgYyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBmb3IgKHZhciB1ID0gW10sIGwgPSAwOyBsIDwgYXJndW1lbnRzLmxlbmd0aDsgbCsrKVxyXG4gICAgICAgIHVbbF0gPSBhcmd1bWVudHNbbF07XHJcbiAgICAgIHJldHVybiBhLm5leHQoMSA8IHUubGVuZ3RoID8gdSA6IHVbMF0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBvKGMpLCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHMoYyk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uICR0KGUsIHQpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcclxuICAgICAgcmV0dXJuIGVbbl0odCwgcik7XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gQ2koZSkge1xyXG4gIHJldHVybiBBKGUuYWRkTGlzdGVuZXIpICYmIEEoZS5yZW1vdmVMaXN0ZW5lcik7XHJcbn1cclxuZnVuY3Rpb24gUGkoZSkge1xyXG4gIHJldHVybiBBKGUub24pICYmIEEoZS5vZmYpO1xyXG59XHJcbmZ1bmN0aW9uIEFpKGUpIHtcclxuICByZXR1cm4gQShlLmFkZEV2ZW50TGlzdGVuZXIpICYmIEEoZS5yZW1vdmVFdmVudExpc3RlbmVyKTtcclxufVxyXG5mdW5jdGlvbiBRZShlLCB0KSB7XHJcbiAgcmV0dXJuIEIoZnVuY3Rpb24obiwgcikge1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgbi5zdWJzY3JpYmUoVyhyLCBmdW5jdGlvbihvKSB7XHJcbiAgICAgIHJldHVybiBlLmNhbGwodCwgbywgaSsrKSAmJiByLm5leHQobyk7XHJcbiAgICB9KSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gT2koZSwgdCwgbiwgciwgaSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihvLCBzKSB7XHJcbiAgICB2YXIgYSA9IG4sIGMgPSB0LCB1ID0gMDtcclxuICAgIG8uc3Vic2NyaWJlKFcocywgZnVuY3Rpb24obCkge1xyXG4gICAgICB2YXIgZiA9IHUrKztcclxuICAgICAgYyA9IGEgPyBlKGMsIGwsIGYpIDogKGEgPSAhMCwgbCksIHMubmV4dChjKTtcclxuICAgIH0sIGkpKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGtpKGUsIHQpIHtcclxuICByZXR1cm4gdCA9PT0gdm9pZCAwICYmICh0ID0gYnQpLCBlID0gZSA/PyBMaSwgQihmdW5jdGlvbihuLCByKSB7XHJcbiAgICB2YXIgaSwgbyA9ICEwO1xyXG4gICAgbi5zdWJzY3JpYmUoVyhyLCBmdW5jdGlvbihzKSB7XHJcbiAgICAgIHZhciBhID0gdChzKTtcclxuICAgICAgKG8gfHwgIWUoaSwgYSkpICYmIChvID0gITEsIGkgPSBhLCByLm5leHQocykpO1xyXG4gICAgfSkpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIExpKGUsIHQpIHtcclxuICByZXR1cm4gZSA9PT0gdDtcclxufVxyXG5mdW5jdGlvbiBjdChlLCB0KSB7XHJcbiAgcmV0dXJuIEIoT2koZSwgdCwgYXJndW1lbnRzLmxlbmd0aCA+PSAyLCAhMCkpO1xyXG59XHJcbmZ1bmN0aW9uIF9pKGUpIHtcclxuICBlID09PSB2b2lkIDAgJiYgKGUgPSB7fSk7XHJcbiAgdmFyIHQgPSBlLmNvbm5lY3RvciwgbiA9IHQgPT09IHZvaWQgMCA/IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBaKCk7XHJcbiAgfSA6IHQsIHIgPSBlLnJlc2V0T25FcnJvciwgaSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbyA9IGUucmVzZXRPbkNvbXBsZXRlLCBzID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBhID0gZS5yZXNldE9uUmVmQ291bnRaZXJvLCBjID0gYSA9PT0gdm9pZCAwID8gITAgOiBhO1xyXG4gIHJldHVybiBmdW5jdGlvbih1KSB7XHJcbiAgICB2YXIgbCwgZiwgdiwgZCA9IDAsIG0gPSAhMSwgcCA9ICExLCBnID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGYgPT0gbnVsbCB8fCBmLnVuc3Vic2NyaWJlKCksIGYgPSB2b2lkIDA7XHJcbiAgICB9LCBoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGcoKSwgbCA9IHYgPSB2b2lkIDAsIG0gPSBwID0gITE7XHJcbiAgICB9LCB4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBFID0gbDtcclxuICAgICAgaCgpLCBFID09IG51bGwgfHwgRS51bnN1YnNjcmliZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCKGZ1bmN0aW9uKEUsIFApIHtcclxuICAgICAgZCsrLCAhcCAmJiAhbSAmJiBnKCk7XHJcbiAgICAgIHZhciBiID0gdiA9IHYgPz8gbigpO1xyXG4gICAgICBQLmFkZChmdW5jdGlvbigpIHtcclxuICAgICAgICBkLS0sIGQgPT09IDAgJiYgIXAgJiYgIW0gJiYgKGYgPSBldCh4LCBjKSk7XHJcbiAgICAgIH0pLCBiLnN1YnNjcmliZShQKSwgIWwgJiYgZCA+IDAgJiYgKGwgPSBuZXcgQ2Uoe1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKFMpIHtcclxuICAgICAgICAgIHJldHVybiBiLm5leHQoUyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oUykge1xyXG4gICAgICAgICAgcCA9ICEwLCBnKCksIGYgPSBldChoLCBpLCBTKSwgYi5lcnJvcihTKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIG0gPSAhMCwgZygpLCBmID0gZXQoaCwgcyksIGIuY29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLCBIKEUpLnN1YnNjcmliZShsKSk7XHJcbiAgICB9KSh1KTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGV0KGUsIHQpIHtcclxuICBmb3IgKHZhciBuID0gW10sIHIgPSAyOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKVxyXG4gICAgbltyIC0gMl0gPSBhcmd1bWVudHNbcl07XHJcbiAgaWYgKHQgPT09ICEwKSB7XHJcbiAgICBlKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh0ICE9PSAhMSkge1xyXG4gICAgdmFyIGkgPSBuZXcgQ2Uoe1xyXG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpLnVuc3Vic2NyaWJlKCksIGUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gSCh0LmFwcGx5KHZvaWQgMCwgZ2UoW10sIHVlKG4pKSkpLnN1YnNjcmliZShpKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gSWkoZSkge1xyXG4gIHJldHVybiBCKGZ1bmN0aW9uKHQsIG4pIHtcclxuICAgIHZhciByID0gITEsIGkgPSBXKG4sIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpID09IG51bGwgfHwgaS51bnN1YnNjcmliZSgpLCByID0gITA7XHJcbiAgICB9LCBqZSk7XHJcbiAgICBIKGUpLnN1YnNjcmliZShpKSwgdC5zdWJzY3JpYmUoVyhuLCBmdW5jdGlvbihvKSB7XHJcbiAgICAgIHJldHVybiByICYmIG4ubmV4dChvKTtcclxuICAgIH0pKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBEKCkge1xyXG4gIGZvciAodmFyIGUgPSBbXSwgdCA9IDA7IHQgPCBhcmd1bWVudHMubGVuZ3RoOyB0KyspXHJcbiAgICBlW3RdID0gYXJndW1lbnRzW3RdO1xyXG4gIHZhciBuID0geXQoZSk7XHJcbiAgcmV0dXJuIEIoZnVuY3Rpb24ociwgaSkge1xyXG4gICAgKG4gPyBXZShlLCByLCBuKSA6IFdlKGUsIHIpKS5zdWJzY3JpYmUoaSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gVG4oZSwgdCkge1xyXG4gIHJldHVybiBCKGZ1bmN0aW9uKG4sIHIpIHtcclxuICAgIHZhciBpID0gbnVsbCwgbyA9IDAsIHMgPSAhMSwgYSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcyAmJiAhaSAmJiByLmNvbXBsZXRlKCk7XHJcbiAgICB9O1xyXG4gICAgbi5zdWJzY3JpYmUoVyhyLCBmdW5jdGlvbihjKSB7XHJcbiAgICAgIGkgPT0gbnVsbCB8fCBpLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIHZhciB1ID0gMCwgbCA9IG8rKztcclxuICAgICAgSChlKGMsIGwpKS5zdWJzY3JpYmUoaSA9IFcociwgZnVuY3Rpb24oZikge1xyXG4gICAgICAgIHJldHVybiByLm5leHQodCA/IHQoYywgZiwgbCwgdSsrKSA6IGYpO1xyXG4gICAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgICBpID0gbnVsbCwgYSgpO1xyXG4gICAgICB9KSk7XHJcbiAgICB9LCBmdW5jdGlvbigpIHtcclxuICAgICAgcyA9ICEwLCBhKCk7XHJcbiAgICB9KSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gTnQoZSkge1xyXG4gIHJldHVybiBCKGZ1bmN0aW9uKHQsIG4pIHtcclxuICAgIEgoZSkuc3Vic2NyaWJlKFcobiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuLmNvbXBsZXRlKCk7XHJcbiAgICB9LCBqZSkpLCAhbi5jbG9zZWQgJiYgdC5zdWJzY3JpYmUobik7XHJcbiAgfSk7XHJcbn1cclxudmFyIFJpID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBNaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBEaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBGdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsICRpID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgTmkgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLCBVdCA9IChlLCB0LCBuKSA9PiB0IGluIGUgPyBSaShlLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBuIH0pIDogZVt0XSA9IG4sIFggPSAoZSwgdCkgPT4ge1xyXG4gIGZvciAodmFyIG4gaW4gdCB8fCAodCA9IHt9KSlcclxuICAgICRpLmNhbGwodCwgbikgJiYgVXQoZSwgbiwgdFtuXSk7XHJcbiAgaWYgKEZ0KVxyXG4gICAgZm9yICh2YXIgbiBvZiBGdCh0KSlcclxuICAgICAgTmkuY2FsbCh0LCBuKSAmJiBVdChlLCBuLCB0W25dKTtcclxuICByZXR1cm4gZTtcclxufSwgVGUgPSAoZSwgdCkgPT4gTWkoZSwgRGkodCkpLCBWID0gKGUsIHQsIG4pID0+IG5ldyBQcm9taXNlKChyLCBpKSA9PiB7XHJcbiAgdmFyIG8gPSAoYykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYShuLm5leHQoYykpO1xyXG4gICAgfSBjYXRjaCAodSkge1xyXG4gICAgICBpKHUpO1xyXG4gICAgfVxyXG4gIH0sIHMgPSAoYykgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYShuLnRocm93KGMpKTtcclxuICAgIH0gY2F0Y2ggKHUpIHtcclxuICAgICAgaSh1KTtcclxuICAgIH1cclxuICB9LCBhID0gKGMpID0+IGMuZG9uZSA/IHIoYy52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoYy52YWx1ZSkudGhlbihvLCBzKTtcclxuICBhKChuID0gbi5hcHBseShlLCB0KSkubmV4dCgpKTtcclxufSksIEVuID0gXCJsa1wiO1xyXG5mdW5jdGlvbiBqKGUpIHtcclxuICByZXR1cm4gdHlwZW9mIGUgPiBcInVcIiA/ICExIDogRmkoZSkgfHwgVWkoZSk7XHJcbn1cclxuZnVuY3Rpb24gRmkoZSkge1xyXG4gIHZhciB0O1xyXG4gIHJldHVybiBlID8gZS5oYXNPd25Qcm9wZXJ0eShcInBhcnRpY2lwYW50XCIpICYmIGUuaGFzT3duUHJvcGVydHkoXCJzb3VyY2VcIikgJiYgZS5oYXNPd25Qcm9wZXJ0eShcInRyYWNrXCIpICYmIHR5cGVvZiAoKHQgPSBlLnB1YmxpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogdC50cmFjaykgPCBcInVcIiA6ICExO1xyXG59XHJcbmZ1bmN0aW9uIFVpKGUpIHtcclxuICByZXR1cm4gZSA/IGUuaGFzT3duUHJvcGVydHkoXCJwYXJ0aWNpcGFudFwiKSAmJiBlLmhhc093blByb3BlcnR5KFwic291cmNlXCIpICYmIGUuaGFzT3duUHJvcGVydHkoXCJwdWJsaWNhdGlvblwiKSAmJiB0eXBlb2YgZS5wdWJsaWNhdGlvbiA8IFwidVwiIDogITE7XHJcbn1cclxuZnVuY3Rpb24gUGUoZSkge1xyXG4gIHJldHVybiBlID8gZS5oYXNPd25Qcm9wZXJ0eShcInBhcnRpY2lwYW50XCIpICYmIGUuaGFzT3duUHJvcGVydHkoXCJzb3VyY2VcIikgJiYgdHlwZW9mIGUucHVibGljYXRpb24gPiBcInVcIiA6ICExO1xyXG59XHJcbmZ1bmN0aW9uIE4oZSkge1xyXG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpXHJcbiAgICByZXR1cm4gYCR7ZX1gO1xyXG4gIGlmIChQZShlKSlcclxuICAgIHJldHVybiBgJHtlLnBhcnRpY2lwYW50LmlkZW50aXR5fV8ke2Uuc291cmNlfV9wbGFjZWhvbGRlcmA7XHJcbiAgaWYgKGooZSkpXHJcbiAgICByZXR1cm4gYCR7ZS5wYXJ0aWNpcGFudC5pZGVudGl0eX1fJHtlLnB1YmxpY2F0aW9uLnNvdXJjZX1fJHtlLnB1YmxpY2F0aW9uLnRyYWNrU2lkfWA7XHJcbiAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBnZW5lcmF0ZSBhIGlkIGZvciB0aGUgZ2l2ZW4gdHJhY2sgcmVmZXJlbmNlOiAke2V9YCk7XHJcbn1cclxuZnVuY3Rpb24gRG8oZSwgdCkge1xyXG4gIHJldHVybiBlID09PSB2b2lkIDAgfHwgdCA9PT0gdm9pZCAwID8gITEgOiBqKGUpICYmIGoodCkgPyBlLnB1YmxpY2F0aW9uLnRyYWNrU2lkID09PSB0LnB1YmxpY2F0aW9uLnRyYWNrU2lkIDogTihlKSA9PT0gTih0KTtcclxufVxyXG5mdW5jdGlvbiAkbyhlLCB0KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB0ID4gXCJ1XCIgPyAhMSA6IGooZSkgPyB0LnNvbWUoXHJcbiAgICAobikgPT4gbi5wYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gZS5wYXJ0aWNpcGFudC5pZGVudGl0eSAmJiBqKG4pICYmIG4ucHVibGljYXRpb24udHJhY2tTaWQgPT09IGUucHVibGljYXRpb24udHJhY2tTaWRcclxuICApIDogUGUoZSkgPyB0LnNvbWUoXHJcbiAgICAobikgPT4gbi5wYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gZS5wYXJ0aWNpcGFudC5pZGVudGl0eSAmJiBQZShuKSAmJiBuLnNvdXJjZSA9PT0gZS5zb3VyY2VcclxuICApIDogITE7XHJcbn1cclxuZnVuY3Rpb24gamkoZSwgdCkge1xyXG4gIHJldHVybiBQZShlKSAmJiBqKHQpICYmIHQucGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGUucGFydGljaXBhbnQuaWRlbnRpdHkgJiYgdC5zb3VyY2UgPT09IGUuc291cmNlO1xyXG59XHJcbmZ1bmN0aW9uIE5vKCkge1xyXG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcclxuICBlLnN0eWxlLndpZHRoID0gXCIxMDAlXCIsIGUuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xyXG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIHQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIHQuc3R5bGUudG9wID0gXCIwcHhcIiwgdC5zdHlsZS5sZWZ0ID0gXCIwcHhcIiwgdC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdC5zdHlsZS53aWR0aCA9IFwiMjAwcHhcIiwgdC5zdHlsZS5oZWlnaHQgPSBcIjE1MHB4XCIsIHQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCB0LmFwcGVuZENoaWxkKGUpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO1xyXG4gIGNvbnN0IG4gPSBlLm9mZnNldFdpZHRoO1xyXG4gIHQuc3R5bGUub3ZlcmZsb3cgPSBcInNjcm9sbFwiO1xyXG4gIGxldCByID0gZS5vZmZzZXRXaWR0aDtcclxuICByZXR1cm4gbiA9PT0gciAmJiAociA9IHQuY2xpZW50V2lkdGgpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpLCBuIC0gcjtcclxufVxyXG5mdW5jdGlvbiBGbygpIHtcclxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCI7XHJcbn1cclxuZnVuY3Rpb24gV2koZSkge1xyXG4gIGUgPSBYKHt9LCBlKTtcclxuICBjb25zdCB0ID0gXCIoPzooPzpbYS16XSs6KT8vLyk/XCIsIG4gPSBcIig/OlxcXFxTKyg/OjpcXFxcUyopP0ApP1wiLCByID0gbmV3IFJlZ0V4cChcclxuICAgIFwiKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M31cIixcclxuICAgIFwiZ1wiXHJcbiAgKS5zb3VyY2UsIHUgPSBgKD86JHt0fXx3d3dcXFxcLikke259KD86bG9jYWxob3N0fCR7cn18KD86KD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldWy1fXSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0tKikqW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKykqKD86XFxcXC4oPzpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZl17Mix9KSlcXFxcLj8pKD86OlxcXFxkezIsNX0pPyg/OlsvPyNdW15cXFxcc1wiXSopP2A7XHJcbiAgcmV0dXJuIGUuZXhhY3QgPyBuZXcgUmVnRXhwKGAoPzpeJHt1fSQpYCwgXCJpXCIpIDogbmV3IFJlZ0V4cCh1LCBcImlnXCIpO1xyXG59XHJcbnZhciBqdCA9IFwiW15cXFxcLlxcXFxzQDpdKD86W15cXFxcc0A6XSpbXlxcXFxzQDpcXFxcLl0pP0BbXlxcXFwuXFxcXHNAXSsoPzpcXFxcLlteXFxcXC5cXFxcc0BdKykqXCI7XHJcbmZ1bmN0aW9uIEJpKHsgZXhhY3Q6IGUgfSA9IHt9KSB7XHJcbiAgcmV0dXJuIGUgPyBuZXcgUmVnRXhwKGBeJHtqdH0kYCkgOiBuZXcgUmVnRXhwKGp0LCBcImdcIik7XHJcbn1cclxuZnVuY3Rpb24gVW8oZSwgdCwgbikge1xyXG4gIHJldHVybiBTcihlLCB0LCAoKSA9PiBWKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBjb25zdCB7IHg6IGksIHk6IG8gfSA9IHlpZWxkIFByKGUsIHQsIHtcclxuICAgICAgcGxhY2VtZW50OiBcInRvcFwiLFxyXG4gICAgICBtaWRkbGV3YXJlOiBbVHIoNiksIENyKCksIEVyKHsgcGFkZGluZzogNSB9KV1cclxuICAgIH0pO1xyXG4gICAgbiA9PSBudWxsIHx8IG4oaSwgbyk7XHJcbiAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGpvKGUsIHQpIHtcclxuICByZXR1cm4gIWUuY29udGFpbnModC50YXJnZXQpO1xyXG59XHJcbnZhciBXbyA9ICgpID0+ICh7XHJcbiAgZW1haWw6IEJpKCksXHJcbiAgdXJsOiBXaSh7fSlcclxufSk7XHJcbmZ1bmN0aW9uIEJvKGUsIHQpIHtcclxuICBjb25zdCBuID0gT2JqZWN0LmVudHJpZXModCkubWFwKFxyXG4gICAgKFtvLCBzXSwgYSkgPT4gQXJyYXkuZnJvbShlLm1hdGNoQWxsKHMpKS5tYXAoKHsgaW5kZXg6IGMsIDA6IHUgfSkgPT4gKHtcclxuICAgICAgdHlwZTogbyxcclxuICAgICAgd2VpZ2h0OiBhLFxyXG4gICAgICBjb250ZW50OiB1LFxyXG4gICAgICBpbmRleDogYyA/PyAwXHJcbiAgICB9KSlcclxuICApLmZsYXQoKS5zb3J0KChvLCBzKSA9PiB7XHJcbiAgICBjb25zdCBhID0gby5pbmRleCAtIHMuaW5kZXg7XHJcbiAgICByZXR1cm4gYSAhPT0gMCA/IGEgOiBvLndlaWdodCAtIHMud2VpZ2h0O1xyXG4gIH0pLmZpbHRlcigoeyBpbmRleDogbyB9LCBzLCBhKSA9PiB7XHJcbiAgICBpZiAocyA9PT0gMCkgcmV0dXJuICEwO1xyXG4gICAgY29uc3QgYyA9IGFbcyAtIDFdO1xyXG4gICAgcmV0dXJuIGMuaW5kZXggKyBjLmNvbnRlbnQubGVuZ3RoIDw9IG87XHJcbiAgfSksIHIgPSBbXTtcclxuICBsZXQgaSA9IDA7XHJcbiAgZm9yIChjb25zdCB7IHR5cGU6IG8sIGNvbnRlbnQ6IHMsIGluZGV4OiBhIH0gb2YgbilcclxuICAgIGEgPiBpICYmIHIucHVzaChlLnN1YnN0cmluZyhpLCBhKSksIHIucHVzaCh7IHR5cGU6IG8sIGNvbnRlbnQ6IHMgfSksIGkgPSBhICsgcy5sZW5ndGg7XHJcbiAgcmV0dXJuIGUubGVuZ3RoID4gaSAmJiByLnB1c2goZS5zdWJzdHJpbmcoaSkpLCByO1xyXG59XHJcbnZhciBWaSA9IFtcclxuICB5LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsXHJcbiAgeS5Sb29tTWV0YWRhdGFDaGFuZ2VkLFxyXG4gIHkuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLFxyXG4gIHkuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLFxyXG4gIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXHJcbiAgeS5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCxcclxuICB5LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxyXG4gIHkuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsXHJcbiAgeS5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLFxyXG4gIHkuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCxcclxuICB5LlRyYWNrTXV0ZWQsXHJcbiAgeS5UcmFja1VubXV0ZWQsXHJcbiAgeS5UcmFja1B1Ymxpc2hlZCxcclxuICB5LlRyYWNrVW5wdWJsaXNoZWQsXHJcbiAgeS5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCxcclxuICB5LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLFxyXG4gIHkuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcclxuICB5LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFxyXG5dLCBDbiA9IFtcclxuICAuLi5WaSxcclxuICB5LkxvY2FsVHJhY2tQdWJsaXNoZWQsXHJcbiAgeS5Mb2NhbFRyYWNrVW5wdWJsaXNoZWRcclxuXSwgSGkgPSBbXHJcbiAgdy5UcmFja1B1Ymxpc2hlZCxcclxuICB3LlRyYWNrVW5wdWJsaXNoZWQsXHJcbiAgdy5UcmFja011dGVkLFxyXG4gIHcuVHJhY2tVbm11dGVkLFxyXG4gIHcuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsXHJcbiAgdy5UcmFja1N1YnNjcmliZWQsXHJcbiAgdy5UcmFja1Vuc3Vic2NyaWJlZCxcclxuICB3LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsXHJcbiAgdy5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCxcclxuICB3LkxvY2FsVHJhY2tQdWJsaXNoZWQsXHJcbiAgdy5Mb2NhbFRyYWNrVW5wdWJsaXNoZWRcclxuXSwgemkgPSBbXHJcbiAgdy5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXHJcbiAgdy5Jc1NwZWFraW5nQ2hhbmdlZCxcclxuICB3LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLFxyXG4gIHcuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXHJcbiAgdy5UcmFja011dGVkLFxyXG4gIHcuVHJhY2tVbm11dGVkLFxyXG4gIHcuVHJhY2tQdWJsaXNoZWQsXHJcbiAgdy5UcmFja1VucHVibGlzaGVkLFxyXG4gIHcuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsXHJcbiAgdy5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCxcclxuICB3LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsXHJcbiAgdy5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcclxuXSwgUG4gPSBbXHJcbiAgLi4uemksXHJcbiAgdy5Mb2NhbFRyYWNrUHVibGlzaGVkLFxyXG4gIHcuTG9jYWxUcmFja1VucHVibGlzaGVkXHJcbl0sIF8gPSBfci5nZXRMb2dnZXIoXCJsay1jb21wb25lbnRzLWpzXCIpO1xyXG5fLnNldERlZmF1bHRMZXZlbChcIldBUk5cIik7XHJcbmZ1bmN0aW9uIFZvKGUsIHQgPSB7fSkge1xyXG4gIHZhciBuO1xyXG4gIF8uc2V0TGV2ZWwoZSksIFZuKChuID0gdC5saXZlS2l0Q2xpZW50TG9nTGV2ZWwpICE9IG51bGwgPyBuIDogZSk7XHJcbn1cclxuZnVuY3Rpb24gSG8oZSwgdCA9IHt9KSB7XHJcbiAgdmFyIG47XHJcbiAgY29uc3QgciA9IF8ubWV0aG9kRmFjdG9yeTtcclxuICBfLm1ldGhvZEZhY3RvcnkgPSAoaSwgbywgcykgPT4ge1xyXG4gICAgY29uc3QgYSA9IHIoaSwgbywgcyksIGMgPSBTdFtpXSwgdSA9IGMgPj0gbyAmJiBjIDwgU3Quc2lsZW50O1xyXG4gICAgcmV0dXJuIChsLCBmKSA9PiB7XHJcbiAgICAgIGYgPyBhKGwsIGYpIDogYShsKSwgdSAmJiBlKGMsIGwsIGYpO1xyXG4gICAgfTtcclxuICB9LCBfLnNldExldmVsKF8uZ2V0TGV2ZWwoKSksIEhuKChuID0gdC5saXZlS2l0Q2xpZW50TG9nRXh0ZW5zaW9uKSAhPSBudWxsID8gbiA6IGUpO1xyXG59XHJcbnZhciB6byA9IFtcclxuICB7XHJcbiAgICBjb2x1bW5zOiAxLFxyXG4gICAgcm93czogMVxyXG4gIH0sXHJcbiAge1xyXG4gICAgY29sdW1uczogMSxcclxuICAgIHJvd3M6IDIsXHJcbiAgICBvcmllbnRhdGlvbjogXCJwb3J0cmFpdFwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBjb2x1bW5zOiAyLFxyXG4gICAgcm93czogMSxcclxuICAgIG9yaWVudGF0aW9uOiBcImxhbmRzY2FwZVwiXHJcbiAgfSxcclxuICB7XHJcbiAgICBjb2x1bW5zOiAyLFxyXG4gICAgcm93czogMixcclxuICAgIG1pbldpZHRoOiA1NjBcclxuICB9LFxyXG4gIHtcclxuICAgIGNvbHVtbnM6IDMsXHJcbiAgICByb3dzOiAzLFxyXG4gICAgbWluV2lkdGg6IDcwMFxyXG4gIH0sXHJcbiAge1xyXG4gICAgY29sdW1uczogNCxcclxuICAgIHJvd3M6IDQsXHJcbiAgICBtaW5XaWR0aDogOTYwXHJcbiAgfSxcclxuICB7XHJcbiAgICBjb2x1bW5zOiA1LFxyXG4gICAgcm93czogNSxcclxuICAgIG1pbldpZHRoOiAxMTAwXHJcbiAgfVxyXG5dO1xyXG5mdW5jdGlvbiBZaShlLCB0LCBuLCByKSB7XHJcbiAgaWYgKGUubGVuZ3RoIDwgMSlcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBncmlkIGxheW91dCBkZWZpbml0aW9uIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xyXG4gIGNvbnN0IGkgPSBxaShlKTtcclxuICBpZiAobiA8PSAwIHx8IHIgPD0gMClcclxuICAgIHJldHVybiBpWzBdO1xyXG4gIGxldCBvID0gMDtcclxuICBjb25zdCBzID0gbiAvIHIgPiAxID8gXCJsYW5kc2NhcGVcIiA6IFwicG9ydHJhaXRcIjtcclxuICBsZXQgYSA9IGkuZmluZCgoYywgdSwgbCkgPT4ge1xyXG4gICAgbyA9IHU7XHJcbiAgICBjb25zdCBmID0gbC5maW5kSW5kZXgoKHYsIGQpID0+IHtcclxuICAgICAgY29uc3QgbSA9ICF2Lm9yaWVudGF0aW9uIHx8IHYub3JpZW50YXRpb24gPT09IHMsIHAgPSBkID4gdSwgZyA9IHYubWF4VGlsZXMgPT09IGMubWF4VGlsZXM7XHJcbiAgICAgIHJldHVybiBwICYmIGcgJiYgbTtcclxuICAgIH0pICE9PSAtMTtcclxuICAgIHJldHVybiBjLm1heFRpbGVzID49IHQgJiYgIWY7XHJcbiAgfSk7XHJcbiAgaWYgKGEgPT09IHZvaWQgMClcclxuICAgIGlmIChhID0gaVtpLmxlbmd0aCAtIDFdLCBhKVxyXG4gICAgICBfLndhcm4oXHJcbiAgICAgICAgYE5vIGxheW91dCBmb3VuZCBmb3I6IHBhcnRpY2lwYW50Q291bnQ6ICR7dH0sIHdpZHRoL2hlaWdodDogJHtufS8ke3J9IGZhbGxiYWNrIHRvIGJpZ2dlc3QgYXZhaWxhYmxlIGxheW91dCAoJHthfSkuYFxyXG4gICAgICApO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBsYXlvdXQgb3IgZmFsbGJhY2sgbGF5b3V0IGZvdW5kLlwiKTtcclxuICBpZiAoKG4gPCBhLm1pbldpZHRoIHx8IHIgPCBhLm1pbkhlaWdodCkgJiYgbyA+IDApIHtcclxuICAgIGNvbnN0IGMgPSBpW28gLSAxXTtcclxuICAgIGEgPSBZaShcclxuICAgICAgaS5zbGljZSgwLCBvKSxcclxuICAgICAgYy5tYXhUaWxlcyxcclxuICAgICAgbixcclxuICAgICAgclxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIGE7XHJcbn1cclxuZnVuY3Rpb24gcWkoZSkge1xyXG4gIHJldHVybiBbLi4uZV0ubWFwKCh0KSA9PiB7XHJcbiAgICB2YXIgbiwgcjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IGAke3QuY29sdW1uc314JHt0LnJvd3N9YCxcclxuICAgICAgY29sdW1uczogdC5jb2x1bW5zLFxyXG4gICAgICByb3dzOiB0LnJvd3MsXHJcbiAgICAgIG1heFRpbGVzOiB0LmNvbHVtbnMgKiB0LnJvd3MsXHJcbiAgICAgIG1pbldpZHRoOiAobiA9IHQubWluV2lkdGgpICE9IG51bGwgPyBuIDogMCxcclxuICAgICAgbWluSGVpZ2h0OiAociA9IHQubWluSGVpZ2h0KSAhPSBudWxsID8gciA6IDAsXHJcbiAgICAgIG9yaWVudGF0aW9uOiB0Lm9yaWVudGF0aW9uXHJcbiAgICB9O1xyXG4gIH0pLnNvcnQoKHQsIG4pID0+IHQubWF4VGlsZXMgIT09IG4ubWF4VGlsZXMgPyB0Lm1heFRpbGVzIC0gbi5tYXhUaWxlcyA6IHQubWluV2lkdGggIT09IDAgfHwgbi5taW5XaWR0aCAhPT0gMCA/IHQubWluV2lkdGggLSBuLm1pbldpZHRoIDogdC5taW5IZWlnaHQgIT09IDAgfHwgbi5taW5IZWlnaHQgIT09IDAgPyB0Lm1pbkhlaWdodCAtIG4ubWluSGVpZ2h0IDogMCk7XHJcbn1cclxuZnVuY3Rpb24gWW8oKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmICEhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWE7XHJcbn1cclxuZnVuY3Rpb24gcW8oZSwgdCkge1xyXG4gIHZhciBuO1xyXG4gIHJldHVybiBUZShYKHt9LCBlKSwge1xyXG4gICAgcmVjZWl2ZWRBdE1lZGlhVGltZXN0YW1wOiAobiA9IHQucnRwVGltZXN0YW1wKSAhPSBudWxsID8gbiA6IDAsXHJcbiAgICByZWNlaXZlZEF0OiB0LnRpbWVzdGFtcFxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEtvKGUsIHQsIG4pIHtcclxuICByZXR1cm4gWy4uLmUsIC4uLnRdLnJlZHVjZVJpZ2h0KChyLCBpKSA9PiAoci5maW5kKChvKSA9PiBvLmlkID09PSBpLmlkKSB8fCByLnVuc2hpZnQoaSksIHIpLCBbXSkuc2xpY2UoMCAtIG4pO1xyXG59XHJcbnZhciBBbiA9IFtdLCBPbiA9IHtcclxuICBzaG93Q2hhdDogITEsXHJcbiAgdW5yZWFkTWVzc2FnZXM6IDAsXHJcbiAgc2hvd1NldHRpbmdzOiAhMVxyXG59O1xyXG5mdW5jdGlvbiBLaShlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCI7XHJcbn1cclxuZnVuY3Rpb24gR28oZSkge1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGUpICYmIGUuZmlsdGVyKEtpKS5sZW5ndGggPiAwO1xyXG59XHJcbmZ1bmN0aW9uIGtuKGUsIHQpIHtcclxuICByZXR1cm4gdC5hdWRpb0xldmVsIC0gZS5hdWRpb0xldmVsO1xyXG59XHJcbmZ1bmN0aW9uIExuKGUsIHQpIHtcclxuICByZXR1cm4gZS5pc1NwZWFraW5nID09PSB0LmlzU3BlYWtpbmcgPyAwIDogZS5pc1NwZWFraW5nID8gLTEgOiAxO1xyXG59XHJcbmZ1bmN0aW9uIF9uKGUsIHQpIHtcclxuICB2YXIgbiwgciwgaSwgbztcclxuICByZXR1cm4gZS5sYXN0U3Bva2VBdCAhPT0gdm9pZCAwIHx8IHQubGFzdFNwb2tlQXQgIT09IHZvaWQgMCA/ICgociA9IChuID0gdC5sYXN0U3Bva2VBdCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uZ2V0VGltZSgpKSAhPSBudWxsID8gciA6IDApIC0gKChvID0gKGkgPSBlLmxhc3RTcG9rZUF0KSA9PSBudWxsID8gdm9pZCAwIDogaS5nZXRUaW1lKCkpICE9IG51bGwgPyBvIDogMCkgOiAwO1xyXG59XHJcbmZ1bmN0aW9uIEJlKGUsIHQpIHtcclxuICB2YXIgbiwgciwgaSwgbztcclxuICByZXR1cm4gKChyID0gKG4gPSBlLmpvaW5lZEF0KSA9PSBudWxsID8gdm9pZCAwIDogbi5nZXRUaW1lKCkpICE9IG51bGwgPyByIDogMCkgLSAoKG8gPSAoaSA9IHQuam9pbmVkQXQpID09IG51bGwgPyB2b2lkIDAgOiBpLmdldFRpbWUoKSkgIT0gbnVsbCA/IG8gOiAwKTtcclxufVxyXG5mdW5jdGlvbiBHaShlLCB0KSB7XHJcbiAgcmV0dXJuIGooZSkgPyBqKHQpID8gMCA6IC0xIDogaih0KSA/IDEgOiAwO1xyXG59XHJcbmZ1bmN0aW9uIFFpKGUsIHQpIHtcclxuICBjb25zdCBuID0gZS5wYXJ0aWNpcGFudC5pc0NhbWVyYUVuYWJsZWQsIHIgPSB0LnBhcnRpY2lwYW50LmlzQ2FtZXJhRW5hYmxlZDtcclxuICByZXR1cm4gbiAhPT0gciA/IG4gPyAtMSA6IDEgOiAwO1xyXG59XHJcbmZ1bmN0aW9uIFFvKGUpIHtcclxuICBjb25zdCB0ID0gW10sIG4gPSBbXSwgciA9IFtdLCBpID0gW107XHJcbiAgZS5mb3JFYWNoKChhKSA9PiB7XHJcbiAgICBhLnBhcnRpY2lwYW50LmlzTG9jYWwgJiYgYS5zb3VyY2UgPT09IE0uU291cmNlLkNhbWVyYSA/IHQucHVzaChhKSA6IGEuc291cmNlID09PSBNLlNvdXJjZS5TY3JlZW5TaGFyZSA/IG4ucHVzaChhKSA6IGEuc291cmNlID09PSBNLlNvdXJjZS5DYW1lcmEgPyByLnB1c2goYSkgOiBpLnB1c2goYSk7XHJcbiAgfSk7XHJcbiAgY29uc3QgbyA9IEppKG4pLCBzID0gWGkocik7XHJcbiAgcmV0dXJuIFsuLi50LCAuLi5vLCAuLi5zLCAuLi5pXTtcclxufVxyXG5mdW5jdGlvbiBKaShlKSB7XHJcbiAgY29uc3QgdCA9IFtdLCBuID0gW107XHJcbiAgcmV0dXJuIGUuZm9yRWFjaCgoaSkgPT4ge1xyXG4gICAgaS5wYXJ0aWNpcGFudC5pc0xvY2FsID8gdC5wdXNoKGkpIDogbi5wdXNoKGkpO1xyXG4gIH0pLCB0LnNvcnQoKGksIG8pID0+IEJlKGkucGFydGljaXBhbnQsIG8ucGFydGljaXBhbnQpKSwgbi5zb3J0KChpLCBvKSA9PiBCZShpLnBhcnRpY2lwYW50LCBvLnBhcnRpY2lwYW50KSksIFsuLi5uLCAuLi50XTtcclxufVxyXG5mdW5jdGlvbiBYaShlKSB7XHJcbiAgY29uc3QgdCA9IFtdLCBuID0gW107XHJcbiAgcmV0dXJuIGUuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgci5wYXJ0aWNpcGFudC5pc0xvY2FsID8gdC5wdXNoKHIpIDogbi5wdXNoKHIpO1xyXG4gIH0pLCBuLnNvcnQoKHIsIGkpID0+IHIucGFydGljaXBhbnQuaXNTcGVha2luZyAmJiBpLnBhcnRpY2lwYW50LmlzU3BlYWtpbmcgPyBrbihyLnBhcnRpY2lwYW50LCBpLnBhcnRpY2lwYW50KSA6IHIucGFydGljaXBhbnQuaXNTcGVha2luZyAhPT0gaS5wYXJ0aWNpcGFudC5pc1NwZWFraW5nID8gTG4oci5wYXJ0aWNpcGFudCwgaS5wYXJ0aWNpcGFudCkgOiByLnBhcnRpY2lwYW50Lmxhc3RTcG9rZUF0ICE9PSBpLnBhcnRpY2lwYW50Lmxhc3RTcG9rZUF0ID8gX24oci5wYXJ0aWNpcGFudCwgaS5wYXJ0aWNpcGFudCkgOiBqKHIpICE9PSBqKGkpID8gR2kociwgaSkgOiByLnBhcnRpY2lwYW50LmlzQ2FtZXJhRW5hYmxlZCAhPT0gaS5wYXJ0aWNpcGFudC5pc0NhbWVyYUVuYWJsZWQgPyBRaShyLCBpKSA6IEJlKHIucGFydGljaXBhbnQsIGkucGFydGljaXBhbnQpKSwgWy4uLnQsIC4uLm5dO1xyXG59XHJcbmZ1bmN0aW9uIEpvKGUpIHtcclxuICBjb25zdCB0ID0gWy4uLmVdO1xyXG4gIHQuc29ydCgociwgaSkgPT4ge1xyXG4gICAgaWYgKHIuaXNTcGVha2luZyAmJiBpLmlzU3BlYWtpbmcpXHJcbiAgICAgIHJldHVybiBrbihyLCBpKTtcclxuICAgIGlmIChyLmlzU3BlYWtpbmcgIT09IGkuaXNTcGVha2luZylcclxuICAgICAgcmV0dXJuIExuKHIsIGkpO1xyXG4gICAgaWYgKHIubGFzdFNwb2tlQXQgIT09IGkubGFzdFNwb2tlQXQpXHJcbiAgICAgIHJldHVybiBfbihyLCBpKTtcclxuICAgIGNvbnN0IG8gPSByLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuc2l6ZSA+IDAsIHMgPSBpLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuc2l6ZSA+IDA7XHJcbiAgICByZXR1cm4gbyAhPT0gcyA/IG8gPyAtMSA6IDEgOiBCZShyLCBpKTtcclxuICB9KTtcclxuICBjb25zdCBuID0gdC5maW5kKChyKSA9PiByLmlzTG9jYWwpO1xyXG4gIGlmIChuKSB7XHJcbiAgICBjb25zdCByID0gdC5pbmRleE9mKG4pO1xyXG4gICAgciA+PSAwICYmICh0LnNwbGljZShyLCAxKSwgdC5sZW5ndGggPiAwID8gdC5zcGxpY2UoMCwgMCwgbikgOiB0LnB1c2gobikpO1xyXG4gIH1cclxuICByZXR1cm4gdDtcclxufVxyXG5mdW5jdGlvbiBaaShlLCB0KSB7XHJcbiAgcmV0dXJuIGUucmVkdWNlKFxyXG4gICAgKG4sIHIsIGkpID0+IGkgJSB0ID09PSAwID8gWy4uLm4sIFtyXV0gOiBbLi4ubi5zbGljZSgwLCAtMSksIFsuLi5uLnNsaWNlKC0xKVswXSwgcl1dLFxyXG4gICAgW11cclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIFd0KGUsIHQpIHtcclxuICBjb25zdCBuID0gTWF0aC5tYXgoZS5sZW5ndGgsIHQubGVuZ3RoKTtcclxuICByZXR1cm4gbmV3IEFycmF5KG4pLmZpbGwoW10pLm1hcCgociwgaSkgPT4gW2VbaV0sIHRbaV1dKTtcclxufVxyXG5mdW5jdGlvbiBWZShlLCB0LCBuKSB7XHJcbiAgcmV0dXJuIGUuZmlsdGVyKChyKSA9PiAhdC5tYXAoKGkpID0+IG4oaSkpLmluY2x1ZGVzKG4ocikpKTtcclxufVxyXG5mdW5jdGlvbiB1dChlKSB7XHJcbiAgcmV0dXJuIGUubWFwKCh0KSA9PiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0ID09IFwibnVtYmVyXCIgPyBgJHt0fWAgOiBOKHQpKTtcclxufVxyXG5mdW5jdGlvbiBlbyhlLCB0KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGRyb3BwZWQ6IFZlKGUsIHQsIE4pLFxyXG4gICAgYWRkZWQ6IFZlKHQsIGUsIE4pXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiB0byhlKSB7XHJcbiAgcmV0dXJuIGUuYWRkZWQubGVuZ3RoICE9PSAwIHx8IGUuZHJvcHBlZC5sZW5ndGggIT09IDA7XHJcbn1cclxuZnVuY3Rpb24gbHQoZSwgdCkge1xyXG4gIGNvbnN0IG4gPSB0LmZpbmRJbmRleChcclxuICAgIChyKSA9PiBOKHIpID09PSBOKGUpXHJcbiAgKTtcclxuICBpZiAobiA9PT0gLTEpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBFbGVtZW50IG5vdCBwYXJ0IG9mIHRoZSBhcnJheTogJHtOKFxyXG4gICAgICAgIGVcclxuICAgICAgKX0gbm90IGluICR7dXQodCl9YFxyXG4gICAgKTtcclxuICByZXR1cm4gbjtcclxufVxyXG5mdW5jdGlvbiBubyhlLCB0LCBuKSB7XHJcbiAgY29uc3QgciA9IGx0KGUsIG4pLCBpID0gbHQodCwgbik7XHJcbiAgcmV0dXJuIG4uc3BsaWNlKHIsIDEsIHQpLCBuLnNwbGljZShpLCAxLCBlKSwgbjtcclxufVxyXG5mdW5jdGlvbiBybyhlLCB0KSB7XHJcbiAgY29uc3QgbiA9IGx0KGUsIHQpO1xyXG4gIHJldHVybiB0LnNwbGljZShuLCAxKSwgdDtcclxufVxyXG5mdW5jdGlvbiBpbyhlLCB0KSB7XHJcbiAgcmV0dXJuIFsuLi50LCBlXTtcclxufVxyXG5mdW5jdGlvbiB0dChlLCB0KSB7XHJcbiAgcmV0dXJuIFppKGUsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIFhvKGUsIHQsIG4pIHtcclxuICBsZXQgciA9IG9vKGUsIHQpO1xyXG4gIGlmIChyLmxlbmd0aCA8IHQubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzID0gVmUodCwgciwgTik7XHJcbiAgICByID0gWy4uLnIsIC4uLnNdO1xyXG4gIH1cclxuICBjb25zdCBpID0gdHQociwgbiksIG8gPSB0dCh0LCBuKTtcclxuICBpZiAoV3QoaSwgbykuZm9yRWFjaCgoW3MsIGFdLCBjKSA9PiB7XHJcbiAgICBpZiAocyAmJiBhKSB7XHJcbiAgICAgIGNvbnN0IHUgPSB0dChyLCBuKVtjXSwgbCA9IGVvKHUsIGEpO1xyXG4gICAgICB0byhsKSAmJiAoXy5kZWJ1ZyhcclxuICAgICAgICBgRGV0ZWN0ZWQgdmlzdWFsIGNoYW5nZXMgb24gcGFnZTogJHtjfSwgY3VycmVudDogJHt1dChcclxuICAgICAgICAgIHNcclxuICAgICAgICApfSwgbmV4dDogJHt1dChhKX1gLFxyXG4gICAgICAgIHsgY2hhbmdlczogbCB9XHJcbiAgICAgICksIGwuYWRkZWQubGVuZ3RoID09PSBsLmRyb3BwZWQubGVuZ3RoICYmIFd0KGwuYWRkZWQsIGwuZHJvcHBlZCkuZm9yRWFjaCgoW2YsIHZdKSA9PiB7XHJcbiAgICAgICAgaWYgKGYgJiYgdilcclxuICAgICAgICAgIHIgPSBubyhmLCB2LCByKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBGb3IgYSBzd2FwIGFjdGlvbiB3ZSBuZWVkIGEgYWRkaXRpb24gYW5kIGEgcmVtb3ZhbCBvbmUgaXMgbWlzc2luZzogJHtmfSwgJHt2fWBcclxuICAgICAgICAgICk7XHJcbiAgICAgIH0pLCBsLmFkZGVkLmxlbmd0aCA9PT0gMCAmJiBsLmRyb3BwZWQubGVuZ3RoID4gMCAmJiBsLmRyb3BwZWQuZm9yRWFjaCgoZikgPT4ge1xyXG4gICAgICAgIHIgPSBybyhmLCByKTtcclxuICAgICAgfSksIGwuYWRkZWQubGVuZ3RoID4gMCAmJiBsLmRyb3BwZWQubGVuZ3RoID09PSAwICYmIGwuYWRkZWQuZm9yRWFjaCgoZikgPT4ge1xyXG4gICAgICAgIHIgPSBpbyhmLCByKTtcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0pLCByLmxlbmd0aCA+IHQubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzID0gVmUociwgdCwgTik7XHJcbiAgICByID0gci5maWx0ZXIoXHJcbiAgICAgIChhKSA9PiAhcy5tYXAoTikuaW5jbHVkZXMoTihhKSlcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiByO1xyXG59XHJcbmZ1bmN0aW9uIG9vKGUsIHQpIHtcclxuICByZXR1cm4gZS5tYXAoKG4pID0+IHtcclxuICAgIGNvbnN0IHIgPSB0LmZpbmQoXHJcbiAgICAgIChpKSA9PiAoXHJcbiAgICAgICAgLy8gSWYgdGhlIElEcyBtYXRjaCBvciAuLlxyXG4gICAgICAgIE4obikgPT09IE4oaSkgfHwgLy8gLi4uIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBwbGFjZWhvbGRlciBhbmQgdGhlIG5ldyBpdGVtIGlzIHRoZSB0cmFjayByZWZlcmVuY2UgY2FuIHJlcGxhY2UgaXQuXHJcbiAgICAgICAgdHlwZW9mIG4gIT0gXCJudW1iZXJcIiAmJiBQZShuKSAmJiBqKGkpICYmIGppKG4sIGkpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgICByZXR1cm4gciA/PyBuO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEYoZSkge1xyXG4gIHJldHVybiBgJHtFbn0tJHtlfWA7XHJcbn1cclxuZnVuY3Rpb24gWm8oZSkge1xyXG4gIGNvbnN0IHQgPSBCdChlKSwgbiA9IEluKGUucGFydGljaXBhbnQpLnBpcGUoXHJcbiAgICBPKCgpID0+IEJ0KGUpKSxcclxuICAgIEQodClcclxuICApO1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogRihcclxuICAgIGUuc291cmNlID09PSBNLlNvdXJjZS5DYW1lcmEgfHwgZS5zb3VyY2UgPT09IE0uU291cmNlLlNjcmVlblNoYXJlID8gXCJwYXJ0aWNpcGFudC1tZWRpYS12aWRlb1wiIDogXCJwYXJ0aWNpcGFudC1tZWRpYS1hdWRpb1wiXHJcbiAgKSwgdHJhY2tPYnNlcnZlcjogbiB9O1xyXG59XHJcbmZ1bmN0aW9uIEJ0KGUpIHtcclxuICBpZiAoaihlKSlcclxuICAgIHJldHVybiBlLnB1YmxpY2F0aW9uO1xyXG4gIHtcclxuICAgIGNvbnN0IHsgc291cmNlOiB0LCBuYW1lOiBuLCBwYXJ0aWNpcGFudDogciB9ID0gZTtcclxuICAgIGlmICh0ICYmIG4pXHJcbiAgICAgIHJldHVybiByLmdldFRyYWNrUHVibGljYXRpb25zKCkuZmluZCgoaSkgPT4gaS5zb3VyY2UgPT09IHQgJiYgaS50cmFja05hbWUgPT09IG4pO1xyXG4gICAgaWYgKG4pXHJcbiAgICAgIHJldHVybiByLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobik7XHJcbiAgICBpZiAodClcclxuICAgICAgcmV0dXJuIHIuZ2V0VHJhY2tQdWJsaWNhdGlvbih0KTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBvZiBzb3VyY2UgYW5kIG5hbWUgbmVlZHMgdG8gYmUgZGVmaW5lZFwiKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gbGUoZSwgLi4udCkge1xyXG4gIHJldHVybiBuZXcgaygocikgPT4ge1xyXG4gICAgY29uc3QgaSA9ICgpID0+IHtcclxuICAgICAgci5uZXh0KGUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiB0LmZvckVhY2goKHMpID0+IHtcclxuICAgICAgZS5vbihzLCBpKTtcclxuICAgIH0pLCAoKSA9PiB7XHJcbiAgICAgIHQuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICAgIGUub2ZmKHMsIGkpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSkucGlwZShEKGUpKTtcclxufVxyXG5mdW5jdGlvbiB5ZShlLCB0KSB7XHJcbiAgcmV0dXJuIG5ldyBrKChyKSA9PiB7XHJcbiAgICBjb25zdCBpID0gKC4uLnMpID0+IHtcclxuICAgICAgci5uZXh0KHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBlLm9uKHQsIGkpLCAoKSA9PiB7XHJcbiAgICAgIGUub2ZmKHQsIGkpO1xyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBlcyhlKSB7XHJcbiAgcmV0dXJuIHllKGUsIHkuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCkucGlwZShcclxuICAgIE8oKFt0XSkgPT4gdCksXHJcbiAgICBEKGUuc3RhdGUpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiB0cyhlKSB7XHJcbiAgcmV0dXJuIGxlKFxyXG4gICAgZSxcclxuICAgIHkuUm9vbU1ldGFkYXRhQ2hhbmdlZCxcclxuICAgIHkuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxyXG4gICkucGlwZShcclxuICAgIE8oKG4pID0+ICh7IG5hbWU6IG4ubmFtZSwgbWV0YWRhdGE6IG4ubWV0YWRhdGEgfSkpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBucyhlKSB7XHJcbiAgcmV0dXJuIHllKGUsIHkuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkKS5waXBlKFxyXG4gICAgTygoW3RdKSA9PiB0KVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gcnMoZSwgdCwgbiA9ICEwKSB7XHJcbiAgY29uc3QgciA9IG5ldyBrKChvKSA9PiB7XHJcbiAgICBUdC5nZXRMb2NhbERldmljZXMoZSwgbikudGhlbigocykgPT4ge1xyXG4gICAgICBvLm5leHQocyksIG8uY29tcGxldGUoKTtcclxuICAgIH0pLmNhdGNoKChzKSA9PiB7XHJcbiAgICAgIHQgPT0gbnVsbCB8fCB0KHMpLCBvLm5leHQoW10pLCBvLmNvbXBsZXRlKCk7XHJcbiAgICB9KTtcclxuICB9KSwgaSA9IG5ldyBrKChvKSA9PiB7XHJcbiAgICB2YXIgcztcclxuICAgIGNvbnN0IGEgPSAoKSA9PiBWKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYyA9IHlpZWxkIFR0LmdldExvY2FsRGV2aWNlcyhlLCBuKTtcclxuICAgICAgICBvLm5leHQoYyk7XHJcbiAgICAgIH0gY2F0Y2ggKGMpIHtcclxuICAgICAgICB0ID09IG51bGwgfHwgdChjKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA8IFwidVwiKSB7XHJcbiAgICAgIGlmICghd2luZG93LmlzU2VjdXJlQ29udGV4dClcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBcIkFjY2Vzc2luZyBtZWRpYSBkZXZpY2VzIGlzIGF2YWlsYWJsZSBvbmx5IGluIHNlY3VyZSBjb250ZXh0cyAoSFRUUFMgYW5kIGxvY2FsaG9zdCksIGluIHNvbWUgb3IgYWxsIHN1cHBvcnRpbmcgYnJvd3NlcnMuIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05hdmlnYXRvci9tZWRpYURldmljZXNcIlxyXG4gICAgICAgICk7XHJcbiAgICAgIChzID0gbmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PSBudWxsIHx8IHMuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZWNoYW5nZVwiLCBhKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHZhciBjO1xyXG4gICAgICAoYyA9IG5hdmlnYXRvciA9PSBudWxsID8gdm9pZCAwIDogbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT0gbnVsbCB8fCBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VjaGFuZ2VcIiwgYSk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG4gIHJldHVybiBXZShyLCBpKTtcclxufVxyXG5mdW5jdGlvbiBzbyhlKSB7XHJcbiAgcmV0dXJuIHllKGUsIHkuRGF0YVJlY2VpdmVkKTtcclxufVxyXG5mdW5jdGlvbiBhbyhlKSB7XHJcbiAgcmV0dXJuIGxlKGUsIHkuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQpLnBpcGUoXHJcbiAgICBPKChuKSA9PiAoeyBjYW5QbGF5QXVkaW86IG4uY2FuUGxheWJhY2tBdWRpbyB9KSlcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIGNvKGUpIHtcclxuICByZXR1cm4gbGUoZSwgeS5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCkucGlwZShcclxuICAgIE8oKG4pID0+ICh7IGNhblBsYXlWaWRlbzogbi5jYW5QbGF5YmFja1ZpZGVvIH0pKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gdW8oZSwgdCkge1xyXG4gIHJldHVybiB5ZShlLCB5LkFjdGl2ZURldmljZUNoYW5nZWQpLnBpcGUoXHJcbiAgICBRZSgoW25dKSA9PiBuID09PSB0KSxcclxuICAgIE8oKFtuLCByXSkgPT4gKF8uZGVidWcoXCJhY3RpdmVEZXZpY2VPYnNlcnZhYmxlIHwgUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWRcIiwgeyBraW5kOiBuLCBkZXZpY2VJZDogciB9KSwgcikpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBpcyhlLCB0KSB7XHJcbiAgcmV0dXJuIHllKGUsIHkuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCkucGlwZShcclxuICAgIFFlKFxyXG4gICAgICAoWywgbl0pID0+ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlkZW50aXR5KSA9PT0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaWRlbnRpdHkpIHx8ICFuICYmICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlkZW50aXR5KSA9PT0gZS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XHJcbiAgICApLFxyXG4gICAgTygoW25dKSA9PiBuKSxcclxuICAgIEQoXHJcbiAgICAgIHQgIT0gbnVsbCAmJiB0LmlzTG9jYWwgPyB0LmlzRTJFRUVuYWJsZWQgOiAhISh0ICE9IG51bGwgJiYgdC5pc0VuY3J5cHRlZClcclxuICAgIClcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIG9zKGUpIHtcclxuICByZXR1cm4geWUoZSwgeS5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkKS5waXBlKFxyXG4gICAgTygoW3RdKSA9PiB0KSxcclxuICAgIEQoZS5pc1JlY29yZGluZylcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIHdlKGUsIC4uLnQpIHtcclxuICByZXR1cm4gbmV3IGsoKHIpID0+IHtcclxuICAgIGNvbnN0IGkgPSAoKSA9PiB7XHJcbiAgICAgIHIubmV4dChlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gdC5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIGUub24ocywgaSk7XHJcbiAgICB9KSwgKCkgPT4ge1xyXG4gICAgICB0LmZvckVhY2goKHMpID0+IHtcclxuICAgICAgICBlLm9mZihzLCBpKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0pLnBpcGUoRChlKSk7XHJcbn1cclxuZnVuY3Rpb24gSW4oZSkge1xyXG4gIHJldHVybiB3ZShcclxuICAgIGUsXHJcbiAgICB3LlRyYWNrTXV0ZWQsXHJcbiAgICB3LlRyYWNrVW5tdXRlZCxcclxuICAgIHcuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXHJcbiAgICAvLyBQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLFxyXG4gICAgdy5UcmFja1B1Ymxpc2hlZCxcclxuICAgIHcuVHJhY2tVbnB1Ymxpc2hlZCxcclxuICAgIHcuTG9jYWxUcmFja1B1Ymxpc2hlZCxcclxuICAgIHcuTG9jYWxUcmFja1VucHVibGlzaGVkLFxyXG4gICAgdy5NZWRpYURldmljZXNFcnJvcixcclxuICAgIHcuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXHJcbiAgICAvLyBQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcclxuICApLnBpcGUoXHJcbiAgICBPKChuKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgaXNNaWNyb3Bob25lRW5hYmxlZDogciwgaXNDYW1lcmFFbmFibGVkOiBpLCBpc1NjcmVlblNoYXJlRW5hYmxlZDogbyB9ID0gbiwgcyA9IG4uZ2V0VHJhY2tQdWJsaWNhdGlvbihNLlNvdXJjZS5NaWNyb3Bob25lKSwgYSA9IG4uZ2V0VHJhY2tQdWJsaWNhdGlvbihNLlNvdXJjZS5DYW1lcmEpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQ2FtZXJhRW5hYmxlZDogaSxcclxuICAgICAgICBpc01pY3JvcGhvbmVFbmFibGVkOiByLFxyXG4gICAgICAgIGlzU2NyZWVuU2hhcmVFbmFibGVkOiBvLFxyXG4gICAgICAgIGNhbWVyYVRyYWNrOiBhLFxyXG4gICAgICAgIG1pY3JvcGhvbmVUcmFjazogcyxcclxuICAgICAgICBwYXJ0aWNpcGFudDogblxyXG4gICAgICB9O1xyXG4gICAgfSlcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIGxvKGUpIHtcclxuICByZXR1cm4gZSA/IHdlKFxyXG4gICAgZSxcclxuICAgIHcuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsXHJcbiAgICB3LlBhcnRpY2lwYW50TmFtZUNoYW5nZWRcclxuICApLnBpcGUoXHJcbiAgICBPKCh7IG5hbWU6IG4sIGlkZW50aXR5OiByLCBtZXRhZGF0YTogaSB9KSA9PiAoe1xyXG4gICAgICBuYW1lOiBuLFxyXG4gICAgICBpZGVudGl0eTogcixcclxuICAgICAgbWV0YWRhdGE6IGlcclxuICAgIH0pKSxcclxuICAgIEQoe1xyXG4gICAgICBuYW1lOiBlLm5hbWUsXHJcbiAgICAgIGlkZW50aXR5OiBlLmlkZW50aXR5LFxyXG4gICAgICBtZXRhZGF0YTogZS5tZXRhZGF0YVxyXG4gICAgfSlcclxuICApIDogdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIGZvKGUpIHtcclxuICByZXR1cm4gSmUoXHJcbiAgICBlLFxyXG4gICAgdy5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcclxuICApLnBpcGUoXHJcbiAgICBPKChbbl0pID0+IG4pLFxyXG4gICAgRChlLmNvbm5lY3Rpb25RdWFsaXR5KVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gSmUoZSwgdCkge1xyXG4gIHJldHVybiBuZXcgaygocikgPT4ge1xyXG4gICAgY29uc3QgaSA9ICguLi5zKSA9PiB7XHJcbiAgICAgIHIubmV4dChzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZS5vbih0LCBpKSwgKCkgPT4ge1xyXG4gICAgICBlLm9mZih0LCBpKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcG8oZSkge1xyXG4gIHZhciB0LCBuLCByLCBpO1xyXG4gIHJldHVybiB3ZShcclxuICAgIGUucGFydGljaXBhbnQsXHJcbiAgICB3LlRyYWNrTXV0ZWQsXHJcbiAgICB3LlRyYWNrVW5tdXRlZCxcclxuICAgIHcuVHJhY2tTdWJzY3JpYmVkLFxyXG4gICAgdy5UcmFja1Vuc3Vic2NyaWJlZCxcclxuICAgIHcuTG9jYWxUcmFja1B1Ymxpc2hlZCxcclxuICAgIHcuTG9jYWxUcmFja1VucHVibGlzaGVkXHJcbiAgKS5waXBlKFxyXG4gICAgTygobykgPT4ge1xyXG4gICAgICB2YXIgcywgYTtcclxuICAgICAgY29uc3QgYyA9IChzID0gZS5wdWJsaWNhdGlvbikgIT0gbnVsbCA/IHMgOiBvLmdldFRyYWNrUHVibGljYXRpb24oZS5zb3VyY2UpO1xyXG4gICAgICByZXR1cm4gKGEgPSBjID09IG51bGwgPyB2b2lkIDAgOiBjLmlzTXV0ZWQpICE9IG51bGwgPyBhIDogITA7XHJcbiAgICB9KSxcclxuICAgIEQoXHJcbiAgICAgIChpID0gKHIgPSAodCA9IGUucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiB0LmlzTXV0ZWQpICE9IG51bGwgPyByIDogKG4gPSBlLnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24oZS5zb3VyY2UpKSA9PSBudWxsID8gdm9pZCAwIDogbi5pc011dGVkKSAhPSBudWxsID8gaSA6ICEwXHJcbiAgICApXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBzcyhlKSB7XHJcbiAgcmV0dXJuIEplKGUsIHcuSXNTcGVha2luZ0NoYW5nZWQpLnBpcGUoXHJcbiAgICBPKChbdF0pID0+IHQpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBhcyhlLCB0ID0ge30pIHtcclxuICB2YXIgbjtcclxuICBsZXQgcjtcclxuICBjb25zdCBpID0gbmV3IGsoKGMpID0+IChyID0gYywgKCkgPT4gYS51bnN1YnNjcmliZSgpKSkucGlwZShEKEFycmF5LmZyb20oZS5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpKSksIG8gPSAobiA9IHQuYWRkaXRpb25hbFJvb21FdmVudHMpICE9IG51bGwgPyBuIDogQ24sIHMgPSBBcnJheS5mcm9tKFxyXG4gICAgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xyXG4gICAgICB5LlBhcnRpY2lwYW50Q29ubmVjdGVkLFxyXG4gICAgICB5LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLFxyXG4gICAgICB5LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsXHJcbiAgICAgIC4uLm9cclxuICAgIF0pXHJcbiAgKSwgYSA9IGxlKGUsIC4uLnMpLnN1YnNjcmliZShcclxuICAgIChjKSA9PiByID09IG51bGwgPyB2b2lkIDAgOiByLm5leHQoQXJyYXkuZnJvbShjLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkpXHJcbiAgKTtcclxuICByZXR1cm4gZS5yZW1vdGVQYXJ0aWNpcGFudHMuc2l6ZSA+IDAgJiYgKHIgPT0gbnVsbCB8fCByLm5leHQoQXJyYXkuZnJvbShlLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkpKSwgaTtcclxufVxyXG5mdW5jdGlvbiBjcyhlLCB0LCBuID0ge30pIHtcclxuICB2YXIgcjtcclxuICBjb25zdCBpID0gKHIgPSBuLmFkZGl0aW9uYWxFdmVudHMpICE9IG51bGwgPyByIDogUG47XHJcbiAgcmV0dXJuIGxlKFxyXG4gICAgZSxcclxuICAgIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXHJcbiAgICB5LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLFxyXG4gICAgeS5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXHJcbiAgKS5waXBlKFxyXG4gICAgVG4oKHMpID0+IHtcclxuICAgICAgY29uc3QgYSA9IHMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHQpO1xyXG4gICAgICByZXR1cm4gYSA/IHdlKGEsIC4uLmkpIDogbmV3IGsoKGMpID0+IGMubmV4dCh2b2lkIDApKTtcclxuICAgIH0pLFxyXG4gICAgRChlLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eSh0KSlcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIHVzKGUpIHtcclxuICByZXR1cm4gSmUoXHJcbiAgICBlLFxyXG4gICAgdy5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFxyXG4gICkucGlwZShcclxuICAgIE8oKCkgPT4gZS5wZXJtaXNzaW9ucyksXHJcbiAgICBEKGUucGVybWlzc2lvbnMpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBscyhlLCB7IGtpbmQ6IHQsIGlkZW50aXR5OiBuIH0sIHIgPSB7fSkge1xyXG4gIHZhciBpO1xyXG4gIGNvbnN0IG8gPSAoaSA9IHIuYWRkaXRpb25hbEV2ZW50cykgIT0gbnVsbCA/IGkgOiBQbiwgcyA9IChjKSA9PiB7XHJcbiAgICBsZXQgdSA9ICEwO1xyXG4gICAgcmV0dXJuIHQgJiYgKHUgPSB1ICYmIGMua2luZCA9PT0gdCksIG4gJiYgKHUgPSB1ICYmIGMuaWRlbnRpdHkgPT09IG4pLCB1O1xyXG4gIH07XHJcbiAgcmV0dXJuIGxlKFxyXG4gICAgZSxcclxuICAgIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXHJcbiAgICB5LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLFxyXG4gICAgeS5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXHJcbiAgKS5waXBlKFxyXG4gICAgVG4oKGMpID0+IHtcclxuICAgICAgY29uc3QgdSA9IEFycmF5LmZyb20oYy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQoXHJcbiAgICAgICAgKGwpID0+IHMobClcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIHUgPyB3ZSh1LCAuLi5vKSA6IG5ldyBrKChsKSA9PiBsLm5leHQodm9pZCAwKSk7XHJcbiAgICB9KSxcclxuICAgIEQoQXJyYXkuZnJvbShlLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZCgoYykgPT4gcyhjKSkpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBmcyhlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBlID4gXCJ1XCIgPyBuZXcgaygpIDogSmUoZSwgdy5BdHRyaWJ1dGVzQ2hhbmdlZCkucGlwZShcclxuICAgIE8oKFt0XSkgPT4gKHtcclxuICAgICAgY2hhbmdlZDogdCxcclxuICAgICAgYXR0cmlidXRlczogZS5hdHRyaWJ1dGVzXHJcbiAgICB9KSksXHJcbiAgICBEKHsgY2hhbmdlZDogZS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzOiBlLmF0dHJpYnV0ZXMgfSlcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIGRzKGUsIHQsIG4sIHIsIGkpIHtcclxuICBjb25zdCB7IGxvY2FsUGFydGljaXBhbnQ6IG8gfSA9IHQsIHMgPSAoZiwgdikgPT4ge1xyXG4gICAgbGV0IGQgPSAhMTtcclxuICAgIHN3aXRjaCAoZikge1xyXG4gICAgICBjYXNlIE0uU291cmNlLkNhbWVyYTpcclxuICAgICAgICBkID0gdi5pc0NhbWVyYUVuYWJsZWQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgTS5Tb3VyY2UuTWljcm9waG9uZTpcclxuICAgICAgICBkID0gdi5pc01pY3JvcGhvbmVFbmFibGVkO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIE0uU291cmNlLlNjcmVlblNoYXJlOlxyXG4gICAgICAgIGQgPSB2LmlzU2NyZWVuU2hhcmVFbmFibGVkO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGQ7XHJcbiAgfSwgYSA9IEluKG8pLnBpcGUoXHJcbiAgICBPKChmKSA9PiBzKGUsIGYucGFydGljaXBhbnQpKSxcclxuICAgIEQocyhlLCBvKSlcclxuICApLCBjID0gbmV3IFooKSwgdSA9IChmLCB2KSA9PiBWKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzd2l0Y2ggKHYgPz8gKHYgPSBuKSwgYy5uZXh0KCEwKSwgZSkge1xyXG4gICAgICAgIGNhc2UgTS5Tb3VyY2UuQ2FtZXJhOlxyXG4gICAgICAgICAgcmV0dXJuIHlpZWxkIG8uc2V0Q2FtZXJhRW5hYmxlZChcclxuICAgICAgICAgICAgZiA/PyAhby5pc0NhbWVyYUVuYWJsZWQsXHJcbiAgICAgICAgICAgIHYsXHJcbiAgICAgICAgICAgIHJcclxuICAgICAgICAgICksIG8uaXNDYW1lcmFFbmFibGVkO1xyXG4gICAgICAgIGNhc2UgTS5Tb3VyY2UuTWljcm9waG9uZTpcclxuICAgICAgICAgIHJldHVybiB5aWVsZCBvLnNldE1pY3JvcGhvbmVFbmFibGVkKFxyXG4gICAgICAgICAgICBmID8/ICFvLmlzTWljcm9waG9uZUVuYWJsZWQsXHJcbiAgICAgICAgICAgIHYsXHJcbiAgICAgICAgICAgIHJcclxuICAgICAgICAgICksIG8uaXNNaWNyb3Bob25lRW5hYmxlZDtcclxuICAgICAgICBjYXNlIE0uU291cmNlLlNjcmVlblNoYXJlOlxyXG4gICAgICAgICAgcmV0dXJuIHlpZWxkIG8uc2V0U2NyZWVuU2hhcmVFbmFibGVkKFxyXG4gICAgICAgICAgICBmID8/ICFvLmlzU2NyZWVuU2hhcmVFbmFibGVkLFxyXG4gICAgICAgICAgICB2LFxyXG4gICAgICAgICAgICByXHJcbiAgICAgICAgICApLCBvLmlzU2NyZWVuU2hhcmVFbmFibGVkO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHJpZWQgdG8gdG9nZ2xlIHVuc3VwcG9ydGVkIHNvdXJjZVwiKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZCkge1xyXG4gICAgICBpZiAoaSAmJiBkIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICBpID09IG51bGwgfHwgaShkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHRocm93IGQ7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBjLm5leHQoITEpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB7XHJcbiAgICBjbGFzc05hbWU6IEYoXCJidXR0b25cIiksXHJcbiAgICB0b2dnbGU6IHUsXHJcbiAgICBlbmFibGVkT2JzZXJ2ZXI6IGEsXHJcbiAgICBwZW5kaW5nT2JzZXJ2ZXI6IGMuYXNPYnNlcnZhYmxlKClcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBzKCkge1xyXG4gIGxldCBlID0gITE7XHJcbiAgY29uc3QgdCA9IG5ldyBaKCksIG4gPSBuZXcgWigpLCByID0gKG8pID0+IFYodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcclxuICAgIG4ubmV4dCghMCksIGUgPSBvID8/ICFlLCB0Lm5leHQoZSksIG4ubmV4dCghMSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNsYXNzTmFtZTogRihcImJ1dHRvblwiKSxcclxuICAgIHRvZ2dsZTogcixcclxuICAgIGVuYWJsZWRPYnNlcnZlcjogdC5hc09ic2VydmFibGUoKSxcclxuICAgIHBlbmRpbmdPYnNlcnZlcjogbi5hc09ic2VydmFibGUoKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaHMoZSwgdCwgbikge1xyXG4gIGNvbnN0IHIgPSBuZXcgbG4odm9pZCAwKSwgaSA9IHVvKHQsIGUpLCBvID0gKGEsIC4uLmMpID0+IFYodGhpcywgW2EsIC4uLmNdLCBmdW5jdGlvbiogKHUsIGwgPSB7fSkge1xyXG4gICAgdmFyIGYsIHYsIGQ7XHJcbiAgICBpZiAodCkge1xyXG4gICAgICBfLmRlYnVnKGBTd2l0Y2hpbmcgYWN0aXZlIGRldmljZSBvZiBraW5kIFwiJHtlfVwiIHdpdGggaWQgJHt1fS5gKSwgeWllbGQgdC5zd2l0Y2hBY3RpdmVEZXZpY2UoZSwgdSwgbC5leGFjdCk7XHJcbiAgICAgIGNvbnN0IG0gPSAoZiA9IHQuZ2V0QWN0aXZlRGV2aWNlKGUpKSAhPSBudWxsID8gZiA6IHU7XHJcbiAgICAgIG0gIT09IHUgJiYgdSAhPT0gXCJkZWZhdWx0XCIgJiYgXy5pbmZvKFxyXG4gICAgICAgIGBXZSB0cmllZCB0byBzZWxlY3QgdGhlIGRldmljZSB3aXRoIGlkICgke3V9KSwgYnV0IHRoZSBicm93c2VyIGRlY2lkZWQgdG8gc2VsZWN0IHRoZSBkZXZpY2Ugd2l0aCBpZCAoJHttfSkgaW5zdGVhZC5gXHJcbiAgICAgICk7XHJcbiAgICAgIGxldCBwO1xyXG4gICAgICBlID09PSBcImF1ZGlvaW5wdXRcIiA/IHAgPSAodiA9IHQubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uKE0uU291cmNlLk1pY3JvcGhvbmUpKSA9PSBudWxsID8gdm9pZCAwIDogdi50cmFjayA6IGUgPT09IFwidmlkZW9pbnB1dFwiICYmIChwID0gKGQgPSB0LmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbihNLlNvdXJjZS5DYW1lcmEpKSA9PSBudWxsID8gdm9pZCAwIDogZC50cmFjayk7XHJcbiAgICAgIGNvbnN0IGcgPSB1ID09PSBcImRlZmF1bHRcIiAmJiAhcCB8fCB1ID09PSBcImRlZmF1bHRcIiAmJiAocCA9PSBudWxsID8gdm9pZCAwIDogcC5tZWRpYVN0cmVhbVRyYWNrLmxhYmVsLnN0YXJ0c1dpdGgoXCJEZWZhdWx0XCIpKTtcclxuICAgICAgci5uZXh0KGcgPyB1IDogbSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNsYXNzTmFtZTogRihcIm1lZGlhLWRldmljZS1zZWxlY3RcIiksXHJcbiAgICBhY3RpdmVEZXZpY2VPYnNlcnZhYmxlOiBpLFxyXG4gICAgc2V0QWN0aXZlTWVkaWFEZXZpY2U6IG9cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZzKGUpIHtcclxuICBjb25zdCB0ID0gKHIpID0+IHtcclxuICAgIGUuZGlzY29ubmVjdChyKTtcclxuICB9O1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogRihcImRpc2Nvbm5lY3QtYnV0dG9uXCIpLCBkaXNjb25uZWN0OiB0IH07XHJcbn1cclxuZnVuY3Rpb24gbXMoZSkge1xyXG4gIGNvbnN0IHQgPSBGKFwiY29ubmVjdGlvbi1xdWFsaXR5XCIpLCBuID0gZm8oZSk7XHJcbiAgcmV0dXJuIHsgY2xhc3NOYW1lOiB0LCBjb25uZWN0aW9uUXVhbGl0eU9ic2VydmVyOiBuIH07XHJcbn1cclxuZnVuY3Rpb24gZ3MoZSkge1xyXG4gIGxldCB0ID0gXCJ0cmFjay1tdXRlZC1pbmRpY2F0b3ItY2FtZXJhXCI7XHJcbiAgc3dpdGNoIChlLnNvdXJjZSkge1xyXG4gICAgY2FzZSBNLlNvdXJjZS5DYW1lcmE6XHJcbiAgICAgIHQgPSBcInRyYWNrLW11dGVkLWluZGljYXRvci1jYW1lcmFcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIE0uU291cmNlLk1pY3JvcGhvbmU6XHJcbiAgICAgIHQgPSBcInRyYWNrLW11dGVkLWluZGljYXRvci1taWNyb3Bob25lXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICBjb25zdCBuID0gRih0KSwgciA9IHBvKGUpO1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogbiwgbWVkaWFNdXRlZE9ic2VydmVyOiByIH07XHJcbn1cclxuZnVuY3Rpb24gYnMoZSkge1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogXCJsay1wYXJ0aWNpcGFudC1uYW1lXCIsIGluZm9PYnNlcnZlcjogbG8oZSkgfTtcclxufVxyXG5mdW5jdGlvbiB5cygpIHtcclxuICByZXR1cm4ge1xyXG4gICAgY2xhc3NOYW1lOiBGKFwicGFydGljaXBhbnQtdGlsZVwiKVxyXG4gIH07XHJcbn1cclxudmFyIGhvID0ge1xyXG4gIENIQVQ6IFwibGsuY2hhdFwiLFxyXG4gIFRSQU5TQ1JJUFRJT046IFwibGsudHJhbnNjcmlwdGlvblwiXHJcbn0sIHZvID0ge1xyXG4gIENIQVQ6IFwibGstY2hhdC10b3BpY1wiXHJcbn07XHJcbmZ1bmN0aW9uIFJuKGUsIHQpIHtcclxuICByZXR1cm4gVih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAobiwgciwgaSA9IHt9KSB7XHJcbiAgICBjb25zdCB7IHJlbGlhYmxlOiBvLCBkZXN0aW5hdGlvbklkZW50aXRpZXM6IHMsIHRvcGljOiBhIH0gPSBpO1xyXG4gICAgeWllbGQgbi5wdWJsaXNoRGF0YShyLCB7XHJcbiAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogcyxcclxuICAgICAgdG9waWM6IGEsXHJcbiAgICAgIHJlbGlhYmxlOiBvXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBtbyhlLCB0LCBuKSB7XHJcbiAgY29uc3QgciA9IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW3RdLCBpID0gc28oZSkucGlwZShcclxuICAgIFFlKFxyXG4gICAgICAoWywgLCAsIGNdKSA9PiB0ID09PSB2b2lkIDAgfHwgYyAhPT0gdm9pZCAwICYmIHIuaW5jbHVkZXMoYylcclxuICAgICksXHJcbiAgICBPKChbYywgdSwgLCBsXSkgPT4ge1xyXG4gICAgICBjb25zdCBmID0ge1xyXG4gICAgICAgIHBheWxvYWQ6IGMsXHJcbiAgICAgICAgdG9waWM6IGwsXHJcbiAgICAgICAgZnJvbTogdVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbiA9PSBudWxsIHx8IG4oZiksIGY7XHJcbiAgICB9KVxyXG4gICk7XHJcbiAgbGV0IG87XHJcbiAgY29uc3QgcyA9IG5ldyBrKChjKSA9PiB7XHJcbiAgICBvID0gYztcclxuICB9KTtcclxuICByZXR1cm4geyBtZXNzYWdlT2JzZXJ2YWJsZTogaSwgaXNTZW5kaW5nT2JzZXJ2YWJsZTogcywgc2VuZDogKGMsIC4uLnUpID0+IFYodGhpcywgW2MsIC4uLnVdLCBmdW5jdGlvbiogKGwsIGYgPSB7fSkge1xyXG4gICAgby5uZXh0KCEwKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHlpZWxkIFJuKGUubG9jYWxQYXJ0aWNpcGFudCwgbCwgWCh7IHRvcGljOiByWzBdIH0sIGYpKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIG8ubmV4dCghMSk7XHJcbiAgICB9XHJcbiAgfSkgfTtcclxufVxyXG52YXIgSWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gZ28oZSkge1xyXG4gIHJldHVybiBlLmlnbm9yZUxlZ2FjeSA9PSAhMDtcclxufVxyXG52YXIgYm8gPSAoZSkgPT4gSlNPTi5wYXJzZShuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZSkpLCB5byA9IChlKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoZSkpO1xyXG5mdW5jdGlvbiB3cyhlLCB0KSB7XHJcbiAgdmFyIG4sIHIsIGksIG8sIHMsIGE7XHJcbiAgY29uc3QgYyA9ICgpID0+IHtcclxuICAgIHZhciBiLCBTLCBDO1xyXG4gICAgcmV0dXJuICgoYiA9IGUuc2VydmVySW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IGIuZWRpdGlvbikgPT09IDEgfHwgISEoKFMgPSBlLnNlcnZlckluZm8pICE9IG51bGwgJiYgUy52ZXJzaW9uKSAmJiB6bigoQyA9IGUuc2VydmVySW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IEMudmVyc2lvbiwgXCIxLjguMlwiKSA+IDA7XHJcbiAgfSwgdSA9IG5ldyBaKCksIGwgPSAobiA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY2hhbm5lbFRvcGljKSAhPSBudWxsID8gbiA6IGhvLkNIQVQsIGYgPSAociA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY2hhbm5lbFRvcGljKSAhPSBudWxsID8gciA6IHZvLkNIQVQ7XHJcbiAgbGV0IHYgPSAhMTtcclxuICBJZS5oYXMoZSkgfHwgKHYgPSAhMCk7XHJcbiAgY29uc3QgZCA9IChpID0gSWUuZ2V0KGUpKSAhPSBudWxsID8gaSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIG0gPSAobyA9IGQuZ2V0KGwpKSAhPSBudWxsID8gbyA6IG5ldyBaKCk7XHJcbiAgZC5zZXQobCwgbSksIEllLnNldChlLCBkKTtcclxuICBjb25zdCBwID0gKHMgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1lc3NhZ2VEZWNvZGVyKSAhPSBudWxsID8gcyA6IGJvO1xyXG4gIGlmICh2KSB7XHJcbiAgICBlLnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIobCwgKFMsIEMpID0+IFYodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgeyBpZDogJCwgdGltZXN0YW1wOiBJIH0gPSBTLmluZm87XHJcbiAgICAgIEdlKFMpLnBpcGUoXHJcbiAgICAgICAgY3QoKFQsIEwpID0+IFQgKyBMKSxcclxuICAgICAgICBPKChUKSA9PiAoe1xyXG4gICAgICAgICAgaWQ6ICQsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IEksXHJcbiAgICAgICAgICBtZXNzYWdlOiBULFxyXG4gICAgICAgICAgZnJvbTogZS5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkoQy5pZGVudGl0eSlcclxuICAgICAgICAgIC8vIGVkaXRUaW1lc3RhbXA6IHR5cGUgPT09ICd1cGRhdGUnID8gdGltZXN0YW1wIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH0pKVxyXG4gICAgICApLnN1YnNjcmliZSh7XHJcbiAgICAgICAgbmV4dDogKFQpID0+IG0ubmV4dChUKVxyXG4gICAgICB9KTtcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHsgbWVzc2FnZU9ic2VydmFibGU6IGIgfSA9IG1vKGUsIFtmXSk7XHJcbiAgICBiLnBpcGUoXHJcbiAgICAgIE8oKFMpID0+IHtcclxuICAgICAgICBjb25zdCBDID0gcChTLnBheWxvYWQpO1xyXG4gICAgICAgIHJldHVybiBnbyhDKSA/IHZvaWQgMCA6IFRlKFgoe30sIEMpLCB7IGZyb206IFMuZnJvbSB9KTtcclxuICAgICAgfSksXHJcbiAgICAgIFFlKChTKSA9PiAhIVMpLFxyXG4gICAgICBOdCh1KVxyXG4gICAgKS5zdWJzY3JpYmUobSk7XHJcbiAgfVxyXG4gIGNvbnN0IGcgPSBtLnBpcGUoXHJcbiAgICBjdCgoYiwgUykgPT4ge1xyXG4gICAgICBpZiAoXCJpZFwiIGluIFMgJiYgYi5maW5kKChDKSA9PiB7XHJcbiAgICAgICAgdmFyICQsIEk7XHJcbiAgICAgICAgcmV0dXJuICgoJCA9IEMuZnJvbSkgPT0gbnVsbCA/IHZvaWQgMCA6ICQuaWRlbnRpdHkpID09PSAoKEkgPSBTLmZyb20pID09IG51bGwgPyB2b2lkIDAgOiBJLmlkZW50aXR5KSAmJiBDLmlkID09PSBTLmlkO1xyXG4gICAgICB9KSkge1xyXG4gICAgICAgIGNvbnN0IEMgPSBiLmZpbmRJbmRleCgoJCkgPT4gJC5pZCA9PT0gUy5pZCk7XHJcbiAgICAgICAgaWYgKEMgPiAtMSkge1xyXG4gICAgICAgICAgY29uc3QgJCA9IGJbQ107XHJcbiAgICAgICAgICBiW0NdID0gVGUoWCh7fSwgUyksIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wOiAkLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgZWRpdFRpbWVzdGFtcDogUy50aW1lc3RhbXBcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gWy4uLmJdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbLi4uYiwgU107XHJcbiAgICB9LCBbXSksXHJcbiAgICBOdCh1KVxyXG4gICksIGggPSBuZXcgbG4oITEpLCB4ID0gKGEgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1lc3NhZ2VFbmNvZGVyKSAhPSBudWxsID8gYSA6IHlvLCBFID0gKGIsIFMpID0+IFYodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcclxuICAgIHZhciBDO1xyXG4gICAgUyB8fCAoUyA9IHt9KSwgKEMgPSBTLnRvcGljKSAhPSBudWxsIHx8IChTLnRvcGljID0gbCksIGgubmV4dCghMCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBJID0ge1xyXG4gICAgICAgIGlkOiAoeWllbGQgZS5sb2NhbFBhcnRpY2lwYW50LnNlbmRUZXh0KGIsIFMpKS5pZCxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgbWVzc2FnZTogYixcclxuICAgICAgICBmcm9tOiBlLmxvY2FsUGFydGljaXBhbnQsXHJcbiAgICAgICAgYXR0YWNoZWRGaWxlczogUy5hdHRhY2htZW50c1xyXG4gICAgICB9O1xyXG4gICAgICBtLm5leHQoSSk7XHJcbiAgICAgIGNvbnN0IHogPSB4KFRlKFgoe30sIEkpLCB7XHJcbiAgICAgICAgaWdub3JlTGVnYWN5OiBjKClcclxuICAgICAgfSkpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIFJuKGUubG9jYWxQYXJ0aWNpcGFudCwgeiwge1xyXG4gICAgICAgICAgcmVsaWFibGU6ICEwLFxyXG4gICAgICAgICAgdG9waWM6IGZcclxuICAgICAgICB9KTtcclxuICAgICAgfSBjYXRjaCAoVCkge1xyXG4gICAgICAgIF8uaW5mbyhcImNvdWxkIG5vdCBzZW5kIG1lc3NhZ2UgaW4gbGVnYWN5IGNoYXQgZm9ybWF0XCIsIFQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBJO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaC5uZXh0KCExKTtcclxuICAgIH1cclxuICB9KTtcclxuICBmdW5jdGlvbiBQKCkge1xyXG4gICAgdS5uZXh0KCksIHUuY29tcGxldGUoKSwgbS5jb21wbGV0ZSgpLCBJZS5kZWxldGUoZSksIGUudW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKGwpO1xyXG4gIH1cclxuICByZXR1cm4gZS5vbmNlKHkuRGlzY29ubmVjdGVkLCBQKSwge1xyXG4gICAgbWVzc2FnZU9ic2VydmFibGU6IGcsXHJcbiAgICBpc1NlbmRpbmdPYnNlcnZhYmxlOiBoLFxyXG4gICAgc2VuZDogRVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24geHMoKSB7XHJcbiAgY29uc3QgZSA9IChuKSA9PiBWKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBfLmluZm8oXCJTdGFydCBBdWRpbyBmb3Igcm9vbTogXCIsIG4pLCB5aWVsZCBuLnN0YXJ0QXVkaW8oKTtcclxuICB9KTtcclxuICByZXR1cm4geyBjbGFzc05hbWU6IEYoXCJzdGFydC1hdWRpby1idXR0b25cIiksIHJvb21BdWRpb1BsYXliYWNrQWxsb3dlZE9ic2VydmFibGU6IGFvLCBoYW5kbGVTdGFydEF1ZGlvUGxheWJhY2s6IGUgfTtcclxufVxyXG5mdW5jdGlvbiBTcygpIHtcclxuICBjb25zdCBlID0gKG4pID0+IFYodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcclxuICAgIF8uaW5mbyhcIlN0YXJ0IFZpZGVvIGZvciByb29tOiBcIiwgbiksIHlpZWxkIG4uc3RhcnRWaWRlbygpO1xyXG4gIH0pO1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogRihcInN0YXJ0LWF1ZGlvLWJ1dHRvblwiKSwgcm9vbVZpZGVvUGxheWJhY2tBbGxvd2VkT2JzZXJ2YWJsZTogY28sIGhhbmRsZVN0YXJ0VmlkZW9QbGF5YmFjazogZSB9O1xyXG59XHJcbmZ1bmN0aW9uIFRzKCkge1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogW0YoXCJidXR0b25cIiksIEYoXCJjaGF0LXRvZ2dsZVwiKV0uam9pbihcIiBcIikgfTtcclxufVxyXG5mdW5jdGlvbiBFcygpIHtcclxuICByZXR1cm4geyBjbGFzc05hbWU6IFtGKFwiYnV0dG9uXCIpLCBGKFwiZm9jdXMtdG9nZ2xlLWJ1dHRvblwiKV0uam9pbihcIiBcIikgfTtcclxufVxyXG5mdW5jdGlvbiBDcygpIHtcclxuICByZXR1cm4geyBjbGFzc05hbWU6IFwibGstY2xlYXItcGluLWJ1dHRvbiBsay1idXR0b25cIiB9O1xyXG59XHJcbmZ1bmN0aW9uIFBzKCkge1xyXG4gIHJldHVybiB7IGNsYXNzTmFtZTogXCJsay1yb29tLWNvbnRhaW5lclwiIH07XHJcbn1cclxuZnVuY3Rpb24gVnQoZSwgdCwgbiA9ICEwKSB7XHJcbiAgY29uc3QgaSA9IFtlLmxvY2FsUGFydGljaXBhbnQsIC4uLkFycmF5LmZyb20oZS5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpXSwgbyA9IFtdO1xyXG4gIHJldHVybiBpLmZvckVhY2goKHMpID0+IHtcclxuICAgIHQuZm9yRWFjaCgoYSkgPT4ge1xyXG4gICAgICBjb25zdCBjID0gQXJyYXkuZnJvbShcclxuICAgICAgICBzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpXHJcbiAgICAgICkuZmlsdGVyKFxyXG4gICAgICAgICh1KSA9PiB1LnNvdXJjZSA9PT0gYSAmJiAvLyBlaXRoZXIgcmV0dXJuIGFsbCBvciBvbmx5IHRoZSBvbmVzIHRoYXQgYXJlIHN1YnNjcmliZWRcclxuICAgICAgICAoIW4gfHwgdS50cmFjaylcclxuICAgICAgKS5tYXAoKHUpID0+ICh7XHJcbiAgICAgICAgcGFydGljaXBhbnQ6IHMsXHJcbiAgICAgICAgcHVibGljYXRpb246IHUsXHJcbiAgICAgICAgc291cmNlOiB1LnNvdXJjZVxyXG4gICAgICB9KSk7XHJcbiAgICAgIG8ucHVzaCguLi5jKTtcclxuICAgIH0pO1xyXG4gIH0pLCB7IHRyYWNrUmVmZXJlbmNlczogbywgcGFydGljaXBhbnRzOiBpIH07XHJcbn1cclxuZnVuY3Rpb24gSHQoZSwgdCwgbiA9ICExKSB7XHJcbiAgY29uc3QgeyBzb3VyY2VzOiByLCBraW5kOiBpLCBuYW1lOiBvIH0gPSB0O1xyXG4gIHJldHVybiBBcnJheS5mcm9tKGUudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbHRlcihcclxuICAgIChhKSA9PiAoIXIgfHwgci5pbmNsdWRlcyhhLnNvdXJjZSkpICYmICghaSB8fCBhLmtpbmQgPT09IGkpICYmICghbyB8fCBhLnRyYWNrTmFtZSA9PT0gbykgJiYgLy8gZWl0aGVyIHJldHVybiBhbGwgb3Igb25seSB0aGUgb25lcyB0aGF0IGFyZSBzdWJzY3JpYmVkXHJcbiAgICAoIW4gfHwgYS50cmFjaylcclxuICApLm1hcCgoYSkgPT4gKHtcclxuICAgIHBhcnRpY2lwYW50OiBlLFxyXG4gICAgcHVibGljYXRpb246IGEsXHJcbiAgICBzb3VyY2U6IGEuc291cmNlXHJcbiAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIEFzKGUsIHQsIG4pIHtcclxuICB2YXIgciwgaTtcclxuICBjb25zdCBvID0gKHIgPSBuLmFkZGl0aW9uYWxSb29tRXZlbnRzKSAhPSBudWxsID8gciA6IENuLCBzID0gKGkgPSBuLm9ubHlTdWJzY3JpYmVkKSAhPSBudWxsID8gaSA6ICEwLCBhID0gQXJyYXkuZnJvbShcclxuICAgICgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXHJcbiAgICAgIHkuUGFydGljaXBhbnRDb25uZWN0ZWQsXHJcbiAgICAgIHkuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsXHJcbiAgICAgIHkuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCxcclxuICAgICAgeS5Mb2NhbFRyYWNrUHVibGlzaGVkLFxyXG4gICAgICB5LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCxcclxuICAgICAgeS5UcmFja1B1Ymxpc2hlZCxcclxuICAgICAgeS5UcmFja1VucHVibGlzaGVkLFxyXG4gICAgICB5LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCxcclxuICAgICAgLi4ub1xyXG4gICAgXSkpLnZhbHVlcygpXHJcbiAgKTtcclxuICByZXR1cm4gbGUoZSwgLi4uYSkucGlwZShcclxuICAgIE8oKHUpID0+IHtcclxuICAgICAgY29uc3QgbCA9IFZ0KHUsIHQsIHMpO1xyXG4gICAgICByZXR1cm4gXy5kZWJ1ZyhgVHJhY2tSZWZlcmVuY2VbXSB3YXMgdXBkYXRlZC4gKGxlbmd0aCAke2wudHJhY2tSZWZlcmVuY2VzLmxlbmd0aH0pYCwgbCksIGw7XHJcbiAgICB9KSxcclxuICAgIEQoVnQoZSwgdCwgcykpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBPcyhlLCB0KSB7XHJcbiAgcmV0dXJuIHdlKGUsIC4uLkhpKS5waXBlKFxyXG4gICAgTygocikgPT4ge1xyXG4gICAgICBjb25zdCBpID0gSHQociwgdCk7XHJcbiAgICAgIHJldHVybiBfLmRlYnVnKGBUcmFja1JlZmVyZW5jZVtdIHdhcyB1cGRhdGVkLiAobGVuZ3RoICR7aS5sZW5ndGh9KWAsIGkpLCBpO1xyXG4gICAgfSksXHJcbiAgICBEKEh0KGUsIHQpKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gTW4oZSwgdCkge1xyXG4gIHJldHVybiBuZXcgaygocikgPT4ge1xyXG4gICAgY29uc3QgaSA9ICguLi5zKSA9PiB7XHJcbiAgICAgIHIubmV4dChzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZS5vbih0LCBpKSwgKCkgPT4ge1xyXG4gICAgICBlLm9mZih0LCBpKTtcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24ga3MoZSkge1xyXG4gIHJldHVybiBNbihlLCBZdC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQpO1xyXG59XHJcbmZ1bmN0aW9uIExzKGUpIHtcclxuICByZXR1cm4gTW4oZSwgWXQuVGltZVN5bmNVcGRhdGUpLnBpcGUoXHJcbiAgICBPKChbdF0pID0+IHQpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBfcyhlLCB0ID0gMWUzKSB7XHJcbiAgaWYgKGUgPT09IG51bGwpIHJldHVybiBEdCghMSk7XHJcbiAgY29uc3QgbiA9IGF0KGUsIFwibW91c2Vtb3ZlXCIsIHsgcGFzc2l2ZTogITAgfSkucGlwZShPKCgpID0+ICEwKSksIHIgPSBuLnBpcGUoXHJcbiAgICBoaSh7XHJcbiAgICAgIGVhY2g6IHQsXHJcbiAgICAgIHdpdGg6ICgpID0+IFdlKER0KCExKSwgci5waXBlKElpKG4pKSlcclxuICAgIH0pLFxyXG4gICAga2koKVxyXG4gICk7XHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuZnVuY3Rpb24gd28oZSwgdCkge1xyXG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID4gXCJ1XCIpIHtcclxuICAgIF8uZXJyb3IoXCJMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgaWYgKHQpIHtcclxuICAgICAgY29uc3QgbiA9IE9iamVjdC5mcm9tRW50cmllcyhcclxuICAgICAgICBPYmplY3QuZW50cmllcyh0KS5maWx0ZXIoKFssIHJdKSA9PiByICE9PSBcIlwiKVxyXG4gICAgICApO1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCBKU09OLnN0cmluZ2lmeShuKSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAobikge1xyXG4gICAgXy5lcnJvcihgRXJyb3Igc2V0dGluZyBpdGVtIHRvIGxvY2FsIHN0b3JhZ2U6ICR7bn1gKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24geG8oZSkge1xyXG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID4gXCJ1XCIpIHtcclxuICAgIF8uZXJyb3IoXCJMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0cnkge1xyXG4gICAgY29uc3QgdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpO1xyXG4gICAgaWYgKCF0KSB7XHJcbiAgICAgIF8ud2FybihgSXRlbSB3aXRoIGtleSAke2V9IGRvZXMgbm90IGV4aXN0IGluIGxvY2FsIHN0b3JhZ2UuYCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnBhcnNlKHQpO1xyXG4gIH0gY2F0Y2ggKHQpIHtcclxuICAgIF8uZXJyb3IoYEVycm9yIGdldHRpbmcgaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2U6ICR7dH1gKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gU28oZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBsb2FkOiAoKSA9PiB4byhlKSxcclxuICAgIHNhdmU6ICh0KSA9PiB3byhlLCB0KVxyXG4gIH07XHJcbn1cclxudmFyIFRvID0gYCR7RW59LXVzZXItY2hvaWNlc2AsIFNlID0ge1xyXG4gIHZpZGVvRW5hYmxlZDogITAsXHJcbiAgYXVkaW9FbmFibGVkOiAhMCxcclxuICB2aWRlb0RldmljZUlkOiBcImRlZmF1bHRcIixcclxuICBhdWRpb0RldmljZUlkOiBcImRlZmF1bHRcIixcclxuICB1c2VybmFtZTogXCJcIlxyXG59LCB7IGxvYWQ6IEVvLCBzYXZlOiBDbyB9ID0gU28oVG8pO1xyXG5mdW5jdGlvbiBJcyhlLCB0ID0gITEpIHtcclxuICB0ICE9PSAhMCAmJiBDbyhlKTtcclxufVxyXG5mdW5jdGlvbiBScyhlLCB0ID0gITEpIHtcclxuICB2YXIgbiwgciwgaSwgbywgcztcclxuICBjb25zdCBhID0ge1xyXG4gICAgdmlkZW9FbmFibGVkOiAobiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudmlkZW9FbmFibGVkKSAhPSBudWxsID8gbiA6IFNlLnZpZGVvRW5hYmxlZCxcclxuICAgIGF1ZGlvRW5hYmxlZDogKHIgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1ZGlvRW5hYmxlZCkgIT0gbnVsbCA/IHIgOiBTZS5hdWRpb0VuYWJsZWQsXHJcbiAgICB2aWRlb0RldmljZUlkOiAoaSA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudmlkZW9EZXZpY2VJZCkgIT0gbnVsbCA/IGkgOiBTZS52aWRlb0RldmljZUlkLFxyXG4gICAgYXVkaW9EZXZpY2VJZDogKG8gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1ZGlvRGV2aWNlSWQpICE9IG51bGwgPyBvIDogU2UuYXVkaW9EZXZpY2VJZCxcclxuICAgIHVzZXJuYW1lOiAocyA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudXNlcm5hbWUpICE9IG51bGwgPyBzIDogU2UudXNlcm5hbWVcclxuICB9O1xyXG4gIGlmICh0KVxyXG4gICAgcmV0dXJuIGE7XHJcbiAge1xyXG4gICAgY29uc3QgYyA9IEVvKCk7XHJcbiAgICByZXR1cm4gWChYKHt9LCBhKSwgYyA/PyB7fSk7XHJcbiAgfVxyXG59XHJcbnZhciBudCA9IG51bGwsIHJ0ID0gbnVsbCwgUG8gPSAwO1xyXG5mdW5jdGlvbiB6dCgpIHtcclxuICByZXR1cm4gbnQgfHwgKG50ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIG50O1xyXG59XHJcbmZ1bmN0aW9uIEFvKCkge1xyXG4gIHJldHVybiBydCB8fCAocnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSksIHJ0O1xyXG59XHJcbmZ1bmN0aW9uIE9vKGUsIHQpIHtcclxuICBjb25zdCBuID0gQW8oKTtcclxuICBsZXQgciA9IG4uZ2V0KGUpO1xyXG4gIHJldHVybiByIHx8IChyID0gYHJvb21fJHtQbysrfWAsIG4uc2V0KGUsIHIpKSwgYCR7cn06JHt0fWA7XHJcbn1cclxuZnVuY3Rpb24gTXMoZSwgdCkge1xyXG4gIGNvbnN0IG4gPSBPbyhlLCB0KSwgciA9IHp0KCksIGkgPSByLmdldChuKTtcclxuICBpZiAoaSlcclxuICAgIHJldHVybiBpO1xyXG4gIGNvbnN0IG8gPSBuZXcgWigpLCBzID0gW10sIGEgPSBcImxrLnNlZ21lbnRfaWRcIjtcclxuICBlLnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIodCwgKHUsIGwpID0+IFYodGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcclxuICAgIHZhciBmO1xyXG4gICAgY29uc3QgdiA9IEdlKHUpLnBpcGUoXHJcbiAgICAgIGN0KChtLCBwKSA9PiBtICsgcCwgXCJcIilcclxuICAgICksIGQgPSAhISgoZiA9IHUuaW5mby5hdHRyaWJ1dGVzKSAhPSBudWxsICYmIGZbYV0pO1xyXG4gICAgdi5zdWJzY3JpYmUoKG0pID0+IHtcclxuICAgICAgY29uc3QgcCA9IHMuZmluZEluZGV4KFxyXG4gICAgICAgIChnKSA9PiB7XHJcbiAgICAgICAgICB2YXIgaCwgeDtcclxuICAgICAgICAgIHJldHVybiBnLnN0cmVhbUluZm8uaWQgPT09IHUuaW5mby5pZCB8fCBkICYmICgoaCA9IGcuc3RyZWFtSW5mby5hdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogaFthXSkgPT09ICgoeCA9IHUuaW5mby5hdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogeFthXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgICBwICE9PSAtMSA/IChzW3BdID0gVGUoWCh7fSwgc1twXSksIHtcclxuICAgICAgICB0ZXh0OiBtXHJcbiAgICAgIH0pLCBvLm5leHQoWy4uLnNdKSkgOiAocy5wdXNoKHtcclxuICAgICAgICB0ZXh0OiBtLFxyXG4gICAgICAgIHBhcnRpY2lwYW50SW5mbzogbCxcclxuICAgICAgICBzdHJlYW1JbmZvOiB1LmluZm9cclxuICAgICAgfSksIG8ubmV4dChbLi4uc10pKTtcclxuICAgIH0pO1xyXG4gIH0pKTtcclxuICBjb25zdCBjID0gby5hc09ic2VydmFibGUoKS5waXBlKF9pKCkpO1xyXG4gIHJldHVybiByLnNldChuLCBjKSwgZS5vbmNlKHkuRGlzY29ubmVjdGVkLCAoKSA9PiB7XHJcbiAgICBlLnVucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0KSwgby5jb21wbGV0ZSgpLCB6dCgpLmRlbGV0ZShuKTtcclxuICB9KSwgYztcclxufVxyXG5mdW5jdGlvbiBEbihlLCB0KSB7XHJcbiAgaWYgKHQubXNnID09PSBcInNob3dfY2hhdFwiKVxyXG4gICAgcmV0dXJuIHsgLi4uZSwgc2hvd0NoYXQ6ICEwLCB1bnJlYWRNZXNzYWdlczogMCB9O1xyXG4gIGlmICh0Lm1zZyA9PT0gXCJoaWRlX2NoYXRcIilcclxuICAgIHJldHVybiB7IC4uLmUsIHNob3dDaGF0OiAhMSB9O1xyXG4gIGlmICh0Lm1zZyA9PT0gXCJ0b2dnbGVfY2hhdFwiKSB7XHJcbiAgICBjb25zdCBuID0geyAuLi5lLCBzaG93Q2hhdDogIWUuc2hvd0NoYXQgfTtcclxuICAgIHJldHVybiBuLnNob3dDaGF0ID09PSAhMCAmJiAobi51bnJlYWRNZXNzYWdlcyA9IDApLCBuO1xyXG4gIH0gZWxzZSByZXR1cm4gdC5tc2cgPT09IFwidW5yZWFkX21zZ1wiID8geyAuLi5lLCB1bnJlYWRNZXNzYWdlczogdC5jb3VudCB9IDogdC5tc2cgPT09IFwidG9nZ2xlX3NldHRpbmdzXCIgPyB7IC4uLmUsIHNob3dTZXR0aW5nczogIWUuc2hvd1NldHRpbmdzIH0gOiB7IC4uLmUgfTtcclxufVxyXG5mdW5jdGlvbiAkbihlLCB0KSB7XHJcbiAgcmV0dXJuIHQubXNnID09PSBcInNldF9waW5cIiA/IFt0LnRyYWNrUmVmZXJlbmNlXSA6IHQubXNnID09PSBcImNsZWFyX3BpblwiID8gW10gOiB7IC4uLmUgfTtcclxufVxyXG5jb25zdCBObiA9IFIuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xyXG5mdW5jdGlvbiBEcygpIHtcclxuICBjb25zdCBlID0gUi51c2VDb250ZXh0KE5uKTtcclxuICBpZiAoIWUpXHJcbiAgICB0aHJvdyBFcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBMYXlvdXRDb250ZXh0IGNvbnRleHQgb3V0c2lkZSBhIExheW91dENvbnRleHRQcm92aWRlciBwcm92aWRlci5cIik7XHJcbiAgcmV0dXJuIGU7XHJcbn1cclxuZnVuY3Rpb24gJHMoZSkge1xyXG4gIGNvbnN0IHQgPSBrbygpO1xyXG4gIGlmIChlID8/IChlID0gdCksICFlKVxyXG4gICAgdGhyb3cgRXJyb3IoXCJUcmllZCB0byBhY2Nlc3MgTGF5b3V0Q29udGV4dCBjb250ZXh0IG91dHNpZGUgYSBMYXlvdXRDb250ZXh0UHJvdmlkZXIgcHJvdmlkZXIuXCIpO1xyXG4gIHJldHVybiBlO1xyXG59XHJcbmZ1bmN0aW9uIE5zKCkge1xyXG4gIGNvbnN0IFtlLCB0XSA9IFIudXNlUmVkdWNlcigkbiwgQW4pLCBbbiwgcl0gPSBSLnVzZVJlZHVjZXIoRG4sIE9uKTtcclxuICByZXR1cm4ge1xyXG4gICAgcGluOiB7IGRpc3BhdGNoOiB0LCBzdGF0ZTogZSB9LFxyXG4gICAgd2lkZ2V0OiB7IGRpc3BhdGNoOiByLCBzdGF0ZTogbiB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBGcyhlKSB7XHJcbiAgY29uc3QgW3QsIG5dID0gUi51c2VSZWR1Y2VyKCRuLCBBbiksIFtyLCBpXSA9IFIudXNlUmVkdWNlcihEbiwgT24pO1xyXG4gIHJldHVybiBlID8/IHtcclxuICAgIHBpbjogeyBkaXNwYXRjaDogbiwgc3RhdGU6IHQgfSxcclxuICAgIHdpZGdldDogeyBkaXNwYXRjaDogaSwgc3RhdGU6IHIgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24ga28oKSB7XHJcbiAgcmV0dXJuIFIudXNlQ29udGV4dChObik7XHJcbn1cclxuY29uc3QgRm4gPSBSLmNyZWF0ZUNvbnRleHQoXHJcbiAgdm9pZCAwXHJcbik7XHJcbmZ1bmN0aW9uIFVzKCkge1xyXG4gIGNvbnN0IGUgPSBSLnVzZUNvbnRleHQoRm4pO1xyXG4gIGlmICghZSlcclxuICAgIHRocm93IEVycm9yKFwidHJpZWQgdG8gYWNjZXNzIHRyYWNrIGNvbnRleHQgb3V0c2lkZSBvZiB0cmFjayBjb250ZXh0IHByb3ZpZGVyXCIpO1xyXG4gIHJldHVybiBlO1xyXG59XHJcbmZ1bmN0aW9uIFVuKCkge1xyXG4gIHJldHVybiBSLnVzZUNvbnRleHQoRm4pO1xyXG59XHJcbmZ1bmN0aW9uIGpzKGUpIHtcclxuICBjb25zdCB0ID0gVW4oKSwgbiA9IGUgPz8gdDtcclxuICBpZiAoIW4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIFwiTm8gVHJhY2tSZWYsIG1ha2Ugc3VyZSB5b3UgYXJlIGluc2lkZSBhIFRyYWNrUmVmQ29udGV4dCBvciBwYXNzIHRoZSBUcmFja1JlZiBleHBsaWNpdGx5XCJcclxuICAgICk7XHJcbiAgcmV0dXJuIG47XHJcbn1cclxuY29uc3Qgam4gPSBSLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcclxuZnVuY3Rpb24gV3MoKSB7XHJcbiAgY29uc3QgZSA9IFIudXNlQ29udGV4dChqbik7XHJcbiAgaWYgKCFlKVxyXG4gICAgdGhyb3cgRXJyb3IoXCJ0cmllZCB0byBhY2Nlc3MgcGFydGljaXBhbnQgY29udGV4dCBvdXRzaWRlIG9mIHBhcnRpY2lwYW50IGNvbnRleHQgcHJvdmlkZXJcIik7XHJcbiAgcmV0dXJuIGU7XHJcbn1cclxuZnVuY3Rpb24gTG8oKSB7XHJcbiAgcmV0dXJuIFIudXNlQ29udGV4dChqbik7XHJcbn1cclxuZnVuY3Rpb24gQnMoZSkge1xyXG4gIGNvbnN0IHQgPSBMbygpLCBuID0gVW4oKSwgciA9IGUgPz8gdCA/PyAobiA9PSBudWxsID8gdm9pZCAwIDogbi5wYXJ0aWNpcGFudCk7XHJcbiAgaWYgKCFyKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBcIk5vIHBhcnRpY2lwYW50IHByb3ZpZGVkLCBtYWtlIHN1cmUgeW91IGFyZSBpbnNpZGUgYSBwYXJ0aWNpcGFudCBjb250ZXh0IG9yIHBhc3MgdGhlIHBhcnRpY2lwYW50IGV4cGxpY2l0bHlcIlxyXG4gICAgKTtcclxuICByZXR1cm4gcjtcclxufVxyXG5jb25zdCBXbiA9IFIuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xyXG5mdW5jdGlvbiBWcygpIHtcclxuICBjb25zdCBlID0gUi51c2VDb250ZXh0KFduKTtcclxuICBpZiAoIWUpXHJcbiAgICB0aHJvdyBFcnJvcihcInRyaWVkIHRvIGFjY2VzcyByb29tIGNvbnRleHQgb3V0c2lkZSBvZiBsaXZla2l0IHJvb20gY29tcG9uZW50XCIpO1xyXG4gIHJldHVybiBlO1xyXG59XHJcbmZ1bmN0aW9uIF9vKCkge1xyXG4gIHJldHVybiBSLnVzZUNvbnRleHQoV24pO1xyXG59XHJcbmZ1bmN0aW9uIEhzKGUpIHtcclxuICBjb25zdCB0ID0gX28oKSwgbiA9IGUgPz8gdDtcclxuICBpZiAoIW4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIFwiTm8gcm9vbSBwcm92aWRlZCwgbWFrZSBzdXJlIHlvdSBhcmUgaW5zaWRlIGEgUm9vbSBjb250ZXh0IG9yIHBhc3MgdGhlIHJvb20gZXhwbGljaXRseVwiXHJcbiAgICApO1xyXG4gIHJldHVybiBuO1xyXG59XHJcbmNvbnN0IElvID0gUi5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XHJcbmZ1bmN0aW9uIHpzKGUpIHtcclxuICBjb25zdCB0ID0gUi51c2VDb250ZXh0KElvKTtcclxuICBpZiAoZSA9PT0gITApIHtcclxuICAgIGlmICh0KVxyXG4gICAgICByZXR1cm4gdDtcclxuICAgIHRocm93IEVycm9yKFwidHJpZWQgdG8gYWNjZXNzIGZlYXR1cmUgY29udGV4dCwgYnV0IG5vbmUgaXMgcHJlc2VudFwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuZXhwb3J0IHtcclxuICBJcyBhcyAkLFxyXG4gIFhvIGFzIEEsXHJcbiAgTG8gYXMgQixcclxuICBsbyBhcyBDLFxyXG4gIHlzIGFzIEQsXHJcbiAgYXMgYXMgRSxcclxuICAkcyBhcyBGLFxyXG4gIHpvIGFzIEcsXHJcbiAgY3MgYXMgSCxcclxuICBscyBhcyBJLFxyXG4gIHRzIGFzIEosXHJcbiAgbnMgYXMgSyxcclxuICBJbyBhcyBMLFxyXG4gIEpvIGFzIE0sXHJcbiAgeHMgYXMgTixcclxuICBTcyBhcyBPLFxyXG4gIFRzIGFzIFAsXHJcbiAgZ3MgYXMgUSxcclxuICBXbiBhcyBSLFxyXG4gIGRzIGFzIFMsXHJcbiAgcHMgYXMgVCxcclxuICBLaSBhcyBVLFxyXG4gIEFzIGFzIFYsXHJcbiAgR28gYXMgVyxcclxuICBCdCBhcyBYLFxyXG4gIFpvIGFzIFksXHJcbiAgd3MgYXMgWixcclxuICBScyBhcyBfLFxyXG4gIERzIGFzIGEsXHJcbiAgaXMgYXMgYTAsXHJcbiAgaiBhcyBhMSxcclxuICBPcyBhcyBhMixcclxuICBMcyBhcyBhMyxcclxuICBrcyBhcyBhNCxcclxuICBLbyBhcyBhNSxcclxuICBxbyBhcyBhNixcclxuICBmcyBhcyBhNyxcclxuICBvcyBhcyBhOCxcclxuICBNcyBhcyBhOSxcclxuICBobyBhcyBhYSxcclxuICBVbiBhcyBhYixcclxuICBObiBhcyBhYyxcclxuICBicyBhcyBhZCxcclxuICBNbyBhcyBhZSxcclxuICBBciBhcyBhZixcclxuICBqbiBhcyBhZyxcclxuICBGbiBhcyBhaCxcclxuICB6cyBhcyBhaSxcclxuICBfcyBhcyBhaixcclxuICBObyBhcyBhayxcclxuICBGcyBhcyBhbCxcclxuICBCbyBhcyBhbSxcclxuICBXbyBhcyBhbixcclxuICBVbyBhcyBhbyxcclxuICBqbyBhcyBhcCxcclxuICBZbyBhcyBhcSxcclxuICBOcyBhcyBhcixcclxuICBEbyBhcyBhcyxcclxuICBGbyBhcyBhdCxcclxuICBWbyBhcyBhdSxcclxuICBIbyBhcyBhdixcclxuICBXcyBhcyBhdyxcclxuICBVcyBhcyBheCxcclxuICBDcyBhcyBiLFxyXG4gIEJzIGFzIGMsXHJcbiAgbXMgYXMgZCxcclxuICBlcyBhcyBlLFxyXG4gIFZzIGFzIGYsXHJcbiAgbW8gYXMgZyxcclxuICB2cyBhcyBoLFxyXG4gIGpzIGFzIGksXHJcbiAga28gYXMgaixcclxuICBFcyBhcyBrLFxyXG4gIF8gYXMgbCxcclxuICAkbyBhcyBtLFxyXG4gIFlpIGFzIG4sXHJcbiAgcG8gYXMgbyxcclxuICBOIGFzIHAsXHJcbiAgc3MgYXMgcSxcclxuICBhbyBhcyByLFxyXG4gIFBzIGFzIHMsXHJcbiAgSW4gYXMgdCxcclxuICBIcyBhcyB1LFxyXG4gIHVzIGFzIHYsXHJcbiAgX28gYXMgdyxcclxuICBycyBhcyB4LFxyXG4gIGhzIGFzIHksXHJcbiAgUW8gYXMgelxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0cy1DbTFhU0JUcy5tanMubWFwXHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-OJtwh4jO.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/hooks-OJtwh4jO.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ At),\n/* harmony export */   B: () => (/* binding */ Ft),\n/* harmony export */   C: () => (/* binding */ et),\n/* harmony export */   D: () => (/* binding */ Mt),\n/* harmony export */   E: () => (/* binding */ kt),\n/* harmony export */   F: () => (/* binding */ Ze),\n/* harmony export */   G: () => (/* binding */ z),\n/* harmony export */   H: () => (/* binding */ Ke),\n/* harmony export */   I: () => (/* binding */ Dt),\n/* harmony export */   J: () => (/* binding */ Lt),\n/* harmony export */   K: () => (/* binding */ Nt),\n/* harmony export */   L: () => (/* binding */ Vt),\n/* harmony export */   M: () => (/* binding */ H),\n/* harmony export */   N: () => (/* binding */ Bt),\n/* harmony export */   O: () => (/* binding */ nt),\n/* harmony export */   P: () => (/* binding */ xt),\n/* harmony export */   Q: () => (/* binding */ $t),\n/* harmony export */   R: () => (/* binding */ Yt),\n/* harmony export */   S: () => (/* binding */ Kt),\n/* harmony export */   T: () => (/* binding */ q),\n/* harmony export */   U: () => (/* binding */ pt),\n/* harmony export */   V: () => (/* binding */ tn),\n/* harmony export */   W: () => (/* binding */ bt),\n/* harmony export */   X: () => (/* binding */ en),\n/* harmony export */   Y: () => (/* binding */ nn),\n/* harmony export */   Z: () => (/* binding */ mt),\n/* harmony export */   _: () => (/* binding */ sn),\n/* harmony export */   a: () => (/* binding */ I),\n/* harmony export */   b: () => (/* binding */ Jt),\n/* harmony export */   c: () => (/* binding */ Tt),\n/* harmony export */   d: () => (/* binding */ Et),\n/* harmony export */   e: () => (/* binding */ Ct),\n/* harmony export */   f: () => (/* binding */ zt),\n/* harmony export */   g: () => (/* binding */ Ut),\n/* harmony export */   h: () => (/* binding */ Gt),\n/* harmony export */   i: () => (/* binding */ Pt),\n/* harmony export */   j: () => (/* binding */ b),\n/* harmony export */   k: () => (/* binding */ Wt),\n/* harmony export */   l: () => (/* binding */ Rt),\n/* harmony export */   m: () => (/* binding */ Xt),\n/* harmony export */   n: () => (/* binding */ wt),\n/* harmony export */   o: () => (/* binding */ Ot),\n/* harmony export */   p: () => (/* binding */ qt),\n/* harmony export */   q: () => (/* binding */ Ye),\n/* harmony export */   r: () => (/* binding */ tt),\n/* harmony export */   s: () => (/* binding */ Zt),\n/* harmony export */   t: () => (/* binding */ Qt),\n/* harmony export */   u: () => (/* binding */ yt),\n/* harmony export */   v: () => (/* binding */ _t),\n/* harmony export */   w: () => (/* binding */ Ht),\n/* harmony export */   x: () => (/* binding */ jt),\n/* harmony export */   y: () => (/* binding */ It),\n/* harmony export */   z: () => (/* binding */ ht)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contexts-Cm1aSBTs.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs\");\n/* harmony import */ var _room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./room-889cObLb.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-889cObLb.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n\r\n\r\n\r\n\r\nconst $e = (e) => {\r\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(e);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    t.current = e;\r\n  }), t;\r\n};\r\nfunction He(e, t) {\r\n  const n = Xe(), a = $e(t);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n    let s = !1;\r\n    const c = e.current;\r\n    if (!c) return;\r\n    function o(u, i) {\r\n      s || a.current(u, i);\r\n    }\r\n    return n == null || n.subscribe(c, o), () => {\r\n      s = !0, n == null || n.unsubscribe(c, o);\r\n    };\r\n  }, [e.current, n, a]), n == null ? void 0 : n.observer;\r\n}\r\nfunction je() {\r\n  let e = !1, t = [];\r\n  const n = /* @__PURE__ */ new Map();\r\n  if (typeof window > \"u\")\r\n    return;\r\n  const a = new ResizeObserver((s, c) => {\r\n    t = t.concat(s), e || window.requestAnimationFrame(() => {\r\n      const o = /* @__PURE__ */ new Set();\r\n      for (let u = 0; u < t.length; u++) {\r\n        if (o.has(t[u].target)) continue;\r\n        o.add(t[u].target);\r\n        const i = n.get(t[u].target);\r\n        i == null || i.forEach((d) => d(t[u], c));\r\n      }\r\n      t = [], e = !1;\r\n    }), e = !0;\r\n  });\r\n  return {\r\n    observer: a,\r\n    subscribe(s, c) {\r\n      a.observe(s);\r\n      const o = n.get(s) ?? [];\r\n      o.push(c), n.set(s, o);\r\n    },\r\n    unsubscribe(s, c) {\r\n      const o = n.get(s) ?? [];\r\n      if (o.length === 1) {\r\n        a.unobserve(s), n.delete(s);\r\n        return;\r\n      }\r\n      const u = o.indexOf(c);\r\n      u !== -1 && o.splice(u, 1), n.set(s, o);\r\n    }\r\n  };\r\n}\r\nlet D;\r\nconst Xe = () => D || (D = je()), Ye = (e) => {\r\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState({ width: 0, height: 0 });\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\r\n    if (e.current) {\r\n      const { width: s, height: c } = e.current.getBoundingClientRect();\r\n      n({ width: s, height: c });\r\n    }\r\n  }, [e.current]);\r\n  const a = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\r\n    (s) => n(s.contentRect),\r\n    []\r\n  );\r\n  return He(e, a), t;\r\n};\r\nfunction b(e, t, n = !0) {\r\n  const [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (n && s(t), typeof window > \"u\" || !e) return;\r\n    const c = e.subscribe(s);\r\n    return () => c.unsubscribe();\r\n  }, [e, n]), a;\r\n}\r\nfunction ht(e) {\r\n  const t = (c) => typeof window < \"u\" ? window.matchMedia(c).matches : !1, [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t(e));\r\n  function s() {\r\n    a(t(e));\r\n  }\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const c = window.matchMedia(e);\r\n    return s(), c.addListener ? c.addListener(s) : c.addEventListener(\"change\", s), () => {\r\n      c.removeListener ? c.removeListener(s) : c.removeEventListener(\"change\", s);\r\n    };\r\n  }, [e]), n;\r\n}\r\nfunction Mt(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), n = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async () => {\r\n    await t.startAudio();\r\n  }, [t]), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.r)(t),\r\n    [t]\r\n  ), { canPlayAudio: s } = b(a, {\r\n    canPlayAudio: t.canPlaybackAudio\r\n  });\r\n  return { canPlayAudio: s, startAudio: n };\r\n}\r\nfunction yt(e) {\r\n  const { state: t, dispatch: n } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a)().pin;\r\n  return { buttonProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    const { className: s } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.b)();\r\n    return (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\r\n      className: s,\r\n      disabled: !(t != null && t.length),\r\n      onClick: () => {\r\n        n && n({ msg: \"clear_pin\" });\r\n      }\r\n    });\r\n  }, [e, n, t]) };\r\n}\r\nfunction Pt(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e.participant), { className: n, connectionQualityObserver: a } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.d)(t),\r\n    [t]\r\n  ), s = b(a, livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionQuality.Unknown);\r\n  return { className: n, quality: s };\r\n}\r\nfunction I(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.e)(t), [t]);\r\n  return b(n, t.state);\r\n}\r\nfunction kt(e, t) {\r\n  const n = typeof e == \"function\" ? e : t, a = typeof e == \"string\" ? e : void 0, s = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), { send: c, messageObservable: o, isSendingObservable: u } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(s, a, n),\r\n    [s, a, n]\r\n  ), i = b(o, void 0), d = b(u, !1);\r\n  return {\r\n    message: i,\r\n    send: c,\r\n    isSending: d\r\n  };\r\n}\r\nfunction Tt(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), n = I(t);\r\n  return { buttonProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    const { className: s, disconnect: c } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.h)(t);\r\n    return (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\r\n      className: s,\r\n      onClick: () => c(e.stopTracks ?? !0),\r\n      disabled: n === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected\r\n    });\r\n  }, [t, e, n]) };\r\n}\r\nfunction Ze(e) {\r\n  if (e.publication instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.LocalTrackPublication) {\r\n    const t = e.publication.track;\r\n    if (t) {\r\n      const { facingMode: n } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.facingModeFromLocalTrack)(t);\r\n      return n;\r\n    }\r\n  }\r\n  return \"undefined\";\r\n}\r\nfunction Et({ trackRef: e, props: t }) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), a = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.j)(), { className: s } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.k)(), []), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.m)(n, a == null ? void 0 : a.pin.state), [n, a == null ? void 0 : a.pin.state]);\r\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(t, {\r\n      className: s,\r\n      onClick: (u) => {\r\n        var i, d, f, l, p;\r\n        (i = t.onClick) == null || i.call(t, u), c ? (f = a == null ? void 0 : (d = a.pin).dispatch) == null || f.call(d, {\r\n          msg: \"clear_pin\"\r\n        }) : (p = a == null ? void 0 : (l = a.pin).dispatch) == null || p.call(l, {\r\n          msg: \"set_pin\",\r\n          trackReference: n\r\n        });\r\n      }\r\n    }),\r\n    [t, s, n, c, a == null ? void 0 : a.pin]\r\n  ), inFocus: c };\r\n}\r\nfunction wt(e, t, n = {}) {\r\n  const a = n.gridLayouts ?? _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.G, { width: s, height: c } = Ye(e), o = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.n)(a, t, s, c);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    e.current && o && (e.current.style.setProperty(\"--lk-col-count\", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty(\"--lk-row-count\", o == null ? void 0 : o.rows.toString()));\r\n  }, [e, o]), {\r\n    layout: o,\r\n    containerWidth: s,\r\n    containerHeight: c\r\n  };\r\n}\r\nfunction z(e, t = {}) {\r\n  var u, i;\r\n  const n = typeof e == \"string\" ? t.participant : e.participant, a = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(n), s = typeof e == \"string\" ? { participant: a, source: e } : e, [c, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    !!((u = s.publication) != null && u.isMuted || (i = a.getTrackPublication(s.source)) != null && i.isMuted)\r\n  );\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const d = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.o)(s).subscribe(o);\r\n    return () => d.unsubscribe();\r\n  }, [(0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(s)]), c;\r\n}\r\nfunction Ke(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e), n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.q)(t), [t]);\r\n  return b(n, t.isSpeaking);\r\n}\r\nfunction et(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.localParticipant), [s, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    n.isMicrophoneEnabled\r\n  ), [o, u] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    n.isMicrophoneEnabled\r\n  ), [i, d] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    n.lastMicrophoneError\r\n  ), [f, l] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n.lastCameraError), [p, S] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    n.isMicrophoneEnabled\r\n  ), [g, m] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    void 0\r\n  ), [y, h] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0), P = (M) => {\r\n    u(M.isCameraEnabled), c(M.isMicrophoneEnabled), S(M.isScreenShareEnabled), h(M.cameraTrack), m(M.microphoneTrack), d(M.participant.lastMicrophoneError), l(M.participant.lastCameraError), a(M.participant);\r\n  };\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const M = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.t)(t.localParticipant).subscribe(P);\r\n    return () => M.unsubscribe();\r\n  }, [t]), {\r\n    isMicrophoneEnabled: s,\r\n    isScreenShareEnabled: p,\r\n    isCameraEnabled: o,\r\n    microphoneTrack: g,\r\n    cameraTrack: y,\r\n    lastMicrophoneError: i,\r\n    lastCameraError: f,\r\n    localParticipant: n\r\n  };\r\n}\r\nfunction At() {\r\n  const e = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.v)(e.localParticipant),\r\n    [e]\r\n  );\r\n  return b(t, e.localParticipant.permissions);\r\n}\r\nfunction Ct({\r\n  kind: e,\r\n  room: t,\r\n  track: n,\r\n  requestPermissions: a,\r\n  onError: s\r\n}) {\r\n  const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => t ?? c ?? new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Room(), [t, c]), u = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.x)(e, s, a),\r\n    [e, a, s]\r\n  ), i = b(u, []), [d, f] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    (o == null ? void 0 : o.getActiveDevice(e)) ?? \"default\"\r\n  ), { className: l, activeDeviceObservable: p, setActiveMediaDevice: S } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.y)(e, o),\r\n    [e, o, n]\r\n  );\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const g = p.subscribe((m) => {\r\n      m && (_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.info(\"setCurrentDeviceId\", m), f(m));\r\n    });\r\n    return () => {\r\n      g == null || g.unsubscribe();\r\n    };\r\n  }, [p]), { devices: i, className: l, activeDeviceId: d, setActiveMediaDevice: S };\r\n}\r\nfunction It({\r\n  kind: e,\r\n  onError: t\r\n}) {\r\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.x)(e, t),\r\n    [e, t]\r\n  );\r\n  return b(n, []);\r\n}\r\nfunction tt(e, t, n = {}) {\r\n  const a = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]), s = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1), c = t !== s.current, o = typeof n.customSortFunction == \"function\" ? n.customSortFunction(e) : (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.z)(e);\r\n  let u = [...o];\r\n  if (c === !1)\r\n    try {\r\n      u = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.A)(a.current, o, t);\r\n    } catch (i) {\r\n      _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.error(\"Error while running updatePages(): \", i);\r\n    }\r\n  return c ? a.current = o : a.current = u, s.current = t, u;\r\n}\r\nfunction Ot(e, t) {\r\n  const [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(1), s = Math.max(Math.ceil(t.length / e), 1);\r\n  n > s && a(s);\r\n  const c = n * e, o = c - e, u = (l) => {\r\n    a((p) => l === \"next\" ? p === s ? p : p + 1 : p === 1 ? p : p - 1);\r\n  }, i = (l) => {\r\n    l > s ? a(s) : l < 1 ? a(1) : a(l);\r\n  }, f = tt(t, e).slice(o, c);\r\n  return {\r\n    totalPageCount: s,\r\n    nextPage: () => u(\"next\"),\r\n    prevPage: () => u(\"previous\"),\r\n    setPage: i,\r\n    firstItemIndex: o,\r\n    lastItemIndex: c,\r\n    tracks: f,\r\n    currentPage: n\r\n  };\r\n}\r\nfunction Dt(e = {}) {\r\n  let t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.B)();\r\n  e.participant && (t = e.participant);\r\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.C)(t), [t]), { identity: a, name: s, metadata: c } = b(n, {\r\n    name: t == null ? void 0 : t.name,\r\n    identity: t == null ? void 0 : t.identity,\r\n    metadata: t == null ? void 0 : t.metadata\r\n  });\r\n  return { identity: a, name: s, metadata: c };\r\n}\r\nfunction Lt(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e.participant), n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.v)(t), [t]);\r\n  return b(n, t.permissions);\r\n}\r\nfunction Rt({\r\n  trackRef: e,\r\n  onParticipantClick: t,\r\n  disableSpeakingIndicator: n,\r\n  htmlProps: a\r\n}) {\r\n  const s = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    const { className: p } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.D)();\r\n    return (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(a, {\r\n      className: p,\r\n      onClick: (S) => {\r\n        var g;\r\n        if ((g = a.onClick) == null || g.call(a, S), typeof t == \"function\") {\r\n          const m = s.publication ?? s.participant.getTrackPublication(s.source);\r\n          t({ participant: s.participant, track: m });\r\n        }\r\n      }\r\n    });\r\n  }, [\r\n    a,\r\n    t,\r\n    s.publication,\r\n    s.source,\r\n    s.participant\r\n  ]), o = s.participant.getTrackPublication(livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone), u = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\r\n    participant: s.participant,\r\n    source: livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone,\r\n    publication: o\r\n  }), [o, s.participant]), i = z(s), d = z(u), f = Ke(s.participant), l = Ze(s);\r\n  return {\r\n    elementProps: {\r\n      \"data-lk-audio-muted\": d,\r\n      \"data-lk-video-muted\": i,\r\n      \"data-lk-speaking\": n === !0 ? !1 : f,\r\n      \"data-lk-local-participant\": s.participant.isLocal,\r\n      \"data-lk-source\": s.source,\r\n      \"data-lk-facing-mode\": l,\r\n      ...c\r\n    }\r\n  };\r\n}\r\nfunction H(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), [n, a] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const s = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.E)(t, {\r\n      additionalRoomEvents: e.updateOnlyOn\r\n    }).subscribe(a);\r\n    return () => s.unsubscribe();\r\n  }, [t, JSON.stringify(e.updateOnlyOn)]), n;\r\n}\r\nfunction Nt(e = {}) {\r\n  const t = H(e), { localParticipant: n } = et(e);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => [n, ...t],\r\n    [n, t]\r\n  );\r\n}\r\nfunction Ft(e) {\r\n  return e = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.F)(e), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);\r\n}\r\nfunction Vt(e, t = {}) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), [a] = react__WEBPACK_IMPORTED_MODULE_0__.useState(t.updateOnlyOn), s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => typeof e == \"string\" ? (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.H)(n, e, {\r\n    additionalEvents: a\r\n  }) : (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.I)(n, e, {\r\n    additionalEvents: a\r\n  }), [n, JSON.stringify(e), a]), [c, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\r\n    p: void 0\r\n  });\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const u = s.subscribe((i) => o({ p: i }));\r\n    return () => u.unsubscribe();\r\n  }, [s]), c.p;\r\n}\r\nfunction _t(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e.room), n = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.J)(t), [t]), { name: a, metadata: s } = b(n, {\r\n    name: t.name,\r\n    metadata: t.metadata\r\n  });\r\n  return { name: a, metadata: s };\r\n}\r\nfunction nt() {\r\n  const e = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.K)(e), [e]);\r\n  return b(t, e.activeSpeakers);\r\n}\r\nfunction Bt(e) {\r\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(e)\r\n  ), a = nt();\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    n((0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.M)(e));\r\n  }, [a, e]), t;\r\n}\r\nfunction zt({ room: e, props: t }) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), { className: a, roomAudioPlaybackAllowedObservable: s, handleStartAudioPlayback: c } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.N)(),\r\n    []\r\n  ), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => s(n),\r\n    [n, s]\r\n  ), { canPlayAudio: u } = b(o, {\r\n    canPlayAudio: n.canPlaybackAudio\r\n  });\r\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(t, {\r\n      className: a,\r\n      onClick: () => {\r\n        c(n);\r\n      },\r\n      style: { display: u ? \"none\" : \"block\" }\r\n    }),\r\n    [t, a, u, c, n]\r\n  ), canPlayAudio: u };\r\n}\r\nfunction Ut({ room: e, props: t }) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), { className: a, roomVideoPlaybackAllowedObservable: s, handleStartVideoPlayback: c } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.O)(),\r\n    []\r\n  ), o = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => s(n),\r\n    [n, s]\r\n  ), { canPlayVideo: u } = b(o, {\r\n    canPlayVideo: n.canPlaybackVideo\r\n  });\r\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(t, {\r\n      className: a,\r\n      onClick: () => {\r\n        c(n);\r\n      },\r\n      style: { display: u ? \"none\" : \"block\" }\r\n    }),\r\n    [t, a, u, c, n]\r\n  ), canPlayVideo: u };\r\n}\r\nfunction qt(e, t = {}) {\r\n  const n = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), a = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null), s = t.minSwipeDistance ?? 50, c = (i) => {\r\n    a.current = null, n.current = i.targetTouches[0].clientX;\r\n  }, o = (i) => {\r\n    a.current = i.targetTouches[0].clientX;\r\n  }, u = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\r\n    if (!n.current || !a.current)\r\n      return;\r\n    const i = n.current - a.current, d = i > s, f = i < -s;\r\n    d && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe();\r\n  }, [s, t]);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const i = e.current;\r\n    return i && (i.addEventListener(\"touchstart\", c, { passive: !0 }), i.addEventListener(\"touchmove\", o, { passive: !0 }), i.addEventListener(\"touchend\", u, { passive: !0 })), () => {\r\n      i && (i.removeEventListener(\"touchstart\", c), i.removeEventListener(\"touchmove\", o), i.removeEventListener(\"touchend\", u));\r\n    };\r\n  }, [e, u]);\r\n}\r\nfunction Jt({ props: e }) {\r\n  const { dispatch: t, state: n } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a)().widget, { className: a } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.P)(), []);\r\n  return { mergedProps: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(e, {\r\n    className: a,\r\n    onClick: () => {\r\n      t && t({ msg: \"toggle_chat\" });\r\n    },\r\n    \"aria-pressed\": n != null && n.showChat ? \"true\" : \"false\",\r\n    \"data-lk-unread-msgs\": n ? n.unreadMessages < 10 ? n.unreadMessages.toFixed(0) : \"9+\" : \"0\"\r\n  }), [e, a, t, n]) };\r\n}\r\nfunction xt(e, t, n = {}) {\r\n  const [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(void 0);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    var o;\r\n    if (e === void 0)\r\n      throw Error(\"token endpoint needs to be defined\");\r\n    if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0)\r\n      return;\r\n    (async () => {\r\n      _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"fetching token\");\r\n      const u = new URLSearchParams({ ...n.userInfo, roomName: t }), i = await fetch(`${e}?${u.toString()}`);\r\n      if (!i.ok) {\r\n        _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.error(\r\n          `Could not fetch token. Server responded with status ${i.status}: ${i.statusText}`\r\n        );\r\n        return;\r\n      }\r\n      const { accessToken: d } = await i.json();\r\n      s(d);\r\n    })();\r\n  }, [e, t, JSON.stringify(n)]), a;\r\n}\r\nfunction Wt(e) {\r\n  var c, o;\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.i)(e), { className: n, mediaMutedObserver: a } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.Q)(t),\r\n    [(0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(t)]\r\n  );\r\n  return { isMuted: b(\r\n    a,\r\n    !!((c = t.publication) != null && c.isMuted || (o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)\r\n  ), className: n };\r\n}\r\nfunction Gt({\r\n  source: e,\r\n  onChange: t,\r\n  initialState: n,\r\n  captureOptions: a,\r\n  publishOptions: s,\r\n  onDeviceError: c,\r\n  ...o\r\n}) {\r\n  var P;\r\n  const u = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.w)(), i = (P = u == null ? void 0 : u.localParticipant) == null ? void 0 : P.getTrackPublication(e), d = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!1), { toggle: f, className: l, pendingObserver: p, enabledObserver: S } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => u ? (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.S)(e, u, a, s, c) : (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.T)(),\r\n    [u, e, JSON.stringify(a), s]\r\n  ), g = b(p, !1), m = b(S, n ?? !!(i != null && i.isEnabled));\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    t == null || t(m, d.current), d.current = !1;\r\n  }, [m, t]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    n !== void 0 && (_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"forcing initial toggle state\", e, n), f(n));\r\n  }, []);\r\n  const y = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_room_889cObLb_mjs__WEBPACK_IMPORTED_MODULE_3__.m)(o, { className: l }), [o, l]), h = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\r\n    (M) => {\r\n      var O;\r\n      d.current = !0, f().catch(() => d.current = !1), (O = o.onClick) == null || O.call(o, M);\r\n    },\r\n    [o, f]\r\n  );\r\n  return {\r\n    toggle: f,\r\n    enabled: m,\r\n    pending: g,\r\n    track: i,\r\n    buttonProps: {\r\n      ...y,\r\n      \"aria-pressed\": m,\r\n      \"data-lk-source\": e,\r\n      \"data-lk-enabled\": m,\r\n      disabled: g,\r\n      onClick: h\r\n    }\r\n  };\r\n}\r\nfunction Qt(e = [\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShare,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.ScreenShareAudio,\r\n  livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown\r\n], t = {}) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(t.room), [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), [c, o] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), u = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => e.map((d) => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.U)(d) ? d.source : d), [JSON.stringify(e)]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const d = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.V)(n, u, {\r\n      additionalRoomEvents: t.updateOnlyOn,\r\n      onlySubscribed: t.onlySubscribed\r\n    }).subscribe(({ trackReferences: f, participants: l }) => {\r\n      _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"setting track bundles\", f, l), s(f), o(l);\r\n    });\r\n    return () => d.unsubscribe();\r\n  }, [\r\n    n,\r\n    JSON.stringify(t.onlySubscribed),\r\n    JSON.stringify(t.updateOnlyOn),\r\n    JSON.stringify(e)\r\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    if ((0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.W)(e)) {\r\n      const d = at(e, c), f = Array.from(a);\r\n      return c.forEach((l) => {\r\n        d.has(l.identity) && (d.get(l.identity) ?? []).forEach((S) => {\r\n          if (a.find(\r\n            ({ participant: m, publication: y }) => l.identity === m.identity && y.source === S\r\n          ))\r\n            return;\r\n          _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\r\n            `Add ${S} placeholder for participant ${l.identity}.`\r\n          );\r\n          const g = {\r\n            participant: l,\r\n            source: S\r\n          };\r\n          f.push(g);\r\n        });\r\n      }), f;\r\n    } else\r\n      return a;\r\n  }, [a, c, e]);\r\n}\r\nfunction st(e, t) {\r\n  const n = new Set(e);\r\n  for (const a of t)\r\n    n.delete(a);\r\n  return n;\r\n}\r\nfunction at(e, t) {\r\n  const n = /* @__PURE__ */ new Map();\r\n  if ((0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.W)(e)) {\r\n    const a = e.filter((s) => s.withPlaceholder).map((s) => s.source);\r\n    t.forEach((s) => {\r\n      const c = s.getTrackPublications().map((u) => {\r\n        var i;\r\n        return (i = u.track) == null ? void 0 : i.source;\r\n      }).filter((u) => u !== void 0), o = Array.from(\r\n        st(new Set(a), new Set(c))\r\n      );\r\n      o.length > 0 && n.set(s.identity, o);\r\n    });\r\n  }\r\n  return n;\r\n}\r\nfunction rt(e) {\r\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState((0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.X)(e)), { trackObserver: a } = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.Y)(e), [e.participant.sid ?? e.participant.identity, e.source]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    const s = a.subscribe((c) => {\r\n      n(c);\r\n    });\r\n    return () => s == null ? void 0 : s.unsubscribe();\r\n  }, [a]), {\r\n    participant: e.participant,\r\n    source: e.source ?? livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Unknown,\r\n    publication: t\r\n  };\r\n}\r\nfunction $t(e, t) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(t);\r\n  return rt({ name: e, participant: n });\r\n}\r\nfunction Ht(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), n = I(t), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => n === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected,\r\n    [n]\r\n  ), s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.Z)(t, e),\r\n    [t, e, a]\r\n  ), c = b(s.isSendingObservable, !1), o = b(s.messageObservable, []);\r\n  return { send: s.send, chatMessages: o, isSending: c };\r\n}\r\nfunction jt(e = {}) {\r\n  const [t, n] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__._)(e.defaults, e.preventLoad ?? !1)\r\n  ), a = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\r\n    n((d) => ({ ...d, audioEnabled: i }));\r\n  }, []), s = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\r\n    n((d) => ({ ...d, videoEnabled: i }));\r\n  }, []), c = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\r\n    n((d) => ({ ...d, audioDeviceId: i }));\r\n  }, []), o = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\r\n    n((d) => ({ ...d, videoDeviceId: i }));\r\n  }, []), u = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((i) => {\r\n    n((d) => ({ ...d, username: i }));\r\n  }, []);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.$)(t, e.preventSave ?? !1);\r\n  }, [t, e.preventSave]), {\r\n    userChoices: t,\r\n    saveAudioInputEnabled: a,\r\n    saveVideoInputEnabled: s,\r\n    saveAudioInputDeviceId: c,\r\n    saveVideoInputDeviceId: o,\r\n    saveUsername: u\r\n  };\r\n}\r\nfunction Xt(e, t = {}) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(e), a = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(t.room), s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a0)(a, n), [a, n]);\r\n  return b(\r\n    s,\r\n    n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted)\r\n  );\r\n}\r\nfunction Yt(e, t = { fftSize: 32, smoothingTimeConstant: 0 }) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a1)(e) ? e.publication.track : e, [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!n || !n.mediaStream)\r\n      return;\r\n    const { cleanup: c, analyser: o } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(n, t), u = o.frequencyBinCount, i = new Uint8Array(u), f = setInterval(() => {\r\n      o.getByteFrequencyData(i);\r\n      let l = 0;\r\n      for (let p = 0; p < i.length; p++) {\r\n        const S = i[p];\r\n        l += S * S;\r\n      }\r\n      s(Math.sqrt(l / i.length) / 255);\r\n    }, 1e3 / 30);\r\n    return () => {\r\n      c(), clearInterval(f);\r\n    };\r\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), a;\r\n}\r\nconst ct = (e) => {\r\n  const t = (n) => {\r\n    let c = 1 - Math.max(-100, Math.min(-10, n)) * -1 / 100;\r\n    return c = Math.sqrt(c), c;\r\n  };\r\n  return e.map((n) => n === -1 / 0 ? 0 : t(n));\r\n}, ot = {\r\n  bands: 5,\r\n  loPass: 100,\r\n  hiPass: 600,\r\n  updateInterval: 32,\r\n  analyserOptions: { fftSize: 2048 }\r\n};\r\nfunction Zt(e, t = {}) {\r\n  var o;\r\n  const n = e instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track, a = { ...ot, ...t }, [s, c] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\r\n    new Array(a.bands).fill(0)\r\n  );\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!n || !(n != null && n.mediaStream))\r\n      return;\r\n    const { analyser: u, cleanup: i } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(n, a.analyserOptions), d = u.frequencyBinCount, f = new Float32Array(d), p = setInterval(() => {\r\n      u.getFloatFrequencyData(f);\r\n      let S = new Float32Array(f.length);\r\n      for (let h = 0; h < f.length; h++)\r\n        S[h] = f[h];\r\n      S = S.slice(t.loPass, t.hiPass);\r\n      const g = ct(S), m = Math.ceil(g.length / a.bands), y = [];\r\n      for (let h = 0; h < a.bands; h++) {\r\n        const P = g.slice(h * m, (h + 1) * m).reduce((M, O) => M += O, 0);\r\n        y.push(P / m);\r\n      }\r\n      c(y);\r\n    }, a.updateInterval);\r\n    return () => {\r\n      i(), clearInterval(p);\r\n    };\r\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), s;\r\n}\r\nconst it = {\r\n  barCount: 120,\r\n  volMultiplier: 5,\r\n  updateInterval: 20\r\n};\r\nfunction Kt(e, t = {}) {\r\n  var f;\r\n  const n = e instanceof livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track, a = { ...it, ...t }, s = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Float32Array()), c = react__WEBPACK_IMPORTED_MODULE_0__.useRef(performance.now()), o = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0), [u, i] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), d = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((l) => {\r\n    i(\r\n      Array.from(\r\n        dt(l, a.barCount).map((p) => Math.sqrt(p) * a.volMultiplier)\r\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\r\n      )\r\n    );\r\n  }, []);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!n || !(n != null && n.mediaStream))\r\n      return;\r\n    const { analyser: l, cleanup: p } = (0,livekit_client__WEBPACK_IMPORTED_MODULE_1__.createAudioAnalyser)(n, {\r\n      fftSize: U(a.barCount)\r\n    }), S = U(a.barCount), g = new Float32Array(S), m = () => {\r\n      if (y = requestAnimationFrame(m), l.getFloatTimeDomainData(g), s.current.map((h, P) => h + g[P]), o.current += 1, performance.now() - c.current >= a.updateInterval) {\r\n        const h = g.map((P) => P / o.current);\r\n        d(h), c.current = performance.now(), o.current = 0;\r\n      }\r\n    };\r\n    let y = requestAnimationFrame(m);\r\n    return () => {\r\n      p(), cancelAnimationFrame(y);\r\n    };\r\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), d]), {\r\n    bars: u\r\n  };\r\n}\r\nfunction U(e) {\r\n  return e < 32 ? 32 : ut(e);\r\n}\r\nfunction ut(e) {\r\n  let t = 2;\r\n  for (; e >>= 1; )\r\n    t <<= 1;\r\n  return t;\r\n}\r\nfunction dt(e, t) {\r\n  const n = Math.floor(e.length / t), a = new Float32Array(t);\r\n  for (let s = 0; s < t; s++) {\r\n    const c = n * s;\r\n    let o = 0;\r\n    for (let u = 0; u < n; u++)\r\n      o = o + Math.abs(e[c + u]);\r\n    a[s] = o / n;\r\n  }\r\n  return a;\r\n}\r\nfunction q(e, t) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), a = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.B)(), s = t ? n.getParticipantByIdentity(t) : a, c = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => s ? (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a2)(s, { sources: e }) : void 0,\r\n    [s == null ? void 0 : s.sid, s == null ? void 0 : s.identity, JSON.stringify(e)]\r\n  );\r\n  return b(c, []);\r\n}\r\nfunction lt(e) {\r\n  var n, a, s;\r\n  const t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => {\r\n      var c;\r\n      return (c = e == null ? void 0 : e.publication) != null && c.track ? (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a3)(e == null ? void 0 : e.publication.track) : void 0;\r\n    },\r\n    [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]\r\n  );\r\n  return b(t, {\r\n    timestamp: Date.now(),\r\n    rtpTimestamp: (s = (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track) == null ? void 0 : s.rtpTimestamp\r\n  });\r\n}\r\nconst ft = {\r\n  bufferSize: 100\r\n  // maxAge: 2_000,\r\n};\r\nfunction pt(e, t) {\r\n  const n = { ...ft, ...t }, [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]), c = lt(e), o = (u) => {\r\n    var i;\r\n    (i = n.onTranscription) == null || i.call(n, u), s(\r\n      (d) => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a5)(\r\n        d,\r\n        // when first receiving a segment, add the current media timestamp to it\r\n        u.map((f) => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a6)(f, c)),\r\n        n.bufferSize\r\n      )\r\n    );\r\n  };\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!(e != null && e.publication))\r\n      return;\r\n    const u = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a4)(e.publication).subscribe((i) => {\r\n      o(...i);\r\n    });\r\n    return () => {\r\n      u.unsubscribe();\r\n    };\r\n  }, [e && (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.p)(e), o]), { segments: a };\r\n}\r\nfunction bt(e = {}) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.B)(), n = e.participant ?? t, a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    // weird typescript constraint\r\n    () => n ? (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(n) : (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(n),\r\n    [n]\r\n  );\r\n  return b(a, {\r\n    attributes: n == null ? void 0 : n.attributes\r\n  });\r\n}\r\nfunction en(e, t = {}) {\r\n  const n = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.c)(t.participant), [a, s] = react__WEBPACK_IMPORTED_MODULE_0__.useState(n.attributes[e]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!n)\r\n      return;\r\n    const c = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a7)(n).subscribe((o) => {\r\n      o.changed[e] !== void 0 && s(o.attributes[e]);\r\n    });\r\n    return () => {\r\n      c.unsubscribe();\r\n    };\r\n  }, [n, e]), a;\r\n}\r\nconst J = \"lk.agent.state\";\r\nfunction tn() {\r\n  const e = H(), t = e.find(\r\n    (l) => l.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && !(\"lk.publish_on_behalf\" in l.attributes)\r\n  ), n = e.find(\r\n    (l) => l.kind === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ParticipantKind.AGENT && l.attributes[\"lk.publish_on_behalf\"] === (t == null ? void 0 : t.identity)\r\n  ), a = q(\r\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera],\r\n    t == null ? void 0 : t.identity\r\n  ), s = q(\r\n    [livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone, livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera],\r\n    n == null ? void 0 : n.identity\r\n  ), c = a.find((l) => l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone) ?? s.find((l) => l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Microphone), o = a.find((l) => l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera) ?? s.find((l) => l.source === livekit_client__WEBPACK_IMPORTED_MODULE_1__.Track.Source.Camera), { segments: u } = pt(c), i = I(), { attributes: d } = bt({ participant: t }), f = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => i === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected ? \"disconnected\" : i === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Connecting || !t || !(d != null && d[J]) ? \"connecting\" : d[J], [d, t, i]);\r\n  return {\r\n    agent: t,\r\n    state: f,\r\n    audioTrack: c,\r\n    videoTrack: o,\r\n    agentTranscriptions: u,\r\n    agentAttributes: d\r\n  };\r\n}\r\nfunction nn(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(e), n = I(t), a = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a8)(t), [t, n]);\r\n  return b(a, t.isRecording);\r\n}\r\nfunction mt(e) {\r\n  const t = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(), a = I(t) === livekit_client__WEBPACK_IMPORTED_MODULE_1__.ConnectionState.Disconnected, s = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.a9)(t, e), [t, e]);\r\n  return { textStreams: b(a ? void 0 : s, []) };\r\n}\r\nfunction sn(e) {\r\n  const { participantIdentities: t, trackSids: n } = e ?? {}, { textStreams: a } = mt(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.aa.TRANSCRIPTION);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\r\n    () => a.filter(\r\n      (c) => t ? t.includes(c.participantInfo.identity) : !0\r\n    ).filter(\r\n      (c) => {\r\n        var o;\r\n        return n ? n.includes(((o = c.streamInfo.attributes) == null ? void 0 : o[\"lk.transcribed_track_id\"]) ?? \"\") : !0;\r\n      }\r\n    ),\r\n    [a, t, n]\r\n  );\r\n}\r\n\r\n//# sourceMappingURL=hooks-OJtwh4jO.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3QvaG9va3MtT0p0d2g0ak8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUNvakI7QUFDbGlCO0FBQ3VLO0FBQ3BOO0FBQ0EsWUFBWSx5Q0FBUTtBQUNwQixTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVSxHQUFHLHFCQUFxQjtBQUNuRCxFQUFFLGtEQUFpQjtBQUNuQjtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0EsR0FBRztBQUNILFlBQVksOENBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFVO0FBQzNCLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxRkFBcUYsMkNBQVU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSx5REFBQyxTQUFTLDhDQUFhO0FBQ25DO0FBQ0EsR0FBRyxZQUFZLDBDQUFTO0FBQ3hCLFVBQVUseURBQUM7QUFDWDtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSx3QkFBd0IsRUFBRSx5REFBQztBQUNyQyxXQUFXLGFBQWEsMENBQVM7QUFDakMsWUFBWSxlQUFlLEVBQUUseURBQUM7QUFDOUIsV0FBVyxxREFBQztBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0Esa0JBQWtCO0FBQ2xCLFlBQVkseURBQUMsbUJBQW1CLDZDQUE2QyxFQUFFLDBDQUFTO0FBQ3hGLFVBQVUseURBQUM7QUFDWDtBQUNBLGNBQWMsNkRBQUU7QUFDaEIsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZLHlEQUFDLFNBQVMsMENBQVMsT0FBTyx5REFBQztBQUN2QztBQUNBO0FBQ0E7QUFDQSx1RkFBdUYseURBQUMsTUFBTSx3REFBd0QsRUFBRSwwQ0FBUztBQUNqSyxVQUFVLHlEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQztBQUNiLFdBQVcsYUFBYSwwQ0FBUztBQUNqQyxZQUFZLDhCQUE4QixFQUFFLHlEQUFFO0FBQzlDLFdBQVcscURBQUM7QUFDWjtBQUNBO0FBQ0Esc0JBQXNCLDJEQUFDO0FBQ3ZCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixpRUFBRTtBQUNqQztBQUNBO0FBQ0EsY0FBYyxnQkFBZ0IsRUFBRSx3RUFBRTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsWUFBWSx5REFBQyxTQUFTLHlEQUFFLE1BQU0sZUFBZSxFQUFFLDBDQUFTLE9BQU8seURBQUUsYUFBYSwwQ0FBUyxPQUFPLHlEQUFFO0FBQ2hHLFdBQVcsYUFBYSwwQ0FBUztBQUNqQyxVQUFVLHFEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkIscURBQUUsSUFBSSxzQkFBc0IsYUFBYSx5REFBRTtBQUN4RSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzRUFBc0UseURBQUMsa0NBQWtDLDRCQUE0QixjQUFjLDJDQUFVO0FBQzdKO0FBQ0E7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCLGNBQWMseURBQUU7QUFDaEI7QUFDQSxHQUFHLEdBQUcseURBQUM7QUFDUDtBQUNBO0FBQ0EsWUFBWSx5REFBQyxTQUFTLDBDQUFTLE9BQU8seURBQUU7QUFDeEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixZQUFZLHlEQUFDLG1CQUFtQiwyQ0FBVSwrQkFBK0IsMkNBQVU7QUFDbkY7QUFDQSxjQUFjLDJDQUFVO0FBQ3hCO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBLGNBQWMsMkNBQVUsOEJBQThCLDJDQUFVO0FBQ2hFO0FBQ0EsY0FBYywyQ0FBVTtBQUN4QjtBQUNBLGNBQWMsMkNBQVU7QUFDeEI7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEIsY0FBYyx5REFBRTtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQyxRQUFRLDBDQUFTO0FBQzlCLFVBQVUseURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZLHlEQUFDLFFBQVEsMENBQVMscUJBQXFCLGdEQUFFLGlCQUFpQiwwQ0FBUztBQUMvRSxVQUFVLHlEQUFDO0FBQ1g7QUFDQSw0QkFBNEIsMkNBQVU7QUFDdEM7QUFDQSxPQUFPLG1FQUFtRSxFQUFFLDBDQUFTO0FBQ3JGLFVBQVUseURBQUU7QUFDWjtBQUNBO0FBQ0EsU0FBUyw0Q0FBVztBQUNwQjtBQUNBLFlBQVkscURBQUM7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWSwwQ0FBUztBQUNyQixVQUFVLHlEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsWUFBWSx5Q0FBUSxVQUFVLHlDQUFRLHFHQUFxRyx5REFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUFFO0FBQ1osTUFBTTtBQUNOLE1BQU0scURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixVQUFVLHlEQUFDO0FBQ1g7QUFDQSxZQUFZLDBDQUFTLE9BQU8seURBQUUsYUFBYSxvQ0FBb0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQixZQUFZLHlEQUFDLHFCQUFxQiwwQ0FBUyxPQUFPLHlEQUFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVkseURBQUMsU0FBUywwQ0FBUztBQUMvQixZQUFZLGVBQWUsRUFBRSx5REFBRTtBQUMvQixXQUFXLHFEQUFDO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaURBQUMseUJBQXlCLDBDQUFTO0FBQy9FO0FBQ0EsWUFBWSxpREFBQztBQUNiO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixZQUFZLHlEQUFDLG1CQUFtQiwyQ0FBVTtBQUMxQyxTQUFTLDRDQUFXO0FBQ3BCLGNBQWMseURBQUU7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEIsb0JBQW9CLHNCQUFzQjtBQUMxQyxTQUFTLDBDQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFFLEtBQUssMENBQVM7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckIsWUFBWSx5REFBQyxVQUFVLDJDQUFVLHNCQUFzQiwwQ0FBUyw4QkFBOEIseURBQUU7QUFDaEc7QUFDQSxHQUFHLElBQUkseURBQUU7QUFDVDtBQUNBLEdBQUcsd0NBQXdDLDJDQUFVO0FBQ3JEO0FBQ0EsR0FBRztBQUNILFNBQVMsNENBQVc7QUFDcEIscUNBQXFDLE1BQU07QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQkFBa0I7QUFDbEIsWUFBWSx5REFBQyxjQUFjLDBDQUFTLE9BQU8seURBQUUsYUFBYSx1QkFBdUI7QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVkseURBQUMsUUFBUSwwQ0FBUyxPQUFPLHlEQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVTtBQUMzQixJQUFJLHlEQUFDO0FBQ0w7QUFDQSxTQUFTLDRDQUFXO0FBQ3BCLE1BQU0seURBQUM7QUFDUCxHQUFHO0FBQ0g7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQyxZQUFZLHlEQUFDLE9BQU8sbUZBQW1GLEVBQUUsMENBQVM7QUFDbEgsVUFBVSx5REFBRTtBQUNaO0FBQ0EsU0FBUywwQ0FBUztBQUNsQjtBQUNBO0FBQ0EsT0FBTyxrQkFBa0I7QUFDekI7QUFDQSxHQUFHO0FBQ0gsV0FBVyxhQUFhLDBDQUFTO0FBQ2pDLFVBQVUscURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQyxZQUFZLHlEQUFDLE9BQU8sbUZBQW1GLEVBQUUsMENBQVM7QUFDbEgsVUFBVSx5REFBRTtBQUNaO0FBQ0EsU0FBUywwQ0FBUztBQUNsQjtBQUNBO0FBQ0EsT0FBTyxrQkFBa0I7QUFDekI7QUFDQSxHQUFHO0FBQ0gsV0FBVyxhQUFhLDBDQUFTO0FBQ2pDLFVBQVUscURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsWUFBWSx5Q0FBUSxZQUFZLHlDQUFRO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxNQUFNLDhDQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQVc7QUFDYjtBQUNBLHVEQUF1RCxhQUFhLHdDQUF3QyxhQUFhLHVDQUF1QyxhQUFhO0FBQzdLO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFVBQVU7QUFDeEIsVUFBVSx3QkFBd0IsRUFBRSx5REFBQyxhQUFhLGVBQWUsRUFBRSwwQ0FBUyxPQUFPLHlEQUFFO0FBQ3JGLFdBQVcsYUFBYSwwQ0FBUyxPQUFPLHFEQUFDO0FBQ3pDO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QjtBQUN4QixpQkFBaUIsMkNBQVU7QUFDM0IsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFDO0FBQ1Asc0NBQXNDLDRCQUE0QixzQkFBc0IsRUFBRSxHQUFHLGFBQWE7QUFDMUc7QUFDQSxRQUFRLHFEQUFDO0FBQ1QsaUVBQWlFLFNBQVMsSUFBSSxhQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFDLE9BQU8sc0NBQXNDLEVBQUUsMENBQVM7QUFDckUsVUFBVSx5REFBRTtBQUNaLEtBQUsseURBQUM7QUFDTjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZLHlEQUFDLHVHQUF1Ryx5Q0FBUSxRQUFRLGtFQUFrRSxFQUFFLDBDQUFTO0FBQ2pOLGNBQWMseURBQUUsa0JBQWtCLHlEQUFFO0FBQ3BDO0FBQ0E7QUFDQSxFQUFFLDRDQUFXO0FBQ2I7QUFDQSxHQUFHLFdBQVcsNENBQVc7QUFDekIscUJBQXFCLHFEQUFDO0FBQ3RCLEdBQUc7QUFDSCxZQUFZLDBDQUFTLE9BQU8scURBQUMsTUFBTSxjQUFjLGdCQUFnQiw4Q0FBYTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpREFBQztBQUNILEVBQUUsaURBQUM7QUFDSCxFQUFFLGlEQUFDO0FBQ0gsRUFBRSxpREFBQztBQUNILEVBQUUsaURBQUM7QUFDSCxTQUFTO0FBQ1QsWUFBWSx5REFBQyxtQkFBbUIsMkNBQVUsZUFBZSwyQ0FBVSxVQUFVLDBDQUFTLG9CQUFvQix5REFBRTtBQUM1RyxTQUFTLDRDQUFXO0FBQ3BCLGNBQWMseURBQUU7QUFDaEI7QUFDQTtBQUNBLEtBQUssZUFBZSxxQ0FBcUM7QUFDekQsTUFBTSxxREFBQztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMENBQVM7QUFDZixRQUFRLHlEQUFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0EsVUFBVSxxREFBQztBQUNYLG1CQUFtQixHQUFHLDhCQUE4QixXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVSxDQUFDLHlEQUFFLFFBQVEsbUJBQW1CLEVBQUUsMENBQVMsT0FBTyx5REFBRTtBQUM3RSxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsaURBQUM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFDO0FBQ2IsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBLFlBQVkseURBQUMsa0JBQWtCLDBDQUFTO0FBQ3hDLGdCQUFnQiwyREFBQztBQUNqQjtBQUNBLFNBQVMsMENBQVM7QUFDbEIsVUFBVSx5REFBRTtBQUNaO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCLDJDQUFVO0FBQzNCLElBQUkseURBQUU7QUFDTixTQUFTLDhDQUFhO0FBQ3RCLGdCQUFnQix1QkFBdUI7QUFDdkMsR0FBRyxXQUFXLDhDQUFhO0FBQzNCLGdCQUFnQix1QkFBdUI7QUFDdkMsR0FBRyxXQUFXLDhDQUFhO0FBQzNCLGdCQUFnQix3QkFBd0I7QUFDeEMsR0FBRyxXQUFXLDhDQUFhO0FBQzNCLGdCQUFnQix3QkFBd0I7QUFDeEMsR0FBRyxXQUFXLDhDQUFhO0FBQzNCLGdCQUFnQixtQkFBbUI7QUFDbkMsR0FBRztBQUNILFNBQVMsNENBQVc7QUFDcEIsSUFBSSx5REFBRTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVkseURBQUMsU0FBUyx5REFBQyxjQUFjLDBDQUFTLE9BQU8sMERBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1Q0FBdUM7QUFDNUQsWUFBWSwwREFBRSx3Q0FBd0MsMkNBQVU7QUFDaEUsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSxtRUFBQztBQUN6QztBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EseUJBQXlCLGlEQUFDLGtGQUFrRixhQUFhLFdBQVcsMkNBQVU7QUFDOUk7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBLFlBQVksMEJBQTBCLEVBQUUsbUVBQUM7QUFDekM7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx5QkFBeUIsaURBQUMsa0ZBQWtGLGFBQWEsTUFBTSx5Q0FBUSwwQkFBMEIseUNBQVEseUJBQXlCLHlDQUFRLGNBQWMsMkNBQVUsVUFBVSw4Q0FBYTtBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEIsRUFBRSxtRUFBQztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUMsUUFBUSx5REFBQyxtREFBbUQsMENBQVM7QUFDbEYsY0FBYywwREFBRSxNQUFNLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBUztBQUNyQjtBQUNBO0FBQ0EsMkVBQTJFLDBEQUFFO0FBQzdFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxXQUFXLDJDQUFVO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhLDBEQUFFO0FBQ2Y7QUFDQTtBQUNBLHFCQUFxQiwwREFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQVc7QUFDcEI7QUFDQTtBQUNBLGNBQWMsMERBQUU7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRLHlEQUFDLFlBQVk7QUFDeEI7QUFDQSxrQkFBa0I7QUFDbEIsWUFBWSx5REFBQyxnQ0FBZ0MsMENBQVM7QUFDdEQ7QUFDQSxjQUFjLDBEQUFDLE1BQU0sMERBQUM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckIsWUFBWSx5REFBQywwQkFBMEIsMkNBQVU7QUFDakQsU0FBUyw0Q0FBVztBQUNwQjtBQUNBO0FBQ0EsY0FBYywwREFBQztBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBQztBQUN2QjtBQUNBLHNCQUFzQiwyREFBQztBQUN2QjtBQUNBLEtBQUssaURBQUMsb0JBQW9CLGlEQUFDO0FBQzNCO0FBQ0E7QUFDQSxLQUFLLGlEQUFDLG9CQUFvQixpREFBQztBQUMzQjtBQUNBLG9DQUFvQyxpREFBQyxrREFBa0QsaURBQUMsb0RBQW9ELGlEQUFDLDhDQUE4QyxpREFBQyxtQkFBbUIsY0FBYyxvQkFBb0IsZ0JBQWdCLE9BQU8sZ0JBQWdCLE9BQU8sMENBQVMsYUFBYSwyREFBQyx1Q0FBdUMsMkRBQUM7QUFDOVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFDLG1CQUFtQiwwQ0FBUyxPQUFPLDBEQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQUMsaUJBQWlCLDJEQUFDLG1CQUFtQiwwQ0FBUyxPQUFPLDBEQUFFO0FBQ3BFLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVSx5Q0FBeUMsU0FBUyxJQUFJLGlCQUFpQixLQUFLLHNEQUFFO0FBQ3hGLFNBQVMsMENBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVERTtBQUNGIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBsaXZla2l0XFxjb21wb25lbnRzLXJlYWN0XFxkaXN0XFxob29rcy1PSnR3aDRqTy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgciBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdSBhcyBrLCByIGFzIGosIGEgYXMgeCwgYiBhcyBYLCBjIGFzIEEsIGQgYXMgWSwgZSBhcyBaLCBmIGFzIFQsIGcgYXMgSywgaCBhcyBlZSwgaSBhcyBSLCBqIGFzIHRlLCBrIGFzIG5lLCBtIGFzIHNlLCBHIGFzIGFlLCBuIGFzIHJlLCBvIGFzIGNlLCBwIGFzIE4sIHEgYXMgb2UsIHQgYXMgaWUsIHYgYXMgVywgdyBhcyBHLCB4IGFzIFEsIHkgYXMgdWUsIGwgYXMgdywgeiBhcyBkZSwgQSBhcyBsZSwgQiBhcyBGLCBDIGFzIGZlLCBEIGFzIHBlLCBFIGFzIGJlLCBGIGFzIG1lLCBIIGFzIFNlLCBJIGFzIGdlLCBKIGFzIHZlLCBLIGFzIGhlLCBNIGFzIF8sIE4gYXMgTWUsIE8gYXMgeWUsIFAgYXMgUGUsIFEgYXMga2UsIFMgYXMgVGUsIFQgYXMgRWUsIFUgYXMgd2UsIFYgYXMgQWUsIFcgYXMgJCwgWCBhcyBDZSwgWSBhcyBJZSwgWiBhcyBPZSwgXyBhcyBEZSwgJCBhcyBMZSwgYTAgYXMgUmUsIGExIGFzIE5lLCBhMiBhcyBGZSwgYTMgYXMgVmUsIGE0IGFzIF9lLCBhNSBhcyBCZSwgYTYgYXMgemUsIGE3IGFzIEwsIGE4IGFzIFVlLCBhOSBhcyBxZSwgYWEgYXMgSmUgfSBmcm9tIFwiLi9jb250ZXh0cy1DbTFhU0JUcy5tanNcIjtcclxuaW1wb3J0IHsgbSBhcyBFIH0gZnJvbSBcIi4vcm9vbS04ODljT2JMYi5tanNcIjtcclxuaW1wb3J0IHsgQ29ubmVjdGlvblF1YWxpdHkgYXMgeGUsIENvbm5lY3Rpb25TdGF0ZSBhcyBDLCBMb2NhbFRyYWNrUHVibGljYXRpb24gYXMgV2UsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayBhcyBHZSwgUm9vbSBhcyBRZSwgVHJhY2sgYXMgdiwgY3JlYXRlQXVkaW9BbmFseXNlciBhcyBWLCBQYXJ0aWNpcGFudEtpbmQgYXMgQiB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xyXG5jb25zdCAkZSA9IChlKSA9PiB7XHJcbiAgY29uc3QgdCA9IHIudXNlUmVmKGUpO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICB0LmN1cnJlbnQgPSBlO1xyXG4gIH0pLCB0O1xyXG59O1xyXG5mdW5jdGlvbiBIZShlLCB0KSB7XHJcbiAgY29uc3QgbiA9IFhlKCksIGEgPSAkZSh0KTtcclxuICByZXR1cm4gci51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgbGV0IHMgPSAhMTtcclxuICAgIGNvbnN0IGMgPSBlLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWMpIHJldHVybjtcclxuICAgIGZ1bmN0aW9uIG8odSwgaSkge1xyXG4gICAgICBzIHx8IGEuY3VycmVudCh1LCBpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuID09IG51bGwgfHwgbi5zdWJzY3JpYmUoYywgbyksICgpID0+IHtcclxuICAgICAgcyA9ICEwLCBuID09IG51bGwgfHwgbi51bnN1YnNjcmliZShjLCBvKTtcclxuICAgIH07XHJcbiAgfSwgW2UuY3VycmVudCwgbiwgYV0pLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLm9ic2VydmVyO1xyXG59XHJcbmZ1bmN0aW9uIGplKCkge1xyXG4gIGxldCBlID0gITEsIHQgPSBbXTtcclxuICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA+IFwidVwiKVxyXG4gICAgcmV0dXJuO1xyXG4gIGNvbnN0IGEgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKHMsIGMpID0+IHtcclxuICAgIHQgPSB0LmNvbmNhdChzKSwgZSB8fCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgY29uc3QgbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdC5sZW5ndGg7IHUrKykge1xyXG4gICAgICAgIGlmIChvLmhhcyh0W3VdLnRhcmdldCkpIGNvbnRpbnVlO1xyXG4gICAgICAgIG8uYWRkKHRbdV0udGFyZ2V0KTtcclxuICAgICAgICBjb25zdCBpID0gbi5nZXQodFt1XS50YXJnZXQpO1xyXG4gICAgICAgIGkgPT0gbnVsbCB8fCBpLmZvckVhY2goKGQpID0+IGQodFt1XSwgYykpO1xyXG4gICAgICB9XHJcbiAgICAgIHQgPSBbXSwgZSA9ICExO1xyXG4gICAgfSksIGUgPSAhMDtcclxuICB9KTtcclxuICByZXR1cm4ge1xyXG4gICAgb2JzZXJ2ZXI6IGEsXHJcbiAgICBzdWJzY3JpYmUocywgYykge1xyXG4gICAgICBhLm9ic2VydmUocyk7XHJcbiAgICAgIGNvbnN0IG8gPSBuLmdldChzKSA/PyBbXTtcclxuICAgICAgby5wdXNoKGMpLCBuLnNldChzLCBvKTtcclxuICAgIH0sXHJcbiAgICB1bnN1YnNjcmliZShzLCBjKSB7XHJcbiAgICAgIGNvbnN0IG8gPSBuLmdldChzKSA/PyBbXTtcclxuICAgICAgaWYgKG8ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgYS51bm9ic2VydmUocyksIG4uZGVsZXRlKHMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1ID0gby5pbmRleE9mKGMpO1xyXG4gICAgICB1ICE9PSAtMSAmJiBvLnNwbGljZSh1LCAxKSwgbi5zZXQocywgbyk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5sZXQgRDtcclxuY29uc3QgWGUgPSAoKSA9PiBEIHx8IChEID0gamUoKSksIFllID0gKGUpID0+IHtcclxuICBjb25zdCBbdCwgbl0gPSByLnVzZVN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcclxuICByLnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZS5jdXJyZW50KSB7XHJcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHMsIGhlaWdodDogYyB9ID0gZS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICBuKHsgd2lkdGg6IHMsIGhlaWdodDogYyB9KTtcclxuICAgIH1cclxuICB9LCBbZS5jdXJyZW50XSk7XHJcbiAgY29uc3QgYSA9IHIudXNlQ2FsbGJhY2soXHJcbiAgICAocykgPT4gbihzLmNvbnRlbnRSZWN0KSxcclxuICAgIFtdXHJcbiAgKTtcclxuICByZXR1cm4gSGUoZSwgYSksIHQ7XHJcbn07XHJcbmZ1bmN0aW9uIGIoZSwgdCwgbiA9ICEwKSB7XHJcbiAgY29uc3QgW2EsIHNdID0gci51c2VTdGF0ZSh0KTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG4gJiYgcyh0KSwgdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8ICFlKSByZXR1cm47XHJcbiAgICBjb25zdCBjID0gZS5zdWJzY3JpYmUocyk7XHJcbiAgICByZXR1cm4gKCkgPT4gYy51bnN1YnNjcmliZSgpO1xyXG4gIH0sIFtlLCBuXSksIGE7XHJcbn1cclxuZnVuY3Rpb24gaHQoZSkge1xyXG4gIGNvbnN0IHQgPSAoYykgPT4gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93Lm1hdGNoTWVkaWEoYykubWF0Y2hlcyA6ICExLCBbbiwgYV0gPSByLnVzZVN0YXRlKHQoZSkpO1xyXG4gIGZ1bmN0aW9uIHMoKSB7XHJcbiAgICBhKHQoZSkpO1xyXG4gIH1cclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgYyA9IHdpbmRvdy5tYXRjaE1lZGlhKGUpO1xyXG4gICAgcmV0dXJuIHMoKSwgYy5hZGRMaXN0ZW5lciA/IGMuYWRkTGlzdGVuZXIocykgOiBjLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcyksICgpID0+IHtcclxuICAgICAgYy5yZW1vdmVMaXN0ZW5lciA/IGMucmVtb3ZlTGlzdGVuZXIocykgOiBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcyk7XHJcbiAgICB9O1xyXG4gIH0sIFtlXSksIG47XHJcbn1cclxuZnVuY3Rpb24gTXQoZSkge1xyXG4gIGNvbnN0IHQgPSBrKGUpLCBuID0gci51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCB0LnN0YXJ0QXVkaW8oKTtcclxuICB9LCBbdF0pLCBhID0gci51c2VNZW1vKFxyXG4gICAgKCkgPT4gaih0KSxcclxuICAgIFt0XVxyXG4gICksIHsgY2FuUGxheUF1ZGlvOiBzIH0gPSBiKGEsIHtcclxuICAgIGNhblBsYXlBdWRpbzogdC5jYW5QbGF5YmFja0F1ZGlvXHJcbiAgfSk7XHJcbiAgcmV0dXJuIHsgY2FuUGxheUF1ZGlvOiBzLCBzdGFydEF1ZGlvOiBuIH07XHJcbn1cclxuZnVuY3Rpb24geXQoZSkge1xyXG4gIGNvbnN0IHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBuIH0gPSB4KCkucGluO1xyXG4gIHJldHVybiB7IGJ1dHRvblByb3BzOiByLnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgeyBjbGFzc05hbWU6IHMgfSA9IFgoKTtcclxuICAgIHJldHVybiBFKGUsIHtcclxuICAgICAgY2xhc3NOYW1lOiBzLFxyXG4gICAgICBkaXNhYmxlZDogISh0ICE9IG51bGwgJiYgdC5sZW5ndGgpLFxyXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgbiAmJiBuKHsgbXNnOiBcImNsZWFyX3BpblwiIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LCBbZSwgbiwgdF0pIH07XHJcbn1cclxuZnVuY3Rpb24gUHQoZSA9IHt9KSB7XHJcbiAgY29uc3QgdCA9IEEoZS5wYXJ0aWNpcGFudCksIHsgY2xhc3NOYW1lOiBuLCBjb25uZWN0aW9uUXVhbGl0eU9ic2VydmVyOiBhIH0gPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBZKHQpLFxyXG4gICAgW3RdXHJcbiAgKSwgcyA9IGIoYSwgeGUuVW5rbm93bik7XHJcbiAgcmV0dXJuIHsgY2xhc3NOYW1lOiBuLCBxdWFsaXR5OiBzIH07XHJcbn1cclxuZnVuY3Rpb24gSShlKSB7XHJcbiAgY29uc3QgdCA9IGsoZSksIG4gPSByLnVzZU1lbW8oKCkgPT4gWih0KSwgW3RdKTtcclxuICByZXR1cm4gYihuLCB0LnN0YXRlKTtcclxufVxyXG5mdW5jdGlvbiBrdChlLCB0KSB7XHJcbiAgY29uc3QgbiA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiB0LCBhID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiB2b2lkIDAsIHMgPSBUKCksIHsgc2VuZDogYywgbWVzc2FnZU9ic2VydmFibGU6IG8sIGlzU2VuZGluZ09ic2VydmFibGU6IHUgfSA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IEsocywgYSwgbiksXHJcbiAgICBbcywgYSwgbl1cclxuICApLCBpID0gYihvLCB2b2lkIDApLCBkID0gYih1LCAhMSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIG1lc3NhZ2U6IGksXHJcbiAgICBzZW5kOiBjLFxyXG4gICAgaXNTZW5kaW5nOiBkXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBUdChlKSB7XHJcbiAgY29uc3QgdCA9IFQoKSwgbiA9IEkodCk7XHJcbiAgcmV0dXJuIHsgYnV0dG9uUHJvcHM6IHIudXNlTWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogcywgZGlzY29ubmVjdDogYyB9ID0gZWUodCk7XHJcbiAgICByZXR1cm4gRShlLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogcyxcclxuICAgICAgb25DbGljazogKCkgPT4gYyhlLnN0b3BUcmFja3MgPz8gITApLFxyXG4gICAgICBkaXNhYmxlZDogbiA9PT0gQy5EaXNjb25uZWN0ZWRcclxuICAgIH0pO1xyXG4gIH0sIFt0LCBlLCBuXSkgfTtcclxufVxyXG5mdW5jdGlvbiBaZShlKSB7XHJcbiAgaWYgKGUucHVibGljYXRpb24gaW5zdGFuY2VvZiBXZSkge1xyXG4gICAgY29uc3QgdCA9IGUucHVibGljYXRpb24udHJhY2s7XHJcbiAgICBpZiAodCkge1xyXG4gICAgICBjb25zdCB7IGZhY2luZ01vZGU6IG4gfSA9IEdlKHQpO1xyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XHJcbn1cclxuZnVuY3Rpb24gRXQoeyB0cmFja1JlZjogZSwgcHJvcHM6IHQgfSkge1xyXG4gIGNvbnN0IG4gPSBSKGUpLCBhID0gdGUoKSwgeyBjbGFzc05hbWU6IHMgfSA9IHIudXNlTWVtbygoKSA9PiBuZSgpLCBbXSksIGMgPSByLnVzZU1lbW8oKCkgPT4gc2UobiwgYSA9PSBudWxsID8gdm9pZCAwIDogYS5waW4uc3RhdGUpLCBbbiwgYSA9PSBudWxsID8gdm9pZCAwIDogYS5waW4uc3RhdGVdKTtcclxuICByZXR1cm4geyBtZXJnZWRQcm9wczogci51c2VNZW1vKFxyXG4gICAgKCkgPT4gRSh0LCB7XHJcbiAgICAgIGNsYXNzTmFtZTogcyxcclxuICAgICAgb25DbGljazogKHUpID0+IHtcclxuICAgICAgICB2YXIgaSwgZCwgZiwgbCwgcDtcclxuICAgICAgICAoaSA9IHQub25DbGljaykgPT0gbnVsbCB8fCBpLmNhbGwodCwgdSksIGMgPyAoZiA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IChkID0gYS5waW4pLmRpc3BhdGNoKSA9PSBudWxsIHx8IGYuY2FsbChkLCB7XHJcbiAgICAgICAgICBtc2c6IFwiY2xlYXJfcGluXCJcclxuICAgICAgICB9KSA6IChwID0gYSA9PSBudWxsID8gdm9pZCAwIDogKGwgPSBhLnBpbikuZGlzcGF0Y2gpID09IG51bGwgfHwgcC5jYWxsKGwsIHtcclxuICAgICAgICAgIG1zZzogXCJzZXRfcGluXCIsXHJcbiAgICAgICAgICB0cmFja1JlZmVyZW5jZTogblxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KSxcclxuICAgIFt0LCBzLCBuLCBjLCBhID09IG51bGwgPyB2b2lkIDAgOiBhLnBpbl1cclxuICApLCBpbkZvY3VzOiBjIH07XHJcbn1cclxuZnVuY3Rpb24gd3QoZSwgdCwgbiA9IHt9KSB7XHJcbiAgY29uc3QgYSA9IG4uZ3JpZExheW91dHMgPz8gYWUsIHsgd2lkdGg6IHMsIGhlaWdodDogYyB9ID0gWWUoZSksIG8gPSByZShhLCB0LCBzLCBjKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZS5jdXJyZW50ICYmIG8gJiYgKGUuY3VycmVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tbGstY29sLWNvdW50XCIsIG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uY29sdW1ucy50b1N0cmluZygpKSwgZS5jdXJyZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1say1yb3ctY291bnRcIiwgbyA9PSBudWxsID8gdm9pZCAwIDogby5yb3dzLnRvU3RyaW5nKCkpKTtcclxuICB9LCBbZSwgb10pLCB7XHJcbiAgICBsYXlvdXQ6IG8sXHJcbiAgICBjb250YWluZXJXaWR0aDogcyxcclxuICAgIGNvbnRhaW5lckhlaWdodDogY1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24geihlLCB0ID0ge30pIHtcclxuICB2YXIgdSwgaTtcclxuICBjb25zdCBuID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHQucGFydGljaXBhbnQgOiBlLnBhcnRpY2lwYW50LCBhID0gQShuKSwgcyA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB7IHBhcnRpY2lwYW50OiBhLCBzb3VyY2U6IGUgfSA6IGUsIFtjLCBvXSA9IHIudXNlU3RhdGUoXHJcbiAgICAhISgodSA9IHMucHVibGljYXRpb24pICE9IG51bGwgJiYgdS5pc011dGVkIHx8IChpID0gYS5nZXRUcmFja1B1YmxpY2F0aW9uKHMuc291cmNlKSkgIT0gbnVsbCAmJiBpLmlzTXV0ZWQpXHJcbiAgKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZCA9IGNlKHMpLnN1YnNjcmliZShvKTtcclxuICAgIHJldHVybiAoKSA9PiBkLnVuc3Vic2NyaWJlKCk7XHJcbiAgfSwgW04ocyldKSwgYztcclxufVxyXG5mdW5jdGlvbiBLZShlKSB7XHJcbiAgY29uc3QgdCA9IEEoZSksIG4gPSByLnVzZU1lbW8oKCkgPT4gb2UodCksIFt0XSk7XHJcbiAgcmV0dXJuIGIobiwgdC5pc1NwZWFraW5nKTtcclxufVxyXG5mdW5jdGlvbiBldChlID0ge30pIHtcclxuICBjb25zdCB0ID0gayhlLnJvb20pLCBbbiwgYV0gPSByLnVzZVN0YXRlKHQubG9jYWxQYXJ0aWNpcGFudCksIFtzLCBjXSA9IHIudXNlU3RhdGUoXHJcbiAgICBuLmlzTWljcm9waG9uZUVuYWJsZWRcclxuICApLCBbbywgdV0gPSByLnVzZVN0YXRlKFxyXG4gICAgbi5pc01pY3JvcGhvbmVFbmFibGVkXHJcbiAgKSwgW2ksIGRdID0gci51c2VTdGF0ZShcclxuICAgIG4ubGFzdE1pY3JvcGhvbmVFcnJvclxyXG4gICksIFtmLCBsXSA9IHIudXNlU3RhdGUobi5sYXN0Q2FtZXJhRXJyb3IpLCBbcCwgU10gPSByLnVzZVN0YXRlKFxyXG4gICAgbi5pc01pY3JvcGhvbmVFbmFibGVkXHJcbiAgKSwgW2csIG1dID0gci51c2VTdGF0ZShcclxuICAgIHZvaWQgMFxyXG4gICksIFt5LCBoXSA9IHIudXNlU3RhdGUodm9pZCAwKSwgUCA9IChNKSA9PiB7XHJcbiAgICB1KE0uaXNDYW1lcmFFbmFibGVkKSwgYyhNLmlzTWljcm9waG9uZUVuYWJsZWQpLCBTKE0uaXNTY3JlZW5TaGFyZUVuYWJsZWQpLCBoKE0uY2FtZXJhVHJhY2spLCBtKE0ubWljcm9waG9uZVRyYWNrKSwgZChNLnBhcnRpY2lwYW50Lmxhc3RNaWNyb3Bob25lRXJyb3IpLCBsKE0ucGFydGljaXBhbnQubGFzdENhbWVyYUVycm9yKSwgYShNLnBhcnRpY2lwYW50KTtcclxuICB9O1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBNID0gaWUodC5sb2NhbFBhcnRpY2lwYW50KS5zdWJzY3JpYmUoUCk7XHJcbiAgICByZXR1cm4gKCkgPT4gTS51bnN1YnNjcmliZSgpO1xyXG4gIH0sIFt0XSksIHtcclxuICAgIGlzTWljcm9waG9uZUVuYWJsZWQ6IHMsXHJcbiAgICBpc1NjcmVlblNoYXJlRW5hYmxlZDogcCxcclxuICAgIGlzQ2FtZXJhRW5hYmxlZDogbyxcclxuICAgIG1pY3JvcGhvbmVUcmFjazogZyxcclxuICAgIGNhbWVyYVRyYWNrOiB5LFxyXG4gICAgbGFzdE1pY3JvcGhvbmVFcnJvcjogaSxcclxuICAgIGxhc3RDYW1lcmFFcnJvcjogZixcclxuICAgIGxvY2FsUGFydGljaXBhbnQ6IG5cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIEF0KCkge1xyXG4gIGNvbnN0IGUgPSBUKCksIHQgPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBXKGUubG9jYWxQYXJ0aWNpcGFudCksXHJcbiAgICBbZV1cclxuICApO1xyXG4gIHJldHVybiBiKHQsIGUubG9jYWxQYXJ0aWNpcGFudC5wZXJtaXNzaW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gQ3Qoe1xyXG4gIGtpbmQ6IGUsXHJcbiAgcm9vbTogdCxcclxuICB0cmFjazogbixcclxuICByZXF1ZXN0UGVybWlzc2lvbnM6IGEsXHJcbiAgb25FcnJvcjogc1xyXG59KSB7XHJcbiAgY29uc3QgYyA9IEcoKSwgbyA9IHIudXNlTWVtbygoKSA9PiB0ID8/IGMgPz8gbmV3IFFlKCksIFt0LCBjXSksIHUgPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBRKGUsIHMsIGEpLFxyXG4gICAgW2UsIGEsIHNdXHJcbiAgKSwgaSA9IGIodSwgW10pLCBbZCwgZl0gPSByLnVzZVN0YXRlKFxyXG4gICAgKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ2V0QWN0aXZlRGV2aWNlKGUpKSA/PyBcImRlZmF1bHRcIlxyXG4gICksIHsgY2xhc3NOYW1lOiBsLCBhY3RpdmVEZXZpY2VPYnNlcnZhYmxlOiBwLCBzZXRBY3RpdmVNZWRpYURldmljZTogUyB9ID0gci51c2VNZW1vKFxyXG4gICAgKCkgPT4gdWUoZSwgbyksXHJcbiAgICBbZSwgbywgbl1cclxuICApO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBnID0gcC5zdWJzY3JpYmUoKG0pID0+IHtcclxuICAgICAgbSAmJiAody5pbmZvKFwic2V0Q3VycmVudERldmljZUlkXCIsIG0pLCBmKG0pKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgZyA9PSBudWxsIHx8IGcudW5zdWJzY3JpYmUoKTtcclxuICAgIH07XHJcbiAgfSwgW3BdKSwgeyBkZXZpY2VzOiBpLCBjbGFzc05hbWU6IGwsIGFjdGl2ZURldmljZUlkOiBkLCBzZXRBY3RpdmVNZWRpYURldmljZTogUyB9O1xyXG59XHJcbmZ1bmN0aW9uIEl0KHtcclxuICBraW5kOiBlLFxyXG4gIG9uRXJyb3I6IHRcclxufSkge1xyXG4gIGNvbnN0IG4gPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBRKGUsIHQpLFxyXG4gICAgW2UsIHRdXHJcbiAgKTtcclxuICByZXR1cm4gYihuLCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gdHQoZSwgdCwgbiA9IHt9KSB7XHJcbiAgY29uc3QgYSA9IHIudXNlUmVmKFtdKSwgcyA9IHIudXNlUmVmKC0xKSwgYyA9IHQgIT09IHMuY3VycmVudCwgbyA9IHR5cGVvZiBuLmN1c3RvbVNvcnRGdW5jdGlvbiA9PSBcImZ1bmN0aW9uXCIgPyBuLmN1c3RvbVNvcnRGdW5jdGlvbihlKSA6IGRlKGUpO1xyXG4gIGxldCB1ID0gWy4uLm9dO1xyXG4gIGlmIChjID09PSAhMSlcclxuICAgIHRyeSB7XHJcbiAgICAgIHUgPSBsZShhLmN1cnJlbnQsIG8sIHQpO1xyXG4gICAgfSBjYXRjaCAoaSkge1xyXG4gICAgICB3LmVycm9yKFwiRXJyb3Igd2hpbGUgcnVubmluZyB1cGRhdGVQYWdlcygpOiBcIiwgaSk7XHJcbiAgICB9XHJcbiAgcmV0dXJuIGMgPyBhLmN1cnJlbnQgPSBvIDogYS5jdXJyZW50ID0gdSwgcy5jdXJyZW50ID0gdCwgdTtcclxufVxyXG5mdW5jdGlvbiBPdChlLCB0KSB7XHJcbiAgY29uc3QgW24sIGFdID0gci51c2VTdGF0ZSgxKSwgcyA9IE1hdGgubWF4KE1hdGguY2VpbCh0Lmxlbmd0aCAvIGUpLCAxKTtcclxuICBuID4gcyAmJiBhKHMpO1xyXG4gIGNvbnN0IGMgPSBuICogZSwgbyA9IGMgLSBlLCB1ID0gKGwpID0+IHtcclxuICAgIGEoKHApID0+IGwgPT09IFwibmV4dFwiID8gcCA9PT0gcyA/IHAgOiBwICsgMSA6IHAgPT09IDEgPyBwIDogcCAtIDEpO1xyXG4gIH0sIGkgPSAobCkgPT4ge1xyXG4gICAgbCA+IHMgPyBhKHMpIDogbCA8IDEgPyBhKDEpIDogYShsKTtcclxuICB9LCBmID0gdHQodCwgZSkuc2xpY2UobywgYyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvdGFsUGFnZUNvdW50OiBzLFxyXG4gICAgbmV4dFBhZ2U6ICgpID0+IHUoXCJuZXh0XCIpLFxyXG4gICAgcHJldlBhZ2U6ICgpID0+IHUoXCJwcmV2aW91c1wiKSxcclxuICAgIHNldFBhZ2U6IGksXHJcbiAgICBmaXJzdEl0ZW1JbmRleDogbyxcclxuICAgIGxhc3RJdGVtSW5kZXg6IGMsXHJcbiAgICB0cmFja3M6IGYsXHJcbiAgICBjdXJyZW50UGFnZTogblxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gRHQoZSA9IHt9KSB7XHJcbiAgbGV0IHQgPSBGKCk7XHJcbiAgZS5wYXJ0aWNpcGFudCAmJiAodCA9IGUucGFydGljaXBhbnQpO1xyXG4gIGNvbnN0IG4gPSByLnVzZU1lbW8oKCkgPT4gZmUodCksIFt0XSksIHsgaWRlbnRpdHk6IGEsIG5hbWU6IHMsIG1ldGFkYXRhOiBjIH0gPSBiKG4sIHtcclxuICAgIG5hbWU6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubmFtZSxcclxuICAgIGlkZW50aXR5OiB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlkZW50aXR5LFxyXG4gICAgbWV0YWRhdGE6IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWV0YWRhdGFcclxuICB9KTtcclxuICByZXR1cm4geyBpZGVudGl0eTogYSwgbmFtZTogcywgbWV0YWRhdGE6IGMgfTtcclxufVxyXG5mdW5jdGlvbiBMdChlID0ge30pIHtcclxuICBjb25zdCB0ID0gQShlLnBhcnRpY2lwYW50KSwgbiA9IHIudXNlTWVtbygoKSA9PiBXKHQpLCBbdF0pO1xyXG4gIHJldHVybiBiKG4sIHQucGVybWlzc2lvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIFJ0KHtcclxuICB0cmFja1JlZjogZSxcclxuICBvblBhcnRpY2lwYW50Q2xpY2s6IHQsXHJcbiAgZGlzYWJsZVNwZWFraW5nSW5kaWNhdG9yOiBuLFxyXG4gIGh0bWxQcm9wczogYVxyXG59KSB7XHJcbiAgY29uc3QgcyA9IFIoZSksIGMgPSByLnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgeyBjbGFzc05hbWU6IHAgfSA9IHBlKCk7XHJcbiAgICByZXR1cm4gRShhLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogcCxcclxuICAgICAgb25DbGljazogKFMpID0+IHtcclxuICAgICAgICB2YXIgZztcclxuICAgICAgICBpZiAoKGcgPSBhLm9uQ2xpY2spID09IG51bGwgfHwgZy5jYWxsKGEsIFMpLCB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgIGNvbnN0IG0gPSBzLnB1YmxpY2F0aW9uID8/IHMucGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbihzLnNvdXJjZSk7XHJcbiAgICAgICAgICB0KHsgcGFydGljaXBhbnQ6IHMucGFydGljaXBhbnQsIHRyYWNrOiBtIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSwgW1xyXG4gICAgYSxcclxuICAgIHQsXHJcbiAgICBzLnB1YmxpY2F0aW9uLFxyXG4gICAgcy5zb3VyY2UsXHJcbiAgICBzLnBhcnRpY2lwYW50XHJcbiAgXSksIG8gPSBzLnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odi5Tb3VyY2UuTWljcm9waG9uZSksIHUgPSByLnVzZU1lbW8oKCkgPT4gKHtcclxuICAgIHBhcnRpY2lwYW50OiBzLnBhcnRpY2lwYW50LFxyXG4gICAgc291cmNlOiB2LlNvdXJjZS5NaWNyb3Bob25lLFxyXG4gICAgcHVibGljYXRpb246IG9cclxuICB9KSwgW28sIHMucGFydGljaXBhbnRdKSwgaSA9IHoocyksIGQgPSB6KHUpLCBmID0gS2Uocy5wYXJ0aWNpcGFudCksIGwgPSBaZShzKTtcclxuICByZXR1cm4ge1xyXG4gICAgZWxlbWVudFByb3BzOiB7XHJcbiAgICAgIFwiZGF0YS1say1hdWRpby1tdXRlZFwiOiBkLFxyXG4gICAgICBcImRhdGEtbGstdmlkZW8tbXV0ZWRcIjogaSxcclxuICAgICAgXCJkYXRhLWxrLXNwZWFraW5nXCI6IG4gPT09ICEwID8gITEgOiBmLFxyXG4gICAgICBcImRhdGEtbGstbG9jYWwtcGFydGljaXBhbnRcIjogcy5wYXJ0aWNpcGFudC5pc0xvY2FsLFxyXG4gICAgICBcImRhdGEtbGstc291cmNlXCI6IHMuc291cmNlLFxyXG4gICAgICBcImRhdGEtbGstZmFjaW5nLW1vZGVcIjogbCxcclxuICAgICAgLi4uY1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gSChlID0ge30pIHtcclxuICBjb25zdCB0ID0gayhlLnJvb20pLCBbbiwgYV0gPSByLnVzZVN0YXRlKFtdKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgcyA9IGJlKHQsIHtcclxuICAgICAgYWRkaXRpb25hbFJvb21FdmVudHM6IGUudXBkYXRlT25seU9uXHJcbiAgICB9KS5zdWJzY3JpYmUoYSk7XHJcbiAgICByZXR1cm4gKCkgPT4gcy51bnN1YnNjcmliZSgpO1xyXG4gIH0sIFt0LCBKU09OLnN0cmluZ2lmeShlLnVwZGF0ZU9ubHlPbildKSwgbjtcclxufVxyXG5mdW5jdGlvbiBOdChlID0ge30pIHtcclxuICBjb25zdCB0ID0gSChlKSwgeyBsb2NhbFBhcnRpY2lwYW50OiBuIH0gPSBldChlKTtcclxuICByZXR1cm4gci51c2VNZW1vKFxyXG4gICAgKCkgPT4gW24sIC4uLnRdLFxyXG4gICAgW24sIHRdXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBGdChlKSB7XHJcbiAgcmV0dXJuIGUgPSBtZShlKSwgci51c2VNZW1vKCgpID0+IChlID09IG51bGwgPyB2b2lkIDAgOiBlLnBpbi5zdGF0ZSkgIT09IHZvaWQgMCAmJiBlLnBpbi5zdGF0ZS5sZW5ndGggPj0gMSA/IGUucGluLnN0YXRlIDogW10sIFtlLnBpbi5zdGF0ZV0pO1xyXG59XHJcbmZ1bmN0aW9uIFZ0KGUsIHQgPSB7fSkge1xyXG4gIGNvbnN0IG4gPSBUKCksIFthXSA9IHIudXNlU3RhdGUodC51cGRhdGVPbmx5T24pLCBzID0gci51c2VNZW1vKCgpID0+IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBTZShuLCBlLCB7XHJcbiAgICBhZGRpdGlvbmFsRXZlbnRzOiBhXHJcbiAgfSkgOiBnZShuLCBlLCB7XHJcbiAgICBhZGRpdGlvbmFsRXZlbnRzOiBhXHJcbiAgfSksIFtuLCBKU09OLnN0cmluZ2lmeShlKSwgYV0pLCBbYywgb10gPSByLnVzZVN0YXRlKHtcclxuICAgIHA6IHZvaWQgMFxyXG4gIH0pO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB1ID0gcy5zdWJzY3JpYmUoKGkpID0+IG8oeyBwOiBpIH0pKTtcclxuICAgIHJldHVybiAoKSA9PiB1LnVuc3Vic2NyaWJlKCk7XHJcbiAgfSwgW3NdKSwgYy5wO1xyXG59XHJcbmZ1bmN0aW9uIF90KGUgPSB7fSkge1xyXG4gIGNvbnN0IHQgPSBrKGUucm9vbSksIG4gPSByLnVzZU1lbW8oKCkgPT4gdmUodCksIFt0XSksIHsgbmFtZTogYSwgbWV0YWRhdGE6IHMgfSA9IGIobiwge1xyXG4gICAgbmFtZTogdC5uYW1lLFxyXG4gICAgbWV0YWRhdGE6IHQubWV0YWRhdGFcclxuICB9KTtcclxuICByZXR1cm4geyBuYW1lOiBhLCBtZXRhZGF0YTogcyB9O1xyXG59XHJcbmZ1bmN0aW9uIG50KCkge1xyXG4gIGNvbnN0IGUgPSBUKCksIHQgPSByLnVzZU1lbW8oKCkgPT4gaGUoZSksIFtlXSk7XHJcbiAgcmV0dXJuIGIodCwgZS5hY3RpdmVTcGVha2Vycyk7XHJcbn1cclxuZnVuY3Rpb24gQnQoZSkge1xyXG4gIGNvbnN0IFt0LCBuXSA9IHIudXNlU3RhdGUoXHJcbiAgICBfKGUpXHJcbiAgKSwgYSA9IG50KCk7XHJcbiAgcmV0dXJuIHIudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG4oXyhlKSk7XHJcbiAgfSwgW2EsIGVdKSwgdDtcclxufVxyXG5mdW5jdGlvbiB6dCh7IHJvb206IGUsIHByb3BzOiB0IH0pIHtcclxuICBjb25zdCBuID0gayhlKSwgeyBjbGFzc05hbWU6IGEsIHJvb21BdWRpb1BsYXliYWNrQWxsb3dlZE9ic2VydmFibGU6IHMsIGhhbmRsZVN0YXJ0QXVkaW9QbGF5YmFjazogYyB9ID0gci51c2VNZW1vKFxyXG4gICAgKCkgPT4gTWUoKSxcclxuICAgIFtdXHJcbiAgKSwgbyA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IHMobiksXHJcbiAgICBbbiwgc11cclxuICApLCB7IGNhblBsYXlBdWRpbzogdSB9ID0gYihvLCB7XHJcbiAgICBjYW5QbGF5QXVkaW86IG4uY2FuUGxheWJhY2tBdWRpb1xyXG4gIH0pO1xyXG4gIHJldHVybiB7IG1lcmdlZFByb3BzOiByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBFKHQsIHtcclxuICAgICAgY2xhc3NOYW1lOiBhLFxyXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XHJcbiAgICAgICAgYyhuKTtcclxuICAgICAgfSxcclxuICAgICAgc3R5bGU6IHsgZGlzcGxheTogdSA/IFwibm9uZVwiIDogXCJibG9ja1wiIH1cclxuICAgIH0pLFxyXG4gICAgW3QsIGEsIHUsIGMsIG5dXHJcbiAgKSwgY2FuUGxheUF1ZGlvOiB1IH07XHJcbn1cclxuZnVuY3Rpb24gVXQoeyByb29tOiBlLCBwcm9wczogdCB9KSB7XHJcbiAgY29uc3QgbiA9IGsoZSksIHsgY2xhc3NOYW1lOiBhLCByb29tVmlkZW9QbGF5YmFja0FsbG93ZWRPYnNlcnZhYmxlOiBzLCBoYW5kbGVTdGFydFZpZGVvUGxheWJhY2s6IGMgfSA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IHllKCksXHJcbiAgICBbXVxyXG4gICksIG8gPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBzKG4pLFxyXG4gICAgW24sIHNdXHJcbiAgKSwgeyBjYW5QbGF5VmlkZW86IHUgfSA9IGIobywge1xyXG4gICAgY2FuUGxheVZpZGVvOiBuLmNhblBsYXliYWNrVmlkZW9cclxuICB9KTtcclxuICByZXR1cm4geyBtZXJnZWRQcm9wczogci51c2VNZW1vKFxyXG4gICAgKCkgPT4gRSh0LCB7XHJcbiAgICAgIGNsYXNzTmFtZTogYSxcclxuICAgICAgb25DbGljazogKCkgPT4ge1xyXG4gICAgICAgIGMobik7XHJcbiAgICAgIH0sXHJcbiAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IHUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIiB9XHJcbiAgICB9KSxcclxuICAgIFt0LCBhLCB1LCBjLCBuXVxyXG4gICksIGNhblBsYXlWaWRlbzogdSB9O1xyXG59XHJcbmZ1bmN0aW9uIHF0KGUsIHQgPSB7fSkge1xyXG4gIGNvbnN0IG4gPSByLnVzZVJlZihudWxsKSwgYSA9IHIudXNlUmVmKG51bGwpLCBzID0gdC5taW5Td2lwZURpc3RhbmNlID8/IDUwLCBjID0gKGkpID0+IHtcclxuICAgIGEuY3VycmVudCA9IG51bGwsIG4uY3VycmVudCA9IGkudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYO1xyXG4gIH0sIG8gPSAoaSkgPT4ge1xyXG4gICAgYS5jdXJyZW50ID0gaS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFg7XHJcbiAgfSwgdSA9IHIudXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKCFuLmN1cnJlbnQgfHwgIWEuY3VycmVudClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgaSA9IG4uY3VycmVudCAtIGEuY3VycmVudCwgZCA9IGkgPiBzLCBmID0gaSA8IC1zO1xyXG4gICAgZCAmJiB0Lm9uTGVmdFN3aXBlICYmIHQub25MZWZ0U3dpcGUoKSwgZiAmJiB0Lm9uUmlnaHRTd2lwZSAmJiB0Lm9uUmlnaHRTd2lwZSgpO1xyXG4gIH0sIFtzLCB0XSk7XHJcbiAgci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaSA9IGUuY3VycmVudDtcclxuICAgIHJldHVybiBpICYmIChpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGMsIHsgcGFzc2l2ZTogITAgfSksIGkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvLCB7IHBhc3NpdmU6ICEwIH0pLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB1LCB7IHBhc3NpdmU6ICEwIH0pKSwgKCkgPT4ge1xyXG4gICAgICBpICYmIChpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGMpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbyksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHUpKTtcclxuICAgIH07XHJcbiAgfSwgW2UsIHVdKTtcclxufVxyXG5mdW5jdGlvbiBKdCh7IHByb3BzOiBlIH0pIHtcclxuICBjb25zdCB7IGRpc3BhdGNoOiB0LCBzdGF0ZTogbiB9ID0geCgpLndpZGdldCwgeyBjbGFzc05hbWU6IGEgfSA9IHIudXNlTWVtbygoKSA9PiBQZSgpLCBbXSk7XHJcbiAgcmV0dXJuIHsgbWVyZ2VkUHJvcHM6IHIudXNlTWVtbygoKSA9PiBFKGUsIHtcclxuICAgIGNsYXNzTmFtZTogYSxcclxuICAgIG9uQ2xpY2s6ICgpID0+IHtcclxuICAgICAgdCAmJiB0KHsgbXNnOiBcInRvZ2dsZV9jaGF0XCIgfSk7XHJcbiAgICB9LFxyXG4gICAgXCJhcmlhLXByZXNzZWRcIjogbiAhPSBudWxsICYmIG4uc2hvd0NoYXQgPyBcInRydWVcIiA6IFwiZmFsc2VcIixcclxuICAgIFwiZGF0YS1say11bnJlYWQtbXNnc1wiOiBuID8gbi51bnJlYWRNZXNzYWdlcyA8IDEwID8gbi51bnJlYWRNZXNzYWdlcy50b0ZpeGVkKDApIDogXCI5K1wiIDogXCIwXCJcclxuICB9KSwgW2UsIGEsIHQsIG5dKSB9O1xyXG59XHJcbmZ1bmN0aW9uIHh0KGUsIHQsIG4gPSB7fSkge1xyXG4gIGNvbnN0IFthLCBzXSA9IHIudXNlU3RhdGUodm9pZCAwKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdmFyIG87XHJcbiAgICBpZiAoZSA9PT0gdm9pZCAwKVxyXG4gICAgICB0aHJvdyBFcnJvcihcInRva2VuIGVuZHBvaW50IG5lZWRzIHRvIGJlIGRlZmluZWRcIik7XHJcbiAgICBpZiAoKChvID0gbi51c2VySW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaWRlbnRpdHkpID09PSB2b2lkIDApXHJcbiAgICAgIHJldHVybjtcclxuICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHcuZGVidWcoXCJmZXRjaGluZyB0b2tlblwiKTtcclxuICAgICAgY29uc3QgdSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyAuLi5uLnVzZXJJbmZvLCByb29tTmFtZTogdCB9KSwgaSA9IGF3YWl0IGZldGNoKGAke2V9PyR7dS50b1N0cmluZygpfWApO1xyXG4gICAgICBpZiAoIWkub2spIHtcclxuICAgICAgICB3LmVycm9yKFxyXG4gICAgICAgICAgYENvdWxkIG5vdCBmZXRjaCB0b2tlbi4gU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke2kuc3RhdHVzfTogJHtpLnN0YXR1c1RleHR9YFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHsgYWNjZXNzVG9rZW46IGQgfSA9IGF3YWl0IGkuanNvbigpO1xyXG4gICAgICBzKGQpO1xyXG4gICAgfSkoKTtcclxuICB9LCBbZSwgdCwgSlNPTi5zdHJpbmdpZnkobildKSwgYTtcclxufVxyXG5mdW5jdGlvbiBXdChlKSB7XHJcbiAgdmFyIGMsIG87XHJcbiAgY29uc3QgdCA9IFIoZSksIHsgY2xhc3NOYW1lOiBuLCBtZWRpYU11dGVkT2JzZXJ2ZXI6IGEgfSA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IGtlKHQpLFxyXG4gICAgW04odCldXHJcbiAgKTtcclxuICByZXR1cm4geyBpc011dGVkOiBiKFxyXG4gICAgYSxcclxuICAgICEhKChjID0gdC5wdWJsaWNhdGlvbikgIT0gbnVsbCAmJiBjLmlzTXV0ZWQgfHwgKG8gPSB0LnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odC5zb3VyY2UpKSAhPSBudWxsICYmIG8uaXNNdXRlZClcclxuICApLCBjbGFzc05hbWU6IG4gfTtcclxufVxyXG5mdW5jdGlvbiBHdCh7XHJcbiAgc291cmNlOiBlLFxyXG4gIG9uQ2hhbmdlOiB0LFxyXG4gIGluaXRpYWxTdGF0ZTogbixcclxuICBjYXB0dXJlT3B0aW9uczogYSxcclxuICBwdWJsaXNoT3B0aW9uczogcyxcclxuICBvbkRldmljZUVycm9yOiBjLFxyXG4gIC4uLm9cclxufSkge1xyXG4gIHZhciBQO1xyXG4gIGNvbnN0IHUgPSBHKCksIGkgPSAoUCA9IHUgPT0gbnVsbCA/IHZvaWQgMCA6IHUubG9jYWxQYXJ0aWNpcGFudCkgPT0gbnVsbCA/IHZvaWQgMCA6IFAuZ2V0VHJhY2tQdWJsaWNhdGlvbihlKSwgZCA9IHIudXNlUmVmKCExKSwgeyB0b2dnbGU6IGYsIGNsYXNzTmFtZTogbCwgcGVuZGluZ09ic2VydmVyOiBwLCBlbmFibGVkT2JzZXJ2ZXI6IFMgfSA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IHUgPyBUZShlLCB1LCBhLCBzLCBjKSA6IEVlKCksXHJcbiAgICBbdSwgZSwgSlNPTi5zdHJpbmdpZnkoYSksIHNdXHJcbiAgKSwgZyA9IGIocCwgITEpLCBtID0gYihTLCBuID8/ICEhKGkgIT0gbnVsbCAmJiBpLmlzRW5hYmxlZCkpO1xyXG4gIHIudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHQgPT0gbnVsbCB8fCB0KG0sIGQuY3VycmVudCksIGQuY3VycmVudCA9ICExO1xyXG4gIH0sIFttLCB0XSksIHIudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIG4gIT09IHZvaWQgMCAmJiAody5kZWJ1ZyhcImZvcmNpbmcgaW5pdGlhbCB0b2dnbGUgc3RhdGVcIiwgZSwgbiksIGYobikpO1xyXG4gIH0sIFtdKTtcclxuICBjb25zdCB5ID0gci51c2VNZW1vKCgpID0+IEUobywgeyBjbGFzc05hbWU6IGwgfSksIFtvLCBsXSksIGggPSByLnVzZUNhbGxiYWNrKFxyXG4gICAgKE0pID0+IHtcclxuICAgICAgdmFyIE87XHJcbiAgICAgIGQuY3VycmVudCA9ICEwLCBmKCkuY2F0Y2goKCkgPT4gZC5jdXJyZW50ID0gITEpLCAoTyA9IG8ub25DbGljaykgPT0gbnVsbCB8fCBPLmNhbGwobywgTSk7XHJcbiAgICB9LFxyXG4gICAgW28sIGZdXHJcbiAgKTtcclxuICByZXR1cm4ge1xyXG4gICAgdG9nZ2xlOiBmLFxyXG4gICAgZW5hYmxlZDogbSxcclxuICAgIHBlbmRpbmc6IGcsXHJcbiAgICB0cmFjazogaSxcclxuICAgIGJ1dHRvblByb3BzOiB7XHJcbiAgICAgIC4uLnksXHJcbiAgICAgIFwiYXJpYS1wcmVzc2VkXCI6IG0sXHJcbiAgICAgIFwiZGF0YS1say1zb3VyY2VcIjogZSxcclxuICAgICAgXCJkYXRhLWxrLWVuYWJsZWRcIjogbSxcclxuICAgICAgZGlzYWJsZWQ6IGcsXHJcbiAgICAgIG9uQ2xpY2s6IGhcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIFF0KGUgPSBbXHJcbiAgdi5Tb3VyY2UuQ2FtZXJhLFxyXG4gIHYuU291cmNlLk1pY3JvcGhvbmUsXHJcbiAgdi5Tb3VyY2UuU2NyZWVuU2hhcmUsXHJcbiAgdi5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyxcclxuICB2LlNvdXJjZS5Vbmtub3duXHJcbl0sIHQgPSB7fSkge1xyXG4gIGNvbnN0IG4gPSBrKHQucm9vbSksIFthLCBzXSA9IHIudXNlU3RhdGUoW10pLCBbYywgb10gPSByLnVzZVN0YXRlKFtdKSwgdSA9IHIudXNlTWVtbygoKSA9PiBlLm1hcCgoZCkgPT4gd2UoZCkgPyBkLnNvdXJjZSA6IGQpLCBbSlNPTi5zdHJpbmdpZnkoZSldKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgZCA9IEFlKG4sIHUsIHtcclxuICAgICAgYWRkaXRpb25hbFJvb21FdmVudHM6IHQudXBkYXRlT25seU9uLFxyXG4gICAgICBvbmx5U3Vic2NyaWJlZDogdC5vbmx5U3Vic2NyaWJlZFxyXG4gICAgfSkuc3Vic2NyaWJlKCh7IHRyYWNrUmVmZXJlbmNlczogZiwgcGFydGljaXBhbnRzOiBsIH0pID0+IHtcclxuICAgICAgdy5kZWJ1ZyhcInNldHRpbmcgdHJhY2sgYnVuZGxlc1wiLCBmLCBsKSwgcyhmKSwgbyhsKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IGQudW5zdWJzY3JpYmUoKTtcclxuICB9LCBbXHJcbiAgICBuLFxyXG4gICAgSlNPTi5zdHJpbmdpZnkodC5vbmx5U3Vic2NyaWJlZCksXHJcbiAgICBKU09OLnN0cmluZ2lmeSh0LnVwZGF0ZU9ubHlPbiksXHJcbiAgICBKU09OLnN0cmluZ2lmeShlKVxyXG4gIF0pLCByLnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgaWYgKCQoZSkpIHtcclxuICAgICAgY29uc3QgZCA9IGF0KGUsIGMpLCBmID0gQXJyYXkuZnJvbShhKTtcclxuICAgICAgcmV0dXJuIGMuZm9yRWFjaCgobCkgPT4ge1xyXG4gICAgICAgIGQuaGFzKGwuaWRlbnRpdHkpICYmIChkLmdldChsLmlkZW50aXR5KSA/PyBbXSkuZm9yRWFjaCgoUykgPT4ge1xyXG4gICAgICAgICAgaWYgKGEuZmluZChcclxuICAgICAgICAgICAgKHsgcGFydGljaXBhbnQ6IG0sIHB1YmxpY2F0aW9uOiB5IH0pID0+IGwuaWRlbnRpdHkgPT09IG0uaWRlbnRpdHkgJiYgeS5zb3VyY2UgPT09IFNcclxuICAgICAgICAgICkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIHcuZGVidWcoXHJcbiAgICAgICAgICAgIGBBZGQgJHtTfSBwbGFjZWhvbGRlciBmb3IgcGFydGljaXBhbnQgJHtsLmlkZW50aXR5fS5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc3QgZyA9IHtcclxuICAgICAgICAgICAgcGFydGljaXBhbnQ6IGwsXHJcbiAgICAgICAgICAgIHNvdXJjZTogU1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGYucHVzaChnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSksIGY7XHJcbiAgICB9IGVsc2VcclxuICAgICAgcmV0dXJuIGE7XHJcbiAgfSwgW2EsIGMsIGVdKTtcclxufVxyXG5mdW5jdGlvbiBzdChlLCB0KSB7XHJcbiAgY29uc3QgbiA9IG5ldyBTZXQoZSk7XHJcbiAgZm9yIChjb25zdCBhIG9mIHQpXHJcbiAgICBuLmRlbGV0ZShhKTtcclxuICByZXR1cm4gbjtcclxufVxyXG5mdW5jdGlvbiBhdChlLCB0KSB7XHJcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgaWYgKCQoZSkpIHtcclxuICAgIGNvbnN0IGEgPSBlLmZpbHRlcigocykgPT4gcy53aXRoUGxhY2Vob2xkZXIpLm1hcCgocykgPT4gcy5zb3VyY2UpO1xyXG4gICAgdC5mb3JFYWNoKChzKSA9PiB7XHJcbiAgICAgIGNvbnN0IGMgPSBzLmdldFRyYWNrUHVibGljYXRpb25zKCkubWFwKCh1KSA9PiB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgcmV0dXJuIChpID0gdS50cmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuc291cmNlO1xyXG4gICAgICB9KS5maWx0ZXIoKHUpID0+IHUgIT09IHZvaWQgMCksIG8gPSBBcnJheS5mcm9tKFxyXG4gICAgICAgIHN0KG5ldyBTZXQoYSksIG5ldyBTZXQoYykpXHJcbiAgICAgICk7XHJcbiAgICAgIG8ubGVuZ3RoID4gMCAmJiBuLnNldChzLmlkZW50aXR5LCBvKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbjtcclxufVxyXG5mdW5jdGlvbiBydChlKSB7XHJcbiAgY29uc3QgW3QsIG5dID0gci51c2VTdGF0ZShDZShlKSksIHsgdHJhY2tPYnNlcnZlcjogYSB9ID0gci51c2VNZW1vKCgpID0+IEllKGUpLCBbZS5wYXJ0aWNpcGFudC5zaWQgPz8gZS5wYXJ0aWNpcGFudC5pZGVudGl0eSwgZS5zb3VyY2VdKTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgcyA9IGEuc3Vic2NyaWJlKChjKSA9PiB7XHJcbiAgICAgIG4oYyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiBzID09IG51bGwgPyB2b2lkIDAgOiBzLnVuc3Vic2NyaWJlKCk7XHJcbiAgfSwgW2FdKSwge1xyXG4gICAgcGFydGljaXBhbnQ6IGUucGFydGljaXBhbnQsXHJcbiAgICBzb3VyY2U6IGUuc291cmNlID8/IHYuU291cmNlLlVua25vd24sXHJcbiAgICBwdWJsaWNhdGlvbjogdFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gJHQoZSwgdCkge1xyXG4gIGNvbnN0IG4gPSBBKHQpO1xyXG4gIHJldHVybiBydCh7IG5hbWU6IGUsIHBhcnRpY2lwYW50OiBuIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEh0KGUpIHtcclxuICBjb25zdCB0ID0gVCgpLCBuID0gSSh0KSwgYSA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IG4gPT09IEMuRGlzY29ubmVjdGVkLFxyXG4gICAgW25dXHJcbiAgKSwgcyA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IE9lKHQsIGUpLFxyXG4gICAgW3QsIGUsIGFdXHJcbiAgKSwgYyA9IGIocy5pc1NlbmRpbmdPYnNlcnZhYmxlLCAhMSksIG8gPSBiKHMubWVzc2FnZU9ic2VydmFibGUsIFtdKTtcclxuICByZXR1cm4geyBzZW5kOiBzLnNlbmQsIGNoYXRNZXNzYWdlczogbywgaXNTZW5kaW5nOiBjIH07XHJcbn1cclxuZnVuY3Rpb24ganQoZSA9IHt9KSB7XHJcbiAgY29uc3QgW3QsIG5dID0gci51c2VTdGF0ZShcclxuICAgIERlKGUuZGVmYXVsdHMsIGUucHJldmVudExvYWQgPz8gITEpXHJcbiAgKSwgYSA9IHIudXNlQ2FsbGJhY2soKGkpID0+IHtcclxuICAgIG4oKGQpID0+ICh7IC4uLmQsIGF1ZGlvRW5hYmxlZDogaSB9KSk7XHJcbiAgfSwgW10pLCBzID0gci51c2VDYWxsYmFjaygoaSkgPT4ge1xyXG4gICAgbigoZCkgPT4gKHsgLi4uZCwgdmlkZW9FbmFibGVkOiBpIH0pKTtcclxuICB9LCBbXSksIGMgPSByLnVzZUNhbGxiYWNrKChpKSA9PiB7XHJcbiAgICBuKChkKSA9PiAoeyAuLi5kLCBhdWRpb0RldmljZUlkOiBpIH0pKTtcclxuICB9LCBbXSksIG8gPSByLnVzZUNhbGxiYWNrKChpKSA9PiB7XHJcbiAgICBuKChkKSA9PiAoeyAuLi5kLCB2aWRlb0RldmljZUlkOiBpIH0pKTtcclxuICB9LCBbXSksIHUgPSByLnVzZUNhbGxiYWNrKChpKSA9PiB7XHJcbiAgICBuKChkKSA9PiAoeyAuLi5kLCB1c2VybmFtZTogaSB9KSk7XHJcbiAgfSwgW10pO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBMZSh0LCBlLnByZXZlbnRTYXZlID8/ICExKTtcclxuICB9LCBbdCwgZS5wcmV2ZW50U2F2ZV0pLCB7XHJcbiAgICB1c2VyQ2hvaWNlczogdCxcclxuICAgIHNhdmVBdWRpb0lucHV0RW5hYmxlZDogYSxcclxuICAgIHNhdmVWaWRlb0lucHV0RW5hYmxlZDogcyxcclxuICAgIHNhdmVBdWRpb0lucHV0RGV2aWNlSWQ6IGMsXHJcbiAgICBzYXZlVmlkZW9JbnB1dERldmljZUlkOiBvLFxyXG4gICAgc2F2ZVVzZXJuYW1lOiB1XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBYdChlLCB0ID0ge30pIHtcclxuICBjb25zdCBuID0gQShlKSwgYSA9IGsodC5yb29tKSwgcyA9IHIudXNlTWVtbygoKSA9PiBSZShhLCBuKSwgW2EsIG5dKTtcclxuICByZXR1cm4gYihcclxuICAgIHMsXHJcbiAgICBuLmlzTG9jYWwgPyBuLmlzRTJFRUVuYWJsZWQgOiAhIShuICE9IG51bGwgJiYgbi5pc0VuY3J5cHRlZClcclxuICApO1xyXG59XHJcbmZ1bmN0aW9uIFl0KGUsIHQgPSB7IGZmdFNpemU6IDMyLCBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAgfSkge1xyXG4gIGNvbnN0IG4gPSBOZShlKSA/IGUucHVibGljYXRpb24udHJhY2sgOiBlLCBbYSwgc10gPSByLnVzZVN0YXRlKDApO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW4gfHwgIW4ubWVkaWFTdHJlYW0pXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHsgY2xlYW51cDogYywgYW5hbHlzZXI6IG8gfSA9IFYobiwgdCksIHUgPSBvLmZyZXF1ZW5jeUJpbkNvdW50LCBpID0gbmV3IFVpbnQ4QXJyYXkodSksIGYgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIG8uZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoaSk7XHJcbiAgICAgIGxldCBsID0gMDtcclxuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBpLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgY29uc3QgUyA9IGlbcF07XHJcbiAgICAgICAgbCArPSBTICogUztcclxuICAgICAgfVxyXG4gICAgICBzKE1hdGguc3FydChsIC8gaS5sZW5ndGgpIC8gMjU1KTtcclxuICAgIH0sIDFlMyAvIDMwKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGMoKSwgY2xlYXJJbnRlcnZhbChmKTtcclxuICAgIH07XHJcbiAgfSwgW24sIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubWVkaWFTdHJlYW0sIEpTT04uc3RyaW5naWZ5KHQpXSksIGE7XHJcbn1cclxuY29uc3QgY3QgPSAoZSkgPT4ge1xyXG4gIGNvbnN0IHQgPSAobikgPT4ge1xyXG4gICAgbGV0IGMgPSAxIC0gTWF0aC5tYXgoLTEwMCwgTWF0aC5taW4oLTEwLCBuKSkgKiAtMSAvIDEwMDtcclxuICAgIHJldHVybiBjID0gTWF0aC5zcXJ0KGMpLCBjO1xyXG4gIH07XHJcbiAgcmV0dXJuIGUubWFwKChuKSA9PiBuID09PSAtMSAvIDAgPyAwIDogdChuKSk7XHJcbn0sIG90ID0ge1xyXG4gIGJhbmRzOiA1LFxyXG4gIGxvUGFzczogMTAwLFxyXG4gIGhpUGFzczogNjAwLFxyXG4gIHVwZGF0ZUludGVydmFsOiAzMixcclxuICBhbmFseXNlck9wdGlvbnM6IHsgZmZ0U2l6ZTogMjA0OCB9XHJcbn07XHJcbmZ1bmN0aW9uIFp0KGUsIHQgPSB7fSkge1xyXG4gIHZhciBvO1xyXG4gIGNvbnN0IG4gPSBlIGluc3RhbmNlb2YgdiA/IGUgOiAobyA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBvLnRyYWNrLCBhID0geyAuLi5vdCwgLi4udCB9LCBbcywgY10gPSByLnVzZVN0YXRlKFxyXG4gICAgbmV3IEFycmF5KGEuYmFuZHMpLmZpbGwoMClcclxuICApO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW4gfHwgIShuICE9IG51bGwgJiYgbi5tZWRpYVN0cmVhbSkpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHsgYW5hbHlzZXI6IHUsIGNsZWFudXA6IGkgfSA9IFYobiwgYS5hbmFseXNlck9wdGlvbnMpLCBkID0gdS5mcmVxdWVuY3lCaW5Db3VudCwgZiA9IG5ldyBGbG9hdDMyQXJyYXkoZCksIHAgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIHUuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKGYpO1xyXG4gICAgICBsZXQgUyA9IG5ldyBGbG9hdDMyQXJyYXkoZi5sZW5ndGgpO1xyXG4gICAgICBmb3IgKGxldCBoID0gMDsgaCA8IGYubGVuZ3RoOyBoKyspXHJcbiAgICAgICAgU1toXSA9IGZbaF07XHJcbiAgICAgIFMgPSBTLnNsaWNlKHQubG9QYXNzLCB0LmhpUGFzcyk7XHJcbiAgICAgIGNvbnN0IGcgPSBjdChTKSwgbSA9IE1hdGguY2VpbChnLmxlbmd0aCAvIGEuYmFuZHMpLCB5ID0gW107XHJcbiAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgYS5iYW5kczsgaCsrKSB7XHJcbiAgICAgICAgY29uc3QgUCA9IGcuc2xpY2UoaCAqIG0sIChoICsgMSkgKiBtKS5yZWR1Y2UoKE0sIE8pID0+IE0gKz0gTywgMCk7XHJcbiAgICAgICAgeS5wdXNoKFAgLyBtKTtcclxuICAgICAgfVxyXG4gICAgICBjKHkpO1xyXG4gICAgfSwgYS51cGRhdGVJbnRlcnZhbCk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpKCksIGNsZWFySW50ZXJ2YWwocCk7XHJcbiAgICB9O1xyXG4gIH0sIFtuLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLm1lZGlhU3RyZWFtLCBKU09OLnN0cmluZ2lmeSh0KV0pLCBzO1xyXG59XHJcbmNvbnN0IGl0ID0ge1xyXG4gIGJhckNvdW50OiAxMjAsXHJcbiAgdm9sTXVsdGlwbGllcjogNSxcclxuICB1cGRhdGVJbnRlcnZhbDogMjBcclxufTtcclxuZnVuY3Rpb24gS3QoZSwgdCA9IHt9KSB7XHJcbiAgdmFyIGY7XHJcbiAgY29uc3QgbiA9IGUgaW5zdGFuY2VvZiB2ID8gZSA6IChmID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGYudHJhY2ssIGEgPSB7IC4uLml0LCAuLi50IH0sIHMgPSByLnVzZVJlZihuZXcgRmxvYXQzMkFycmF5KCkpLCBjID0gci51c2VSZWYocGVyZm9ybWFuY2Uubm93KCkpLCBvID0gci51c2VSZWYoMCksIFt1LCBpXSA9IHIudXNlU3RhdGUoW10pLCBkID0gci51c2VDYWxsYmFjaygobCkgPT4ge1xyXG4gICAgaShcclxuICAgICAgQXJyYXkuZnJvbShcclxuICAgICAgICBkdChsLCBhLmJhckNvdW50KS5tYXAoKHApID0+IE1hdGguc3FydChwKSAqIGEudm9sTXVsdGlwbGllcilcclxuICAgICAgICAvLyB3YXZlLnNsaWNlKDAsIG9wdHMuYmFyQ291bnQpLm1hcCgodikgPT4gc2lnbW9pZCh2ICogb3B0cy52b2xNdWx0aXBsaWVyLCAwLjA4LCAwLjIpKSxcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9LCBbXSk7XHJcbiAgcmV0dXJuIHIudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghbiB8fCAhKG4gIT0gbnVsbCAmJiBuLm1lZGlhU3RyZWFtKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgeyBhbmFseXNlcjogbCwgY2xlYW51cDogcCB9ID0gVihuLCB7XHJcbiAgICAgIGZmdFNpemU6IFUoYS5iYXJDb3VudClcclxuICAgIH0pLCBTID0gVShhLmJhckNvdW50KSwgZyA9IG5ldyBGbG9hdDMyQXJyYXkoUyksIG0gPSAoKSA9PiB7XHJcbiAgICAgIGlmICh5ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG0pLCBsLmdldEZsb2F0VGltZURvbWFpbkRhdGEoZyksIHMuY3VycmVudC5tYXAoKGgsIFApID0+IGggKyBnW1BdKSwgby5jdXJyZW50ICs9IDEsIHBlcmZvcm1hbmNlLm5vdygpIC0gYy5jdXJyZW50ID49IGEudXBkYXRlSW50ZXJ2YWwpIHtcclxuICAgICAgICBjb25zdCBoID0gZy5tYXAoKFApID0+IFAgLyBvLmN1cnJlbnQpO1xyXG4gICAgICAgIGQoaCksIGMuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpLCBvLmN1cnJlbnQgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgbGV0IHkgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBwKCksIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHkpO1xyXG4gICAgfTtcclxuICB9LCBbbiwgbiA9PSBudWxsID8gdm9pZCAwIDogbi5tZWRpYVN0cmVhbSwgSlNPTi5zdHJpbmdpZnkodCksIGRdKSwge1xyXG4gICAgYmFyczogdVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gVShlKSB7XHJcbiAgcmV0dXJuIGUgPCAzMiA/IDMyIDogdXQoZSk7XHJcbn1cclxuZnVuY3Rpb24gdXQoZSkge1xyXG4gIGxldCB0ID0gMjtcclxuICBmb3IgKDsgZSA+Pj0gMTsgKVxyXG4gICAgdCA8PD0gMTtcclxuICByZXR1cm4gdDtcclxufVxyXG5mdW5jdGlvbiBkdChlLCB0KSB7XHJcbiAgY29uc3QgbiA9IE1hdGguZmxvb3IoZS5sZW5ndGggLyB0KSwgYSA9IG5ldyBGbG9hdDMyQXJyYXkodCk7XHJcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCB0OyBzKyspIHtcclxuICAgIGNvbnN0IGMgPSBuICogcztcclxuICAgIGxldCBvID0gMDtcclxuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbjsgdSsrKVxyXG4gICAgICBvID0gbyArIE1hdGguYWJzKGVbYyArIHVdKTtcclxuICAgIGFbc10gPSBvIC8gbjtcclxuICB9XHJcbiAgcmV0dXJuIGE7XHJcbn1cclxuZnVuY3Rpb24gcShlLCB0KSB7XHJcbiAgY29uc3QgbiA9IFQoKSwgYSA9IEYoKSwgcyA9IHQgPyBuLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eSh0KSA6IGEsIGMgPSByLnVzZU1lbW8oXHJcbiAgICAoKSA9PiBzID8gRmUocywgeyBzb3VyY2VzOiBlIH0pIDogdm9pZCAwLFxyXG4gICAgW3MgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2lkLCBzID09IG51bGwgPyB2b2lkIDAgOiBzLmlkZW50aXR5LCBKU09OLnN0cmluZ2lmeShlKV1cclxuICApO1xyXG4gIHJldHVybiBiKGMsIFtdKTtcclxufVxyXG5mdW5jdGlvbiBsdChlKSB7XHJcbiAgdmFyIG4sIGEsIHM7XHJcbiAgY29uc3QgdCA9IHIudXNlTWVtbyhcclxuICAgICgpID0+IHtcclxuICAgICAgdmFyIGM7XHJcbiAgICAgIHJldHVybiAoYyA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljYXRpb24pICE9IG51bGwgJiYgYy50cmFjayA/IFZlKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljYXRpb24udHJhY2spIDogdm9pZCAwO1xyXG4gICAgfSxcclxuICAgIFsobiA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucHVibGljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBuLnRyYWNrXVxyXG4gICk7XHJcbiAgcmV0dXJuIGIodCwge1xyXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgcnRwVGltZXN0YW1wOiAocyA9IChhID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5wdWJsaWNhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGEudHJhY2spID09IG51bGwgPyB2b2lkIDAgOiBzLnJ0cFRpbWVzdGFtcFxyXG4gIH0pO1xyXG59XHJcbmNvbnN0IGZ0ID0ge1xyXG4gIGJ1ZmZlclNpemU6IDEwMFxyXG4gIC8vIG1heEFnZTogMl8wMDAsXHJcbn07XHJcbmZ1bmN0aW9uIHB0KGUsIHQpIHtcclxuICBjb25zdCBuID0geyAuLi5mdCwgLi4udCB9LCBbYSwgc10gPSByLnVzZVN0YXRlKFtdKSwgYyA9IGx0KGUpLCBvID0gKHUpID0+IHtcclxuICAgIHZhciBpO1xyXG4gICAgKGkgPSBuLm9uVHJhbnNjcmlwdGlvbikgPT0gbnVsbCB8fCBpLmNhbGwobiwgdSksIHMoXHJcbiAgICAgIChkKSA9PiBCZShcclxuICAgICAgICBkLFxyXG4gICAgICAgIC8vIHdoZW4gZmlyc3QgcmVjZWl2aW5nIGEgc2VnbWVudCwgYWRkIHRoZSBjdXJyZW50IG1lZGlhIHRpbWVzdGFtcCB0byBpdFxyXG4gICAgICAgIHUubWFwKChmKSA9PiB6ZShmLCBjKSksXHJcbiAgICAgICAgbi5idWZmZXJTaXplXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfTtcclxuICByZXR1cm4gci51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCEoZSAhPSBudWxsICYmIGUucHVibGljYXRpb24pKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCB1ID0gX2UoZS5wdWJsaWNhdGlvbikuc3Vic2NyaWJlKChpKSA9PiB7XHJcbiAgICAgIG8oLi4uaSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHUudW5zdWJzY3JpYmUoKTtcclxuICAgIH07XHJcbiAgfSwgW2UgJiYgTihlKSwgb10pLCB7IHNlZ21lbnRzOiBhIH07XHJcbn1cclxuZnVuY3Rpb24gYnQoZSA9IHt9KSB7XHJcbiAgY29uc3QgdCA9IEYoKSwgbiA9IGUucGFydGljaXBhbnQgPz8gdCwgYSA9IHIudXNlTWVtbyhcclxuICAgIC8vIHdlaXJkIHR5cGVzY3JpcHQgY29uc3RyYWludFxyXG4gICAgKCkgPT4gbiA/IEwobikgOiBMKG4pLFxyXG4gICAgW25dXHJcbiAgKTtcclxuICByZXR1cm4gYihhLCB7XHJcbiAgICBhdHRyaWJ1dGVzOiBuID09IG51bGwgPyB2b2lkIDAgOiBuLmF0dHJpYnV0ZXNcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBlbihlLCB0ID0ge30pIHtcclxuICBjb25zdCBuID0gQSh0LnBhcnRpY2lwYW50KSwgW2EsIHNdID0gci51c2VTdGF0ZShuLmF0dHJpYnV0ZXNbZV0pO1xyXG4gIHJldHVybiByLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIW4pXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IGMgPSBMKG4pLnN1YnNjcmliZSgobykgPT4ge1xyXG4gICAgICBvLmNoYW5nZWRbZV0gIT09IHZvaWQgMCAmJiBzKG8uYXR0cmlidXRlc1tlXSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGMudW5zdWJzY3JpYmUoKTtcclxuICAgIH07XHJcbiAgfSwgW24sIGVdKSwgYTtcclxufVxyXG5jb25zdCBKID0gXCJsay5hZ2VudC5zdGF0ZVwiO1xyXG5mdW5jdGlvbiB0bigpIHtcclxuICBjb25zdCBlID0gSCgpLCB0ID0gZS5maW5kKFxyXG4gICAgKGwpID0+IGwua2luZCA9PT0gQi5BR0VOVCAmJiAhKFwibGsucHVibGlzaF9vbl9iZWhhbGZcIiBpbiBsLmF0dHJpYnV0ZXMpXHJcbiAgKSwgbiA9IGUuZmluZChcclxuICAgIChsKSA9PiBsLmtpbmQgPT09IEIuQUdFTlQgJiYgbC5hdHRyaWJ1dGVzW1wibGsucHVibGlzaF9vbl9iZWhhbGZcIl0gPT09ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlkZW50aXR5KVxyXG4gICksIGEgPSBxKFxyXG4gICAgW3YuU291cmNlLk1pY3JvcGhvbmUsIHYuU291cmNlLkNhbWVyYV0sXHJcbiAgICB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmlkZW50aXR5XHJcbiAgKSwgcyA9IHEoXHJcbiAgICBbdi5Tb3VyY2UuTWljcm9waG9uZSwgdi5Tb3VyY2UuQ2FtZXJhXSxcclxuICAgIG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaWRlbnRpdHlcclxuICApLCBjID0gYS5maW5kKChsKSA9PiBsLnNvdXJjZSA9PT0gdi5Tb3VyY2UuTWljcm9waG9uZSkgPz8gcy5maW5kKChsKSA9PiBsLnNvdXJjZSA9PT0gdi5Tb3VyY2UuTWljcm9waG9uZSksIG8gPSBhLmZpbmQoKGwpID0+IGwuc291cmNlID09PSB2LlNvdXJjZS5DYW1lcmEpID8/IHMuZmluZCgobCkgPT4gbC5zb3VyY2UgPT09IHYuU291cmNlLkNhbWVyYSksIHsgc2VnbWVudHM6IHUgfSA9IHB0KGMpLCBpID0gSSgpLCB7IGF0dHJpYnV0ZXM6IGQgfSA9IGJ0KHsgcGFydGljaXBhbnQ6IHQgfSksIGYgPSByLnVzZU1lbW8oKCkgPT4gaSA9PT0gQy5EaXNjb25uZWN0ZWQgPyBcImRpc2Nvbm5lY3RlZFwiIDogaSA9PT0gQy5Db25uZWN0aW5nIHx8ICF0IHx8ICEoZCAhPSBudWxsICYmIGRbSl0pID8gXCJjb25uZWN0aW5nXCIgOiBkW0pdLCBbZCwgdCwgaV0pO1xyXG4gIHJldHVybiB7XHJcbiAgICBhZ2VudDogdCxcclxuICAgIHN0YXRlOiBmLFxyXG4gICAgYXVkaW9UcmFjazogYyxcclxuICAgIHZpZGVvVHJhY2s6IG8sXHJcbiAgICBhZ2VudFRyYW5zY3JpcHRpb25zOiB1LFxyXG4gICAgYWdlbnRBdHRyaWJ1dGVzOiBkXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBubihlKSB7XHJcbiAgY29uc3QgdCA9IGsoZSksIG4gPSBJKHQpLCBhID0gci51c2VNZW1vKCgpID0+IFVlKHQpLCBbdCwgbl0pO1xyXG4gIHJldHVybiBiKGEsIHQuaXNSZWNvcmRpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIG10KGUpIHtcclxuICBjb25zdCB0ID0gVCgpLCBhID0gSSh0KSA9PT0gQy5EaXNjb25uZWN0ZWQsIHMgPSByLnVzZU1lbW8oKCkgPT4gcWUodCwgZSksIFt0LCBlXSk7XHJcbiAgcmV0dXJuIHsgdGV4dFN0cmVhbXM6IGIoYSA/IHZvaWQgMCA6IHMsIFtdKSB9O1xyXG59XHJcbmZ1bmN0aW9uIHNuKGUpIHtcclxuICBjb25zdCB7IHBhcnRpY2lwYW50SWRlbnRpdGllczogdCwgdHJhY2tTaWRzOiBuIH0gPSBlID8/IHt9LCB7IHRleHRTdHJlYW1zOiBhIH0gPSBtdChKZS5UUkFOU0NSSVBUSU9OKTtcclxuICByZXR1cm4gci51c2VNZW1vKFxyXG4gICAgKCkgPT4gYS5maWx0ZXIoXHJcbiAgICAgIChjKSA9PiB0ID8gdC5pbmNsdWRlcyhjLnBhcnRpY2lwYW50SW5mby5pZGVudGl0eSkgOiAhMFxyXG4gICAgKS5maWx0ZXIoXHJcbiAgICAgIChjKSA9PiB7XHJcbiAgICAgICAgdmFyIG87XHJcbiAgICAgICAgcmV0dXJuIG4gPyBuLmluY2x1ZGVzKCgobyA9IGMuc3RyZWFtSW5mby5hdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogb1tcImxrLnRyYW5zY3JpYmVkX3RyYWNrX2lkXCJdKSA/PyBcIlwiKSA6ICEwO1xyXG4gICAgICB9XHJcbiAgICApLFxyXG4gICAgW2EsIHQsIG5dXHJcbiAgKTtcclxufVxyXG5leHBvcnQge1xyXG4gIEF0IGFzIEEsXHJcbiAgRnQgYXMgQixcclxuICBldCBhcyBDLFxyXG4gIE10IGFzIEQsXHJcbiAga3QgYXMgRSxcclxuICBaZSBhcyBGLFxyXG4gIHogYXMgRyxcclxuICBLZSBhcyBILFxyXG4gIER0IGFzIEksXHJcbiAgTHQgYXMgSixcclxuICBOdCBhcyBLLFxyXG4gIFZ0IGFzIEwsXHJcbiAgSCBhcyBNLFxyXG4gIEJ0IGFzIE4sXHJcbiAgbnQgYXMgTyxcclxuICB4dCBhcyBQLFxyXG4gICR0IGFzIFEsXHJcbiAgWXQgYXMgUixcclxuICBLdCBhcyBTLFxyXG4gIHEgYXMgVCxcclxuICBwdCBhcyBVLFxyXG4gIHRuIGFzIFYsXHJcbiAgYnQgYXMgVyxcclxuICBlbiBhcyBYLFxyXG4gIG5uIGFzIFksXHJcbiAgbXQgYXMgWixcclxuICBzbiBhcyBfLFxyXG4gIEkgYXMgYSxcclxuICBKdCBhcyBiLFxyXG4gIFR0IGFzIGMsXHJcbiAgRXQgYXMgZCxcclxuICBDdCBhcyBlLFxyXG4gIHp0IGFzIGYsXHJcbiAgVXQgYXMgZyxcclxuICBHdCBhcyBoLFxyXG4gIFB0IGFzIGksXHJcbiAgYiBhcyBqLFxyXG4gIFd0IGFzIGssXHJcbiAgUnQgYXMgbCxcclxuICBYdCBhcyBtLFxyXG4gIHd0IGFzIG4sXHJcbiAgT3QgYXMgbyxcclxuICBxdCBhcyBwLFxyXG4gIFllIGFzIHEsXHJcbiAgdHQgYXMgcixcclxuICBadCBhcyBzLFxyXG4gIFF0IGFzIHQsXHJcbiAgeXQgYXMgdSxcclxuICBfdCBhcyB2LFxyXG4gIEh0IGFzIHcsXHJcbiAganQgYXMgeCxcclxuICBJdCBhcyB5LFxyXG4gIGh0IGFzIHpcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MtT0p0d2g0ak8ubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-OJtwh4jO.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-889cObLb.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@livekit/components-react/dist/room-889cObLb.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   L: () => (/* binding */ W),\n/* harmony export */   a: () => (/* binding */ G),\n/* harmony export */   c: () => (/* binding */ H),\n/* harmony export */   m: () => (/* binding */ M),\n/* harmony export */   r: () => (/* binding */ T),\n/* harmony export */   u: () => (/* binding */ $),\n/* harmony export */   w: () => (/* binding */ Q)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contexts-Cm1aSBTs.mjs */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/contexts-Cm1aSBTs.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\r\n\r\n\r\nfunction L(n) {\r\n  var e, o, t = \"\";\r\n  if (typeof n == \"string\" || typeof n == \"number\") t += n;\r\n  else if (typeof n == \"object\") if (Array.isArray(n)) {\r\n    var r = n.length;\r\n    for (e = 0; e < r; e++) n[e] && (o = L(n[e])) && (t && (t += \" \"), t += o);\r\n  } else for (o in n) n[o] && (t && (t += \" \"), t += o);\r\n  return t;\r\n}\r\nfunction A() {\r\n  for (var n, e, o = 0, t = \"\", r = arguments.length; o < r; o++) (n = arguments[o]) && (e = L(n)) && (t && (t += \" \"), t += e);\r\n  return t;\r\n}\r\nfunction I(...n) {\r\n  return (...e) => {\r\n    for (const o of n)\r\n      if (typeof o == \"function\")\r\n        try {\r\n          o(...e);\r\n        } catch (t) {\r\n          console.error(t);\r\n        }\r\n  };\r\n}\r\nfunction M(...n) {\r\n  const e = { ...n[0] };\r\n  for (let o = 1; o < n.length; o++) {\r\n    const t = n[o];\r\n    for (const r in t) {\r\n      const d = e[r], a = t[r];\r\n      typeof d == \"function\" && typeof a == \"function\" && // This is a lot faster than a regex.\r\n      r[0] === \"o\" && r[1] === \"n\" && r.charCodeAt(2) >= /* 'A' */\r\n      65 && r.charCodeAt(2) <= /* 'Z' */\r\n      90 ? e[r] = I(d, a) : (r === \"className\" || r === \"UNSAFE_className\") && typeof d == \"string\" && typeof a == \"string\" ? e[r] = A(d, a) : e[r] = a !== void 0 ? a : d;\r\n    }\r\n  }\r\n  return e;\r\n}\r\nfunction J(n) {\r\n  return n !== void 0;\r\n}\r\nfunction G(...n) {\r\n  return M(...n.filter(J));\r\n}\r\nfunction H(n, e, o) {\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(n, (t) => react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(t) && react__WEBPACK_IMPORTED_MODULE_0__.Children.only(n) ? (t.props.className && (e ?? (e = {}), e.className = A(t.props.className, e.className), e.style = { ...t.props.style, ...e.style }), react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(t, { ...e, key: o })) : t);\r\n}\r\nfunction Q(n) {\r\n  var e, o;\r\n  if (typeof window < \"u\" && typeof process < \"u\" && // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n  (((e = process == null ? void 0 : process.env) == null ? void 0 : e.NODE_ENV) === \"dev\" || // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n  ((o = process == null ? void 0 : process.env) == null ? void 0 : o.NODE_ENV) === \"development\")) {\r\n    const t = document.querySelector(\".lk-room-container\");\r\n    t && !getComputedStyle(t).getPropertyValue(\"--lk-has-imported-styles\") && _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\r\n      \"It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page.\"\r\n    );\r\n  }\r\n}\r\nfunction T(n, e) {\r\n  return n === \"processor\" && e && typeof e == \"object\" && \"name\" in e ? e.name : n === \"e2ee\" && e ? \"e2ee-enabled\" : e;\r\n}\r\nconst q = {\r\n  connect: !0,\r\n  audio: !1,\r\n  video: !1\r\n};\r\nfunction $(n) {\r\n  const {\r\n    token: e,\r\n    serverUrl: o,\r\n    options: t,\r\n    room: r,\r\n    connectOptions: d,\r\n    connect: a,\r\n    audio: p,\r\n    video: y,\r\n    screen: g,\r\n    onConnected: v,\r\n    onDisconnected: h,\r\n    onError: c,\r\n    onMediaDeviceFailure: b,\r\n    onEncryptionError: E,\r\n    simulateParticipants: w,\r\n    ...N\r\n  } = { ...q, ...n };\r\n  t && r && _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\r\n    \"when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.\"\r\n  );\r\n  const [s, O] = react__WEBPACK_IMPORTED_MODULE_0__.useState(), C = react__WEBPACK_IMPORTED_MODULE_0__.useRef(a);\r\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    O(r ?? new livekit_client__WEBPACK_IMPORTED_MODULE_1__.Room(t));\r\n  }, [r, JSON.stringify(t, T)]);\r\n  const F = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    const { className: m } = (0,_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.s)();\r\n    return M(N, { className: m });\r\n  }, [N]);\r\n  return react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (!s) return;\r\n    const m = () => {\r\n      const f = s.localParticipant;\r\n      _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"trying to publish local tracks\"), Promise.all([\r\n        f.setMicrophoneEnabled(!!p, typeof p != \"boolean\" ? p : void 0),\r\n        f.setCameraEnabled(!!y, typeof y != \"boolean\" ? y : void 0),\r\n        f.setScreenShareEnabled(!!g, typeof g != \"boolean\" ? g : void 0)\r\n      ]).catch((R) => {\r\n        _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(R), c == null || c(R);\r\n      });\r\n    }, P = (f, R) => {\r\n      const K = livekit_client__WEBPACK_IMPORTED_MODULE_1__.MediaDeviceFailure.getFailure(f);\r\n      b == null || b(K, R);\r\n    }, S = (f) => {\r\n      E == null || E(f);\r\n    }, k = (f) => {\r\n      h == null || h(f);\r\n    }, D = () => {\r\n      v == null || v();\r\n    };\r\n    return s.on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.SignalConnected, m).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, P).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, S).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Disconnected, k).on(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Connected, D), () => {\r\n      s.off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.SignalConnected, m).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.MediaDevicesError, P).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.EncryptionError, S).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Disconnected, k).off(livekit_client__WEBPACK_IMPORTED_MODULE_1__.RoomEvent.Connected, D);\r\n    };\r\n  }, [\r\n    s,\r\n    p,\r\n    y,\r\n    g,\r\n    c,\r\n    E,\r\n    b,\r\n    v,\r\n    h\r\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (s) {\r\n      if (w) {\r\n        s.simulateParticipants({\r\n          participants: {\r\n            count: w\r\n          },\r\n          publish: {\r\n            audio: !0,\r\n            useRealTracks: !0\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      if (a) {\r\n        if (C.current = !0, _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"connecting\"), !e) {\r\n          _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"no token yet\");\r\n          return;\r\n        }\r\n        if (!o) {\r\n          _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(\"no livekit url provided\"), c == null || c(Error(\"no livekit url provided\"));\r\n          return;\r\n        }\r\n        s.connect(o, e, d).catch((m) => {\r\n          _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.warn(m), C.current === !0 && (c == null || c(m));\r\n        });\r\n      } else\r\n        _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.debug(\"disconnecting because connect is false\"), C.current = !1, s.disconnect();\r\n    }\r\n  }, [\r\n    a,\r\n    e,\r\n    JSON.stringify(d),\r\n    s,\r\n    c,\r\n    o,\r\n    w\r\n  ]), react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\r\n    if (s)\r\n      return () => {\r\n        _contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.l.info(\"disconnecting on onmount\"), s.disconnect();\r\n      };\r\n  }, [s]), { room: s, htmlProps: F };\r\n}\r\nconst W = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function(e, o) {\r\n  const { room: t, htmlProps: r } = $(e);\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: o, ...r }, t && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.R.Provider, { value: t }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_contexts_Cm1aSBTs_mjs__WEBPACK_IMPORTED_MODULE_2__.L.Provider, { value: e.featureFlags }, e.children)));\r\n});\r\n\r\n//# sourceMappingURL=room-889cObLb.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0L2Rpc3Qvcm9vbS04ODljT2JMYi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkI7QUFDOEM7QUFDVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJDQUFVLGVBQWUsaURBQWdCLE9BQU8sMkNBQVUsOENBQThDLGdFQUFnRSw4QkFBOEIsR0FBRywrQ0FBYyxNQUFNLGNBQWM7QUFDcFA7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0MsU0FBUyxPQUFPLG9CQUFvQixPQUFPO0FBQzNDLFFBQVEsT0FBTyxvQkFBb0IsT0FBTztBQUMxQztBQUNBLDhFQUE4RSxxREFBQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixZQUFZLHFEQUFDO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQiwyQ0FBVSxRQUFRLHlDQUFRO0FBQzNDLEVBQUUsNENBQVc7QUFDYixlQUFlLGdEQUFDO0FBQ2hCLEdBQUc7QUFDSCxZQUFZLDBDQUFTO0FBQ3JCLFlBQVksZUFBZSxFQUFFLHlEQUFDO0FBQzlCLGtCQUFrQixjQUFjO0FBQ2hDLEdBQUc7QUFDSCxTQUFTLDRDQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQUM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLGdCQUFnQiw4REFBQztBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFDLHdCQUF3QixxREFBQywwQkFBMEIscURBQUMsd0JBQXdCLHFEQUFDLHFCQUFxQixxREFBQztBQUNwSCxZQUFZLHFEQUFDLHlCQUF5QixxREFBQywyQkFBMkIscURBQUMseUJBQXlCLHFEQUFDLHNCQUFzQixxREFBQztBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRDQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFEQUFDO0FBQzdCLFVBQVUscURBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBQztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1IsUUFBUSxxREFBQztBQUNUO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0Q0FBVztBQUNqQjtBQUNBO0FBQ0EsUUFBUSxxREFBQztBQUNUO0FBQ0EsR0FBRyxVQUFVO0FBQ2I7QUFDQSwwQkFBMEIsNkNBQVk7QUFDdEMsVUFBVSx3QkFBd0I7QUFDbEMseUJBQXlCLGdEQUFlLFVBQVUsY0FBYyx1QkFBdUIsZ0RBQWUsQ0FBQyxxREFBQyxhQUFhLFVBQVUsa0JBQWtCLGdEQUFlLENBQUMscURBQUMsYUFBYSx1QkFBdUI7QUFDdE0sQ0FBQztBQVNDO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQGxpdmVraXRcXGNvbXBvbmVudHMtcmVhY3RcXGRpc3RcXHJvb20tODg5Y09iTGIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGkgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IGwgYXMgdSwgcyBhcyB4LCBSIGFzIFYsIEwgYXMgaiB9IGZyb20gXCIuL2NvbnRleHRzLUNtMWFTQlRzLm1qc1wiO1xyXG5pbXBvcnQgeyBSb29tIGFzIFUsIFJvb21FdmVudCBhcyBsLCBNZWRpYURldmljZUZhaWx1cmUgYXMgXyB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xyXG5mdW5jdGlvbiBMKG4pIHtcclxuICB2YXIgZSwgbywgdCA9IFwiXCI7XHJcbiAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG4gPT0gXCJudW1iZXJcIikgdCArPSBuO1xyXG4gIGVsc2UgaWYgKHR5cGVvZiBuID09IFwib2JqZWN0XCIpIGlmIChBcnJheS5pc0FycmF5KG4pKSB7XHJcbiAgICB2YXIgciA9IG4ubGVuZ3RoO1xyXG4gICAgZm9yIChlID0gMDsgZSA8IHI7IGUrKykgbltlXSAmJiAobyA9IEwobltlXSkpICYmICh0ICYmICh0ICs9IFwiIFwiKSwgdCArPSBvKTtcclxuICB9IGVsc2UgZm9yIChvIGluIG4pIG5bb10gJiYgKHQgJiYgKHQgKz0gXCIgXCIpLCB0ICs9IG8pO1xyXG4gIHJldHVybiB0O1xyXG59XHJcbmZ1bmN0aW9uIEEoKSB7XHJcbiAgZm9yICh2YXIgbiwgZSwgbyA9IDAsIHQgPSBcIlwiLCByID0gYXJndW1lbnRzLmxlbmd0aDsgbyA8IHI7IG8rKykgKG4gPSBhcmd1bWVudHNbb10pICYmIChlID0gTChuKSkgJiYgKHQgJiYgKHQgKz0gXCIgXCIpLCB0ICs9IGUpO1xyXG4gIHJldHVybiB0O1xyXG59XHJcbmZ1bmN0aW9uIEkoLi4ubikge1xyXG4gIHJldHVybiAoLi4uZSkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBvIG9mIG4pXHJcbiAgICAgIGlmICh0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIG8oLi4uZSk7XHJcbiAgICAgICAgfSBjYXRjaCAodCkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcih0KTtcclxuICAgICAgICB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBNKC4uLm4pIHtcclxuICBjb25zdCBlID0geyAuLi5uWzBdIH07XHJcbiAgZm9yIChsZXQgbyA9IDE7IG8gPCBuLmxlbmd0aDsgbysrKSB7XHJcbiAgICBjb25zdCB0ID0gbltvXTtcclxuICAgIGZvciAoY29uc3QgciBpbiB0KSB7XHJcbiAgICAgIGNvbnN0IGQgPSBlW3JdLCBhID0gdFtyXTtcclxuICAgICAgdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIiAmJiAvLyBUaGlzIGlzIGEgbG90IGZhc3RlciB0aGFuIGEgcmVnZXguXHJcbiAgICAgIHJbMF0gPT09IFwib1wiICYmIHJbMV0gPT09IFwiblwiICYmIHIuY2hhckNvZGVBdCgyKSA+PSAvKiAnQScgKi9cclxuICAgICAgNjUgJiYgci5jaGFyQ29kZUF0KDIpIDw9IC8qICdaJyAqL1xyXG4gICAgICA5MCA/IGVbcl0gPSBJKGQsIGEpIDogKHIgPT09IFwiY2xhc3NOYW1lXCIgfHwgciA9PT0gXCJVTlNBRkVfY2xhc3NOYW1lXCIpICYmIHR5cGVvZiBkID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiA/IGVbcl0gPSBBKGQsIGEpIDogZVtyXSA9IGEgIT09IHZvaWQgMCA/IGEgOiBkO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZTtcclxufVxyXG5mdW5jdGlvbiBKKG4pIHtcclxuICByZXR1cm4gbiAhPT0gdm9pZCAwO1xyXG59XHJcbmZ1bmN0aW9uIEcoLi4ubikge1xyXG4gIHJldHVybiBNKC4uLm4uZmlsdGVyKEopKTtcclxufVxyXG5mdW5jdGlvbiBIKG4sIGUsIG8pIHtcclxuICByZXR1cm4gaS5DaGlsZHJlbi5tYXAobiwgKHQpID0+IGkuaXNWYWxpZEVsZW1lbnQodCkgJiYgaS5DaGlsZHJlbi5vbmx5KG4pID8gKHQucHJvcHMuY2xhc3NOYW1lICYmIChlID8/IChlID0ge30pLCBlLmNsYXNzTmFtZSA9IEEodC5wcm9wcy5jbGFzc05hbWUsIGUuY2xhc3NOYW1lKSwgZS5zdHlsZSA9IHsgLi4udC5wcm9wcy5zdHlsZSwgLi4uZS5zdHlsZSB9KSwgaS5jbG9uZUVsZW1lbnQodCwgeyAuLi5lLCBrZXk6IG8gfSkpIDogdCk7XHJcbn1cclxuZnVuY3Rpb24gUShuKSB7XHJcbiAgdmFyIGUsIG87XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2YgcHJvY2VzcyA8IFwidVwiICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0dXJiby9uby11bmRlY2xhcmVkLWVudi12YXJzXHJcbiAgKCgoZSA9IHByb2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PSBudWxsID8gdm9pZCAwIDogZS5OT0RFX0VOVikgPT09IFwiZGV2XCIgfHwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHR1cmJvL25vLXVuZGVjbGFyZWQtZW52LXZhcnNcclxuICAoKG8gPSBwcm9jZXNzID09IG51bGwgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT0gbnVsbCA/IHZvaWQgMCA6IG8uTk9ERV9FTlYpID09PSBcImRldmVsb3BtZW50XCIpKSB7XHJcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5say1yb29tLWNvbnRhaW5lclwiKTtcclxuICAgIHQgJiYgIWdldENvbXB1dGVkU3R5bGUodCkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tbGstaGFzLWltcG9ydGVkLXN0eWxlc1wiKSAmJiB1Lndhcm4oXHJcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgbm90IHVzaW5nIHRoZSBgQGxpdmVraXQvY29tcG9uZW50cy1zdHlsZXMgcGFja2FnZWAuIFRvIHJlbmRlciB0aGUgVUkgd2l0aCB0aGUgZGVmYXVsdCBzdHlsaW5nLCBwbGVhc2UgaW1wb3J0IGl0IGluIHlvdXIgbGF5b3V0IG9yIHBhZ2UuXCJcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIFQobiwgZSkge1xyXG4gIHJldHVybiBuID09PSBcInByb2Nlc3NvclwiICYmIGUgJiYgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcIm5hbWVcIiBpbiBlID8gZS5uYW1lIDogbiA9PT0gXCJlMmVlXCIgJiYgZSA/IFwiZTJlZS1lbmFibGVkXCIgOiBlO1xyXG59XHJcbmNvbnN0IHEgPSB7XHJcbiAgY29ubmVjdDogITAsXHJcbiAgYXVkaW86ICExLFxyXG4gIHZpZGVvOiAhMVxyXG59O1xyXG5mdW5jdGlvbiAkKG4pIHtcclxuICBjb25zdCB7XHJcbiAgICB0b2tlbjogZSxcclxuICAgIHNlcnZlclVybDogbyxcclxuICAgIG9wdGlvbnM6IHQsXHJcbiAgICByb29tOiByLFxyXG4gICAgY29ubmVjdE9wdGlvbnM6IGQsXHJcbiAgICBjb25uZWN0OiBhLFxyXG4gICAgYXVkaW86IHAsXHJcbiAgICB2aWRlbzogeSxcclxuICAgIHNjcmVlbjogZyxcclxuICAgIG9uQ29ubmVjdGVkOiB2LFxyXG4gICAgb25EaXNjb25uZWN0ZWQ6IGgsXHJcbiAgICBvbkVycm9yOiBjLFxyXG4gICAgb25NZWRpYURldmljZUZhaWx1cmU6IGIsXHJcbiAgICBvbkVuY3J5cHRpb25FcnJvcjogRSxcclxuICAgIHNpbXVsYXRlUGFydGljaXBhbnRzOiB3LFxyXG4gICAgLi4uTlxyXG4gIH0gPSB7IC4uLnEsIC4uLm4gfTtcclxuICB0ICYmIHIgJiYgdS53YXJuKFxyXG4gICAgXCJ3aGVuIHVzaW5nIGEgbWFudWFsbHkgY3JlYXRlZCByb29tLCB0aGUgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBpZ25vcmVkLiBzZXQgdGhlIGRlc2lyZWQgb3B0aW9ucyBkaXJlY3RseSB3aGVuIGNyZWF0aW5nIHRoZSByb29tIGluc3RlYWQuXCJcclxuICApO1xyXG4gIGNvbnN0IFtzLCBPXSA9IGkudXNlU3RhdGUoKSwgQyA9IGkudXNlUmVmKGEpO1xyXG4gIGkudXNlRWZmZWN0KCgpID0+IHtcclxuICAgIE8ociA/PyBuZXcgVSh0KSk7XHJcbiAgfSwgW3IsIEpTT04uc3RyaW5naWZ5KHQsIFQpXSk7XHJcbiAgY29uc3QgRiA9IGkudXNlTWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCB7IGNsYXNzTmFtZTogbSB9ID0geCgpO1xyXG4gICAgcmV0dXJuIE0oTiwgeyBjbGFzc05hbWU6IG0gfSk7XHJcbiAgfSwgW05dKTtcclxuICByZXR1cm4gaS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFzKSByZXR1cm47XHJcbiAgICBjb25zdCBtID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBmID0gcy5sb2NhbFBhcnRpY2lwYW50O1xyXG4gICAgICB1LmRlYnVnKFwidHJ5aW5nIHRvIHB1Ymxpc2ggbG9jYWwgdHJhY2tzXCIpLCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZi5zZXRNaWNyb3Bob25lRW5hYmxlZCghIXAsIHR5cGVvZiBwICE9IFwiYm9vbGVhblwiID8gcCA6IHZvaWQgMCksXHJcbiAgICAgICAgZi5zZXRDYW1lcmFFbmFibGVkKCEheSwgdHlwZW9mIHkgIT0gXCJib29sZWFuXCIgPyB5IDogdm9pZCAwKSxcclxuICAgICAgICBmLnNldFNjcmVlblNoYXJlRW5hYmxlZCghIWcsIHR5cGVvZiBnICE9IFwiYm9vbGVhblwiID8gZyA6IHZvaWQgMClcclxuICAgICAgXSkuY2F0Y2goKFIpID0+IHtcclxuICAgICAgICB1Lndhcm4oUiksIGMgPT0gbnVsbCB8fCBjKFIpO1xyXG4gICAgICB9KTtcclxuICAgIH0sIFAgPSAoZiwgUikgPT4ge1xyXG4gICAgICBjb25zdCBLID0gXy5nZXRGYWlsdXJlKGYpO1xyXG4gICAgICBiID09IG51bGwgfHwgYihLLCBSKTtcclxuICAgIH0sIFMgPSAoZikgPT4ge1xyXG4gICAgICBFID09IG51bGwgfHwgRShmKTtcclxuICAgIH0sIGsgPSAoZikgPT4ge1xyXG4gICAgICBoID09IG51bGwgfHwgaChmKTtcclxuICAgIH0sIEQgPSAoKSA9PiB7XHJcbiAgICAgIHYgPT0gbnVsbCB8fCB2KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHMub24obC5TaWduYWxDb25uZWN0ZWQsIG0pLm9uKGwuTWVkaWFEZXZpY2VzRXJyb3IsIFApLm9uKGwuRW5jcnlwdGlvbkVycm9yLCBTKS5vbihsLkRpc2Nvbm5lY3RlZCwgaykub24obC5Db25uZWN0ZWQsIEQpLCAoKSA9PiB7XHJcbiAgICAgIHMub2ZmKGwuU2lnbmFsQ29ubmVjdGVkLCBtKS5vZmYobC5NZWRpYURldmljZXNFcnJvciwgUCkub2ZmKGwuRW5jcnlwdGlvbkVycm9yLCBTKS5vZmYobC5EaXNjb25uZWN0ZWQsIGspLm9mZihsLkNvbm5lY3RlZCwgRCk7XHJcbiAgICB9O1xyXG4gIH0sIFtcclxuICAgIHMsXHJcbiAgICBwLFxyXG4gICAgeSxcclxuICAgIGcsXHJcbiAgICBjLFxyXG4gICAgRSxcclxuICAgIGIsXHJcbiAgICB2LFxyXG4gICAgaFxyXG4gIF0pLCBpLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAocykge1xyXG4gICAgICBpZiAodykge1xyXG4gICAgICAgIHMuc2ltdWxhdGVQYXJ0aWNpcGFudHMoe1xyXG4gICAgICAgICAgcGFydGljaXBhbnRzOiB7XHJcbiAgICAgICAgICAgIGNvdW50OiB3XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcHVibGlzaDoge1xyXG4gICAgICAgICAgICBhdWRpbzogITAsXHJcbiAgICAgICAgICAgIHVzZVJlYWxUcmFja3M6ICEwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgaWYgKEMuY3VycmVudCA9ICEwLCB1LmRlYnVnKFwiY29ubmVjdGluZ1wiKSwgIWUpIHtcclxuICAgICAgICAgIHUuZGVidWcoXCJubyB0b2tlbiB5ZXRcIik7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbykge1xyXG4gICAgICAgICAgdS53YXJuKFwibm8gbGl2ZWtpdCB1cmwgcHJvdmlkZWRcIiksIGMgPT0gbnVsbCB8fCBjKEVycm9yKFwibm8gbGl2ZWtpdCB1cmwgcHJvdmlkZWRcIikpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzLmNvbm5lY3QobywgZSwgZCkuY2F0Y2goKG0pID0+IHtcclxuICAgICAgICAgIHUud2FybihtKSwgQy5jdXJyZW50ID09PSAhMCAmJiAoYyA9PSBudWxsIHx8IGMobSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2VcclxuICAgICAgICB1LmRlYnVnKFwiZGlzY29ubmVjdGluZyBiZWNhdXNlIGNvbm5lY3QgaXMgZmFsc2VcIiksIEMuY3VycmVudCA9ICExLCBzLmRpc2Nvbm5lY3QoKTtcclxuICAgIH1cclxuICB9LCBbXHJcbiAgICBhLFxyXG4gICAgZSxcclxuICAgIEpTT04uc3RyaW5naWZ5KGQpLFxyXG4gICAgcyxcclxuICAgIGMsXHJcbiAgICBvLFxyXG4gICAgd1xyXG4gIF0pLCBpLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAocylcclxuICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB1LmluZm8oXCJkaXNjb25uZWN0aW5nIG9uIG9ubW91bnRcIiksIHMuZGlzY29ubmVjdCgpO1xyXG4gICAgICB9O1xyXG4gIH0sIFtzXSksIHsgcm9vbTogcywgaHRtbFByb3BzOiBGIH07XHJcbn1cclxuY29uc3QgVyA9IC8qIEBfX1BVUkVfXyAqLyBpLmZvcndhcmRSZWYoZnVuY3Rpb24oZSwgbykge1xyXG4gIGNvbnN0IHsgcm9vbTogdCwgaHRtbFByb3BzOiByIH0gPSAkKGUpO1xyXG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBvLCAuLi5yIH0sIHQgJiYgLyogQF9fUFVSRV9fICovIGkuY3JlYXRlRWxlbWVudChWLlByb3ZpZGVyLCB7IHZhbHVlOiB0IH0sIC8qIEBfX1BVUkVfXyAqLyBpLmNyZWF0ZUVsZW1lbnQoai5Qcm92aWRlciwgeyB2YWx1ZTogZS5mZWF0dXJlRmxhZ3MgfSwgZS5jaGlsZHJlbikpKTtcclxufSk7XHJcbmV4cG9ydCB7XHJcbiAgVyBhcyBMLFxyXG4gIEcgYXMgYSxcclxuICBIIGFzIGMsXHJcbiAgTSBhcyBtLFxyXG4gIFQgYXMgcixcclxuICAkIGFzIHUsXHJcbiAgUSBhcyB3XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb20tODg5Y09iTGIubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-889cObLb.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalTrackRecorder: () => (/* binding */ LocalTrackRecorder),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   attributes: () => (/* binding */ attributeTypings),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nfunction _mergeNamespaces(n, m) {\r\n  m.forEach(function (e) {\r\n    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\r\n      if (k !== 'default' && !(k in n)) {\r\n        var d = Object.getOwnPropertyDescriptor(e, k);\r\n        Object.defineProperty(n, k, d.get ? d : {\r\n          enumerable: true,\r\n          get: function () { return e[k]; }\r\n        });\r\n      }\r\n    });\r\n  });\r\n  return Object.freeze(n);\r\n}\r\n\r\nvar e = Object.defineProperty;\r\nvar h = (i, s, t) => s in i ? e(i, s, {\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true,\r\n  value: t\r\n}) : i[s] = t;\r\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\r\nclass _ {\r\n  constructor() {\r\n    o(this, \"_locking\");\r\n    o(this, \"_locks\");\r\n    this._locking = Promise.resolve(), this._locks = 0;\r\n  }\r\n  isLocked() {\r\n    return this._locks > 0;\r\n  }\r\n  lock() {\r\n    this._locks += 1;\r\n    let s;\r\n    const t = new Promise(l => s = () => {\r\n        this._locks -= 1, l();\r\n      }),\r\n      c = this._locking.then(() => s);\r\n    return this._locking = this._locking.then(() => t), c;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Assert that condition is truthy or throw error (with message)\r\n */\r\nfunction assert(condition, msg) {\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\r\n  if (!condition) {\r\n    throw new Error(msg);\r\n  }\r\n}\r\nconst FLOAT32_MAX = 3.4028234663852886e38,\r\n  FLOAT32_MIN = -34028234663852886e22,\r\n  UINT32_MAX = 0xffffffff,\r\n  INT32_MAX = 0x7fffffff,\r\n  INT32_MIN = -2147483648;\r\n/**\r\n * Assert a valid signed protobuf 32-bit integer.\r\n */\r\nfunction assertInt32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\r\n  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n/**\r\n * Assert a valid unsigned protobuf 32-bit integer.\r\n */\r\nfunction assertUInt32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\r\n  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n/**\r\n * Assert a valid protobuf float value.\r\n */\r\nfunction assertFloat32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\r\n  if (!Number.isFinite(arg)) return;\r\n  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\r\n/**\r\n * Get reflection information from a generated enum.\r\n * If this function is called on something other than a generated\r\n * enum, it raises an error.\r\n */\r\nfunction getEnumType(enumObject) {\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\r\n  const t = enumObject[enumTypeSymbol];\r\n  assert(t, \"missing enum type on enum object\");\r\n  return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\r\n}\r\n/**\r\n * Sets reflection information on a generated enum.\r\n */\r\nfunction setEnumType(enumObject, typeName, values, opt) {\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(v => ({\r\n    no: v.no,\r\n    name: v.name,\r\n    localName: enumObject[v.no]\r\n  })));\r\n}\r\n/**\r\n * Create a new EnumType with the given values.\r\n */\r\nfunction makeEnumType(typeName, values,\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n_opt) {\r\n  const names = Object.create(null);\r\n  const numbers = Object.create(null);\r\n  const normalValues = [];\r\n  for (const value of values) {\r\n    // We do not surface options at this time\r\n    // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\r\n    const n = normalizeEnumValue(value);\r\n    normalValues.push(n);\r\n    names[value.name] = n;\r\n    numbers[value.no] = n;\r\n  }\r\n  return {\r\n    typeName,\r\n    values: normalValues,\r\n    // We do not surface options at this time\r\n    // options: opt?.options ?? Object.create(null),\r\n    findName(name) {\r\n      return names[name];\r\n    },\r\n    findNumber(no) {\r\n      return numbers[no];\r\n    }\r\n  };\r\n}\r\n/**\r\n * Create a new enum object with the given values.\r\n * Sets reflection information.\r\n */\r\nfunction makeEnum(typeName, values, opt) {\r\n  const enumObject = {};\r\n  for (const value of values) {\r\n    const n = normalizeEnumValue(value);\r\n    enumObject[n.localName] = n.no;\r\n    enumObject[n.no] = n.localName;\r\n  }\r\n  setEnumType(enumObject, typeName, values);\r\n  return enumObject;\r\n}\r\nfunction normalizeEnumValue(value) {\r\n  if (\"localName\" in value) {\r\n    return value;\r\n  }\r\n  return Object.assign(Object.assign({}, value), {\r\n    localName: value.name\r\n  });\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Message is the base class of every message, generated, or created at\r\n * runtime.\r\n *\r\n * It is _not_ safe to extend this class. If you want to create a message at\r\n * run time, use proto3.makeMessageType().\r\n */\r\nclass Message {\r\n  /**\r\n   * Compare with a message of the same type.\r\n   * Note that this function disregards extensions and unknown fields.\r\n   */\r\n  equals(other) {\r\n    return this.getType().runtime.util.equals(this.getType(), this, other);\r\n  }\r\n  /**\r\n   * Create a deep copy.\r\n   */\r\n  clone() {\r\n    return this.getType().runtime.util.clone(this);\r\n  }\r\n  /**\r\n   * Parse from binary data, merging fields.\r\n   *\r\n   * Repeated fields are appended. Map entries are added, overwriting\r\n   * existing keys.\r\n   *\r\n   * If a message field is already present, it will be merged with the\r\n   * new data.\r\n   */\r\n  fromBinary(bytes, options) {\r\n    const type = this.getType(),\r\n      format = type.runtime.bin,\r\n      opt = format.makeReadOptions(options);\r\n    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\r\n    return this;\r\n  }\r\n  /**\r\n   * Parse a message from a JSON value.\r\n   */\r\n  fromJson(jsonValue, options) {\r\n    const type = this.getType(),\r\n      format = type.runtime.json,\r\n      opt = format.makeReadOptions(options);\r\n    format.readMessage(type, jsonValue, opt, this);\r\n    return this;\r\n  }\r\n  /**\r\n   * Parse a message from a JSON string.\r\n   */\r\n  fromJsonString(jsonString, options) {\r\n    let json;\r\n    try {\r\n      json = JSON.parse(jsonString);\r\n    } catch (e) {\r\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\r\n    }\r\n    return this.fromJson(json, options);\r\n  }\r\n  /**\r\n   * Serialize the message to binary data.\r\n   */\r\n  toBinary(options) {\r\n    const type = this.getType(),\r\n      bin = type.runtime.bin,\r\n      opt = bin.makeWriteOptions(options),\r\n      writer = opt.writerFactory();\r\n    bin.writeMessage(this, writer, opt);\r\n    return writer.finish();\r\n  }\r\n  /**\r\n   * Serialize the message to a JSON value, a JavaScript value that can be\r\n   * passed to JSON.stringify().\r\n   */\r\n  toJson(options) {\r\n    const type = this.getType(),\r\n      json = type.runtime.json,\r\n      opt = json.makeWriteOptions(options);\r\n    return json.writeMessage(this, opt);\r\n  }\r\n  /**\r\n   * Serialize the message to a JSON string.\r\n   */\r\n  toJsonString(options) {\r\n    var _a;\r\n    const value = this.toJson(options);\r\n    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\r\n  }\r\n  /**\r\n   * Override for serialization behavior. This will be invoked when calling\r\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\r\n   *\r\n   * Note that this will not serialize google.protobuf.Any with a packed\r\n   * message because the protobuf JSON format specifies that it needs to be\r\n   * unpacked, and this is only possible with a type registry to look up the\r\n   * message type.  As a result, attempting to serialize a message with this\r\n   * type will throw an Error.\r\n   *\r\n   * This method is protected because you should not need to invoke it\r\n   * directly -- instead use JSON.stringify or toJsonString for\r\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\r\n   * use toJson.\r\n   */\r\n  toJSON() {\r\n    return this.toJson({\r\n      emitDefaultValues: true\r\n    });\r\n  }\r\n  /**\r\n   * Retrieve the MessageType of this message - a singleton that represents\r\n   * the protobuf message declaration and provides metadata for reflection-\r\n   * based operations.\r\n   */\r\n  getType() {\r\n    // Any class that extends Message _must_ provide a complete static\r\n    // implementation of MessageType.\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\r\n    return Object.getPrototypeOf(this).constructor;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Create a new message type using the given runtime.\r\n */\r\nfunction makeMessageType(runtime, typeName, fields, opt) {\r\n  var _a;\r\n  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\r\n  const type = {\r\n    [localName]: function (data) {\r\n      runtime.util.initFields(this);\r\n      runtime.util.initPartial(data, this);\r\n    }\r\n  }[localName];\r\n  Object.setPrototypeOf(type.prototype, new Message());\r\n  Object.assign(type, {\r\n    runtime,\r\n    typeName,\r\n    fields: runtime.util.newFieldList(fields),\r\n    fromBinary(bytes, options) {\r\n      return new type().fromBinary(bytes, options);\r\n    },\r\n    fromJson(jsonValue, options) {\r\n      return new type().fromJson(jsonValue, options);\r\n    },\r\n    fromJsonString(jsonString, options) {\r\n      return new type().fromJsonString(jsonString, options);\r\n    },\r\n    equals(a, b) {\r\n      return runtime.util.equals(type, a, b);\r\n    }\r\n  });\r\n  return type;\r\n}\r\n\r\n// Copyright 2008 Google Inc.  All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are\r\n// met:\r\n//\r\n// * Redistributions of source code must retain the above copyright\r\n// notice, this list of conditions and the following disclaimer.\r\n// * Redistributions in binary form must reproduce the above\r\n// copyright notice, this list of conditions and the following disclaimer\r\n// in the documentation and/or other materials provided with the\r\n// distribution.\r\n// * Neither the name of Google Inc. nor the names of its\r\n// contributors may be used to endorse or promote products derived from\r\n// this software without specific prior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n// Code generated by the Protocol Buffer compiler is owned by the owner\r\n// of the input file used when generating it.  This code is not\r\n// standalone and requires a support library to be linked with it.  This\r\n// support library is itself covered by the above license.\r\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\r\n/**\r\n * Read a 64 bit varint as two JS numbers.\r\n *\r\n * Returns tuple:\r\n * [0]: low bits\r\n * [1]: high bits\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\r\n */\r\nfunction varint64read() {\r\n  let lowBits = 0;\r\n  let highBits = 0;\r\n  for (let shift = 0; shift < 28; shift += 7) {\r\n    let b = this.buf[this.pos++];\r\n    lowBits |= (b & 0x7f) << shift;\r\n    if ((b & 0x80) == 0) {\r\n      this.assertBounds();\r\n      return [lowBits, highBits];\r\n    }\r\n  }\r\n  let middleByte = this.buf[this.pos++];\r\n  // last four bits of the first 32 bit number\r\n  lowBits |= (middleByte & 0x0f) << 28;\r\n  // 3 upper bits are part of the next 32 bit number\r\n  highBits = (middleByte & 0x70) >> 4;\r\n  if ((middleByte & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return [lowBits, highBits];\r\n  }\r\n  for (let shift = 3; shift <= 31; shift += 7) {\r\n    let b = this.buf[this.pos++];\r\n    highBits |= (b & 0x7f) << shift;\r\n    if ((b & 0x80) == 0) {\r\n      this.assertBounds();\r\n      return [lowBits, highBits];\r\n    }\r\n  }\r\n  throw new Error(\"invalid varint\");\r\n}\r\n/**\r\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\r\n */\r\nfunction varint64write(lo, hi, bytes) {\r\n  for (let i = 0; i < 28; i = i + 7) {\r\n    const shift = lo >>> i;\r\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\r\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\r\n    bytes.push(byte);\r\n    if (!hasNext) {\r\n      return;\r\n    }\r\n  }\r\n  const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\r\n  const hasMoreBits = !(hi >> 3 == 0);\r\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\r\n  if (!hasMoreBits) {\r\n    return;\r\n  }\r\n  for (let i = 3; i < 31; i = i + 7) {\r\n    const shift = hi >>> i;\r\n    const hasNext = !(shift >>> 7 == 0);\r\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\r\n    bytes.push(byte);\r\n    if (!hasNext) {\r\n      return;\r\n    }\r\n  }\r\n  bytes.push(hi >>> 31 & 0x01);\r\n}\r\n// constants for binary math\r\nconst TWO_PWR_32_DBL = 0x100000000;\r\n/**\r\n * Parse decimal string of 64 bit integer value as two JS numbers.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction int64FromString(dec) {\r\n  // Check for minus sign.\r\n  const minus = dec[0] === \"-\";\r\n  if (minus) {\r\n    dec = dec.slice(1);\r\n  }\r\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\r\n  // digits to binary. This is safe to do with floating point math because\r\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\r\n  const base = 1e6;\r\n  let lowBits = 0;\r\n  let highBits = 0;\r\n  function add1e6digit(begin, end) {\r\n    // Note: Number('') is 0.\r\n    const digit1e6 = Number(dec.slice(begin, end));\r\n    highBits *= base;\r\n    lowBits = lowBits * base + digit1e6;\r\n    // Carry bits from lowBits to\r\n    if (lowBits >= TWO_PWR_32_DBL) {\r\n      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\r\n      lowBits = lowBits % TWO_PWR_32_DBL;\r\n    }\r\n  }\r\n  add1e6digit(-24, -18);\r\n  add1e6digit(-18, -12);\r\n  add1e6digit(-12, -6);\r\n  add1e6digit(-6);\r\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\r\n}\r\n/**\r\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\r\n * into a decimal string.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction int64ToString(lo, hi) {\r\n  let bits = newBits(lo, hi);\r\n  // If we're treating the input as a signed value and the high bit is set, do\r\n  // a manual two's complement conversion before the decimal conversion.\r\n  const negative = bits.hi & 0x80000000;\r\n  if (negative) {\r\n    bits = negate(bits.lo, bits.hi);\r\n  }\r\n  const result = uInt64ToString(bits.lo, bits.hi);\r\n  return negative ? \"-\" + result : result;\r\n}\r\n/**\r\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\r\n * into a decimal string.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction uInt64ToString(lo, hi) {\r\n  ({\r\n    lo,\r\n    hi\r\n  } = toUnsigned(lo, hi));\r\n  // Skip the expensive conversion if the number is small enough to use the\r\n  // built-in conversions.\r\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\r\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\r\n  // integer precision.\r\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\r\n  if (hi <= 0x1FFFFF) {\r\n    return String(TWO_PWR_32_DBL * hi + lo);\r\n  }\r\n  // What this code is doing is essentially converting the input number from\r\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\r\n  // only 3 (very large) digits. Those digits are then trivial to convert to\r\n  // a base-10 string.\r\n  // The magic numbers used here are -\r\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\r\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\r\n  // Split 32:32 representation into 16:24:24 representation so our\r\n  // intermediate digits don't overflow.\r\n  const low = lo & 0xFFFFFF;\r\n  const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\r\n  const high = hi >> 16 & 0xFFFF;\r\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\r\n  // value in a digit at this step is representable as a 48-bit integer, which\r\n  // can be stored in a 64-bit floating point number.\r\n  let digitA = low + mid * 6777216 + high * 6710656;\r\n  let digitB = mid + high * 8147497;\r\n  let digitC = high * 2;\r\n  // Apply carries from A to B and from B to C.\r\n  const base = 10000000;\r\n  if (digitA >= base) {\r\n    digitB += Math.floor(digitA / base);\r\n    digitA %= base;\r\n  }\r\n  if (digitB >= base) {\r\n    digitC += Math.floor(digitB / base);\r\n    digitB %= base;\r\n  }\r\n  // If digitC is 0, then we should have returned in the trivial code path\r\n  // at the top for non-safe integers. Given this, we can assume both digitB\r\n  // and digitA need leading zeros.\r\n  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\r\n}\r\nfunction toUnsigned(lo, hi) {\r\n  return {\r\n    lo: lo >>> 0,\r\n    hi: hi >>> 0\r\n  };\r\n}\r\nfunction newBits(lo, hi) {\r\n  return {\r\n    lo: lo | 0,\r\n    hi: hi | 0\r\n  };\r\n}\r\n/**\r\n * Returns two's compliment negation of input.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\r\n */\r\nfunction negate(lowBits, highBits) {\r\n  highBits = ~highBits;\r\n  if (lowBits) {\r\n    lowBits = ~lowBits + 1;\r\n  } else {\r\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\r\n    // adding 1 to that, results in 0x100000000, which leaves\r\n    // the low bits 0x0 and simply adds one to the high bits.\r\n    highBits += 1;\r\n  }\r\n  return newBits(lowBits, highBits);\r\n}\r\n/**\r\n * Returns decimal representation of digit1e7 with leading zeros.\r\n */\r\nconst decimalFrom1e7WithLeadingZeros = digit1e7 => {\r\n  const partial = String(digit1e7);\r\n  return \"0000000\".slice(partial.length) + partial;\r\n};\r\n/**\r\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\r\n */\r\nfunction varint32write(value, bytes) {\r\n  if (value >= 0) {\r\n    // write value as varint 32\r\n    while (value > 0x7f) {\r\n      bytes.push(value & 0x7f | 0x80);\r\n      value = value >>> 7;\r\n    }\r\n    bytes.push(value);\r\n  } else {\r\n    for (let i = 0; i < 9; i++) {\r\n      bytes.push(value & 127 | 128);\r\n      value = value >> 7;\r\n    }\r\n    bytes.push(1);\r\n  }\r\n}\r\n/**\r\n * Read an unsigned 32 bit varint.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\r\n */\r\nfunction varint32read() {\r\n  let b = this.buf[this.pos++];\r\n  let result = b & 0x7f;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 7;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 14;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 21;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  // Extract only last 4 bits\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x0f) << 28;\r\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];\r\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\r\n  this.assertBounds();\r\n  // Result can have 32 bits, convert it to unsigned\r\n  return result >>> 0;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nfunction makeInt64Support() {\r\n  const dv = new DataView(new ArrayBuffer(8));\r\n  // note that Safari 14 implements BigInt, but not the DataView methods\r\n  const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\r\n  if (ok) {\r\n    const MIN = BigInt(\"-9223372036854775808\"),\r\n      MAX = BigInt(\"9223372036854775807\"),\r\n      UMIN = BigInt(\"0\"),\r\n      UMAX = BigInt(\"18446744073709551615\");\r\n    return {\r\n      zero: BigInt(0),\r\n      supported: true,\r\n      parse(value) {\r\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\r\n        if (bi > MAX || bi < MIN) {\r\n          throw new Error(\"int64 invalid: \".concat(value));\r\n        }\r\n        return bi;\r\n      },\r\n      uParse(value) {\r\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\r\n        if (bi > UMAX || bi < UMIN) {\r\n          throw new Error(\"uint64 invalid: \".concat(value));\r\n        }\r\n        return bi;\r\n      },\r\n      enc(value) {\r\n        dv.setBigInt64(0, this.parse(value), true);\r\n        return {\r\n          lo: dv.getInt32(0, true),\r\n          hi: dv.getInt32(4, true)\r\n        };\r\n      },\r\n      uEnc(value) {\r\n        dv.setBigInt64(0, this.uParse(value), true);\r\n        return {\r\n          lo: dv.getInt32(0, true),\r\n          hi: dv.getInt32(4, true)\r\n        };\r\n      },\r\n      dec(lo, hi) {\r\n        dv.setInt32(0, lo, true);\r\n        dv.setInt32(4, hi, true);\r\n        return dv.getBigInt64(0, true);\r\n      },\r\n      uDec(lo, hi) {\r\n        dv.setInt32(0, lo, true);\r\n        dv.setInt32(4, hi, true);\r\n        return dv.getBigUint64(0, true);\r\n      }\r\n    };\r\n  }\r\n  const assertInt64String = value => assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\r\n  const assertUInt64String = value => assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\r\n  return {\r\n    zero: \"0\",\r\n    supported: false,\r\n    parse(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertInt64String(value);\r\n      return value;\r\n    },\r\n    uParse(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertUInt64String(value);\r\n      return value;\r\n    },\r\n    enc(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertInt64String(value);\r\n      return int64FromString(value);\r\n    },\r\n    uEnc(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertUInt64String(value);\r\n      return int64FromString(value);\r\n    },\r\n    dec(lo, hi) {\r\n      return int64ToString(lo, hi);\r\n    },\r\n    uDec(lo, hi) {\r\n      return uInt64ToString(lo, hi);\r\n    }\r\n  };\r\n}\r\nconst protoInt64 = makeInt64Support();\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Scalar value types. This is a subset of field types declared by protobuf\r\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\r\n * are omitted, but the numerical values are identical.\r\n */\r\nvar ScalarType;\r\n(function (ScalarType) {\r\n  // 0 is reserved for errors.\r\n  // Order is weird for historical reasons.\r\n  ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\r\n  ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\r\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\r\n  // negative values are likely.\r\n  ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\r\n  ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\r\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\r\n  // negative values are likely.\r\n  ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\r\n  ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\r\n  ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\r\n  ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\r\n  ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\r\n  // Tag-delimited aggregate.\r\n  // Group type is deprecated and not supported in proto3. However, Proto3\r\n  // implementations should still be able to parse the group wire format and\r\n  // treat group fields as unknown fields.\r\n  // TYPE_GROUP = 10,\r\n  // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\r\n  // New in version 2.\r\n  ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\r\n  ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\r\n  // TYPE_ENUM = 14,\r\n  ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\r\n  ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\r\n  ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\r\n  ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\r\n})(ScalarType || (ScalarType = {}));\r\n/**\r\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\r\n * sint64, fixed64, sfixed64).\r\n *\r\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\r\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\r\n * String if `[jstype = JS_STRING]` is specified.\r\n *\r\n * ```protobuf\r\n * uint64 field_a = 1; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\r\n * ```\r\n */\r\nvar LongType;\r\n(function (LongType) {\r\n  /**\r\n   * Use JavaScript BigInt.\r\n   */\r\n  LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\r\n  /**\r\n   * Use JavaScript String.\r\n   *\r\n   * Field option `[jstype = JS_STRING]`.\r\n   */\r\n  LongType[LongType[\"STRING\"] = 1] = \"STRING\";\r\n})(LongType || (LongType = {}));\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns true if both scalar values are equal.\r\n */\r\nfunction scalarEquals(type, a, b) {\r\n  if (a === b) {\r\n    // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\r\n    return true;\r\n  }\r\n  // Special case BYTES - we need to compare each byte individually\r\n  if (type == ScalarType.BYTES) {\r\n    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\r\n      return false;\r\n    }\r\n    if (a.length !== b.length) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  // Special case 64-bit integers - we support number, string and bigint representation.\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n  switch (type) {\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      // Loose comparison will match between 0n, 0 and \"0\".\r\n      return a == b;\r\n  }\r\n  // Anything that hasn't been caught by strict comparison or special cased\r\n  // BYTES and 64-bit integers is not equal.\r\n  return false;\r\n}\r\n/**\r\n * Returns the zero value for the given scalar type.\r\n */\r\nfunction scalarZeroValue(type, longType) {\r\n  switch (type) {\r\n    case ScalarType.BOOL:\r\n      return false;\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\r\n      return longType == 0 ? protoInt64.zero : \"0\";\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FLOAT:\r\n      return 0.0;\r\n    case ScalarType.BYTES:\r\n      return new Uint8Array(0);\r\n    case ScalarType.STRING:\r\n      return \"\";\r\n    default:\r\n      // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\r\n      // We do not use individual cases to save a few bytes code size.\r\n      return 0;\r\n  }\r\n}\r\n/**\r\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\r\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\r\n *\r\n * In proto3, zero-values are not written to the wire, unless the field is\r\n * optional or repeated.\r\n */\r\nfunction isScalarZeroValue(type, value) {\r\n  switch (type) {\r\n    case ScalarType.BOOL:\r\n      return value === false;\r\n    case ScalarType.STRING:\r\n      return value === \"\";\r\n    case ScalarType.BYTES:\r\n      return value instanceof Uint8Array && !value.byteLength;\r\n    default:\r\n      return value == 0;\r\n    // Loose comparison matches 0n, 0 and \"0\"\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\r\n/**\r\n * Protobuf binary format wire types.\r\n *\r\n * A wire type provides just enough information to find the length of the\r\n * following value.\r\n *\r\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\r\n */\r\nvar WireType;\r\n(function (WireType) {\r\n  /**\r\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\r\n   */\r\n  WireType[WireType[\"Varint\"] = 0] = \"Varint\";\r\n  /**\r\n   * Used for fixed64, sfixed64, double.\r\n   * Always 8 bytes with little-endian byte order.\r\n   */\r\n  WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\r\n  /**\r\n   * Used for string, bytes, embedded messages, packed repeated fields\r\n   *\r\n   * Only repeated numeric types (types which use the varint, 32-bit,\r\n   * or 64-bit wire types) can be packed. In proto3, such fields are\r\n   * packed by default.\r\n   */\r\n  WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\r\n  /**\r\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\r\n   * in editions with message_encoding = DELIMITED.\r\n   */\r\n  WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\r\n  /**\r\n   * End of a tag-delimited aggregate.\r\n   */\r\n  WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\r\n  /**\r\n   * Used for fixed32, sfixed32, float.\r\n   * Always 4 bytes with little-endian byte order.\r\n   */\r\n  WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\r\n})(WireType || (WireType = {}));\r\nclass BinaryWriter {\r\n  constructor(textEncoder) {\r\n    /**\r\n     * Previous fork states.\r\n     */\r\n    this.stack = [];\r\n    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\r\n    this.chunks = [];\r\n    this.buf = [];\r\n  }\r\n  /**\r\n   * Return all bytes written and reset this writer.\r\n   */\r\n  finish() {\r\n    this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\r\n    let len = 0;\r\n    for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;\r\n    let bytes = new Uint8Array(len);\r\n    let offset = 0;\r\n    for (let i = 0; i < this.chunks.length; i++) {\r\n      bytes.set(this.chunks[i], offset);\r\n      offset += this.chunks[i].length;\r\n    }\r\n    this.chunks = [];\r\n    return bytes;\r\n  }\r\n  /**\r\n   * Start a new fork for length-delimited data like a message\r\n   * or a packed repeated field.\r\n   *\r\n   * Must be joined later with `join()`.\r\n   */\r\n  fork() {\r\n    this.stack.push({\r\n      chunks: this.chunks,\r\n      buf: this.buf\r\n    });\r\n    this.chunks = [];\r\n    this.buf = [];\r\n    return this;\r\n  }\r\n  /**\r\n   * Join the last fork. Write its length and bytes, then\r\n   * return to the previous state.\r\n   */\r\n  join() {\r\n    // get chunk of fork\r\n    let chunk = this.finish();\r\n    // restore previous state\r\n    let prev = this.stack.pop();\r\n    if (!prev) throw new Error(\"invalid state, fork stack empty\");\r\n    this.chunks = prev.chunks;\r\n    this.buf = prev.buf;\r\n    // write length of chunk as varint\r\n    this.uint32(chunk.byteLength);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Writes a tag (field number and wire type).\r\n   *\r\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\r\n   *\r\n   * Generated code should compute the tag ahead of time and call `uint32()`.\r\n   */\r\n  tag(fieldNo, type) {\r\n    return this.uint32((fieldNo << 3 | type) >>> 0);\r\n  }\r\n  /**\r\n   * Write a chunk of raw bytes.\r\n   */\r\n  raw(chunk) {\r\n    if (this.buf.length) {\r\n      this.chunks.push(new Uint8Array(this.buf));\r\n      this.buf = [];\r\n    }\r\n    this.chunks.push(chunk);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `uint32` value, an unsigned 32 bit varint.\r\n   */\r\n  uint32(value) {\r\n    assertUInt32(value);\r\n    // write value as varint 32, inlined for speed\r\n    while (value > 0x7f) {\r\n      this.buf.push(value & 0x7f | 0x80);\r\n      value = value >>> 7;\r\n    }\r\n    this.buf.push(value);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `int32` value, a signed 32 bit varint.\r\n   */\r\n  int32(value) {\r\n    assertInt32(value);\r\n    varint32write(value, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `bool` value, a variant.\r\n   */\r\n  bool(value) {\r\n    this.buf.push(value ? 1 : 0);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `bytes` value, length-delimited arbitrary data.\r\n   */\r\n  bytes(value) {\r\n    this.uint32(value.byteLength); // write length of chunk as varint\r\n    return this.raw(value);\r\n  }\r\n  /**\r\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\r\n   */\r\n  string(value) {\r\n    let chunk = this.textEncoder.encode(value);\r\n    this.uint32(chunk.byteLength); // write length of chunk as varint\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `float` value, 32-bit floating point number.\r\n   */\r\n  float(value) {\r\n    assertFloat32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setFloat32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `double` value, a 64-bit floating point number.\r\n   */\r\n  double(value) {\r\n    let chunk = new Uint8Array(8);\r\n    new DataView(chunk.buffer).setFloat64(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\r\n   */\r\n  fixed32(value) {\r\n    assertUInt32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setUint32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\r\n   */\r\n  sfixed32(value) {\r\n    assertInt32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setInt32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\r\n   */\r\n  sint32(value) {\r\n    assertInt32(value);\r\n    // zigzag encode\r\n    value = (value << 1 ^ value >> 31) >>> 0;\r\n    varint32write(value, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\r\n   */\r\n  sfixed64(value) {\r\n    let chunk = new Uint8Array(8),\r\n      view = new DataView(chunk.buffer),\r\n      tc = protoInt64.enc(value);\r\n    view.setInt32(0, tc.lo, true);\r\n    view.setInt32(4, tc.hi, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\r\n   */\r\n  fixed64(value) {\r\n    let chunk = new Uint8Array(8),\r\n      view = new DataView(chunk.buffer),\r\n      tc = protoInt64.uEnc(value);\r\n    view.setInt32(0, tc.lo, true);\r\n    view.setInt32(4, tc.hi, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `int64` value, a signed 64-bit varint.\r\n   */\r\n  int64(value) {\r\n    let tc = protoInt64.enc(value);\r\n    varint64write(tc.lo, tc.hi, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\r\n   */\r\n  sint64(value) {\r\n    let tc = protoInt64.enc(value),\r\n      // zigzag encode\r\n      sign = tc.hi >> 31,\r\n      lo = tc.lo << 1 ^ sign,\r\n      hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\r\n    varint64write(lo, hi, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `uint64` value, an unsigned 64-bit varint.\r\n   */\r\n  uint64(value) {\r\n    let tc = protoInt64.uEnc(value);\r\n    varint64write(tc.lo, tc.hi, this.buf);\r\n    return this;\r\n  }\r\n}\r\nclass BinaryReader {\r\n  constructor(buf, textDecoder) {\r\n    this.varint64 = varint64read; // dirty cast for `this`\r\n    /**\r\n     * Read a `uint32` field, an unsigned 32 bit varint.\r\n     */\r\n    this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\r\n    this.buf = buf;\r\n    this.len = buf.length;\r\n    this.pos = 0;\r\n    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\r\n    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\r\n  }\r\n  /**\r\n   * Reads a tag - field number and wire type.\r\n   */\r\n  tag() {\r\n    let tag = this.uint32(),\r\n      fieldNo = tag >>> 3,\r\n      wireType = tag & 7;\r\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\r\n    return [fieldNo, wireType];\r\n  }\r\n  /**\r\n   * Skip one element and return the skipped data.\r\n   *\r\n   * When skipping StartGroup, provide the tags field number to check for\r\n   * matching field number in the EndGroup tag.\r\n   */\r\n  skip(wireType, fieldNo) {\r\n    let start = this.pos;\r\n    switch (wireType) {\r\n      case WireType.Varint:\r\n        while (this.buf[this.pos++] & 0x80) {\r\n          // ignore\r\n        }\r\n        break;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore TS7029: Fallthrough case in switch\r\n      case WireType.Bit64:\r\n        this.pos += 4;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore TS7029: Fallthrough case in switch\r\n      case WireType.Bit32:\r\n        this.pos += 4;\r\n        break;\r\n      case WireType.LengthDelimited:\r\n        let len = this.uint32();\r\n        this.pos += len;\r\n        break;\r\n      case WireType.StartGroup:\r\n        for (;;) {\r\n          const [fn, wt] = this.tag();\r\n          if (wt === WireType.EndGroup) {\r\n            if (fieldNo !== undefined && fn !== fieldNo) {\r\n              throw new Error(\"invalid end group tag\");\r\n            }\r\n            break;\r\n          }\r\n          this.skip(wt, fn);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error(\"cant skip wire type \" + wireType);\r\n    }\r\n    this.assertBounds();\r\n    return this.buf.subarray(start, this.pos);\r\n  }\r\n  /**\r\n   * Throws error if position in byte array is out of range.\r\n   */\r\n  assertBounds() {\r\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\r\n  }\r\n  /**\r\n   * Read a `int32` field, a signed 32 bit varint.\r\n   */\r\n  int32() {\r\n    return this.uint32() | 0;\r\n  }\r\n  /**\r\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\r\n   */\r\n  sint32() {\r\n    let zze = this.uint32();\r\n    // decode zigzag\r\n    return zze >>> 1 ^ -(zze & 1);\r\n  }\r\n  /**\r\n   * Read a `int64` field, a signed 64-bit varint.\r\n   */\r\n  int64() {\r\n    return protoInt64.dec(...this.varint64());\r\n  }\r\n  /**\r\n   * Read a `uint64` field, an unsigned 64-bit varint.\r\n   */\r\n  uint64() {\r\n    return protoInt64.uDec(...this.varint64());\r\n  }\r\n  /**\r\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\r\n   */\r\n  sint64() {\r\n    let [lo, hi] = this.varint64();\r\n    // decode zig zag\r\n    let s = -(lo & 1);\r\n    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\r\n    hi = hi >>> 1 ^ s;\r\n    return protoInt64.dec(lo, hi);\r\n  }\r\n  /**\r\n   * Read a `bool` field, a variant.\r\n   */\r\n  bool() {\r\n    let [lo, hi] = this.varint64();\r\n    return lo !== 0 || hi !== 0;\r\n  }\r\n  /**\r\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\r\n   */\r\n  fixed32() {\r\n    return this.view.getUint32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\r\n   */\r\n  sfixed32() {\r\n    return this.view.getInt32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\r\n   */\r\n  fixed64() {\r\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\r\n  }\r\n  /**\r\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\r\n   */\r\n  sfixed64() {\r\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\r\n  }\r\n  /**\r\n   * Read a `float` field, 32-bit floating point number.\r\n   */\r\n  float() {\r\n    return this.view.getFloat32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `double` field, a 64-bit floating point number.\r\n   */\r\n  double() {\r\n    return this.view.getFloat64((this.pos += 8) - 8, true);\r\n  }\r\n  /**\r\n   * Read a `bytes` field, length-delimited arbitrary data.\r\n   */\r\n  bytes() {\r\n    let len = this.uint32(),\r\n      start = this.pos;\r\n    this.pos += len;\r\n    this.assertBounds();\r\n    return this.buf.subarray(start, start + len);\r\n  }\r\n  /**\r\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\r\n   */\r\n  string() {\r\n    return this.textDecoder.decode(this.bytes());\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Create a new extension using the given runtime.\r\n */\r\nfunction makeExtension(runtime, typeName, extendee, field) {\r\n  let fi;\r\n  return {\r\n    typeName,\r\n    extendee,\r\n    get field() {\r\n      if (!fi) {\r\n        const i = typeof field == \"function\" ? field() : field;\r\n        i.name = typeName.split(\".\").pop();\r\n        i.jsonName = \"[\".concat(typeName, \"]\");\r\n        fi = runtime.util.newFieldList([i]).list()[0];\r\n      }\r\n      return fi;\r\n    },\r\n    runtime\r\n  };\r\n}\r\n/**\r\n * Create a container that allows us to read extension fields into it with the\r\n * same logic as regular fields.\r\n */\r\nfunction createExtensionContainer(extension) {\r\n  const localName = extension.field.localName;\r\n  const container = Object.create(null);\r\n  container[localName] = initExtensionField(extension);\r\n  return [container, () => container[localName]];\r\n}\r\nfunction initExtensionField(ext) {\r\n  const field = ext.field;\r\n  if (field.repeated) {\r\n    return [];\r\n  }\r\n  if (field.default !== undefined) {\r\n    return field.default;\r\n  }\r\n  switch (field.kind) {\r\n    case \"enum\":\r\n      return field.T.values[0].no;\r\n    case \"scalar\":\r\n      return scalarZeroValue(field.T, field.L);\r\n    case \"message\":\r\n      // eslint-disable-next-line no-case-declarations\r\n      const T = field.T,\r\n        value = new T();\r\n      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\r\n    case \"map\":\r\n      throw \"map fields are not allowed to be extensions\";\r\n  }\r\n}\r\n/**\r\n * Helper to filter unknown fields, optimized based on field type.\r\n */\r\nfunction filterUnknownFields(unknownFields, field) {\r\n  if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\r\n    // singular scalar fields do not merge, we pick the last\r\n    for (let i = unknownFields.length - 1; i >= 0; --i) {\r\n      if (unknownFields[i].no == field.no) {\r\n        return [unknownFields[i]];\r\n      }\r\n    }\r\n    return [];\r\n  }\r\n  return unknownFields.filter(uf => uf.no === field.no);\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\r\n// lookup table from base64 character to byte\r\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\r\n// lookup table from base64 character *code* to byte because lookup by number is fast\r\nlet decTable = [];\r\nfor (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;\r\n// support base64url variants\r\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\r\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\r\nconst protoBase64 = {\r\n  /**\r\n   * Decodes a base64 string to a byte array.\r\n   *\r\n   * - ignores white-space, including line breaks and tabs\r\n   * - allows inner padding (can decode concatenated base64 strings)\r\n   * - does not require padding\r\n   * - understands base64url encoding:\r\n   *   \"-\" instead of \"+\",\r\n   *   \"_\" instead of \"/\",\r\n   *   no padding\r\n   */\r\n  dec(base64Str) {\r\n    // estimate byte size, not accounting for inner padding and whitespace\r\n    let es = base64Str.length * 3 / 4;\r\n    if (base64Str[base64Str.length - 2] == \"=\") es -= 2;else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\r\n    let bytes = new Uint8Array(es),\r\n      bytePos = 0,\r\n      // position in byte array\r\n      groupPos = 0,\r\n      // position in base64 group\r\n      b,\r\n      // current byte\r\n      p = 0; // previous byte\r\n    for (let i = 0; i < base64Str.length; i++) {\r\n      b = decTable[base64Str.charCodeAt(i)];\r\n      if (b === undefined) {\r\n        switch (base64Str[i]) {\r\n          // @ts-ignore TS7029: Fallthrough case in switch\r\n          case \"=\":\r\n            groupPos = 0;\r\n          // reset state when padding found\r\n          // @ts-ignore TS7029: Fallthrough case in switch\r\n          case \"\\n\":\r\n          case \"\\r\":\r\n          case \"\\t\":\r\n          case \" \":\r\n            continue;\r\n          // skip white-space, and padding\r\n          default:\r\n            throw Error(\"invalid base64 string.\");\r\n        }\r\n      }\r\n      switch (groupPos) {\r\n        case 0:\r\n          p = b;\r\n          groupPos = 1;\r\n          break;\r\n        case 1:\r\n          bytes[bytePos++] = p << 2 | (b & 48) >> 4;\r\n          p = b;\r\n          groupPos = 2;\r\n          break;\r\n        case 2:\r\n          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\r\n          p = b;\r\n          groupPos = 3;\r\n          break;\r\n        case 3:\r\n          bytes[bytePos++] = (p & 3) << 6 | b;\r\n          groupPos = 0;\r\n          break;\r\n      }\r\n    }\r\n    if (groupPos == 1) throw Error(\"invalid base64 string.\");\r\n    return bytes.subarray(0, bytePos);\r\n  },\r\n  /**\r\n   * Encode a byte array to a base64 string.\r\n   */\r\n  enc(bytes) {\r\n    let base64 = \"\",\r\n      groupPos = 0,\r\n      // position in base64 group\r\n      b,\r\n      // current byte\r\n      p = 0; // carry over from previous byte\r\n    for (let i = 0; i < bytes.length; i++) {\r\n      b = bytes[i];\r\n      switch (groupPos) {\r\n        case 0:\r\n          base64 += encTable[b >> 2];\r\n          p = (b & 3) << 4;\r\n          groupPos = 1;\r\n          break;\r\n        case 1:\r\n          base64 += encTable[p | b >> 4];\r\n          p = (b & 15) << 2;\r\n          groupPos = 2;\r\n          break;\r\n        case 2:\r\n          base64 += encTable[p | b >> 6];\r\n          base64 += encTable[b & 63];\r\n          groupPos = 0;\r\n          break;\r\n      }\r\n    }\r\n    // add output padding\r\n    if (groupPos) {\r\n      base64 += encTable[p];\r\n      base64 += \"=\";\r\n      if (groupPos == 1) base64 += \"=\";\r\n    }\r\n    return base64;\r\n  }\r\n};\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Retrieve an extension value from a message.\r\n *\r\n * The function never returns undefined. Use hasExtension() to check whether an\r\n * extension is set. If the extension is not set, this function returns the\r\n * default value (if one was specified in the protobuf source), or the zero value\r\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\r\n * an empty message instance for message fields).\r\n *\r\n * Extensions are stored as unknown fields on a message. To mutate an extension\r\n * value, make sure to store the new value with setExtension() after mutating.\r\n *\r\n * If the extension does not extend the given message, an error is raised.\r\n */\r\nfunction getExtension(message, extension, options) {\r\n  assertExtendee(extension, message);\r\n  const opt = extension.runtime.bin.makeReadOptions(options);\r\n  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\r\n  const [container, get] = createExtensionContainer(extension);\r\n  for (const uf of ufs) {\r\n    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\r\n  }\r\n  return get();\r\n}\r\n/**\r\n * Set an extension value on a message. If the message already has a value for\r\n * this extension, the value is replaced.\r\n *\r\n * If the extension does not extend the given message, an error is raised.\r\n */\r\nfunction setExtension(message, extension, value, options) {\r\n  assertExtendee(extension, message);\r\n  const readOpt = extension.runtime.bin.makeReadOptions(options);\r\n  const writeOpt = extension.runtime.bin.makeWriteOptions(options);\r\n  if (hasExtension(message, extension)) {\r\n    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter(uf => uf.no != extension.field.no);\r\n    message.getType().runtime.bin.discardUnknownFields(message);\r\n    for (const uf of ufs) {\r\n      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\r\n    }\r\n  }\r\n  const writer = writeOpt.writerFactory();\r\n  let f = extension.field;\r\n  // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\r\n  // We patch the field info to use explicit presence:\r\n  if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\r\n    f = Object.assign(Object.assign({}, extension.field), {\r\n      opt: true\r\n    });\r\n  }\r\n  extension.runtime.bin.writeField(f, value, writer, writeOpt);\r\n  const reader = readOpt.readerFactory(writer.finish());\r\n  while (reader.pos < reader.len) {\r\n    const [no, wireType] = reader.tag();\r\n    const data = reader.skip(wireType, no);\r\n    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\r\n  }\r\n}\r\n/**\r\n * Check whether an extension is set on a message.\r\n */\r\nfunction hasExtension(message, extension) {\r\n  const messageType = message.getType();\r\n  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(uf => uf.no == extension.field.no);\r\n}\r\nfunction assertExtendee(extension, message) {\r\n  assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns true if the field is set.\r\n */\r\nfunction isFieldSet(field, target) {\r\n  const localName = field.localName;\r\n  if (field.repeated) {\r\n    return target[localName].length > 0;\r\n  }\r\n  if (field.oneof) {\r\n    return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\r\n  }\r\n  switch (field.kind) {\r\n    case \"enum\":\r\n    case \"scalar\":\r\n      if (field.opt || field.req) {\r\n        // explicit presence\r\n        return target[localName] !== undefined;\r\n      }\r\n      // implicit presence\r\n      if (field.kind == \"enum\") {\r\n        return target[localName] !== field.T.values[0].no;\r\n      }\r\n      return !isScalarZeroValue(field.T, target[localName]);\r\n    case \"message\":\r\n      return target[localName] !== undefined;\r\n    case \"map\":\r\n      return Object.keys(target[localName]).length > 0;\r\n    // eslint-disable-line @typescript-eslint/no-unsafe-argument\r\n  }\r\n}\r\n/**\r\n * Resets the field, so that isFieldSet() will return false.\r\n */\r\nfunction clearField(field, target) {\r\n  const localName = field.localName;\r\n  const implicitPresence = !field.opt && !field.req;\r\n  if (field.repeated) {\r\n    target[localName] = [];\r\n  } else if (field.oneof) {\r\n    target[field.oneof.localName] = {\r\n      case: undefined\r\n    };\r\n  } else {\r\n    switch (field.kind) {\r\n      case \"map\":\r\n        target[localName] = {};\r\n        break;\r\n      case \"enum\":\r\n        target[localName] = implicitPresence ? field.T.values[0].no : undefined;\r\n        break;\r\n      case \"scalar\":\r\n        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\r\n        break;\r\n      case \"message\":\r\n        target[localName] = undefined;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Check whether the given object is any subtype of Message or is a specific\r\n * Message by passing the type.\r\n *\r\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\r\n * `isMessage` is that it compares identity by the message type name, not by\r\n * class identity. This makes it robust against the dual package hazard and\r\n * similar situations, where the same message is duplicated.\r\n *\r\n * This function is _mostly_ equivalent to the `instanceof` operator. For\r\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\r\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\r\n * `isMessage` should be preferred over `instanceof`.\r\n *\r\n * However, due to the fact that `isMessage` does not use class identity, there\r\n * are subtle differences between this function and `instanceof`. Notably,\r\n * calling `isMessage` on an explicit type of Message will return false.\r\n */\r\nfunction isMessage(arg, type) {\r\n  if (arg === null || typeof arg != \"object\") {\r\n    return false;\r\n  }\r\n  if (!Object.getOwnPropertyNames(Message.prototype).every(m => m in arg && typeof arg[m] == \"function\")) {\r\n    return false;\r\n  }\r\n  const actualType = arg.getType();\r\n  if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\r\n    return false;\r\n  }\r\n  return type === undefined ? true : actualType.typeName == type.typeName;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Wrap a primitive message field value in its corresponding wrapper\r\n * message. This function is idempotent.\r\n */\r\nfunction wrapField(type, value) {\r\n  if (isMessage(value) || !type.fieldWrapper) {\r\n    return value;\r\n  }\r\n  return type.fieldWrapper.wrapField(value);\r\n}\r\n({\r\n  \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\r\n  \"google.protobuf.FloatValue\": ScalarType.FLOAT,\r\n  \"google.protobuf.Int64Value\": ScalarType.INT64,\r\n  \"google.protobuf.UInt64Value\": ScalarType.UINT64,\r\n  \"google.protobuf.Int32Value\": ScalarType.INT32,\r\n  \"google.protobuf.UInt32Value\": ScalarType.UINT32,\r\n  \"google.protobuf.BoolValue\": ScalarType.BOOL,\r\n  \"google.protobuf.StringValue\": ScalarType.STRING,\r\n  \"google.protobuf.BytesValue\": ScalarType.BYTES\r\n});\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */\r\n// Default options for parsing JSON.\r\nconst jsonReadDefaults = {\r\n  ignoreUnknownFields: false\r\n};\r\n// Default options for serializing to JSON.\r\nconst jsonWriteDefaults = {\r\n  emitDefaultValues: false,\r\n  enumAsInteger: false,\r\n  useProtoFieldName: false,\r\n  prettySpaces: 0\r\n};\r\nfunction makeReadOptions$1(options) {\r\n  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\r\n}\r\nfunction makeWriteOptions$1(options) {\r\n  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\r\n}\r\nconst tokenNull = Symbol();\r\nconst tokenIgnoredUnknownEnum = Symbol();\r\nfunction makeJsonFormat() {\r\n  return {\r\n    makeReadOptions: makeReadOptions$1,\r\n    makeWriteOptions: makeWriteOptions$1,\r\n    readMessage(type, json, options, message) {\r\n      if (json == null || Array.isArray(json) || typeof json != \"object\") {\r\n        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\r\n      }\r\n      message = message !== null && message !== void 0 ? message : new type();\r\n      const oneofSeen = new Map();\r\n      const registry = options.typeRegistry;\r\n      for (const [jsonKey, jsonValue] of Object.entries(json)) {\r\n        const field = type.fields.findJsonName(jsonKey);\r\n        if (field) {\r\n          if (field.oneof) {\r\n            if (jsonValue === null && field.kind == \"scalar\") {\r\n              // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\r\n              continue;\r\n            }\r\n            const seen = oneofSeen.get(field.oneof);\r\n            if (seen !== undefined) {\r\n              throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\r\n            }\r\n            oneofSeen.set(field.oneof, jsonKey);\r\n          }\r\n          readField$1(message, jsonValue, field, options, type);\r\n        } else {\r\n          let found = false;\r\n          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\r\n            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\r\n            if (ext && ext.extendee.typeName == type.typeName) {\r\n              found = true;\r\n              const [container, get] = createExtensionContainer(ext);\r\n              readField$1(container, jsonValue, ext.field, options, ext);\r\n              // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\r\n              // so that users can bring their own binary reader and writer factories\r\n              // if necessary.\r\n              setExtension(message, ext, get(), options);\r\n            }\r\n          }\r\n          if (!found && !options.ignoreUnknownFields) {\r\n            throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\r\n          }\r\n        }\r\n      }\r\n      return message;\r\n    },\r\n    writeMessage(message, options) {\r\n      const type = message.getType();\r\n      const json = {};\r\n      let field;\r\n      try {\r\n        for (field of type.fields.byNumber()) {\r\n          if (!isFieldSet(field, message)) {\r\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n            if (field.req) {\r\n              throw \"required field not set\";\r\n            }\r\n            if (!options.emitDefaultValues) {\r\n              continue;\r\n            }\r\n            if (!canEmitFieldDefaultValue(field)) {\r\n              continue;\r\n            }\r\n          }\r\n          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\r\n          const jsonValue = writeField$1(field, value, options);\r\n          if (jsonValue !== undefined) {\r\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\r\n          }\r\n        }\r\n        const registry = options.typeRegistry;\r\n        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\r\n          for (const uf of type.runtime.bin.listUnknownFields(message)) {\r\n            const ext = registry.findExtensionFor(type.typeName, uf.no);\r\n            if (ext && hasExtension(message, ext)) {\r\n              // We pass on the options as BinaryReadOptions, so that users can bring their own\r\n              // binary reader factory if necessary.\r\n              const value = getExtension(message, ext, options);\r\n              const jsonValue = writeField$1(ext.field, value, options);\r\n              if (jsonValue !== undefined) {\r\n                json[ext.field.jsonName] = jsonValue;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (e) {\r\n        const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\r\n        const r = e instanceof Error ? e.message : String(e);\r\n        throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\r\n      }\r\n      return json;\r\n    },\r\n    readScalar(type, json, longType) {\r\n      // The signature of our internal function has changed. For backwards-\r\n      // compatibility, we support the old form that is part of the public API\r\n      // through the interface JsonFormat.\r\n      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\r\n    },\r\n    writeScalar(type, value, emitDefaultValues) {\r\n      // The signature of our internal function has changed. For backwards-\r\n      // compatibility, we support the old form that is part of the public API\r\n      // through the interface JsonFormat.\r\n      if (value === undefined) {\r\n        return undefined;\r\n      }\r\n      if (emitDefaultValues || isScalarZeroValue(type, value)) {\r\n        return writeScalar$1(type, value);\r\n      }\r\n      return undefined;\r\n    },\r\n    debug: debugJsonValue\r\n  };\r\n}\r\nfunction debugJsonValue(json) {\r\n  if (json === null) {\r\n    return \"null\";\r\n  }\r\n  switch (typeof json) {\r\n    case \"object\":\r\n      return Array.isArray(json) ? \"array\" : \"object\";\r\n    case \"string\":\r\n      return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\r\n    default:\r\n      return String(json);\r\n  }\r\n}\r\n// Read a JSON value for a field.\r\n// The \"parentType\" argument is only used to provide context in errors.\r\nfunction readField$1(target, jsonValue, field, options, parentType) {\r\n  let localName = field.localName;\r\n  if (field.repeated) {\r\n    assert(field.kind != \"map\");\r\n    if (jsonValue === null) {\r\n      return;\r\n    }\r\n    if (!Array.isArray(jsonValue)) {\r\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\r\n    }\r\n    const targetArray = target[localName];\r\n    for (const jsonItem of jsonValue) {\r\n      if (jsonItem === null) {\r\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\r\n      }\r\n      switch (field.kind) {\r\n        case \"message\":\r\n          targetArray.push(field.T.fromJson(jsonItem, options));\r\n          break;\r\n        case \"enum\":\r\n          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\r\n          if (enumValue !== tokenIgnoredUnknownEnum) {\r\n            targetArray.push(enumValue);\r\n          }\r\n          break;\r\n        case \"scalar\":\r\n          try {\r\n            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\r\n          } catch (e) {\r\n            let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\r\n            if (e instanceof Error && e.message.length > 0) {\r\n              m += \": \".concat(e.message);\r\n            }\r\n            throw new Error(m);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  } else if (field.kind == \"map\") {\r\n    if (jsonValue === null) {\r\n      return;\r\n    }\r\n    if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\r\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\r\n    }\r\n    const targetMap = target[localName];\r\n    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\r\n      if (jsonMapValue === null) {\r\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\r\n      }\r\n      let key;\r\n      try {\r\n        key = readMapKey(field.K, jsonMapKey);\r\n      } catch (e) {\r\n        let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n        if (e instanceof Error && e.message.length > 0) {\r\n          m += \": \".concat(e.message);\r\n        }\r\n        throw new Error(m);\r\n      }\r\n      switch (field.V.kind) {\r\n        case \"message\":\r\n          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\r\n          break;\r\n        case \"enum\":\r\n          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\r\n          if (enumValue !== tokenIgnoredUnknownEnum) {\r\n            targetMap[key] = enumValue;\r\n          }\r\n          break;\r\n        case \"scalar\":\r\n          try {\r\n            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\r\n          } catch (e) {\r\n            let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n            if (e instanceof Error && e.message.length > 0) {\r\n              m += \": \".concat(e.message);\r\n            }\r\n            throw new Error(m);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  } else {\r\n    if (field.oneof) {\r\n      target = target[field.oneof.localName] = {\r\n        case: localName\r\n      };\r\n      localName = \"value\";\r\n    }\r\n    switch (field.kind) {\r\n      case \"message\":\r\n        const messageType = field.T;\r\n        if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\r\n          return;\r\n        }\r\n        let currentValue = target[localName];\r\n        if (isMessage(currentValue)) {\r\n          currentValue.fromJson(jsonValue, options);\r\n        } else {\r\n          target[localName] = currentValue = messageType.fromJson(jsonValue, options);\r\n          if (messageType.fieldWrapper && !field.oneof) {\r\n            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\r\n          }\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\r\n        switch (enumValue) {\r\n          case tokenNull:\r\n            clearField(field, target);\r\n            break;\r\n          case tokenIgnoredUnknownEnum:\r\n            break;\r\n          default:\r\n            target[localName] = enumValue;\r\n            break;\r\n        }\r\n        break;\r\n      case \"scalar\":\r\n        try {\r\n          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\r\n          switch (scalarValue) {\r\n            case tokenNull:\r\n              clearField(field, target);\r\n              break;\r\n            default:\r\n              target[localName] = scalarValue;\r\n              break;\r\n          }\r\n        } catch (e) {\r\n          let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n          if (e instanceof Error && e.message.length > 0) {\r\n            m += \": \".concat(e.message);\r\n          }\r\n          throw new Error(m);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n}\r\nfunction readMapKey(type, json) {\r\n  if (type === ScalarType.BOOL) {\r\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n    switch (json) {\r\n      case \"true\":\r\n        json = true;\r\n        break;\r\n      case \"false\":\r\n        json = false;\r\n        break;\r\n    }\r\n  }\r\n  return readScalar$1(type, json, LongType.BIGINT, true).toString();\r\n}\r\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\r\n  if (json === null) {\r\n    if (nullAsZeroValue) {\r\n      return scalarZeroValue(type, longType);\r\n    }\r\n    return tokenNull;\r\n  }\r\n  // every valid case in the switch below returns, and every fall\r\n  // through is regarded as a failure.\r\n  switch (type) {\r\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\r\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FLOAT:\r\n      if (json === \"NaN\") return Number.NaN;\r\n      if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\r\n      if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\r\n      if (json === \"\") {\r\n        // empty string is not a number\r\n        break;\r\n      }\r\n      if (typeof json == \"string\" && json.trim().length !== json.length) {\r\n        // extra whitespace\r\n        break;\r\n      }\r\n      if (typeof json != \"string\" && typeof json != \"number\") {\r\n        break;\r\n      }\r\n      const float = Number(json);\r\n      if (Number.isNaN(float)) {\r\n        // not a number\r\n        break;\r\n      }\r\n      if (!Number.isFinite(float)) {\r\n        // infinity and -infinity are handled by string representation above, so this is an error\r\n        break;\r\n      }\r\n      if (type == ScalarType.FLOAT) assertFloat32(float);\r\n      return float;\r\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\r\n    case ScalarType.INT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n    case ScalarType.UINT32:\r\n      let int32;\r\n      if (typeof json == \"number\") int32 = json;else if (typeof json == \"string\" && json.length > 0) {\r\n        if (json.trim().length === json.length) int32 = Number(json);\r\n      }\r\n      if (int32 === undefined) break;\r\n      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);else assertInt32(int32);\r\n      return int32;\r\n    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      if (typeof json != \"number\" && typeof json != \"string\") break;\r\n      const long = protoInt64.parse(json);\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      return longType ? long.toString() : long;\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.UINT64:\r\n      if (typeof json != \"number\" && typeof json != \"string\") break;\r\n      const uLong = protoInt64.uParse(json);\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      return longType ? uLong.toString() : uLong;\r\n    // bool:\r\n    case ScalarType.BOOL:\r\n      if (typeof json !== \"boolean\") break;\r\n      return json;\r\n    // string:\r\n    case ScalarType.STRING:\r\n      if (typeof json !== \"string\") {\r\n        break;\r\n      }\r\n      // A string must always contain UTF-8 encoded or 7-bit ASCII.\r\n      // We validate with encodeURIComponent, which appears to be the fastest widely available option.\r\n      try {\r\n        encodeURIComponent(json);\r\n      } catch (e) {\r\n        throw new Error(\"invalid UTF8\");\r\n      }\r\n      return json;\r\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\r\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\r\n    case ScalarType.BYTES:\r\n      if (json === \"\") return new Uint8Array(0);\r\n      if (typeof json !== \"string\") break;\r\n      return protoBase64.dec(json);\r\n  }\r\n  throw new Error();\r\n}\r\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\r\n  if (json === null) {\r\n    if (type.typeName == \"google.protobuf.NullValue\") {\r\n      return 0; // google.protobuf.NullValue.NULL_VALUE = 0\r\n    }\r\n    return nullAsZeroValue ? type.values[0].no : tokenNull;\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n  switch (typeof json) {\r\n    case \"number\":\r\n      if (Number.isInteger(json)) {\r\n        return json;\r\n      }\r\n      break;\r\n    case \"string\":\r\n      const value = type.findName(json);\r\n      if (value !== undefined) {\r\n        return value.no;\r\n      }\r\n      if (ignoreUnknownFields) {\r\n        return tokenIgnoredUnknownEnum;\r\n      }\r\n      break;\r\n  }\r\n  throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\r\n}\r\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\r\nfunction canEmitFieldDefaultValue(field) {\r\n  if (field.repeated || field.kind == \"map\") {\r\n    // maps are {}, repeated fields are []\r\n    return true;\r\n  }\r\n  if (field.oneof) {\r\n    // oneof fields are never emitted\r\n    return false;\r\n  }\r\n  if (field.kind == \"message\") {\r\n    // singular message field are allowed to emit JSON null, but we do not\r\n    return false;\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n  if (field.opt || field.req) {\r\n    // the field uses explicit presence, so we cannot emit a zero value\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nfunction writeField$1(field, value, options) {\r\n  if (field.kind == \"map\") {\r\n    assert(typeof value == \"object\" && value != null);\r\n    const jsonObj = {};\r\n    const entries = Object.entries(value);\r\n    switch (field.V.kind) {\r\n      case \"scalar\":\r\n        for (const [entryKey, entryValue] of entries) {\r\n          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\r\n        }\r\n        break;\r\n      case \"message\":\r\n        for (const [entryKey, entryValue] of entries) {\r\n          // JSON standard allows only (double quoted) string as property key\r\n          jsonObj[entryKey.toString()] = entryValue.toJson(options);\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        const enumType = field.V.T;\r\n        for (const [entryKey, entryValue] of entries) {\r\n          // JSON standard allows only (double quoted) string as property key\r\n          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\r\n        }\r\n        break;\r\n    }\r\n    return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\r\n  }\r\n  if (field.repeated) {\r\n    assert(Array.isArray(value));\r\n    const jsonArr = [];\r\n    switch (field.kind) {\r\n      case \"scalar\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(writeScalar$1(field.T, value[i]));\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\r\n        }\r\n        break;\r\n      case \"message\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(value[i].toJson(options));\r\n        }\r\n        break;\r\n    }\r\n    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\r\n  }\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n      return writeScalar$1(field.T, value);\r\n    case \"enum\":\r\n      return writeEnum(field.T, value, options.enumAsInteger);\r\n    case \"message\":\r\n      return wrapField(field.T, value).toJson(options);\r\n  }\r\n}\r\nfunction writeEnum(type, value, enumAsInteger) {\r\n  var _a;\r\n  assert(typeof value == \"number\");\r\n  if (type.typeName == \"google.protobuf.NullValue\") {\r\n    return null;\r\n  }\r\n  if (enumAsInteger) {\r\n    return value;\r\n  }\r\n  const val = type.findNumber(value);\r\n  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\r\n}\r\nfunction writeScalar$1(type, value) {\r\n  switch (type) {\r\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\r\n    case ScalarType.INT32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.UINT32:\r\n      assert(typeof value == \"number\");\r\n      return value;\r\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\r\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\r\n    case ScalarType.FLOAT:\r\n    // assertFloat32(value);\r\n    case ScalarType.DOUBLE:\r\n      // eslint-disable-line no-fallthrough\r\n      assert(typeof value == \"number\");\r\n      if (Number.isNaN(value)) return \"NaN\";\r\n      if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\r\n      if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\r\n      return value;\r\n    // string:\r\n    case ScalarType.STRING:\r\n      assert(typeof value == \"string\");\r\n      return value;\r\n    // bool:\r\n    case ScalarType.BOOL:\r\n      assert(typeof value == \"boolean\");\r\n      return value;\r\n    // JSON value will be a decimal string. Either numbers or strings are accepted.\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\r\n      return value.toString();\r\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\r\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\r\n    case ScalarType.BYTES:\r\n      assert(value instanceof Uint8Array);\r\n      return protoBase64.enc(value);\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */\r\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\r\n// Default options for parsing binary data.\r\nconst readDefaults = {\r\n  readUnknownFields: true,\r\n  readerFactory: bytes => new BinaryReader(bytes)\r\n};\r\n// Default options for serializing binary data.\r\nconst writeDefaults = {\r\n  writeUnknownFields: true,\r\n  writerFactory: () => new BinaryWriter()\r\n};\r\nfunction makeReadOptions(options) {\r\n  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\r\n}\r\nfunction makeWriteOptions(options) {\r\n  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\r\n}\r\nfunction makeBinaryFormat() {\r\n  return {\r\n    makeReadOptions,\r\n    makeWriteOptions,\r\n    listUnknownFields(message) {\r\n      var _a;\r\n      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\r\n    },\r\n    discardUnknownFields(message) {\r\n      delete message[unknownFieldsSymbol];\r\n    },\r\n    writeUnknownFields(message, writer) {\r\n      const m = message;\r\n      const c = m[unknownFieldsSymbol];\r\n      if (c) {\r\n        for (const f of c) {\r\n          writer.tag(f.no, f.wireType).raw(f.data);\r\n        }\r\n      }\r\n    },\r\n    onUnknownField(message, no, wireType, data) {\r\n      const m = message;\r\n      if (!Array.isArray(m[unknownFieldsSymbol])) {\r\n        m[unknownFieldsSymbol] = [];\r\n      }\r\n      m[unknownFieldsSymbol].push({\r\n        no,\r\n        wireType,\r\n        data\r\n      });\r\n    },\r\n    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\r\n      const type = message.getType();\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\r\n      let fieldNo, wireType;\r\n      while (reader.pos < end) {\r\n        [fieldNo, wireType] = reader.tag();\r\n        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\r\n          break;\r\n        }\r\n        const field = type.fields.find(fieldNo);\r\n        if (!field) {\r\n          const data = reader.skip(wireType, fieldNo);\r\n          if (options.readUnknownFields) {\r\n            this.onUnknownField(message, fieldNo, wireType, data);\r\n          }\r\n          continue;\r\n        }\r\n        readField(message, reader, field, wireType, options);\r\n      }\r\n      if (delimitedMessageEncoding && (\r\n      // eslint-disable-line @typescript-eslint/strict-boolean-expressions\r\n      wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\r\n        throw new Error(\"invalid end group tag\");\r\n      }\r\n    },\r\n    readField,\r\n    writeMessage(message, writer, options) {\r\n      const type = message.getType();\r\n      for (const field of type.fields.byNumber()) {\r\n        if (!isFieldSet(field, message)) {\r\n          if (field.req) {\r\n            throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\r\n          }\r\n          continue;\r\n        }\r\n        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\r\n        writeField(field, value, writer, options);\r\n      }\r\n      if (options.writeUnknownFields) {\r\n        this.writeUnknownFields(message, writer);\r\n      }\r\n      return writer;\r\n    },\r\n    writeField(field, value, writer, options) {\r\n      // The behavior of our internal function has changed, it does no longer\r\n      // accept `undefined` values for singular scalar and map.\r\n      // For backwards-compatibility, we support the old form that is part of\r\n      // the public API through the interface BinaryFormat.\r\n      if (value === undefined) {\r\n        return undefined;\r\n      }\r\n      writeField(field, value, writer, options);\r\n    }\r\n  };\r\n}\r\nfunction readField(target,\r\n// eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\r\nreader, field, wireType, options) {\r\n  let {\r\n    repeated,\r\n    localName\r\n  } = field;\r\n  if (field.oneof) {\r\n    target = target[field.oneof.localName];\r\n    if (target.case != localName) {\r\n      delete target.value;\r\n    }\r\n    target.case = localName;\r\n    localName = \"value\";\r\n  }\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n    case \"enum\":\r\n      const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\r\n      let read = readScalar;\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\r\n      if (field.kind == \"scalar\" && field.L > 0) {\r\n        read = readScalarLTString;\r\n      }\r\n      if (repeated) {\r\n        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\r\n        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\r\n        if (isPacked) {\r\n          let e = reader.uint32() + reader.pos;\r\n          while (reader.pos < e) {\r\n            arr.push(read(reader, scalarType));\r\n          }\r\n        } else {\r\n          arr.push(read(reader, scalarType));\r\n        }\r\n      } else {\r\n        target[localName] = read(reader, scalarType);\r\n      }\r\n      break;\r\n    case \"message\":\r\n      const messageType = field.T;\r\n      if (repeated) {\r\n        // safe to assume presence of array, oneof cannot contain repeated values\r\n        target[localName].push(readMessageField(reader, new messageType(), options, field));\r\n      } else {\r\n        if (isMessage(target[localName])) {\r\n          readMessageField(reader, target[localName], options, field);\r\n        } else {\r\n          target[localName] = readMessageField(reader, new messageType(), options, field);\r\n          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\r\n            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    case \"map\":\r\n      let [mapKey, mapVal] = readMapEntry(field, reader, options);\r\n      // safe to assume presence of map object, oneof cannot contain repeated values\r\n      target[localName][mapKey] = mapVal;\r\n      break;\r\n  }\r\n}\r\n// Read a message, avoiding MessageType.fromBinary() to re-use the\r\n// BinaryReadOptions and the IBinaryReader.\r\nfunction readMessageField(reader, message, options, field) {\r\n  const format = message.getType().runtime.bin;\r\n  const delimited = field === null || field === void 0 ? void 0 : field.delimited;\r\n  format.readMessage(message, reader, delimited ? field.no : reader.uint32(),\r\n  // eslint-disable-line @typescript-eslint/strict-boolean-expressions\r\n  options, delimited);\r\n  return message;\r\n}\r\n// Read a map field, expecting key field = 1, value field = 2\r\nfunction readMapEntry(field, reader, options) {\r\n  const length = reader.uint32(),\r\n    end = reader.pos + length;\r\n  let key, val;\r\n  while (reader.pos < end) {\r\n    const [fieldNo] = reader.tag();\r\n    switch (fieldNo) {\r\n      case 1:\r\n        key = readScalar(reader, field.K);\r\n        break;\r\n      case 2:\r\n        switch (field.V.kind) {\r\n          case \"scalar\":\r\n            val = readScalar(reader, field.V.T);\r\n            break;\r\n          case \"enum\":\r\n            val = reader.int32();\r\n            break;\r\n          case \"message\":\r\n            val = readMessageField(reader, new field.V.T(), options, undefined);\r\n            break;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n  if (key === undefined) {\r\n    key = scalarZeroValue(field.K, LongType.BIGINT);\r\n  }\r\n  if (typeof key != \"string\" && typeof key != \"number\") {\r\n    key = key.toString();\r\n  }\r\n  if (val === undefined) {\r\n    switch (field.V.kind) {\r\n      case \"scalar\":\r\n        val = scalarZeroValue(field.V.T, LongType.BIGINT);\r\n        break;\r\n      case \"enum\":\r\n        val = field.V.T.values[0].no;\r\n        break;\r\n      case \"message\":\r\n        val = new field.V.T();\r\n        break;\r\n    }\r\n  }\r\n  return [key, val];\r\n}\r\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\r\n// sint64, fixed64, sfixed64) as string instead of bigint.\r\nfunction readScalarLTString(reader, type) {\r\n  const v = readScalar(reader, type);\r\n  return typeof v == \"bigint\" ? v.toString() : v;\r\n}\r\n// Does not use scalarTypeInfo() for better performance.\r\nfunction readScalar(reader, type) {\r\n  switch (type) {\r\n    case ScalarType.STRING:\r\n      return reader.string();\r\n    case ScalarType.BOOL:\r\n      return reader.bool();\r\n    case ScalarType.DOUBLE:\r\n      return reader.double();\r\n    case ScalarType.FLOAT:\r\n      return reader.float();\r\n    case ScalarType.INT32:\r\n      return reader.int32();\r\n    case ScalarType.INT64:\r\n      return reader.int64();\r\n    case ScalarType.UINT64:\r\n      return reader.uint64();\r\n    case ScalarType.FIXED64:\r\n      return reader.fixed64();\r\n    case ScalarType.BYTES:\r\n      return reader.bytes();\r\n    case ScalarType.FIXED32:\r\n      return reader.fixed32();\r\n    case ScalarType.SFIXED32:\r\n      return reader.sfixed32();\r\n    case ScalarType.SFIXED64:\r\n      return reader.sfixed64();\r\n    case ScalarType.SINT64:\r\n      return reader.sint64();\r\n    case ScalarType.UINT32:\r\n      return reader.uint32();\r\n    case ScalarType.SINT32:\r\n      return reader.sint32();\r\n  }\r\n}\r\nfunction writeField(field, value, writer, options) {\r\n  assert(value !== undefined);\r\n  const repeated = field.repeated;\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n    case \"enum\":\r\n      let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\r\n      if (repeated) {\r\n        assert(Array.isArray(value));\r\n        if (field.packed) {\r\n          writePacked(writer, scalarType, field.no, value);\r\n        } else {\r\n          for (const item of value) {\r\n            writeScalar(writer, scalarType, field.no, item);\r\n          }\r\n        }\r\n      } else {\r\n        writeScalar(writer, scalarType, field.no, value);\r\n      }\r\n      break;\r\n    case \"message\":\r\n      if (repeated) {\r\n        assert(Array.isArray(value));\r\n        for (const item of value) {\r\n          writeMessageField(writer, options, field, item);\r\n        }\r\n      } else {\r\n        writeMessageField(writer, options, field, value);\r\n      }\r\n      break;\r\n    case \"map\":\r\n      assert(typeof value == \"object\" && value != null);\r\n      for (const [key, val] of Object.entries(value)) {\r\n        writeMapEntry(writer, options, field, key, val);\r\n      }\r\n      break;\r\n  }\r\n}\r\nfunction writeMapEntry(writer, options, field, key, value) {\r\n  writer.tag(field.no, WireType.LengthDelimited);\r\n  writer.fork();\r\n  // javascript only allows number or string for object properties\r\n  // we convert from our representation to the protobuf type\r\n  let keyValue = key;\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\r\n  switch (field.K) {\r\n    case ScalarType.INT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.UINT32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n      keyValue = Number.parseInt(key);\r\n      break;\r\n    case ScalarType.BOOL:\r\n      assert(key == \"true\" || key == \"false\");\r\n      keyValue = key == \"true\";\r\n      break;\r\n  }\r\n  // write key, expecting key field number = 1\r\n  writeScalar(writer, field.K, 1, keyValue);\r\n  // write value, expecting value field number = 2\r\n  switch (field.V.kind) {\r\n    case \"scalar\":\r\n      writeScalar(writer, field.V.T, 2, value);\r\n      break;\r\n    case \"enum\":\r\n      writeScalar(writer, ScalarType.INT32, 2, value);\r\n      break;\r\n    case \"message\":\r\n      assert(value !== undefined);\r\n      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\r\n      break;\r\n  }\r\n  writer.join();\r\n}\r\n// Value must not be undefined\r\nfunction writeMessageField(writer, options, field, value) {\r\n  const message = wrapField(field.T, value);\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n  if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\r\n}\r\nfunction writeScalar(writer, type, fieldNo, value) {\r\n  assert(value !== undefined);\r\n  let [wireType, method] = scalarTypeInfo(type);\r\n  writer.tag(fieldNo, wireType)[method](value);\r\n}\r\nfunction writePacked(writer, type, fieldNo, value) {\r\n  if (!value.length) {\r\n    return;\r\n  }\r\n  writer.tag(fieldNo, WireType.LengthDelimited).fork();\r\n  let [, method] = scalarTypeInfo(type);\r\n  for (let i = 0; i < value.length; i++) {\r\n    writer[method](value[i]);\r\n  }\r\n  writer.join();\r\n}\r\n/**\r\n * Get information for writing a scalar value.\r\n *\r\n * Returns tuple:\r\n * [0]: appropriate WireType\r\n * [1]: name of the appropriate method of IBinaryWriter\r\n * [2]: whether the given value is a default value for proto3 semantics\r\n *\r\n * If argument `value` is omitted, [2] is always false.\r\n */\r\n// TODO replace call-sites writeScalar() and writePacked(), then remove\r\nfunction scalarTypeInfo(type) {\r\n  let wireType = WireType.Varint;\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\r\n  switch (type) {\r\n    case ScalarType.BYTES:\r\n    case ScalarType.STRING:\r\n      wireType = WireType.LengthDelimited;\r\n      break;\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.SFIXED64:\r\n      wireType = WireType.Bit64;\r\n      break;\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.FLOAT:\r\n      wireType = WireType.Bit32;\r\n      break;\r\n  }\r\n  const method = ScalarType[type].toLowerCase();\r\n  return [wireType, method];\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\r\nfunction makeUtilCommon() {\r\n  return {\r\n    setEnumType,\r\n    initPartial(source, target) {\r\n      if (source === undefined) {\r\n        return;\r\n      }\r\n      const type = target.getType();\r\n      for (const member of type.fields.byMember()) {\r\n        const localName = member.localName,\r\n          t = target,\r\n          s = source;\r\n        if (s[localName] == null) {\r\n          // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence\r\n          continue;\r\n        }\r\n        switch (member.kind) {\r\n          case \"oneof\":\r\n            const sk = s[localName].case;\r\n            if (sk === undefined) {\r\n              continue;\r\n            }\r\n            const sourceField = member.findField(sk);\r\n            let val = s[localName].value;\r\n            if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\r\n              val = new sourceField.T(val);\r\n            } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\r\n              val = toU8Arr(val);\r\n            }\r\n            t[localName] = {\r\n              case: sk,\r\n              value: val\r\n            };\r\n            break;\r\n          case \"scalar\":\r\n          case \"enum\":\r\n            let copy = s[localName];\r\n            if (member.T === ScalarType.BYTES) {\r\n              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\r\n            }\r\n            t[localName] = copy;\r\n            break;\r\n          case \"map\":\r\n            switch (member.V.kind) {\r\n              case \"scalar\":\r\n              case \"enum\":\r\n                if (member.V.T === ScalarType.BYTES) {\r\n                  for (const [k, v] of Object.entries(s[localName])) {\r\n                    t[localName][k] = toU8Arr(v);\r\n                  }\r\n                } else {\r\n                  Object.assign(t[localName], s[localName]);\r\n                }\r\n                break;\r\n              case \"message\":\r\n                const messageType = member.V.T;\r\n                for (const k of Object.keys(s[localName])) {\r\n                  let val = s[localName][k];\r\n                  if (!messageType.fieldWrapper) {\r\n                    // We only take partial input for messages that are not a wrapper type.\r\n                    // For those messages, we recursively normalize the partial input.\r\n                    val = new messageType(val);\r\n                  }\r\n                  t[localName][k] = val;\r\n                }\r\n                break;\r\n            }\r\n            break;\r\n          case \"message\":\r\n            const mt = member.T;\r\n            if (member.repeated) {\r\n              t[localName] = s[localName].map(val => isMessage(val, mt) ? val : new mt(val));\r\n            } else {\r\n              const val = s[localName];\r\n              if (mt.fieldWrapper) {\r\n                if (\r\n                // We can't use BytesValue.typeName as that will create a circular import\r\n                mt.typeName === \"google.protobuf.BytesValue\") {\r\n                  t[localName] = toU8Arr(val);\r\n                } else {\r\n                  t[localName] = val;\r\n                }\r\n              } else {\r\n                t[localName] = isMessage(val, mt) ? val : new mt(val);\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    },\r\n    // TODO use isFieldSet() here to support future field presence\r\n    equals(type, a, b) {\r\n      if (a === b) {\r\n        return true;\r\n      }\r\n      if (!a || !b) {\r\n        return false;\r\n      }\r\n      return type.fields.byMember().every(m => {\r\n        const va = a[m.localName];\r\n        const vb = b[m.localName];\r\n        if (m.repeated) {\r\n          if (va.length !== vb.length) {\r\n            return false;\r\n          }\r\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\r\n          switch (m.kind) {\r\n            case \"message\":\r\n              return va.every((a, i) => m.T.equals(a, vb[i]));\r\n            case \"scalar\":\r\n              return va.every((a, i) => scalarEquals(m.T, a, vb[i]));\r\n            case \"enum\":\r\n              return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));\r\n          }\r\n          throw new Error(\"repeated cannot contain \".concat(m.kind));\r\n        }\r\n        switch (m.kind) {\r\n          case \"message\":\r\n            let a = va;\r\n            let b = vb;\r\n            if (m.T.fieldWrapper) {\r\n              if (a !== undefined && !isMessage(a)) {\r\n                a = m.T.fieldWrapper.wrapField(a);\r\n              }\r\n              if (b !== undefined && !isMessage(b)) {\r\n                b = m.T.fieldWrapper.wrapField(b);\r\n              }\r\n            }\r\n            return m.T.equals(a, b);\r\n          case \"enum\":\r\n            return scalarEquals(ScalarType.INT32, va, vb);\r\n          case \"scalar\":\r\n            return scalarEquals(m.T, va, vb);\r\n          case \"oneof\":\r\n            if (va.case !== vb.case) {\r\n              return false;\r\n            }\r\n            const s = m.findField(va.case);\r\n            if (s === undefined) {\r\n              return true;\r\n            }\r\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\r\n            switch (s.kind) {\r\n              case \"message\":\r\n                return s.T.equals(va.value, vb.value);\r\n              case \"enum\":\r\n                return scalarEquals(ScalarType.INT32, va.value, vb.value);\r\n              case \"scalar\":\r\n                return scalarEquals(s.T, va.value, vb.value);\r\n            }\r\n            throw new Error(\"oneof cannot contain \".concat(s.kind));\r\n          case \"map\":\r\n            const keys = Object.keys(va).concat(Object.keys(vb));\r\n            switch (m.V.kind) {\r\n              case \"message\":\r\n                const messageType = m.V.T;\r\n                return keys.every(k => messageType.equals(va[k], vb[k]));\r\n              case \"enum\":\r\n                return keys.every(k => scalarEquals(ScalarType.INT32, va[k], vb[k]));\r\n              case \"scalar\":\r\n                const scalarType = m.V.T;\r\n                return keys.every(k => scalarEquals(scalarType, va[k], vb[k]));\r\n            }\r\n            break;\r\n        }\r\n      });\r\n    },\r\n    // TODO use isFieldSet() here to support future field presence\r\n    clone(message) {\r\n      const type = message.getType(),\r\n        target = new type(),\r\n        any = target;\r\n      for (const member of type.fields.byMember()) {\r\n        const source = message[member.localName];\r\n        let copy;\r\n        if (member.repeated) {\r\n          copy = source.map(cloneSingularField);\r\n        } else if (member.kind == \"map\") {\r\n          copy = any[member.localName];\r\n          for (const [key, v] of Object.entries(source)) {\r\n            copy[key] = cloneSingularField(v);\r\n          }\r\n        } else if (member.kind == \"oneof\") {\r\n          const f = member.findField(source.case);\r\n          copy = f ? {\r\n            case: source.case,\r\n            value: cloneSingularField(source.value)\r\n          } : {\r\n            case: undefined\r\n          };\r\n        } else {\r\n          copy = cloneSingularField(source);\r\n        }\r\n        any[member.localName] = copy;\r\n      }\r\n      for (const uf of type.runtime.bin.listUnknownFields(message)) {\r\n        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\r\n      }\r\n      return target;\r\n    }\r\n  };\r\n}\r\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\r\nfunction cloneSingularField(value) {\r\n  if (value === undefined) {\r\n    return value;\r\n  }\r\n  if (isMessage(value)) {\r\n    return value.clone();\r\n  }\r\n  if (value instanceof Uint8Array) {\r\n    const c = new Uint8Array(value.byteLength);\r\n    c.set(value);\r\n    return c;\r\n  }\r\n  return value;\r\n}\r\n// converts any ArrayLike<number> to Uint8Array if necessary.\r\nfunction toU8Arr(input) {\r\n  return input instanceof Uint8Array ? input : new Uint8Array(input);\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\r\n  return {\r\n    syntax,\r\n    json: makeJsonFormat(),\r\n    bin: makeBinaryFormat(),\r\n    util: Object.assign(Object.assign({}, makeUtilCommon()), {\r\n      newFieldList,\r\n      initFields\r\n    }),\r\n    makeMessageType(typeName, fields, opt) {\r\n      return makeMessageType(this, typeName, fields, opt);\r\n    },\r\n    makeEnum,\r\n    makeEnumType,\r\n    getEnumType,\r\n    makeExtension(typeName, extendee, field) {\r\n      return makeExtension(this, typeName, extendee, field);\r\n    }\r\n  };\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nclass InternalFieldList {\r\n  constructor(fields, normalizer) {\r\n    this._fields = fields;\r\n    this._normalizer = normalizer;\r\n  }\r\n  findJsonName(jsonName) {\r\n    if (!this.jsonNames) {\r\n      const t = {};\r\n      for (const f of this.list()) {\r\n        t[f.jsonName] = t[f.name] = f;\r\n      }\r\n      this.jsonNames = t;\r\n    }\r\n    return this.jsonNames[jsonName];\r\n  }\r\n  find(fieldNo) {\r\n    if (!this.numbers) {\r\n      const t = {};\r\n      for (const f of this.list()) {\r\n        t[f.no] = f;\r\n      }\r\n      this.numbers = t;\r\n    }\r\n    return this.numbers[fieldNo];\r\n  }\r\n  list() {\r\n    if (!this.all) {\r\n      this.all = this._normalizer(this._fields);\r\n    }\r\n    return this.all;\r\n  }\r\n  byNumber() {\r\n    if (!this.numbersAsc) {\r\n      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);\r\n    }\r\n    return this.numbersAsc;\r\n  }\r\n  byMember() {\r\n    if (!this.members) {\r\n      this.members = [];\r\n      const a = this.members;\r\n      let o;\r\n      for (const f of this.list()) {\r\n        if (f.oneof) {\r\n          if (f.oneof !== o) {\r\n            o = f.oneof;\r\n            a.push(o);\r\n          }\r\n        } else {\r\n          a.push(f);\r\n        }\r\n      }\r\n    }\r\n    return this.members;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns the name of a protobuf element in generated code.\r\n *\r\n * Field names - including oneofs - are converted to lowerCamelCase. For\r\n * messages, enumerations and services, the package name is stripped from\r\n * the type name. For nested messages and enumerations, the names are joined\r\n * with an underscore. For methods, the first character is made lowercase.\r\n */\r\n/**\r\n * Returns the name of a field in generated code.\r\n */\r\nfunction localFieldName(protoName, inOneof) {\r\n  const name = protoCamelCase(protoName);\r\n  if (inOneof) {\r\n    // oneof member names are not properties, but values of the `case` property.\r\n    return name;\r\n  }\r\n  return safeObjectProperty(safeMessageProperty(name));\r\n}\r\n/**\r\n * Returns the name of a oneof group in generated code.\r\n */\r\nfunction localOneofName(protoName) {\r\n  return localFieldName(protoName, false);\r\n}\r\n/**\r\n * Returns the JSON name for a protobuf field, exactly like protoc does.\r\n */\r\nconst fieldJsonName = protoCamelCase;\r\n/**\r\n * Converts snake_case to protoCamelCase according to the convention\r\n * used by protoc to convert a field name to a JSON name.\r\n */\r\nfunction protoCamelCase(snakeCase) {\r\n  let capNext = false;\r\n  const b = [];\r\n  for (let i = 0; i < snakeCase.length; i++) {\r\n    let c = snakeCase.charAt(i);\r\n    switch (c) {\r\n      case \"_\":\r\n        capNext = true;\r\n        break;\r\n      case \"0\":\r\n      case \"1\":\r\n      case \"2\":\r\n      case \"3\":\r\n      case \"4\":\r\n      case \"5\":\r\n      case \"6\":\r\n      case \"7\":\r\n      case \"8\":\r\n      case \"9\":\r\n        b.push(c);\r\n        capNext = false;\r\n        break;\r\n      default:\r\n        if (capNext) {\r\n          capNext = false;\r\n          c = c.toUpperCase();\r\n        }\r\n        b.push(c);\r\n        break;\r\n    }\r\n  }\r\n  return b.join(\"\");\r\n}\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by built-in JavaScript properties.\r\n */\r\nconst reservedObjectProperties = new Set([\r\n// names reserved by JavaScript\r\n\"constructor\", \"toString\", \"toJSON\", \"valueOf\"]);\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by the runtime.\r\n */\r\nconst reservedMessageProperties = new Set([\r\n// names reserved by the runtime\r\n\"getType\", \"clone\", \"equals\", \"fromBinary\", \"fromJson\", \"fromJsonString\", \"toBinary\", \"toJson\", \"toJsonString\",\r\n// names reserved by the runtime for the future\r\n\"toObject\"]);\r\nconst fallback = name => \"\".concat(name, \"$\");\r\n/**\r\n * Will wrap names that are Object prototype properties or names reserved\r\n * for `Message`s.\r\n */\r\nconst safeMessageProperty = name => {\r\n  if (reservedMessageProperties.has(name)) {\r\n    return fallback(name);\r\n  }\r\n  return name;\r\n};\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by built-in JavaScript properties.\r\n */\r\nconst safeObjectProperty = name => {\r\n  if (reservedObjectProperties.has(name)) {\r\n    return fallback(name);\r\n  }\r\n  return name;\r\n};\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nclass InternalOneofInfo {\r\n  constructor(name) {\r\n    this.kind = \"oneof\";\r\n    this.repeated = false;\r\n    this.packed = false;\r\n    this.opt = false;\r\n    this.req = false;\r\n    this.default = undefined;\r\n    this.fields = [];\r\n    this.name = name;\r\n    this.localName = localOneofName(name);\r\n  }\r\n  addField(field) {\r\n    assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\r\n    this.fields.push(field);\r\n  }\r\n  findField(localName) {\r\n    if (!this._lookup) {\r\n      this._lookup = Object.create(null);\r\n      for (let i = 0; i < this.fields.length; i++) {\r\n        this._lookup[this.fields[i].localName] = this.fields[i];\r\n      }\r\n    }\r\n    return this._lookup[localName];\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Convert a collection of field info to an array of normalized FieldInfo.\r\n *\r\n * The argument `packedByDefault` specifies whether fields that do not specify\r\n * `packed` should be packed (proto3) or unpacked (proto2).\r\n */\r\nfunction normalizeFieldInfos(fieldInfos, packedByDefault) {\r\n  var _a, _b, _c, _d, _e, _f;\r\n  const r = [];\r\n  let o;\r\n  for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos) {\r\n    const f = field;\r\n    f.localName = localFieldName(field.name, field.oneof !== undefined);\r\n    f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\r\n    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\r\n    if (field.kind == \"scalar\") {\r\n      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\r\n    }\r\n    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\r\n    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\r\n    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\r\n    if (field.packed === undefined) {\r\n      {\r\n        f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\r\n      }\r\n    }\r\n    // We do not surface options at this time\r\n    // f.options = field.options ?? emptyReadonlyObject;\r\n    if (field.oneof !== undefined) {\r\n      const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\r\n      if (!o || o.name != ooname) {\r\n        o = new InternalOneofInfo(ooname);\r\n      }\r\n      f.oneof = o;\r\n      o.addField(f);\r\n    }\r\n    r.push(f);\r\n  }\r\n  return r;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Provides functionality for messages defined with the proto3 syntax.\r\n */\r\nconst proto3 = makeProtoRuntime(\"proto3\", fields => {\r\n  return new InternalFieldList(fields, source => normalizeFieldInfos(source));\r\n},\r\n// TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\r\ntarget => {\r\n  for (const member of target.getType().fields.byMember()) {\r\n    if (member.opt) {\r\n      continue;\r\n    }\r\n    const name = member.localName,\r\n      t = target;\r\n    if (member.repeated) {\r\n      t[name] = [];\r\n      continue;\r\n    }\r\n    switch (member.kind) {\r\n      case \"oneof\":\r\n        t[name] = {\r\n          case: undefined\r\n        };\r\n        break;\r\n      case \"enum\":\r\n        t[name] = 0;\r\n        break;\r\n      case \"map\":\r\n        t[name] = {};\r\n        break;\r\n      case \"scalar\":\r\n        t[name] = scalarZeroValue(member.T, member.L);\r\n        break;\r\n    }\r\n  }\r\n});\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * A Timestamp represents a point in time independent of any time zone or local\r\n * calendar, encoded as a count of seconds and fractions of seconds at\r\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\r\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\r\n * Gregorian calendar backwards to year one.\r\n *\r\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\r\n * second table is needed for interpretation, using a [24-hour linear\r\n * smear](https://developers.google.com/time/smear).\r\n *\r\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\r\n * restricting to that range, we ensure that we can convert to and from [RFC\r\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\r\n *\r\n * # Examples\r\n *\r\n * Example 1: Compute Timestamp from POSIX `time()`.\r\n *\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds(time(NULL));\r\n *     timestamp.set_nanos(0);\r\n *\r\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\r\n *\r\n *     struct timeval tv;\r\n *     gettimeofday(&tv, NULL);\r\n *\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds(tv.tv_sec);\r\n *     timestamp.set_nanos(tv.tv_usec * 1000);\r\n *\r\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\r\n *\r\n *     FILETIME ft;\r\n *     GetSystemTimeAsFileTime(&ft);\r\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\r\n *\r\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\r\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\r\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\r\n *\r\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\r\n *\r\n *     long millis = System.currentTimeMillis();\r\n *\r\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\r\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\r\n *\r\n * Example 5: Compute Timestamp from Java `Instant.now()`.\r\n *\r\n *     Instant now = Instant.now();\r\n *\r\n *     Timestamp timestamp =\r\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\r\n *             .setNanos(now.getNano()).build();\r\n *\r\n * Example 6: Compute Timestamp from current time in Python.\r\n *\r\n *     timestamp = Timestamp()\r\n *     timestamp.GetCurrentTime()\r\n *\r\n * # JSON Mapping\r\n *\r\n * In JSON format, the Timestamp type is encoded as a string in the\r\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\r\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\r\n * where {year} is always expressed using four digits while {month}, {day},\r\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\r\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\r\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\r\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\r\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\r\n * able to accept both UTC and other timezones (as indicated by an offset).\r\n *\r\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\r\n * 01:30 UTC on January 15, 2017.\r\n *\r\n * In JavaScript, one can convert a Date object to this format using the\r\n * standard\r\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\r\n * method. In Python, a standard `datetime.datetime` object can be converted\r\n * to this format using\r\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\r\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\r\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\r\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\r\n * ) to obtain a formatter capable of generating timestamps in this format.\r\n *\r\n *\r\n * @generated from message google.protobuf.Timestamp\r\n */\r\nclass Timestamp extends Message {\r\n  constructor(data) {\r\n    super();\r\n    /**\r\n     * Represents seconds of UTC time since Unix epoch\r\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     * 9999-12-31T23:59:59Z inclusive.\r\n     *\r\n     * @generated from field: int64 seconds = 1;\r\n     */\r\n    this.seconds = protoInt64.zero;\r\n    /**\r\n     * Non-negative fractions of a second at nanosecond resolution. Negative\r\n     * second values with fractions must still have non-negative nanos values\r\n     * that count forward in time. Must be from 0 to 999,999,999\r\n     * inclusive.\r\n     *\r\n     * @generated from field: int32 nanos = 2;\r\n     */\r\n    this.nanos = 0;\r\n    proto3.util.initPartial(data, this);\r\n  }\r\n  fromJson(json, options) {\r\n    if (typeof json !== \"string\") {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\r\n    }\r\n    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\r\n    if (!matches) {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\r\n    }\r\n    const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\r\n    if (Number.isNaN(ms)) {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\r\n    }\r\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\r\n      throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\r\n    }\r\n    this.seconds = protoInt64.parse(ms / 1000);\r\n    this.nanos = 0;\r\n    if (matches[7]) {\r\n      this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\r\n    }\r\n    return this;\r\n  }\r\n  toJson(options) {\r\n    const ms = Number(this.seconds) * 1000;\r\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\r\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\r\n    }\r\n    if (this.nanos < 0) {\r\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\r\n    }\r\n    let z = \"Z\";\r\n    if (this.nanos > 0) {\r\n      const nanosStr = (this.nanos + 1000000000).toString().substring(1);\r\n      if (nanosStr.substring(3) === \"000000\") {\r\n        z = \".\" + nanosStr.substring(0, 3) + \"Z\";\r\n      } else if (nanosStr.substring(6) === \"000\") {\r\n        z = \".\" + nanosStr.substring(0, 6) + \"Z\";\r\n      } else {\r\n        z = \".\" + nanosStr + \"Z\";\r\n      }\r\n    }\r\n    return new Date(ms).toISOString().replace(\".000Z\", z);\r\n  }\r\n  toDate() {\r\n    return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\r\n  }\r\n  static now() {\r\n    return Timestamp.fromDate(new Date());\r\n  }\r\n  static fromDate(date) {\r\n    const ms = date.getTime();\r\n    return new Timestamp({\r\n      seconds: protoInt64.parse(Math.floor(ms / 1000)),\r\n      nanos: ms % 1000 * 1000000\r\n    });\r\n  }\r\n  static fromBinary(bytes, options) {\r\n    return new Timestamp().fromBinary(bytes, options);\r\n  }\r\n  static fromJson(jsonValue, options) {\r\n    return new Timestamp().fromJson(jsonValue, options);\r\n  }\r\n  static fromJsonString(jsonString, options) {\r\n    return new Timestamp().fromJsonString(jsonString, options);\r\n  }\r\n  static equals(a, b) {\r\n    return proto3.util.equals(Timestamp, a, b);\r\n  }\r\n}\r\nTimestamp.runtime = proto3;\r\nTimestamp.typeName = \"google.protobuf.Timestamp\";\r\nTimestamp.fields = proto3.util.newFieldList(() => [{\r\n  no: 1,\r\n  name: \"seconds\",\r\n  kind: \"scalar\",\r\n  T: 3 /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"nanos\",\r\n  kind: \"scalar\",\r\n  T: 5 /* ScalarType.INT32 */\r\n}]);\r\n\r\nconst MetricsBatch = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricsBatch\", () => [{\r\n  no: 1,\r\n  name: \"timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"normalized_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 3,\r\n  name: \"str_data\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"time_series\",\r\n  kind: \"message\",\r\n  T: TimeSeriesMetric,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"events\",\r\n  kind: \"message\",\r\n  T: EventMetric,\r\n  repeated: true\r\n}]);\r\nconst TimeSeriesMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimeSeriesMetric\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"samples\",\r\n  kind: \"message\",\r\n  T: MetricSample,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"rid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst MetricSample = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricSample\", () => [{\r\n  no: 1,\r\n  name: \"timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"normalized_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 3,\r\n  name: \"value\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}]);\r\nconst EventMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.EventMetric\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"start_timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 5,\r\n  name: \"end_timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  opt: true\r\n}, {\r\n  no: 6,\r\n  name: \"normalized_start_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 7,\r\n  name: \"normalized_end_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp,\r\n  opt: true\r\n}, {\r\n  no: 8,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"rid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst BackupCodecPolicy$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.BackupCodecPolicy\", [{\r\n  no: 0,\r\n  name: \"PREFER_REGRESSION\"\r\n}, {\r\n  no: 1,\r\n  name: \"SIMULCAST\"\r\n}, {\r\n  no: 2,\r\n  name: \"REGRESSION\"\r\n}]);\r\nconst TrackType = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackType\", [{\r\n  no: 0,\r\n  name: \"AUDIO\"\r\n}, {\r\n  no: 1,\r\n  name: \"VIDEO\"\r\n}, {\r\n  no: 2,\r\n  name: \"DATA\"\r\n}]);\r\nconst TrackSource = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackSource\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"CAMERA\"\r\n}, {\r\n  no: 2,\r\n  name: \"MICROPHONE\"\r\n}, {\r\n  no: 3,\r\n  name: \"SCREEN_SHARE\"\r\n}, {\r\n  no: 4,\r\n  name: \"SCREEN_SHARE_AUDIO\"\r\n}]);\r\nconst VideoQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoQuality\", [{\r\n  no: 0,\r\n  name: \"LOW\"\r\n}, {\r\n  no: 1,\r\n  name: \"MEDIUM\"\r\n}, {\r\n  no: 2,\r\n  name: \"HIGH\"\r\n}, {\r\n  no: 3,\r\n  name: \"OFF\"\r\n}]);\r\nconst ConnectionQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.ConnectionQuality\", [{\r\n  no: 0,\r\n  name: \"POOR\"\r\n}, {\r\n  no: 1,\r\n  name: \"GOOD\"\r\n}, {\r\n  no: 2,\r\n  name: \"EXCELLENT\"\r\n}, {\r\n  no: 3,\r\n  name: \"LOST\"\r\n}]);\r\nconst ClientConfigSetting = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientConfigSetting\", [{\r\n  no: 0,\r\n  name: \"UNSET\"\r\n}, {\r\n  no: 1,\r\n  name: \"DISABLED\"\r\n}, {\r\n  no: 2,\r\n  name: \"ENABLED\"\r\n}]);\r\nconst DisconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.DisconnectReason\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN_REASON\"\r\n}, {\r\n  no: 1,\r\n  name: \"CLIENT_INITIATED\"\r\n}, {\r\n  no: 2,\r\n  name: \"DUPLICATE_IDENTITY\"\r\n}, {\r\n  no: 3,\r\n  name: \"SERVER_SHUTDOWN\"\r\n}, {\r\n  no: 4,\r\n  name: \"PARTICIPANT_REMOVED\"\r\n}, {\r\n  no: 5,\r\n  name: \"ROOM_DELETED\"\r\n}, {\r\n  no: 6,\r\n  name: \"STATE_MISMATCH\"\r\n}, {\r\n  no: 7,\r\n  name: \"JOIN_FAILURE\"\r\n}, {\r\n  no: 8,\r\n  name: \"MIGRATION\"\r\n}, {\r\n  no: 9,\r\n  name: \"SIGNAL_CLOSE\"\r\n}, {\r\n  no: 10,\r\n  name: \"ROOM_CLOSED\"\r\n}, {\r\n  no: 11,\r\n  name: \"USER_UNAVAILABLE\"\r\n}, {\r\n  no: 12,\r\n  name: \"USER_REJECTED\"\r\n}, {\r\n  no: 13,\r\n  name: \"SIP_TRUNK_FAILURE\"\r\n}, {\r\n  no: 14,\r\n  name: \"CONNECTION_TIMEOUT\"\r\n}, {\r\n  no: 15,\r\n  name: \"MEDIA_FAILURE\"\r\n}]);\r\nconst ReconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.ReconnectReason\", [{\r\n  no: 0,\r\n  name: \"RR_UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"RR_SIGNAL_DISCONNECTED\"\r\n}, {\r\n  no: 2,\r\n  name: \"RR_PUBLISHER_FAILED\"\r\n}, {\r\n  no: 3,\r\n  name: \"RR_SUBSCRIBER_FAILED\"\r\n}, {\r\n  no: 4,\r\n  name: \"RR_SWITCH_CANDIDATE\"\r\n}]);\r\nconst SubscriptionError = /* @__PURE__ */proto3.makeEnum(\"livekit.SubscriptionError\", [{\r\n  no: 0,\r\n  name: \"SE_UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"SE_CODEC_UNSUPPORTED\"\r\n}, {\r\n  no: 2,\r\n  name: \"SE_TRACK_NOTFOUND\"\r\n}]);\r\nconst AudioTrackFeature = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioTrackFeature\", [{\r\n  no: 0,\r\n  name: \"TF_STEREO\"\r\n}, {\r\n  no: 1,\r\n  name: \"TF_NO_DTX\"\r\n}, {\r\n  no: 2,\r\n  name: \"TF_AUTO_GAIN_CONTROL\"\r\n}, {\r\n  no: 3,\r\n  name: \"TF_ECHO_CANCELLATION\"\r\n}, {\r\n  no: 4,\r\n  name: \"TF_NOISE_SUPPRESSION\"\r\n}, {\r\n  no: 5,\r\n  name: \"TF_ENHANCED_NOISE_CANCELLATION\"\r\n}, {\r\n  no: 6,\r\n  name: \"TF_PRECONNECT_BUFFER\"\r\n}]);\r\nconst Room$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.Room\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"empty_timeout\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 14,\r\n  name: \"departure_timeout\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"max_participants\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"creation_time\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 15,\r\n  name: \"creation_time_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 6,\r\n  name: \"turn_password\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"enabled_codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 8,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"num_participants\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"num_publishers\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 10,\r\n  name: \"active_recording\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 13,\r\n  name: \"version\",\r\n  kind: \"message\",\r\n  T: TimedVersion\r\n}]);\r\nconst Codec = /* @__PURE__ */proto3.makeMessageType(\"livekit.Codec\", () => [{\r\n  no: 1,\r\n  name: \"mime\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"fmtp_line\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantPermission\", () => [{\r\n  no: 1,\r\n  name: \"can_subscribe\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"can_publish\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"can_publish_data\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 9,\r\n  name: \"can_publish_sources\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource),\r\n  repeated: true\r\n}, {\r\n  no: 7,\r\n  name: \"hidden\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"recorder\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 10,\r\n  name: \"can_update_metadata\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 11,\r\n  name: \"agent\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 12,\r\n  name: \"can_subscribe_metrics\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst ParticipantInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"state\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_State)\r\n}, {\r\n  no: 4,\r\n  name: \"tracks\",\r\n  kind: \"message\",\r\n  T: TrackInfo,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"joined_at\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 17,\r\n  name: \"joined_at_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 9,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"permission\",\r\n  kind: \"message\",\r\n  T: ParticipantPermission\r\n}, {\r\n  no: 12,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 13,\r\n  name: \"is_publisher\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 14,\r\n  name: \"kind\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_Kind)\r\n}, {\r\n  no: 15,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 16,\r\n  name: \"disconnect_reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DisconnectReason)\r\n}, {\r\n  no: 18,\r\n  name: \"kind_details\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_KindDetail),\r\n  repeated: true\r\n}]);\r\nconst ParticipantInfo_State = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.State\", [{\r\n  no: 0,\r\n  name: \"JOINING\"\r\n}, {\r\n  no: 1,\r\n  name: \"JOINED\"\r\n}, {\r\n  no: 2,\r\n  name: \"ACTIVE\"\r\n}, {\r\n  no: 3,\r\n  name: \"DISCONNECTED\"\r\n}]);\r\nconst ParticipantInfo_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [{\r\n  no: 0,\r\n  name: \"STANDARD\"\r\n}, {\r\n  no: 1,\r\n  name: \"INGRESS\"\r\n}, {\r\n  no: 2,\r\n  name: \"EGRESS\"\r\n}, {\r\n  no: 3,\r\n  name: \"SIP\"\r\n}, {\r\n  no: 4,\r\n  name: \"AGENT\"\r\n}]);\r\nconst ParticipantInfo_KindDetail = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [{\r\n  no: 0,\r\n  name: \"CLOUD_AGENT\"\r\n}, {\r\n  no: 1,\r\n  name: \"FORWARDED\"\r\n}]);\r\nconst Encryption_Type = /* @__PURE__ */proto3.makeEnum(\"livekit.Encryption.Type\", [{\r\n  no: 0,\r\n  name: \"NONE\"\r\n}, {\r\n  no: 1,\r\n  name: \"GCM\"\r\n}, {\r\n  no: 2,\r\n  name: \"CUSTOM\"\r\n}]);\r\nconst SimulcastCodecInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", () => [{\r\n  no: 1,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"mid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}]);\r\nconst TrackInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackType)\r\n}, {\r\n  no: 3,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 5,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 7,\r\n  name: \"simulcast\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"disable_dtx\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 9,\r\n  name: \"source\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource)\r\n}, {\r\n  no: 10,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}, {\r\n  no: 11,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 12,\r\n  name: \"mid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 13,\r\n  name: \"codecs\",\r\n  kind: \"message\",\r\n  T: SimulcastCodecInfo,\r\n  repeated: true\r\n}, {\r\n  no: 14,\r\n  name: \"stereo\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 15,\r\n  name: \"disable_red\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 16,\r\n  name: \"encryption\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 17,\r\n  name: \"stream\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 18,\r\n  name: \"version\",\r\n  kind: \"message\",\r\n  T: TimedVersion\r\n}, {\r\n  no: 19,\r\n  name: \"audio_features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}, {\r\n  no: 20,\r\n  name: \"backup_codec_policy\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(BackupCodecPolicy$1)\r\n}]);\r\nconst VideoLayer = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoLayer\", () => [{\r\n  no: 1,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 2,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"bitrate\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"ssrc\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst DataPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataPacket\", () => [{\r\n  no: 1,\r\n  name: \"kind\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DataPacket_Kind)\r\n}, {\r\n  no: 4,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"destination_identities\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"user\",\r\n  kind: \"message\",\r\n  T: UserPacket,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 3,\r\n  name: \"speaker\",\r\n  kind: \"message\",\r\n  T: ActiveSpeakerUpdate,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 6,\r\n  name: \"sip_dtmf\",\r\n  kind: \"message\",\r\n  T: SipDTMF,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 7,\r\n  name: \"transcription\",\r\n  kind: \"message\",\r\n  T: Transcription,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 8,\r\n  name: \"metrics\",\r\n  kind: \"message\",\r\n  T: MetricsBatch,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 9,\r\n  name: \"chat_message\",\r\n  kind: \"message\",\r\n  T: ChatMessage,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 10,\r\n  name: \"rpc_request\",\r\n  kind: \"message\",\r\n  T: RpcRequest,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 11,\r\n  name: \"rpc_ack\",\r\n  kind: \"message\",\r\n  T: RpcAck,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 12,\r\n  name: \"rpc_response\",\r\n  kind: \"message\",\r\n  T: RpcResponse,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 13,\r\n  name: \"stream_header\",\r\n  kind: \"message\",\r\n  T: DataStream_Header,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 14,\r\n  name: \"stream_chunk\",\r\n  kind: \"message\",\r\n  T: DataStream_Chunk,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 15,\r\n  name: \"stream_trailer\",\r\n  kind: \"message\",\r\n  T: DataStream_Trailer,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 16,\r\n  name: \"sequence\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 17,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst DataPacket_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.DataPacket.Kind\", [{\r\n  no: 0,\r\n  name: \"RELIABLE\"\r\n}, {\r\n  no: 1,\r\n  name: \"LOSSY\"\r\n}]);\r\nconst ActiveSpeakerUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", () => [{\r\n  no: 1,\r\n  name: \"speakers\",\r\n  kind: \"message\",\r\n  T: SpeakerInfo,\r\n  repeated: true\r\n}]);\r\nconst SpeakerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakerInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"level\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}, {\r\n  no: 3,\r\n  name: \"active\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst UserPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.UserPacket\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 3,\r\n  name: \"destination_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 6,\r\n  name: \"destination_identities\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"topic\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  opt: true\r\n}, {\r\n  no: 8,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  opt: true\r\n}, {\r\n  no: 9,\r\n  name: \"start_time\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 10,\r\n  name: \"end_time\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 11,\r\n  name: \"nonce\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}]);\r\nconst SipDTMF = /* @__PURE__ */proto3.makeMessageType(\"livekit.SipDTMF\", () => [{\r\n  no: 3,\r\n  name: \"code\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"digit\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst Transcription = /* @__PURE__ */proto3.makeMessageType(\"livekit.Transcription\", () => [{\r\n  no: 2,\r\n  name: \"transcribed_participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"track_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"segments\",\r\n  kind: \"message\",\r\n  T: TranscriptionSegment,\r\n  repeated: true\r\n}]);\r\nconst TranscriptionSegment = /* @__PURE__ */proto3.makeMessageType(\"livekit.TranscriptionSegment\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"text\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"start_time\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 4,\r\n  name: \"end_time\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 5,\r\n  name: \"final\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 6,\r\n  name: \"language\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ChatMessage = /* @__PURE__ */proto3.makeMessageType(\"livekit.ChatMessage\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"edit_timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  opt: true\r\n}, {\r\n  no: 4,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"deleted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 6,\r\n  name: \"generated\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst RpcRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcRequest\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"method\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"response_timeout_ms\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst RpcAck = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcAck\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst RpcResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcResponse\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 3,\r\n  name: \"error\",\r\n  kind: \"message\",\r\n  T: RpcError$1,\r\n  oneof: \"value\"\r\n}]);\r\nconst RpcError$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcError\", () => [{\r\n  no: 1,\r\n  name: \"code\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"data\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantTracks = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantTracks\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}]);\r\nconst ServerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ServerInfo\", () => [{\r\n  no: 1,\r\n  name: \"edition\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ServerInfo_Edition)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"node_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"debug_info\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"agent_protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}]);\r\nconst ServerInfo_Edition = /* @__PURE__ */proto3.makeEnum(\"livekit.ServerInfo.Edition\", [{\r\n  no: 0,\r\n  name: \"Standard\"\r\n}, {\r\n  no: 1,\r\n  name: \"Cloud\"\r\n}]);\r\nconst ClientInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientInfo\", () => [{\r\n  no: 1,\r\n  name: \"sdk\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientInfo_SDK)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"os\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"os_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"device_model\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"browser\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 8,\r\n  name: \"browser_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"address\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"network\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 11,\r\n  name: \"other_sdks\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ClientInfo_SDK = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientInfo.SDK\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"JS\"\r\n}, {\r\n  no: 2,\r\n  name: \"SWIFT\"\r\n}, {\r\n  no: 3,\r\n  name: \"ANDROID\"\r\n}, {\r\n  no: 4,\r\n  name: \"FLUTTER\"\r\n}, {\r\n  no: 5,\r\n  name: \"GO\"\r\n}, {\r\n  no: 6,\r\n  name: \"UNITY\"\r\n}, {\r\n  no: 7,\r\n  name: \"REACT_NATIVE\"\r\n}, {\r\n  no: 8,\r\n  name: \"RUST\"\r\n}, {\r\n  no: 9,\r\n  name: \"PYTHON\"\r\n}, {\r\n  no: 10,\r\n  name: \"CPP\"\r\n}, {\r\n  no: 11,\r\n  name: \"UNITY_WEB\"\r\n}, {\r\n  no: 12,\r\n  name: \"NODE\"\r\n}, {\r\n  no: 13,\r\n  name: \"UNREAL\"\r\n}]);\r\nconst ClientConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientConfiguration\", () => [{\r\n  no: 1,\r\n  name: \"video\",\r\n  kind: \"message\",\r\n  T: VideoConfiguration\r\n}, {\r\n  no: 2,\r\n  name: \"screen\",\r\n  kind: \"message\",\r\n  T: VideoConfiguration\r\n}, {\r\n  no: 3,\r\n  name: \"resume_connection\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}, {\r\n  no: 4,\r\n  name: \"disabled_codecs\",\r\n  kind: \"message\",\r\n  T: DisabledCodecs\r\n}, {\r\n  no: 5,\r\n  name: \"force_relay\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}]);\r\nconst VideoConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoConfiguration\", () => [{\r\n  no: 1,\r\n  name: \"hardware_encoder\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}]);\r\nconst DisabledCodecs = /* @__PURE__ */proto3.makeMessageType(\"livekit.DisabledCodecs\", () => [{\r\n  no: 1,\r\n  name: \"codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"publish\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}]);\r\nconst TimedVersion = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimedVersion\", () => [{\r\n  no: 1,\r\n  name: \"unix_micro\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"ticks\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}]);\r\nconst DataStream_OperationType = /* @__PURE__ */proto3.makeEnum(\"livekit.DataStream.OperationType\", [{\r\n  no: 0,\r\n  name: \"CREATE\"\r\n}, {\r\n  no: 1,\r\n  name: \"UPDATE\"\r\n}, {\r\n  no: 2,\r\n  name: \"DELETE\"\r\n}, {\r\n  no: 3,\r\n  name: \"REACTION\"\r\n}]);\r\nconst DataStream_TextHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.TextHeader\", () => [{\r\n  no: 1,\r\n  name: \"operation_type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DataStream_OperationType)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"reply_to_stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"attached_stream_ids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"generated\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}], {\r\n  localName: \"DataStream_TextHeader\"\r\n});\r\nconst DataStream_ByteHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", () => [{\r\n  no: 1,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}], {\r\n  localName: \"DataStream_ByteHeader\"\r\n});\r\nconst DataStream_Header = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Header\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"topic\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"total_length\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 7,\r\n  name: \"encryption_type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 8,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 9,\r\n  name: \"text_header\",\r\n  kind: \"message\",\r\n  T: DataStream_TextHeader,\r\n  oneof: \"content_header\"\r\n}, {\r\n  no: 10,\r\n  name: \"byte_header\",\r\n  kind: \"message\",\r\n  T: DataStream_ByteHeader,\r\n  oneof: \"content_header\"\r\n}], {\r\n  localName: \"DataStream_Header\"\r\n});\r\nconst DataStream_Chunk = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Chunk\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"chunk_index\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"content\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 4,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"iv\",\r\n  kind: \"scalar\",\r\n  T: 12,\r\n  opt: true\r\n}], {\r\n  localName: \"DataStream_Chunk\"\r\n});\r\nconst DataStream_Trailer = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Trailer\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}], {\r\n  localName: \"DataStream_Trailer\"\r\n});\r\nconst SignalTarget = /* @__PURE__ */proto3.makeEnum(\"livekit.SignalTarget\", [{\r\n  no: 0,\r\n  name: \"PUBLISHER\"\r\n}, {\r\n  no: 1,\r\n  name: \"SUBSCRIBER\"\r\n}]);\r\nconst StreamState = /* @__PURE__ */proto3.makeEnum(\"livekit.StreamState\", [{\r\n  no: 0,\r\n  name: \"ACTIVE\"\r\n}, {\r\n  no: 1,\r\n  name: \"PAUSED\"\r\n}]);\r\nconst CandidateProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.CandidateProtocol\", [{\r\n  no: 0,\r\n  name: \"UDP\"\r\n}, {\r\n  no: 1,\r\n  name: \"TCP\"\r\n}, {\r\n  no: 2,\r\n  name: \"TLS\"\r\n}]);\r\nconst SignalRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalRequest\", () => [{\r\n  no: 1,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 2,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 3,\r\n  name: \"trickle\",\r\n  kind: \"message\",\r\n  T: TrickleRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 4,\r\n  name: \"add_track\",\r\n  kind: \"message\",\r\n  T: AddTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 5,\r\n  name: \"mute\",\r\n  kind: \"message\",\r\n  T: MuteTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 6,\r\n  name: \"subscription\",\r\n  kind: \"message\",\r\n  T: UpdateSubscription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 7,\r\n  name: \"track_setting\",\r\n  kind: \"message\",\r\n  T: UpdateTrackSettings,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 8,\r\n  name: \"leave\",\r\n  kind: \"message\",\r\n  T: LeaveRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 10,\r\n  name: \"update_layers\",\r\n  kind: \"message\",\r\n  T: UpdateVideoLayers,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 11,\r\n  name: \"subscription_permission\",\r\n  kind: \"message\",\r\n  T: SubscriptionPermission,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 12,\r\n  name: \"sync_state\",\r\n  kind: \"message\",\r\n  T: SyncState,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 13,\r\n  name: \"simulate\",\r\n  kind: \"message\",\r\n  T: SimulateScenario,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 14,\r\n  name: \"ping\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 15,\r\n  name: \"update_metadata\",\r\n  kind: \"message\",\r\n  T: UpdateParticipantMetadata,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 16,\r\n  name: \"ping_req\",\r\n  kind: \"message\",\r\n  T: Ping,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 17,\r\n  name: \"update_audio_track\",\r\n  kind: \"message\",\r\n  T: UpdateLocalAudioTrack,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 18,\r\n  name: \"update_video_track\",\r\n  kind: \"message\",\r\n  T: UpdateLocalVideoTrack,\r\n  oneof: \"message\"\r\n}]);\r\nconst SignalResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalResponse\", () => [{\r\n  no: 1,\r\n  name: \"join\",\r\n  kind: \"message\",\r\n  T: JoinResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 2,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 3,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 4,\r\n  name: \"trickle\",\r\n  kind: \"message\",\r\n  T: TrickleRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 5,\r\n  name: \"update\",\r\n  kind: \"message\",\r\n  T: ParticipantUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 6,\r\n  name: \"track_published\",\r\n  kind: \"message\",\r\n  T: TrackPublishedResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 8,\r\n  name: \"leave\",\r\n  kind: \"message\",\r\n  T: LeaveRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 9,\r\n  name: \"mute\",\r\n  kind: \"message\",\r\n  T: MuteTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 10,\r\n  name: \"speakers_changed\",\r\n  kind: \"message\",\r\n  T: SpeakersChanged,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 11,\r\n  name: \"room_update\",\r\n  kind: \"message\",\r\n  T: RoomUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 12,\r\n  name: \"connection_quality\",\r\n  kind: \"message\",\r\n  T: ConnectionQualityUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 13,\r\n  name: \"stream_state_update\",\r\n  kind: \"message\",\r\n  T: StreamStateUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 14,\r\n  name: \"subscribed_quality_update\",\r\n  kind: \"message\",\r\n  T: SubscribedQualityUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 15,\r\n  name: \"subscription_permission_update\",\r\n  kind: \"message\",\r\n  T: SubscriptionPermissionUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 16,\r\n  name: \"refresh_token\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 17,\r\n  name: \"track_unpublished\",\r\n  kind: \"message\",\r\n  T: TrackUnpublishedResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 18,\r\n  name: \"pong\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 19,\r\n  name: \"reconnect\",\r\n  kind: \"message\",\r\n  T: ReconnectResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 20,\r\n  name: \"pong_resp\",\r\n  kind: \"message\",\r\n  T: Pong,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 21,\r\n  name: \"subscription_response\",\r\n  kind: \"message\",\r\n  T: SubscriptionResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 22,\r\n  name: \"request_response\",\r\n  kind: \"message\",\r\n  T: RequestResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 23,\r\n  name: \"track_subscribed\",\r\n  kind: \"message\",\r\n  T: TrackSubscribed,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 24,\r\n  name: \"room_moved\",\r\n  kind: \"message\",\r\n  T: RoomMovedResponse,\r\n  oneof: \"message\"\r\n}]);\r\nconst SimulcastCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodec\", () => [{\r\n  no: 1,\r\n  name: \"codec\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst AddTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.AddTrackRequest\", () => [{\r\n  no: 1,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackType)\r\n}, {\r\n  no: 4,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 7,\r\n  name: \"disable_dtx\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"source\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource)\r\n}, {\r\n  no: 9,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}, {\r\n  no: 10,\r\n  name: \"simulcast_codecs\",\r\n  kind: \"message\",\r\n  T: SimulcastCodec,\r\n  repeated: true\r\n}, {\r\n  no: 11,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 12,\r\n  name: \"stereo\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 13,\r\n  name: \"disable_red\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 14,\r\n  name: \"encryption\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 15,\r\n  name: \"stream\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 16,\r\n  name: \"backup_codec_policy\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(BackupCodecPolicy$1)\r\n}, {\r\n  no: 17,\r\n  name: \"audio_features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}]);\r\nconst TrickleRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrickleRequest\", () => [{\r\n  no: 1,\r\n  name: \"candidateInit\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"target\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SignalTarget)\r\n}, {\r\n  no: 3,\r\n  name: \"final\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst MuteTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.MuteTrackRequest\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst JoinResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.JoinResponse\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}, {\r\n  no: 2,\r\n  name: \"participant\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo\r\n}, {\r\n  no: 3,\r\n  name: \"other_participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"server_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"ice_servers\",\r\n  kind: \"message\",\r\n  T: ICEServer,\r\n  repeated: true\r\n}, {\r\n  no: 6,\r\n  name: \"subscriber_primary\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 7,\r\n  name: \"alternative_url\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 8,\r\n  name: \"client_configuration\",\r\n  kind: \"message\",\r\n  T: ClientConfiguration\r\n}, {\r\n  no: 9,\r\n  name: \"server_region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"ping_timeout\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"ping_interval\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 12,\r\n  name: \"server_info\",\r\n  kind: \"message\",\r\n  T: ServerInfo\r\n}, {\r\n  no: 13,\r\n  name: \"sif_trailer\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 14,\r\n  name: \"enabled_publish_codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 15,\r\n  name: \"fast_publish\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst ReconnectResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.ReconnectResponse\", () => [{\r\n  no: 1,\r\n  name: \"ice_servers\",\r\n  kind: \"message\",\r\n  T: ICEServer,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"client_configuration\",\r\n  kind: \"message\",\r\n  T: ClientConfiguration\r\n}, {\r\n  no: 3,\r\n  name: \"server_info\",\r\n  kind: \"message\",\r\n  T: ServerInfo\r\n}, {\r\n  no: 4,\r\n  name: \"last_message_seq\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst TrackPublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPublishedResponse\", () => [{\r\n  no: 1,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track\",\r\n  kind: \"message\",\r\n  T: TrackInfo\r\n}]);\r\nconst TrackUnpublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SessionDescription = /* @__PURE__ */proto3.makeMessageType(\"livekit.SessionDescription\", () => [{\r\n  no: 1,\r\n  name: \"type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"sdp\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantUpdate\", () => [{\r\n  no: 1,\r\n  name: \"participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}]);\r\nconst UpdateSubscription = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateSubscription\", () => [{\r\n  no: 1,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"subscribe\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"participant_tracks\",\r\n  kind: \"message\",\r\n  T: ParticipantTracks,\r\n  repeated: true\r\n}]);\r\nconst UpdateTrackSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateTrackSettings\", () => [{\r\n  no: 1,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 3,\r\n  name: \"disabled\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 4,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 5,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 7,\r\n  name: \"fps\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 8,\r\n  name: \"priority\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst UpdateLocalAudioTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}]);\r\nconst UpdateLocalVideoTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst LeaveRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.LeaveRequest\", () => [{\r\n  no: 1,\r\n  name: \"can_reconnect\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DisconnectReason)\r\n}, {\r\n  no: 3,\r\n  name: \"action\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(LeaveRequest_Action)\r\n}, {\r\n  no: 4,\r\n  name: \"regions\",\r\n  kind: \"message\",\r\n  T: RegionSettings\r\n}]);\r\nconst LeaveRequest_Action = /* @__PURE__ */proto3.makeEnum(\"livekit.LeaveRequest.Action\", [{\r\n  no: 0,\r\n  name: \"DISCONNECT\"\r\n}, {\r\n  no: 1,\r\n  name: \"RESUME\"\r\n}, {\r\n  no: 2,\r\n  name: \"RECONNECT\"\r\n}]);\r\nconst UpdateVideoLayers = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateVideoLayers\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}]);\r\nconst UpdateParticipantMetadata = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", () => [{\r\n  no: 1,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 4,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst ICEServer = /* @__PURE__ */proto3.makeMessageType(\"livekit.ICEServer\", () => [{\r\n  no: 1,\r\n  name: \"urls\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"username\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"credential\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SpeakersChanged = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakersChanged\", () => [{\r\n  no: 1,\r\n  name: \"speakers\",\r\n  kind: \"message\",\r\n  T: SpeakerInfo,\r\n  repeated: true\r\n}]);\r\nconst RoomUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomUpdate\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}]);\r\nconst ConnectionQualityInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ConnectionQuality$1)\r\n}, {\r\n  no: 3,\r\n  name: \"score\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}]);\r\nconst ConnectionQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", () => [{\r\n  no: 1,\r\n  name: \"updates\",\r\n  kind: \"message\",\r\n  T: ConnectionQualityInfo,\r\n  repeated: true\r\n}]);\r\nconst StreamStateInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateInfo\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"state\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(StreamState)\r\n}]);\r\nconst StreamStateUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateUpdate\", () => [{\r\n  no: 1,\r\n  name: \"stream_states\",\r\n  kind: \"message\",\r\n  T: StreamStateInfo,\r\n  repeated: true\r\n}]);\r\nconst SubscribedQuality = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQuality\", () => [{\r\n  no: 1,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 2,\r\n  name: \"enabled\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst SubscribedCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedCodec\", () => [{\r\n  no: 1,\r\n  name: \"codec\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"qualities\",\r\n  kind: \"message\",\r\n  T: SubscribedQuality,\r\n  repeated: true\r\n}]);\r\nconst SubscribedQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"subscribed_qualities\",\r\n  kind: \"message\",\r\n  T: SubscribedQuality,\r\n  repeated: true\r\n}, {\r\n  no: 3,\r\n  name: \"subscribed_codecs\",\r\n  kind: \"message\",\r\n  T: SubscribedCodec,\r\n  repeated: true\r\n}]);\r\nconst TrackPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPermission\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"all_tracks\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SubscriptionPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermission\", () => [{\r\n  no: 1,\r\n  name: \"all_participants\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"track_permissions\",\r\n  kind: \"message\",\r\n  T: TrackPermission,\r\n  repeated: true\r\n}]);\r\nconst SubscriptionPermissionUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"allowed\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst RoomMovedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomMovedResponse\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}, {\r\n  no: 2,\r\n  name: \"token\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"participant\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo\r\n}, {\r\n  no: 4,\r\n  name: \"other_participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}]);\r\nconst SyncState = /* @__PURE__ */proto3.makeMessageType(\"livekit.SyncState\", () => [{\r\n  no: 1,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription\r\n}, {\r\n  no: 2,\r\n  name: \"subscription\",\r\n  kind: \"message\",\r\n  T: UpdateSubscription\r\n}, {\r\n  no: 3,\r\n  name: \"publish_tracks\",\r\n  kind: \"message\",\r\n  T: TrackPublishedResponse,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"data_channels\",\r\n  kind: \"message\",\r\n  T: DataChannelInfo,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription\r\n}, {\r\n  no: 6,\r\n  name: \"track_sids_disabled\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 7,\r\n  name: \"datachannel_receive_states\",\r\n  kind: \"message\",\r\n  T: DataChannelReceiveState,\r\n  repeated: true\r\n}]);\r\nconst DataChannelReceiveState = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelReceiveState\", () => [{\r\n  no: 1,\r\n  name: \"publisher_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"last_seq\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst DataChannelInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelInfo\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"target\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SignalTarget)\r\n}]);\r\nconst SimulateScenario = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulateScenario\", () => [{\r\n  no: 1,\r\n  name: \"speaker_update\",\r\n  kind: \"scalar\",\r\n  T: 5,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 2,\r\n  name: \"node_failure\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 3,\r\n  name: \"migration\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 4,\r\n  name: \"server_leave\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 5,\r\n  name: \"switch_candidate_protocol\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(CandidateProtocol),\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 6,\r\n  name: \"subscriber_bandwidth\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 7,\r\n  name: \"disconnect_signal_on_resume\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 8,\r\n  name: \"disconnect_signal_on_resume_no_messages\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 9,\r\n  name: \"leave_request_full_reconnect\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}]);\r\nconst Ping = /* @__PURE__ */proto3.makeMessageType(\"livekit.Ping\", () => [{\r\n  no: 1,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"rtt\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst Pong = /* @__PURE__ */proto3.makeMessageType(\"livekit.Pong\", () => [{\r\n  no: 1,\r\n  name: \"last_ping_timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst RegionSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionSettings\", () => [{\r\n  no: 1,\r\n  name: \"regions\",\r\n  kind: \"message\",\r\n  T: RegionInfo,\r\n  repeated: true\r\n}]);\r\nconst RegionInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionInfo\", () => [{\r\n  no: 1,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"url\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"distance\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst SubscriptionResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionResponse\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"err\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SubscriptionError)\r\n}]);\r\nconst RequestResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RequestResponse\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(RequestResponse_Reason)\r\n}, {\r\n  no: 3,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst RequestResponse_Reason = /* @__PURE__ */proto3.makeEnum(\"livekit.RequestResponse.Reason\", [{\r\n  no: 0,\r\n  name: \"OK\"\r\n}, {\r\n  no: 1,\r\n  name: \"NOT_FOUND\"\r\n}, {\r\n  no: 2,\r\n  name: \"NOT_ALLOWED\"\r\n}, {\r\n  no: 3,\r\n  name: \"LIMIT_EXCEEDED\"\r\n}]);\r\nconst TrackSubscribed = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackSubscribed\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\n\r\nfunction getDefaultExportFromCjs (x) {\r\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\r\n}\r\n\r\nvar loglevel$1 = {exports: {}};\r\n\r\n/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\nvar loglevel = loglevel$1.exports;\r\nvar hasRequiredLoglevel;\r\nfunction requireLoglevel() {\r\n  if (hasRequiredLoglevel) return loglevel$1.exports;\r\n  hasRequiredLoglevel = 1;\r\n  (function (module) {\r\n    (function (root, definition) {\r\n\r\n      if (module.exports) {\r\n        module.exports = definition();\r\n      } else {\r\n        root.log = definition();\r\n      }\r\n    })(loglevel, function () {\r\n\r\n      // Slightly dubious tricks to cut down minimized file size\r\n      var noop = function () {};\r\n      var undefinedType = \"undefined\";\r\n      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\r\n      var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\r\n      var _loggersByName = {};\r\n      var defaultLogger = null;\r\n\r\n      // Cross-browser bind equivalent that works at least back to IE6\r\n      function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n          return method.bind(obj);\r\n        } else {\r\n          try {\r\n            return Function.prototype.bind.call(method, obj);\r\n          } catch (e) {\r\n            // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n            return function () {\r\n              return Function.prototype.apply.apply(method, [obj, arguments]);\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      // Trace() doesn't print the message in IE, so for that case we need to wrap it\r\n      function traceForIE() {\r\n        if (console.log) {\r\n          if (console.log.apply) {\r\n            console.log.apply(console, arguments);\r\n          } else {\r\n            // In old IE, native console methods themselves don't have apply().\r\n            Function.prototype.apply.apply(console.log, [console, arguments]);\r\n          }\r\n        }\r\n        if (console.trace) console.trace();\r\n      }\r\n\r\n      // Build the best logging method possible for this env\r\n      // Wherever possible we want to bind, not wrap, to preserve stack traces\r\n      function realMethod(methodName) {\r\n        if (methodName === 'debug') {\r\n          methodName = 'log';\r\n        }\r\n        if (typeof console === undefinedType) {\r\n          return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\r\n        } else if (methodName === 'trace' && isIE) {\r\n          return traceForIE;\r\n        } else if (console[methodName] !== undefined) {\r\n          return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n          return bindMethod(console, 'log');\r\n        } else {\r\n          return noop;\r\n        }\r\n      }\r\n\r\n      // These private functions always need `this` to be set properly\r\n\r\n      function replaceLoggingMethods() {\r\n        /*jshint validthis:true */\r\n        var level = this.getLevel();\r\n\r\n        // Replace the actual methods.\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n          var methodName = logMethods[i];\r\n          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\r\n        }\r\n\r\n        // Define log.log as an alias for log.debug\r\n        this.log = this.debug;\r\n\r\n        // Return any important warnings.\r\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\r\n          return \"No console available for logging\";\r\n        }\r\n      }\r\n\r\n      // In old IE versions, the console isn't present until you first open it.\r\n      // We build realMethod() replacements here that regenerate logging methods\r\n      function enableLoggingWhenConsoleArrives(methodName) {\r\n        return function () {\r\n          if (typeof console !== undefinedType) {\r\n            replaceLoggingMethods.call(this);\r\n            this[methodName].apply(this, arguments);\r\n          }\r\n        };\r\n      }\r\n\r\n      // By default, we use closely bound real methods wherever possible, and\r\n      // otherwise we wait for a console to appear, and then try again.\r\n      function defaultMethodFactory(methodName, _level, _loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n      }\r\n      function Logger(name, factory) {\r\n        // Private instance variables.\r\n        var self = this;\r\n        /**\r\n         * The level inherited from a parent logger (or a global default). We\r\n         * cache this here rather than delegating to the parent so that it stays\r\n         * in sync with the actual logging methods that we have installed (the\r\n         * parent could change levels but we might not have rebuilt the loggers\r\n         * in this child yet).\r\n         * @type {number}\r\n         */\r\n        var inheritedLevel;\r\n        /**\r\n         * The default level for this logger, if any. If set, this overrides\r\n         * `inheritedLevel`.\r\n         * @type {number|null}\r\n         */\r\n        var defaultLevel;\r\n        /**\r\n         * A user-specific level for this logger. If set, this overrides\r\n         * `defaultLevel`.\r\n         * @type {number|null}\r\n         */\r\n        var userLevel;\r\n        var storageKey = \"loglevel\";\r\n        if (typeof name === \"string\") {\r\n          storageKey += \":\" + name;\r\n        } else if (typeof name === \"symbol\") {\r\n          storageKey = undefined;\r\n        }\r\n        function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n            window.localStorage[storageKey] = levelName;\r\n            return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n            window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n        }\r\n        function getPersistedLevel() {\r\n          var storedLevel;\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n          try {\r\n            storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          // Fallback to cookies if local storage gives us nothing\r\n          if (typeof storedLevel === undefinedType) {\r\n            try {\r\n              var cookie = window.document.cookie;\r\n              var cookieName = encodeURIComponent(storageKey);\r\n              var location = cookie.indexOf(cookieName + \"=\");\r\n              if (location !== -1) {\r\n                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\r\n              }\r\n            } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n            storedLevel = undefined;\r\n          }\r\n          return storedLevel;\r\n        }\r\n        function clearPersistedLevel() {\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n            window.localStorage.removeItem(storageKey);\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n            window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\r\n          } catch (ignore) {}\r\n        }\r\n        function normalizeLevel(input) {\r\n          var level = input;\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n            level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n            return level;\r\n          } else {\r\n            throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\r\n          }\r\n        }\r\n\r\n        /*\r\n         *\r\n         * Public logger API - see https://github.com/pimterry/loglevel for details\r\n         *\r\n         */\r\n\r\n        self.name = name;\r\n        self.levels = {\r\n          \"TRACE\": 0,\r\n          \"DEBUG\": 1,\r\n          \"INFO\": 2,\r\n          \"WARN\": 3,\r\n          \"ERROR\": 4,\r\n          \"SILENT\": 5\r\n        };\r\n        self.methodFactory = factory || defaultMethodFactory;\r\n        self.getLevel = function () {\r\n          if (userLevel != null) {\r\n            return userLevel;\r\n          } else if (defaultLevel != null) {\r\n            return defaultLevel;\r\n          } else {\r\n            return inheritedLevel;\r\n          }\r\n        };\r\n        self.setLevel = function (level, persist) {\r\n          userLevel = normalizeLevel(level);\r\n          if (persist !== false) {\r\n            // defaults to true\r\n            persistLevelIfPossible(userLevel);\r\n          }\r\n\r\n          // NOTE: in v2, this should call rebuild(), which updates children.\r\n          return replaceLoggingMethods.call(self);\r\n        };\r\n        self.setDefaultLevel = function (level) {\r\n          defaultLevel = normalizeLevel(level);\r\n          if (!getPersistedLevel()) {\r\n            self.setLevel(level, false);\r\n          }\r\n        };\r\n        self.resetLevel = function () {\r\n          userLevel = null;\r\n          clearPersistedLevel();\r\n          replaceLoggingMethods.call(self);\r\n        };\r\n        self.enableAll = function (persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n        };\r\n        self.disableAll = function (persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n        };\r\n        self.rebuild = function () {\r\n          if (defaultLogger !== self) {\r\n            inheritedLevel = normalizeLevel(defaultLogger.getLevel());\r\n          }\r\n          replaceLoggingMethods.call(self);\r\n          if (defaultLogger === self) {\r\n            for (var childName in _loggersByName) {\r\n              _loggersByName[childName].rebuild();\r\n            }\r\n          }\r\n        };\r\n\r\n        // Initialize all the internal levels.\r\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\r\n        var initialLevel = getPersistedLevel();\r\n        if (initialLevel != null) {\r\n          userLevel = normalizeLevel(initialLevel);\r\n        }\r\n        replaceLoggingMethods.call(self);\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Top-level API\r\n       *\r\n       */\r\n\r\n      defaultLogger = new Logger();\r\n      defaultLogger.getLogger = function getLogger(name) {\r\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n      };\r\n\r\n      // Grab the current global log variable in case of overwrite\r\n      var _log = typeof window !== undefinedType ? window.log : undefined;\r\n      defaultLogger.noConflict = function () {\r\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\r\n          window.log = _log;\r\n        }\r\n        return defaultLogger;\r\n      };\r\n      defaultLogger.getLoggers = function getLoggers() {\r\n        return _loggersByName;\r\n      };\r\n\r\n      // ES6 default export, for compatibility\r\n      defaultLogger['default'] = defaultLogger;\r\n      return defaultLogger;\r\n    });\r\n  })(loglevel$1);\r\n  return loglevel$1.exports;\r\n}\r\n\r\nvar loglevelExports = requireLoglevel();\r\n\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\r\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\r\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\r\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\r\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\r\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\r\n})(LogLevel || (LogLevel = {}));\r\nvar LoggerNames;\r\n(function (LoggerNames) {\r\n  LoggerNames[\"Default\"] = \"livekit\";\r\n  LoggerNames[\"Room\"] = \"livekit-room\";\r\n  LoggerNames[\"Participant\"] = \"livekit-participant\";\r\n  LoggerNames[\"Track\"] = \"livekit-track\";\r\n  LoggerNames[\"Publication\"] = \"livekit-track-publication\";\r\n  LoggerNames[\"Engine\"] = \"livekit-engine\";\r\n  LoggerNames[\"Signal\"] = \"livekit-signal\";\r\n  LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\r\n  LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\r\n  LoggerNames[\"E2EE\"] = \"lk-e2ee\";\r\n})(LoggerNames || (LoggerNames = {}));\r\nlet livekitLogger = loglevelExports.getLogger('livekit');\r\nconst livekitLoggers = Object.values(LoggerNames).map(name => loglevelExports.getLogger(name));\r\nlivekitLogger.setDefaultLevel(LogLevel.info);\r\n/**\r\n * @internal\r\n */\r\nfunction getLogger(name) {\r\n  const logger = loglevelExports.getLogger(name);\r\n  logger.setDefaultLevel(livekitLogger.getLevel());\r\n  return logger;\r\n}\r\nfunction setLogLevel(level, loggerName) {\r\n  if (loggerName) {\r\n    loglevelExports.getLogger(loggerName).setLevel(level);\r\n  } else {\r\n    for (const logger of livekitLoggers) {\r\n      logger.setLevel(level);\r\n    }\r\n  }\r\n}\r\n/**\r\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\r\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\r\n */\r\nfunction setLogExtension(extension, logger) {\r\n  const loggers = logger ? [logger] : livekitLoggers;\r\n  loggers.forEach(logR => {\r\n    const originalFactory = logR.methodFactory;\r\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\r\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\r\n      const logLevel = LogLevel[methodName];\r\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\r\n      return (msg, context) => {\r\n        if (context) rawMethod(msg, context);else rawMethod(msg);\r\n        if (needLog) {\r\n          extension(logLevel, msg, context);\r\n        }\r\n      };\r\n    };\r\n    logR.setLevel(logR.getLevel());\r\n  });\r\n}\r\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');\r\n\r\nconst maxRetryDelay = 7000;\r\nconst DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\r\nclass DefaultReconnectPolicy {\r\n  constructor(retryDelays) {\r\n    this._retryDelays = retryDelays !== undefined ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\r\n  }\r\n  nextRetryDelayInMs(context) {\r\n    if (context.retryCount >= this._retryDelays.length) return null;\r\n    const retryDelay = this._retryDelays[context.retryCount];\r\n    if (context.retryCount <= 1) return retryDelay;\r\n    return retryDelay + Math.random() * 1000;\r\n  }\r\n}\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nvar events = {exports: {}};\r\n\r\nvar hasRequiredEvents;\r\nfunction requireEvents() {\r\n  if (hasRequiredEvents) return events.exports;\r\n  hasRequiredEvents = 1;\r\n  var R = typeof Reflect === 'object' ? Reflect : null;\r\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\r\n    return Function.prototype.apply.call(target, receiver, args);\r\n  };\r\n  var ReflectOwnKeys;\r\n  if (R && typeof R.ownKeys === 'function') {\r\n    ReflectOwnKeys = R.ownKeys;\r\n  } else if (Object.getOwnPropertySymbols) {\r\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\r\n    };\r\n  } else {\r\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n      return Object.getOwnPropertyNames(target);\r\n    };\r\n  }\r\n  function ProcessEmitWarning(warning) {\r\n    if (console && console.warn) console.warn(warning);\r\n  }\r\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\r\n    return value !== value;\r\n  };\r\n  function EventEmitter() {\r\n    EventEmitter.init.call(this);\r\n  }\r\n  events.exports = EventEmitter;\r\n  events.exports.once = once;\r\n\r\n  // Backwards-compat with node 0.10.x\r\n  EventEmitter.EventEmitter = EventEmitter;\r\n  EventEmitter.prototype._events = undefined;\r\n  EventEmitter.prototype._eventsCount = 0;\r\n  EventEmitter.prototype._maxListeners = undefined;\r\n\r\n  // By default EventEmitters will print a warning if more than 10 listeners are\r\n  // added to it. This is a useful default which helps finding memory leaks.\r\n  var defaultMaxListeners = 10;\r\n  function checkListener(listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\r\n    }\r\n  }\r\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\r\n    enumerable: true,\r\n    get: function () {\r\n      return defaultMaxListeners;\r\n    },\r\n    set: function (arg) {\r\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\r\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\r\n      }\r\n      defaultMaxListeners = arg;\r\n    }\r\n  });\r\n  EventEmitter.init = function () {\r\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\r\n      this._events = Object.create(null);\r\n      this._eventsCount = 0;\r\n    }\r\n    this._maxListeners = this._maxListeners || undefined;\r\n  };\r\n\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\r\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\r\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\r\n    }\r\n    this._maxListeners = n;\r\n    return this;\r\n  };\r\n  function _getMaxListeners(that) {\r\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\r\n    return that._maxListeners;\r\n  }\r\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\r\n    return _getMaxListeners(this);\r\n  };\r\n  EventEmitter.prototype.emit = function emit(type) {\r\n    var args = [];\r\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\r\n    var doError = type === 'error';\r\n    var events = this._events;\r\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\r\n\r\n    // If there is no 'error' event listener then throw.\r\n    if (doError) {\r\n      var er;\r\n      if (args.length > 0) er = args[0];\r\n      if (er instanceof Error) {\r\n        // Note: The comments on the `throw` lines are intentional, they show\r\n        // up in Node's output if this results in an unhandled exception.\r\n        throw er; // Unhandled 'error' event\r\n      }\r\n      // At least give some kind of context to the user\r\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\r\n      err.context = er;\r\n      throw err; // Unhandled 'error' event\r\n    }\r\n    var handler = events[type];\r\n    if (handler === undefined) return false;\r\n    if (typeof handler === 'function') {\r\n      ReflectApply(handler, this, args);\r\n    } else {\r\n      var len = handler.length;\r\n      var listeners = arrayClone(handler, len);\r\n      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\r\n    }\r\n    return true;\r\n  };\r\n  function _addListener(target, type, listener, prepend) {\r\n    var m;\r\n    var events;\r\n    var existing;\r\n    checkListener(listener);\r\n    events = target._events;\r\n    if (events === undefined) {\r\n      events = target._events = Object.create(null);\r\n      target._eventsCount = 0;\r\n    } else {\r\n      // To avoid recursion in the case that type === \"newListener\"! Before\r\n      // adding it to the listeners, first emit \"newListener\".\r\n      if (events.newListener !== undefined) {\r\n        target.emit('newListener', type, listener.listener ? listener.listener : listener);\r\n\r\n        // Re-assign `events` because a newListener handler could have caused the\r\n        // this._events to be assigned to a new object\r\n        events = target._events;\r\n      }\r\n      existing = events[type];\r\n    }\r\n    if (existing === undefined) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      existing = events[type] = listener;\r\n      ++target._eventsCount;\r\n    } else {\r\n      if (typeof existing === 'function') {\r\n        // Adding the second element, need to change to array.\r\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\r\n        // If we've already got an array, just append.\r\n      } else if (prepend) {\r\n        existing.unshift(listener);\r\n      } else {\r\n        existing.push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      m = _getMaxListeners(target);\r\n      if (m > 0 && existing.length > m && !existing.warned) {\r\n        existing.warned = true;\r\n        // No error code for this since it is a Warning\r\n        // eslint-disable-next-line no-restricted-syntax\r\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\r\n        w.name = 'MaxListenersExceededWarning';\r\n        w.emitter = target;\r\n        w.type = type;\r\n        w.count = existing.length;\r\n        ProcessEmitWarning(w);\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\r\n    return _addListener(this, type, listener, false);\r\n  };\r\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\r\n    return _addListener(this, type, listener, true);\r\n  };\r\n  function onceWrapper() {\r\n    if (!this.fired) {\r\n      this.target.removeListener(this.type, this.wrapFn);\r\n      this.fired = true;\r\n      if (arguments.length === 0) return this.listener.call(this.target);\r\n      return this.listener.apply(this.target, arguments);\r\n    }\r\n  }\r\n  function _onceWrap(target, type, listener) {\r\n    var state = {\r\n      fired: false,\r\n      wrapFn: undefined,\r\n      target: target,\r\n      type: type,\r\n      listener: listener\r\n    };\r\n    var wrapped = onceWrapper.bind(state);\r\n    wrapped.listener = listener;\r\n    state.wrapFn = wrapped;\r\n    return wrapped;\r\n  }\r\n  EventEmitter.prototype.once = function once(type, listener) {\r\n    checkListener(listener);\r\n    this.on(type, _onceWrap(this, type, listener));\r\n    return this;\r\n  };\r\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\r\n    checkListener(listener);\r\n    this.prependListener(type, _onceWrap(this, type, listener));\r\n    return this;\r\n  };\r\n\r\n  // Emits a 'removeListener' event if and only if the listener was removed.\r\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\r\n    var list, events, position, i, originalListener;\r\n    checkListener(listener);\r\n    events = this._events;\r\n    if (events === undefined) return this;\r\n    list = events[type];\r\n    if (list === undefined) return this;\r\n    if (list === listener || list.listener === listener) {\r\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\r\n        delete events[type];\r\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\r\n      }\r\n    } else if (typeof list !== 'function') {\r\n      position = -1;\r\n      for (i = list.length - 1; i >= 0; i--) {\r\n        if (list[i] === listener || list[i].listener === listener) {\r\n          originalListener = list[i].listener;\r\n          position = i;\r\n          break;\r\n        }\r\n      }\r\n      if (position < 0) return this;\r\n      if (position === 0) list.shift();else {\r\n        spliceOne(list, position);\r\n      }\r\n      if (list.length === 1) events[type] = list[0];\r\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\r\n    }\r\n    return this;\r\n  };\r\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\r\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\r\n    var listeners, events, i;\r\n    events = this._events;\r\n    if (events === undefined) return this;\r\n\r\n    // not listening for removeListener, no need to emit\r\n    if (events.removeListener === undefined) {\r\n      if (arguments.length === 0) {\r\n        this._events = Object.create(null);\r\n        this._eventsCount = 0;\r\n      } else if (events[type] !== undefined) {\r\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\r\n      }\r\n      return this;\r\n    }\r\n\r\n    // emit removeListener for all listeners on all events\r\n    if (arguments.length === 0) {\r\n      var keys = Object.keys(events);\r\n      var key;\r\n      for (i = 0; i < keys.length; ++i) {\r\n        key = keys[i];\r\n        if (key === 'removeListener') continue;\r\n        this.removeAllListeners(key);\r\n      }\r\n      this.removeAllListeners('removeListener');\r\n      this._events = Object.create(null);\r\n      this._eventsCount = 0;\r\n      return this;\r\n    }\r\n    listeners = events[type];\r\n    if (typeof listeners === 'function') {\r\n      this.removeListener(type, listeners);\r\n    } else if (listeners !== undefined) {\r\n      // LIFO order\r\n      for (i = listeners.length - 1; i >= 0; i--) {\r\n        this.removeListener(type, listeners[i]);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n  function _listeners(target, type, unwrap) {\r\n    var events = target._events;\r\n    if (events === undefined) return [];\r\n    var evlistener = events[type];\r\n    if (evlistener === undefined) return [];\r\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\r\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\r\n  }\r\n  EventEmitter.prototype.listeners = function listeners(type) {\r\n    return _listeners(this, type, true);\r\n  };\r\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\r\n    return _listeners(this, type, false);\r\n  };\r\n  EventEmitter.listenerCount = function (emitter, type) {\r\n    if (typeof emitter.listenerCount === 'function') {\r\n      return emitter.listenerCount(type);\r\n    } else {\r\n      return listenerCount.call(emitter, type);\r\n    }\r\n  };\r\n  EventEmitter.prototype.listenerCount = listenerCount;\r\n  function listenerCount(type) {\r\n    var events = this._events;\r\n    if (events !== undefined) {\r\n      var evlistener = events[type];\r\n      if (typeof evlistener === 'function') {\r\n        return 1;\r\n      } else if (evlistener !== undefined) {\r\n        return evlistener.length;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n  EventEmitter.prototype.eventNames = function eventNames() {\r\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\r\n  };\r\n  function arrayClone(arr, n) {\r\n    var copy = new Array(n);\r\n    for (var i = 0; i < n; ++i) copy[i] = arr[i];\r\n    return copy;\r\n  }\r\n  function spliceOne(list, index) {\r\n    for (; index + 1 < list.length; index++) list[index] = list[index + 1];\r\n    list.pop();\r\n  }\r\n  function unwrapListeners(arr) {\r\n    var ret = new Array(arr.length);\r\n    for (var i = 0; i < ret.length; ++i) {\r\n      ret[i] = arr[i].listener || arr[i];\r\n    }\r\n    return ret;\r\n  }\r\n  function once(emitter, name) {\r\n    return new Promise(function (resolve, reject) {\r\n      function errorListener(err) {\r\n        emitter.removeListener(name, resolver);\r\n        reject(err);\r\n      }\r\n      function resolver() {\r\n        if (typeof emitter.removeListener === 'function') {\r\n          emitter.removeListener('error', errorListener);\r\n        }\r\n        resolve([].slice.call(arguments));\r\n      }\r\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\r\n        once: true\r\n      });\r\n      if (name !== 'error') {\r\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\r\n          once: true\r\n        });\r\n      }\r\n    });\r\n  }\r\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\r\n    if (typeof emitter.on === 'function') {\r\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\r\n    }\r\n  }\r\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\r\n    if (typeof emitter.on === 'function') {\r\n      if (flags.once) {\r\n        emitter.once(name, listener);\r\n      } else {\r\n        emitter.on(name, listener);\r\n      }\r\n    } else if (typeof emitter.addEventListener === 'function') {\r\n      // EventTarget does not have `error` event semantics like Node\r\n      // EventEmitters, we do not listen for `error` events here.\r\n      emitter.addEventListener(name, function wrapListener(arg) {\r\n        // IE does not have builtin `{ once: true }` support so we\r\n        // have to do it manually.\r\n        if (flags.once) {\r\n          emitter.removeEventListener(name, wrapListener);\r\n        }\r\n        listener(arg);\r\n      });\r\n    } else {\r\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\r\n    }\r\n  }\r\n  return events.exports;\r\n}\r\n\r\nvar eventsExports = requireEvents();\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nlet logDisabled_ = true;\r\nlet deprecationWarnings_ = true;\r\n\r\n/**\r\n * Extract browser version out of the provided user agent string.\r\n *\r\n * @param {!string} uastring userAgent string.\r\n * @param {!string} expr Regular expression used as match criteria.\r\n * @param {!number} pos position in the version string to be returned.\r\n * @return {!number} browser version.\r\n */\r\nfunction extractVersion(uastring, expr, pos) {\r\n  const match = uastring.match(expr);\r\n  return match && match.length >= pos && parseFloat(match[pos], 10);\r\n}\r\n\r\n// Wraps the peerconnection event eventNameToWrap in a function\r\n// which returns the modified event object (or false to prevent\r\n// the event).\r\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  const proto = window.RTCPeerConnection.prototype;\r\n  const nativeAddEventListener = proto.addEventListener;\r\n  proto.addEventListener = function (nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap) {\r\n      return nativeAddEventListener.apply(this, arguments);\r\n    }\r\n    const wrappedCallback = e => {\r\n      const modifiedEvent = wrapper(e);\r\n      if (modifiedEvent) {\r\n        if (cb.handleEvent) {\r\n          cb.handleEvent(modifiedEvent);\r\n        } else {\r\n          cb(modifiedEvent);\r\n        }\r\n      }\r\n    };\r\n    this._eventMap = this._eventMap || {};\r\n    if (!this._eventMap[eventNameToWrap]) {\r\n      this._eventMap[eventNameToWrap] = new Map();\r\n    }\r\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\r\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\r\n  };\r\n  const nativeRemoveEventListener = proto.removeEventListener;\r\n  proto.removeEventListener = function (nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\r\n    this._eventMap[eventNameToWrap].delete(cb);\r\n    if (this._eventMap[eventNameToWrap].size === 0) {\r\n      delete this._eventMap[eventNameToWrap];\r\n    }\r\n    if (Object.keys(this._eventMap).length === 0) {\r\n      delete this._eventMap;\r\n    }\r\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\r\n  };\r\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\r\n    get() {\r\n      return this['_on' + eventNameToWrap];\r\n    },\r\n    set(cb) {\r\n      if (this['_on' + eventNameToWrap]) {\r\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\r\n        delete this['_on' + eventNameToWrap];\r\n      }\r\n      if (cb) {\r\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n}\r\nfunction disableLog(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\r\n  }\r\n  logDisabled_ = bool;\r\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\r\n}\r\n\r\n/**\r\n * Disable or enable deprecation warnings\r\n * @param {!boolean} bool set to true to disable warnings.\r\n */\r\nfunction disableWarnings(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\r\n  }\r\n  deprecationWarnings_ = !bool;\r\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\r\n}\r\nfunction log() {\r\n  if (typeof window === 'object') {\r\n    if (logDisabled_) {\r\n      return;\r\n    }\r\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\r\n      console.log.apply(console, arguments);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\r\n */\r\nfunction deprecated(oldMethod, newMethod) {\r\n  if (!deprecationWarnings_) {\r\n    return;\r\n  }\r\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\r\n}\r\n\r\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\r\nfunction detectBrowser(window) {\r\n  // Returned result object.\r\n  const result = {\r\n    browser: null,\r\n    version: null\r\n  };\r\n\r\n  // Fail early if it's not a browser\r\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\r\n    result.browser = 'Not a browser.';\r\n    return result;\r\n  }\r\n  const {\r\n    navigator\r\n  } = window;\r\n\r\n  // Prefer navigator.userAgentData.\r\n  if (navigator.userAgentData && navigator.userAgentData.brands) {\r\n    const chromium = navigator.userAgentData.brands.find(brand => {\r\n      return brand.brand === 'Chromium';\r\n    });\r\n    if (chromium) {\r\n      return {\r\n        browser: 'chrome',\r\n        version: parseInt(chromium.version, 10)\r\n      };\r\n    }\r\n  }\r\n  if (navigator.mozGetUserMedia) {\r\n    // Firefox.\r\n    result.browser = 'firefox';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1));\r\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection) {\r\n    // Chrome, Chromium, Webview, Opera.\r\n    // Version matches Chrome/WebRTC version.\r\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\r\n    // more complicated fallback to webkitRTCPeerConnection.\r\n    result.browser = 'chrome';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2));\r\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\r\n    // Safari.\r\n    result.browser = 'safari';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1));\r\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\r\n    // Only for internal usage.\r\n    result._safariVersion = extractVersion(navigator.userAgent, /Version\\/(\\d+(\\.?\\d+))/, 1);\r\n  } else {\r\n    // Default fallthrough: not supported.\r\n    result.browser = 'Not a supported browser.';\r\n    return result;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if something is an object.\r\n *\r\n * @param {*} val The something you want to check.\r\n * @return true if val is an object, false otherwise.\r\n */\r\nfunction isObject(val) {\r\n  return Object.prototype.toString.call(val) === '[object Object]';\r\n}\r\n\r\n/**\r\n * Remove all empty objects and undefined values\r\n * from a nested object -- an enhanced and vanilla version\r\n * of Lodash's `compact`.\r\n */\r\nfunction compactObject(data) {\r\n  if (!isObject(data)) {\r\n    return data;\r\n  }\r\n  return Object.keys(data).reduce(function (accumulator, key) {\r\n    const isObj = isObject(data[key]);\r\n    const value = isObj ? compactObject(data[key]) : data[key];\r\n    const isEmptyObject = isObj && !Object.keys(value).length;\r\n    if (value === undefined || isEmptyObject) {\r\n      return accumulator;\r\n    }\r\n    return Object.assign(accumulator, {\r\n      [key]: value\r\n    });\r\n  }, {});\r\n}\r\n\r\n/* iterates the stats graph recursively. */\r\nfunction walkStats(stats, base, resultSet) {\r\n  if (!base || resultSet.has(base.id)) {\r\n    return;\r\n  }\r\n  resultSet.set(base.id, base);\r\n  Object.keys(base).forEach(name => {\r\n    if (name.endsWith('Id')) {\r\n      walkStats(stats, stats.get(base[name]), resultSet);\r\n    } else if (name.endsWith('Ids')) {\r\n      base[name].forEach(id => {\r\n        walkStats(stats, stats.get(id), resultSet);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/* filter getStats for a sender/receiver track. */\r\nfunction filterStats(result, track, outbound) {\r\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\r\n  const filteredResult = new Map();\r\n  if (track === null) {\r\n    return filteredResult;\r\n  }\r\n  const trackStats = [];\r\n  result.forEach(value => {\r\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\r\n      trackStats.push(value);\r\n    }\r\n  });\r\n  trackStats.forEach(trackStat => {\r\n    result.forEach(stats => {\r\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\r\n        walkStats(result, stats, filteredResult);\r\n      }\r\n    });\r\n  });\r\n  return filteredResult;\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nconst logging = log;\r\nfunction shimGetUserMedia$2(window, browserDetails) {\r\n  const navigator = window && window.navigator;\r\n  if (!navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  const constraintsToChrome_ = function (c) {\r\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\r\n      return c;\r\n    }\r\n    const cc = {};\r\n    Object.keys(c).forEach(key => {\r\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\r\n        return;\r\n      }\r\n      const r = typeof c[key] === 'object' ? c[key] : {\r\n        ideal: c[key]\r\n      };\r\n      if (r.exact !== undefined && typeof r.exact === 'number') {\r\n        r.min = r.max = r.exact;\r\n      }\r\n      const oldname_ = function (prefix, name) {\r\n        if (prefix) {\r\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\r\n        }\r\n        return name === 'deviceId' ? 'sourceId' : name;\r\n      };\r\n      if (r.ideal !== undefined) {\r\n        cc.optional = cc.optional || [];\r\n        let oc = {};\r\n        if (typeof r.ideal === 'number') {\r\n          oc[oldname_('min', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n          oc = {};\r\n          oc[oldname_('max', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        } else {\r\n          oc[oldname_('', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        }\r\n      }\r\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\r\n        cc.mandatory = cc.mandatory || {};\r\n        cc.mandatory[oldname_('', key)] = r.exact;\r\n      } else {\r\n        ['min', 'max'].forEach(mix => {\r\n          if (r[mix] !== undefined) {\r\n            cc.mandatory = cc.mandatory || {};\r\n            cc.mandatory[oldname_(mix, key)] = r[mix];\r\n          }\r\n        });\r\n      }\r\n    });\r\n    if (c.advanced) {\r\n      cc.optional = (cc.optional || []).concat(c.advanced);\r\n    }\r\n    return cc;\r\n  };\r\n  const shimConstraints_ = function (constraints, func) {\r\n    if (browserDetails.version >= 61) {\r\n      return func(constraints);\r\n    }\r\n    constraints = JSON.parse(JSON.stringify(constraints));\r\n    if (constraints && typeof constraints.audio === 'object') {\r\n      const remap = function (obj, a, b) {\r\n        if (a in obj && !(b in obj)) {\r\n          obj[b] = obj[a];\r\n          delete obj[a];\r\n        }\r\n      };\r\n      constraints = JSON.parse(JSON.stringify(constraints));\r\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\r\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\r\n      constraints.audio = constraintsToChrome_(constraints.audio);\r\n    }\r\n    if (constraints && typeof constraints.video === 'object') {\r\n      // Shim facingMode for mobile & surface pro.\r\n      let face = constraints.video.facingMode;\r\n      face = face && (typeof face === 'object' ? face : {\r\n        ideal: face\r\n      });\r\n      const getSupportedFacingModeLies = browserDetails.version < 66;\r\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\r\n        delete constraints.video.facingMode;\r\n        let matches;\r\n        if (face.exact === 'environment' || face.ideal === 'environment') {\r\n          matches = ['back', 'rear'];\r\n        } else if (face.exact === 'user' || face.ideal === 'user') {\r\n          matches = ['front'];\r\n        }\r\n        if (matches) {\r\n          // Look for matches in label, or use last cam for back (typical).\r\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\r\n            devices = devices.filter(d => d.kind === 'videoinput');\r\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\r\n            if (!dev && devices.length && matches.includes('back')) {\r\n              dev = devices[devices.length - 1]; // more likely the back cam\r\n            }\r\n            if (dev) {\r\n              constraints.video.deviceId = face.exact ? {\r\n                exact: dev.deviceId\r\n              } : {\r\n                ideal: dev.deviceId\r\n              };\r\n            }\r\n            constraints.video = constraintsToChrome_(constraints.video);\r\n            logging('chrome: ' + JSON.stringify(constraints));\r\n            return func(constraints);\r\n          });\r\n        }\r\n      }\r\n      constraints.video = constraintsToChrome_(constraints.video);\r\n    }\r\n    logging('chrome: ' + JSON.stringify(constraints));\r\n    return func(constraints);\r\n  };\r\n  const shimError_ = function (e) {\r\n    if (browserDetails.version >= 64) {\r\n      return e;\r\n    }\r\n    return {\r\n      name: {\r\n        PermissionDeniedError: 'NotAllowedError',\r\n        PermissionDismissedError: 'NotAllowedError',\r\n        InvalidStateError: 'NotAllowedError',\r\n        DevicesNotFoundError: 'NotFoundError',\r\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\r\n        TrackStartError: 'NotReadableError',\r\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\r\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\r\n        TabCaptureError: 'AbortError',\r\n        ScreenCaptureError: 'AbortError',\r\n        DeviceCaptureError: 'AbortError'\r\n      }[e.name] || e.name,\r\n      message: e.message,\r\n      constraint: e.constraint || e.constraintName,\r\n      toString() {\r\n        return this.name + (this.message && ': ') + this.message;\r\n      }\r\n    };\r\n  };\r\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\r\n    shimConstraints_(constraints, c => {\r\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\r\n        if (onError) {\r\n          onError(shimError_(e));\r\n        }\r\n      });\r\n    });\r\n  };\r\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\r\n\r\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\r\n  // function which returns a Promise, it does not accept spec-style\r\n  // constraints.\r\n  if (navigator.mediaDevices.getUserMedia) {\r\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function (cs) {\r\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\r\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\r\n          stream.getTracks().forEach(track => {\r\n            track.stop();\r\n          });\r\n          throw new DOMException('', 'NotFoundError');\r\n        }\r\n        return stream;\r\n      }, e => Promise.reject(shimError_(e))));\r\n    };\r\n  }\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimMediaStream(window) {\r\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\r\n}\r\nfunction shimOnTrack$1(window) {\r\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\r\n      get() {\r\n        return this._ontrack;\r\n      },\r\n      set(f) {\r\n        if (this._ontrack) {\r\n          this.removeEventListener('track', this._ontrack);\r\n        }\r\n        this.addEventListener('track', this._ontrack = f);\r\n      },\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n      if (!this._ontrackpoly) {\r\n        this._ontrackpoly = e => {\r\n          // onaddstream does not fire when a track is added to an existing\r\n          // stream. But stream.onaddtrack is implemented so we use that.\r\n          e.stream.addEventListener('addtrack', te => {\r\n            let receiver;\r\n            if (window.RTCPeerConnection.prototype.getReceivers) {\r\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\r\n            } else {\r\n              receiver = {\r\n                track: te.track\r\n              };\r\n            }\r\n            const event = new Event('track');\r\n            event.track = te.track;\r\n            event.receiver = receiver;\r\n            event.transceiver = {\r\n              receiver\r\n            };\r\n            event.streams = [e.stream];\r\n            this.dispatchEvent(event);\r\n          });\r\n          e.stream.getTracks().forEach(track => {\r\n            let receiver;\r\n            if (window.RTCPeerConnection.prototype.getReceivers) {\r\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\r\n            } else {\r\n              receiver = {\r\n                track\r\n              };\r\n            }\r\n            const event = new Event('track');\r\n            event.track = track;\r\n            event.receiver = receiver;\r\n            event.transceiver = {\r\n              receiver\r\n            };\r\n            event.streams = [e.stream];\r\n            this.dispatchEvent(event);\r\n          });\r\n        };\r\n        this.addEventListener('addstream', this._ontrackpoly);\r\n      }\r\n      return origSetRemoteDescription.apply(this, arguments);\r\n    };\r\n  } else {\r\n    // even if RTCRtpTransceiver is in window, it is only used and\r\n    // emitted in unified-plan. Unfortunately this means we need\r\n    // to unconditionally wrap the event.\r\n    wrapPeerConnectionEvent(window, 'track', e => {\r\n      if (!e.transceiver) {\r\n        Object.defineProperty(e, 'transceiver', {\r\n          value: {\r\n            receiver: e.receiver\r\n          }\r\n        });\r\n      }\r\n      return e;\r\n    });\r\n  }\r\n}\r\nfunction shimGetSendersWithDtmf(window) {\r\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\r\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\r\n    const shimSenderWithDtmf = function (pc, track) {\r\n      return {\r\n        track,\r\n        get dtmf() {\r\n          if (this._dtmf === undefined) {\r\n            if (track.kind === 'audio') {\r\n              this._dtmf = pc.createDTMFSender(track);\r\n            } else {\r\n              this._dtmf = null;\r\n            }\r\n          }\r\n          return this._dtmf;\r\n        },\r\n        _pc: pc\r\n      };\r\n    };\r\n\r\n    // augment addTrack when getSenders is not available.\r\n    if (!window.RTCPeerConnection.prototype.getSenders) {\r\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n        this._senders = this._senders || [];\r\n        return this._senders.slice(); // return a copy of the internal state.\r\n      };\r\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n        let sender = origAddTrack.apply(this, arguments);\r\n        if (!sender) {\r\n          sender = shimSenderWithDtmf(this, track);\r\n          this._senders.push(sender);\r\n        }\r\n        return sender;\r\n      };\r\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\r\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n        origRemoveTrack.apply(this, arguments);\r\n        const idx = this._senders.indexOf(sender);\r\n        if (idx !== -1) {\r\n          this._senders.splice(idx, 1);\r\n        }\r\n      };\r\n    }\r\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n      this._senders = this._senders || [];\r\n      origAddStream.apply(this, [stream]);\r\n      stream.getTracks().forEach(track => {\r\n        this._senders.push(shimSenderWithDtmf(this, track));\r\n      });\r\n    };\r\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n      this._senders = this._senders || [];\r\n      origRemoveStream.apply(this, [stream]);\r\n      stream.getTracks().forEach(track => {\r\n        const sender = this._senders.find(s => s.track === track);\r\n        if (sender) {\r\n          // remove sender\r\n          this._senders.splice(this._senders.indexOf(sender), 1);\r\n        }\r\n      });\r\n    };\r\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\r\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n      const senders = origGetSenders.apply(this, []);\r\n      senders.forEach(sender => sender._pc = this);\r\n      return senders;\r\n    };\r\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\r\n      get() {\r\n        if (this._dtmf === undefined) {\r\n          if (this.track.kind === 'audio') {\r\n            this._dtmf = this._pc.createDTMFSender(this.track);\r\n          } else {\r\n            this._dtmf = null;\r\n          }\r\n        }\r\n        return this._dtmf;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimSenderReceiverGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\r\n    return;\r\n  }\r\n\r\n  // shim sender stats.\r\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\r\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n    if (origGetSenders) {\r\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n        const senders = origGetSenders.apply(this, []);\r\n        senders.forEach(sender => sender._pc = this);\r\n        return senders;\r\n      };\r\n    }\r\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n    if (origAddTrack) {\r\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\r\n        const sender = origAddTrack.apply(this, arguments);\r\n        sender._pc = this;\r\n        return sender;\r\n      };\r\n    }\r\n    window.RTCRtpSender.prototype.getStats = function getStats() {\r\n      const sender = this;\r\n      return this._pc.getStats().then(result =>\r\n      /* Note: this will include stats of all senders that\r\n       *   send a track with the same id as sender.track as\r\n       *   it is not possible to identify the RTCRtpSender.\r\n       */\r\n      filterStats(result, sender.track, true));\r\n    };\r\n  }\r\n\r\n  // shim receiver stats.\r\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\r\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\r\n    if (origGetReceivers) {\r\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\r\n        const receivers = origGetReceivers.apply(this, []);\r\n        receivers.forEach(receiver => receiver._pc = this);\r\n        return receivers;\r\n      };\r\n    }\r\n    wrapPeerConnectionEvent(window, 'track', e => {\r\n      e.receiver._pc = e.srcElement;\r\n      return e;\r\n    });\r\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\r\n      const receiver = this;\r\n      return this._pc.getStats().then(result => filterStats(result, receiver.track, false));\r\n    };\r\n  }\r\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\r\n    return;\r\n  }\r\n\r\n  // shim RTCPeerConnection.getStats(track).\r\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\r\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\r\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\r\n      const track = arguments[0];\r\n      let sender;\r\n      let receiver;\r\n      let err;\r\n      this.getSenders().forEach(s => {\r\n        if (s.track === track) {\r\n          if (sender) {\r\n            err = true;\r\n          } else {\r\n            sender = s;\r\n          }\r\n        }\r\n      });\r\n      this.getReceivers().forEach(r => {\r\n        if (r.track === track) {\r\n          if (receiver) {\r\n            err = true;\r\n          } else {\r\n            receiver = r;\r\n          }\r\n        }\r\n        return r.track === track;\r\n      });\r\n      if (err || sender && receiver) {\r\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\r\n      } else if (sender) {\r\n        return sender.getStats();\r\n      } else if (receiver) {\r\n        return receiver.getStats();\r\n      }\r\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\r\n    }\r\n    return origGetStats.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddTrackRemoveTrackWithNative(window) {\r\n  // shim addTrack/removeTrack with native variants in order to make\r\n  // the interactions with legacy getLocalStreams behave as in other browsers.\r\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\r\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\r\n  };\r\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n    if (!stream) {\r\n      return origAddTrack.apply(this, arguments);\r\n    }\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    const sender = origAddTrack.apply(this, arguments);\r\n    if (!this._shimmedLocalStreams[stream.id]) {\r\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\r\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\r\n      this._shimmedLocalStreams[stream.id].push(sender);\r\n    }\r\n    return sender;\r\n  };\r\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    stream.getTracks().forEach(track => {\r\n      const alreadyExists = this.getSenders().find(s => s.track === track);\r\n      if (alreadyExists) {\r\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n      }\r\n    });\r\n    const existingSenders = this.getSenders();\r\n    origAddStream.apply(this, arguments);\r\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\r\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\r\n  };\r\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    delete this._shimmedLocalStreams[stream.id];\r\n    return origRemoveStream.apply(this, arguments);\r\n  };\r\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\r\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    if (sender) {\r\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\r\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\r\n        if (idx !== -1) {\r\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\r\n        }\r\n        if (this._shimmedLocalStreams[streamId].length === 1) {\r\n          delete this._shimmedLocalStreams[streamId];\r\n        }\r\n      });\r\n    }\r\n    return origRemoveTrack.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  // shim addTrack and removeTrack.\r\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\r\n    return shimAddTrackRemoveTrackWithNative(window);\r\n  }\r\n\r\n  // also shim pc.getLocalStreams when addTrack is shimmed\r\n  // to return the original streams.\r\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\r\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n    const nativeStreams = origGetLocalStreams.apply(this);\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\r\n  };\r\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    stream.getTracks().forEach(track => {\r\n      const alreadyExists = this.getSenders().find(s => s.track === track);\r\n      if (alreadyExists) {\r\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n      }\r\n    });\r\n    // Add identity mapping for consistency with addTrack.\r\n    // Unless this is being used with a stream from addTrack.\r\n    if (!this._reverseStreams[stream.id]) {\r\n      const newStream = new window.MediaStream(stream.getTracks());\r\n      this._streams[stream.id] = newStream;\r\n      this._reverseStreams[newStream.id] = stream;\r\n      stream = newStream;\r\n    }\r\n    origAddStream.apply(this, [stream]);\r\n  };\r\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\r\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\r\n    delete this._streams[stream.id];\r\n  };\r\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n    if (this.signalingState === 'closed') {\r\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\r\n    }\r\n    const streams = [].slice.call(arguments, 1);\r\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\r\n      // this is not fully correct but all we can manage without\r\n      // [[associated MediaStreams]] internal slot.\r\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\r\n    }\r\n    const alreadyExists = this.getSenders().find(s => s.track === track);\r\n    if (alreadyExists) {\r\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n    }\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    const oldStream = this._streams[stream.id];\r\n    if (oldStream) {\r\n      // this is using odd Chrome behaviour, use with caution:\r\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\r\n      // Note: we rely on the high-level addTrack/dtmf shim to\r\n      // create the sender with a dtmf sender.\r\n      oldStream.addTrack(track);\r\n\r\n      // Trigger ONN async.\r\n      Promise.resolve().then(() => {\r\n        this.dispatchEvent(new Event('negotiationneeded'));\r\n      });\r\n    } else {\r\n      const newStream = new window.MediaStream([track]);\r\n      this._streams[stream.id] = newStream;\r\n      this._reverseStreams[newStream.id] = stream;\r\n      this.addStream(newStream);\r\n    }\r\n    return this.getSenders().find(s => s.track === track);\r\n  };\r\n\r\n  // replace the internal stream id with the external one and\r\n  // vice versa.\r\n  function replaceInternalStreamId(pc, description) {\r\n    let sdp = description.sdp;\r\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\r\n      const externalStream = pc._reverseStreams[internalId];\r\n      const internalStream = pc._streams[externalStream.id];\r\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\r\n    });\r\n    return new RTCSessionDescription({\r\n      type: description.type,\r\n      sdp\r\n    });\r\n  }\r\n  function replaceExternalStreamId(pc, description) {\r\n    let sdp = description.sdp;\r\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\r\n      const externalStream = pc._reverseStreams[internalId];\r\n      const internalStream = pc._streams[externalStream.id];\r\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\r\n    });\r\n    return new RTCSessionDescription({\r\n      type: description.type,\r\n      sdp\r\n    });\r\n  }\r\n  ['createOffer', 'createAnswer'].forEach(function (method) {\r\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n    const methodObj = {\r\n      [method]() {\r\n        const args = arguments;\r\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\r\n        if (isLegacyCall) {\r\n          return nativeMethod.apply(this, [description => {\r\n            const desc = replaceInternalStreamId(this, description);\r\n            args[0].apply(null, [desc]);\r\n          }, err => {\r\n            if (args[1]) {\r\n              args[1].apply(null, err);\r\n            }\r\n          }, arguments[2]]);\r\n        }\r\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\r\n      }\r\n    };\r\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n  });\r\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\r\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\r\n    if (!arguments.length || !arguments[0].type) {\r\n      return origSetLocalDescription.apply(this, arguments);\r\n    }\r\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\r\n    return origSetLocalDescription.apply(this, arguments);\r\n  };\r\n\r\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\r\n\r\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\r\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\r\n    get() {\r\n      const description = origLocalDescription.get.apply(this);\r\n      if (description.type === '') {\r\n        return description;\r\n      }\r\n      return replaceInternalStreamId(this, description);\r\n    }\r\n  });\r\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n    if (this.signalingState === 'closed') {\r\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\r\n    }\r\n    // We can not yet check for sender instanceof RTCRtpSender\r\n    // since we shim RTPSender. So we check if sender._pc is set.\r\n    if (!sender._pc) {\r\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\r\n    }\r\n    const isLocal = sender._pc === this;\r\n    if (!isLocal) {\r\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\r\n    }\r\n\r\n    // Search for the native stream the senders track belongs to.\r\n    this._streams = this._streams || {};\r\n    let stream;\r\n    Object.keys(this._streams).forEach(streamid => {\r\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\r\n      if (hasTrack) {\r\n        stream = this._streams[streamid];\r\n      }\r\n    });\r\n    if (stream) {\r\n      if (stream.getTracks().length === 1) {\r\n        // if this is the last track of the stream, remove the stream. This\r\n        // takes care of any shimmed _senders.\r\n        this.removeStream(this._reverseStreams[stream.id]);\r\n      } else {\r\n        // relying on the same odd chrome behaviour as above.\r\n        stream.removeTrack(sender.track);\r\n      }\r\n      this.dispatchEvent(new Event('negotiationneeded'));\r\n    }\r\n  };\r\n}\r\nfunction shimPeerConnection$1(window, browserDetails) {\r\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\r\n    // very basic support for old versions.\r\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\r\n  }\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n\r\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\r\n  if (browserDetails.version < 53) {\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\r\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n      const methodObj = {\r\n        [method]() {\r\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\r\n          return nativeMethod.apply(this, arguments);\r\n        }\r\n      };\r\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n    });\r\n  }\r\n}\r\n\r\n// Attempt to fix ONN in plan-b mode.\r\nfunction fixNegotiationNeeded(window, browserDetails) {\r\n  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\r\n    const pc = e.target;\r\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\r\n      if (pc.signalingState !== 'stable') {\r\n        return;\r\n      }\r\n    }\r\n    return e;\r\n  });\r\n}\r\n\r\nvar chromeShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  fixNegotiationNeeded: fixNegotiationNeeded,\r\n  shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\r\n  shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\r\n  shimGetSendersWithDtmf: shimGetSendersWithDtmf,\r\n  shimGetUserMedia: shimGetUserMedia$2,\r\n  shimMediaStream: shimMediaStream,\r\n  shimOnTrack: shimOnTrack$1,\r\n  shimPeerConnection: shimPeerConnection$1,\r\n  shimSenderReceiverGetStats: shimSenderReceiverGetStats\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimGetUserMedia$1(window, browserDetails) {\r\n  const navigator = window && window.navigator;\r\n  const MediaStreamTrack = window && window.MediaStreamTrack;\r\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\r\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\r\n    deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\r\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\r\n  };\r\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\r\n    const remap = function (obj, a, b) {\r\n      if (a in obj && !(b in obj)) {\r\n        obj[b] = obj[a];\r\n        delete obj[a];\r\n      }\r\n    };\r\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function (c) {\r\n      if (typeof c === 'object' && typeof c.audio === 'object') {\r\n        c = JSON.parse(JSON.stringify(c));\r\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\r\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\r\n      }\r\n      return nativeGetUserMedia(c);\r\n    };\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\r\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\r\n      MediaStreamTrack.prototype.getSettings = function () {\r\n        const obj = nativeGetSettings.apply(this, arguments);\r\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\r\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\r\n        return obj;\r\n      };\r\n    }\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\r\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\r\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\r\n        if (this.kind === 'audio' && typeof c === 'object') {\r\n          c = JSON.parse(JSON.stringify(c));\r\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\r\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\r\n        }\r\n        return nativeApplyConstraints.apply(this, [c]);\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\r\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  if (!window.navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\r\n    if (!(constraints && constraints.video)) {\r\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\r\n      err.name = 'NotFoundError';\r\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\r\n      err.code = 8;\r\n      return Promise.reject(err);\r\n    }\r\n    if (constraints.video === true) {\r\n      constraints.video = {\r\n        mediaSource: preferredMediaSource\r\n      };\r\n    } else {\r\n      constraints.video.mediaSource = preferredMediaSource;\r\n    }\r\n    return window.navigator.mediaDevices.getUserMedia(constraints);\r\n  };\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimOnTrack(window) {\r\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\r\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n      get() {\r\n        return {\r\n          receiver: this.receiver\r\n        };\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimPeerConnection(window, browserDetails) {\r\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\r\n    return; // probably media.peerconnection.enabled=false in about:config\r\n  }\r\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\r\n    // very basic support for old versions.\r\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\r\n  }\r\n  if (browserDetails.version < 53) {\r\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\r\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n      const methodObj = {\r\n        [method]() {\r\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\r\n          return nativeMethod.apply(this, arguments);\r\n        }\r\n      };\r\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n    });\r\n  }\r\n  const modernStatsTypes = {\r\n    inboundrtp: 'inbound-rtp',\r\n    outboundrtp: 'outbound-rtp',\r\n    candidatepair: 'candidate-pair',\r\n    localcandidate: 'local-candidate',\r\n    remotecandidate: 'remote-candidate'\r\n  };\r\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\r\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\r\n    const [selector, onSucc, onErr] = arguments;\r\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\r\n      if (browserDetails.version < 53 && !onSucc) {\r\n        // Shim only promise getStats with spec-hyphens in type names\r\n        // Leave callback version alone; misc old uses of forEach before Map\r\n        try {\r\n          stats.forEach(stat => {\r\n            stat.type = modernStatsTypes[stat.type] || stat.type;\r\n          });\r\n        } catch (e) {\r\n          if (e.name !== 'TypeError') {\r\n            throw e;\r\n          }\r\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\r\n          stats.forEach((stat, i) => {\r\n            stats.set(i, Object.assign({}, stat, {\r\n              type: modernStatsTypes[stat.type] || stat.type\r\n            }));\r\n          });\r\n        }\r\n      }\r\n      return stats;\r\n    }).then(onSucc, onErr);\r\n  };\r\n}\r\nfunction shimSenderGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\r\n    return;\r\n  }\r\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n  if (origGetSenders) {\r\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n      const senders = origGetSenders.apply(this, []);\r\n      senders.forEach(sender => sender._pc = this);\r\n      return senders;\r\n    };\r\n  }\r\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n  if (origAddTrack) {\r\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\r\n      const sender = origAddTrack.apply(this, arguments);\r\n      sender._pc = this;\r\n      return sender;\r\n    };\r\n  }\r\n  window.RTCRtpSender.prototype.getStats = function getStats() {\r\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\r\n  };\r\n}\r\nfunction shimReceiverGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\r\n    return;\r\n  }\r\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\r\n  if (origGetReceivers) {\r\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\r\n      const receivers = origGetReceivers.apply(this, []);\r\n      receivers.forEach(receiver => receiver._pc = this);\r\n      return receivers;\r\n    };\r\n  }\r\n  wrapPeerConnectionEvent(window, 'track', e => {\r\n    e.receiver._pc = e.srcElement;\r\n    return e;\r\n  });\r\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\r\n    return this._pc.getStats(this.track);\r\n  };\r\n}\r\nfunction shimRemoveStream(window) {\r\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    deprecated('removeStream', 'removeTrack');\r\n    this.getSenders().forEach(sender => {\r\n      if (sender.track && stream.getTracks().includes(sender.track)) {\r\n        this.removeTrack(sender);\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction shimRTCDataChannel(window) {\r\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\r\n  if (window.DataChannel && !window.RTCDataChannel) {\r\n    window.RTCDataChannel = window.DataChannel;\r\n  }\r\n}\r\nfunction shimAddTransceiver(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\r\n  if (origAddTransceiver) {\r\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\r\n      this.setParametersPromises = [];\r\n      // WebIDL input coercion and validation\r\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\r\n      if (sendEncodings === undefined) {\r\n        sendEncodings = [];\r\n      }\r\n      sendEncodings = [...sendEncodings];\r\n      const shouldPerformCheck = sendEncodings.length > 0;\r\n      if (shouldPerformCheck) {\r\n        // If sendEncodings params are provided, validate grammar\r\n        sendEncodings.forEach(encodingParam => {\r\n          if ('rid' in encodingParam) {\r\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\r\n            if (!ridRegex.test(encodingParam.rid)) {\r\n              throw new TypeError('Invalid RID value provided.');\r\n            }\r\n          }\r\n          if ('scaleResolutionDownBy' in encodingParam) {\r\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\r\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\r\n            }\r\n          }\r\n          if ('maxFramerate' in encodingParam) {\r\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\r\n              throw new RangeError('max_framerate must be >= 0.0');\r\n            }\r\n          }\r\n        });\r\n      }\r\n      const transceiver = origAddTransceiver.apply(this, arguments);\r\n      if (shouldPerformCheck) {\r\n        // Check if the init options were applied. If not we do this in an\r\n        // asynchronous way and save the promise reference in a global object.\r\n        // This is an ugly hack, but at the same time is way more robust than\r\n        // checking the sender parameters before and after the createOffer\r\n        // Also note that after the createoffer we are not 100% sure that\r\n        // the params were asynchronously applied so we might miss the\r\n        // opportunity to recreate offer.\r\n        const {\r\n          sender\r\n        } = transceiver;\r\n        const params = sender.getParameters();\r\n        if (!('encodings' in params) ||\r\n        // Avoid being fooled by patched getParameters() below.\r\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\r\n          params.encodings = sendEncodings;\r\n          sender.sendEncodings = sendEncodings;\r\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\r\n            delete sender.sendEncodings;\r\n          }).catch(() => {\r\n            delete sender.sendEncodings;\r\n          }));\r\n        }\r\n      }\r\n      return transceiver;\r\n    };\r\n  }\r\n}\r\nfunction shimGetParameters(window) {\r\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\r\n  if (origGetParameters) {\r\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\r\n      const params = origGetParameters.apply(this, arguments);\r\n      if (!('encodings' in params)) {\r\n        params.encodings = [].concat(this.sendEncodings || [{}]);\r\n      }\r\n      return params;\r\n    };\r\n  }\r\n}\r\nfunction shimCreateOffer(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\r\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\r\n    if (this.setParametersPromises && this.setParametersPromises.length) {\r\n      return Promise.all(this.setParametersPromises).then(() => {\r\n        return origCreateOffer.apply(this, arguments);\r\n      }).finally(() => {\r\n        this.setParametersPromises = [];\r\n      });\r\n    }\r\n    return origCreateOffer.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimCreateAnswer(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\r\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\r\n    if (this.setParametersPromises && this.setParametersPromises.length) {\r\n      return Promise.all(this.setParametersPromises).then(() => {\r\n        return origCreateAnswer.apply(this, arguments);\r\n      }).finally(() => {\r\n        this.setParametersPromises = [];\r\n      });\r\n    }\r\n    return origCreateAnswer.apply(this, arguments);\r\n  };\r\n}\r\n\r\nvar firefoxShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  shimAddTransceiver: shimAddTransceiver,\r\n  shimCreateAnswer: shimCreateAnswer,\r\n  shimCreateOffer: shimCreateOffer,\r\n  shimGetDisplayMedia: shimGetDisplayMedia,\r\n  shimGetParameters: shimGetParameters,\r\n  shimGetUserMedia: shimGetUserMedia$1,\r\n  shimOnTrack: shimOnTrack,\r\n  shimPeerConnection: shimPeerConnection,\r\n  shimRTCDataChannel: shimRTCDataChannel,\r\n  shimReceiverGetStats: shimReceiverGetStats,\r\n  shimRemoveStream: shimRemoveStream,\r\n  shimSenderGetStats: shimSenderGetStats\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\nfunction shimLocalStreamsAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      return this._localStreams;\r\n    };\r\n  }\r\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\r\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\r\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      if (!this._localStreams.includes(stream)) {\r\n        this._localStreams.push(stream);\r\n      }\r\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\r\n      // Safari orders by track id.\r\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\r\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\r\n    };\r\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\r\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n        streams[_key - 1] = arguments[_key];\r\n      }\r\n      if (streams) {\r\n        streams.forEach(stream => {\r\n          if (!this._localStreams) {\r\n            this._localStreams = [stream];\r\n          } else if (!this._localStreams.includes(stream)) {\r\n            this._localStreams.push(stream);\r\n          }\r\n        });\r\n      }\r\n      return _addTrack.apply(this, arguments);\r\n    };\r\n  }\r\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      const index = this._localStreams.indexOf(stream);\r\n      if (index === -1) {\r\n        return;\r\n      }\r\n      this._localStreams.splice(index, 1);\r\n      const tracks = stream.getTracks();\r\n      this.getSenders().forEach(sender => {\r\n        if (tracks.includes(sender.track)) {\r\n          this.removeTrack(sender);\r\n        }\r\n      });\r\n    };\r\n  }\r\n}\r\nfunction shimRemoteStreamsAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\r\n      return this._remoteStreams ? this._remoteStreams : [];\r\n    };\r\n  }\r\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\r\n      get() {\r\n        return this._onaddstream;\r\n      },\r\n      set(f) {\r\n        if (this._onaddstream) {\r\n          this.removeEventListener('addstream', this._onaddstream);\r\n          this.removeEventListener('track', this._onaddstreampoly);\r\n        }\r\n        this.addEventListener('addstream', this._onaddstream = f);\r\n        this.addEventListener('track', this._onaddstreampoly = e => {\r\n          e.streams.forEach(stream => {\r\n            if (!this._remoteStreams) {\r\n              this._remoteStreams = [];\r\n            }\r\n            if (this._remoteStreams.includes(stream)) {\r\n              return;\r\n            }\r\n            this._remoteStreams.push(stream);\r\n            const event = new Event('addstream');\r\n            event.stream = stream;\r\n            this.dispatchEvent(event);\r\n          });\r\n        });\r\n      }\r\n    });\r\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n      const pc = this;\r\n      if (!this._onaddstreampoly) {\r\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\r\n          e.streams.forEach(stream => {\r\n            if (!pc._remoteStreams) {\r\n              pc._remoteStreams = [];\r\n            }\r\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\r\n              return;\r\n            }\r\n            pc._remoteStreams.push(stream);\r\n            const event = new Event('addstream');\r\n            event.stream = stream;\r\n            pc.dispatchEvent(event);\r\n          });\r\n        });\r\n      }\r\n      return origSetRemoteDescription.apply(pc, arguments);\r\n    };\r\n  }\r\n}\r\nfunction shimCallbacksAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  const prototype = window.RTCPeerConnection.prototype;\r\n  const origCreateOffer = prototype.createOffer;\r\n  const origCreateAnswer = prototype.createAnswer;\r\n  const setLocalDescription = prototype.setLocalDescription;\r\n  const setRemoteDescription = prototype.setRemoteDescription;\r\n  const addIceCandidate = prototype.addIceCandidate;\r\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\r\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\r\n    const promise = origCreateOffer.apply(this, [options]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\r\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\r\n    const promise = origCreateAnswer.apply(this, [options]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  let withCallback = function (description, successCallback, failureCallback) {\r\n    const promise = setLocalDescription.apply(this, [description]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.setLocalDescription = withCallback;\r\n  withCallback = function (description, successCallback, failureCallback) {\r\n    const promise = setRemoteDescription.apply(this, [description]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.setRemoteDescription = withCallback;\r\n  withCallback = function (candidate, successCallback, failureCallback) {\r\n    const promise = addIceCandidate.apply(this, [candidate]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.addIceCandidate = withCallback;\r\n}\r\nfunction shimGetUserMedia(window) {\r\n  const navigator = window && window.navigator;\r\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n    // shim not needed in Safari 12.1\r\n    const mediaDevices = navigator.mediaDevices;\r\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = constraints => {\r\n      return _getUserMedia(shimConstraints(constraints));\r\n    };\r\n  }\r\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\r\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\r\n    }.bind(navigator);\r\n  }\r\n}\r\nfunction shimConstraints(constraints) {\r\n  if (constraints && constraints.video !== undefined) {\r\n    return Object.assign({}, constraints, {\r\n      video: compactObject(constraints.video)\r\n    });\r\n  }\r\n  return constraints;\r\n}\r\nfunction shimRTCIceServerUrls(window) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\r\n  const OrigPeerConnection = window.RTCPeerConnection;\r\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\r\n    if (pcConfig && pcConfig.iceServers) {\r\n      const newIceServers = [];\r\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\r\n        let server = pcConfig.iceServers[i];\r\n        if (server.urls === undefined && server.url) {\r\n          deprecated('RTCIceServer.url', 'RTCIceServer.urls');\r\n          server = JSON.parse(JSON.stringify(server));\r\n          server.urls = server.url;\r\n          delete server.url;\r\n          newIceServers.push(server);\r\n        } else {\r\n          newIceServers.push(pcConfig.iceServers[i]);\r\n        }\r\n      }\r\n      pcConfig.iceServers = newIceServers;\r\n    }\r\n    return new OrigPeerConnection(pcConfig, pcConstraints);\r\n  };\r\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\r\n  // wrap static methods. Currently just generateCertificate.\r\n  if ('generateCertificate' in OrigPeerConnection) {\r\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n      get() {\r\n        return OrigPeerConnection.generateCertificate;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimTrackEventTransceiver(window) {\r\n  // Add event.transceiver member over deprecated event.receiver\r\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\r\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n      get() {\r\n        return {\r\n          receiver: this.receiver\r\n        };\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimCreateOfferLegacy(window) {\r\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\r\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\r\n    if (offerOptions) {\r\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\r\n        // support bit values\r\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\r\n      }\r\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\r\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\r\n        if (audioTransceiver.direction === 'sendrecv') {\r\n          if (audioTransceiver.setDirection) {\r\n            audioTransceiver.setDirection('sendonly');\r\n          } else {\r\n            audioTransceiver.direction = 'sendonly';\r\n          }\r\n        } else if (audioTransceiver.direction === 'recvonly') {\r\n          if (audioTransceiver.setDirection) {\r\n            audioTransceiver.setDirection('inactive');\r\n          } else {\r\n            audioTransceiver.direction = 'inactive';\r\n          }\r\n        }\r\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\r\n        this.addTransceiver('audio', {\r\n          direction: 'recvonly'\r\n        });\r\n      }\r\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\r\n        // support bit values\r\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\r\n      }\r\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\r\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\r\n        if (videoTransceiver.direction === 'sendrecv') {\r\n          if (videoTransceiver.setDirection) {\r\n            videoTransceiver.setDirection('sendonly');\r\n          } else {\r\n            videoTransceiver.direction = 'sendonly';\r\n          }\r\n        } else if (videoTransceiver.direction === 'recvonly') {\r\n          if (videoTransceiver.setDirection) {\r\n            videoTransceiver.setDirection('inactive');\r\n          } else {\r\n            videoTransceiver.direction = 'inactive';\r\n          }\r\n        }\r\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\r\n        this.addTransceiver('video', {\r\n          direction: 'recvonly'\r\n        });\r\n      }\r\n    }\r\n    return origCreateOffer.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAudioContext(window) {\r\n  if (typeof window !== 'object' || window.AudioContext) {\r\n    return;\r\n  }\r\n  window.AudioContext = window.webkitAudioContext;\r\n}\r\n\r\nvar safariShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  shimAudioContext: shimAudioContext,\r\n  shimCallbacksAPI: shimCallbacksAPI,\r\n  shimConstraints: shimConstraints,\r\n  shimCreateOfferLegacy: shimCreateOfferLegacy,\r\n  shimGetUserMedia: shimGetUserMedia,\r\n  shimLocalStreamsAPI: shimLocalStreamsAPI,\r\n  shimRTCIceServerUrls: shimRTCIceServerUrls,\r\n  shimRemoteStreamsAPI: shimRemoteStreamsAPI,\r\n  shimTrackEventTransceiver: shimTrackEventTransceiver\r\n});\r\n\r\nvar sdp$1 = {exports: {}};\r\n\r\n/* eslint-env node */\r\nvar hasRequiredSdp;\r\nfunction requireSdp() {\r\n  if (hasRequiredSdp) return sdp$1.exports;\r\n  hasRequiredSdp = 1;\r\n  (function (module) {\r\n\r\n    // SDP helpers.\r\n    const SDPUtils = {};\r\n\r\n    // Generate an alphanumeric identifier for cname or mids.\r\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\r\n    SDPUtils.generateIdentifier = function () {\r\n      return Math.random().toString(36).substring(2, 12);\r\n    };\r\n\r\n    // The RTCP CNAME used by all peerconnections from the same JS.\r\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\r\n\r\n    // Splits SDP into lines, dealing with both CRLF and LF.\r\n    SDPUtils.splitLines = function (blob) {\r\n      return blob.trim().split('\\n').map(line => line.trim());\r\n    };\r\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\r\n    SDPUtils.splitSections = function (blob) {\r\n      const parts = blob.split('\\nm=');\r\n      return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\r\n    };\r\n\r\n    // Returns the session description.\r\n    SDPUtils.getDescription = function (blob) {\r\n      const sections = SDPUtils.splitSections(blob);\r\n      return sections && sections[0];\r\n    };\r\n\r\n    // Returns the individual media sections.\r\n    SDPUtils.getMediaSections = function (blob) {\r\n      const sections = SDPUtils.splitSections(blob);\r\n      sections.shift();\r\n      return sections;\r\n    };\r\n\r\n    // Returns lines that start with a certain prefix.\r\n    SDPUtils.matchPrefix = function (blob, prefix) {\r\n      return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\r\n    };\r\n\r\n    // Parses an ICE candidate line. Sample input:\r\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\r\n    // rport 55996\"\r\n    // Input can be prefixed with a=.\r\n    SDPUtils.parseCandidate = function (line) {\r\n      let parts;\r\n      // Parse both variants.\r\n      if (line.indexOf('a=candidate:') === 0) {\r\n        parts = line.substring(12).split(' ');\r\n      } else {\r\n        parts = line.substring(10).split(' ');\r\n      }\r\n      const candidate = {\r\n        foundation: parts[0],\r\n        component: {\r\n          1: 'rtp',\r\n          2: 'rtcp'\r\n        }[parts[1]] || parts[1],\r\n        protocol: parts[2].toLowerCase(),\r\n        priority: parseInt(parts[3], 10),\r\n        ip: parts[4],\r\n        address: parts[4],\r\n        // address is an alias for ip.\r\n        port: parseInt(parts[5], 10),\r\n        // skip parts[6] == 'typ'\r\n        type: parts[7]\r\n      };\r\n      for (let i = 8; i < parts.length; i += 2) {\r\n        switch (parts[i]) {\r\n          case 'raddr':\r\n            candidate.relatedAddress = parts[i + 1];\r\n            break;\r\n          case 'rport':\r\n            candidate.relatedPort = parseInt(parts[i + 1], 10);\r\n            break;\r\n          case 'tcptype':\r\n            candidate.tcpType = parts[i + 1];\r\n            break;\r\n          case 'ufrag':\r\n            candidate.ufrag = parts[i + 1]; // for backward compatibility.\r\n            candidate.usernameFragment = parts[i + 1];\r\n            break;\r\n          default:\r\n            // extension handling, in particular ufrag. Don't overwrite.\r\n            if (candidate[parts[i]] === undefined) {\r\n              candidate[parts[i]] = parts[i + 1];\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      return candidate;\r\n    };\r\n\r\n    // Translates a candidate object into SDP candidate attribute.\r\n    // This does not include the a= prefix!\r\n    SDPUtils.writeCandidate = function (candidate) {\r\n      const sdp = [];\r\n      sdp.push(candidate.foundation);\r\n      const component = candidate.component;\r\n      if (component === 'rtp') {\r\n        sdp.push(1);\r\n      } else if (component === 'rtcp') {\r\n        sdp.push(2);\r\n      } else {\r\n        sdp.push(component);\r\n      }\r\n      sdp.push(candidate.protocol.toUpperCase());\r\n      sdp.push(candidate.priority);\r\n      sdp.push(candidate.address || candidate.ip);\r\n      sdp.push(candidate.port);\r\n      const type = candidate.type;\r\n      sdp.push('typ');\r\n      sdp.push(type);\r\n      if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\r\n        sdp.push('raddr');\r\n        sdp.push(candidate.relatedAddress);\r\n        sdp.push('rport');\r\n        sdp.push(candidate.relatedPort);\r\n      }\r\n      if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\r\n        sdp.push('tcptype');\r\n        sdp.push(candidate.tcpType);\r\n      }\r\n      if (candidate.usernameFragment || candidate.ufrag) {\r\n        sdp.push('ufrag');\r\n        sdp.push(candidate.usernameFragment || candidate.ufrag);\r\n      }\r\n      return 'candidate:' + sdp.join(' ');\r\n    };\r\n\r\n    // Parses an ice-options line, returns an array of option tags.\r\n    // Sample input:\r\n    // a=ice-options:foo bar\r\n    SDPUtils.parseIceOptions = function (line) {\r\n      return line.substring(14).split(' ');\r\n    };\r\n\r\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\r\n    // a=rtpmap:111 opus/48000/2\r\n    SDPUtils.parseRtpMap = function (line) {\r\n      let parts = line.substring(9).split(' ');\r\n      const parsed = {\r\n        payloadType: parseInt(parts.shift(), 10) // was: id\r\n      };\r\n      parts = parts[0].split('/');\r\n      parsed.name = parts[0];\r\n      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\r\n      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\r\n      // legacy alias, got renamed back to channels in ORTC.\r\n      parsed.numChannels = parsed.channels;\r\n      return parsed;\r\n    };\r\n\r\n    // Generates a rtpmap line from RTCRtpCodecCapability or\r\n    // RTCRtpCodecParameters.\r\n    SDPUtils.writeRtpMap = function (codec) {\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      const channels = codec.channels || codec.numChannels || 1;\r\n      return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\r\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\r\n    SDPUtils.parseExtmap = function (line) {\r\n      const parts = line.substring(9).split(' ');\r\n      return {\r\n        id: parseInt(parts[0], 10),\r\n        direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\r\n        uri: parts[1],\r\n        attributes: parts.slice(2).join(' ')\r\n      };\r\n    };\r\n\r\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\r\n    // RTCRtpHeaderExtension.\r\n    SDPUtils.writeExtmap = function (headerExtension) {\r\n      return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses a fmtp line, returns dictionary. Sample input:\r\n    // a=fmtp:96 vbr=on;cng=on\r\n    // Also deals with vbr=on; cng=on\r\n    SDPUtils.parseFmtp = function (line) {\r\n      const parsed = {};\r\n      let kv;\r\n      const parts = line.substring(line.indexOf(' ') + 1).split(';');\r\n      for (let j = 0; j < parts.length; j++) {\r\n        kv = parts[j].trim().split('=');\r\n        parsed[kv[0].trim()] = kv[1];\r\n      }\r\n      return parsed;\r\n    };\r\n\r\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\r\n    SDPUtils.writeFmtp = function (codec) {\r\n      let line = '';\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      if (codec.parameters && Object.keys(codec.parameters).length) {\r\n        const params = [];\r\n        Object.keys(codec.parameters).forEach(param => {\r\n          if (codec.parameters[param] !== undefined) {\r\n            params.push(param + '=' + codec.parameters[param]);\r\n          } else {\r\n            params.push(param);\r\n          }\r\n        });\r\n        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\r\n      }\r\n      return line;\r\n    };\r\n\r\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\r\n    // a=rtcp-fb:98 nack rpsi\r\n    SDPUtils.parseRtcpFb = function (line) {\r\n      const parts = line.substring(line.indexOf(' ') + 1).split(' ');\r\n      return {\r\n        type: parts.shift(),\r\n        parameter: parts.join(' ')\r\n      };\r\n    };\r\n\r\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\r\n    SDPUtils.writeRtcpFb = function (codec) {\r\n      let lines = '';\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\r\n        // FIXME: special handling for trr-int?\r\n        codec.rtcpFeedback.forEach(fb => {\r\n          lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\r\n        });\r\n      }\r\n      return lines;\r\n    };\r\n\r\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\r\n    // a=ssrc:3735928559 cname:something\r\n    SDPUtils.parseSsrcMedia = function (line) {\r\n      const sp = line.indexOf(' ');\r\n      const parts = {\r\n        ssrc: parseInt(line.substring(7, sp), 10)\r\n      };\r\n      const colon = line.indexOf(':', sp);\r\n      if (colon > -1) {\r\n        parts.attribute = line.substring(sp + 1, colon);\r\n        parts.value = line.substring(colon + 1);\r\n      } else {\r\n        parts.attribute = line.substring(sp + 1);\r\n      }\r\n      return parts;\r\n    };\r\n\r\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\r\n    // a=ssrc-group:semantics 12 34\r\n    SDPUtils.parseSsrcGroup = function (line) {\r\n      const parts = line.substring(13).split(' ');\r\n      return {\r\n        semantics: parts.shift(),\r\n        ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\r\n      };\r\n    };\r\n\r\n    // Extracts the MID (RFC 5888) from a media section.\r\n    // Returns the MID or undefined if no mid line was found.\r\n    SDPUtils.getMid = function (mediaSection) {\r\n      const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\r\n      if (mid) {\r\n        return mid.substring(6);\r\n      }\r\n    };\r\n\r\n    // Parses a fingerprint line for DTLS-SRTP.\r\n    SDPUtils.parseFingerprint = function (line) {\r\n      const parts = line.substring(14).split(' ');\r\n      return {\r\n        algorithm: parts[0].toLowerCase(),\r\n        // algorithm is case-sensitive in Edge.\r\n        value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\r\n      };\r\n    };\r\n\r\n    // Extracts DTLS parameters from SDP media section or sessionpart.\r\n    // FIXME: for consistency with other functions this should only\r\n    //   get the fingerprint line as input. See also getIceParameters.\r\n    SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\r\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\r\n      // Note: a=setup line is ignored since we use the 'auto' role in Edge.\r\n      return {\r\n        role: 'auto',\r\n        fingerprints: lines.map(SDPUtils.parseFingerprint)\r\n      };\r\n    };\r\n\r\n    // Serializes DTLS parameters to SDP.\r\n    SDPUtils.writeDtlsParameters = function (params, setupType) {\r\n      let sdp = 'a=setup:' + setupType + '\\r\\n';\r\n      params.fingerprints.forEach(fp => {\r\n        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\r\n      });\r\n      return sdp;\r\n    };\r\n\r\n    // Parses a=crypto lines into\r\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\r\n    SDPUtils.parseCryptoLine = function (line) {\r\n      const parts = line.substring(9).split(' ');\r\n      return {\r\n        tag: parseInt(parts[0], 10),\r\n        cryptoSuite: parts[1],\r\n        keyParams: parts[2],\r\n        sessionParams: parts.slice(3)\r\n      };\r\n    };\r\n    SDPUtils.writeCryptoLine = function (parameters) {\r\n      return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses the crypto key parameters into\r\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\r\n    SDPUtils.parseCryptoKeyParams = function (keyParams) {\r\n      if (keyParams.indexOf('inline:') !== 0) {\r\n        return null;\r\n      }\r\n      const parts = keyParams.substring(7).split('|');\r\n      return {\r\n        keyMethod: 'inline',\r\n        keySalt: parts[0],\r\n        lifeTime: parts[1],\r\n        mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\r\n        mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\r\n      };\r\n    };\r\n    SDPUtils.writeCryptoKeyParams = function (keyParams) {\r\n      return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\r\n    };\r\n\r\n    // Extracts all SDES parameters.\r\n    SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\r\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\r\n      return lines.map(SDPUtils.parseCryptoLine);\r\n    };\r\n\r\n    // Parses ICE information from SDP media section or sessionpart.\r\n    // FIXME: for consistency with other functions this should only\r\n    //   get the ice-ufrag and ice-pwd lines as input.\r\n    SDPUtils.getIceParameters = function (mediaSection, sessionpart) {\r\n      const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\r\n      const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\r\n      if (!(ufrag && pwd)) {\r\n        return null;\r\n      }\r\n      return {\r\n        usernameFragment: ufrag.substring(12),\r\n        password: pwd.substring(10)\r\n      };\r\n    };\r\n\r\n    // Serializes ICE parameters to SDP.\r\n    SDPUtils.writeIceParameters = function (params) {\r\n      let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\r\n      if (params.iceLite) {\r\n        sdp += 'a=ice-lite\\r\\n';\r\n      }\r\n      return sdp;\r\n    };\r\n\r\n    // Parses the SDP media section and returns RTCRtpParameters.\r\n    SDPUtils.parseRtpParameters = function (mediaSection) {\r\n      const description = {\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        fecMechanisms: [],\r\n        rtcp: []\r\n      };\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const mline = lines[0].split(' ');\r\n      description.profile = mline[2];\r\n      for (let i = 3; i < mline.length; i++) {\r\n        // find all codecs from mline[3..]\r\n        const pt = mline[i];\r\n        const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\r\n        if (rtpmapline) {\r\n          const codec = SDPUtils.parseRtpMap(rtpmapline);\r\n          const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\r\n          // Only the first a=fmtp:<pt> is considered.\r\n          codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\r\n          codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\r\n          description.codecs.push(codec);\r\n          // parse FEC mechanisms from rtpmap lines.\r\n          switch (codec.name.toUpperCase()) {\r\n            case 'RED':\r\n            case 'ULPFEC':\r\n              description.fecMechanisms.push(codec.name.toUpperCase());\r\n              break;\r\n          }\r\n        }\r\n      }\r\n      SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\r\n        description.headerExtensions.push(SDPUtils.parseExtmap(line));\r\n      });\r\n      const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\r\n      description.codecs.forEach(codec => {\r\n        wildcardRtcpFb.forEach(fb => {\r\n          const duplicate = codec.rtcpFeedback.find(existingFeedback => {\r\n            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\r\n          });\r\n          if (!duplicate) {\r\n            codec.rtcpFeedback.push(fb);\r\n          }\r\n        });\r\n      });\r\n      // FIXME: parse rtcp.\r\n      return description;\r\n    };\r\n\r\n    // Generates parts of the SDP media section describing the capabilities /\r\n    // parameters.\r\n    SDPUtils.writeRtpDescription = function (kind, caps) {\r\n      let sdp = '';\r\n\r\n      // Build the mline.\r\n      sdp += 'm=' + kind + ' ';\r\n      sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\r\n      sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\r\n      sdp += caps.codecs.map(codec => {\r\n        if (codec.preferredPayloadType !== undefined) {\r\n          return codec.preferredPayloadType;\r\n        }\r\n        return codec.payloadType;\r\n      }).join(' ') + '\\r\\n';\r\n      sdp += 'c=IN IP4 0.0.0.0\\r\\n';\r\n      sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\r\n\r\n      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\r\n      caps.codecs.forEach(codec => {\r\n        sdp += SDPUtils.writeRtpMap(codec);\r\n        sdp += SDPUtils.writeFmtp(codec);\r\n        sdp += SDPUtils.writeRtcpFb(codec);\r\n      });\r\n      let maxptime = 0;\r\n      caps.codecs.forEach(codec => {\r\n        if (codec.maxptime > maxptime) {\r\n          maxptime = codec.maxptime;\r\n        }\r\n      });\r\n      if (maxptime > 0) {\r\n        sdp += 'a=maxptime:' + maxptime + '\\r\\n';\r\n      }\r\n      if (caps.headerExtensions) {\r\n        caps.headerExtensions.forEach(extension => {\r\n          sdp += SDPUtils.writeExtmap(extension);\r\n        });\r\n      }\r\n      // FIXME: write fecMechanisms.\r\n      return sdp;\r\n    };\r\n\r\n    // Parses the SDP media section and returns an array of\r\n    // RTCRtpEncodingParameters.\r\n    SDPUtils.parseRtpEncodingParameters = function (mediaSection) {\r\n      const encodingParameters = [];\r\n      const description = SDPUtils.parseRtpParameters(mediaSection);\r\n      const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\r\n      const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\r\n\r\n      // filter a=ssrc:... cname:, ignore PlanB-msid\r\n      const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\r\n      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\r\n      let secondarySsrc;\r\n      const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\r\n        const parts = line.substring(17).split(' ');\r\n        return parts.map(part => parseInt(part, 10));\r\n      });\r\n      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\r\n        secondarySsrc = flows[0][1];\r\n      }\r\n      description.codecs.forEach(codec => {\r\n        if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\r\n          let encParam = {\r\n            ssrc: primarySsrc,\r\n            codecPayloadType: parseInt(codec.parameters.apt, 10)\r\n          };\r\n          if (primarySsrc && secondarySsrc) {\r\n            encParam.rtx = {\r\n              ssrc: secondarySsrc\r\n            };\r\n          }\r\n          encodingParameters.push(encParam);\r\n          if (hasRed) {\r\n            encParam = JSON.parse(JSON.stringify(encParam));\r\n            encParam.fec = {\r\n              ssrc: primarySsrc,\r\n              mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\r\n            };\r\n            encodingParameters.push(encParam);\r\n          }\r\n        }\r\n      });\r\n      if (encodingParameters.length === 0 && primarySsrc) {\r\n        encodingParameters.push({\r\n          ssrc: primarySsrc\r\n        });\r\n      }\r\n\r\n      // we support both b=AS and b=TIAS but interpret AS as TIAS.\r\n      let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\r\n      if (bandwidth.length) {\r\n        if (bandwidth[0].indexOf('b=TIAS:') === 0) {\r\n          bandwidth = parseInt(bandwidth[0].substring(7), 10);\r\n        } else if (bandwidth[0].indexOf('b=AS:') === 0) {\r\n          // use formula from JSEP to convert b=AS to TIAS value.\r\n          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\r\n        } else {\r\n          bandwidth = undefined;\r\n        }\r\n        encodingParameters.forEach(params => {\r\n          params.maxBitrate = bandwidth;\r\n        });\r\n      }\r\n      return encodingParameters;\r\n    };\r\n\r\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\r\n    SDPUtils.parseRtcpParameters = function (mediaSection) {\r\n      const rtcpParameters = {};\r\n\r\n      // Gets the first SSRC. Note that with RTX there might be multiple\r\n      // SSRCs.\r\n      const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\r\n      if (remoteSsrc) {\r\n        rtcpParameters.cname = remoteSsrc.value;\r\n        rtcpParameters.ssrc = remoteSsrc.ssrc;\r\n      }\r\n\r\n      // Edge uses the compound attribute instead of reducedSize\r\n      // compound is !reducedSize\r\n      const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\r\n      rtcpParameters.reducedSize = rsize.length > 0;\r\n      rtcpParameters.compound = rsize.length === 0;\r\n\r\n      // parses the rtcp-mux attrіbute.\r\n      // Note that Edge does not support unmuxed RTCP.\r\n      const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\r\n      rtcpParameters.mux = mux.length > 0;\r\n      return rtcpParameters;\r\n    };\r\n    SDPUtils.writeRtcpParameters = function (rtcpParameters) {\r\n      let sdp = '';\r\n      if (rtcpParameters.reducedSize) {\r\n        sdp += 'a=rtcp-rsize\\r\\n';\r\n      }\r\n      if (rtcpParameters.mux) {\r\n        sdp += 'a=rtcp-mux\\r\\n';\r\n      }\r\n      if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\r\n        sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\r\n      }\r\n      return sdp;\r\n    };\r\n\r\n    // parses either a=msid: or a=ssrc:... msid lines and returns\r\n    // the id of the MediaStream and MediaStreamTrack.\r\n    SDPUtils.parseMsid = function (mediaSection) {\r\n      let parts;\r\n      const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\r\n      if (spec.length === 1) {\r\n        parts = spec[0].substring(7).split(' ');\r\n        return {\r\n          stream: parts[0],\r\n          track: parts[1]\r\n        };\r\n      }\r\n      const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\r\n      if (planB.length > 0) {\r\n        parts = planB[0].value.split(' ');\r\n        return {\r\n          stream: parts[0],\r\n          track: parts[1]\r\n        };\r\n      }\r\n    };\r\n\r\n    // SCTP\r\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\r\n    // to draft-ietf-mmusic-sctp-sdp-05\r\n    SDPUtils.parseSctpDescription = function (mediaSection) {\r\n      const mline = SDPUtils.parseMLine(mediaSection);\r\n      const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\r\n      let maxMessageSize;\r\n      if (maxSizeLine.length > 0) {\r\n        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\r\n      }\r\n      if (isNaN(maxMessageSize)) {\r\n        maxMessageSize = 65536;\r\n      }\r\n      const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\r\n      if (sctpPort.length > 0) {\r\n        return {\r\n          port: parseInt(sctpPort[0].substring(12), 10),\r\n          protocol: mline.fmt,\r\n          maxMessageSize\r\n        };\r\n      }\r\n      const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\r\n      if (sctpMapLines.length > 0) {\r\n        const parts = sctpMapLines[0].substring(10).split(' ');\r\n        return {\r\n          port: parseInt(parts[0], 10),\r\n          protocol: parts[1],\r\n          maxMessageSize\r\n        };\r\n      }\r\n    };\r\n\r\n    // SCTP\r\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\r\n    // support by now receiving in this format, unless we originally parsed\r\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\r\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\r\n    SDPUtils.writeSctpDescription = function (media, sctp) {\r\n      let output = [];\r\n      if (media.protocol !== 'DTLS/SCTP') {\r\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\r\n      } else {\r\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\r\n      }\r\n      if (sctp.maxMessageSize !== undefined) {\r\n        output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\r\n      }\r\n      return output.join('');\r\n    };\r\n\r\n    // Generate a session ID for SDP.\r\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\r\n    // recommends using a cryptographically random +ve 64-bit value\r\n    // but right now this should be acceptable and within the right range\r\n    SDPUtils.generateSessionId = function () {\r\n      return Math.random().toString().substr(2, 22);\r\n    };\r\n\r\n    // Write boiler plate for start of SDP\r\n    // sessId argument is optional - if not supplied it will\r\n    // be generated randomly\r\n    // sessVersion is optional and defaults to 2\r\n    // sessUser is optional and defaults to 'thisisadapterortc'\r\n    SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\r\n      let sessionId;\r\n      const version = sessVer !== undefined ? sessVer : 2;\r\n      if (sessId) {\r\n        sessionId = sessId;\r\n      } else {\r\n        sessionId = SDPUtils.generateSessionId();\r\n      }\r\n      const user = sessUser || 'thisisadapterortc';\r\n      // FIXME: sess-id should be an NTP timestamp.\r\n      return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\r\n    };\r\n\r\n    // Gets the direction from the mediaSection or the sessionpart.\r\n    SDPUtils.getDirection = function (mediaSection, sessionpart) {\r\n      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      for (let i = 0; i < lines.length; i++) {\r\n        switch (lines[i]) {\r\n          case 'a=sendrecv':\r\n          case 'a=sendonly':\r\n          case 'a=recvonly':\r\n          case 'a=inactive':\r\n            return lines[i].substring(2);\r\n          // FIXME: What should happen here?\r\n        }\r\n      }\r\n      if (sessionpart) {\r\n        return SDPUtils.getDirection(sessionpart);\r\n      }\r\n      return 'sendrecv';\r\n    };\r\n    SDPUtils.getKind = function (mediaSection) {\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const mline = lines[0].split(' ');\r\n      return mline[0].substring(2);\r\n    };\r\n    SDPUtils.isRejected = function (mediaSection) {\r\n      return mediaSection.split(' ', 2)[1] === '0';\r\n    };\r\n    SDPUtils.parseMLine = function (mediaSection) {\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const parts = lines[0].substring(2).split(' ');\r\n      return {\r\n        kind: parts[0],\r\n        port: parseInt(parts[1], 10),\r\n        protocol: parts[2],\r\n        fmt: parts.slice(3).join(' ')\r\n      };\r\n    };\r\n    SDPUtils.parseOLine = function (mediaSection) {\r\n      const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\r\n      const parts = line.substring(2).split(' ');\r\n      return {\r\n        username: parts[0],\r\n        sessionId: parts[1],\r\n        sessionVersion: parseInt(parts[2], 10),\r\n        netType: parts[3],\r\n        addressType: parts[4],\r\n        address: parts[5]\r\n      };\r\n    };\r\n\r\n    // a very naive interpretation of a valid SDP.\r\n    SDPUtils.isValidSDP = function (blob) {\r\n      if (typeof blob !== 'string' || blob.length === 0) {\r\n        return false;\r\n      }\r\n      const lines = SDPUtils.splitLines(blob);\r\n      for (let i = 0; i < lines.length; i++) {\r\n        if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\r\n          return false;\r\n        }\r\n        // TODO: check the modifier a bit more.\r\n      }\r\n      return true;\r\n    };\r\n\r\n    // Expose public methods.\r\n    {\r\n      module.exports = SDPUtils;\r\n    }\r\n  })(sdp$1);\r\n  return sdp$1.exports;\r\n}\r\n\r\nvar sdpExports = requireSdp();\r\nvar SDPUtils = /*@__PURE__*/getDefaultExportFromCjs(sdpExports);\r\n\r\nvar sdp = /*#__PURE__*/_mergeNamespaces({\r\n  __proto__: null,\r\n  default: SDPUtils\r\n}, [sdpExports]);\r\n\r\n/*\r\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimRTCIceCandidate(window) {\r\n  // foundation is arbitrarily chosen as an indicator for full support for\r\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\r\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\r\n    return;\r\n  }\r\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\r\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\r\n    // Remove the a= which shouldn't be part of the candidate string.\r\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\r\n      args = JSON.parse(JSON.stringify(args));\r\n      args.candidate = args.candidate.substring(2);\r\n    }\r\n    if (args.candidate && args.candidate.length) {\r\n      // Augment the native candidate with the parsed fields.\r\n      const nativeCandidate = new NativeRTCIceCandidate(args);\r\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\r\n      for (const key in parsedCandidate) {\r\n        if (!(key in nativeCandidate)) {\r\n          Object.defineProperty(nativeCandidate, key, {\r\n            value: parsedCandidate[key]\r\n          });\r\n        }\r\n      }\r\n\r\n      // Override serializer to not serialize the extra attributes.\r\n      nativeCandidate.toJSON = function toJSON() {\r\n        return {\r\n          candidate: nativeCandidate.candidate,\r\n          sdpMid: nativeCandidate.sdpMid,\r\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\r\n          usernameFragment: nativeCandidate.usernameFragment\r\n        };\r\n      };\r\n      return nativeCandidate;\r\n    }\r\n    return new NativeRTCIceCandidate(args);\r\n  };\r\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\r\n\r\n  // Hook up the augmented candidate in onicecandidate and\r\n  // addEventListener('icecandidate', ...)\r\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\r\n    if (e.candidate) {\r\n      Object.defineProperty(e, 'candidate', {\r\n        value: new window.RTCIceCandidate(e.candidate),\r\n        writable: 'false'\r\n      });\r\n    }\r\n    return e;\r\n  });\r\n}\r\nfunction shimRTCIceCandidateRelayProtocol(window) {\r\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype) {\r\n    return;\r\n  }\r\n\r\n  // Hook up the augmented candidate in onicecandidate and\r\n  // addEventListener('icecandidate', ...)\r\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\r\n    if (e.candidate) {\r\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\r\n      if (parsedCandidate.type === 'relay') {\r\n        // This is a libwebrtc-specific mapping of local type preference\r\n        // to relayProtocol.\r\n        e.candidate.relayProtocol = {\r\n          0: 'tls',\r\n          1: 'tcp',\r\n          2: 'udp'\r\n        }[parsedCandidate.priority >> 24];\r\n      }\r\n    }\r\n    return e;\r\n  });\r\n}\r\nfunction shimMaxMessageSize(window, browserDetails) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\r\n      get() {\r\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\r\n      }\r\n    });\r\n  }\r\n  const sctpInDescription = function (description) {\r\n    if (!description || !description.sdp) {\r\n      return false;\r\n    }\r\n    const sections = SDPUtils.splitSections(description.sdp);\r\n    sections.shift();\r\n    return sections.some(mediaSection => {\r\n      const mLine = SDPUtils.parseMLine(mediaSection);\r\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\r\n    });\r\n  };\r\n  const getRemoteFirefoxVersion = function (description) {\r\n    // TODO: Is there a better solution for detecting Firefox?\r\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\r\n    if (match === null || match.length < 2) {\r\n      return -1;\r\n    }\r\n    const version = parseInt(match[1], 10);\r\n    // Test for NaN (yes, this is ugly)\r\n    return version !== version ? -1 : version;\r\n  };\r\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\r\n    // Every implementation we know can send at least 64 KiB.\r\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\r\n    //       data does not reach the other peer reliably.\r\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\r\n    let canSendMaxMessageSize = 65536;\r\n    if (browserDetails.browser === 'firefox') {\r\n      if (browserDetails.version < 57) {\r\n        if (remoteIsFirefox === -1) {\r\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\r\n          // fragmentation.\r\n          canSendMaxMessageSize = 16384;\r\n        } else {\r\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\r\n          // messages. Thus, supporting ~2 GiB when sending.\r\n          canSendMaxMessageSize = 2147483637;\r\n        }\r\n      } else if (browserDetails.version < 60) {\r\n        // Currently, all FF >= 57 will reset the remote maximum message size\r\n        // to the default value when a data channel is created at a later\r\n        // stage. :(\r\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\r\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\r\n      } else {\r\n        // FF >= 60 supports sending ~2 GiB\r\n        canSendMaxMessageSize = 2147483637;\r\n      }\r\n    }\r\n    return canSendMaxMessageSize;\r\n  };\r\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\r\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\r\n    //       every implementation we know supports receiving 65536 bytes.\r\n    let maxMessageSize = 65536;\r\n\r\n    // FF 57 has a slightly incorrect default remote max message size, so\r\n    // we need to adjust it here to avoid a failure when sending.\r\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\r\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\r\n      maxMessageSize = 65535;\r\n    }\r\n    const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\r\n    if (match.length > 0) {\r\n      maxMessageSize = parseInt(match[0].substring(19), 10);\r\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\r\n      // If the maximum message size is not present in the remote SDP and\r\n      // both local and remote are Firefox, the remote peer can receive\r\n      // ~2 GiB.\r\n      maxMessageSize = 2147483637;\r\n    }\r\n    return maxMessageSize;\r\n  };\r\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n    this._sctp = null;\r\n    // Chrome decided to not expose .sctp in plan-b mode.\r\n    // As usual, adapter.js has to do an 'ugly worakaround'\r\n    // to cover up the mess.\r\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\r\n      const {\r\n        sdpSemantics\r\n      } = this.getConfiguration();\r\n      if (sdpSemantics === 'plan-b') {\r\n        Object.defineProperty(this, 'sctp', {\r\n          get() {\r\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\r\n          },\r\n          enumerable: true,\r\n          configurable: true\r\n        });\r\n      }\r\n    }\r\n    if (sctpInDescription(arguments[0])) {\r\n      // Check if the remote is FF.\r\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\r\n\r\n      // Get the maximum message size the local peer is capable of sending\r\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\r\n\r\n      // Get the maximum message size of the remote peer.\r\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\r\n\r\n      // Determine final maximum message size\r\n      let maxMessageSize;\r\n      if (canSendMMS === 0 && remoteMMS === 0) {\r\n        maxMessageSize = Number.POSITIVE_INFINITY;\r\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\r\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\r\n      } else {\r\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\r\n      }\r\n\r\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\r\n      // attribute.\r\n      const sctp = {};\r\n      Object.defineProperty(sctp, 'maxMessageSize', {\r\n        get() {\r\n          return maxMessageSize;\r\n        }\r\n      });\r\n      this._sctp = sctp;\r\n    }\r\n    return origSetRemoteDescription.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimSendThrowTypeError(window) {\r\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n\r\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\r\n  //       message size can be reset for all data channels at a later stage.\r\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\r\n\r\n  function wrapDcSend(dc, pc) {\r\n    const origDataChannelSend = dc.send;\r\n    dc.send = function send() {\r\n      const data = arguments[0];\r\n      const length = data.length || data.size || data.byteLength;\r\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\r\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\r\n      }\r\n      return origDataChannelSend.apply(dc, arguments);\r\n    };\r\n  }\r\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\r\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\r\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\r\n    wrapDcSend(dataChannel, this);\r\n    return dataChannel;\r\n  };\r\n  wrapPeerConnectionEvent(window, 'datachannel', e => {\r\n    wrapDcSend(e.channel, e.target);\r\n    return e;\r\n  });\r\n}\r\n\r\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\r\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\r\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\r\n * since DTLS failures would be hidden. See\r\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\r\n * for the Firefox tracking bug.\r\n */\r\nfunction shimConnectionState(window) {\r\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\r\n    return;\r\n  }\r\n  const proto = window.RTCPeerConnection.prototype;\r\n  Object.defineProperty(proto, 'connectionState', {\r\n    get() {\r\n      return {\r\n        completed: 'connected',\r\n        checking: 'connecting'\r\n      }[this.iceConnectionState] || this.iceConnectionState;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n  Object.defineProperty(proto, 'onconnectionstatechange', {\r\n    get() {\r\n      return this._onconnectionstatechange || null;\r\n    },\r\n    set(cb) {\r\n      if (this._onconnectionstatechange) {\r\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\r\n        delete this._onconnectionstatechange;\r\n      }\r\n      if (cb) {\r\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\r\n    const origMethod = proto[method];\r\n    proto[method] = function () {\r\n      if (!this._connectionstatechangepoly) {\r\n        this._connectionstatechangepoly = e => {\r\n          const pc = e.target;\r\n          if (pc._lastConnectionState !== pc.connectionState) {\r\n            pc._lastConnectionState = pc.connectionState;\r\n            const newEvent = new Event('connectionstatechange', e);\r\n            pc.dispatchEvent(newEvent);\r\n          }\r\n          return e;\r\n        };\r\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\r\n      }\r\n      return origMethod.apply(this, arguments);\r\n    };\r\n  });\r\n}\r\nfunction removeExtmapAllowMixed(window, browserDetails) {\r\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\r\n    return;\r\n  }\r\n  if (browserDetails.browser === 'safari' && browserDetails._safariVersion >= 13.1) {\r\n    return;\r\n  }\r\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\r\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\r\n      const sdp = desc.sdp.split('\\n').filter(line => {\r\n        return line.trim() !== 'a=extmap-allow-mixed';\r\n      }).join('\\n');\r\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\r\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\r\n        arguments[0] = new window.RTCSessionDescription({\r\n          type: desc.type,\r\n          sdp\r\n        });\r\n      } else {\r\n        desc.sdp = sdp;\r\n      }\r\n    }\r\n    return nativeSRD.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\r\n  // Support for addIceCandidate(null or undefined)\r\n  // as well as addIceCandidate({candidate: \"\", ...})\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\r\n  // Note: must be called before other polyfills which change the signature.\r\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\r\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\r\n    if (!arguments[0]) {\r\n      if (arguments[1]) {\r\n        arguments[1].apply(null);\r\n      }\r\n      return Promise.resolve();\r\n    }\r\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\r\n    // in older versions.\r\n    // Native support for ignoring exists for Chrome M77+.\r\n    // Safari ignores as well, exact version unknown but works in the same\r\n    // version that also ignores addIceCandidate(null).\r\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\r\n      return Promise.resolve();\r\n    }\r\n    return nativeAddIceCandidate.apply(this, arguments);\r\n  };\r\n}\r\n\r\n// Note: Make sure to call this ahead of APIs that modify\r\n// setLocalDescription.length\r\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\r\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\r\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\r\n    let desc = arguments[0] || {};\r\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\r\n      return nativeSetLocalDescription.apply(this, arguments);\r\n    }\r\n    // The remaining steps should technically happen when SLD comes off the\r\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\r\n    // this is too difficult to shim. Instead, this shim only covers the\r\n    // common case where the operations chain is empty. This is imperfect, but\r\n    // should cover many cases. Rationale: Even if we can't reduce the glare\r\n    // window to zero on imperfect implementations, there's value in tapping\r\n    // into the perfect negotiation pattern that several browsers support.\r\n    desc = {\r\n      type: desc.type,\r\n      sdp: desc.sdp\r\n    };\r\n    if (!desc.type) {\r\n      switch (this.signalingState) {\r\n        case 'stable':\r\n        case 'have-local-offer':\r\n        case 'have-remote-pranswer':\r\n          desc.type = 'offer';\r\n          break;\r\n        default:\r\n          desc.type = 'answer';\r\n          break;\r\n      }\r\n    }\r\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\r\n      return nativeSetLocalDescription.apply(this, [desc]);\r\n    }\r\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\r\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\r\n  };\r\n}\r\n\r\nvar commonShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  removeExtmapAllowMixed: removeExtmapAllowMixed,\r\n  shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\r\n  shimConnectionState: shimConnectionState,\r\n  shimMaxMessageSize: shimMaxMessageSize,\r\n  shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\r\n  shimRTCIceCandidate: shimRTCIceCandidate,\r\n  shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\r\n  shimSendThrowTypeError: shimSendThrowTypeError\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n\r\n// Shimming starts here.\r\nfunction adapterFactory() {\r\n  let {\r\n    window\r\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\r\n    shimChrome: true,\r\n    shimFirefox: true,\r\n    shimSafari: true\r\n  };\r\n  // Utils.\r\n  const logging = log;\r\n  const browserDetails = detectBrowser(window);\r\n  const adapter = {\r\n    browserDetails,\r\n    commonShim,\r\n    extractVersion: extractVersion,\r\n    disableLog: disableLog,\r\n    disableWarnings: disableWarnings,\r\n    // Expose sdp as a convenience. For production apps include directly.\r\n    sdp\r\n  };\r\n\r\n  // Shim browser if found.\r\n  switch (browserDetails.browser) {\r\n    case 'chrome':\r\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\r\n        logging('Chrome shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      if (browserDetails.version === null) {\r\n        logging('Chrome shim can not determine version, not shimming.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming chrome.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = chromeShim;\r\n\r\n      // Must be called before shimPeerConnection.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimGetUserMedia$2(window, browserDetails);\r\n      shimMediaStream(window);\r\n      shimPeerConnection$1(window, browserDetails);\r\n      shimOnTrack$1(window);\r\n      shimAddTrackRemoveTrack(window, browserDetails);\r\n      shimGetSendersWithDtmf(window);\r\n      shimSenderReceiverGetStats(window);\r\n      fixNegotiationNeeded(window, browserDetails);\r\n      shimRTCIceCandidate(window);\r\n      shimRTCIceCandidateRelayProtocol(window);\r\n      shimConnectionState(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      removeExtmapAllowMixed(window, browserDetails);\r\n      break;\r\n    case 'firefox':\r\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\r\n        logging('Firefox shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming firefox.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = firefoxShim;\r\n\r\n      // Must be called before shimPeerConnection.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimGetUserMedia$1(window, browserDetails);\r\n      shimPeerConnection(window, browserDetails);\r\n      shimOnTrack(window);\r\n      shimRemoveStream(window);\r\n      shimSenderGetStats(window);\r\n      shimReceiverGetStats(window);\r\n      shimRTCDataChannel(window);\r\n      shimAddTransceiver(window);\r\n      shimGetParameters(window);\r\n      shimCreateOffer(window);\r\n      shimCreateAnswer(window);\r\n      shimRTCIceCandidate(window);\r\n      shimConnectionState(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      break;\r\n    case 'safari':\r\n      if (!safariShim || !options.shimSafari) {\r\n        logging('Safari shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming safari.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = safariShim;\r\n\r\n      // Must be called before shimCallbackAPI.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimRTCIceServerUrls(window);\r\n      shimCreateOfferLegacy(window);\r\n      shimCallbacksAPI(window);\r\n      shimLocalStreamsAPI(window);\r\n      shimRemoteStreamsAPI(window);\r\n      shimTrackEventTransceiver(window);\r\n      shimGetUserMedia(window);\r\n      shimAudioContext(window);\r\n      shimRTCIceCandidate(window);\r\n      shimRTCIceCandidateRelayProtocol(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      removeExtmapAllowMixed(window, browserDetails);\r\n      break;\r\n    default:\r\n      logging('Unsupported browser!');\r\n      break;\r\n  }\r\n  return adapter;\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nadapterFactory({\r\n  window: typeof window === 'undefined' ? undefined : window\r\n});\r\n\r\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\r\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\r\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\r\n// flag set to indicate that e2ee has been setup for sender/receiver;\r\nconst E2EE_FLAG = 'lk_e2ee';\r\nconst SALT = 'LKFrameEncryptionKey';\r\nconst KEY_PROVIDER_DEFAULTS = {\r\n  sharedKey: false,\r\n  ratchetSalt: SALT,\r\n  ratchetWindowSize: 8,\r\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\r\n  keyringSize: 16\r\n};\r\n\r\nvar KeyProviderEvent;\r\n(function (KeyProviderEvent) {\r\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\r\n  /** Event for requesting to ratchet the key used to encrypt the stream */\r\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\r\n  /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or\r\n   *  following a `RatchetRequest`, will contain the ratcheted key material */\r\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\r\n})(KeyProviderEvent || (KeyProviderEvent = {}));\r\nvar KeyHandlerEvent;\r\n(function (KeyHandlerEvent) {\r\n  /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted\r\n   * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */\r\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\r\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\r\nvar EncryptionEvent;\r\n(function (EncryptionEvent) {\r\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\r\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\r\n})(EncryptionEvent || (EncryptionEvent = {}));\r\nvar CryptorEvent;\r\n(function (CryptorEvent) {\r\n  CryptorEvent[\"Error\"] = \"cryptorError\";\r\n})(CryptorEvent || (CryptorEvent = {}));\r\n\r\nfunction isE2EESupported() {\r\n  return isInsertableStreamSupported() || isScriptTransformSupported();\r\n}\r\nfunction isScriptTransformSupported() {\r\n  // @ts-ignore\r\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\r\n}\r\nfunction isInsertableStreamSupported() {\r\n  return typeof window.RTCRtpSender !== 'undefined' &&\r\n  // @ts-ignore\r\n  typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\r\n}\r\nfunction isVideoFrame(frame) {\r\n  return 'type' in frame;\r\n}\r\nfunction importKey(keyBytes_1) {\r\n  return __awaiter(this, arguments, void 0, function (keyBytes) {\r\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\r\n      name: ENCRYPTION_ALGORITHM\r\n    };\r\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\r\n    return function* () {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\r\n      return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\r\n    }();\r\n  });\r\n}\r\nfunction createKeyMaterialFromString(password) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    let enc = new TextEncoder();\r\n    const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\r\n      name: 'PBKDF2'\r\n    }, false, ['deriveBits', 'deriveKey']);\r\n    return keyMaterial;\r\n  });\r\n}\r\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, ['deriveBits', 'deriveKey']);\r\n    return keyMaterial;\r\n  });\r\n}\r\nfunction getAlgoOptions(algorithmName, salt) {\r\n  const textEncoder = new TextEncoder();\r\n  const encodedSalt = textEncoder.encode(salt);\r\n  switch (algorithmName) {\r\n    case 'HKDF':\r\n      return {\r\n        name: 'HKDF',\r\n        salt: encodedSalt,\r\n        hash: 'SHA-256',\r\n        info: new ArrayBuffer(128)\r\n      };\r\n    case 'PBKDF2':\r\n      {\r\n        return {\r\n          name: 'PBKDF2',\r\n          salt: encodedSalt,\r\n          hash: 'SHA-256',\r\n          iterations: 100000\r\n        };\r\n      }\r\n    default:\r\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\r\n  }\r\n}\r\n/**\r\n * Derives a set of keys from the master key.\r\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\r\n */\r\nfunction deriveKeys(material, salt) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\r\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\r\n      name: ENCRYPTION_ALGORITHM,\r\n      length: 128\r\n    }, false, ['encrypt', 'decrypt']);\r\n    return {\r\n      material,\r\n      encryptionKey\r\n    };\r\n  });\r\n}\r\nfunction createE2EEKey() {\r\n  return window.crypto.getRandomValues(new Uint8Array(32));\r\n}\r\n/**\r\n * Ratchets a key. See\r\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\r\n */\r\nfunction ratchet(material, salt) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\r\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\r\n  });\r\n}\r\nfunction needsRbspUnescaping(frameData) {\r\n  for (var i = 0; i < frameData.length - 3; i++) {\r\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\r\n  }\r\n  return false;\r\n}\r\nfunction parseRbsp(stream) {\r\n  const dataOut = [];\r\n  var length = stream.length;\r\n  for (var i = 0; i < stream.length;) {\r\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\r\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\r\n    // above, and that expression will produce the number of bytes left in\r\n    // the stream including the byte at i.\r\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\r\n      // Two rbsp bytes.\r\n      dataOut.push(stream[i++]);\r\n      dataOut.push(stream[i++]);\r\n      // Skip the emulation byte.\r\n      i++;\r\n    } else {\r\n      // Single rbsp byte.\r\n      dataOut.push(stream[i++]);\r\n    }\r\n  }\r\n  return new Uint8Array(dataOut);\r\n}\r\nconst kZerosInStartSequence = 2;\r\nconst kEmulationByte = 3;\r\nfunction writeRbsp(data_in) {\r\n  const dataOut = [];\r\n  var numConsecutiveZeros = 0;\r\n  for (var i = 0; i < data_in.length; ++i) {\r\n    var byte = data_in[i];\r\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\r\n      // Need to escape.\r\n      dataOut.push(kEmulationByte);\r\n      numConsecutiveZeros = 0;\r\n    }\r\n    dataOut.push(byte);\r\n    if (byte == 0) {\r\n      ++numConsecutiveZeros;\r\n    } else {\r\n      numConsecutiveZeros = 0;\r\n    }\r\n  }\r\n  return new Uint8Array(dataOut);\r\n}\r\n\r\n/**\r\n * @experimental\r\n */\r\nclass BaseKeyProvider extends eventsExports.EventEmitter {\r\n  constructor() {\r\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    super();\r\n    /**\r\n     * Callback being invoked after a key has been ratcheted.\r\n     * Can happen when:\r\n     * - A decryption failure occurs and the key is auto-ratcheted\r\n     * - A ratchet request is sent (see {@link ratchetKey()})\r\n     * @param ratchetResult Contains the ratcheted chain key (exportable to other participants) and the derived new key material.\r\n     * @param participantId\r\n     * @param keyIndex\r\n     */\r\n    this.onKeyRatcheted = (ratchetResult, participantId, keyIndex) => {\r\n      livekitLogger.debug('key ratcheted event received', {\r\n        ratchetResult,\r\n        participantId,\r\n        keyIndex\r\n      });\r\n    };\r\n    this.keyInfoMap = new Map();\r\n    this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\r\n    this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\r\n  }\r\n  /**\r\n   * callback to invoke once a key has been set for a participant\r\n   * @param key\r\n   * @param participantIdentity\r\n   * @param keyIndex\r\n   */\r\n  onSetEncryptionKey(key, participantIdentity, keyIndex) {\r\n    const keyInfo = {\r\n      key,\r\n      participantIdentity,\r\n      keyIndex\r\n    };\r\n    if (!this.options.sharedKey && !participantIdentity) {\r\n      throw new Error('participant identity needs to be passed for encryption key if sharedKey option is false');\r\n    }\r\n    this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\r\n    this.emit(KeyProviderEvent.SetKey, keyInfo);\r\n  }\r\n  getKeys() {\r\n    return Array.from(this.keyInfoMap.values());\r\n  }\r\n  getOptions() {\r\n    return this.options;\r\n  }\r\n  ratchetKey(participantIdentity, keyIndex) {\r\n    this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\r\n  }\r\n}\r\n/**\r\n * A basic KeyProvider implementation intended for a single shared\r\n * passphrase between all participants\r\n * @experimental\r\n */\r\nclass ExternalE2EEKeyProvider extends BaseKeyProvider {\r\n  constructor() {\r\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    const opts = Object.assign(Object.assign({}, options), {\r\n      sharedKey: true,\r\n      // for a shared key provider failing to decrypt for a specific participant\r\n      // should not mark the key as invalid, so we accept wrong keys forever\r\n      // and won't try to auto-ratchet\r\n      ratchetWindowSize: 0,\r\n      failureTolerance: -1\r\n    });\r\n    super(opts);\r\n  }\r\n  /**\r\n   * Accepts a passphrase that's used to create the crypto keys.\r\n   * When passing in a string, PBKDF2 is used.\r\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\r\n   * @param key\r\n   */\r\n  setKey(key) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\r\n      this.onSetEncryptionKey(derivedKey);\r\n    });\r\n  }\r\n}\r\n\r\nclass LivekitError extends Error {\r\n  constructor(code, message) {\r\n    super(message || 'an error has occured');\r\n    this.name = 'LiveKitError';\r\n    this.code = code;\r\n  }\r\n}\r\nvar ConnectionErrorReason;\r\n(function (ConnectionErrorReason) {\r\n  ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"Timeout\"] = 5] = \"Timeout\";\r\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\r\nclass ConnectionError extends LivekitError {\r\n  constructor(message, reason, status, context) {\r\n    super(1, message);\r\n    this.name = 'ConnectionError';\r\n    this.status = status;\r\n    this.reason = reason;\r\n    this.context = context;\r\n    this.reasonName = ConnectionErrorReason[reason];\r\n  }\r\n}\r\nclass DeviceUnsupportedError extends LivekitError {\r\n  constructor(message) {\r\n    super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\r\n    this.name = 'DeviceUnsupportedError';\r\n  }\r\n}\r\nclass TrackInvalidError extends LivekitError {\r\n  constructor(message) {\r\n    super(20, message !== null && message !== void 0 ? message : 'track is invalid');\r\n    this.name = 'TrackInvalidError';\r\n  }\r\n}\r\nclass UnsupportedServer extends LivekitError {\r\n  constructor(message) {\r\n    super(10, message !== null && message !== void 0 ? message : 'unsupported server');\r\n    this.name = 'UnsupportedServer';\r\n  }\r\n}\r\nclass UnexpectedConnectionState extends LivekitError {\r\n  constructor(message) {\r\n    super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\r\n    this.name = 'UnexpectedConnectionState';\r\n  }\r\n}\r\nclass NegotiationError extends LivekitError {\r\n  constructor(message) {\r\n    super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\r\n    this.name = 'NegotiationError';\r\n  }\r\n}\r\nclass PublishDataError extends LivekitError {\r\n  constructor(message) {\r\n    super(14, message !== null && message !== void 0 ? message : 'unable to publish data');\r\n    this.name = 'PublishDataError';\r\n  }\r\n}\r\nclass PublishTrackError extends LivekitError {\r\n  constructor(message, status) {\r\n    super(15, message);\r\n    this.name = 'PublishTrackError';\r\n    this.status = status;\r\n  }\r\n}\r\nclass SignalRequestError extends LivekitError {\r\n  constructor(message, reason) {\r\n    super(15, message);\r\n    this.reason = reason;\r\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\r\n  }\r\n}\r\nvar MediaDeviceFailure;\r\n(function (MediaDeviceFailure) {\r\n  // user rejected permissions\r\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\r\n  // device is not available\r\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\r\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\r\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\r\n  MediaDeviceFailure[\"Other\"] = \"Other\";\r\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\r\n(function (MediaDeviceFailure) {\r\n  function getFailure(error) {\r\n    if (error && 'name' in error) {\r\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\r\n        return MediaDeviceFailure.NotFound;\r\n      }\r\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\r\n        return MediaDeviceFailure.PermissionDenied;\r\n      }\r\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\r\n        return MediaDeviceFailure.DeviceInUse;\r\n      }\r\n      return MediaDeviceFailure.Other;\r\n    }\r\n  }\r\n  MediaDeviceFailure.getFailure = getFailure;\r\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\r\n\r\nvar CryptorErrorReason;\r\n(function (CryptorErrorReason) {\r\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\r\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\r\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\r\n})(CryptorErrorReason || (CryptorErrorReason = {}));\r\nclass CryptorError extends LivekitError {\r\n  constructor(message) {\r\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\r\n    let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\r\n    super(40, message);\r\n    this.reason = reason;\r\n    this.participantIdentity = participantIdentity;\r\n  }\r\n}\r\n\r\n/**\r\n * Events are the primary way LiveKit notifies your application of changes.\r\n *\r\n * The following are events emitted by [[Room]], listen to room events like\r\n *\r\n * ```typescript\r\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\r\n * ```\r\n */\r\nvar RoomEvent;\r\n(function (RoomEvent) {\r\n  /**\r\n   * When the connection to the server has been established\r\n   */\r\n  RoomEvent[\"Connected\"] = \"connected\";\r\n  /**\r\n   * When the connection to the server has been interrupted and it's attempting\r\n   * to reconnect.\r\n   */\r\n  RoomEvent[\"Reconnecting\"] = \"reconnecting\";\r\n  /**\r\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\r\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\r\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\r\n   */\r\n  RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\r\n  /**\r\n   * Fires when a reconnection has been successful.\r\n   */\r\n  RoomEvent[\"Reconnected\"] = \"reconnected\";\r\n  /**\r\n   * When disconnected from room. This fires when room.disconnect() is called or\r\n   * when an unrecoverable connection issue had occured.\r\n   *\r\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\r\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\r\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\r\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\r\n   *\r\n   * args: ([[DisconnectReason]])\r\n   */\r\n  RoomEvent[\"Disconnected\"] = \"disconnected\";\r\n  /**\r\n   * Whenever the connection state of the room changes\r\n   *\r\n   * args: ([[ConnectionState]])\r\n   */\r\n  RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\r\n  /**\r\n   * When participant has been moved to a different room by the service request.\r\n   * The behavior looks like the participant has been disconnected and reconnected to a different room\r\n   * seamlessly without connection state transition.\r\n   * A new token will be provided for reconnecting to the new room if needed.\r\n   *\r\n   * args: ([[room: string, token: string]])\r\n   */\r\n  RoomEvent[\"Moved\"] = \"moved\";\r\n  /**\r\n   * When input or output devices on the machine have changed.\r\n   */\r\n  RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\r\n  /**\r\n   * When a [[RemoteParticipant]] joins *after* the local\r\n   * participant. It will not emit events for participants that are already\r\n   * in the room\r\n   *\r\n   * args: ([[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\r\n  /**\r\n   * When a [[RemoteParticipant]] leaves *after* the local\r\n   * participant has joined.\r\n   *\r\n   * args: ([[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\r\n  /**\r\n   * When a new track is published to room *after* the local\r\n   * participant has joined. It will not fire for tracks that are already published.\r\n   *\r\n   * A track published doesn't mean the participant has subscribed to it. It's\r\n   * simply reflecting the state of the room.\r\n   *\r\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackPublished\"] = \"trackPublished\";\r\n  /**\r\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\r\n   * fire as long as new tracks are ready for use.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\r\n  /**\r\n   * Could not subscribe to a track\r\n   *\r\n   * args: (track sid, [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\r\n  /**\r\n   * A [[RemoteParticipant]] has unpublished a track\r\n   *\r\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\r\n  /**\r\n   * A subscribed track is no longer available. Clients should listen to this\r\n   * event and ensure they detach tracks.\r\n   *\r\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\r\n  /**\r\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]], [[Participant]])\r\n   */\r\n  RoomEvent[\"TrackMuted\"] = \"trackMuted\";\r\n  /**\r\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]], [[Participant]])\r\n   */\r\n  RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\r\n  /**\r\n   * A local track was published successfully. This event is helpful to know\r\n   * when to update your local UI with the newly published track.\r\n   *\r\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\r\n   */\r\n  RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\r\n  /**\r\n   * A local track was unpublished. This event is helpful to know when to remove\r\n   * the local track from your UI.\r\n   *\r\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\r\n   * this event will also fire.\r\n   *\r\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\r\n   */\r\n  RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  /**\r\n   * When a local audio track is published the SDK checks whether there is complete silence\r\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\r\n   * This allows for applications to show UI informing users that they might have to\r\n   * reset their audio hardware or check for proper device connectivity.\r\n   */\r\n  RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\r\n  /**\r\n   * Active speakers changed. List of speakers are ordered by their audio level.\r\n   * loudest speakers first. This will include the LocalParticipant too.\r\n   *\r\n   * Speaker updates are sent only to the publishing participant and their subscribers.\r\n   *\r\n   * args: (Array<[[Participant]]>)\r\n   */\r\n  RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\r\n  /**\r\n   * Participant metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\r\n   * state, *all*  participants in the room will fire this event.\r\n   *\r\n   * args: (prevMetadata: string, [[Participant]])\r\n   *\r\n   */\r\n  RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\r\n  /**\r\n   * Participant's display name changed\r\n   *\r\n   * args: (name: string, [[Participant]])\r\n   *\r\n   */\r\n  RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\r\n  /**\r\n   * Participant attributes is an app-specific key value state to be pushed to\r\n   * all users.\r\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\r\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\r\n  /**\r\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\r\n   *\r\n   * args: (participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantActive\"] = \"participantActive\";\r\n  /**\r\n   * Room metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\r\n   * *all*  participants in the room will fire this event.\r\n   *\r\n   * args: (string)\r\n   */\r\n  RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\r\n  /**\r\n   * Data received from another participant.\r\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\r\n   * All participants in the room will receive the messages sent to the room.\r\n   *\r\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\r\n   */\r\n  RoomEvent[\"DataReceived\"] = \"dataReceived\";\r\n  /**\r\n   * SIP DTMF tones received from another participant.\r\n   *\r\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\r\n   */\r\n  RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\r\n  /**\r\n   * Transcription received from a participant's track.\r\n   * @beta\r\n   */\r\n  RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * Connection quality was changed for a Participant. It'll receive updates\r\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\r\n   * subscribed to.\r\n   *\r\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\r\n  /**\r\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\r\n   * (typically this happens because of subscriber's bandwidth constraints)\r\n   *\r\n   * When bandwidth conditions allow, the track will be resumed automatically.\r\n   * TrackStreamStateChanged will also be emitted when that happens.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its permissions for the current\r\n   * participant. If permission was revoked, then the track will no longer\r\n   * be subscribed. If permission was granted, a TrackSubscribed event will\r\n   * be emitted.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.PermissionStatus]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its status for the current\r\n   * participant.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.SubscriptionStatus]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\r\n  /**\r\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\r\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\r\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\r\n   */\r\n  RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\r\n  /**\r\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\r\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\r\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\r\n   */\r\n  RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\r\n  /**\r\n   * When we have encountered an error while attempting to create a track.\r\n   * The errors take place in getUserMedia().\r\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\r\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\r\n   * will indicate if it had an error while creating the audio or video track respectively.\r\n   *\r\n   * args: (error: Error)\r\n   */\r\n  RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\r\n  /**\r\n   * A participant's permission has changed.\r\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\r\n  /**\r\n   * Signal connected, can publish tracks.\r\n   */\r\n  RoomEvent[\"SignalConnected\"] = \"signalConnected\";\r\n  /**\r\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\r\n   * args: (isRecording: boolean)\r\n   */\r\n  RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\r\n  RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\r\n  RoomEvent[\"EncryptionError\"] = \"encryptionError\";\r\n  /**\r\n   * Emits whenever the current buffer status of a data channel changes\r\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\r\n   */\r\n  RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\r\n  /**\r\n   * Triggered by a call to room.switchActiveDevice\r\n   * args: (kind: MediaDeviceKind, deviceId: string)\r\n   */\r\n  RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\r\n  RoomEvent[\"ChatMessage\"] = \"chatMessage\";\r\n  /**\r\n   * fired when the first remote participant has subscribed to the localParticipant's track\r\n   */\r\n  RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  /**\r\n   * fired when the client receives connection metrics from other participants\r\n   */\r\n  RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\r\n})(RoomEvent || (RoomEvent = {}));\r\nvar ParticipantEvent;\r\n(function (ParticipantEvent) {\r\n  /**\r\n   * When a new track is published to room *after* the local\r\n   * participant has joined. It will not fire for tracks that are already published.\r\n   *\r\n   * A track published doesn't mean the participant has subscribed to it. It's\r\n   * simply reflecting the state of the room.\r\n   *\r\n   * args: ([[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\r\n  /**\r\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\r\n   * This event will **always** fire as long as new tracks are ready for use.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\r\n  /**\r\n   * Could not subscribe to a track\r\n   *\r\n   * args: (track sid)\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\r\n  /**\r\n   * A [[RemoteParticipant]] has unpublished a track\r\n   *\r\n   * args: ([[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\r\n  /**\r\n   * A subscribed track is no longer available. Clients should listen to this\r\n   * event and ensure they detach tracks.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\r\n  /**\r\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\r\n  /**\r\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\r\n  /**\r\n   * A local track was published successfully. This event is helpful to know\r\n   * when to update your local UI with the newly published track.\r\n   *\r\n   * args: ([[LocalTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\r\n  /**\r\n   * A local track was unpublished. This event is helpful to know when to remove\r\n   * the local track from your UI.\r\n   *\r\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\r\n   * this event will also fire.\r\n   *\r\n   * args: ([[LocalTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  /**\r\n   * Participant metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\r\n   * state, *all*  participants in the room will fire this event.\r\n   * To access the current metadata, see [[Participant.metadata]].\r\n   *\r\n   * args: (prevMetadata: string)\r\n   *\r\n   */\r\n  ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\r\n  /**\r\n   * Participant's display name changed\r\n   *\r\n   * args: (name: string, [[Participant]])\r\n   *\r\n   */\r\n  ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\r\n  /**\r\n   * Data received from this participant as sender.\r\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\r\n   * All participants in the room will receive the messages sent to the room.\r\n   *\r\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\r\n   */\r\n  ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\r\n  /**\r\n   * SIP DTMF tones received from this participant as sender.\r\n   *\r\n   * args: (dtmf: [[DataPacket_Kind]])\r\n   */\r\n  ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\r\n  /**\r\n   * Transcription received from this participant as data source.\r\n   * @beta\r\n   */\r\n  ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * Has speaking status changed for the current participant\r\n   *\r\n   * args: (speaking: boolean)\r\n   */\r\n  ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\r\n  /**\r\n   * Connection quality was changed for a Participant. It'll receive updates\r\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\r\n   * subscribed to.\r\n   *\r\n   * args: (connectionQuality: [[ConnectionQuality]])\r\n   */\r\n  ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\r\n  /**\r\n   * StreamState indicates if a subscribed track has been paused by the SFU\r\n   * (typically this happens because of subscriber's bandwidth constraints)\r\n   *\r\n   * When bandwidth conditions allow, the track will be resumed automatically.\r\n   * TrackStreamStateChanged will also be emitted when that happens.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\r\n   */\r\n  ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its permissions for the current\r\n   * participant. If permission was revoked, then the track will no longer\r\n   * be subscribed. If permission was granted, a TrackSubscribed event will\r\n   * be emitted.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.SubscriptionStatus]])\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\r\n  /**\r\n   * One of the remote participants publications has changed its subscription status.\r\n   *\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\r\n  // fired only on LocalParticipant\r\n  /** @internal */\r\n  ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\r\n  // fired only on LocalParticipant\r\n  /** @internal */\r\n  ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\r\n  /**\r\n   * A participant's permission has changed.\r\n   * args: (prevPermissions: [[ParticipantPermission]])\r\n   */\r\n  ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\r\n  /** @internal */\r\n  ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\r\n  /**\r\n   * Participant attributes is an app-specific key value state to be pushed to\r\n   * all users.\r\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\r\n   * args: (changedAttributes: [[Record<string, string]])\r\n   */\r\n  ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\r\n  /**\r\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\r\n   */\r\n  ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  /** only emitted on local participant */\r\n  ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\r\n  /**\r\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\r\n   */\r\n  ParticipantEvent[\"Active\"] = \"active\";\r\n})(ParticipantEvent || (ParticipantEvent = {}));\r\n/** @internal */\r\nvar EngineEvent;\r\n(function (EngineEvent) {\r\n  EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\r\n  EngineEvent[\"Connected\"] = \"connected\";\r\n  EngineEvent[\"Disconnected\"] = \"disconnected\";\r\n  EngineEvent[\"Resuming\"] = \"resuming\";\r\n  EngineEvent[\"Resumed\"] = \"resumed\";\r\n  EngineEvent[\"Restarting\"] = \"restarting\";\r\n  EngineEvent[\"Restarted\"] = \"restarted\";\r\n  EngineEvent[\"SignalResumed\"] = \"signalResumed\";\r\n  EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\r\n  EngineEvent[\"Closing\"] = \"closing\";\r\n  EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\r\n  EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\r\n  EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\r\n  EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\r\n  EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\r\n  EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\r\n  EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\r\n  EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\r\n  EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\r\n  EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\r\n  EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\r\n  EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\r\n  EngineEvent[\"RemoteMute\"] = \"remoteMute\";\r\n  EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\r\n  EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  EngineEvent[\"Offline\"] = \"offline\";\r\n  EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\r\n  EngineEvent[\"SignalConnected\"] = \"signalConnected\";\r\n  EngineEvent[\"RoomMoved\"] = \"roomMoved\";\r\n})(EngineEvent || (EngineEvent = {}));\r\nvar TrackEvent;\r\n(function (TrackEvent) {\r\n  TrackEvent[\"Message\"] = \"message\";\r\n  TrackEvent[\"Muted\"] = \"muted\";\r\n  TrackEvent[\"Unmuted\"] = \"unmuted\";\r\n  /**\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"Restarted\"] = \"restarted\";\r\n  TrackEvent[\"Ended\"] = \"ended\";\r\n  TrackEvent[\"Subscribed\"] = \"subscribed\";\r\n  TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\r\n  /** @internal */\r\n  TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\r\n  /** @internal */\r\n  TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\r\n  /** @internal */\r\n  TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\r\n  /** @internal */\r\n  TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalAudioTrack instances\r\n   */\r\n  TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\r\n  /** @internal */\r\n  TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\r\n  /** @internal */\r\n  TrackEvent[\"ElementAttached\"] = \"elementAttached\";\r\n  /** @internal */\r\n  TrackEvent[\"ElementDetached\"] = \"elementDetached\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\r\n  /**\r\n   * @internal\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\r\n  /**\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\r\n  /**\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\r\n  /**\r\n   * @beta\r\n   */\r\n  TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * @experimental\r\n   */\r\n  TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"PreConnectBufferFlushed\"] = \"preConnectBufferFlushed\";\r\n})(TrackEvent || (TrackEvent = {}));\r\n\r\nfunction cloneDeep(value) {\r\n  if (typeof value === 'undefined') {\r\n    return value;\r\n  }\r\n  if (typeof structuredClone === 'function') {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // ensure that the value is not a proxy by spreading it\r\n      return structuredClone(Object.assign({}, value));\r\n    }\r\n    return structuredClone(value);\r\n  } else {\r\n    return JSON.parse(JSON.stringify(value));\r\n  }\r\n}\r\n\r\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\r\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\r\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\r\nlet browserDetails;\r\n/**\r\n * @internal\r\n */\r\nfunction getBrowser(userAgent) {\r\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n  if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\r\n    return;\r\n  }\r\n  const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\r\n  if (browserDetails === undefined || force) {\r\n    const browser = browsersList.find(_ref => {\r\n      let {\r\n        test\r\n      } = _ref;\r\n      return test.test(ua);\r\n    });\r\n    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\r\n  }\r\n  return browserDetails;\r\n}\r\nconst browsersList = [{\r\n  test: /firefox|iceweasel|fxios/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Firefox',\r\n      version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\r\n      os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}, {\r\n  test: /chrom|crios|crmo/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Chrome',\r\n      version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\r\n      os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}, /* Safari */\r\n{\r\n  test: /safari|applewebkit/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Safari',\r\n      version: getMatch(commonVersionIdentifier, ua),\r\n      os: ua.includes('mobile/') ? 'iOS' : 'macOS',\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}];\r\nfunction getMatch(exp, ua) {\r\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\r\n  const match = ua.match(exp);\r\n  return match && match.length >= id && match[id] || '';\r\n}\r\nfunction getOSVersion(ua) {\r\n  return ua.includes('mac os') ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, '.') : undefined;\r\n}\r\n\r\nvar version$1 = \"2.13.5\";\r\n\r\nconst version = version$1;\r\nconst protocolVersion = 16;\r\n\r\n/**\r\n * Timers that can be overridden with platform specific implementations\r\n * that ensure that they are fired. These should be used when it is critical\r\n * that the timer fires on time.\r\n */\r\nclass CriticalTimers {}\r\nCriticalTimers.setTimeout = function () {\r\n  return setTimeout(...arguments);\r\n};\r\nCriticalTimers.setInterval =\r\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\r\nfunction () {\r\n  return setInterval(...arguments);\r\n};\r\nCriticalTimers.clearTimeout = function () {\r\n  return clearTimeout(...arguments);\r\n};\r\nCriticalTimers.clearInterval = function () {\r\n  return clearInterval(...arguments);\r\n};\r\n\r\nconst BACKGROUND_REACTION_DELAY = 5000;\r\n// keep old audio elements when detached, we would re-use them since on iOS\r\n// Safari tracks which audio elements have been \"blessed\" by the user.\r\nconst recycledElements = [];\r\nvar VideoQuality;\r\n(function (VideoQuality) {\r\n  VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\r\n  VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\r\n  VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\r\n})(VideoQuality || (VideoQuality = {}));\r\nclass Track extends eventsExports.EventEmitter {\r\n  constructor(mediaTrack, kind) {\r\n    let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var _a;\r\n    super();\r\n    this.attachedElements = [];\r\n    this.isMuted = false;\r\n    /**\r\n     * indicates current state of stream, it'll indicate `paused` if the track\r\n     * has been paused by congestion controller\r\n     */\r\n    this.streamState = Track.StreamState.Active;\r\n    this.isInBackground = false;\r\n    this._currentBitrate = 0;\r\n    this.log = livekitLogger;\r\n    this.appVisibilityChangedListener = () => {\r\n      if (this.backgroundTimeout) {\r\n        clearTimeout(this.backgroundTimeout);\r\n      }\r\n      // delay app visibility update if it goes to hidden\r\n      // update immediately if it comes back to focus\r\n      if (document.visibilityState === 'hidden') {\r\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\r\n      } else {\r\n        this.handleAppVisibilityChanged();\r\n      }\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\r\n    this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    this.setMaxListeners(100);\r\n    this.kind = kind;\r\n    this._mediaStreamTrack = mediaTrack;\r\n    this._mediaStreamID = mediaTrack.id;\r\n    this.source = Track.Source.Unknown;\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\r\n  }\r\n  /** current receive bits per second */\r\n  get currentBitrate() {\r\n    return this._currentBitrate;\r\n  }\r\n  get mediaStreamTrack() {\r\n    return this._mediaStreamTrack;\r\n  }\r\n  /**\r\n   * @internal\r\n   * used for keep mediaStream's first id, since it's id might change\r\n   * if we disable/enable a track\r\n   */\r\n  get mediaStreamID() {\r\n    return this._mediaStreamID;\r\n  }\r\n  attach(element) {\r\n    let elementType = 'audio';\r\n    if (this.kind === Track.Kind.Video) {\r\n      elementType = 'video';\r\n    }\r\n    if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\r\n      this.addAppVisibilityListener();\r\n    }\r\n    if (!element) {\r\n      if (elementType === 'audio') {\r\n        recycledElements.forEach(e => {\r\n          if (e.parentElement === null && !element) {\r\n            element = e;\r\n          }\r\n        });\r\n        if (element) {\r\n          // remove it from pool\r\n          recycledElements.splice(recycledElements.indexOf(element), 1);\r\n        }\r\n      }\r\n      if (!element) {\r\n        element = document.createElement(elementType);\r\n      }\r\n    }\r\n    if (!this.attachedElements.includes(element)) {\r\n      this.attachedElements.push(element);\r\n    }\r\n    // even if we believe it's already attached to the element, it's possible\r\n    // the element's srcObject was set to something else out of band.\r\n    // we'll want to re-attach it in that case\r\n    attachToElement(this.mediaStreamTrack, element);\r\n    // handle auto playback failures\r\n    const allMediaStreamTracks = element.srcObject.getTracks();\r\n    const hasAudio = allMediaStreamTracks.some(tr => tr.kind === 'audio');\r\n    // manually play media to detect auto playback status\r\n    element.play().then(() => {\r\n      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\r\n    }).catch(e => {\r\n      if (e.name === 'NotAllowedError') {\r\n        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\r\n      } else if (e.name === 'AbortError') {\r\n        // commonly triggered by another `play` request, only log for debugging purposes\r\n        livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\r\n      } else {\r\n        livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\r\n      }\r\n      // If audio playback isn't allowed make sure we still play back the video\r\n      if (hasAudio && element && allMediaStreamTracks.some(tr => tr.kind === 'video') && e.name === 'NotAllowedError') {\r\n        element.muted = true;\r\n        element.play().catch(() => {\r\n          // catch for Safari, exceeded options at this point to automatically play the media element\r\n        });\r\n      }\r\n    });\r\n    this.emit(TrackEvent.ElementAttached, element);\r\n    return element;\r\n  }\r\n  detach(element) {\r\n    try {\r\n      // detach from a single element\r\n      if (element) {\r\n        detachTrack(this.mediaStreamTrack, element);\r\n        const idx = this.attachedElements.indexOf(element);\r\n        if (idx >= 0) {\r\n          this.attachedElements.splice(idx, 1);\r\n          this.recycleElement(element);\r\n          this.emit(TrackEvent.ElementDetached, element);\r\n        }\r\n        return element;\r\n      }\r\n      const detached = [];\r\n      this.attachedElements.forEach(elm => {\r\n        detachTrack(this.mediaStreamTrack, elm);\r\n        detached.push(elm);\r\n        this.recycleElement(elm);\r\n        this.emit(TrackEvent.ElementDetached, elm);\r\n      });\r\n      // remove all tracks\r\n      this.attachedElements = [];\r\n      return detached;\r\n    } finally {\r\n      if (this.attachedElements.length === 0) {\r\n        this.removeAppVisibilityListener();\r\n      }\r\n    }\r\n  }\r\n  stop() {\r\n    this.stopMonitor();\r\n    this._mediaStreamTrack.stop();\r\n  }\r\n  enable() {\r\n    this._mediaStreamTrack.enabled = true;\r\n  }\r\n  disable() {\r\n    this._mediaStreamTrack.enabled = false;\r\n  }\r\n  /* @internal */\r\n  stopMonitor() {\r\n    if (this.monitorInterval) {\r\n      clearInterval(this.monitorInterval);\r\n    }\r\n    if (this.timeSyncHandle) {\r\n      cancelAnimationFrame(this.timeSyncHandle);\r\n    }\r\n  }\r\n  /** @internal */\r\n  updateLoggerOptions(loggerOptions) {\r\n    if (loggerOptions.loggerName) {\r\n      this.log = getLogger(loggerOptions.loggerName);\r\n    }\r\n    if (loggerOptions.loggerContextCb) {\r\n      this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    }\r\n  }\r\n  recycleElement(element) {\r\n    if (element instanceof HTMLAudioElement) {\r\n      // we only need to re-use a single element\r\n      let shouldCache = true;\r\n      element.pause();\r\n      recycledElements.forEach(e => {\r\n        if (!e.parentElement) {\r\n          shouldCache = false;\r\n        }\r\n      });\r\n      if (shouldCache) {\r\n        recycledElements.push(element);\r\n      }\r\n    }\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.isInBackground = document.visibilityState === 'hidden';\r\n      if (!this.isInBackground && this.kind === Track.Kind.Video) {\r\n        setTimeout(() => this.attachedElements.forEach(el => el.play().catch(() => {\r\n          /** catch clause necessary for Safari */\r\n        })), 0);\r\n      }\r\n    });\r\n  }\r\n  addAppVisibilityListener() {\r\n    if (isWeb()) {\r\n      this.isInBackground = document.visibilityState === 'hidden';\r\n      document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\r\n    } else {\r\n      this.isInBackground = false;\r\n    }\r\n  }\r\n  removeAppVisibilityListener() {\r\n    if (isWeb()) {\r\n      document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\r\n    }\r\n  }\r\n}\r\nfunction attachToElement(track, element) {\r\n  let mediaStream;\r\n  if (element.srcObject instanceof MediaStream) {\r\n    mediaStream = element.srcObject;\r\n  } else {\r\n    mediaStream = new MediaStream();\r\n  }\r\n  // check if track matches existing track\r\n  let existingTracks;\r\n  if (track.kind === 'audio') {\r\n    existingTracks = mediaStream.getAudioTracks();\r\n  } else {\r\n    existingTracks = mediaStream.getVideoTracks();\r\n  }\r\n  if (!existingTracks.includes(track)) {\r\n    existingTracks.forEach(et => {\r\n      mediaStream.removeTrack(et);\r\n    });\r\n    mediaStream.addTrack(track);\r\n  }\r\n  if (!isSafari() || !(element instanceof HTMLVideoElement)) {\r\n    // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\r\n    // when a video starts that has the `autoplay` attribute is set.\r\n    // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\r\n    element.autoplay = true;\r\n  }\r\n  // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\r\n  element.muted = mediaStream.getAudioTracks().length === 0;\r\n  if (element instanceof HTMLVideoElement) {\r\n    element.playsInline = true;\r\n  }\r\n  // avoid flicker\r\n  if (element.srcObject !== mediaStream) {\r\n    element.srcObject = mediaStream;\r\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\r\n      // Firefox also has a timing issue where video doesn't actually get attached unless\r\n      // performed out-of-band\r\n      // Safari 15 has a bug where in certain layouts, video element renders\r\n      // black until the page is resized or other changes take place.\r\n      // Resetting the src triggers it to render.\r\n      // https://developer.apple.com/forums/thread/690523\r\n      setTimeout(() => {\r\n        element.srcObject = mediaStream;\r\n        // Safari 15 sometimes fails to start a video\r\n        // when the window is backgrounded before the first frame is drawn\r\n        // manually calling play here seems to fix that\r\n        element.play().catch(() => {\r\n          /** do nothing */\r\n        });\r\n      }, 0);\r\n    }\r\n  }\r\n}\r\n/** @internal */\r\nfunction detachTrack(track, element) {\r\n  if (element.srcObject instanceof MediaStream) {\r\n    const mediaStream = element.srcObject;\r\n    mediaStream.removeTrack(track);\r\n    if (mediaStream.getTracks().length > 0) {\r\n      element.srcObject = mediaStream;\r\n    } else {\r\n      element.srcObject = null;\r\n    }\r\n  }\r\n}\r\n(function (Track) {\r\n  let Kind;\r\n  (function (Kind) {\r\n    Kind[\"Audio\"] = \"audio\";\r\n    Kind[\"Video\"] = \"video\";\r\n    Kind[\"Unknown\"] = \"unknown\";\r\n  })(Kind = Track.Kind || (Track.Kind = {}));\r\n  let Source;\r\n  (function (Source) {\r\n    Source[\"Camera\"] = \"camera\";\r\n    Source[\"Microphone\"] = \"microphone\";\r\n    Source[\"ScreenShare\"] = \"screen_share\";\r\n    Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\r\n    Source[\"Unknown\"] = \"unknown\";\r\n  })(Source = Track.Source || (Track.Source = {}));\r\n  let StreamState$1;\r\n  (function (StreamState) {\r\n    StreamState[\"Active\"] = \"active\";\r\n    StreamState[\"Paused\"] = \"paused\";\r\n    StreamState[\"Unknown\"] = \"unknown\";\r\n  })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\r\n  /** @internal */\r\n  function kindToProto(k) {\r\n    switch (k) {\r\n      case Kind.Audio:\r\n        return TrackType.AUDIO;\r\n      case Kind.Video:\r\n        return TrackType.VIDEO;\r\n      default:\r\n        // FIXME this was UNRECOGNIZED before\r\n        return TrackType.DATA;\r\n    }\r\n  }\r\n  Track.kindToProto = kindToProto;\r\n  /** @internal */\r\n  function kindFromProto(t) {\r\n    switch (t) {\r\n      case TrackType.AUDIO:\r\n        return Kind.Audio;\r\n      case TrackType.VIDEO:\r\n        return Kind.Video;\r\n      default:\r\n        return Kind.Unknown;\r\n    }\r\n  }\r\n  Track.kindFromProto = kindFromProto;\r\n  /** @internal */\r\n  function sourceToProto(s) {\r\n    switch (s) {\r\n      case Source.Camera:\r\n        return TrackSource.CAMERA;\r\n      case Source.Microphone:\r\n        return TrackSource.MICROPHONE;\r\n      case Source.ScreenShare:\r\n        return TrackSource.SCREEN_SHARE;\r\n      case Source.ScreenShareAudio:\r\n        return TrackSource.SCREEN_SHARE_AUDIO;\r\n      default:\r\n        return TrackSource.UNKNOWN;\r\n    }\r\n  }\r\n  Track.sourceToProto = sourceToProto;\r\n  /** @internal */\r\n  function sourceFromProto(s) {\r\n    switch (s) {\r\n      case TrackSource.CAMERA:\r\n        return Source.Camera;\r\n      case TrackSource.MICROPHONE:\r\n        return Source.Microphone;\r\n      case TrackSource.SCREEN_SHARE:\r\n        return Source.ScreenShare;\r\n      case TrackSource.SCREEN_SHARE_AUDIO:\r\n        return Source.ScreenShareAudio;\r\n      default:\r\n        return Source.Unknown;\r\n    }\r\n  }\r\n  Track.sourceFromProto = sourceFromProto;\r\n  /** @internal */\r\n  function streamStateFromProto(s) {\r\n    switch (s) {\r\n      case StreamState.ACTIVE:\r\n        return StreamState$1.Active;\r\n      case StreamState.PAUSED:\r\n        return StreamState$1.Paused;\r\n      default:\r\n        return StreamState$1.Unknown;\r\n    }\r\n  }\r\n  Track.streamStateFromProto = streamStateFromProto;\r\n})(Track || (Track = {}));\r\n\r\nclass VideoPreset {\r\n  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {\r\n    if (typeof widthOrOptions === 'object') {\r\n      this.width = widthOrOptions.width;\r\n      this.height = widthOrOptions.height;\r\n      this.aspectRatio = widthOrOptions.aspectRatio;\r\n      this.encoding = {\r\n        maxBitrate: widthOrOptions.maxBitrate,\r\n        maxFramerate: widthOrOptions.maxFramerate,\r\n        priority: widthOrOptions.priority\r\n      };\r\n    } else if (height !== undefined && maxBitrate !== undefined) {\r\n      this.width = widthOrOptions;\r\n      this.height = height;\r\n      this.aspectRatio = widthOrOptions / height;\r\n      this.encoding = {\r\n        maxBitrate,\r\n        maxFramerate,\r\n        priority\r\n      };\r\n    } else {\r\n      throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');\r\n    }\r\n  }\r\n  get resolution() {\r\n    return {\r\n      width: this.width,\r\n      height: this.height,\r\n      frameRate: this.encoding.maxFramerate,\r\n      aspectRatio: this.aspectRatio\r\n    };\r\n  }\r\n}\r\nconst backupCodecs = ['vp8', 'h264'];\r\nconst videoCodecs = ['vp8', 'h264', 'vp9', 'av1'];\r\nfunction isBackupCodec(codec) {\r\n  return !!backupCodecs.find(backup => backup === codec);\r\n}\r\nvar BackupCodecPolicy;\r\n(function (BackupCodecPolicy) {\r\n  // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\r\n  BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\r\n  // multi-codec simulcast, publish both primary and backup codec at the same time\r\n  BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\r\n  // always use backup codec only\r\n  BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\r\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\r\nvar AudioPresets;\r\n(function (AudioPresets) {\r\n  AudioPresets.telephone = {\r\n    maxBitrate: 12000\r\n  };\r\n  AudioPresets.speech = {\r\n    maxBitrate: 24000\r\n  };\r\n  AudioPresets.music = {\r\n    maxBitrate: 48000\r\n  };\r\n  AudioPresets.musicStereo = {\r\n    maxBitrate: 64000\r\n  };\r\n  AudioPresets.musicHighQuality = {\r\n    maxBitrate: 96000\r\n  };\r\n  AudioPresets.musicHighQualityStereo = {\r\n    maxBitrate: 128000\r\n  };\r\n})(AudioPresets || (AudioPresets = {}));\r\n/**\r\n * Sane presets for video resolution/encoding\r\n */\r\nconst VideoPresets = {\r\n  h90: new VideoPreset(160, 90, 90000, 20),\r\n  h180: new VideoPreset(320, 180, 160000, 20),\r\n  h216: new VideoPreset(384, 216, 180000, 20),\r\n  h360: new VideoPreset(640, 360, 450000, 20),\r\n  h540: new VideoPreset(960, 540, 800000, 25),\r\n  h720: new VideoPreset(1280, 720, 1700000, 30),\r\n  h1080: new VideoPreset(1920, 1080, 3000000, 30),\r\n  h1440: new VideoPreset(2560, 1440, 5000000, 30),\r\n  h2160: new VideoPreset(3840, 2160, 8000000, 30)\r\n};\r\n/**\r\n * Four by three presets\r\n */\r\nconst VideoPresets43 = {\r\n  h120: new VideoPreset(160, 120, 70000, 20),\r\n  h180: new VideoPreset(240, 180, 125000, 20),\r\n  h240: new VideoPreset(320, 240, 140000, 20),\r\n  h360: new VideoPreset(480, 360, 330000, 20),\r\n  h480: new VideoPreset(640, 480, 500000, 20),\r\n  h540: new VideoPreset(720, 540, 600000, 25),\r\n  h720: new VideoPreset(960, 720, 1300000, 30),\r\n  h1080: new VideoPreset(1440, 1080, 2300000, 30),\r\n  h1440: new VideoPreset(1920, 1440, 3800000, 30)\r\n};\r\nconst ScreenSharePresets = {\r\n  h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\r\n  h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\r\n  h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\r\n  h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\r\n  h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\r\n  h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\r\n  h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\r\n  // original resolution, without resizing\r\n  original: new VideoPreset(0, 0, 7000000, 30, 'medium')\r\n};\r\n\r\nconst separator = '|';\r\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\r\nfunction unpackStreamId(packed) {\r\n  const parts = packed.split(separator);\r\n  if (parts.length > 1) {\r\n    return [parts[0], packed.substr(parts[0].length + 1)];\r\n  }\r\n  return [packed, ''];\r\n}\r\nfunction sleep(duration) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    return new Promise(resolve => CriticalTimers.setTimeout(resolve, duration));\r\n  });\r\n}\r\n/** @internal */\r\nfunction supportsTransceiver() {\r\n  return 'addTransceiver' in RTCPeerConnection.prototype;\r\n}\r\n/** @internal */\r\nfunction supportsAddTrack() {\r\n  return 'addTrack' in RTCPeerConnection.prototype;\r\n}\r\nfunction supportsAdaptiveStream() {\r\n  return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\r\n}\r\nfunction supportsDynacast() {\r\n  return supportsTransceiver();\r\n}\r\nfunction supportsAV1() {\r\n  if (!('getCapabilities' in RTCRtpSender)) {\r\n    return false;\r\n  }\r\n  if (isSafari()) {\r\n    // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\r\n    return false;\r\n  }\r\n  const capabilities = RTCRtpSender.getCapabilities('video');\r\n  let hasAV1 = false;\r\n  if (capabilities) {\r\n    for (const codec of capabilities.codecs) {\r\n      if (codec.mimeType === 'video/AV1') {\r\n        hasAV1 = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return hasAV1;\r\n}\r\nfunction supportsVP9() {\r\n  if (!('getCapabilities' in RTCRtpSender)) {\r\n    return false;\r\n  }\r\n  if (isFireFox()) {\r\n    // technically speaking FireFox supports VP9, but SVC publishing is broken\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\r\n    return false;\r\n  }\r\n  if (isSafari()) {\r\n    const browser = getBrowser();\r\n    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\r\n      // Safari 16 and below does not support VP9\r\n      return false;\r\n    }\r\n  }\r\n  const capabilities = RTCRtpSender.getCapabilities('video');\r\n  let hasVP9 = false;\r\n  if (capabilities) {\r\n    for (const codec of capabilities.codecs) {\r\n      if (codec.mimeType === 'video/VP9') {\r\n        hasVP9 = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return hasVP9;\r\n}\r\nfunction isSVCCodec(codec) {\r\n  return codec === 'av1' || codec === 'vp9';\r\n}\r\nfunction supportsSetSinkId(elm) {\r\n  if (!document) {\r\n    return false;\r\n  }\r\n  if (!elm) {\r\n    elm = document.createElement('audio');\r\n  }\r\n  return 'setSinkId' in elm;\r\n}\r\nfunction isBrowserSupported() {\r\n  if (typeof RTCPeerConnection === 'undefined') {\r\n    return false;\r\n  }\r\n  return supportsTransceiver() || supportsAddTrack();\r\n}\r\nfunction isFireFox() {\r\n  var _a;\r\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\r\n}\r\nfunction isSafari() {\r\n  var _a;\r\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\r\n}\r\nfunction isSafariBased() {\r\n  const b = getBrowser();\r\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' || (b === null || b === void 0 ? void 0 : b.os) === 'iOS';\r\n}\r\nfunction isSafari17() {\r\n  const b = getBrowser();\r\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.');\r\n}\r\nfunction isSafariSvcApi(browser) {\r\n  if (!browser) {\r\n    browser = getBrowser();\r\n  }\r\n  // Safari 18.4 requires legacy svc api and scaleResolutionDown to be set\r\n  return (browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '18.3') > 0;\r\n}\r\nfunction isMobile() {\r\n  var _a, _b;\r\n  if (!isWeb()) return false;\r\n  return (\r\n    // @ts-expect-error `userAgentData` is not yet part of typescript\r\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)\r\n  );\r\n}\r\nfunction isE2EESimulcastSupported() {\r\n  const browser = getBrowser();\r\n  const supportedSafariVersion = '17.2'; // see https://bugs.webkit.org/show_bug.cgi?id=257803\r\n  if (browser) {\r\n    if (browser.name !== 'Safari' && browser.os !== 'iOS') {\r\n      return true;\r\n    } else if (browser.os === 'iOS' && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {\r\n      return true;\r\n    } else if (browser.name === 'Safari' && compareVersions(supportedSafariVersion, browser.version) >= 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}\r\nfunction isWeb() {\r\n  return typeof document !== 'undefined';\r\n}\r\nfunction isReactNative() {\r\n  // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\r\n  return navigator.product == 'ReactNative';\r\n}\r\nfunction isCloud(serverUrl) {\r\n  return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\r\n}\r\nfunction getLKReactNativeInfo() {\r\n  // global defined only for ReactNative.\r\n  // @ts-ignore\r\n  if (global && global.LiveKitReactNativeGlobal) {\r\n    // @ts-ignore\r\n    return global.LiveKitReactNativeGlobal;\r\n  }\r\n  return undefined;\r\n}\r\nfunction getReactNativeOs() {\r\n  if (!isReactNative()) {\r\n    return undefined;\r\n  }\r\n  let info = getLKReactNativeInfo();\r\n  if (info) {\r\n    return info.platform;\r\n  }\r\n  return undefined;\r\n}\r\nfunction getDevicePixelRatio() {\r\n  if (isWeb()) {\r\n    return window.devicePixelRatio;\r\n  }\r\n  if (isReactNative()) {\r\n    let info = getLKReactNativeInfo();\r\n    if (info) {\r\n      return info.devicePixelRatio;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\nfunction compareVersions(v1, v2) {\r\n  const parts1 = v1.split('.');\r\n  const parts2 = v2.split('.');\r\n  const k = Math.min(parts1.length, parts2.length);\r\n  for (let i = 0; i < k; ++i) {\r\n    const p1 = parseInt(parts1[i], 10);\r\n    const p2 = parseInt(parts2[i], 10);\r\n    if (p1 > p2) return 1;\r\n    if (p1 < p2) return -1;\r\n    if (i === k - 1 && p1 === p2) return 0;\r\n  }\r\n  if (v1 === '' && v2 !== '') {\r\n    return -1;\r\n  } else if (v2 === '') {\r\n    return 1;\r\n  }\r\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\r\n}\r\nfunction roDispatchCallback(entries) {\r\n  for (const entry of entries) {\r\n    entry.target.handleResize(entry);\r\n  }\r\n}\r\nfunction ioDispatchCallback(entries) {\r\n  for (const entry of entries) {\r\n    entry.target.handleVisibilityChanged(entry);\r\n  }\r\n}\r\nlet resizeObserver = null;\r\nconst getResizeObserver = () => {\r\n  if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\r\n  return resizeObserver;\r\n};\r\nlet intersectionObserver = null;\r\nconst getIntersectionObserver = () => {\r\n  if (!intersectionObserver) {\r\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\r\n      root: null,\r\n      rootMargin: '0px'\r\n    });\r\n  }\r\n  return intersectionObserver;\r\n};\r\nfunction getClientInfo() {\r\n  var _a;\r\n  const info = new ClientInfo({\r\n    sdk: ClientInfo_SDK.JS,\r\n    protocol: protocolVersion,\r\n    version\r\n  });\r\n  if (isReactNative()) {\r\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\r\n  }\r\n  return info;\r\n}\r\nlet emptyVideoStreamTrack;\r\nfunction getEmptyVideoStreamTrack() {\r\n  if (!emptyVideoStreamTrack) {\r\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\r\n  }\r\n  return emptyVideoStreamTrack.clone();\r\n}\r\nfunction createDummyVideoStreamTrack() {\r\n  let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\r\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\r\n  let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n  const canvas = document.createElement('canvas');\r\n  // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  const ctx = canvas.getContext('2d');\r\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  if (paintContent && ctx) {\r\n    ctx.beginPath();\r\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\r\n    ctx.closePath();\r\n    ctx.fillStyle = 'grey';\r\n    ctx.fill();\r\n  }\r\n  // @ts-ignore\r\n  const dummyStream = canvas.captureStream();\r\n  const [dummyTrack] = dummyStream.getTracks();\r\n  if (!dummyTrack) {\r\n    throw Error('Could not get empty media stream video track');\r\n  }\r\n  dummyTrack.enabled = enabled;\r\n  return dummyTrack;\r\n}\r\nlet emptyAudioStreamTrack;\r\nfunction getEmptyAudioStreamTrack() {\r\n  if (!emptyAudioStreamTrack) {\r\n    // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\r\n    const ctx = new AudioContext();\r\n    const oscillator = ctx.createOscillator();\r\n    const gain = ctx.createGain();\r\n    gain.gain.setValueAtTime(0, 0);\r\n    const dst = ctx.createMediaStreamDestination();\r\n    oscillator.connect(gain);\r\n    gain.connect(dst);\r\n    oscillator.start();\r\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\r\n    if (!emptyAudioStreamTrack) {\r\n      throw Error('Could not get empty media stream audio track');\r\n    }\r\n    emptyAudioStreamTrack.enabled = false;\r\n  }\r\n  return emptyAudioStreamTrack.clone();\r\n}\r\nclass Future {\r\n  constructor(futureBase, onFinally) {\r\n    this.onFinally = onFinally;\r\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n      if (futureBase) {\r\n        yield futureBase(resolve, reject);\r\n      }\r\n    })).finally(() => {\r\n      var _a;\r\n      return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    });\r\n  }\r\n}\r\n/**\r\n * Creates and returns an analyser web audio node that is attached to the provided track.\r\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\r\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\r\n */\r\nfunction createAudioAnalyser(track, options) {\r\n  const opts = Object.assign({\r\n    cloneTrack: false,\r\n    fftSize: 2048,\r\n    smoothingTimeConstant: 0.8,\r\n    minDecibels: -100,\r\n    maxDecibels: -80\r\n  }, options);\r\n  const audioContext = getNewAudioContext();\r\n  if (!audioContext) {\r\n    throw new Error('Audio Context not supported on this browser');\r\n  }\r\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\r\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\r\n  const analyser = audioContext.createAnalyser();\r\n  analyser.minDecibels = opts.minDecibels;\r\n  analyser.maxDecibels = opts.maxDecibels;\r\n  analyser.fftSize = opts.fftSize;\r\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\r\n  mediaStreamSource.connect(analyser);\r\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n  /**\r\n   * Calculates the current volume of the track in the range from 0 to 1\r\n   */\r\n  const calculateVolume = () => {\r\n    analyser.getByteFrequencyData(dataArray);\r\n    let sum = 0;\r\n    for (const amplitude of dataArray) {\r\n      sum += Math.pow(amplitude / 255, 2);\r\n    }\r\n    const volume = Math.sqrt(sum / dataArray.length);\r\n    return volume;\r\n  };\r\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\r\n    yield audioContext.close();\r\n    if (opts.cloneTrack) {\r\n      streamTrack.stop();\r\n    }\r\n  });\r\n  return {\r\n    calculateVolume,\r\n    analyser,\r\n    cleanup\r\n  };\r\n}\r\nfunction isVideoCodec(maybeCodec) {\r\n  return videoCodecs.includes(maybeCodec);\r\n}\r\nfunction unwrapConstraint(constraint) {\r\n  if (typeof constraint === 'string' || typeof constraint === 'number') {\r\n    return constraint;\r\n  }\r\n  if (Array.isArray(constraint)) {\r\n    return constraint[0];\r\n  }\r\n  if (constraint.exact) {\r\n    if (Array.isArray(constraint.exact)) {\r\n      return constraint.exact[0];\r\n    }\r\n    return constraint.exact;\r\n  }\r\n  if (constraint.ideal) {\r\n    if (Array.isArray(constraint.ideal)) {\r\n      return constraint.ideal[0];\r\n    }\r\n    return constraint.ideal;\r\n  }\r\n  throw Error('could not unwrap constraint');\r\n}\r\nfunction toWebsocketUrl(url) {\r\n  if (url.startsWith('http')) {\r\n    return url.replace(/^(http)/, 'ws');\r\n  }\r\n  return url;\r\n}\r\nfunction toHttpUrl(url) {\r\n  if (url.startsWith('ws')) {\r\n    return url.replace(/^(ws)/, 'http');\r\n  }\r\n  return url;\r\n}\r\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\r\n  return transcription.segments.map(_ref => {\r\n    let {\r\n      id,\r\n      text,\r\n      language,\r\n      startTime,\r\n      endTime,\r\n      final\r\n    } = _ref;\r\n    var _a;\r\n    const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\r\n    const lastReceivedTime = Date.now();\r\n    if (final) {\r\n      firstReceivedTimesMap.delete(id);\r\n    } else {\r\n      firstReceivedTimesMap.set(id, firstReceivedTime);\r\n    }\r\n    return {\r\n      id,\r\n      text,\r\n      startTime: Number.parseInt(startTime.toString()),\r\n      endTime: Number.parseInt(endTime.toString()),\r\n      final,\r\n      language,\r\n      firstReceivedTime,\r\n      lastReceivedTime\r\n    };\r\n  });\r\n}\r\nfunction extractChatMessage(msg) {\r\n  const {\r\n    id,\r\n    timestamp,\r\n    message,\r\n    editTimestamp\r\n  } = msg;\r\n  return {\r\n    id,\r\n    timestamp: Number.parseInt(timestamp.toString()),\r\n    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\r\n    message\r\n  };\r\n}\r\nfunction getDisconnectReasonFromConnectionError(e) {\r\n  switch (e.reason) {\r\n    case ConnectionErrorReason.LeaveRequest:\r\n      return e.context;\r\n    case ConnectionErrorReason.Cancelled:\r\n      return DisconnectReason.CLIENT_INITIATED;\r\n    case ConnectionErrorReason.NotAllowed:\r\n      return DisconnectReason.USER_REJECTED;\r\n    case ConnectionErrorReason.ServerUnreachable:\r\n      return DisconnectReason.JOIN_FAILURE;\r\n    default:\r\n      return DisconnectReason.UNKNOWN_REASON;\r\n  }\r\n}\r\n/** convert bigints to numbers preserving undefined values */\r\nfunction bigIntToNumber(value) {\r\n  return value !== undefined ? Number(value) : undefined;\r\n}\r\n/** convert numbers to bigints preserving undefined values */\r\nfunction numberToBigInt(value) {\r\n  return value !== undefined ? BigInt(value) : undefined;\r\n}\r\nfunction isLocalTrack(track) {\r\n  return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\r\n}\r\nfunction isAudioTrack(track) {\r\n  return !!track && track.kind == Track.Kind.Audio;\r\n}\r\nfunction isVideoTrack(track) {\r\n  return !!track && track.kind == Track.Kind.Video;\r\n}\r\nfunction isLocalVideoTrack(track) {\r\n  return isLocalTrack(track) && isVideoTrack(track);\r\n}\r\nfunction isLocalAudioTrack(track) {\r\n  return isLocalTrack(track) && isAudioTrack(track);\r\n}\r\nfunction isRemoteTrack(track) {\r\n  return !!track && !track.isLocal;\r\n}\r\nfunction isRemotePub(pub) {\r\n  return !!pub && !pub.isLocal;\r\n}\r\nfunction isRemoteVideoTrack(track) {\r\n  return isRemoteTrack(track) && isVideoTrack(track);\r\n}\r\nfunction isLocalParticipant(p) {\r\n  return p.isLocal;\r\n}\r\nfunction isRemoteParticipant(p) {\r\n  return !p.isLocal;\r\n}\r\nfunction splitUtf8(s, n) {\r\n  // adapted from https://stackoverflow.com/a/6043797\r\n  const result = [];\r\n  let encoded = new TextEncoder().encode(s);\r\n  while (encoded.length > n) {\r\n    let k = n;\r\n    while (k > 0) {\r\n      const byte = encoded[k];\r\n      if (byte !== undefined && (byte & 0xc0) !== 0x80) {\r\n        break;\r\n      }\r\n      k--;\r\n    }\r\n    result.push(encoded.slice(0, k));\r\n    encoded = encoded.slice(k);\r\n  }\r\n  if (encoded.length > 0) {\r\n    result.push(encoded);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\r\n  var _a, _b;\r\n  var _c, _d;\r\n  const {\r\n    optionsWithoutProcessor,\r\n    audioProcessor,\r\n    videoProcessor\r\n  } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\r\n  const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\r\n  const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\r\n  const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\r\n  if (clonedOptions.audio === true) clonedOptions.audio = {};\r\n  if (clonedOptions.video === true) clonedOptions.video = {};\r\n  // use defaults\r\n  if (clonedOptions.audio) {\r\n    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\r\n    (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\r\n      ideal: 'default'\r\n    };\r\n    if (audioProcessor || defaultAudioProcessor) {\r\n      clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\r\n    }\r\n  }\r\n  if (clonedOptions.video) {\r\n    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\r\n    (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\r\n      ideal: 'default'\r\n    };\r\n    if (videoProcessor || defaultVideoProcessor) {\r\n      clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\r\n    }\r\n  }\r\n  return clonedOptions;\r\n}\r\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\r\n  Object.keys(objectToMerge).forEach(key => {\r\n    if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\r\n  });\r\n  return mainObject;\r\n}\r\nfunction constraintsForOptions(options) {\r\n  var _a, _b;\r\n  var _c, _d;\r\n  const constraints = {};\r\n  if (options.video) {\r\n    // default video options\r\n    if (typeof options.video === 'object') {\r\n      const videoOptions = {};\r\n      const target = videoOptions;\r\n      const source = options.video;\r\n      Object.keys(source).forEach(key => {\r\n        switch (key) {\r\n          case 'resolution':\r\n            // flatten VideoResolution fields\r\n            mergeObjectWithoutOverwriting(target, source.resolution);\r\n            break;\r\n          default:\r\n            target[key] = source[key];\r\n        }\r\n      });\r\n      constraints.video = videoOptions;\r\n      (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\r\n        ideal: 'default'\r\n      };\r\n    } else {\r\n      constraints.video = options.video ? {\r\n        deviceId: {\r\n          ideal: 'default'\r\n        }\r\n      } : false;\r\n    }\r\n  } else {\r\n    constraints.video = false;\r\n  }\r\n  if (options.audio) {\r\n    if (typeof options.audio === 'object') {\r\n      constraints.audio = options.audio;\r\n      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\r\n        ideal: 'default'\r\n      };\r\n    } else {\r\n      constraints.audio = {\r\n        deviceId: {\r\n          ideal: 'default'\r\n        }\r\n      };\r\n    }\r\n  } else {\r\n    constraints.audio = false;\r\n  }\r\n  return constraints;\r\n}\r\n/**\r\n * This function detects silence on a given [[Track]] instance.\r\n * Returns true if the track seems to be entirely silent.\r\n */\r\nfunction detectSilence(track_1) {\r\n  return __awaiter(this, arguments, void 0, function (track) {\r\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\r\n    return function* () {\r\n      const ctx = getNewAudioContext();\r\n      if (ctx) {\r\n        const analyser = ctx.createAnalyser();\r\n        analyser.fftSize = 2048;\r\n        const bufferLength = analyser.frequencyBinCount;\r\n        const dataArray = new Uint8Array(bufferLength);\r\n        const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\r\n        source.connect(analyser);\r\n        yield sleep(timeOffset);\r\n        analyser.getByteTimeDomainData(dataArray);\r\n        const someNoise = dataArray.some(sample => sample !== 128 && sample !== 0);\r\n        ctx.close();\r\n        return !someNoise;\r\n      }\r\n      return false;\r\n    }();\r\n  });\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction getNewAudioContext() {\r\n  var _a;\r\n  const AudioContext =\r\n  // @ts-ignore\r\n  typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\r\n  if (AudioContext) {\r\n    const audioContext = new AudioContext({\r\n      latencyHint: 'interactive'\r\n    });\r\n    // If the audio context is suspended, we need to resume it when the user clicks on the page\r\n    if (audioContext.state === 'suspended' && typeof window !== 'undefined' && ((_a = window.document) === null || _a === void 0 ? void 0 : _a.body)) {\r\n      const handleResume = () => __awaiter(this, void 0, void 0, function* () {\r\n        var _a;\r\n        try {\r\n          if (audioContext.state === 'suspended') {\r\n            yield audioContext.resume();\r\n          }\r\n        } catch (e) {\r\n          console.warn('Error trying to auto-resume audio context', e);\r\n        }\r\n        (_a = window.document.body) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', handleResume);\r\n      });\r\n      window.document.body.addEventListener('click', handleResume);\r\n    }\r\n    return audioContext;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction kindToSource(kind) {\r\n  if (kind === 'audioinput') {\r\n    return Track.Source.Microphone;\r\n  } else if (kind === 'videoinput') {\r\n    return Track.Source.Camera;\r\n  } else {\r\n    return Track.Source.Unknown;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction sourceToKind(source) {\r\n  if (source === Track.Source.Microphone) {\r\n    return 'audioinput';\r\n  } else if (source === Track.Source.Camera) {\r\n    return 'videoinput';\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction screenCaptureToDisplayMediaStreamOptions(options) {\r\n  var _a, _b;\r\n  let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\r\n  // treat 0 as uncapped\r\n  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\r\n    videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\r\n    if (isSafari()) {\r\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\r\n        width: {\r\n          max: options.resolution.width\r\n        },\r\n        height: {\r\n          max: options.resolution.height\r\n        },\r\n        frameRate: options.resolution.frameRate\r\n      });\r\n    } else {\r\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\r\n        width: {\r\n          ideal: options.resolution.width\r\n        },\r\n        height: {\r\n          ideal: options.resolution.height\r\n        },\r\n        frameRate: options.resolution.frameRate\r\n      });\r\n    }\r\n  }\r\n  return {\r\n    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\r\n    video: videoConstraints,\r\n    // @ts-expect-error support for experimental display media features\r\n    controller: options.controller,\r\n    selfBrowserSurface: options.selfBrowserSurface,\r\n    surfaceSwitching: options.surfaceSwitching,\r\n    systemAudio: options.systemAudio,\r\n    preferCurrentTab: options.preferCurrentTab\r\n  };\r\n}\r\nfunction mimeTypeToVideoCodecString(mimeType) {\r\n  return mimeType.split('/')[1].toLowerCase();\r\n}\r\nfunction getTrackPublicationInfo(tracks) {\r\n  const infos = [];\r\n  tracks.forEach(track => {\r\n    if (track.track !== undefined) {\r\n      infos.push(new TrackPublishedResponse({\r\n        cid: track.track.mediaStreamID,\r\n        track: track.trackInfo\r\n      }));\r\n    }\r\n  });\r\n  return infos;\r\n}\r\nfunction getLogContextFromTrack(track) {\r\n  if ('mediaStreamTrack' in track) {\r\n    return {\r\n      trackID: track.sid,\r\n      source: track.source,\r\n      muted: track.isMuted,\r\n      enabled: track.mediaStreamTrack.enabled,\r\n      kind: track.kind,\r\n      streamID: track.mediaStreamID,\r\n      streamTrackID: track.mediaStreamTrack.id\r\n    };\r\n  } else {\r\n    return {\r\n      trackID: track.trackSid,\r\n      enabled: track.isEnabled,\r\n      muted: track.isMuted,\r\n      trackInfo: Object.assign({\r\n        mimeType: track.mimeType,\r\n        name: track.trackName,\r\n        encrypted: track.isEncrypted,\r\n        kind: track.kind,\r\n        source: track.source\r\n      }, track.track ? getLogContextFromTrack(track.track) : {})\r\n    };\r\n  }\r\n}\r\nfunction supportsSynchronizationSources() {\r\n  return typeof RTCRtpReceiver !== 'undefined' && 'getSynchronizationSources' in RTCRtpReceiver;\r\n}\r\nfunction diffAttributes(oldValues, newValues) {\r\n  var _a;\r\n  if (oldValues === undefined) {\r\n    oldValues = {};\r\n  }\r\n  if (newValues === undefined) {\r\n    newValues = {};\r\n  }\r\n  const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];\r\n  const diff = {};\r\n  for (const key of allKeys) {\r\n    if (oldValues[key] !== newValues[key]) {\r\n      diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n  }\r\n  return diff;\r\n}\r\n/** @internal */\r\nfunction extractProcessorsFromOptions(options) {\r\n  const newOptions = Object.assign({}, options);\r\n  let audioProcessor;\r\n  let videoProcessor;\r\n  if (typeof newOptions.audio === 'object' && newOptions.audio.processor) {\r\n    audioProcessor = newOptions.audio.processor;\r\n    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\r\n      processor: undefined\r\n    });\r\n  }\r\n  if (typeof newOptions.video === 'object' && newOptions.video.processor) {\r\n    videoProcessor = newOptions.video.processor;\r\n    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\r\n      processor: undefined\r\n    });\r\n  }\r\n  return {\r\n    audioProcessor,\r\n    videoProcessor,\r\n    optionsWithoutProcessor: cloneDeep(newOptions)\r\n  };\r\n}\r\nfunction getTrackSourceFromProto(source) {\r\n  switch (source) {\r\n    case TrackSource.CAMERA:\r\n      return Track.Source.Camera;\r\n    case TrackSource.MICROPHONE:\r\n      return Track.Source.Microphone;\r\n    case TrackSource.SCREEN_SHARE:\r\n      return Track.Source.ScreenShare;\r\n    case TrackSource.SCREEN_SHARE_AUDIO:\r\n      return Track.Source.ScreenShareAudio;\r\n    default:\r\n      return Track.Source.Unknown;\r\n  }\r\n}\r\n\r\n/**\r\n * @experimental\r\n */\r\nclass E2EEManager extends eventsExports.EventEmitter {\r\n  constructor(options) {\r\n    super();\r\n    this.onWorkerMessage = ev => {\r\n      var _a, _b;\r\n      const {\r\n        kind,\r\n        data\r\n      } = ev.data;\r\n      switch (kind) {\r\n        case 'error':\r\n          livekitLogger.error(data.error.message);\r\n          this.emit(EncryptionEvent.EncryptionError, data.error);\r\n          break;\r\n        case 'initAck':\r\n          if (data.enabled) {\r\n            this.keyProvider.getKeys().forEach(keyInfo => {\r\n              this.postKey(keyInfo);\r\n            });\r\n          }\r\n          break;\r\n        case 'enable':\r\n          if (data.enabled) {\r\n            this.keyProvider.getKeys().forEach(keyInfo => {\r\n              this.postKey(keyInfo);\r\n            });\r\n          }\r\n          if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\r\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\r\n            this.encryptionEnabled = data.enabled;\r\n          } else if (data.participantIdentity) {\r\n            const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\r\n            if (!participant) {\r\n              throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\r\n            }\r\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\r\n          }\r\n          break;\r\n        case 'ratchetKey':\r\n          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.ratchetResult, data.participantIdentity, data.keyIndex);\r\n          break;\r\n      }\r\n    };\r\n    this.onWorkerError = ev => {\r\n      livekitLogger.error('e2ee worker encountered an error:', {\r\n        error: ev.error\r\n      });\r\n      this.emit(EncryptionEvent.EncryptionError, ev.error);\r\n    };\r\n    this.keyProvider = options.keyProvider;\r\n    this.worker = options.worker;\r\n    this.encryptionEnabled = false;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setup(room) {\r\n    if (!isE2EESupported()) {\r\n      throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\r\n    }\r\n    livekitLogger.info('setting up e2ee');\r\n    if (room !== this.room) {\r\n      this.room = room;\r\n      this.setupEventListeners(room, this.keyProvider);\r\n      // this.worker = new Worker('');\r\n      const msg = {\r\n        kind: 'init',\r\n        data: {\r\n          keyProviderOptions: this.keyProvider.getOptions(),\r\n          loglevel: workerLogger.getLevel()\r\n        }\r\n      };\r\n      if (this.worker) {\r\n        livekitLogger.info(\"initializing worker\", {\r\n          worker: this.worker\r\n        });\r\n        this.worker.onmessage = this.onWorkerMessage;\r\n        this.worker.onerror = this.onWorkerError;\r\n        this.worker.postMessage(msg);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setParticipantCryptorEnabled(enabled, participantIdentity) {\r\n    livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\r\n    this.postEnable(enabled, participantIdentity);\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setSifTrailer(trailer) {\r\n    if (!trailer || trailer.length === 0) {\r\n      livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\r\n    } else {\r\n      this.postSifTrailer(trailer);\r\n    }\r\n  }\r\n  setupEngine(engine) {\r\n    engine.on(EngineEvent.RTPVideoMapUpdate, rtpMap => {\r\n      this.postRTPMap(rtpMap);\r\n    });\r\n  }\r\n  setupEventListeners(room, keyProvider) {\r\n    room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\r\n    room.on(RoomEvent.ConnectionStateChanged, state => {\r\n      if (state === ConnectionState.Connected) {\r\n        room.remoteParticipants.forEach(participant => {\r\n          participant.trackPublications.forEach(pub => {\r\n            this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\r\n          });\r\n        });\r\n      }\r\n    }).on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {\r\n      var _a;\r\n      const msg = {\r\n        kind: 'removeTransform',\r\n        data: {\r\n          participantIdentity: participant.identity,\r\n          trackId: track.mediaStreamID\r\n        }\r\n      };\r\n      (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\r\n    }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {\r\n      this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\r\n    }).on(RoomEvent.SignalConnected, () => {\r\n      if (!this.room) {\r\n        throw new TypeError(\"expected room to be present on signal connect\");\r\n      }\r\n      keyProvider.getKeys().forEach(keyInfo => {\r\n        this.postKey(keyInfo);\r\n      });\r\n      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\r\n    });\r\n    room.localParticipant.on(ParticipantEvent.LocalTrackPublished, publication => __awaiter(this, void 0, void 0, function* () {\r\n      this.setupE2EESender(publication.track, publication.track.sender);\r\n    }));\r\n    keyProvider.on(KeyProviderEvent.SetKey, keyInfo => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));\r\n  }\r\n  postRatchetRequest(participantIdentity, keyIndex) {\r\n    if (!this.worker) {\r\n      throw Error('could not ratchet key, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'ratchetRequest',\r\n      data: {\r\n        participantIdentity: participantIdentity,\r\n        keyIndex\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postKey(_ref) {\r\n    let {\r\n      key,\r\n      participantIdentity,\r\n      keyIndex\r\n    } = _ref;\r\n    var _a;\r\n    if (!this.worker) {\r\n      throw Error('could not set key, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setKey',\r\n      data: {\r\n        participantIdentity: participantIdentity,\r\n        isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\r\n        key,\r\n        keyIndex\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postEnable(enabled, participantIdentity) {\r\n    if (this.worker) {\r\n      const enableMsg = {\r\n        kind: 'enable',\r\n        data: {\r\n          enabled,\r\n          participantIdentity\r\n        }\r\n      };\r\n      this.worker.postMessage(enableMsg);\r\n    } else {\r\n      throw new ReferenceError('failed to enable e2ee, worker is not ready');\r\n    }\r\n  }\r\n  postRTPMap(map) {\r\n    var _a;\r\n    if (!this.worker) {\r\n      throw TypeError('could not post rtp map, worker is missing');\r\n    }\r\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\r\n      throw TypeError('could not post rtp map, local participant identity is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setRTPMap',\r\n      data: {\r\n        map,\r\n        participantIdentity: this.room.localParticipant.identity\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postSifTrailer(trailer) {\r\n    if (!this.worker) {\r\n      throw Error('could not post SIF trailer, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setSifTrailer',\r\n      data: {\r\n        trailer\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  setupE2EEReceiver(track, remoteId, trackInfo) {\r\n    if (!track.receiver) {\r\n      return;\r\n    }\r\n    if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\r\n      throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\r\n    }\r\n    this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\r\n  }\r\n  setupE2EESender(track, sender) {\r\n    if (!isLocalTrack(track) || !sender) {\r\n      if (!sender) livekitLogger.warn('early return because sender is not ready');\r\n      return;\r\n    }\r\n    this.handleSender(sender, track.mediaStreamID, undefined);\r\n  }\r\n  /**\r\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\r\n   * a frame decoder.\r\n   *\r\n   */\r\n  handleReceiver(receiver, trackId, participantIdentity, codec) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.worker) {\r\n        return;\r\n      }\r\n      if (isScriptTransformSupported()) {\r\n        const options = {\r\n          kind: 'decode',\r\n          participantIdentity,\r\n          trackId,\r\n          codec\r\n        };\r\n        // @ts-ignore\r\n        receiver.transform = new RTCRtpScriptTransform(this.worker, options);\r\n      } else {\r\n        if (E2EE_FLAG in receiver && codec) {\r\n          // only update codec\r\n          const msg = {\r\n            kind: 'updateCodec',\r\n            data: {\r\n              trackId,\r\n              codec,\r\n              participantIdentity: participantIdentity\r\n            }\r\n          };\r\n          this.worker.postMessage(msg);\r\n          return;\r\n        }\r\n        // @ts-ignore\r\n        let writable = receiver.writableStream;\r\n        // @ts-ignore\r\n        let readable = receiver.readableStream;\r\n        if (!writable || !readable) {\r\n          // @ts-ignore\r\n          const receiverStreams = receiver.createEncodedStreams();\r\n          // @ts-ignore\r\n          receiver.writableStream = receiverStreams.writable;\r\n          writable = receiverStreams.writable;\r\n          // @ts-ignore\r\n          receiver.readableStream = receiverStreams.readable;\r\n          readable = receiverStreams.readable;\r\n        }\r\n        const msg = {\r\n          kind: 'decode',\r\n          data: {\r\n            readableStream: readable,\r\n            writableStream: writable,\r\n            trackId: trackId,\r\n            codec,\r\n            participantIdentity: participantIdentity\r\n          }\r\n        };\r\n        this.worker.postMessage(msg, [readable, writable]);\r\n      }\r\n      // @ts-ignore\r\n      receiver[E2EE_FLAG] = true;\r\n    });\r\n  }\r\n  /**\r\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\r\n   * a frame encoder.\r\n   *\r\n   */\r\n  handleSender(sender, trackId, codec) {\r\n    var _a;\r\n    if (E2EE_FLAG in sender || !this.worker) {\r\n      return;\r\n    }\r\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\r\n      throw TypeError('local identity needs to be known in order to set up encrypted sender');\r\n    }\r\n    if (isScriptTransformSupported()) {\r\n      livekitLogger.info('initialize script transform');\r\n      const options = {\r\n        kind: 'encode',\r\n        participantIdentity: this.room.localParticipant.identity,\r\n        trackId,\r\n        codec\r\n      };\r\n      // @ts-ignore\r\n      sender.transform = new RTCRtpScriptTransform(this.worker, options);\r\n    } else {\r\n      livekitLogger.info('initialize encoded streams');\r\n      // @ts-ignore\r\n      const senderStreams = sender.createEncodedStreams();\r\n      const msg = {\r\n        kind: 'encode',\r\n        data: {\r\n          readableStream: senderStreams.readable,\r\n          writableStream: senderStreams.writable,\r\n          codec,\r\n          trackId,\r\n          participantIdentity: this.room.localParticipant.identity\r\n        }\r\n      };\r\n      this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);\r\n    }\r\n    // @ts-ignore\r\n    sender[E2EE_FLAG] = true;\r\n  }\r\n}\r\n\r\nconst defaultId = 'default';\r\nclass DeviceManager {\r\n  constructor() {\r\n    this._previousDevices = [];\r\n  }\r\n  static getInstance() {\r\n    if (this.instance === undefined) {\r\n      this.instance = new DeviceManager();\r\n    }\r\n    return this.instance;\r\n  }\r\n  get previousDevices() {\r\n    return this._previousDevices;\r\n  }\r\n  getDevices(kind_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind) {\r\n      var _this = this;\r\n      let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a;\r\n        if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\r\n          livekitLogger.debug('awaiting getUserMedia promise');\r\n          try {\r\n            if (kind) {\r\n              yield DeviceManager.userMediaPromiseMap.get(kind);\r\n            } else {\r\n              yield Promise.all(DeviceManager.userMediaPromiseMap.values());\r\n            }\r\n          } catch (e) {\r\n            livekitLogger.warn('error waiting for media permissons');\r\n          }\r\n        }\r\n        let devices = yield navigator.mediaDevices.enumerateDevices();\r\n        if (requestPermissions &&\r\n        // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\r\n        !(isSafari() && _this.hasDeviceInUse(kind))) {\r\n          const isDummyDeviceOrEmpty = devices.filter(d => d.kind === kind).length === 0 || devices.some(device => {\r\n            const noLabel = device.label === '';\r\n            const isRelevant = kind ? device.kind === kind : true;\r\n            return noLabel && isRelevant;\r\n          });\r\n          if (isDummyDeviceOrEmpty) {\r\n            const permissionsToAcquire = {\r\n              video: kind !== 'audioinput' && kind !== 'audiooutput',\r\n              audio: kind !== 'videoinput' && {\r\n                deviceId: {\r\n                  ideal: 'default'\r\n                }\r\n              }\r\n            };\r\n            const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\r\n            devices = yield navigator.mediaDevices.enumerateDevices();\r\n            stream.getTracks().forEach(track => {\r\n              track.stop();\r\n            });\r\n          }\r\n        }\r\n        _this._previousDevices = devices;\r\n        if (kind) {\r\n          devices = devices.filter(device => device.kind === kind);\r\n        }\r\n        return devices;\r\n      }();\r\n    });\r\n  }\r\n  normalizeDeviceId(kind, deviceId, groupId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (deviceId !== defaultId) {\r\n        return deviceId;\r\n      }\r\n      // resolve actual device id if it's 'default': Chrome returns it when no\r\n      // device has been chosen\r\n      const devices = yield this.getDevices(kind);\r\n      const defaultDevice = devices.find(d => d.deviceId === defaultId);\r\n      if (!defaultDevice) {\r\n        livekitLogger.warn('could not reliably determine default device');\r\n        return undefined;\r\n      }\r\n      const device = devices.find(d => d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\r\n      if (!device) {\r\n        livekitLogger.warn('could not reliably determine default device');\r\n        return undefined;\r\n      }\r\n      return device === null || device === void 0 ? void 0 : device.deviceId;\r\n    });\r\n  }\r\n  hasDeviceInUse(kind) {\r\n    return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\r\n  }\r\n}\r\nDeviceManager.mediaDeviceKinds = ['audioinput', 'audiooutput', 'videoinput'];\r\nDeviceManager.userMediaPromiseMap = new Map();\r\n\r\nvar QueueTaskStatus;\r\n(function (QueueTaskStatus) {\r\n  QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\r\n  QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\r\n  QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\r\n})(QueueTaskStatus || (QueueTaskStatus = {}));\r\nclass AsyncQueue {\r\n  constructor() {\r\n    this.pendingTasks = new Map();\r\n    this.taskMutex = new _();\r\n    this.nextTaskIndex = 0;\r\n  }\r\n  run(task) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const taskInfo = {\r\n        id: this.nextTaskIndex++,\r\n        enqueuedAt: Date.now(),\r\n        status: QueueTaskStatus.WAITING\r\n      };\r\n      this.pendingTasks.set(taskInfo.id, taskInfo);\r\n      const unlock = yield this.taskMutex.lock();\r\n      try {\r\n        taskInfo.executedAt = Date.now();\r\n        taskInfo.status = QueueTaskStatus.RUNNING;\r\n        return yield task();\r\n      } finally {\r\n        taskInfo.status = QueueTaskStatus.COMPLETED;\r\n        this.pendingTasks.delete(taskInfo.id);\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  flush() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {}));\r\n    });\r\n  }\r\n  snapshot() {\r\n    return Array.from(this.pendingTasks.values());\r\n  }\r\n}\r\n\r\nfunction createRtcUrl(url, searchParams) {\r\n  const urlObj = new URL(toWebsocketUrl(url));\r\n  searchParams.forEach((value, key) => {\r\n    urlObj.searchParams.set(key, value);\r\n  });\r\n  return appendUrlPath(urlObj, 'rtc');\r\n}\r\nfunction createValidateUrl(rtcWsUrl) {\r\n  const urlObj = new URL(toHttpUrl(rtcWsUrl));\r\n  return appendUrlPath(urlObj, 'validate');\r\n}\r\nfunction ensureTrailingSlash(path) {\r\n  return path.endsWith('/') ? path : \"\".concat(path, \"/\");\r\n}\r\nfunction appendUrlPath(urlObj, path) {\r\n  urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\r\n  return urlObj.toString();\r\n}\r\n\r\nconst passThroughQueueSignals = ['syncState', 'trickle', 'offer', 'answer', 'simulate', 'leave'];\r\nfunction canPassThroughQueue(req) {\r\n  const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\r\n  livekitLogger.trace('request allowed to bypass queue:', {\r\n    canPass,\r\n    req\r\n  });\r\n  return canPass;\r\n}\r\nvar SignalConnectionState;\r\n(function (SignalConnectionState) {\r\n  SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\r\n  SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\r\n})(SignalConnectionState || (SignalConnectionState = {}));\r\n/** @internal */\r\nclass SignalClient {\r\n  get currentState() {\r\n    return this.state;\r\n  }\r\n  get isDisconnected() {\r\n    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\r\n  }\r\n  get isEstablishingConnection() {\r\n    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\r\n  }\r\n  getNextRequestId() {\r\n    this._requestId += 1;\r\n    return this._requestId;\r\n  }\r\n  constructor() {\r\n    let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var _a;\r\n    /** signal rtt in milliseconds */\r\n    this.rtt = 0;\r\n    this.state = SignalConnectionState.DISCONNECTED;\r\n    this.log = livekitLogger;\r\n    this._requestId = 0;\r\n    /** @internal */\r\n    this.resetCallbacks = () => {\r\n      this.onAnswer = undefined;\r\n      this.onLeave = undefined;\r\n      this.onLocalTrackPublished = undefined;\r\n      this.onLocalTrackUnpublished = undefined;\r\n      this.onNegotiateRequested = undefined;\r\n      this.onOffer = undefined;\r\n      this.onRemoteMuteChanged = undefined;\r\n      this.onSubscribedQualityUpdate = undefined;\r\n      this.onTokenRefresh = undefined;\r\n      this.onTrickle = undefined;\r\n      this.onClose = undefined;\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\r\n    this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    this.useJSON = useJSON;\r\n    this.requestQueue = new AsyncQueue();\r\n    this.queuedRequests = [];\r\n    this.closingLock = new _();\r\n    this.connectionLock = new _();\r\n    this.state = SignalConnectionState.DISCONNECTED;\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\r\n  }\r\n  join(url, token, opts, abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // during a full reconnect, we'd want to start the sequence even if currently\r\n      // connected\r\n      this.state = SignalConnectionState.CONNECTING;\r\n      this.options = opts;\r\n      const res = yield this.connect(url, token, opts, abortSignal);\r\n      return res;\r\n    });\r\n  }\r\n  reconnect(url, token, sid, reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.options) {\r\n        this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\r\n        return;\r\n      }\r\n      this.state = SignalConnectionState.RECONNECTING;\r\n      // clear ping interval and restart it once reconnected\r\n      this.clearPingInterval();\r\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\r\n        reconnect: true,\r\n        sid,\r\n        reconnectReason: reason\r\n      }));\r\n      if (res instanceof ReconnectResponse) {\r\n        return res;\r\n      }\r\n      return;\r\n    });\r\n  }\r\n  connect(url, token, opts, abortSignal) {\r\n    this.connectOptions = opts;\r\n    const clientInfo = getClientInfo();\r\n    const params = createConnectionParams(token, clientInfo, opts);\r\n    const rtcUrl = createRtcUrl(url, params);\r\n    const validateUrl = createValidateUrl(rtcUrl);\r\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.connectionLock.lock();\r\n      try {\r\n        const abortHandler = () => __awaiter(this, void 0, void 0, function* () {\r\n          this.close();\r\n          clearTimeout(wsTimeout);\r\n          reject(new ConnectionError('room connection has been cancelled (signal)', ConnectionErrorReason.Cancelled));\r\n        });\r\n        const wsTimeout = setTimeout(() => {\r\n          this.close();\r\n          reject(new ConnectionError('room connection has timed out (signal)', ConnectionErrorReason.ServerUnreachable));\r\n        }, opts.websocketTimeout);\r\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\r\n          abortHandler();\r\n        }\r\n        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\r\n        const redactedUrl = new URL(rtcUrl);\r\n        if (redactedUrl.searchParams.has('access_token')) {\r\n          redactedUrl.searchParams.set('access_token', '<redacted>');\r\n        }\r\n        this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\r\n          reconnect: opts.reconnect,\r\n          reconnectReason: opts.reconnectReason\r\n        }, this.logContext));\r\n        if (this.ws) {\r\n          yield this.close(false);\r\n        }\r\n        this.ws = new WebSocket(rtcUrl);\r\n        this.ws.binaryType = 'arraybuffer';\r\n        this.ws.onopen = () => {\r\n          clearTimeout(wsTimeout);\r\n        };\r\n        this.ws.onerror = ev => __awaiter(this, void 0, void 0, function* () {\r\n          if (this.state !== SignalConnectionState.CONNECTED) {\r\n            this.state = SignalConnectionState.DISCONNECTED;\r\n            clearTimeout(wsTimeout);\r\n            try {\r\n              const resp = yield fetch(validateUrl);\r\n              if (resp.status.toFixed(0).startsWith('4')) {\r\n                const msg = yield resp.text();\r\n                reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));\r\n              } else {\r\n                reject(new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));\r\n              }\r\n            } catch (e) {\r\n              reject(new ConnectionError(e instanceof Error ? e.message : 'server was not reachable', ConnectionErrorReason.ServerUnreachable));\r\n            }\r\n            return;\r\n          }\r\n          // other errors, handle\r\n          this.handleWSError(ev);\r\n        });\r\n        this.ws.onmessage = ev => __awaiter(this, void 0, void 0, function* () {\r\n          var _a, _b, _c;\r\n          // not considered connected until JoinResponse is received\r\n          let resp;\r\n          if (typeof ev.data === 'string') {\r\n            const json = JSON.parse(ev.data);\r\n            resp = SignalResponse.fromJson(json, {\r\n              ignoreUnknownFields: true\r\n            });\r\n          } else if (ev.data instanceof ArrayBuffer) {\r\n            resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\r\n          } else {\r\n            this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\r\n            return;\r\n          }\r\n          if (this.state !== SignalConnectionState.CONNECTED) {\r\n            let shouldProcessMessage = false;\r\n            // handle join message only\r\n            if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\r\n              this.state = SignalConnectionState.CONNECTED;\r\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\r\n              this.pingTimeoutDuration = resp.message.value.pingTimeout;\r\n              this.pingIntervalDuration = resp.message.value.pingInterval;\r\n              if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\r\n                this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\r\n                  timeout: this.pingTimeoutDuration,\r\n                  interval: this.pingIntervalDuration\r\n                }));\r\n                this.startPingInterval();\r\n              }\r\n              resolve(resp.message.value);\r\n            } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== 'leave') {\r\n              // in reconnecting, any message received means signal reconnected\r\n              this.state = SignalConnectionState.CONNECTED;\r\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\r\n              this.startPingInterval();\r\n              if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === 'reconnect') {\r\n                resolve(resp.message.value);\r\n              } else {\r\n                this.log.debug('declaring signal reconnected without reconnect response received', this.logContext);\r\n                resolve(undefined);\r\n                shouldProcessMessage = true;\r\n              }\r\n            } else if (this.isEstablishingConnection && resp.message.case === 'leave') {\r\n              reject(new ConnectionError('Received leave request while trying to (re)connect', ConnectionErrorReason.LeaveRequest, undefined, resp.message.value.reason));\r\n            } else if (!opts.reconnect) {\r\n              // non-reconnect case, should receive join response first\r\n              reject(new ConnectionError(\"did not receive join response, got \".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, \" instead\"), ConnectionErrorReason.InternalError));\r\n            }\r\n            if (!shouldProcessMessage) {\r\n              return;\r\n            }\r\n          }\r\n          if (this.signalLatency) {\r\n            yield sleep(this.signalLatency);\r\n          }\r\n          this.handleSignalResponse(resp);\r\n        });\r\n        this.ws.onclose = ev => {\r\n          if (this.isEstablishingConnection) {\r\n            reject(new ConnectionError('Websocket got closed during a (re)connection attempt', ConnectionErrorReason.InternalError));\r\n          }\r\n          this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\r\n            reason: ev.reason,\r\n            code: ev.code,\r\n            wasClean: ev.wasClean,\r\n            state: this.state\r\n          }));\r\n          this.handleOnClose(ev.reason);\r\n        };\r\n      } finally {\r\n        unlock();\r\n      }\r\n    }));\r\n  }\r\n  close() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this = this;\r\n      let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        const unlock = yield _this.closingLock.lock();\r\n        try {\r\n          _this.clearPingInterval();\r\n          if (updateState) {\r\n            _this.state = SignalConnectionState.DISCONNECTING;\r\n          }\r\n          if (_this.ws) {\r\n            _this.ws.onmessage = null;\r\n            _this.ws.onopen = null;\r\n            _this.ws.onclose = null;\r\n            // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\r\n            const closePromise = new Promise(resolve => {\r\n              if (_this.ws) {\r\n                _this.ws.onclose = () => {\r\n                  resolve();\r\n                };\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n            if (_this.ws.readyState < _this.ws.CLOSING) {\r\n              _this.ws.close();\r\n              // 250ms grace period for ws to close gracefully\r\n              yield Promise.race([closePromise, sleep(250)]);\r\n            }\r\n            _this.ws = undefined;\r\n          }\r\n        } finally {\r\n          if (updateState) {\r\n            _this.state = SignalConnectionState.DISCONNECTED;\r\n          }\r\n          unlock();\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  // initial offer after joining\r\n  sendOffer(offer) {\r\n    this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\r\n      offerSdp: offer.sdp\r\n    }));\r\n    this.sendRequest({\r\n      case: 'offer',\r\n      value: toProtoSessionDescription(offer)\r\n    });\r\n  }\r\n  // answer a server-initiated offer\r\n  sendAnswer(answer) {\r\n    this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\r\n      answerSdp: answer.sdp\r\n    }));\r\n    return this.sendRequest({\r\n      case: 'answer',\r\n      value: toProtoSessionDescription(answer)\r\n    });\r\n  }\r\n  sendIceCandidate(candidate, target) {\r\n    this.log.debug('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\r\n      candidate\r\n    }));\r\n    return this.sendRequest({\r\n      case: 'trickle',\r\n      value: new TrickleRequest({\r\n        candidateInit: JSON.stringify(candidate),\r\n        target\r\n      })\r\n    });\r\n  }\r\n  sendMuteTrack(trackSid, muted) {\r\n    return this.sendRequest({\r\n      case: 'mute',\r\n      value: new MuteTrackRequest({\r\n        sid: trackSid,\r\n        muted\r\n      })\r\n    });\r\n  }\r\n  sendAddTrack(req) {\r\n    return this.sendRequest({\r\n      case: 'addTrack',\r\n      value: req\r\n    });\r\n  }\r\n  sendUpdateLocalMetadata(metadata_1, name_1) {\r\n    return __awaiter(this, arguments, void 0, function (metadata, name) {\r\n      var _this2 = this;\r\n      let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      return function* () {\r\n        const requestId = _this2.getNextRequestId();\r\n        yield _this2.sendRequest({\r\n          case: 'updateMetadata',\r\n          value: new UpdateParticipantMetadata({\r\n            requestId,\r\n            metadata,\r\n            name,\r\n            attributes\r\n          })\r\n        });\r\n        return requestId;\r\n      }();\r\n    });\r\n  }\r\n  sendUpdateTrackSettings(settings) {\r\n    this.sendRequest({\r\n      case: 'trackSetting',\r\n      value: settings\r\n    });\r\n  }\r\n  sendUpdateSubscription(sub) {\r\n    return this.sendRequest({\r\n      case: 'subscription',\r\n      value: sub\r\n    });\r\n  }\r\n  sendSyncState(sync) {\r\n    return this.sendRequest({\r\n      case: 'syncState',\r\n      value: sync\r\n    });\r\n  }\r\n  sendUpdateVideoLayers(trackSid, layers) {\r\n    return this.sendRequest({\r\n      case: 'updateLayers',\r\n      value: new UpdateVideoLayers({\r\n        trackSid,\r\n        layers\r\n      })\r\n    });\r\n  }\r\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\r\n    return this.sendRequest({\r\n      case: 'subscriptionPermission',\r\n      value: new SubscriptionPermission({\r\n        allParticipants,\r\n        trackPermissions\r\n      })\r\n    });\r\n  }\r\n  sendSimulateScenario(scenario) {\r\n    return this.sendRequest({\r\n      case: 'simulate',\r\n      value: scenario\r\n    });\r\n  }\r\n  sendPing() {\r\n    /** send both of ping and pingReq for compatibility to old and new server */\r\n    return Promise.all([this.sendRequest({\r\n      case: 'ping',\r\n      value: protoInt64.parse(Date.now())\r\n    }), this.sendRequest({\r\n      case: 'pingReq',\r\n      value: new Ping({\r\n        timestamp: protoInt64.parse(Date.now()),\r\n        rtt: protoInt64.parse(this.rtt)\r\n      })\r\n    })]);\r\n  }\r\n  sendUpdateLocalAudioTrack(trackSid, features) {\r\n    return this.sendRequest({\r\n      case: 'updateAudioTrack',\r\n      value: new UpdateLocalAudioTrack({\r\n        trackSid,\r\n        features\r\n      })\r\n    });\r\n  }\r\n  sendLeave() {\r\n    return this.sendRequest({\r\n      case: 'leave',\r\n      value: new LeaveRequest({\r\n        reason: DisconnectReason.CLIENT_INITIATED,\r\n        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\r\n        action: LeaveRequest_Action.DISCONNECT\r\n      })\r\n    });\r\n  }\r\n  sendRequest(message_1) {\r\n    return __awaiter(this, arguments, void 0, function (message) {\r\n      var _this3 = this;\r\n      let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      return function* () {\r\n        // capture all requests while reconnecting and put them in a queue\r\n        // unless the request originates from the queue, then don't enqueue again\r\n        const canQueue = !fromQueue && !canPassThroughQueue(message);\r\n        if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\r\n          _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {\r\n            yield this.sendRequest(message, true);\r\n          }));\r\n          return;\r\n        }\r\n        // make sure previously queued requests are being sent first\r\n        if (!fromQueue) {\r\n          yield _this3.requestQueue.flush();\r\n        }\r\n        if (_this3.signalLatency) {\r\n          yield sleep(_this3.signalLatency);\r\n        }\r\n        if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {\r\n          _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\r\n          return;\r\n        }\r\n        const req = new SignalRequest({\r\n          message\r\n        });\r\n        try {\r\n          if (_this3.useJSON) {\r\n            _this3.ws.send(req.toJsonString());\r\n          } else {\r\n            _this3.ws.send(req.toBinary());\r\n          }\r\n        } catch (e) {\r\n          _this3.log.error('error sending signal message', Object.assign(Object.assign({}, _this3.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  handleSignalResponse(res) {\r\n    var _a, _b;\r\n    const msg = res.message;\r\n    if (msg == undefined) {\r\n      this.log.debug('received unsupported message', this.logContext);\r\n      return;\r\n    }\r\n    let pingHandled = false;\r\n    if (msg.case === 'answer') {\r\n      const sd = fromProtoSessionDescription(msg.value);\r\n      if (this.onAnswer) {\r\n        this.onAnswer(sd);\r\n      }\r\n    } else if (msg.case === 'offer') {\r\n      const sd = fromProtoSessionDescription(msg.value);\r\n      if (this.onOffer) {\r\n        this.onOffer(sd);\r\n      }\r\n    } else if (msg.case === 'trickle') {\r\n      const candidate = JSON.parse(msg.value.candidateInit);\r\n      if (this.onTrickle) {\r\n        this.onTrickle(candidate, msg.value.target);\r\n      }\r\n    } else if (msg.case === 'update') {\r\n      if (this.onParticipantUpdate) {\r\n        this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\r\n      }\r\n    } else if (msg.case === 'trackPublished') {\r\n      if (this.onLocalTrackPublished) {\r\n        this.onLocalTrackPublished(msg.value);\r\n      }\r\n    } else if (msg.case === 'speakersChanged') {\r\n      if (this.onSpeakersChanged) {\r\n        this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\r\n      }\r\n    } else if (msg.case === 'leave') {\r\n      if (this.onLeave) {\r\n        this.onLeave(msg.value);\r\n      }\r\n    } else if (msg.case === 'mute') {\r\n      if (this.onRemoteMuteChanged) {\r\n        this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\r\n      }\r\n    } else if (msg.case === 'roomUpdate') {\r\n      if (this.onRoomUpdate && msg.value.room) {\r\n        this.onRoomUpdate(msg.value.room);\r\n      }\r\n    } else if (msg.case === 'connectionQuality') {\r\n      if (this.onConnectionQuality) {\r\n        this.onConnectionQuality(msg.value);\r\n      }\r\n    } else if (msg.case === 'streamStateUpdate') {\r\n      if (this.onStreamStateUpdate) {\r\n        this.onStreamStateUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscribedQualityUpdate') {\r\n      if (this.onSubscribedQualityUpdate) {\r\n        this.onSubscribedQualityUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscriptionPermissionUpdate') {\r\n      if (this.onSubscriptionPermissionUpdate) {\r\n        this.onSubscriptionPermissionUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'refreshToken') {\r\n      if (this.onTokenRefresh) {\r\n        this.onTokenRefresh(msg.value);\r\n      }\r\n    } else if (msg.case === 'trackUnpublished') {\r\n      if (this.onLocalTrackUnpublished) {\r\n        this.onLocalTrackUnpublished(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscriptionResponse') {\r\n      if (this.onSubscriptionError) {\r\n        this.onSubscriptionError(msg.value);\r\n      }\r\n    } else if (msg.case === 'pong') ; else if (msg.case === 'pongResp') {\r\n      this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\r\n      this.resetPingTimeout();\r\n      pingHandled = true;\r\n    } else if (msg.case === 'requestResponse') {\r\n      if (this.onRequestResponse) {\r\n        this.onRequestResponse(msg.value);\r\n      }\r\n    } else if (msg.case === 'trackSubscribed') {\r\n      if (this.onLocalTrackSubscribed) {\r\n        this.onLocalTrackSubscribed(msg.value.trackSid);\r\n      }\r\n    } else if (msg.case === 'roomMoved') {\r\n      if (this.onTokenRefresh) {\r\n        this.onTokenRefresh(msg.value.token);\r\n      }\r\n      if (this.onRoomMoved) {\r\n        this.onRoomMoved(msg.value);\r\n      }\r\n    } else {\r\n      this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\r\n        msgCase: msg.case\r\n      }));\r\n    }\r\n    if (!pingHandled) {\r\n      this.resetPingTimeout();\r\n    }\r\n  }\r\n  setReconnected() {\r\n    while (this.queuedRequests.length > 0) {\r\n      const req = this.queuedRequests.shift();\r\n      if (req) {\r\n        this.requestQueue.run(req);\r\n      }\r\n    }\r\n  }\r\n  handleOnClose(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state === SignalConnectionState.DISCONNECTED) return;\r\n      const onCloseCallback = this.onClose;\r\n      yield this.close();\r\n      this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\r\n        reason\r\n      }));\r\n      if (onCloseCallback) {\r\n        onCloseCallback(reason);\r\n      }\r\n    });\r\n  }\r\n  handleWSError(ev) {\r\n    this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\r\n      error: ev\r\n    }));\r\n  }\r\n  /**\r\n   * Resets the ping timeout and starts a new timeout.\r\n   * Call this after receiving a pong message\r\n   */\r\n  resetPingTimeout() {\r\n    this.clearPingTimeout();\r\n    if (!this.pingTimeoutDuration) {\r\n      this.log.warn('ping timeout duration not set', this.logContext);\r\n      return;\r\n    }\r\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\r\n      this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\r\n      this.handleOnClose('ping timeout');\r\n    }, this.pingTimeoutDuration * 1000);\r\n  }\r\n  /**\r\n   * Clears ping timeout (does not start a new timeout)\r\n   */\r\n  clearPingTimeout() {\r\n    if (this.pingTimeout) {\r\n      CriticalTimers.clearTimeout(this.pingTimeout);\r\n    }\r\n  }\r\n  startPingInterval() {\r\n    this.clearPingInterval();\r\n    this.resetPingTimeout();\r\n    if (!this.pingIntervalDuration) {\r\n      this.log.warn('ping interval duration not set', this.logContext);\r\n      return;\r\n    }\r\n    this.log.debug('start ping interval', this.logContext);\r\n    this.pingInterval = CriticalTimers.setInterval(() => {\r\n      this.sendPing();\r\n    }, this.pingIntervalDuration * 1000);\r\n  }\r\n  clearPingInterval() {\r\n    this.log.debug('clearing ping interval', this.logContext);\r\n    this.clearPingTimeout();\r\n    if (this.pingInterval) {\r\n      CriticalTimers.clearInterval(this.pingInterval);\r\n    }\r\n  }\r\n}\r\nfunction fromProtoSessionDescription(sd) {\r\n  const rsd = {\r\n    type: 'offer',\r\n    sdp: sd.sdp\r\n  };\r\n  switch (sd.type) {\r\n    case 'answer':\r\n    case 'offer':\r\n    case 'pranswer':\r\n    case 'rollback':\r\n      rsd.type = sd.type;\r\n      break;\r\n  }\r\n  return rsd;\r\n}\r\nfunction toProtoSessionDescription(rsd) {\r\n  const sd = new SessionDescription({\r\n    sdp: rsd.sdp,\r\n    type: rsd.type\r\n  });\r\n  return sd;\r\n}\r\nfunction createConnectionParams(token, info, opts) {\r\n  var _a;\r\n  const params = new URLSearchParams();\r\n  params.set('access_token', token);\r\n  // opts\r\n  if (opts.reconnect) {\r\n    params.set('reconnect', '1');\r\n    if (opts.sid) {\r\n      params.set('sid', opts.sid);\r\n    }\r\n  }\r\n  params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\r\n  // ClientInfo\r\n  params.set('sdk', isReactNative() ? 'reactnative' : 'js');\r\n  params.set('version', info.version);\r\n  params.set('protocol', info.protocol.toString());\r\n  if (info.deviceModel) {\r\n    params.set('device_model', info.deviceModel);\r\n  }\r\n  if (info.os) {\r\n    params.set('os', info.os);\r\n  }\r\n  if (info.osVersion) {\r\n    params.set('os_version', info.osVersion);\r\n  }\r\n  if (info.browser) {\r\n    params.set('browser', info.browser);\r\n  }\r\n  if (info.browserVersion) {\r\n    params.set('browser_version', info.browserVersion);\r\n  }\r\n  if (opts.adaptiveStream) {\r\n    params.set('adaptive_stream', '1');\r\n  }\r\n  if (opts.reconnectReason) {\r\n    params.set('reconnect_reason', opts.reconnectReason.toString());\r\n  }\r\n  // @ts-ignore\r\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\r\n    // @ts-ignore\r\n    params.set('network', navigator.connection.type);\r\n  }\r\n  return params;\r\n}\r\n\r\nclass DataPacketBuffer {\r\n  constructor() {\r\n    this.buffer = [];\r\n    this._totalSize = 0;\r\n  }\r\n  push(item) {\r\n    this.buffer.push(item);\r\n    this._totalSize += item.data.byteLength;\r\n  }\r\n  pop() {\r\n    const item = this.buffer.shift();\r\n    if (item) {\r\n      this._totalSize -= item.data.byteLength;\r\n    }\r\n    return item;\r\n  }\r\n  getAll() {\r\n    return this.buffer.slice();\r\n  }\r\n  popToSequence(sequence) {\r\n    while (this.buffer.length > 0) {\r\n      const first = this.buffer[0];\r\n      if (first.sequence <= sequence) {\r\n        this.pop();\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  alignBufferedAmount(bufferedAmount) {\r\n    while (this.buffer.length > 0) {\r\n      const first = this.buffer[0];\r\n      if (this._totalSize - first.data.byteLength <= bufferedAmount) {\r\n        break;\r\n      }\r\n      this.pop();\r\n    }\r\n  }\r\n  get length() {\r\n    return this.buffer.length;\r\n  }\r\n}\r\n\r\nclass TTLMap {\r\n  /**\r\n   * @param ttl ttl of the key (ms)\r\n   */\r\n  constructor(ttl) {\r\n    this._map = new Map();\r\n    this._lastCleanup = 0;\r\n    this.ttl = ttl;\r\n  }\r\n  set(key, value) {\r\n    const now = Date.now();\r\n    if (now - this._lastCleanup > this.ttl / 2) {\r\n      this.cleanup();\r\n    }\r\n    const expiresAt = now + this.ttl;\r\n    this._map.set(key, {\r\n      value,\r\n      expiresAt\r\n    });\r\n    return this;\r\n  }\r\n  get(key) {\r\n    const entry = this._map.get(key);\r\n    if (!entry) return undefined;\r\n    if (entry.expiresAt < Date.now()) {\r\n      this._map.delete(key);\r\n      return undefined;\r\n    }\r\n    return entry.value;\r\n  }\r\n  has(key) {\r\n    const entry = this._map.get(key);\r\n    if (!entry) return false;\r\n    if (entry.expiresAt < Date.now()) {\r\n      this._map.delete(key);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  delete(key) {\r\n    return this._map.delete(key);\r\n  }\r\n  clear() {\r\n    this._map.clear();\r\n  }\r\n  cleanup() {\r\n    const now = Date.now();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt < now) {\r\n        this._map.delete(key);\r\n      }\r\n    }\r\n    this._lastCleanup = now;\r\n  }\r\n  get size() {\r\n    this.cleanup();\r\n    return this._map.size;\r\n  }\r\n  forEach(callback) {\r\n    this.cleanup();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt >= Date.now()) {\r\n        callback(entry.value, key, this.asValueMap());\r\n      }\r\n    }\r\n  }\r\n  map(callback) {\r\n    this.cleanup();\r\n    const result = [];\r\n    const valueMap = this.asValueMap();\r\n    for (const [key, value] of valueMap.entries()) {\r\n      result.push(callback(value, key, valueMap));\r\n    }\r\n    return result;\r\n  }\r\n  asValueMap() {\r\n    const result = new Map();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt >= Date.now()) {\r\n        result.set(key, entry.value);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nvar lib = {};\r\n\r\nvar parser = {};\r\n\r\nvar grammar = {exports: {}};\r\n\r\nvar hasRequiredGrammar;\r\nfunction requireGrammar() {\r\n  if (hasRequiredGrammar) return grammar.exports;\r\n  hasRequiredGrammar = 1;\r\n  var grammar$1 = grammar.exports = {\r\n    v: [{\r\n      name: 'version',\r\n      reg: /^(\\d*)$/\r\n    }],\r\n    o: [{\r\n      // o=- 20518 0 IN IP4 203.0.113.1\r\n      // NB: sessionId will be a String in most cases because it is huge\r\n      name: 'origin',\r\n      reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\r\n      names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\r\n      format: '%s %s %d %s IP%d %s'\r\n    }],\r\n    // default parsing of these only (though some of these feel outdated)\r\n    s: [{\r\n      name: 'name'\r\n    }],\r\n    i: [{\r\n      name: 'description'\r\n    }],\r\n    u: [{\r\n      name: 'uri'\r\n    }],\r\n    e: [{\r\n      name: 'email'\r\n    }],\r\n    p: [{\r\n      name: 'phone'\r\n    }],\r\n    z: [{\r\n      name: 'timezones'\r\n    }],\r\n    // TODO: this one can actually be parsed properly...\r\n    r: [{\r\n      name: 'repeats'\r\n    }],\r\n    // TODO: this one can also be parsed properly\r\n    // k: [{}], // outdated thing ignored\r\n    t: [{\r\n      // t=0 0\r\n      name: 'timing',\r\n      reg: /^(\\d*) (\\d*)/,\r\n      names: ['start', 'stop'],\r\n      format: '%d %d'\r\n    }],\r\n    c: [{\r\n      // c=IN IP4 10.47.197.26\r\n      name: 'connection',\r\n      reg: /^IN IP(\\d) (\\S*)/,\r\n      names: ['version', 'ip'],\r\n      format: 'IN IP%d %s'\r\n    }],\r\n    b: [{\r\n      // b=AS:4000\r\n      push: 'bandwidth',\r\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\r\n      names: ['type', 'limit'],\r\n      format: '%s:%s'\r\n    }],\r\n    m: [{\r\n      // m=video 51744 RTP/AVP 126 97 98 34 31\r\n      // NB: special - pushes to session\r\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\r\n      reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\r\n      names: ['type', 'port', 'protocol', 'payloads'],\r\n      format: '%s %d %s %s'\r\n    }],\r\n    a: [{\r\n      // a=rtpmap:110 opus/48000/2\r\n      push: 'rtp',\r\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\r\n      names: ['payload', 'codec', 'rate', 'encoding'],\r\n      format: function (o) {\r\n        return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\r\n      }\r\n    }, {\r\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\r\n      // a=fmtp:111 minptime=10; useinbandfec=1\r\n      push: 'fmtp',\r\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\r\n      names: ['payload', 'config'],\r\n      format: 'fmtp:%d %s'\r\n    }, {\r\n      // a=control:streamid=0\r\n      name: 'control',\r\n      reg: /^control:(.*)/,\r\n      format: 'control:%s'\r\n    }, {\r\n      // a=rtcp:65179 IN IP4 193.84.77.194\r\n      name: 'rtcp',\r\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\r\n      names: ['port', 'netType', 'ipVer', 'address'],\r\n      format: function (o) {\r\n        return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\r\n      }\r\n    }, {\r\n      // a=rtcp-fb:98 trr-int 100\r\n      push: 'rtcpFbTrrInt',\r\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\r\n      names: ['payload', 'value'],\r\n      format: 'rtcp-fb:%s trr-int %d'\r\n    }, {\r\n      // a=rtcp-fb:98 nack rpsi\r\n      push: 'rtcpFb',\r\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\r\n      names: ['payload', 'type', 'subtype'],\r\n      format: function (o) {\r\n        return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\r\n      }\r\n    }, {\r\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n      // a=extmap:1/recvonly URI-gps-string\r\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\r\n      push: 'ext',\r\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\r\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\r\n      format: function (o) {\r\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\r\n      }\r\n    }, {\r\n      // a=extmap-allow-mixed\r\n      name: 'extmapAllowMixed',\r\n      reg: /^(extmap-allow-mixed)/\r\n    }, {\r\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\r\n      push: 'crypto',\r\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\r\n      names: ['id', 'suite', 'config', 'sessionConfig'],\r\n      format: function (o) {\r\n        return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\r\n      }\r\n    }, {\r\n      // a=setup:actpass\r\n      name: 'setup',\r\n      reg: /^setup:(\\w*)/,\r\n      format: 'setup:%s'\r\n    }, {\r\n      // a=connection:new\r\n      name: 'connectionType',\r\n      reg: /^connection:(new|existing)/,\r\n      format: 'connection:%s'\r\n    }, {\r\n      // a=mid:1\r\n      name: 'mid',\r\n      reg: /^mid:([^\\s]*)/,\r\n      format: 'mid:%s'\r\n    }, {\r\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\r\n      name: 'msid',\r\n      reg: /^msid:(.*)/,\r\n      format: 'msid:%s'\r\n    }, {\r\n      // a=ptime:20\r\n      name: 'ptime',\r\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\r\n      format: 'ptime:%d'\r\n    }, {\r\n      // a=maxptime:60\r\n      name: 'maxptime',\r\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\r\n      format: 'maxptime:%d'\r\n    }, {\r\n      // a=sendrecv\r\n      name: 'direction',\r\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\r\n    }, {\r\n      // a=ice-lite\r\n      name: 'icelite',\r\n      reg: /^(ice-lite)/\r\n    }, {\r\n      // a=ice-ufrag:F7gI\r\n      name: 'iceUfrag',\r\n      reg: /^ice-ufrag:(\\S*)/,\r\n      format: 'ice-ufrag:%s'\r\n    }, {\r\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\r\n      name: 'icePwd',\r\n      reg: /^ice-pwd:(\\S*)/,\r\n      format: 'ice-pwd:%s'\r\n    }, {\r\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\r\n      name: 'fingerprint',\r\n      reg: /^fingerprint:(\\S*) (\\S*)/,\r\n      names: ['type', 'hash'],\r\n      format: 'fingerprint:%s %s'\r\n    }, {\r\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\r\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\r\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\r\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\r\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\r\n      push: 'candidates',\r\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\r\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\r\n      format: function (o) {\r\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\r\n        str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\r\n\r\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\r\n        str += o.tcptype != null ? ' tcptype %s' : '%v';\r\n        if (o.generation != null) {\r\n          str += ' generation %d';\r\n        }\r\n        str += o['network-id'] != null ? ' network-id %d' : '%v';\r\n        str += o['network-cost'] != null ? ' network-cost %d' : '%v';\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=end-of-candidates (keep after the candidates line for readability)\r\n      name: 'endOfCandidates',\r\n      reg: /^(end-of-candidates)/\r\n    }, {\r\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\r\n      name: 'remoteCandidates',\r\n      reg: /^remote-candidates:(.*)/,\r\n      format: 'remote-candidates:%s'\r\n    }, {\r\n      // a=ice-options:google-ice\r\n      name: 'iceOptions',\r\n      reg: /^ice-options:(\\S*)/,\r\n      format: 'ice-options:%s'\r\n    }, {\r\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\r\n      push: 'ssrcs',\r\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\r\n      names: ['id', 'attribute', 'value'],\r\n      format: function (o) {\r\n        var str = 'ssrc:%d';\r\n        if (o.attribute != null) {\r\n          str += ' %s';\r\n          if (o.value != null) {\r\n            str += ':%s';\r\n          }\r\n        }\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=ssrc-group:FEC 1 2\r\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\r\n      push: 'ssrcGroups',\r\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\r\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\r\n      names: ['semantics', 'ssrcs'],\r\n      format: 'ssrc-group:%s %s'\r\n    }, {\r\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\r\n      name: 'msidSemantic',\r\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\r\n      names: ['semantic', 'token'],\r\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\r\n    }, {\r\n      // a=group:BUNDLE audio video\r\n      push: 'groups',\r\n      reg: /^group:(\\w*) (.*)/,\r\n      names: ['type', 'mids'],\r\n      format: 'group:%s %s'\r\n    }, {\r\n      // a=rtcp-mux\r\n      name: 'rtcpMux',\r\n      reg: /^(rtcp-mux)/\r\n    }, {\r\n      // a=rtcp-rsize\r\n      name: 'rtcpRsize',\r\n      reg: /^(rtcp-rsize)/\r\n    }, {\r\n      // a=sctpmap:5000 webrtc-datachannel 1024\r\n      name: 'sctpmap',\r\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\r\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\r\n      format: function (o) {\r\n        return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\r\n      }\r\n    }, {\r\n      // a=x-google-flag:conference\r\n      name: 'xGoogleFlag',\r\n      reg: /^x-google-flag:([^\\s]*)/,\r\n      format: 'x-google-flag:%s'\r\n    }, {\r\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\r\n      push: 'rids',\r\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\r\n      names: ['id', 'direction', 'params'],\r\n      format: function (o) {\r\n        return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\r\n      }\r\n    }, {\r\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\r\n      // a=imageattr:* send [x=800,y=640] recv *\r\n      // a=imageattr:100 recv [x=320,y=240]\r\n      push: 'imageattrs',\r\n      reg: new RegExp(\r\n      // a=imageattr:97\r\n      '^imageattr:(\\\\d+|\\\\*)' +\r\n      // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\r\n      '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\r\n      // recv [x=330,y=250]\r\n      '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\r\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\r\n      format: function (o) {\r\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\r\n      }\r\n    }, {\r\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\r\n      // a=simulcast:recv 1;4,5 send 6;7\r\n      name: 'simulcast',\r\n      reg: new RegExp(\r\n      // a=simulcast:\r\n      '^simulcast:' +\r\n      // send 1,2,3;~4,~5\r\n      '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\r\n      // space + recv 6;~7,~8\r\n      '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\r\n      // end\r\n      '$'),\r\n      names: ['dir1', 'list1', 'dir2', 'list2'],\r\n      format: function (o) {\r\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\r\n      }\r\n    }, {\r\n      // old simulcast draft 03 (implemented by Firefox)\r\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\r\n      // a=simulcast: recv pt=97;98 send pt=97\r\n      // a=simulcast: send rid=5;6;7 paused=6,7\r\n      name: 'simulcast_03',\r\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\r\n      names: ['value'],\r\n      format: 'simulcast: %s'\r\n    }, {\r\n      // a=framerate:25\r\n      // a=framerate:29.97\r\n      name: 'framerate',\r\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\r\n      format: 'framerate:%s'\r\n    }, {\r\n      // RFC4570\r\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\r\n      name: 'sourceFilter',\r\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\r\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\r\n      format: 'source-filter: %s %s %s %s %s'\r\n    }, {\r\n      // a=bundle-only\r\n      name: 'bundleOnly',\r\n      reg: /^(bundle-only)/\r\n    }, {\r\n      // a=label:1\r\n      name: 'label',\r\n      reg: /^label:(.+)/,\r\n      format: 'label:%s'\r\n    }, {\r\n      // RFC version 26 for SCTP over DTLS\r\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\r\n      name: 'sctpPort',\r\n      reg: /^sctp-port:(\\d+)$/,\r\n      format: 'sctp-port:%s'\r\n    }, {\r\n      // RFC version 26 for SCTP over DTLS\r\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\r\n      name: 'maxMessageSize',\r\n      reg: /^max-message-size:(\\d+)$/,\r\n      format: 'max-message-size:%s'\r\n    }, {\r\n      // RFC7273\r\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\r\n      push: 'tsRefClocks',\r\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\r\n      names: ['clksrc', 'clksrcExt'],\r\n      format: function (o) {\r\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\r\n      }\r\n    }, {\r\n      // RFC7273\r\n      // a=mediaclk:direct=963214424\r\n      name: 'mediaClk',\r\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\r\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\r\n      format: function (o) {\r\n        var str = 'mediaclk:';\r\n        str += o.id != null ? 'id=%s %s' : '%v%s';\r\n        str += o.mediaClockValue != null ? '=%s' : '';\r\n        str += o.rateNumerator != null ? ' rate=%s' : '';\r\n        str += o.rateDenominator != null ? '/%s' : '';\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=keywds:keywords\r\n      name: 'keywords',\r\n      reg: /^keywds:(.+)$/,\r\n      format: 'keywds:%s'\r\n    }, {\r\n      // a=content:main\r\n      name: 'content',\r\n      reg: /^content:(.+)/,\r\n      format: 'content:%s'\r\n    },\r\n    // BFCP https://tools.ietf.org/html/rfc4583\r\n    {\r\n      // a=floorctrl:c-s\r\n      name: 'bfcpFloorCtrl',\r\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\r\n      format: 'floorctrl:%s'\r\n    }, {\r\n      // a=confid:1\r\n      name: 'bfcpConfId',\r\n      reg: /^confid:(\\d+)/,\r\n      format: 'confid:%s'\r\n    }, {\r\n      // a=userid:1\r\n      name: 'bfcpUserId',\r\n      reg: /^userid:(\\d+)/,\r\n      format: 'userid:%s'\r\n    }, {\r\n      // a=floorid:1\r\n      name: 'bfcpFloorId',\r\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\r\n      names: ['id', 'mStream'],\r\n      format: 'floorid:%s mstrm:%s'\r\n    }, {\r\n      // any a= that we don't understand is kept verbatim on media.invalid\r\n      push: 'invalid',\r\n      names: ['value']\r\n    }]\r\n  };\r\n\r\n  // set sensible defaults to avoid polluting the grammar with boring details\r\n  Object.keys(grammar$1).forEach(function (key) {\r\n    var objs = grammar$1[key];\r\n    objs.forEach(function (obj) {\r\n      if (!obj.reg) {\r\n        obj.reg = /(.*)/;\r\n      }\r\n      if (!obj.format) {\r\n        obj.format = '%s';\r\n      }\r\n    });\r\n  });\r\n  return grammar.exports;\r\n}\r\n\r\nvar hasRequiredParser;\r\nfunction requireParser() {\r\n  if (hasRequiredParser) return parser;\r\n  hasRequiredParser = 1;\r\n  (function (exports) {\r\n    var toIntIfInt = function (v) {\r\n      return String(Number(v)) === v ? Number(v) : v;\r\n    };\r\n    var attachProperties = function (match, location, names, rawName) {\r\n      if (rawName && !names) {\r\n        location[rawName] = toIntIfInt(match[1]);\r\n      } else {\r\n        for (var i = 0; i < names.length; i += 1) {\r\n          if (match[i + 1] != null) {\r\n            location[names[i]] = toIntIfInt(match[i + 1]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var parseReg = function (obj, location, content) {\r\n      var needsBlank = obj.name && obj.names;\r\n      if (obj.push && !location[obj.push]) {\r\n        location[obj.push] = [];\r\n      } else if (needsBlank && !location[obj.name]) {\r\n        location[obj.name] = {};\r\n      }\r\n      var keyLocation = obj.push ? {} :\r\n      // blank object that will be pushed\r\n      needsBlank ? location[obj.name] : location; // otherwise, named location or root\r\n\r\n      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\r\n      if (obj.push) {\r\n        location[obj.push].push(keyLocation);\r\n      }\r\n    };\r\n    var grammar = requireGrammar();\r\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\r\n    exports.parse = function (sdp) {\r\n      var session = {},\r\n        media = [],\r\n        location = session; // points at where properties go under (one of the above)\r\n\r\n      // parse lines we understand\r\n      sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\r\n        var type = l[0];\r\n        var content = l.slice(2);\r\n        if (type === 'm') {\r\n          media.push({\r\n            rtp: [],\r\n            fmtp: []\r\n          });\r\n          location = media[media.length - 1]; // point at latest media line\r\n        }\r\n        for (var j = 0; j < (grammar[type] || []).length; j += 1) {\r\n          var obj = grammar[type][j];\r\n          if (obj.reg.test(content)) {\r\n            return parseReg(obj, location, content);\r\n          }\r\n        }\r\n      });\r\n      session.media = media; // link it up\r\n      return session;\r\n    };\r\n    var paramReducer = function (acc, expr) {\r\n      var s = expr.split(/=(.+)/, 2);\r\n      if (s.length === 2) {\r\n        acc[s[0]] = toIntIfInt(s[1]);\r\n      } else if (s.length === 1 && expr.length > 1) {\r\n        acc[s[0]] = undefined;\r\n      }\r\n      return acc;\r\n    };\r\n    exports.parseParams = function (str) {\r\n      return str.split(/;\\s?/).reduce(paramReducer, {});\r\n    };\r\n\r\n    // For backward compatibility - alias will be removed in 3.0.0\r\n    exports.parseFmtpConfig = exports.parseParams;\r\n    exports.parsePayloads = function (str) {\r\n      return str.toString().split(' ').map(Number);\r\n    };\r\n    exports.parseRemoteCandidates = function (str) {\r\n      var candidates = [];\r\n      var parts = str.split(' ').map(toIntIfInt);\r\n      for (var i = 0; i < parts.length; i += 3) {\r\n        candidates.push({\r\n          component: parts[i],\r\n          ip: parts[i + 1],\r\n          port: parts[i + 2]\r\n        });\r\n      }\r\n      return candidates;\r\n    };\r\n    exports.parseImageAttributes = function (str) {\r\n      return str.split(' ').map(function (item) {\r\n        return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\r\n      });\r\n    };\r\n    exports.parseSimulcastStreamList = function (str) {\r\n      return str.split(';').map(function (stream) {\r\n        return stream.split(',').map(function (format) {\r\n          var scid,\r\n            paused = false;\r\n          if (format[0] !== '~') {\r\n            scid = toIntIfInt(format);\r\n          } else {\r\n            scid = toIntIfInt(format.substring(1, format.length));\r\n            paused = true;\r\n          }\r\n          return {\r\n            scid: scid,\r\n            paused: paused\r\n          };\r\n        });\r\n      });\r\n    };\r\n  })(parser);\r\n  return parser;\r\n}\r\n\r\nvar writer;\r\nvar hasRequiredWriter;\r\nfunction requireWriter() {\r\n  if (hasRequiredWriter) return writer;\r\n  hasRequiredWriter = 1;\r\n  var grammar = requireGrammar();\r\n\r\n  // customized util.format - discards excess arguments and can void middle ones\r\n  var formatRegExp = /%[sdv%]/g;\r\n  var format = function (formatStr) {\r\n    var i = 1;\r\n    var args = arguments;\r\n    var len = args.length;\r\n    return formatStr.replace(formatRegExp, function (x) {\r\n      if (i >= len) {\r\n        return x; // missing argument\r\n      }\r\n      var arg = args[i];\r\n      i += 1;\r\n      switch (x) {\r\n        case '%%':\r\n          return '%';\r\n        case '%s':\r\n          return String(arg);\r\n        case '%d':\r\n          return Number(arg);\r\n        case '%v':\r\n          return '';\r\n      }\r\n    });\r\n    // NB: we discard excess arguments - they are typically undefined from makeLine\r\n  };\r\n  var makeLine = function (type, obj, location) {\r\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\r\n    var args = [type + '=' + str];\r\n    if (obj.names) {\r\n      for (var i = 0; i < obj.names.length; i += 1) {\r\n        var n = obj.names[i];\r\n        if (obj.name) {\r\n          args.push(location[obj.name][n]);\r\n        } else {\r\n          // for mLine and push attributes\r\n          args.push(location[obj.names[i]]);\r\n        }\r\n      }\r\n    } else {\r\n      args.push(location[obj.name]);\r\n    }\r\n    return format.apply(null, args);\r\n  };\r\n\r\n  // RFC specified order\r\n  // TODO: extend this with all the rest\r\n  var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\r\n  var defaultInnerOrder = ['i', 'c', 'b', 'a'];\r\n  writer = function (session, opts) {\r\n    opts = opts || {};\r\n    // ensure certain properties exist\r\n    if (session.version == null) {\r\n      session.version = 0; // 'v=0' must be there (only defined version atm)\r\n    }\r\n    if (session.name == null) {\r\n      session.name = ' '; // 's= ' must be there if no meaningful name set\r\n    }\r\n    session.media.forEach(function (mLine) {\r\n      if (mLine.payloads == null) {\r\n        mLine.payloads = '';\r\n      }\r\n    });\r\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\r\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\r\n    var sdp = [];\r\n\r\n    // loop through outerOrder for matching properties on session\r\n    outerOrder.forEach(function (type) {\r\n      grammar[type].forEach(function (obj) {\r\n        if (obj.name in session && session[obj.name] != null) {\r\n          sdp.push(makeLine(type, obj, session));\r\n        } else if (obj.push in session && session[obj.push] != null) {\r\n          session[obj.push].forEach(function (el) {\r\n            sdp.push(makeLine(type, obj, el));\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    // then for each media line, follow the innerOrder\r\n    session.media.forEach(function (mLine) {\r\n      sdp.push(makeLine('m', grammar.m[0], mLine));\r\n      innerOrder.forEach(function (type) {\r\n        grammar[type].forEach(function (obj) {\r\n          if (obj.name in mLine && mLine[obj.name] != null) {\r\n            sdp.push(makeLine(type, obj, mLine));\r\n          } else if (obj.push in mLine && mLine[obj.push] != null) {\r\n            mLine[obj.push].forEach(function (el) {\r\n              sdp.push(makeLine(type, obj, el));\r\n            });\r\n          }\r\n        });\r\n      });\r\n    });\r\n    return sdp.join('\\r\\n') + '\\r\\n';\r\n  };\r\n  return writer;\r\n}\r\n\r\nvar hasRequiredLib;\r\nfunction requireLib() {\r\n  if (hasRequiredLib) return lib;\r\n  hasRequiredLib = 1;\r\n  var parser = requireParser();\r\n  var writer = requireWriter();\r\n  var grammar = requireGrammar();\r\n  lib.grammar = grammar;\r\n  lib.write = writer;\r\n  lib.parse = parser.parse;\r\n  lib.parseParams = parser.parseParams;\r\n  lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\r\n  lib.parsePayloads = parser.parsePayloads;\r\n  lib.parseRemoteCandidates = parser.parseRemoteCandidates;\r\n  lib.parseImageAttributes = parser.parseImageAttributes;\r\n  lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\r\n  return lib;\r\n}\r\n\r\nvar libExports = requireLib();\r\n\r\nfunction r(r, e, n) {\r\n  var i, t, o;\r\n  void 0 === e && (e = 50), void 0 === n && (n = {});\r\n  var a = null != (i = n.isImmediate) && i,\r\n    u = null != (t = n.callback) && t,\r\n    c = n.maxWait,\r\n    v = Date.now(),\r\n    l = [];\r\n  function f() {\r\n    if (void 0 !== c) {\r\n      var r = Date.now() - v;\r\n      if (r + e >= c) return c - r;\r\n    }\r\n    return e;\r\n  }\r\n  var d = function () {\r\n    var e = [].slice.call(arguments),\r\n      n = this;\r\n    return new Promise(function (i, t) {\r\n      var c = a && void 0 === o;\r\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function () {\r\n        if (o = void 0, v = Date.now(), !a) {\r\n          var i = r.apply(n, e);\r\n          u && u(i), l.forEach(function (r) {\r\n            return (0, r.resolve)(i);\r\n          }), l = [];\r\n        }\r\n      }, f()), c) {\r\n        var d = r.apply(n, e);\r\n        return u && u(d), i(d);\r\n      }\r\n      l.push({\r\n        resolve: i,\r\n        reject: t\r\n      });\r\n    });\r\n  };\r\n  return d.cancel = function (r) {\r\n    void 0 !== o && clearTimeout(o), l.forEach(function (e) {\r\n      return (0, e.reject)(r);\r\n    }), l = [];\r\n  }, d;\r\n}\r\n\r\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\r\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\r\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\r\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\r\neliminate this issue.\r\n*/\r\nconst startBitrateForSVC = 0.7;\r\nconst debounceInterval = 20;\r\nconst PCEvents = {\r\n  NegotiationStarted: 'negotiationStarted',\r\n  NegotiationComplete: 'negotiationComplete',\r\n  RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\r\n};\r\n/** @internal */\r\nclass PCTransport extends eventsExports.EventEmitter {\r\n  get pc() {\r\n    if (!this._pc) {\r\n      this._pc = this.createPC();\r\n    }\r\n    return this._pc;\r\n  }\r\n  constructor(config) {\r\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var _a;\r\n    super();\r\n    this.log = livekitLogger;\r\n    this.ddExtID = 0;\r\n    this.pendingCandidates = [];\r\n    this.restartingIce = false;\r\n    this.renegotiate = false;\r\n    this.trackBitrates = [];\r\n    this.remoteStereoMids = [];\r\n    this.remoteNackMids = [];\r\n    // debounced negotiate interface\r\n    this.negotiate = r(onError => __awaiter(this, void 0, void 0, function* () {\r\n      this.emit(PCEvents.NegotiationStarted);\r\n      try {\r\n        yield this.createAndSendOffer();\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n    }), debounceInterval);\r\n    this.close = () => {\r\n      if (!this._pc) {\r\n        return;\r\n      }\r\n      this._pc.close();\r\n      this._pc.onconnectionstatechange = null;\r\n      this._pc.oniceconnectionstatechange = null;\r\n      this._pc.onicegatheringstatechange = null;\r\n      this._pc.ondatachannel = null;\r\n      this._pc.onnegotiationneeded = null;\r\n      this._pc.onsignalingstatechange = null;\r\n      this._pc.onicecandidate = null;\r\n      this._pc.ondatachannel = null;\r\n      this._pc.ontrack = null;\r\n      this._pc.onconnectionstatechange = null;\r\n      this._pc.oniceconnectionstatechange = null;\r\n      this._pc = null;\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\r\n    this.loggerOptions = loggerOptions;\r\n    this.config = config;\r\n    this._pc = this.createPC();\r\n  }\r\n  createPC() {\r\n    const pc = new RTCPeerConnection(this.config);\r\n    pc.onicecandidate = ev => {\r\n      var _a;\r\n      if (!ev.candidate) return;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\r\n    };\r\n    pc.onicecandidateerror = ev => {\r\n      var _a;\r\n      (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    pc.oniceconnectionstatechange = () => {\r\n      var _a;\r\n      (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\r\n    };\r\n    pc.onsignalingstatechange = () => {\r\n      var _a;\r\n      (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\r\n    };\r\n    pc.onconnectionstatechange = () => {\r\n      var _a;\r\n      (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\r\n    };\r\n    pc.ondatachannel = ev => {\r\n      var _a;\r\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    pc.ontrack = ev => {\r\n      var _a;\r\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    return pc;\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  get isICEConnected() {\r\n    return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\r\n  }\r\n  addIceCandidate(candidate) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.pc.remoteDescription && !this.restartingIce) {\r\n        return this.pc.addIceCandidate(candidate);\r\n      }\r\n      this.pendingCandidates.push(candidate);\r\n    });\r\n  }\r\n  setRemoteDescription(sd) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      let mungedSDP = undefined;\r\n      if (sd.type === 'offer') {\r\n        let {\r\n          stereoMids,\r\n          nackMids\r\n        } = extractStereoAndNackAudioFromOffer(sd);\r\n        this.remoteStereoMids = stereoMids;\r\n        this.remoteNackMids = nackMids;\r\n      } else if (sd.type === 'answer') {\r\n        const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\r\n        sdpParsed.media.forEach(media => {\r\n          if (media.type === 'audio') {\r\n            // mung sdp for opus bitrate settings\r\n            this.trackBitrates.some(trackbr => {\r\n              if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\r\n                return false;\r\n              }\r\n              let codecPayload = 0;\r\n              media.rtp.some(rtp => {\r\n                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\r\n                  codecPayload = rtp.payload;\r\n                  return true;\r\n                }\r\n                return false;\r\n              });\r\n              if (codecPayload === 0) {\r\n                return true;\r\n              }\r\n              let fmtpFound = false;\r\n              for (const fmtp of media.fmtp) {\r\n                if (fmtp.payload === codecPayload) {\r\n                  fmtp.config = fmtp.config.split(';').filter(attr => !attr.includes('maxaveragebitrate')).join(';');\r\n                  if (trackbr.maxbr > 0) {\r\n                    fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\r\n                  }\r\n                  fmtpFound = true;\r\n                  break;\r\n                }\r\n              }\r\n              if (!fmtpFound) {\r\n                if (trackbr.maxbr > 0) {\r\n                  media.fmtp.push({\r\n                    payload: codecPayload,\r\n                    config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\r\n                  });\r\n                }\r\n              }\r\n              return true;\r\n            });\r\n          }\r\n        });\r\n        mungedSDP = libExports.write(sdpParsed);\r\n      }\r\n      yield this.setMungedSDP(sd, mungedSDP, true);\r\n      this.pendingCandidates.forEach(candidate => {\r\n        this.pc.addIceCandidate(candidate);\r\n      });\r\n      this.pendingCandidates = [];\r\n      this.restartingIce = false;\r\n      if (this.renegotiate) {\r\n        this.renegotiate = false;\r\n        yield this.createAndSendOffer();\r\n      } else if (sd.type === 'answer') {\r\n        this.emit(PCEvents.NegotiationComplete);\r\n        if (sd.sdp) {\r\n          const sdpParsed = libExports.parse(sd.sdp);\r\n          sdpParsed.media.forEach(media => {\r\n            if (media.type === 'video') {\r\n              this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n  createAndSendOffer(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (this.onOffer === undefined) {\r\n        return;\r\n      }\r\n      if (options === null || options === void 0 ? void 0 : options.iceRestart) {\r\n        this.log.debug('restarting ICE', this.logContext);\r\n        this.restartingIce = true;\r\n      }\r\n      if (this._pc && this._pc.signalingState === 'have-local-offer') {\r\n        // we're waiting for the peer to accept our offer, so we'll just wait\r\n        // the only exception to this is when ICE restart is needed\r\n        const currentSD = this._pc.remoteDescription;\r\n        if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\r\n          // TODO: handle when ICE restart is needed but we don't have a remote description\r\n          // the best thing to do is to recreate the peerconnection\r\n          yield this._pc.setRemoteDescription(currentSD);\r\n        } else {\r\n          this.renegotiate = true;\r\n          return;\r\n        }\r\n      } else if (!this._pc || this._pc.signalingState === 'closed') {\r\n        this.log.warn('could not createOffer with closed peer connection', this.logContext);\r\n        return;\r\n      }\r\n      // actually negotiate\r\n      this.log.debug('starting to negotiate', this.logContext);\r\n      const offer = yield this.pc.createOffer(options);\r\n      this.log.debug('original offer', Object.assign({\r\n        sdp: offer.sdp\r\n      }, this.logContext));\r\n      const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\r\n      sdpParsed.media.forEach(media => {\r\n        ensureIPAddrMatchVersion(media);\r\n        if (media.type === 'audio') {\r\n          ensureAudioNackAndStereo(media, [], []);\r\n        } else if (media.type === 'video') {\r\n          this.trackBitrates.some(trackbr => {\r\n            if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\r\n              return false;\r\n            }\r\n            let codecPayload = 0;\r\n            media.rtp.some(rtp => {\r\n              if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\r\n                codecPayload = rtp.payload;\r\n                return true;\r\n              }\r\n              return false;\r\n            });\r\n            if (codecPayload === 0) {\r\n              return true;\r\n            }\r\n            if (isSVCCodec(trackbr.codec)) {\r\n              this.ensureVideoDDExtensionForSVC(media, sdpParsed);\r\n            }\r\n            // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions\r\n            // mung sdp for av1 bitrate setting that can't apply by sendEncoding\r\n            if (trackbr.codec !== 'av1') {\r\n              return true;\r\n            }\r\n            const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\r\n            for (const fmtp of media.fmtp) {\r\n              if (fmtp.payload === codecPayload) {\r\n                // if another track's fmtp already is set, we cannot override the bitrate\r\n                // this has the unfortunate consequence of being forced to use the\r\n                // initial track's bitrate for all tracks\r\n                if (!fmtp.config.includes('x-google-start-bitrate')) {\r\n                  fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\r\n                }\r\n                break;\r\n              }\r\n            }\r\n            return true;\r\n          });\r\n        }\r\n      });\r\n      yield this.setMungedSDP(offer, libExports.write(sdpParsed));\r\n      this.onOffer(offer);\r\n    });\r\n  }\r\n  createAndSetAnswer() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const answer = yield this.pc.createAnswer();\r\n      const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\r\n      sdpParsed.media.forEach(media => {\r\n        ensureIPAddrMatchVersion(media);\r\n        if (media.type === 'audio') {\r\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\r\n        }\r\n      });\r\n      yield this.setMungedSDP(answer, libExports.write(sdpParsed));\r\n      return answer;\r\n    });\r\n  }\r\n  createDataChannel(label, dataChannelDict) {\r\n    return this.pc.createDataChannel(label, dataChannelDict);\r\n  }\r\n  addTransceiver(mediaStreamTrack, transceiverInit) {\r\n    return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\r\n  }\r\n  addTrack(track) {\r\n    if (!this._pc) {\r\n      throw new UnexpectedConnectionState('PC closed, cannot add track');\r\n    }\r\n    return this._pc.addTrack(track);\r\n  }\r\n  setTrackCodecBitrate(info) {\r\n    this.trackBitrates.push(info);\r\n  }\r\n  setConfiguration(rtcConfig) {\r\n    var _a;\r\n    if (!this._pc) {\r\n      throw new UnexpectedConnectionState('PC closed, cannot configure');\r\n    }\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\r\n  }\r\n  canRemoveTrack() {\r\n    var _a;\r\n    return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\r\n  }\r\n  removeTrack(sender) {\r\n    var _a;\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\r\n  }\r\n  getConnectionState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getICEConnectionState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getSignallingState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getTransceivers() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\r\n  }\r\n  getSenders() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\r\n  }\r\n  getLocalDescription() {\r\n    var _a;\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\r\n  }\r\n  getRemoteDescription() {\r\n    var _a;\r\n    return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\r\n  }\r\n  getStats() {\r\n    return this.pc.getStats();\r\n  }\r\n  getConnectedAddress() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!this._pc) {\r\n        return;\r\n      }\r\n      let selectedCandidatePairId = '';\r\n      const candidatePairs = new Map();\r\n      // id -> candidate ip\r\n      const candidates = new Map();\r\n      const stats = yield this._pc.getStats();\r\n      stats.forEach(v => {\r\n        switch (v.type) {\r\n          case 'transport':\r\n            selectedCandidatePairId = v.selectedCandidatePairId;\r\n            break;\r\n          case 'candidate-pair':\r\n            if (selectedCandidatePairId === '' && v.selected) {\r\n              selectedCandidatePairId = v.id;\r\n            }\r\n            candidatePairs.set(v.id, v);\r\n            break;\r\n          case 'remote-candidate':\r\n            candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\r\n            break;\r\n        }\r\n      });\r\n      if (selectedCandidatePairId === '') {\r\n        return undefined;\r\n      }\r\n      const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\r\n      if (selectedID === undefined) {\r\n        return undefined;\r\n      }\r\n      return candidates.get(selectedID);\r\n    });\r\n  }\r\n  setMungedSDP(sd, munged, remote) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (munged) {\r\n        const originalSdp = sd.sdp;\r\n        sd.sdp = munged;\r\n        try {\r\n          this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\r\n          if (remote) {\r\n            yield this.pc.setRemoteDescription(sd);\r\n          } else {\r\n            yield this.pc.setLocalDescription(sd);\r\n          }\r\n          return;\r\n        } catch (e) {\r\n          this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\r\n            error: e,\r\n            sdp: munged\r\n          }));\r\n          sd.sdp = originalSdp;\r\n        }\r\n      }\r\n      try {\r\n        if (remote) {\r\n          yield this.pc.setRemoteDescription(sd);\r\n        } else {\r\n          yield this.pc.setLocalDescription(sd);\r\n        }\r\n      } catch (e) {\r\n        let msg = 'unknown error';\r\n        if (e instanceof Error) {\r\n          msg = e.message;\r\n        } else if (typeof e === 'string') {\r\n          msg = e;\r\n        }\r\n        const fields = {\r\n          error: msg,\r\n          sdp: sd.sdp\r\n        };\r\n        if (!remote && this.pc.remoteDescription) {\r\n          fields.remoteSdp = this.pc.remoteDescription;\r\n        }\r\n        this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\r\n          fields\r\n        }));\r\n        throw new NegotiationError(msg);\r\n      }\r\n    });\r\n  }\r\n  ensureVideoDDExtensionForSVC(media, sdp) {\r\n    var _a, _b;\r\n    const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some(ext => {\r\n      if (ext.uri === ddExtensionURI) {\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n    if (!ddFound) {\r\n      if (this.ddExtID === 0) {\r\n        let maxID = 0;\r\n        sdp.media.forEach(m => {\r\n          var _a;\r\n          if (m.type !== 'video') {\r\n            return;\r\n          }\r\n          (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach(ext => {\r\n            if (ext.value > maxID) {\r\n              maxID = ext.value;\r\n            }\r\n          });\r\n        });\r\n        this.ddExtID = maxID + 1;\r\n      }\r\n      (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\r\n        value: this.ddExtID,\r\n        uri: ddExtensionURI\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\r\n  // found opus codec to add nack fb\r\n  let opusPayload = 0;\r\n  media.rtp.some(rtp => {\r\n    if (rtp.codec === 'opus') {\r\n      opusPayload = rtp.payload;\r\n      return true;\r\n    }\r\n    return false;\r\n  });\r\n  // add nack rtcpfb if not exist\r\n  if (opusPayload > 0) {\r\n    if (!media.rtcpFb) {\r\n      media.rtcpFb = [];\r\n    }\r\n    if (nackMids.includes(media.mid) && !media.rtcpFb.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\r\n      media.rtcpFb.push({\r\n        payload: opusPayload,\r\n        type: 'nack'\r\n      });\r\n    }\r\n    if (stereoMids.includes(media.mid)) {\r\n      media.fmtp.some(fmtp => {\r\n        if (fmtp.payload === opusPayload) {\r\n          if (!fmtp.config.includes('stereo=1')) {\r\n            fmtp.config += ';stereo=1';\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction extractStereoAndNackAudioFromOffer(offer) {\r\n  var _a;\r\n  const stereoMids = [];\r\n  const nackMids = [];\r\n  const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\r\n  let opusPayload = 0;\r\n  sdpParsed.media.forEach(media => {\r\n    var _a;\r\n    if (media.type === 'audio') {\r\n      media.rtp.some(rtp => {\r\n        if (rtp.codec === 'opus') {\r\n          opusPayload = rtp.payload;\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\r\n        nackMids.push(media.mid);\r\n      }\r\n      media.fmtp.some(fmtp => {\r\n        if (fmtp.payload === opusPayload) {\r\n          if (fmtp.config.includes('sprop-stereo=1')) {\r\n            stereoMids.push(media.mid);\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n    }\r\n  });\r\n  return {\r\n    stereoMids,\r\n    nackMids\r\n  };\r\n}\r\nfunction ensureIPAddrMatchVersion(media) {\r\n  // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\r\n  // in edge case and return error when set sdp.This is not a\r\n  // sdk error but correct it if the issue detected.\r\n  if (media.connection) {\r\n    const isV6 = media.connection.ip.indexOf(':') >= 0;\r\n    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\r\n      // fallback to dummy address\r\n      media.connection.ip = '0.0.0.0';\r\n      media.connection.version = 4;\r\n    }\r\n  }\r\n}\r\n\r\nconst defaultVideoCodec = 'vp8';\r\nconst publishDefaults = {\r\n  audioPreset: AudioPresets.music,\r\n  dtx: true,\r\n  red: true,\r\n  forceStereo: false,\r\n  simulcast: true,\r\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\r\n  stopMicTrackOnMute: false,\r\n  videoCodec: defaultVideoCodec,\r\n  backupCodec: true,\r\n  preConnectBuffer: false\r\n};\r\nconst audioDefaults = {\r\n  deviceId: {\r\n    ideal: 'default'\r\n  },\r\n  autoGainControl: true,\r\n  echoCancellation: true,\r\n  noiseSuppression: true,\r\n  voiceIsolation: true\r\n};\r\nconst videoDefaults = {\r\n  deviceId: {\r\n    ideal: 'default'\r\n  },\r\n  resolution: VideoPresets.h720.resolution\r\n};\r\nconst roomOptionDefaults = {\r\n  adaptiveStream: false,\r\n  dynacast: false,\r\n  stopLocalTrackOnUnpublish: true,\r\n  reconnectPolicy: new DefaultReconnectPolicy(),\r\n  disconnectOnPageLeave: true,\r\n  webAudioMix: false\r\n};\r\nconst roomConnectOptionDefaults = {\r\n  autoSubscribe: true,\r\n  maxRetries: 1,\r\n  peerConnectionTimeout: 15000,\r\n  websocketTimeout: 15000\r\n};\r\n\r\nvar PCTransportState;\r\n(function (PCTransportState) {\r\n  PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\r\n  PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\r\n  PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\r\n  PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\r\n  PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\r\n  PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\r\n})(PCTransportState || (PCTransportState = {}));\r\nclass PCTransportManager {\r\n  get needsPublisher() {\r\n    return this.isPublisherConnectionRequired;\r\n  }\r\n  get needsSubscriber() {\r\n    return this.isSubscriberConnectionRequired;\r\n  }\r\n  get currentState() {\r\n    return this.state;\r\n  }\r\n  constructor(rtcConfig, subscriberPrimary, loggerOptions) {\r\n    var _a;\r\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\r\n    this.log = livekitLogger;\r\n    this.updateState = () => {\r\n      var _a;\r\n      const previousState = this.state;\r\n      const connectionStates = this.requiredTransports.map(tr => tr.getConnectionState());\r\n      if (connectionStates.every(st => st === 'connected')) {\r\n        this.state = PCTransportState.CONNECTED;\r\n      } else if (connectionStates.some(st => st === 'failed')) {\r\n        this.state = PCTransportState.FAILED;\r\n      } else if (connectionStates.some(st => st === 'connecting')) {\r\n        this.state = PCTransportState.CONNECTING;\r\n      } else if (connectionStates.every(st => st === 'closed')) {\r\n        this.state = PCTransportState.CLOSED;\r\n      } else if (connectionStates.some(st => st === 'closed')) {\r\n        this.state = PCTransportState.CLOSING;\r\n      } else if (connectionStates.every(st => st === 'new')) {\r\n        this.state = PCTransportState.NEW;\r\n      }\r\n      if (previousState !== this.state) {\r\n        this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\r\n        (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\r\n      }\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\r\n    this.loggerOptions = loggerOptions;\r\n    this.isPublisherConnectionRequired = !subscriberPrimary;\r\n    this.isSubscriberConnectionRequired = subscriberPrimary;\r\n    this.publisher = new PCTransport(rtcConfig, loggerOptions);\r\n    this.subscriber = new PCTransport(rtcConfig, loggerOptions);\r\n    this.publisher.onConnectionStateChange = this.updateState;\r\n    this.subscriber.onConnectionStateChange = this.updateState;\r\n    this.publisher.onIceConnectionStateChange = this.updateState;\r\n    this.subscriber.onIceConnectionStateChange = this.updateState;\r\n    this.publisher.onSignalingStatechange = this.updateState;\r\n    this.subscriber.onSignalingStatechange = this.updateState;\r\n    this.publisher.onIceCandidate = candidate => {\r\n      var _a;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\r\n    };\r\n    this.subscriber.onIceCandidate = candidate => {\r\n      var _a;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\r\n    };\r\n    // in subscriber primary mode, server side opens sub data channels.\r\n    this.subscriber.onDataChannel = ev => {\r\n      var _a;\r\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    this.subscriber.onTrack = ev => {\r\n      var _a;\r\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    this.publisher.onOffer = offer => {\r\n      var _a;\r\n      (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\r\n    };\r\n    this.state = PCTransportState.NEW;\r\n    this.connectionLock = new _();\r\n    this.remoteOfferLock = new _();\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  requirePublisher() {\r\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    this.isPublisherConnectionRequired = require;\r\n    this.updateState();\r\n  }\r\n  requireSubscriber() {\r\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    this.isSubscriberConnectionRequired = require;\r\n    this.updateState();\r\n  }\r\n  createAndSendPublisherOffer(options) {\r\n    return this.publisher.createAndSendOffer(options);\r\n  }\r\n  setPublisherAnswer(sd) {\r\n    return this.publisher.setRemoteDescription(sd);\r\n  }\r\n  removeTrack(sender) {\r\n    return this.publisher.removeTrack(sender);\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\r\n        const publisher = this.publisher;\r\n        for (const sender of publisher.getSenders()) {\r\n          try {\r\n            // TODO: react-native-webrtc doesn't have removeTrack yet.\r\n            if (publisher.canRemoveTrack()) {\r\n              publisher.removeTrack(sender);\r\n            }\r\n          } catch (e) {\r\n            this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\r\n              error: e\r\n            }));\r\n          }\r\n        }\r\n      }\r\n      yield Promise.all([this.publisher.close(), this.subscriber.close()]);\r\n      this.updateState();\r\n    });\r\n  }\r\n  triggerIceRestart() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.subscriber.restartingIce = true;\r\n      // only restart publisher if it's needed\r\n      if (this.needsPublisher) {\r\n        yield this.createAndSendPublisherOffer({\r\n          iceRestart: true\r\n        });\r\n      }\r\n    });\r\n  }\r\n  addIceCandidate(candidate, target) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (target === SignalTarget.PUBLISHER) {\r\n        yield this.publisher.addIceCandidate(candidate);\r\n      } else {\r\n        yield this.subscriber.addIceCandidate(candidate);\r\n      }\r\n    });\r\n  }\r\n  createSubscriberAnswerFromOffer(sd) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\r\n        RTCSdpType: sd.type,\r\n        sdp: sd.sdp,\r\n        signalingState: this.subscriber.getSignallingState().toString()\r\n      }));\r\n      const unlock = yield this.remoteOfferLock.lock();\r\n      try {\r\n        yield this.subscriber.setRemoteDescription(sd);\r\n        // answer the offer\r\n        const answer = yield this.subscriber.createAndSetAnswer();\r\n        return answer;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  updateConfiguration(config, iceRestart) {\r\n    this.publisher.setConfiguration(config);\r\n    this.subscriber.setConfiguration(config);\r\n    if (iceRestart) {\r\n      this.triggerIceRestart();\r\n    }\r\n  }\r\n  ensurePCTransportConnection(abortController, timeout) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.connectionLock.lock();\r\n      try {\r\n        if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\r\n          this.log.debug('negotiation required, start negotiating', this.logContext);\r\n          this.publisher.negotiate();\r\n        }\r\n        yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map(transport => this.ensureTransportConnected(transport, abortController, timeout)));\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  negotiate(abortController) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        const negotiationTimeout = setTimeout(() => {\r\n          reject('negotiation timed out');\r\n        }, this.peerConnectionTimeout);\r\n        const abortHandler = () => {\r\n          clearTimeout(negotiationTimeout);\r\n          reject('negotiation aborted');\r\n        };\r\n        abortController.signal.addEventListener('abort', abortHandler);\r\n        this.publisher.once(PCEvents.NegotiationStarted, () => {\r\n          if (abortController.signal.aborted) {\r\n            return;\r\n          }\r\n          this.publisher.once(PCEvents.NegotiationComplete, () => {\r\n            clearTimeout(negotiationTimeout);\r\n            resolve();\r\n          });\r\n        });\r\n        yield this.publisher.negotiate(e => {\r\n          clearTimeout(negotiationTimeout);\r\n          reject(e);\r\n        });\r\n      }));\r\n    });\r\n  }\r\n  addPublisherTransceiver(track, transceiverInit) {\r\n    return this.publisher.addTransceiver(track, transceiverInit);\r\n  }\r\n  addPublisherTrack(track) {\r\n    return this.publisher.addTrack(track);\r\n  }\r\n  createPublisherDataChannel(label, dataChannelDict) {\r\n    return this.publisher.createDataChannel(label, dataChannelDict);\r\n  }\r\n  /**\r\n   * Returns the first required transport's address if no explicit target is specified\r\n   */\r\n  getConnectedAddress(target) {\r\n    if (target === SignalTarget.PUBLISHER) {\r\n      return this.publisher.getConnectedAddress();\r\n    } else if (target === SignalTarget.SUBSCRIBER) {\r\n      return this.publisher.getConnectedAddress();\r\n    }\r\n    return this.requiredTransports[0].getConnectedAddress();\r\n  }\r\n  get requiredTransports() {\r\n    const transports = [];\r\n    if (this.isPublisherConnectionRequired) {\r\n      transports.push(this.publisher);\r\n    }\r\n    if (this.isSubscriberConnectionRequired) {\r\n      transports.push(this.subscriber);\r\n    }\r\n    return transports;\r\n  }\r\n  ensureTransportConnected(pcTransport_1, abortController_1) {\r\n    return __awaiter(this, arguments, void 0, function (pcTransport, abortController) {\r\n      var _this = this;\r\n      let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\r\n      return function* () {\r\n        const connectionState = pcTransport.getConnectionState();\r\n        if (connectionState === 'connected') {\r\n          return;\r\n        }\r\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\r\n          const abortHandler = () => {\r\n            this.log.warn('abort transport connection', this.logContext);\r\n            CriticalTimers.clearTimeout(connectTimeout);\r\n            reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\r\n          };\r\n          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\r\n            abortHandler();\r\n          }\r\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\r\n          const connectTimeout = CriticalTimers.setTimeout(() => {\r\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\r\n            reject(new ConnectionError('could not establish pc connection', ConnectionErrorReason.InternalError));\r\n          }, timeout);\r\n          while (this.state !== PCTransportState.CONNECTED) {\r\n            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\r\n            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\r\n              reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\r\n              return;\r\n            }\r\n          }\r\n          CriticalTimers.clearTimeout(connectTimeout);\r\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\r\n          resolve();\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n}\r\n\r\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\r\n//\r\n// SPDX-License-Identifier: Apache-2.0\r\n/**\r\n * Specialized error handling for RPC methods.\r\n *\r\n * Instances of this type, when thrown in a method handler, will have their `message`\r\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\r\n *\r\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\r\n */\r\nclass RpcError extends Error {\r\n  /**\r\n   * Creates an error object with the given code and message, plus an optional data payload.\r\n   *\r\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\r\n   *\r\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\r\n   */\r\n  constructor(code, message, data) {\r\n    super(message);\r\n    this.code = code;\r\n    this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\r\n    this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  static fromProto(proto) {\r\n    return new RpcError(proto.code, proto.message, proto.data);\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  toProto() {\r\n    return new RpcError$1({\r\n      code: this.code,\r\n      message: this.message,\r\n      data: this.data\r\n    });\r\n  }\r\n  /**\r\n   * Creates an error object from the code, with an auto-populated message.\r\n   *\r\n   * @internal\r\n   */\r\n  static builtIn(key, data) {\r\n    return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\r\n  }\r\n}\r\nRpcError.MAX_MESSAGE_BYTES = 256;\r\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\r\nRpcError.ErrorCode = {\r\n  APPLICATION_ERROR: 1500,\r\n  CONNECTION_TIMEOUT: 1501,\r\n  RESPONSE_TIMEOUT: 1502,\r\n  RECIPIENT_DISCONNECTED: 1503,\r\n  RESPONSE_PAYLOAD_TOO_LARGE: 1504,\r\n  SEND_FAILED: 1505,\r\n  UNSUPPORTED_METHOD: 1400,\r\n  RECIPIENT_NOT_FOUND: 1401,\r\n  REQUEST_PAYLOAD_TOO_LARGE: 1402,\r\n  UNSUPPORTED_SERVER: 1403,\r\n  UNSUPPORTED_VERSION: 1404\r\n};\r\n/**\r\n * @internal\r\n */\r\nRpcError.ErrorMessage = {\r\n  APPLICATION_ERROR: 'Application error in method handler',\r\n  CONNECTION_TIMEOUT: 'Connection timeout',\r\n  RESPONSE_TIMEOUT: 'Response timeout',\r\n  RECIPIENT_DISCONNECTED: 'Recipient disconnected',\r\n  RESPONSE_PAYLOAD_TOO_LARGE: 'Response payload too large',\r\n  SEND_FAILED: 'Failed to send',\r\n  UNSUPPORTED_METHOD: 'Method not supported at destination',\r\n  RECIPIENT_NOT_FOUND: 'Recipient not found',\r\n  REQUEST_PAYLOAD_TOO_LARGE: 'Request payload too large',\r\n  UNSUPPORTED_SERVER: 'RPC not supported by server',\r\n  UNSUPPORTED_VERSION: 'Unsupported RPC version'\r\n};\r\n/*\r\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\r\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\r\n */\r\nconst MAX_PAYLOAD_BYTES = 15360; // 15 KB\r\n/**\r\n * @internal\r\n */\r\nfunction byteLength(str) {\r\n  const encoder = new TextEncoder();\r\n  return encoder.encode(str).length;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction truncateBytes(str, maxBytes) {\r\n  if (byteLength(str) <= maxBytes) {\r\n    return str;\r\n  }\r\n  let low = 0;\r\n  let high = str.length;\r\n  const encoder = new TextEncoder();\r\n  while (low < high) {\r\n    const mid = Math.floor((low + high + 1) / 2);\r\n    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\r\n      low = mid;\r\n    } else {\r\n      high = mid - 1;\r\n    }\r\n  }\r\n  return str.slice(0, low);\r\n}\r\n\r\nconst monitorFrequency = 2000;\r\nfunction computeBitrate(currentStats, prevStats) {\r\n  if (!prevStats) {\r\n    return 0;\r\n  }\r\n  let bytesNow;\r\n  let bytesPrev;\r\n  if ('bytesReceived' in currentStats) {\r\n    bytesNow = currentStats.bytesReceived;\r\n    bytesPrev = prevStats.bytesReceived;\r\n  } else if ('bytesSent' in currentStats) {\r\n    bytesNow = currentStats.bytesSent;\r\n    bytesPrev = prevStats.bytesSent;\r\n  }\r\n  if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\r\n    return 0;\r\n  }\r\n  return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\r\n}\r\n\r\n// Check if MediaRecorder is available\r\nconst isMediaRecorderAvailable = typeof MediaRecorder !== 'undefined';\r\n// Fallback class for environments without MediaRecorder\r\nclass FallbackRecorder {\r\n  constructor() {\r\n    throw new Error('MediaRecorder is not available in this environment');\r\n  }\r\n}\r\n// Use conditional inheritance to avoid parse-time errors\r\nconst RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;\r\nclass LocalTrackRecorder extends RecorderBase {\r\n  constructor(track, options) {\r\n    if (!isMediaRecorderAvailable) {\r\n      throw new Error('MediaRecorder is not available in this environment');\r\n    }\r\n    super(new MediaStream([track.mediaStreamTrack]), options);\r\n    let dataListener;\r\n    let streamController;\r\n    const isClosed = () => streamController === undefined;\r\n    const onStop = () => {\r\n      this.removeEventListener('dataavailable', dataListener);\r\n      this.removeEventListener('stop', onStop);\r\n      this.removeEventListener('error', onError);\r\n      streamController === null || streamController === void 0 ? void 0 : streamController.close();\r\n      streamController = undefined;\r\n    };\r\n    const onError = event => {\r\n      streamController === null || streamController === void 0 ? void 0 : streamController.error(event);\r\n      this.removeEventListener('dataavailable', dataListener);\r\n      this.removeEventListener('stop', onStop);\r\n      this.removeEventListener('error', onError);\r\n      streamController = undefined;\r\n    };\r\n    this.byteStream = new ReadableStream({\r\n      start: controller => {\r\n        streamController = controller;\r\n        dataListener = event => __awaiter(this, void 0, void 0, function* () {\r\n          const arrayBuffer = yield event.data.arrayBuffer();\r\n          if (isClosed()) {\r\n            return;\r\n          }\r\n          controller.enqueue(new Uint8Array(arrayBuffer));\r\n        });\r\n        this.addEventListener('dataavailable', dataListener);\r\n      },\r\n      cancel: () => {\r\n        onStop();\r\n      }\r\n    });\r\n    this.addEventListener('stop', onStop);\r\n    this.addEventListener('error', onError);\r\n  }\r\n}\r\n// Helper function to check if recording is supported\r\nfunction isRecordingSupported() {\r\n  return isMediaRecorderAvailable;\r\n}\r\n\r\nconst DEFAULT_DIMENSIONS_TIMEOUT = 1000;\r\nconst PRE_CONNECT_BUFFER_TIMEOUT = 10000;\r\nclass LocalTrack extends Track {\r\n  /** @internal */\r\n  get sender() {\r\n    return this._sender;\r\n  }\r\n  /** @internal */\r\n  set sender(sender) {\r\n    this._sender = sender;\r\n  }\r\n  get constraints() {\r\n    return this._constraints;\r\n  }\r\n  get hasPreConnectBuffer() {\r\n    return !!this.localTrackRecorder;\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param kind\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, kind, constraints) {\r\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n    super(mediaTrack, kind, loggerOptions);\r\n    this.manuallyStopped = false;\r\n    this._isUpstreamPaused = false;\r\n    this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\r\n    this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {\r\n      yield this.pauseUpstream();\r\n    }), 5000);\r\n    this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {\r\n      this.debouncedTrackMuteHandler.cancel('unmute');\r\n      yield this.resumeUpstream();\r\n    });\r\n    this.handleEnded = () => {\r\n      if (this.isInBackground) {\r\n        this.reacquireTrack = true;\r\n      }\r\n      this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n      this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n      this.emit(TrackEvent.Ended, this);\r\n    };\r\n    this.reacquireTrack = false;\r\n    this.providedByUser = userProvidedTrack;\r\n    this.muteLock = new _();\r\n    this.pauseUpstreamLock = new _();\r\n    this.processorLock = new _();\r\n    this.restartLock = new _();\r\n    this.setMediaStreamTrack(mediaTrack, true);\r\n    // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\r\n    this._constraints = mediaTrack.getConstraints();\r\n    if (constraints) {\r\n      this._constraints = constraints;\r\n    }\r\n  }\r\n  get id() {\r\n    return this._mediaStreamTrack.id;\r\n  }\r\n  get dimensions() {\r\n    if (this.kind !== Track.Kind.Video) {\r\n      return undefined;\r\n    }\r\n    const {\r\n      width,\r\n      height\r\n    } = this._mediaStreamTrack.getSettings();\r\n    if (width && height) {\r\n      return {\r\n        width,\r\n        height\r\n      };\r\n    }\r\n    return undefined;\r\n  }\r\n  get isUpstreamPaused() {\r\n    return this._isUpstreamPaused;\r\n  }\r\n  get isUserProvided() {\r\n    return this.providedByUser;\r\n  }\r\n  get mediaStreamTrack() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /**\r\n   * @internal\r\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\r\n   */\r\n  getSourceTrackSettings() {\r\n    return this._mediaStreamTrack.getSettings();\r\n  }\r\n  setMediaStreamTrack(newTrack, force) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (newTrack === this._mediaStreamTrack && !force) {\r\n        return;\r\n      }\r\n      if (this._mediaStreamTrack) {\r\n        // detach\r\n        this.attachedElements.forEach(el => {\r\n          detachTrack(this._mediaStreamTrack, el);\r\n        });\r\n        this.debouncedTrackMuteHandler.cancel('new-track');\r\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n      }\r\n      this.mediaStream = new MediaStream([newTrack]);\r\n      if (newTrack) {\r\n        newTrack.addEventListener('ended', this.handleEnded);\r\n        // when underlying track emits mute, it indicates that the device is unable\r\n        // to produce media. In this case we'll need to signal with remote that\r\n        // the track is \"muted\"\r\n        // note this is different from LocalTrack.mute because we do not want to\r\n        // touch MediaStreamTrack.enabled\r\n        newTrack.addEventListener('mute', this.handleTrackMuteEvent);\r\n        newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\r\n        this._constraints = newTrack.getConstraints();\r\n      }\r\n      let processedTrack;\r\n      if (this.processor && newTrack) {\r\n        const unlock = yield this.processorLock.lock();\r\n        try {\r\n          this.log.debug('restarting processor', this.logContext);\r\n          if (this.kind === 'unknown') {\r\n            throw TypeError('cannot set processor on track of unknown kind');\r\n          }\r\n          if (this.processorElement) {\r\n            attachToElement(newTrack, this.processorElement);\r\n            // ensure the processorElement itself stays muted\r\n            this.processorElement.muted = true;\r\n          }\r\n          yield this.processor.restart({\r\n            track: newTrack,\r\n            kind: this.kind,\r\n            element: this.processorElement\r\n          });\r\n          processedTrack = this.processor.processedTrack;\r\n        } finally {\r\n          unlock();\r\n        }\r\n      }\r\n      if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n        yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\r\n      }\r\n      // if `newTrack` is different from the existing track, stop the\r\n      // older track just before replacing it\r\n      if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\r\n        this._mediaStreamTrack.stop();\r\n      }\r\n      this._mediaStreamTrack = newTrack;\r\n      if (newTrack) {\r\n        // sync muted state with the enabled state of the newly provided track\r\n        this._mediaStreamTrack.enabled = !this.isMuted;\r\n        // when a valid track is replace, we'd want to start producing\r\n        yield this.resumeUpstream();\r\n        this.attachedElements.forEach(el => {\r\n          attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  waitForDimensions() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this = this;\r\n      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_DIMENSIONS_TIMEOUT;\r\n      return function* () {\r\n        var _a;\r\n        if (_this.kind === Track.Kind.Audio) {\r\n          throw new Error('cannot get dimensions for audio tracks');\r\n        }\r\n        if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\r\n          // browsers report wrong initial resolution on iOS.\r\n          // when slightly delaying the call to .getSettings(), the correct resolution is being reported\r\n          yield sleep(10);\r\n        }\r\n        const started = Date.now();\r\n        while (Date.now() - started < timeout) {\r\n          const dims = _this.dimensions;\r\n          if (dims) {\r\n            return dims;\r\n          }\r\n          yield sleep(50);\r\n        }\r\n        throw new TrackInvalidError('unable to get track dimensions after timeout');\r\n      }();\r\n    });\r\n  }\r\n  setDeviceId(deviceId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\r\n        return true;\r\n      }\r\n      this._constraints.deviceId = deviceId;\r\n      // when track is muted, underlying media stream track is stopped and\r\n      // will be restarted later\r\n      if (this.isMuted) {\r\n        return true;\r\n      }\r\n      yield this.restartTrack();\r\n      return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\r\n    });\r\n  }\r\n  /**\r\n   * @returns DeviceID of the device that is currently being used for this track\r\n   */\r\n  getDeviceId() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this2 = this;\r\n      let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        // screen share doesn't have a usable device id\r\n        if (_this2.source === Track.Source.ScreenShare) {\r\n          return;\r\n        }\r\n        const {\r\n          deviceId,\r\n          groupId\r\n        } = _this2._mediaStreamTrack.getSettings();\r\n        const kind = _this2.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\r\n        return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\r\n      }();\r\n    });\r\n  }\r\n  mute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.setTrackMuted(true);\r\n      return this;\r\n    });\r\n  }\r\n  unmute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.setTrackMuted(false);\r\n      return this;\r\n    });\r\n  }\r\n  replaceTrack(track, userProvidedOrOptions) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        throw new TrackInvalidError('unable to replace an unpublished track');\r\n      }\r\n      let userProvidedTrack;\r\n      let stopProcessor;\r\n      if (typeof userProvidedOrOptions === 'boolean') {\r\n        userProvidedTrack = userProvidedOrOptions;\r\n      } else if (userProvidedOrOptions !== undefined) {\r\n        userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\r\n        stopProcessor = userProvidedOrOptions.stopProcessor;\r\n      }\r\n      this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\r\n      this.log.debug('replace MediaStreamTrack', this.logContext);\r\n      yield this.setMediaStreamTrack(track);\r\n      // this must be synced *after* setting mediaStreamTrack above, since it relies\r\n      // on the previous state in order to cleanup\r\n      if (stopProcessor && this.processor) {\r\n        yield this.stopProcessor();\r\n      }\r\n      return this;\r\n    });\r\n  }\r\n  restart(constraints) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.manuallyStopped = false;\r\n      const unlock = yield this.restartLock.lock();\r\n      try {\r\n        if (!constraints) {\r\n          constraints = this._constraints;\r\n        }\r\n        const {\r\n            deviceId,\r\n            facingMode\r\n          } = constraints,\r\n          otherConstraints = __rest(constraints, [\"deviceId\", \"facingMode\"]);\r\n        this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\r\n          constraints\r\n        }));\r\n        const streamConstraints = {\r\n          audio: false,\r\n          video: false\r\n        };\r\n        if (this.kind === Track.Kind.Video) {\r\n          streamConstraints.video = deviceId || facingMode ? {\r\n            deviceId,\r\n            facingMode\r\n          } : true;\r\n        } else {\r\n          streamConstraints.audio = deviceId ? {\r\n            deviceId\r\n          } : true;\r\n        }\r\n        // these steps are duplicated from setMediaStreamTrack because we must stop\r\n        // the previous tracks before new tracks can be acquired\r\n        this.attachedElements.forEach(el => {\r\n          detachTrack(this.mediaStreamTrack, el);\r\n        });\r\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n        // on Safari, the old audio track must be stopped before attempting to acquire\r\n        // the new track, otherwise the new track will stop with\r\n        // 'A MediaStreamTrack ended due to a capture failure`\r\n        this._mediaStreamTrack.stop();\r\n        // create new track and attach\r\n        const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\r\n        const newTrack = mediaStream.getTracks()[0];\r\n        yield newTrack.applyConstraints(otherConstraints);\r\n        newTrack.addEventListener('ended', this.handleEnded);\r\n        this.log.debug('re-acquired MediaStreamTrack', this.logContext);\r\n        yield this.setMediaStreamTrack(newTrack);\r\n        this._constraints = constraints;\r\n        this.emit(TrackEvent.Restarted, this);\r\n        if (this.manuallyStopped) {\r\n          this.log.warn('track was stopped during a restart, stopping restarted track', this.logContext);\r\n          this.stop();\r\n        }\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  setTrackMuted(muted) {\r\n    this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\r\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\r\n      return;\r\n    }\r\n    this.isMuted = muted;\r\n    this._mediaStreamTrack.enabled = !muted;\r\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\r\n  }\r\n  get needsReAcquisition() {\r\n    return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!isMobile()) return;\r\n      this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\r\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\r\n        this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\r\n        yield this.restart();\r\n        this.reacquireTrack = false;\r\n      }\r\n    });\r\n  }\r\n  stop() {\r\n    var _a;\r\n    this.manuallyStopped = true;\r\n    super.stop();\r\n    this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n    this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n    this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n    (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\r\n    this.processor = undefined;\r\n  }\r\n  /**\r\n   * pauses publishing to the server without disabling the local MediaStreamTrack\r\n   * this is used to display a user's own video locally while pausing publishing to\r\n   * the server.\r\n   * this API is unsupported on Safari < 12 due to a bug\r\n   **/\r\n  pauseUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.pauseUpstreamLock.lock();\r\n      try {\r\n        if (this._isUpstreamPaused === true) {\r\n          return;\r\n        }\r\n        if (!this.sender) {\r\n          this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\r\n          return;\r\n        }\r\n        this._isUpstreamPaused = true;\r\n        this.emit(TrackEvent.UpstreamPaused, this);\r\n        const browser = getBrowser();\r\n        if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\r\n          // https://bugs.webkit.org/show_bug.cgi?id=184911\r\n          throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\r\n        }\r\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n          yield this.sender.replaceTrack(null);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  resumeUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.pauseUpstreamLock.lock();\r\n      try {\r\n        if (this._isUpstreamPaused === false) {\r\n          return;\r\n        }\r\n        if (!this.sender) {\r\n          this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\r\n          return;\r\n        }\r\n        this._isUpstreamPaused = false;\r\n        this.emit(TrackEvent.UpstreamResumed, this);\r\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n          // this operation is noop if mediastreamtrack is already being sent\r\n          yield this.sender.replaceTrack(this.mediaStreamTrack);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\r\n   *\r\n   * @returns Promise<RTCStatsReport> | undefined\r\n   */\r\n  getRTCStatsReport() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return;\r\n      }\r\n      const statsReport = yield this.sender.getStats();\r\n      return statsReport;\r\n    });\r\n  }\r\n  /**\r\n   * Sets a processor on this track.\r\n   * See https://github.com/livekit/track-processors-js for example usage\r\n   *\r\n   * @experimental\r\n   *\r\n   * @param processor\r\n   * @param showProcessedStreamLocally\r\n   * @returns\r\n   */\r\n  setProcessor(processor_1) {\r\n    return __awaiter(this, arguments, void 0, function (processor) {\r\n      var _this3 = this;\r\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a;\r\n        const unlock = yield _this3.processorLock.lock();\r\n        try {\r\n          _this3.log.debug('setting up processor', _this3.logContext);\r\n          const processorElement = document.createElement(_this3.kind);\r\n          const processorOptions = {\r\n            kind: _this3.kind,\r\n            track: _this3._mediaStreamTrack,\r\n            element: processorElement,\r\n            audioContext: _this3.audioContext\r\n          };\r\n          yield processor.init(processorOptions);\r\n          _this3.log.debug('processor initialized', _this3.logContext);\r\n          if (_this3.processor) {\r\n            yield _this3.stopProcessor();\r\n          }\r\n          if (_this3.kind === 'unknown') {\r\n            throw TypeError('cannot set processor on track of unknown kind');\r\n          }\r\n          attachToElement(_this3._mediaStreamTrack, processorElement);\r\n          processorElement.muted = true;\r\n          processorElement.play().catch(error => _this3.log.error('failed to play processor element', Object.assign(Object.assign({}, _this3.logContext), {\r\n            error\r\n          })));\r\n          _this3.processor = processor;\r\n          _this3.processorElement = processorElement;\r\n          if (_this3.processor.processedTrack) {\r\n            for (const el of _this3.attachedElements) {\r\n              if (el !== _this3.processorElement && showProcessedStreamLocally) {\r\n                detachTrack(_this3._mediaStreamTrack, el);\r\n                attachToElement(_this3.processor.processedTrack, el);\r\n              }\r\n            }\r\n            yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\r\n          }\r\n          _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\r\n        } finally {\r\n          unlock();\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  getProcessor() {\r\n    return this.processor;\r\n  }\r\n  /**\r\n   * Stops the track processor\r\n   * See https://github.com/livekit/track-processors-js for example usage\r\n   *\r\n   * @experimental\r\n   * @returns\r\n   */\r\n  stopProcessor() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this4 = this;\r\n      let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        var _a, _b;\r\n        if (!_this4.processor) return;\r\n        _this4.log.debug('stopping processor', _this4.logContext);\r\n        (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\r\n        yield _this4.processor.destroy();\r\n        _this4.processor = undefined;\r\n        if (!keepElement) {\r\n          (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\r\n          _this4.processorElement = undefined;\r\n        }\r\n        // apply original track constraints in case the processor changed them\r\n        yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);\r\n        // force re-setting of the mediaStreamTrack on the sender\r\n        yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);\r\n        _this4.emit(TrackEvent.TrackProcessorUpdate);\r\n      }();\r\n    });\r\n  }\r\n  /** @internal */\r\n  startPreConnectBuffer() {\r\n    let timeslice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\r\n    if (!isRecordingSupported()) {\r\n      this.log.warn('MediaRecorder is not available, cannot start preconnect buffer', this.logContext);\r\n      return;\r\n    }\r\n    if (!this.localTrackRecorder) {\r\n      this.localTrackRecorder = new LocalTrackRecorder(this, {\r\n        mimeType: 'audio/webm;codecs=opus'\r\n      });\r\n    } else {\r\n      this.log.warn('preconnect buffer already started');\r\n      return;\r\n    }\r\n    this.localTrackRecorder.start(timeslice);\r\n    this.autoStopPreConnectBuffer = setTimeout(() => {\r\n      this.log.warn('preconnect buffer timed out, stopping recording automatically', this.logContext);\r\n      this.stopPreConnectBuffer();\r\n    }, PRE_CONNECT_BUFFER_TIMEOUT);\r\n  }\r\n  /** @internal */\r\n  stopPreConnectBuffer() {\r\n    clearTimeout(this.autoStopPreConnectBuffer);\r\n    if (this.localTrackRecorder) {\r\n      this.localTrackRecorder.stop();\r\n      this.localTrackRecorder = undefined;\r\n    }\r\n  }\r\n  /** @internal */\r\n  getPreConnectBuffer() {\r\n    var _a;\r\n    return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.byteStream;\r\n  }\r\n}\r\n\r\nclass LocalAudioTrack extends LocalTrack {\r\n  /**\r\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\r\n   */\r\n  get enhancedNoiseCancellation() {\r\n    return this.isKrispNoiseFilterEnabled;\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, constraints) {\r\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n    let audioContext = arguments.length > 3 ? arguments[3] : undefined;\r\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\r\n    /** @internal */\r\n    this.stopOnMute = false;\r\n    this.isKrispNoiseFilterEnabled = false;\r\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      let stats;\r\n      try {\r\n        stats = yield this.getSenderStats();\r\n      } catch (e) {\r\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n        return;\r\n      }\r\n      if (stats && this.prevStats) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.handleKrispNoiseFilterEnable = () => {\r\n      this.isKrispNoiseFilterEnabled = true;\r\n      this.log.debug(\"Krisp noise filter enabled\", this.logContext);\r\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\r\n    };\r\n    this.handleKrispNoiseFilterDisable = () => {\r\n      this.isKrispNoiseFilterEnabled = false;\r\n      this.log.debug(\"Krisp noise filter disabled\", this.logContext);\r\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\r\n    };\r\n    this.audioContext = audioContext;\r\n    this.checkForSilence();\r\n  }\r\n  mute() {\r\n    const _super = Object.create(null, {\r\n      mute: {\r\n        get: () => super.mute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (this.isMuted) {\r\n          this.log.debug('Track already muted', this.logContext);\r\n          return this;\r\n        }\r\n        // disabled special handling as it will cause BT headsets to switch communication modes\r\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\r\n          this.log.debug('stopping mic track', this.logContext);\r\n          // also stop the track, so that microphone indicator is turned off\r\n          this._mediaStreamTrack.stop();\r\n        }\r\n        yield _super.mute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  unmute() {\r\n    const _super = Object.create(null, {\r\n      unmute: {\r\n        get: () => super.unmute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (!this.isMuted) {\r\n          this.log.debug('Track already unmuted', this.logContext);\r\n          return this;\r\n        }\r\n        const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\r\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\r\n          this.log.debug('reacquiring mic track', this.logContext);\r\n          yield this.restartTrack();\r\n        }\r\n        yield _super.unmute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  restartTrack(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let constraints;\r\n      if (options) {\r\n        const streamConstraints = constraintsForOptions({\r\n          audio: options\r\n        });\r\n        if (typeof streamConstraints.audio !== 'boolean') {\r\n          constraints = streamConstraints.audio;\r\n        }\r\n      }\r\n      yield this.restart(constraints);\r\n    });\r\n  }\r\n  restart(constraints) {\r\n    const _super = Object.create(null, {\r\n      restart: {\r\n        get: () => super.restart\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const track = yield _super.restart.call(this, constraints);\r\n      this.checkForSilence();\r\n      return track;\r\n    });\r\n  }\r\n  /* @internal */\r\n  startMonitor() {\r\n    if (!isWeb()) {\r\n      return;\r\n    }\r\n    if (this.monitorInterval) {\r\n      return;\r\n    }\r\n    this.monitorInterval = setInterval(() => {\r\n      this.monitorSender();\r\n    }, monitorFrequency);\r\n  }\r\n  setProcessor(processor) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.processorLock.lock();\r\n      try {\r\n        if (!isReactNative() && !this.audioContext) {\r\n          throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\r\n        }\r\n        if (this.processor) {\r\n          yield this.stopProcessor();\r\n        }\r\n        const processorOptions = {\r\n          kind: this.kind,\r\n          track: this._mediaStreamTrack,\r\n          // RN won't have or use AudioContext\r\n          audioContext: this.audioContext\r\n        };\r\n        this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\r\n        yield processor.init(processorOptions);\r\n        this.processor = processor;\r\n        if (this.processor.processedTrack) {\r\n          yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\r\n          this.processor.processedTrack.addEventListener('enable-lk-krisp-noise-filter', this.handleKrispNoiseFilterEnable);\r\n          this.processor.processedTrack.addEventListener('disable-lk-krisp-noise-filter', this.handleKrispNoiseFilterDisable);\r\n        }\r\n        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   */\r\n  setAudioContext(audioContext) {\r\n    this.audioContext = audioContext;\r\n  }\r\n  getSenderStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return undefined;\r\n      }\r\n      const stats = yield this.sender.getStats();\r\n      let audioStats;\r\n      stats.forEach(v => {\r\n        if (v.type === 'outbound-rtp') {\r\n          audioStats = {\r\n            type: 'audio',\r\n            streamId: v.id,\r\n            packetsSent: v.packetsSent,\r\n            packetsLost: v.packetsLost,\r\n            bytesSent: v.bytesSent,\r\n            timestamp: v.timestamp,\r\n            roundTripTime: v.roundTripTime,\r\n            jitter: v.jitter\r\n          };\r\n        }\r\n      });\r\n      return audioStats;\r\n    });\r\n  }\r\n  checkForSilence() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const trackIsSilent = yield detectSilence(this);\r\n      if (trackIsSilent) {\r\n        if (!this.isMuted) {\r\n          this.log.warn('silence detected on local audio track', this.logContext);\r\n        }\r\n        this.emit(TrackEvent.AudioSilenceDetected);\r\n      }\r\n      return trackIsSilent;\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\r\n  switch (mediaStreamTrack.kind) {\r\n    case 'audio':\r\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\r\n    case 'video':\r\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\r\n    default:\r\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\r\n  }\r\n}\r\n/* @internal */\r\nconst presets169 = Object.values(VideoPresets);\r\n/* @internal */\r\nconst presets43 = Object.values(VideoPresets43);\r\n/* @internal */\r\nconst presetsScreenShare = Object.values(ScreenSharePresets);\r\n/* @internal */\r\nconst defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\r\n/* @internal */\r\nconst defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\r\n/* @internal */\r\nconst computeDefaultScreenShareSimulcastPresets = fromPreset => {\r\n  const layers = [{\r\n    scaleResolutionDownBy: 2,\r\n    fps: fromPreset.encoding.maxFramerate\r\n  }];\r\n  return layers.map(t => {\r\n    var _a, _b;\r\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\r\n  });\r\n};\r\n// /**\r\n//  *\r\n//  * @internal\r\n//  * @experimental\r\n//  */\r\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\r\n//   // use vp8 as a default\r\n//   const vp8 = determineAppropriateEncoding(false, width, height);\r\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\r\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\r\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\r\n//   return {\r\n//     vp8,\r\n//     vp9,\r\n//     h264,\r\n//     av1,\r\n//   };\r\n// };\r\nconst videoRids = ['q', 'h', 'f'];\r\n/* @internal */\r\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\r\n  var _a, _b;\r\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\r\n  if (isScreenShare) {\r\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\r\n  }\r\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\r\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\r\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\r\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\r\n    // when we aren't simulcasting or svc, will need to return a single encoding without\r\n    // capping bandwidth. we always require a encoding for dynacast\r\n    return [{}];\r\n  }\r\n  if (!videoEncoding) {\r\n    // find the right encoding based on width/height\r\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\r\n    livekitLogger.debug('using video encoding', videoEncoding);\r\n  }\r\n  const sourceFramerate = videoEncoding.maxFramerate;\r\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\r\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\r\n    const sm = new ScalabilityMode(scalabilityMode);\r\n    const encodings = [];\r\n    if (sm.spatial > 3) {\r\n      throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\r\n    }\r\n    // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\r\n    // that SVC mode should be used. Safari still works this way.\r\n    // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\r\n    // before M113.\r\n    // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\r\n    const browser = getBrowser();\r\n    if (isSafari() ||\r\n    // Even tho RN runs M114, it does not produce SVC layers when a single encoding\r\n    // is provided. So we'll use the legacy SVC specification for now.\r\n    // TODO: when we upstream libwebrtc, this will need additional verification\r\n    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '113') < 0) {\r\n      const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\r\n      // safari 18.4 uses a different svc API that requires scaleResolutionDownBy to be set.\r\n      const requireScale = isSafariSvcApi(browser);\r\n      for (let i = 0; i < sm.spatial; i += 1) {\r\n        // in legacy SVC, scaleResolutionDownBy cannot be set\r\n        encodings.push({\r\n          rid: videoRids[2 - i],\r\n          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\r\n          maxFramerate: original.encoding.maxFramerate,\r\n          scaleResolutionDownBy: requireScale ? Math.pow(2, i) : undefined\r\n        });\r\n      }\r\n      // legacy SVC, scalabilityMode is set only on the first encoding\r\n      /* @ts-ignore */\r\n      encodings[0].scalabilityMode = scalabilityMode;\r\n    } else {\r\n      encodings.push({\r\n        maxBitrate: videoEncoding.maxBitrate,\r\n        maxFramerate: original.encoding.maxFramerate,\r\n        /* @ts-ignore */\r\n        scalabilityMode: scalabilityMode\r\n      });\r\n    }\r\n    if (original.encoding.priority) {\r\n      encodings[0].priority = original.encoding.priority;\r\n      encodings[0].networkPriority = original.encoding.priority;\r\n    }\r\n    livekitLogger.debug(\"using svc encoding\", {\r\n      encodings\r\n    });\r\n    return encodings;\r\n  }\r\n  if (!useSimulcast) {\r\n    return [videoEncoding];\r\n  }\r\n  let presets = [];\r\n  if (isScreenShare) {\r\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\r\n  } else {\r\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\r\n  }\r\n  let midPreset;\r\n  if (presets.length > 0) {\r\n    const lowPreset = presets[0];\r\n    if (presets.length > 1) {\r\n      [, midPreset] = presets;\r\n    }\r\n    // NOTE:\r\n    //   1. Ordering of these encodings is important. Chrome seems\r\n    //      to use the index into encodings to decide which layer\r\n    //      to disable when CPU constrained.\r\n    //      So encodings should be ordered in increasing spatial\r\n    //      resolution order.\r\n    //   2. livekit-server translates rids into layers. So, all encodings\r\n    //      should have the base layer `q` and then more added\r\n    //      based on other conditions.\r\n    const size = Math.max(width, height);\r\n    if (size >= 960 && midPreset) {\r\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);\r\n    }\r\n    if (size >= 480) {\r\n      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);\r\n    }\r\n  }\r\n  return encodingsFromPresets(width, height, [original]);\r\n}\r\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\r\n  var _a, _b, _c, _d;\r\n  // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\r\n  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\r\n    // backup codec publishing is disabled\r\n    return;\r\n  }\r\n  if (videoCodec !== opts.backupCodec.codec) {\r\n    livekitLogger.warn('requested a different codec than specified as backup', {\r\n      serverRequested: videoCodec,\r\n      backup: opts.backupCodec.codec\r\n    });\r\n  }\r\n  opts.videoCodec = videoCodec;\r\n  // use backup encoding setting as videoEncoding for backup codec publishing\r\n  opts.videoEncoding = opts.backupCodec.encoding;\r\n  const settings = track.mediaStreamTrack.getSettings();\r\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\r\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\r\n  // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\r\n  if (track.source === Track.Source.ScreenShare && opts.simulcast) {\r\n    opts.simulcast = false;\r\n  }\r\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\r\n  return encodings;\r\n}\r\n/* @internal */\r\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\r\n  const presets = presetsForResolution(isScreenShare, width, height);\r\n  let {\r\n    encoding\r\n  } = presets[0];\r\n  // handle portrait by swapping dimensions\r\n  const size = Math.max(width, height);\r\n  for (let i = 0; i < presets.length; i += 1) {\r\n    const preset = presets[i];\r\n    encoding = preset.encoding;\r\n    if (preset.width >= size) {\r\n      break;\r\n    }\r\n  }\r\n  // presets are based on the assumption of vp8 as a codec\r\n  // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\r\n  // users should override these with ones that are optimized for their use case\r\n  // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\r\n  // bitrate for non-SVC codecs does not include other simulcast layers.\r\n  if (codec) {\r\n    switch (codec) {\r\n      case 'av1':\r\n        encoding = Object.assign({}, encoding);\r\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\r\n        break;\r\n      case 'vp9':\r\n        encoding = Object.assign({}, encoding);\r\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\r\n        break;\r\n    }\r\n  }\r\n  return encoding;\r\n}\r\n/* @internal */\r\nfunction presetsForResolution(isScreenShare, width, height) {\r\n  if (isScreenShare) {\r\n    return presetsScreenShare;\r\n  }\r\n  const aspect = width > height ? width / height : height / width;\r\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\r\n    return presets169;\r\n  }\r\n  return presets43;\r\n}\r\n/* @internal */\r\nfunction defaultSimulcastLayers(isScreenShare, original) {\r\n  if (isScreenShare) {\r\n    return computeDefaultScreenShareSimulcastPresets(original);\r\n  }\r\n  const {\r\n    width,\r\n    height\r\n  } = original;\r\n  const aspect = width > height ? width / height : height / width;\r\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\r\n    return defaultSimulcastPresets169;\r\n  }\r\n  return defaultSimulcastPresets43;\r\n}\r\n// presets should be ordered by low, medium, high\r\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\r\n  const encodings = [];\r\n  presets.forEach((preset, idx) => {\r\n    if (idx >= videoRids.length) {\r\n      return;\r\n    }\r\n    const size = Math.min(width, height);\r\n    const rid = videoRids[idx];\r\n    const encoding = {\r\n      rid,\r\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\r\n      maxBitrate: preset.encoding.maxBitrate\r\n    };\r\n    // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\r\n    // original encoding doesn't get bumped unintentionally by any of the other layers\r\n    const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\r\n    if (maxFramerate) {\r\n      encoding.maxFramerate = maxFramerate;\r\n    }\r\n    const canSetPriority = isFireFox() || idx === 0;\r\n    if (preset.encoding.priority && canSetPriority) {\r\n      encoding.priority = preset.encoding.priority;\r\n      encoding.networkPriority = preset.encoding.priority;\r\n    }\r\n    encodings.push(encoding);\r\n  });\r\n  // RN ios simulcast requires all same framerates.\r\n  if (isReactNative() && getReactNativeOs() === 'ios') {\r\n    let topFramerate = undefined;\r\n    encodings.forEach(encoding => {\r\n      if (!topFramerate) {\r\n        topFramerate = encoding.maxFramerate;\r\n      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\r\n        topFramerate = encoding.maxFramerate;\r\n      }\r\n    });\r\n    let notifyOnce = true;\r\n    encodings.forEach(encoding => {\r\n      var _a;\r\n      if (encoding.maxFramerate != topFramerate) {\r\n        if (notifyOnce) {\r\n          notifyOnce = false;\r\n          livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\r\n        }\r\n        livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\r\n        encoding.maxFramerate = topFramerate;\r\n      }\r\n    });\r\n  }\r\n  return encodings;\r\n}\r\n/** @internal */\r\nfunction sortPresets(presets) {\r\n  if (!presets) return;\r\n  return presets.sort((a, b) => {\r\n    const {\r\n      encoding: aEnc\r\n    } = a;\r\n    const {\r\n      encoding: bEnc\r\n    } = b;\r\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\r\n      return 1;\r\n    }\r\n    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\r\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\r\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n/** @internal */\r\nclass ScalabilityMode {\r\n  constructor(scalabilityMode) {\r\n    const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\r\n    if (!results) {\r\n      throw new Error('invalid scalability mode');\r\n    }\r\n    this.spatial = parseInt(results[1]);\r\n    this.temporal = parseInt(results[2]);\r\n    if (results.length > 3) {\r\n      switch (results[3]) {\r\n        case 'h':\r\n        case '_KEY':\r\n        case '_KEY_SHIFT':\r\n          this.suffix = results[3];\r\n      }\r\n    }\r\n  }\r\n  toString() {\r\n    var _a;\r\n    return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\r\n  }\r\n}\r\nfunction getDefaultDegradationPreference(track) {\r\n  // a few of reasons we have different default paths:\r\n  // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\r\n  // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\r\n  if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\r\n    return 'maintain-resolution';\r\n  } else {\r\n    return 'balanced';\r\n  }\r\n}\r\n\r\nconst refreshSubscribedCodecAfterNewCodec = 5000;\r\nclass LocalVideoTrack extends LocalTrack {\r\n  get sender() {\r\n    return this._sender;\r\n  }\r\n  set sender(sender) {\r\n    this._sender = sender;\r\n    if (this.degradationPreference) {\r\n      this.setDegradationPreference(this.degradationPreference);\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, constraints) {\r\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n    let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\r\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\r\n    /* @internal */\r\n    this.simulcastCodecs = new Map();\r\n    this.degradationPreference = 'balanced';\r\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      let stats;\r\n      try {\r\n        stats = yield this.getSenderStats();\r\n      } catch (e) {\r\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n        return;\r\n      }\r\n      const statsMap = new Map(stats.map(s => [s.rid, s]));\r\n      if (this.prevStats) {\r\n        let totalBitrate = 0;\r\n        statsMap.forEach((s, key) => {\r\n          var _a;\r\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\r\n          totalBitrate += computeBitrate(s, prev);\r\n        });\r\n        this._currentBitrate = totalBitrate;\r\n      }\r\n      this.prevStats = statsMap;\r\n    });\r\n    this.senderLock = new _();\r\n  }\r\n  get isSimulcast() {\r\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /* @internal */\r\n  startMonitor(signalClient) {\r\n    var _a;\r\n    this.signalClient = signalClient;\r\n    if (!isWeb()) {\r\n      return;\r\n    }\r\n    // save original encodings\r\n    // TODO : merge simulcast tracks stats\r\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\r\n    if (params) {\r\n      this.encodings = params.encodings;\r\n    }\r\n    if (this.monitorInterval) {\r\n      return;\r\n    }\r\n    this.monitorInterval = setInterval(() => {\r\n      this.monitorSender();\r\n    }, monitorFrequency);\r\n  }\r\n  stop() {\r\n    this._mediaStreamTrack.getConstraints();\r\n    this.simulcastCodecs.forEach(trackInfo => {\r\n      trackInfo.mediaStreamTrack.stop();\r\n    });\r\n    super.stop();\r\n  }\r\n  pauseUpstream() {\r\n    const _super = Object.create(null, {\r\n      pauseUpstream: {\r\n        get: () => super.pauseUpstream\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      var _d;\r\n      yield _super.pauseUpstream.call(this);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  resumeUpstream() {\r\n    const _super = Object.create(null, {\r\n      resumeUpstream: {\r\n        get: () => super.resumeUpstream\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_2, _b, _c;\r\n      var _d;\r\n      yield _super.resumeUpstream.call(this);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\r\n        }\r\n      } catch (e_2_1) {\r\n        e_2 = {\r\n          error: e_2_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_2) throw e_2.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  mute() {\r\n    const _super = Object.create(null, {\r\n      mute: {\r\n        get: () => super.mute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (this.isMuted) {\r\n          this.log.debug('Track already muted', this.logContext);\r\n          return this;\r\n        }\r\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\r\n          this.log.debug('stopping camera track', this.logContext);\r\n          // also stop the track, so that camera indicator is turned off\r\n          this._mediaStreamTrack.stop();\r\n        }\r\n        yield _super.mute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  unmute() {\r\n    const _super = Object.create(null, {\r\n      unmute: {\r\n        get: () => super.unmute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (!this.isMuted) {\r\n          this.log.debug('Track already unmuted', this.logContext);\r\n          return this;\r\n        }\r\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\r\n          this.log.debug('reacquiring camera track', this.logContext);\r\n          yield this.restartTrack();\r\n        }\r\n        yield _super.unmute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  setTrackMuted(muted) {\r\n    super.setTrackMuted(muted);\r\n    for (const sc of this.simulcastCodecs.values()) {\r\n      sc.mediaStreamTrack.enabled = !muted;\r\n    }\r\n  }\r\n  getSenderStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return [];\r\n      }\r\n      const items = [];\r\n      const stats = yield this.sender.getStats();\r\n      stats.forEach(v => {\r\n        var _a;\r\n        if (v.type === 'outbound-rtp') {\r\n          const vs = {\r\n            type: 'video',\r\n            streamId: v.id,\r\n            frameHeight: v.frameHeight,\r\n            frameWidth: v.frameWidth,\r\n            framesPerSecond: v.framesPerSecond,\r\n            framesSent: v.framesSent,\r\n            firCount: v.firCount,\r\n            pliCount: v.pliCount,\r\n            nackCount: v.nackCount,\r\n            packetsSent: v.packetsSent,\r\n            bytesSent: v.bytesSent,\r\n            qualityLimitationReason: v.qualityLimitationReason,\r\n            qualityLimitationDurations: v.qualityLimitationDurations,\r\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\r\n            rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\r\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\r\n            targetBitrate: v.targetBitrate,\r\n            timestamp: v.timestamp\r\n          };\r\n          // locate the appropriate remote-inbound-rtp item\r\n          const r = stats.get(v.remoteId);\r\n          if (r) {\r\n            vs.jitter = r.jitter;\r\n            vs.packetsLost = r.packetsLost;\r\n            vs.roundTripTime = r.roundTripTime;\r\n          }\r\n          items.push(vs);\r\n        }\r\n      });\r\n      // make sure highest res layer is always first\r\n      items.sort((a, b) => {\r\n        var _a, _b;\r\n        return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\r\n      });\r\n      return items;\r\n    });\r\n  }\r\n  setPublishingQuality(maxQuality) {\r\n    const qualities = [];\r\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\r\n      qualities.push(new SubscribedQuality({\r\n        quality: q,\r\n        enabled: q <= maxQuality\r\n      }));\r\n    }\r\n    this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\r\n    this.setPublishingLayers(isSVCCodec(this.codec), qualities);\r\n  }\r\n  restartTrack(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_3, _b, _c;\r\n      var _d;\r\n      let constraints;\r\n      if (options) {\r\n        const streamConstraints = constraintsForOptions({\r\n          video: options\r\n        });\r\n        if (typeof streamConstraints.video !== 'boolean') {\r\n          constraints = streamConstraints.video;\r\n        }\r\n      }\r\n      yield this.restart(constraints);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== 'closed') {\r\n            sc.mediaStreamTrack = this.mediaStreamTrack.clone();\r\n            yield sc.sender.replaceTrack(sc.mediaStreamTrack);\r\n          }\r\n        }\r\n      } catch (e_3_1) {\r\n        e_3 = {\r\n          error: e_3_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_3) throw e_3.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  setProcessor(processor_1) {\r\n    const _super = Object.create(null, {\r\n      setProcessor: {\r\n        get: () => super.setProcessor\r\n      }\r\n    });\r\n    return __awaiter(this, arguments, void 0, function (processor) {\r\n      var _this = this;\r\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a, e_4, _b, _c;\r\n        var _d, _e;\r\n        yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\r\n        if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\r\n          try {\r\n            for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {\r\n              _c = _h.value;\r\n              _f = false;\r\n              const sc = _c;\r\n              yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\r\n            }\r\n          } catch (e_4_1) {\r\n            e_4 = {\r\n              error: e_4_1\r\n            };\r\n          } finally {\r\n            try {\r\n              if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\r\n            } finally {\r\n              if (e_4) throw e_4.error;\r\n            }\r\n          }\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  setDegradationPreference(preference) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.degradationPreference = preference;\r\n      if (this.sender) {\r\n        try {\r\n          this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\r\n          const params = this.sender.getParameters();\r\n          params.degradationPreference = preference;\r\n          this.sender.setParameters(params);\r\n        } catch (e) {\r\n          this.log.warn(\"failed to set degradationPreference\", Object.assign({\r\n            error: e\r\n          }, this.logContext));\r\n        }\r\n      }\r\n    });\r\n  }\r\n  addSimulcastTrack(codec, encodings) {\r\n    if (this.simulcastCodecs.has(codec)) {\r\n      this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\r\n      return;\r\n    }\r\n    const simulcastCodecInfo = {\r\n      codec,\r\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\r\n      sender: undefined,\r\n      encodings\r\n    };\r\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\r\n    return simulcastCodecInfo;\r\n  }\r\n  setSimulcastTrackSender(codec, sender) {\r\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\r\n    if (!simulcastCodecInfo) {\r\n      return;\r\n    }\r\n    simulcastCodecInfo.sender = sender;\r\n    // browser will reenable disabled codec/layers after new codec has been published,\r\n    // so refresh subscribedCodecs after publish a new codec\r\n    setTimeout(() => {\r\n      if (this.subscribedCodecs) {\r\n        this.setPublishingCodecs(this.subscribedCodecs);\r\n      }\r\n    }, refreshSubscribedCodecAfterNewCodec);\r\n  }\r\n  /**\r\n   * @internal\r\n   * Sets codecs that should be publishing, returns new codecs that have not yet\r\n   * been published\r\n   */\r\n  setPublishingCodecs(codecs) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, codecs_1, codecs_1_1;\r\n      var _b, e_5, _c, _d;\r\n      this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\r\n        codecs,\r\n        currentCodec: this.codec\r\n      }));\r\n      // only enable simulcast codec for preference codec setted\r\n      if (!this.codec && codecs.length > 0) {\r\n        yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);\r\n        return [];\r\n      }\r\n      this.subscribedCodecs = codecs;\r\n      const newCodecs = [];\r\n      try {\r\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {\r\n          _d = codecs_1_1.value;\r\n          _a = false;\r\n          const codec = _d;\r\n          if (!this.codec || this.codec === codec.codec) {\r\n            yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);\r\n          } else {\r\n            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\r\n            this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\r\n              simulcastCodecInfo\r\n            }));\r\n            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\r\n              for (const q of codec.qualities) {\r\n                if (q.enabled) {\r\n                  newCodecs.push(codec.codec);\r\n                  break;\r\n                }\r\n              }\r\n            } else if (simulcastCodecInfo.encodings) {\r\n              this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\r\n              yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, isSVCCodec(codec.codec), this.log, this.logContext);\r\n            }\r\n          }\r\n        }\r\n      } catch (e_5_1) {\r\n        e_5 = {\r\n          error: e_5_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\r\n        } finally {\r\n          if (e_5) throw e_5.error;\r\n        }\r\n      }\r\n      return newCodecs;\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * Sets layers that should be publishing\r\n   */\r\n  setPublishingLayers(isSvc, qualities) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\r\n        qualities\r\n      }));\r\n      if (!this.sender || !this.encodings) {\r\n        return;\r\n      }\r\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, isSvc, this.log, this.logContext);\r\n    });\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!isMobile()) return;\r\n      if (this.isInBackground && this.source === Track.Source.Camera) {\r\n        this._mediaStreamTrack.enabled = false;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, isSVC, log, logContext) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const unlock = yield senderLock.lock();\r\n    log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\r\n      sender,\r\n      qualities,\r\n      senderEncodings\r\n    }));\r\n    try {\r\n      const params = sender.getParameters();\r\n      const {\r\n        encodings\r\n      } = params;\r\n      if (!encodings) {\r\n        return;\r\n      }\r\n      if (encodings.length !== senderEncodings.length) {\r\n        log.warn('cannot set publishing layers, encodings mismatch', Object.assign(Object.assign({}, logContext), {\r\n          encodings,\r\n          senderEncodings\r\n        }));\r\n        return;\r\n      }\r\n      let hasChanged = false;\r\n      const browser = getBrowser();\r\n      const closableSpatial = (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '133') > 0;\r\n      /* @ts-ignore */\r\n      if (closableSpatial && encodings[0].scalabilityMode) {\r\n        // svc dynacast encodings\r\n        const encoding = encodings[0];\r\n        /* @ts-ignore */\r\n        const mode = new ScalabilityMode(encoding.scalabilityMode);\r\n        let maxQuality = VideoQuality$1.OFF;\r\n        qualities.forEach(q => {\r\n          if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {\r\n            maxQuality = q.quality;\r\n          }\r\n        });\r\n        if (maxQuality === VideoQuality$1.OFF) {\r\n          if (encoding.active) {\r\n            encoding.active = false;\r\n            hasChanged = true;\r\n          }\r\n        } else if (!encoding.active || mode.spatial !== maxQuality + 1) {\r\n          hasChanged = true;\r\n          encoding.active = true;\r\n          /* @ts-ignore */\r\n          const originalMode = new ScalabilityMode(senderEncodings[0].scalabilityMode);\r\n          mode.spatial = maxQuality + 1;\r\n          mode.suffix = originalMode.suffix;\r\n          if (mode.spatial === 1) {\r\n            // no suffix for L1Tx\r\n            mode.suffix = undefined;\r\n          }\r\n          /* @ts-ignore */\r\n          encoding.scalabilityMode = mode.toString();\r\n          encoding.scaleResolutionDownBy = Math.pow(2, 2 - maxQuality);\r\n          if (senderEncodings[0].maxBitrate) {\r\n            encoding.maxBitrate = senderEncodings[0].maxBitrate / (encoding.scaleResolutionDownBy * encoding.scaleResolutionDownBy);\r\n          }\r\n        }\r\n      } else {\r\n        if (isSVC) {\r\n          const hasEnabledEncoding = qualities.some(q => q.enabled);\r\n          if (hasEnabledEncoding) {\r\n            qualities.forEach(q => q.enabled = true);\r\n          }\r\n        }\r\n        // simulcast dynacast encodings\r\n        encodings.forEach((encoding, idx) => {\r\n          var _a;\r\n          let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\r\n          if (rid === '') {\r\n            rid = 'q';\r\n          }\r\n          const quality = videoQualityForRid(rid);\r\n          const subscribedQuality = qualities.find(q => q.quality === quality);\r\n          if (!subscribedQuality) {\r\n            return;\r\n          }\r\n          if (encoding.active !== subscribedQuality.enabled) {\r\n            hasChanged = true;\r\n            encoding.active = subscribedQuality.enabled;\r\n            log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\r\n            // FireFox does not support setting encoding.active to false, so we\r\n            // have a workaround of lowering its bitrate and resolution to the min.\r\n            if (isFireFox()) {\r\n              if (subscribedQuality.enabled) {\r\n                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\r\n                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\r\n                /* @ts-ignore */\r\n                encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\r\n              } else {\r\n                encoding.scaleResolutionDownBy = 4;\r\n                encoding.maxBitrate = 10;\r\n                /* @ts-ignore */\r\n                encoding.maxFrameRate = 2;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (hasChanged) {\r\n        params.encodings = encodings;\r\n        log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\r\n          encodings: params.encodings\r\n        }));\r\n        yield sender.setParameters(params);\r\n      }\r\n    } finally {\r\n      unlock();\r\n    }\r\n  });\r\n}\r\nfunction videoQualityForRid(rid) {\r\n  switch (rid) {\r\n    case 'f':\r\n      return VideoQuality.HIGH;\r\n    case 'h':\r\n      return VideoQuality.MEDIUM;\r\n    case 'q':\r\n      return VideoQuality.LOW;\r\n    default:\r\n      return VideoQuality.HIGH;\r\n  }\r\n}\r\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\r\n  // default to a single layer, HQ\r\n  if (!encodings) {\r\n    return [new VideoLayer({\r\n      quality: VideoQuality.HIGH,\r\n      width,\r\n      height,\r\n      bitrate: 0,\r\n      ssrc: 0\r\n    })];\r\n  }\r\n  if (svc) {\r\n    // svc layers\r\n    /* @ts-ignore */\r\n    const encodingSM = encodings[0].scalabilityMode;\r\n    const sm = new ScalabilityMode(encodingSM);\r\n    const layers = [];\r\n    const resRatio = sm.suffix == 'h' ? 1.5 : 2;\r\n    const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\r\n    for (let i = 0; i < sm.spatial; i += 1) {\r\n      layers.push(new VideoLayer({\r\n        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\r\n        width: Math.ceil(width / Math.pow(resRatio, i)),\r\n        height: Math.ceil(height / Math.pow(resRatio, i)),\r\n        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\r\n        ssrc: 0\r\n      }));\r\n    }\r\n    return layers;\r\n  }\r\n  return encodings.map(encoding => {\r\n    var _a, _b, _c;\r\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\r\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\r\n    return new VideoLayer({\r\n      quality,\r\n      width: Math.ceil(width / scale),\r\n      height: Math.ceil(height / scale),\r\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\r\n      ssrc: 0\r\n    });\r\n  });\r\n}\r\n\r\nconst lossyDataChannel = '_lossy';\r\nconst reliableDataChannel = '_reliable';\r\nconst minReconnectWait = 2 * 1000;\r\nconst leaveReconnect = 'leave-reconnect';\r\nconst reliabeReceiveStateTTL = 30000;\r\nvar PCState;\r\n(function (PCState) {\r\n  PCState[PCState[\"New\"] = 0] = \"New\";\r\n  PCState[PCState[\"Connected\"] = 1] = \"Connected\";\r\n  PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\r\n  PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\r\n  PCState[PCState[\"Closed\"] = 4] = \"Closed\";\r\n})(PCState || (PCState = {}));\r\n/** @internal */\r\nclass RTCEngine extends eventsExports.EventEmitter {\r\n  get isClosed() {\r\n    return this._isClosed;\r\n  }\r\n  get pendingReconnect() {\r\n    return !!this.reconnectTimeout;\r\n  }\r\n  constructor(options) {\r\n    var _a;\r\n    super();\r\n    this.options = options;\r\n    this.rtcConfig = {};\r\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\r\n    this.fullReconnectOnNext = false;\r\n    this.subscriberPrimary = false;\r\n    this.pcState = PCState.New;\r\n    this._isClosed = true;\r\n    this.pendingTrackResolvers = {};\r\n    this.reconnectAttempts = 0;\r\n    this.reconnectStart = 0;\r\n    this.attemptingReconnect = false;\r\n    /** keeps track of how often an initial join connection has been tried */\r\n    this.joinAttempts = 0;\r\n    /** specifies how often an initial join connection is allowed to retry */\r\n    this.maxJoinAttempts = 1;\r\n    this.shouldFailNext = false;\r\n    this.log = livekitLogger;\r\n    this.reliableDataSequence = 1;\r\n    this.reliableMessageBuffer = new DataPacketBuffer();\r\n    this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);\r\n    this.handleDataChannel = _a => __awaiter(this, [_a], void 0, function (_ref) {\r\n      var _this = this;\r\n      let {\r\n        channel\r\n      } = _ref;\r\n      return function* () {\r\n        if (!channel) {\r\n          return;\r\n        }\r\n        if (channel.label === reliableDataChannel) {\r\n          _this.reliableDCSub = channel;\r\n        } else if (channel.label === lossyDataChannel) {\r\n          _this.lossyDCSub = channel;\r\n        } else {\r\n          return;\r\n        }\r\n        _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\r\n        channel.onmessage = _this.handleDataMessage;\r\n      }();\r\n    });\r\n    this.handleDataMessage = message => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      // make sure to respect incoming data message order by processing message events one after the other\r\n      const unlock = yield this.dataProcessLock.lock();\r\n      try {\r\n        // decode\r\n        let buffer;\r\n        if (message.data instanceof ArrayBuffer) {\r\n          buffer = message.data;\r\n        } else if (message.data instanceof Blob) {\r\n          buffer = yield message.data.arrayBuffer();\r\n        } else {\r\n          this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\r\n            data: message.data\r\n          }));\r\n          return;\r\n        }\r\n        const dp = DataPacket.fromBinary(new Uint8Array(buffer));\r\n        if (dp.sequence > 0 && dp.participantSid !== '') {\r\n          const lastSeq = this.reliableReceivedState.get(dp.participantSid);\r\n          if (lastSeq && dp.sequence <= lastSeq) {\r\n            // ignore duplicate or out-of-order packets in reliable channel\r\n            return;\r\n          }\r\n          this.reliableReceivedState.set(dp.participantSid, dp.sequence);\r\n        }\r\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === 'speaker') {\r\n          // dispatch speaker updates\r\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\r\n        } else {\r\n          if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'user') {\r\n            // compatibility\r\n            applyUserDataCompat(dp, dp.value.value);\r\n          }\r\n          this.emit(EngineEvent.DataPacketReceived, dp);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n    this.handleDataError = event => {\r\n      const channel = event.currentTarget;\r\n      const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\r\n      if (event instanceof ErrorEvent && event.error) {\r\n        const {\r\n          error\r\n        } = event.error;\r\n        this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\r\n          error\r\n        }));\r\n      } else {\r\n        this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\r\n          event\r\n        }));\r\n      }\r\n    };\r\n    this.handleBufferedAmountLow = event => {\r\n      const channel = event.currentTarget;\r\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\r\n      this.updateAndEmitDCBufferStatus(channelKind);\r\n    };\r\n    // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\r\n    // continues to work, we can reconnect to websocket to continue the session\r\n    // after a number of retries, we'll close and give up permanently\r\n    this.handleDisconnect = (connection, disconnectReason) => {\r\n      if (this._isClosed) {\r\n        return;\r\n      }\r\n      this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\r\n      if (this.reconnectAttempts === 0) {\r\n        // only reset start time on the first try\r\n        this.reconnectStart = Date.now();\r\n      }\r\n      const disconnect = duration => {\r\n        this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\r\n        this.emit(EngineEvent.Disconnected);\r\n        this.close();\r\n      };\r\n      const duration = Date.now() - this.reconnectStart;\r\n      let delay = this.getNextRetryDelay({\r\n        elapsedMs: duration,\r\n        retryCount: this.reconnectAttempts\r\n      });\r\n      if (delay === null) {\r\n        disconnect(duration);\r\n        return;\r\n      }\r\n      if (connection === leaveReconnect) {\r\n        delay = 0;\r\n      }\r\n      this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\r\n      this.clearReconnectTimeout();\r\n      if (this.token && this.regionUrlProvider) {\r\n        // token may have been refreshed, we do not want to recreate the regionUrlProvider\r\n        // since the current engine may have inherited a regional url\r\n        this.regionUrlProvider.updateToken(this.token);\r\n      }\r\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = undefined), delay);\r\n    };\r\n    this.waitForRestarted = () => {\r\n      return new Promise((resolve, reject) => {\r\n        if (this.pcState === PCState.Connected) {\r\n          resolve();\r\n        }\r\n        const onRestarted = () => {\r\n          this.off(EngineEvent.Disconnected, onDisconnected);\r\n          resolve();\r\n        };\r\n        const onDisconnected = () => {\r\n          this.off(EngineEvent.Restarted, onRestarted);\r\n          reject();\r\n        };\r\n        this.once(EngineEvent.Restarted, onRestarted);\r\n        this.once(EngineEvent.Disconnected, onDisconnected);\r\n      });\r\n    };\r\n    this.updateAndEmitDCBufferStatus = kind => {\r\n      const status = this.isBufferStatusLow(kind);\r\n      if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\r\n        this.dcBufferStatus.set(kind, status);\r\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\r\n      }\r\n    };\r\n    this.isBufferStatusLow = kind => {\r\n      const dc = this.dataChannelForKind(kind);\r\n      if (dc) {\r\n        if (kind === DataPacket_Kind.RELIABLE) {\r\n          this.reliableMessageBuffer.alignBufferedAmount(dc.bufferedAmount);\r\n        }\r\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\r\n      }\r\n    };\r\n    this.handleBrowserOnLine = () => {\r\n      // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\r\n      if (this.client.currentState === SignalConnectionState.RECONNECTING) {\r\n        this.clearReconnectTimeout();\r\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\r\n      }\r\n    };\r\n    this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\r\n    this.loggerOptions = {\r\n      loggerName: options.loggerName,\r\n      loggerContextCb: () => this.logContext\r\n    };\r\n    this.client = new SignalClient(undefined, this.loggerOptions);\r\n    this.client.signalLatency = this.options.expSignalLatency;\r\n    this.reconnectPolicy = this.options.reconnectPolicy;\r\n    this.registerOnLineListener();\r\n    this.closingLock = new _();\r\n    this.dataProcessLock = new _();\r\n    this.dcBufferStatus = new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\r\n    this.client.onParticipantUpdate = updates => this.emit(EngineEvent.ParticipantUpdate, updates);\r\n    this.client.onConnectionQuality = update => this.emit(EngineEvent.ConnectionQualityUpdate, update);\r\n    this.client.onRoomUpdate = update => this.emit(EngineEvent.RoomUpdate, update);\r\n    this.client.onSubscriptionError = resp => this.emit(EngineEvent.SubscriptionError, resp);\r\n    this.client.onSubscriptionPermissionUpdate = update => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\r\n    this.client.onSpeakersChanged = update => this.emit(EngineEvent.SpeakersChanged, update);\r\n    this.client.onStreamStateUpdate = update => this.emit(EngineEvent.StreamStateChanged, update);\r\n    this.client.onRequestResponse = response => this.emit(EngineEvent.SignalRequestResponse, response);\r\n  }\r\n  /** @internal */\r\n  get logContext() {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    return {\r\n      room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\r\n      roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\r\n      participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\r\n      pID: this.participantSid\r\n    };\r\n  }\r\n  join(url, token, opts, abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.url = url;\r\n      this.token = token;\r\n      this.signalOpts = opts;\r\n      this.maxJoinAttempts = opts.maxRetries;\r\n      try {\r\n        this.joinAttempts += 1;\r\n        this.setupSignalClientCallbacks();\r\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\r\n        this._isClosed = false;\r\n        this.latestJoinResponse = joinResponse;\r\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\r\n        if (!this.pcManager) {\r\n          yield this.configure(joinResponse);\r\n        }\r\n        // create offer\r\n        if (!this.subscriberPrimary || joinResponse.fastPublish) {\r\n          this.negotiate();\r\n        }\r\n        this.clientConfiguration = joinResponse.clientConfiguration;\r\n        this.emit(EngineEvent.SignalConnected, joinResponse);\r\n        return joinResponse;\r\n      } catch (e) {\r\n        if (e instanceof ConnectionError) {\r\n          if (e.reason === ConnectionErrorReason.ServerUnreachable) {\r\n            this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\r\n            if (this.joinAttempts < this.maxJoinAttempts) {\r\n              return this.join(url, token, opts, abortSignal);\r\n            }\r\n          }\r\n        }\r\n        throw e;\r\n      }\r\n    });\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.closingLock.lock();\r\n      if (this.isClosed) {\r\n        unlock();\r\n        return;\r\n      }\r\n      try {\r\n        this._isClosed = true;\r\n        this.joinAttempts = 0;\r\n        this.emit(EngineEvent.Closing);\r\n        this.removeAllListeners();\r\n        this.deregisterOnLineListener();\r\n        this.clearPendingReconnect();\r\n        yield this.cleanupPeerConnections();\r\n        yield this.cleanupClient();\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  cleanupPeerConnections() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\r\n      this.pcManager = undefined;\r\n      const dcCleanup = dc => {\r\n        if (!dc) return;\r\n        dc.close();\r\n        dc.onbufferedamountlow = null;\r\n        dc.onclose = null;\r\n        dc.onclosing = null;\r\n        dc.onerror = null;\r\n        dc.onmessage = null;\r\n        dc.onopen = null;\r\n      };\r\n      dcCleanup(this.lossyDC);\r\n      dcCleanup(this.lossyDCSub);\r\n      dcCleanup(this.reliableDC);\r\n      dcCleanup(this.reliableDCSub);\r\n      this.lossyDC = undefined;\r\n      this.lossyDCSub = undefined;\r\n      this.reliableDC = undefined;\r\n      this.reliableDCSub = undefined;\r\n      this.reliableMessageBuffer = new DataPacketBuffer();\r\n      this.reliableDataSequence = 1;\r\n      this.reliableReceivedState.clear();\r\n    });\r\n  }\r\n  cleanupClient() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.client.close();\r\n      this.client.resetCallbacks();\r\n    });\r\n  }\r\n  addTrack(req) {\r\n    if (this.pendingTrackResolvers[req.cid]) {\r\n      throw new TrackInvalidError('a track with the same ID has already been published');\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      const publicationTimeout = setTimeout(() => {\r\n        delete this.pendingTrackResolvers[req.cid];\r\n        reject(new ConnectionError('publication of local track timed out, no response from server', ConnectionErrorReason.Timeout));\r\n      }, 10000);\r\n      this.pendingTrackResolvers[req.cid] = {\r\n        resolve: info => {\r\n          clearTimeout(publicationTimeout);\r\n          resolve(info);\r\n        },\r\n        reject: () => {\r\n          clearTimeout(publicationTimeout);\r\n          reject(new Error('Cancelled publication by calling unpublish'));\r\n        }\r\n      };\r\n      this.client.sendAddTrack(req);\r\n    });\r\n  }\r\n  /**\r\n   * Removes sender from PeerConnection, returning true if it was removed successfully\r\n   * and a negotiation is necessary\r\n   * @param sender\r\n   * @returns\r\n   */\r\n  removeTrack(sender) {\r\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\r\n      const {\r\n        reject\r\n      } = this.pendingTrackResolvers[sender.track.id];\r\n      if (reject) {\r\n        reject();\r\n      }\r\n      delete this.pendingTrackResolvers[sender.track.id];\r\n    }\r\n    try {\r\n      this.pcManager.removeTrack(sender);\r\n      return true;\r\n    } catch (e) {\r\n      this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n    }\r\n    return false;\r\n  }\r\n  updateMuteStatus(trackSid, muted) {\r\n    this.client.sendMuteTrack(trackSid, muted);\r\n  }\r\n  get dataSubscriberReadyState() {\r\n    var _a;\r\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\r\n  }\r\n  getConnectedServerAddress() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\r\n    });\r\n  }\r\n  /* @internal */\r\n  setRegionUrlProvider(provider) {\r\n    this.regionUrlProvider = provider;\r\n  }\r\n  configure(joinResponse) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      // already configured\r\n      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\r\n        return;\r\n      }\r\n      this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\r\n      const rtcConfig = this.makeRTCConfiguration(joinResponse);\r\n      this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\r\n      this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\r\n      this.pcManager.onIceCandidate = (candidate, target) => {\r\n        this.client.sendIceCandidate(candidate, target);\r\n      };\r\n      this.pcManager.onPublisherOffer = offer => {\r\n        this.client.sendOffer(offer);\r\n      };\r\n      this.pcManager.onDataChannel = this.handleDataChannel;\r\n      this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {\r\n        this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\r\n        if (['closed', 'disconnected', 'failed'].includes(publisherState)) {\r\n          // reset publisher connection promise\r\n          this.publisherConnectionPromise = undefined;\r\n        }\r\n        if (connectionState === PCTransportState.CONNECTED) {\r\n          const shouldEmit = this.pcState === PCState.New;\r\n          this.pcState = PCState.Connected;\r\n          if (shouldEmit) {\r\n            this.emit(EngineEvent.Connected, joinResponse);\r\n          }\r\n        } else if (connectionState === PCTransportState.FAILED) {\r\n          // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\r\n          if (this.pcState === PCState.Connected) {\r\n            this.pcState = PCState.Disconnected;\r\n            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\r\n          }\r\n        }\r\n        // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\r\n        const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\r\n        const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);\r\n        if (isSignalSevered && isPCSevered && !this._isClosed) {\r\n          this.emit(EngineEvent.Offline);\r\n        }\r\n      });\r\n      this.pcManager.onTrack = ev => {\r\n        this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\r\n      };\r\n      if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\r\n        this.createDataChannels();\r\n      }\r\n    });\r\n  }\r\n  setupSignalClientCallbacks() {\r\n    // configure signaling client\r\n    this.client.onAnswer = sd => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\r\n        RTCSdpType: sd.type\r\n      }));\r\n      yield this.pcManager.setPublisherAnswer(sd);\r\n    });\r\n    // add candidate on trickle\r\n    this.client.onTrickle = (candidate, target) => {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      this.log.debug('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\r\n        candidate,\r\n        target\r\n      }));\r\n      this.pcManager.addIceCandidate(candidate, target);\r\n    };\r\n    // when server creates an offer for the client\r\n    this.client.onOffer = sd => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\r\n      this.client.sendAnswer(answer);\r\n    });\r\n    this.client.onLocalTrackPublished = res => {\r\n      var _a;\r\n      this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\r\n        cid: res.cid,\r\n        track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\r\n      }));\r\n      if (!this.pendingTrackResolvers[res.cid]) {\r\n        this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\r\n          cid: res.cid\r\n        }));\r\n        return;\r\n      }\r\n      const {\r\n        resolve\r\n      } = this.pendingTrackResolvers[res.cid];\r\n      delete this.pendingTrackResolvers[res.cid];\r\n      resolve(res.track);\r\n    };\r\n    this.client.onLocalTrackUnpublished = response => {\r\n      this.emit(EngineEvent.LocalTrackUnpublished, response);\r\n    };\r\n    this.client.onLocalTrackSubscribed = trackSid => {\r\n      this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\r\n    };\r\n    this.client.onTokenRefresh = token => {\r\n      this.token = token;\r\n    };\r\n    this.client.onRemoteMuteChanged = (trackSid, muted) => {\r\n      this.emit(EngineEvent.RemoteMute, trackSid, muted);\r\n    };\r\n    this.client.onSubscribedQualityUpdate = update => {\r\n      this.emit(EngineEvent.SubscribedQualityUpdate, update);\r\n    };\r\n    this.client.onRoomMoved = res => {\r\n      var _a;\r\n      this.participantSid = (_a = res.participant) === null || _a === void 0 ? void 0 : _a.sid;\r\n      if (this.latestJoinResponse) {\r\n        this.latestJoinResponse.room = res.room;\r\n      }\r\n      this.emit(EngineEvent.RoomMoved, res);\r\n    };\r\n    this.client.onClose = () => {\r\n      this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\r\n    };\r\n    this.client.onLeave = leave => {\r\n      this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\r\n        reason: leave === null || leave === void 0 ? void 0 : leave.reason\r\n      }));\r\n      if (leave.regions && this.regionUrlProvider) {\r\n        this.log.debug('updating regions', this.logContext);\r\n        this.regionUrlProvider.setServerReportedRegions(leave.regions);\r\n      }\r\n      switch (leave.action) {\r\n        case LeaveRequest_Action.DISCONNECT:\r\n          this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\r\n          this.close();\r\n          break;\r\n        case LeaveRequest_Action.RECONNECT:\r\n          this.fullReconnectOnNext = true;\r\n          // reconnect immediately instead of waiting for next attempt\r\n          this.handleDisconnect(leaveReconnect);\r\n          break;\r\n        case LeaveRequest_Action.RESUME:\r\n          // reconnect immediately instead of waiting for next attempt\r\n          this.handleDisconnect(leaveReconnect);\r\n      }\r\n    };\r\n  }\r\n  makeRTCConfiguration(serverResponse) {\r\n    var _a;\r\n    const rtcConfig = Object.assign({}, this.rtcConfig);\r\n    if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\r\n      this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\r\n      //  this makes sure that no data is sent before the transforms are ready\r\n      // @ts-ignore\r\n      rtcConfig.encodedInsertableStreams = true;\r\n    }\r\n    // update ICE servers before creating PeerConnection\r\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\r\n      const rtcIceServers = [];\r\n      serverResponse.iceServers.forEach(iceServer => {\r\n        const rtcIceServer = {\r\n          urls: iceServer.urls\r\n        };\r\n        if (iceServer.username) rtcIceServer.username = iceServer.username;\r\n        if (iceServer.credential) {\r\n          rtcIceServer.credential = iceServer.credential;\r\n        }\r\n        rtcIceServers.push(rtcIceServer);\r\n      });\r\n      rtcConfig.iceServers = rtcIceServers;\r\n    }\r\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\r\n      rtcConfig.iceTransportPolicy = 'relay';\r\n    }\r\n    // @ts-ignore\r\n    rtcConfig.sdpSemantics = 'unified-plan';\r\n    // @ts-ignore\r\n    rtcConfig.continualGatheringPolicy = 'gather_continually';\r\n    return rtcConfig;\r\n  }\r\n  createDataChannels() {\r\n    if (!this.pcManager) {\r\n      return;\r\n    }\r\n    // clear old data channel callbacks if recreate\r\n    if (this.lossyDC) {\r\n      this.lossyDC.onmessage = null;\r\n      this.lossyDC.onerror = null;\r\n    }\r\n    if (this.reliableDC) {\r\n      this.reliableDC.onmessage = null;\r\n      this.reliableDC.onerror = null;\r\n    }\r\n    // create data channels\r\n    this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\r\n      ordered: false,\r\n      maxRetransmits: 0\r\n    });\r\n    this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\r\n      ordered: true\r\n    });\r\n    // also handle messages over the pub channel, for backwards compatibility\r\n    this.lossyDC.onmessage = this.handleDataMessage;\r\n    this.reliableDC.onmessage = this.handleDataMessage;\r\n    // handle datachannel errors\r\n    this.lossyDC.onerror = this.handleDataError;\r\n    this.reliableDC.onerror = this.handleDataError;\r\n    // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\r\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\r\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\r\n    // handle buffer amount low events\r\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\r\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\r\n  }\r\n  createSender(track, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (supportsTransceiver()) {\r\n        const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\r\n        return sender;\r\n      }\r\n      if (supportsAddTrack()) {\r\n        this.log.warn('using add-track fallback', this.logContext);\r\n        const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\r\n        return sender;\r\n      }\r\n      throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\r\n    });\r\n  }\r\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // store RTCRtpSender\r\n      if (supportsTransceiver()) {\r\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\r\n      }\r\n      if (supportsAddTrack()) {\r\n        this.log.debug('using add-track fallback', this.logContext);\r\n        return this.createRTCRtpSender(track.mediaStreamTrack);\r\n      }\r\n      throw new UnexpectedConnectionState('Cannot stream on this device');\r\n    });\r\n  }\r\n  createTransceiverRTCRtpSender(track, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      const streams = [];\r\n      if (track.mediaStream) {\r\n        streams.push(track.mediaStream);\r\n      }\r\n      if (isVideoTrack(track)) {\r\n        track.codec = opts.videoCodec;\r\n      }\r\n      const transceiverInit = {\r\n        direction: 'sendonly',\r\n        streams\r\n      };\r\n      if (encodings) {\r\n        transceiverInit.sendEncodings = encodings;\r\n      }\r\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\r\n      const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\r\n      return transceiver.sender;\r\n    });\r\n  }\r\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      const transceiverInit = {\r\n        direction: 'sendonly'\r\n      };\r\n      if (encodings) {\r\n        transceiverInit.sendEncodings = encodings;\r\n      }\r\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\r\n      const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\r\n      if (!opts.videoCodec) {\r\n        return;\r\n      }\r\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\r\n      return transceiver.sender;\r\n    });\r\n  }\r\n  createRTCRtpSender(track) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      return this.pcManager.addPublisherTrack(track);\r\n    });\r\n  }\r\n  attemptReconnect(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      if (this._isClosed) {\r\n        return;\r\n      }\r\n      // guard for attempting reconnection multiple times while one attempt is still not finished\r\n      if (this.attemptingReconnect) {\r\n        livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\r\n        return;\r\n      }\r\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED ||\r\n      // signaling state could change to closed due to hardware sleep\r\n      // those connections cannot be resumed\r\n      ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\r\n        this.fullReconnectOnNext = true;\r\n      }\r\n      try {\r\n        this.attemptingReconnect = true;\r\n        if (this.fullReconnectOnNext) {\r\n          yield this.restartConnection();\r\n        } else {\r\n          yield this.resumeConnection(reason);\r\n        }\r\n        this.clearPendingReconnect();\r\n        this.fullReconnectOnNext = false;\r\n      } catch (e) {\r\n        this.reconnectAttempts += 1;\r\n        let recoverable = true;\r\n        if (e instanceof UnexpectedConnectionState) {\r\n          this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n          // unrecoverable\r\n          recoverable = false;\r\n        } else if (!(e instanceof SignalReconnectError)) {\r\n          // cannot resume\r\n          this.fullReconnectOnNext = true;\r\n        }\r\n        if (recoverable) {\r\n          this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\r\n        } else {\r\n          this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\r\n          this.emit(EngineEvent.Disconnected);\r\n          yield this.close();\r\n        }\r\n      } finally {\r\n        this.attemptingReconnect = false;\r\n      }\r\n    });\r\n  }\r\n  getNextRetryDelay(context) {\r\n    try {\r\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\r\n    } catch (e) {\r\n      this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n    }\r\n    // error in user code with provided reconnect policy, stop reconnecting\r\n    return null;\r\n  }\r\n  restartConnection(regionUrl) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      try {\r\n        if (!this.url || !this.token) {\r\n          // permanent failure, don't attempt reconnection\r\n          throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\r\n        }\r\n        this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\r\n        this.emit(EngineEvent.Restarting);\r\n        if (!this.client.isDisconnected) {\r\n          yield this.client.sendLeave();\r\n        }\r\n        yield this.cleanupPeerConnections();\r\n        yield this.cleanupClient();\r\n        let joinResponse;\r\n        try {\r\n          if (!this.signalOpts) {\r\n            this.log.warn('attempted connection restart, without signal options present', this.logContext);\r\n            throw new SignalReconnectError();\r\n          }\r\n          // in case a regionUrl is passed, the region URL takes precedence\r\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\r\n        } catch (e) {\r\n          if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\r\n            throw new UnexpectedConnectionState('could not reconnect, token might be expired');\r\n          }\r\n          throw new SignalReconnectError();\r\n        }\r\n        if (this.shouldFailNext) {\r\n          this.shouldFailNext = false;\r\n          throw new Error('simulated failure');\r\n        }\r\n        this.client.setReconnected();\r\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\r\n        yield this.waitForPCReconnected();\r\n        // re-check signal connection state before setting engine as resumed\r\n        if (this.client.currentState !== SignalConnectionState.CONNECTED) {\r\n          throw new SignalReconnectError('Signal connection got severed during reconnect');\r\n        }\r\n        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\r\n        // reconnect success\r\n        this.emit(EngineEvent.Restarted);\r\n      } catch (error) {\r\n        const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\r\n        if (nextRegionUrl) {\r\n          yield this.restartConnection(nextRegionUrl);\r\n          return;\r\n        } else {\r\n          // no more regions to try (or we're not on cloud)\r\n          (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  resumeConnection(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!this.url || !this.token) {\r\n        // permanent failure, don't attempt reconnection\r\n        throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\r\n      }\r\n      // trigger publisher reconnect\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher and subscriber connections unset');\r\n      }\r\n      this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\r\n      this.emit(EngineEvent.Resuming);\r\n      let res;\r\n      try {\r\n        this.setupSignalClientCallbacks();\r\n        res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\r\n      } catch (error) {\r\n        let message = '';\r\n        if (error instanceof Error) {\r\n          message = error.message;\r\n          this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\r\n            error\r\n          }));\r\n        }\r\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\r\n          throw new UnexpectedConnectionState('could not reconnect, token might be expired');\r\n        }\r\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\r\n          throw error;\r\n        }\r\n        throw new SignalReconnectError(message);\r\n      }\r\n      this.emit(EngineEvent.SignalResumed);\r\n      if (res) {\r\n        const rtcConfig = this.makeRTCConfiguration(res);\r\n        this.pcManager.updateConfiguration(rtcConfig);\r\n        if (this.latestJoinResponse) {\r\n          this.latestJoinResponse.serverInfo = res.serverInfo;\r\n        }\r\n      } else {\r\n        this.log.warn('Did not receive reconnect response', this.logContext);\r\n      }\r\n      if (this.shouldFailNext) {\r\n        this.shouldFailNext = false;\r\n        throw new Error('simulated failure');\r\n      }\r\n      yield this.pcManager.triggerIceRestart();\r\n      yield this.waitForPCReconnected();\r\n      // re-check signal connection state before setting engine as resumed\r\n      if (this.client.currentState !== SignalConnectionState.CONNECTED) {\r\n        throw new SignalReconnectError('Signal connection got severed during reconnect');\r\n      }\r\n      this.client.setReconnected();\r\n      // recreate publish datachannel if it's id is null\r\n      // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\r\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\r\n        this.createDataChannels();\r\n      }\r\n      if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {\r\n        this.resendReliableMessagesForResume(res.lastMessageSeq);\r\n      }\r\n      // resume success\r\n      this.emit(EngineEvent.Resumed);\r\n    });\r\n  }\r\n  waitForPCInitialConnection(timeout, abortController) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('PC manager is closed');\r\n      }\r\n      yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\r\n    });\r\n  }\r\n  waitForPCReconnected() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.pcState = PCState.Reconnecting;\r\n      this.log.debug('waiting for peer connection to reconnect', this.logContext);\r\n      try {\r\n        yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\r\n        if (!this.pcManager) {\r\n          throw new UnexpectedConnectionState('PC manager is closed');\r\n        }\r\n        yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\r\n        this.pcState = PCState.Connected;\r\n      } catch (e) {\r\n        // TODO do we need a `failed` state here for the PC?\r\n        this.pcState = PCState.Disconnected;\r\n        throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\r\n      }\r\n    });\r\n  }\r\n  /** @internal */\r\n  publishRpcResponse(destinationIdentity, requestId, payload, error) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcResponse',\r\n          value: new RpcResponse({\r\n            requestId,\r\n            value: error ? {\r\n              case: 'error',\r\n              value: error.toProto()\r\n            } : {\r\n              case: 'payload',\r\n              value: payload !== null && payload !== void 0 ? payload : ''\r\n            }\r\n          })\r\n        }\r\n      });\r\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /** @internal */\r\n  publishRpcAck(destinationIdentity, requestId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcAck',\r\n          value: new RpcAck({\r\n            requestId\r\n          })\r\n        }\r\n      });\r\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /* @internal */\r\n  sendDataPacket(packet, kind) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // make sure we do have a data connection\r\n      yield this.ensurePublisherConnected(kind);\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        packet.sequence = this.reliableDataSequence;\r\n        this.reliableDataSequence += 1;\r\n      }\r\n      const msg = packet.toBinary();\r\n      const dc = this.dataChannelForKind(kind);\r\n      if (dc) {\r\n        if (kind === DataPacket_Kind.RELIABLE) {\r\n          this.reliableMessageBuffer.push({\r\n            data: msg,\r\n            sequence: packet.sequence\r\n          });\r\n        }\r\n        if (this.attemptingReconnect) {\r\n          return;\r\n        }\r\n        dc.send(msg);\r\n      }\r\n      this.updateAndEmitDCBufferStatus(kind);\r\n    });\r\n  }\r\n  resendReliableMessagesForResume(lastMessageSeq) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);\r\n      const dc = this.dataChannelForKind(DataPacket_Kind.RELIABLE);\r\n      if (dc) {\r\n        this.reliableMessageBuffer.popToSequence(lastMessageSeq);\r\n        this.reliableMessageBuffer.getAll().forEach(msg => {\r\n          dc.send(msg.data);\r\n        });\r\n      }\r\n      this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  waitForBufferStatusLow(kind) {\r\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      if (this.isBufferStatusLow(kind)) {\r\n        resolve();\r\n      } else {\r\n        const onClosing = () => reject('Engine closed');\r\n        this.once(EngineEvent.Closing, onClosing);\r\n        while (!this.dcBufferStatus.get(kind)) {\r\n          yield sleep(10);\r\n        }\r\n        this.off(EngineEvent.Closing, onClosing);\r\n        resolve();\r\n      }\r\n    }));\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  ensureDataTransportConnected(kind_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind) {\r\n      var _this2 = this;\r\n      let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\r\n      return function* () {\r\n        var _a;\r\n        if (!_this2.pcManager) {\r\n          throw new UnexpectedConnectionState('PC manager is closed');\r\n        }\r\n        const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\r\n        const transportName = subscriber ? 'Subscriber' : 'Publisher';\r\n        if (!transport) {\r\n          throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\r\n        }\r\n        let needNegotiation = false;\r\n        if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\r\n          _this2.createDataChannels();\r\n          needNegotiation = true;\r\n        }\r\n        if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== 'checking') {\r\n          needNegotiation = true;\r\n        }\r\n        if (needNegotiation) {\r\n          // start negotiation\r\n          _this2.negotiate();\r\n        }\r\n        const targetChannel = _this2.dataChannelForKind(kind, subscriber);\r\n        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\r\n          return;\r\n        }\r\n        // wait until ICE connected\r\n        const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\r\n        while (new Date().getTime() < endTime) {\r\n          if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\r\n            return;\r\n          }\r\n          yield sleep(50);\r\n        }\r\n        throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\r\n      }();\r\n    });\r\n  }\r\n  ensurePublisherConnected(kind) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.publisherConnectionPromise) {\r\n        this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\r\n      }\r\n      yield this.publisherConnectionPromise;\r\n    });\r\n  }\r\n  /* @internal */\r\n  verifyTransport() {\r\n    if (!this.pcManager) {\r\n      return false;\r\n    }\r\n    // primary connection\r\n    if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\r\n      return false;\r\n    }\r\n    // ensure signal is connected\r\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  negotiate() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // observe signal state\r\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        if (!this.pcManager) {\r\n          reject(new NegotiationError('PC manager is closed'));\r\n          return;\r\n        }\r\n        this.pcManager.requirePublisher();\r\n        // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\r\n        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\r\n          this.createDataChannels();\r\n        }\r\n        const abortController = new AbortController();\r\n        const handleClosed = () => {\r\n          abortController.abort();\r\n          this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\r\n          resolve();\r\n          return;\r\n        };\r\n        if (this.isClosed) {\r\n          reject('cannot negotiate on closed engine');\r\n        }\r\n        this.on(EngineEvent.Closing, handleClosed);\r\n        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, rtpTypes => {\r\n          const rtpMap = new Map();\r\n          rtpTypes.forEach(rtp => {\r\n            const codec = rtp.codec.toLowerCase();\r\n            if (isVideoCodec(codec)) {\r\n              rtpMap.set(rtp.payload, codec);\r\n            }\r\n          });\r\n          this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\r\n        });\r\n        try {\r\n          yield this.pcManager.negotiate(abortController);\r\n          resolve();\r\n        } catch (e) {\r\n          if (e instanceof NegotiationError) {\r\n            this.fullReconnectOnNext = true;\r\n          }\r\n          this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\r\n          reject(e);\r\n        } finally {\r\n          this.off(EngineEvent.Closing, handleClosed);\r\n        }\r\n      }));\r\n    });\r\n  }\r\n  dataChannelForKind(kind, sub) {\r\n    if (!sub) {\r\n      if (kind === DataPacket_Kind.LOSSY) {\r\n        return this.lossyDC;\r\n      }\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        return this.reliableDC;\r\n      }\r\n    } else {\r\n      if (kind === DataPacket_Kind.LOSSY) {\r\n        return this.lossyDCSub;\r\n      }\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        return this.reliableDCSub;\r\n      }\r\n    }\r\n  }\r\n  /** @internal */\r\n  sendSyncState(remoteTracks, localTracks) {\r\n    var _a, _b;\r\n    if (!this.pcManager) {\r\n      this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\r\n      return;\r\n    }\r\n    const previousAnswer = this.pcManager.subscriber.getLocalDescription();\r\n    const previousOffer = this.pcManager.subscriber.getRemoteDescription();\r\n    /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\r\n          in this case, we send unsub tracks, so server add all tracks to this\r\n          subscribe pc and unsub special tracks from it.\r\n       2. autosubscribe off, we send subscribed tracks.\r\n    */\r\n    const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\r\n    const trackSids = new Array();\r\n    const trackSidsDisabled = new Array();\r\n    remoteTracks.forEach(track => {\r\n      if (track.isDesired !== autoSubscribe) {\r\n        trackSids.push(track.trackSid);\r\n      }\r\n      if (!track.isEnabled) {\r\n        trackSidsDisabled.push(track.trackSid);\r\n      }\r\n    });\r\n    this.client.sendSyncState(new SyncState({\r\n      answer: previousAnswer ? toProtoSessionDescription({\r\n        sdp: previousAnswer.sdp,\r\n        type: previousAnswer.type\r\n      }) : undefined,\r\n      offer: previousOffer ? toProtoSessionDescription({\r\n        sdp: previousOffer.sdp,\r\n        type: previousOffer.type\r\n      }) : undefined,\r\n      subscription: new UpdateSubscription({\r\n        trackSids,\r\n        subscribe: !autoSubscribe,\r\n        participantTracks: []\r\n      }),\r\n      publishTracks: getTrackPublicationInfo(localTracks),\r\n      dataChannels: this.dataChannelsInfo(),\r\n      trackSidsDisabled,\r\n      datachannelReceiveStates: this.reliableReceivedState.map((seq, sid) => {\r\n        return new DataChannelReceiveState({\r\n          publisherSid: sid,\r\n          lastSeq: seq\r\n        });\r\n      })\r\n    }));\r\n  }\r\n  /* @internal */\r\n  failNext() {\r\n    // debugging method to fail the next reconnect/resume attempt\r\n    this.shouldFailNext = true;\r\n  }\r\n  dataChannelsInfo() {\r\n    const infos = [];\r\n    const getInfo = (dc, target) => {\r\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\r\n        infos.push(new DataChannelInfo({\r\n          label: dc.label,\r\n          id: dc.id,\r\n          target\r\n        }));\r\n      }\r\n    };\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\r\n    return infos;\r\n  }\r\n  clearReconnectTimeout() {\r\n    if (this.reconnectTimeout) {\r\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\r\n    }\r\n  }\r\n  clearPendingReconnect() {\r\n    this.clearReconnectTimeout();\r\n    this.reconnectAttempts = 0;\r\n  }\r\n  registerOnLineListener() {\r\n    if (isWeb()) {\r\n      window.addEventListener('online', this.handleBrowserOnLine);\r\n    }\r\n  }\r\n  deregisterOnLineListener() {\r\n    if (isWeb()) {\r\n      window.removeEventListener('online', this.handleBrowserOnLine);\r\n    }\r\n  }\r\n}\r\nclass SignalReconnectError extends Error {}\r\nfunction supportOptionalDatachannel(protocol) {\r\n  return protocol !== undefined && protocol > 13;\r\n}\r\nfunction applyUserDataCompat(newObj, oldObj) {\r\n  const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\r\n  newObj.participantIdentity = participantIdentity;\r\n  oldObj.participantIdentity = participantIdentity;\r\n  const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\r\n  newObj.destinationIdentities = destinationIdentities;\r\n  oldObj.destinationIdentities = destinationIdentities;\r\n}\r\n\r\nclass RegionUrlProvider {\r\n  constructor(url, token) {\r\n    this.lastUpdateAt = 0;\r\n    this.settingsCacheTime = 3000;\r\n    this.attemptedRegions = [];\r\n    this.serverUrl = new URL(url);\r\n    this.token = token;\r\n  }\r\n  updateToken(token) {\r\n    this.token = token;\r\n  }\r\n  isCloud() {\r\n    return isCloud(this.serverUrl);\r\n  }\r\n  getServerUrl() {\r\n    return this.serverUrl;\r\n  }\r\n  getNextBestRegionUrl(abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.isCloud()) {\r\n        throw Error('region availability is only supported for LiveKit Cloud domains');\r\n      }\r\n      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\r\n        this.regionSettings = yield this.fetchRegionSettings(abortSignal);\r\n      }\r\n      const regionsLeft = this.regionSettings.regions.filter(region => !this.attemptedRegions.find(attempted => attempted.url === region.url));\r\n      if (regionsLeft.length > 0) {\r\n        const nextRegion = regionsLeft[0];\r\n        this.attemptedRegions.push(nextRegion);\r\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\r\n        return nextRegion.url;\r\n      } else {\r\n        return null;\r\n      }\r\n    });\r\n  }\r\n  resetAttempts() {\r\n    this.attemptedRegions = [];\r\n  }\r\n  /* @internal */\r\n  fetchRegionSettings(signal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\r\n        headers: {\r\n          authorization: \"Bearer \".concat(this.token)\r\n        },\r\n        signal\r\n      });\r\n      if (regionSettingsResponse.ok) {\r\n        const regionSettings = yield regionSettingsResponse.json();\r\n        this.lastUpdateAt = Date.now();\r\n        return regionSettings;\r\n      } else {\r\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\r\n      }\r\n    });\r\n  }\r\n  setServerReportedRegions(regions) {\r\n    this.regionSettings = regions;\r\n    this.lastUpdateAt = Date.now();\r\n  }\r\n}\r\nfunction getCloudConfigUrl(serverUrl) {\r\n  return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\r\n}\r\n\r\nclass BaseStreamReader {\r\n  get info() {\r\n    return this._info;\r\n  }\r\n  constructor(info, stream, totalByteSize) {\r\n    this.reader = stream;\r\n    this.totalByteSize = totalByteSize;\r\n    this._info = info;\r\n    this.bytesReceived = 0;\r\n  }\r\n}\r\nclass ByteStreamReader extends BaseStreamReader {\r\n  handleChunkReceived(chunk) {\r\n    var _a;\r\n    this.bytesReceived += chunk.content.byteLength;\r\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\r\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\r\n  }\r\n  [Symbol.asyncIterator]() {\r\n    const reader = this.reader.getReader();\r\n    return {\r\n      next: () => __awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n          const {\r\n            done,\r\n            value\r\n          } = yield reader.read();\r\n          if (done) {\r\n            return {\r\n              done: true,\r\n              value: undefined\r\n            };\r\n          } else {\r\n            this.handleChunkReceived(value);\r\n            return {\r\n              done: false,\r\n              value: value.content\r\n            };\r\n          }\r\n        } catch (error) {\r\n          // TODO handle errors\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        }\r\n      }),\r\n      return() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n          reader.releaseLock();\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        });\r\n      }\r\n    };\r\n  }\r\n  readAll() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      let chunks = new Set();\r\n      try {\r\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\r\n          _c = _f.value;\r\n          _d = false;\r\n          const chunk = _c;\r\n          chunks.add(chunk);\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n      return Array.from(chunks);\r\n    });\r\n  }\r\n}\r\n/**\r\n * A class to read chunks from a ReadableStream and provide them in a structured format.\r\n */\r\nclass TextStreamReader extends BaseStreamReader {\r\n  /**\r\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\r\n   * that has been received up to the current point in time.\r\n   */\r\n  constructor(info, stream, totalChunkCount) {\r\n    super(info, stream, totalChunkCount);\r\n    this.receivedChunks = new Map();\r\n  }\r\n  handleChunkReceived(chunk) {\r\n    var _a;\r\n    const index = bigIntToNumber(chunk.chunkIndex);\r\n    const previousChunkAtIndex = this.receivedChunks.get(index);\r\n    if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\r\n      // we have a newer version already, dropping the old one\r\n      return;\r\n    }\r\n    this.receivedChunks.set(index, chunk);\r\n    this.bytesReceived += chunk.content.byteLength;\r\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\r\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\r\n  }\r\n  /**\r\n   * Async iterator implementation to allow usage of `for await...of` syntax.\r\n   * Yields structured chunks from the stream.\r\n   *\r\n   */\r\n  [Symbol.asyncIterator]() {\r\n    const reader = this.reader.getReader();\r\n    const decoder = new TextDecoder();\r\n    return {\r\n      next: () => __awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n          const {\r\n            done,\r\n            value\r\n          } = yield reader.read();\r\n          if (done) {\r\n            return {\r\n              done: true,\r\n              value: undefined\r\n            };\r\n          } else {\r\n            this.handleChunkReceived(value);\r\n            return {\r\n              done: false,\r\n              value: decoder.decode(value.content)\r\n            };\r\n          }\r\n        } catch (error) {\r\n          // TODO handle errors\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        }\r\n      }),\r\n      return() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n          reader.releaseLock();\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        });\r\n      }\r\n    };\r\n  }\r\n  readAll() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_2, _b, _c;\r\n      let finalString = '';\r\n      try {\r\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\r\n          _c = _f.value;\r\n          _d = false;\r\n          const chunk = _c;\r\n          finalString += chunk;\r\n        }\r\n      } catch (e_2_1) {\r\n        e_2 = {\r\n          error: e_2_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\r\n        } finally {\r\n          if (e_2) throw e_2.error;\r\n        }\r\n      }\r\n      return finalString;\r\n    });\r\n  }\r\n}\r\n\r\nclass BaseStreamWriter {\r\n  constructor(writableStream, info, onClose) {\r\n    this.writableStream = writableStream;\r\n    this.defaultWriter = writableStream.getWriter();\r\n    this.onClose = onClose;\r\n    this.info = info;\r\n  }\r\n  write(chunk) {\r\n    return this.defaultWriter.write(chunk);\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield this.defaultWriter.close();\r\n      this.defaultWriter.releaseLock();\r\n      (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    });\r\n  }\r\n}\r\nclass TextStreamWriter extends BaseStreamWriter {}\r\nclass ByteStreamWriter extends BaseStreamWriter {}\r\n\r\nclass RemoteTrack extends Track {\r\n  constructor(mediaTrack, sid, kind, receiver, loggerOptions) {\r\n    super(mediaTrack, kind, loggerOptions);\r\n    this.sid = sid;\r\n    this.receiver = receiver;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /** @internal */\r\n  setMuted(muted) {\r\n    if (this.isMuted !== muted) {\r\n      this.isMuted = muted;\r\n      this._mediaStreamTrack.enabled = !muted;\r\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\r\n    }\r\n  }\r\n  /** @internal */\r\n  setMediaStream(stream) {\r\n    // this is needed to determine when the track is finished\r\n    this.mediaStream = stream;\r\n    const onRemoveTrack = event => {\r\n      if (event.track === this._mediaStreamTrack) {\r\n        stream.removeEventListener('removetrack', onRemoveTrack);\r\n        if (this.receiver && 'playoutDelayHint' in this.receiver) {\r\n          this.receiver.playoutDelayHint = undefined;\r\n        }\r\n        this.receiver = undefined;\r\n        this._currentBitrate = 0;\r\n        this.emit(TrackEvent.Ended, this);\r\n      }\r\n    };\r\n    stream.addEventListener('removetrack', onRemoveTrack);\r\n  }\r\n  start() {\r\n    this.startMonitor();\r\n    // use `enabled` of track to enable re-use of transceiver\r\n    super.enable();\r\n  }\r\n  stop() {\r\n    this.stopMonitor();\r\n    // use `enabled` of track to enable re-use of transceiver\r\n    super.disable();\r\n  }\r\n  /**\r\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\r\n   *\r\n   * @returns Promise<RTCStatsReport> | undefined\r\n   */\r\n  getRTCStatsReport() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return;\r\n      }\r\n      const statsReport = yield this.receiver.getStats();\r\n      return statsReport;\r\n    });\r\n  }\r\n  /**\r\n   * Allows to set a playout delay (in seconds) for this track.\r\n   * A higher value allows for more buffering of the track in the browser\r\n   * and will result in a delay of media being played back of `delayInSeconds`\r\n   */\r\n  setPlayoutDelay(delayInSeconds) {\r\n    if (this.receiver) {\r\n      if ('playoutDelayHint' in this.receiver) {\r\n        this.receiver.playoutDelayHint = delayInSeconds;\r\n      } else {\r\n        this.log.warn('Playout delay not supported in this browser');\r\n      }\r\n    } else {\r\n      this.log.warn('Cannot set playout delay, track already ended');\r\n    }\r\n  }\r\n  /**\r\n   * Returns the current playout delay (in seconds) of this track.\r\n   */\r\n  getPlayoutDelay() {\r\n    if (this.receiver) {\r\n      if ('playoutDelayHint' in this.receiver) {\r\n        return this.receiver.playoutDelayHint;\r\n      } else {\r\n        this.log.warn('Playout delay not supported in this browser');\r\n      }\r\n    } else {\r\n      this.log.warn('Cannot get playout delay, track already ended');\r\n    }\r\n    return 0;\r\n  }\r\n  /* @internal */\r\n  startMonitor() {\r\n    if (!this.monitorInterval) {\r\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\r\n    }\r\n    if (supportsSynchronizationSources()) {\r\n      this.registerTimeSyncUpdate();\r\n    }\r\n  }\r\n  registerTimeSyncUpdate() {\r\n    const loop = () => {\r\n      var _a;\r\n      this.timeSyncHandle = requestAnimationFrame(() => loop());\r\n      const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\r\n      if (sources) {\r\n        const {\r\n          timestamp,\r\n          rtpTimestamp\r\n        } = sources;\r\n        if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\r\n          this.emit(TrackEvent.TimeSyncUpdate, {\r\n            timestamp,\r\n            rtpTimestamp\r\n          });\r\n          this.rtpTimestamp = rtpTimestamp;\r\n        }\r\n      }\r\n    };\r\n    loop();\r\n  }\r\n}\r\n\r\nclass RemoteAudioTrack extends RemoteTrack {\r\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {\r\n    super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\r\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      const stats = yield this.getReceiverStats();\r\n      if (stats && this.prevStats && this.receiver) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.audioContext = audioContext;\r\n    this.webAudioPluginNodes = [];\r\n    if (audioOutput) {\r\n      this.sinkId = audioOutput.deviceId;\r\n    }\r\n  }\r\n  /**\r\n   * sets the volume for all attached audio elements\r\n   */\r\n  setVolume(volume) {\r\n    var _a;\r\n    for (const el of this.attachedElements) {\r\n      if (this.audioContext) {\r\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\r\n      } else {\r\n        el.volume = volume;\r\n      }\r\n    }\r\n    if (isReactNative()) {\r\n      // @ts-ignore\r\n      this._mediaStreamTrack._setVolume(volume);\r\n    }\r\n    this.elementVolume = volume;\r\n  }\r\n  /**\r\n   * gets the volume of attached audio elements (loudest)\r\n   */\r\n  getVolume() {\r\n    if (this.elementVolume) {\r\n      return this.elementVolume;\r\n    }\r\n    if (isReactNative()) {\r\n      // RN volume value defaults to 1.0 if hasn't been changed.\r\n      return 1.0;\r\n    }\r\n    let highestVolume = 0;\r\n    this.attachedElements.forEach(element => {\r\n      if (element.volume > highestVolume) {\r\n        highestVolume = element.volume;\r\n      }\r\n    });\r\n    return highestVolume;\r\n  }\r\n  /**\r\n   * calls setSinkId on all attached elements, if supported\r\n   * @param deviceId audio output device\r\n   */\r\n  setSinkId(deviceId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.sinkId = deviceId;\r\n      yield Promise.all(this.attachedElements.map(elm => {\r\n        if (!supportsSetSinkId(elm)) {\r\n          return;\r\n        }\r\n        /* @ts-ignore */\r\n        return elm.setSinkId(deviceId);\r\n      }));\r\n    });\r\n  }\r\n  attach(element) {\r\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\r\n    if (!element) {\r\n      element = super.attach();\r\n    } else {\r\n      super.attach(element);\r\n    }\r\n    if (this.sinkId && supportsSetSinkId(element)) {\r\n      element.setSinkId(this.sinkId).catch(e => {\r\n        this.log.error('Failed to set sink id on remote audio track', e, this.logContext);\r\n      });\r\n    }\r\n    if (this.audioContext && needsNewWebAudioConnection) {\r\n      this.log.debug('using audio context mapping', this.logContext);\r\n      this.connectWebAudio(this.audioContext, element);\r\n      element.volume = 0;\r\n      element.muted = true;\r\n    }\r\n    if (this.elementVolume) {\r\n      // make sure volume setting is being applied to the newly attached element\r\n      this.setVolume(this.elementVolume);\r\n    }\r\n    return element;\r\n  }\r\n  detach(element) {\r\n    let detached;\r\n    if (!element) {\r\n      detached = super.detach();\r\n      this.disconnectWebAudio();\r\n    } else {\r\n      detached = super.detach(element);\r\n      // if there are still any attached elements after detaching, connect webaudio to the first element that's left\r\n      // disconnect webaudio otherwise\r\n      if (this.audioContext) {\r\n        if (this.attachedElements.length > 0) {\r\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\r\n        } else {\r\n          this.disconnectWebAudio();\r\n        }\r\n      }\r\n    }\r\n    return detached;\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   */\r\n  setAudioContext(audioContext) {\r\n    this.audioContext = audioContext;\r\n    if (audioContext && this.attachedElements.length > 0) {\r\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\r\n    } else if (!audioContext) {\r\n      this.disconnectWebAudio();\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\r\n   */\r\n  setWebAudioPlugins(nodes) {\r\n    this.webAudioPluginNodes = nodes;\r\n    if (this.attachedElements.length > 0 && this.audioContext) {\r\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\r\n    }\r\n  }\r\n  connectWebAudio(context, element) {\r\n    this.disconnectWebAudio();\r\n    // @ts-ignore attached elements always have a srcObject set\r\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\r\n    let lastNode = this.sourceNode;\r\n    this.webAudioPluginNodes.forEach(node => {\r\n      lastNode.connect(node);\r\n      lastNode = node;\r\n    });\r\n    this.gainNode = context.createGain();\r\n    lastNode.connect(this.gainNode);\r\n    this.gainNode.connect(context.destination);\r\n    if (this.elementVolume) {\r\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\r\n    }\r\n    // try to resume the context if it isn't running already\r\n    if (context.state !== 'running') {\r\n      context.resume().then(() => {\r\n        if (context.state !== 'running') {\r\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\r\n        }\r\n      }).catch(e => {\r\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\r\n      });\r\n    }\r\n  }\r\n  disconnectWebAudio() {\r\n    var _a, _b;\r\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\r\n    this.gainNode = undefined;\r\n    this.sourceNode = undefined;\r\n  }\r\n  getReceiverStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver || !this.receiver.getStats) {\r\n        return;\r\n      }\r\n      const stats = yield this.receiver.getStats();\r\n      let receiverStats;\r\n      stats.forEach(v => {\r\n        if (v.type === 'inbound-rtp') {\r\n          receiverStats = {\r\n            type: 'audio',\r\n            streamId: v.id,\r\n            timestamp: v.timestamp,\r\n            jitter: v.jitter,\r\n            bytesReceived: v.bytesReceived,\r\n            concealedSamples: v.concealedSamples,\r\n            concealmentEvents: v.concealmentEvents,\r\n            silentConcealedSamples: v.silentConcealedSamples,\r\n            silentConcealmentEvents: v.silentConcealmentEvents,\r\n            totalAudioEnergy: v.totalAudioEnergy,\r\n            totalSamplesDuration: v.totalSamplesDuration\r\n          };\r\n        }\r\n      });\r\n      return receiverStats;\r\n    });\r\n  }\r\n}\r\n\r\nconst REACTION_DELAY = 100;\r\nclass RemoteVideoTrack extends RemoteTrack {\r\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {\r\n    super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\r\n    this.elementInfos = [];\r\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      const stats = yield this.getReceiverStats();\r\n      if (stats && this.prevStats && this.receiver) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.debouncedHandleResize = r(() => {\r\n      this.updateDimensions();\r\n    }, REACTION_DELAY);\r\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\r\n  }\r\n  get isAdaptiveStream() {\r\n    return this.adaptiveStreamSettings !== undefined;\r\n  }\r\n  /**\r\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\r\n   */\r\n  get mediaStreamTrack() {\r\n    return this._mediaStreamTrack;\r\n  }\r\n  /** @internal */\r\n  setMuted(muted) {\r\n    super.setMuted(muted);\r\n    this.attachedElements.forEach(element => {\r\n      // detach or attach\r\n      if (muted) {\r\n        detachTrack(this._mediaStreamTrack, element);\r\n      } else {\r\n        attachToElement(this._mediaStreamTrack, element);\r\n      }\r\n    });\r\n  }\r\n  attach(element) {\r\n    if (!element) {\r\n      element = super.attach();\r\n    } else {\r\n      super.attach(element);\r\n    }\r\n    // It's possible attach is called multiple times on an element. When that's\r\n    // the case, we'd want to avoid adding duplicate elementInfos\r\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info.element === element) === undefined) {\r\n      const elementInfo = new HTMLElementInfo(element);\r\n      this.observeElementInfo(elementInfo);\r\n    }\r\n    return element;\r\n  }\r\n  /**\r\n   * Observe an ElementInfo for changes when adaptive streaming.\r\n   * @param elementInfo\r\n   * @internal\r\n   */\r\n  observeElementInfo(elementInfo) {\r\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info === elementInfo) === undefined) {\r\n      elementInfo.handleResize = () => {\r\n        this.debouncedHandleResize();\r\n      };\r\n      elementInfo.handleVisibilityChanged = () => {\r\n        this.updateVisibility();\r\n      };\r\n      this.elementInfos.push(elementInfo);\r\n      elementInfo.observe();\r\n      // trigger the first resize update cycle\r\n      // if the tab is backgrounded, the initial resize event does not fire until\r\n      // the tab comes into focus for the first time.\r\n      this.debouncedHandleResize();\r\n      this.updateVisibility();\r\n    } else {\r\n      this.log.warn('visibility resize observer not triggered', this.logContext);\r\n    }\r\n  }\r\n  /**\r\n   * Stop observing an ElementInfo for changes.\r\n   * @param elementInfo\r\n   * @internal\r\n   */\r\n  stopObservingElementInfo(elementInfo) {\r\n    if (!this.isAdaptiveStream) {\r\n      this.log.warn('stopObservingElementInfo ignored', this.logContext);\r\n      return;\r\n    }\r\n    const stopElementInfos = this.elementInfos.filter(info => info === elementInfo);\r\n    for (const info of stopElementInfos) {\r\n      info.stopObserving();\r\n    }\r\n    this.elementInfos = this.elementInfos.filter(info => info !== elementInfo);\r\n    this.updateVisibility();\r\n    this.debouncedHandleResize();\r\n  }\r\n  detach(element) {\r\n    let detachedElements = [];\r\n    if (element) {\r\n      this.stopObservingElement(element);\r\n      return super.detach(element);\r\n    }\r\n    detachedElements = super.detach();\r\n    for (const e of detachedElements) {\r\n      this.stopObservingElement(e);\r\n    }\r\n    return detachedElements;\r\n  }\r\n  /** @internal */\r\n  getDecoderImplementation() {\r\n    var _a;\r\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\r\n  }\r\n  getReceiverStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver || !this.receiver.getStats) {\r\n        return;\r\n      }\r\n      const stats = yield this.receiver.getStats();\r\n      let receiverStats;\r\n      let codecID = '';\r\n      let codecs = new Map();\r\n      stats.forEach(v => {\r\n        if (v.type === 'inbound-rtp') {\r\n          codecID = v.codecId;\r\n          receiverStats = {\r\n            type: 'video',\r\n            streamId: v.id,\r\n            framesDecoded: v.framesDecoded,\r\n            framesDropped: v.framesDropped,\r\n            framesReceived: v.framesReceived,\r\n            packetsReceived: v.packetsReceived,\r\n            packetsLost: v.packetsLost,\r\n            frameWidth: v.frameWidth,\r\n            frameHeight: v.frameHeight,\r\n            pliCount: v.pliCount,\r\n            firCount: v.firCount,\r\n            nackCount: v.nackCount,\r\n            jitter: v.jitter,\r\n            timestamp: v.timestamp,\r\n            bytesReceived: v.bytesReceived,\r\n            decoderImplementation: v.decoderImplementation\r\n          };\r\n        } else if (v.type === 'codec') {\r\n          codecs.set(v.id, v);\r\n        }\r\n      });\r\n      if (receiverStats && codecID !== '' && codecs.get(codecID)) {\r\n        receiverStats.mimeType = codecs.get(codecID).mimeType;\r\n      }\r\n      return receiverStats;\r\n    });\r\n  }\r\n  stopObservingElement(element) {\r\n    const stopElementInfos = this.elementInfos.filter(info => info.element === element);\r\n    for (const info of stopElementInfos) {\r\n      this.stopObservingElementInfo(info);\r\n    }\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!this.isAdaptiveStream) return;\r\n      this.updateVisibility();\r\n    });\r\n  }\r\n  updateVisibility() {\r\n    var _a, _b;\r\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\r\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\r\n    ) ? this.isInBackground : false;\r\n    const isPiPMode = this.elementInfos.some(info => info.pictureInPicture);\r\n    const isVisible = this.elementInfos.some(info => info.visible) && !backgroundPause || isPiPMode;\r\n    if (this.lastVisible === isVisible) {\r\n      return;\r\n    }\r\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\r\n      // delay hidden events\r\n      CriticalTimers.setTimeout(() => {\r\n        this.updateVisibility();\r\n      }, REACTION_DELAY);\r\n      return;\r\n    }\r\n    this.lastVisible = isVisible;\r\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\r\n  }\r\n  updateDimensions() {\r\n    var _a, _b;\r\n    let maxWidth = 0;\r\n    let maxHeight = 0;\r\n    const pixelDensity = this.getPixelDensity();\r\n    for (const info of this.elementInfos) {\r\n      const currentElementWidth = info.width() * pixelDensity;\r\n      const currentElementHeight = info.height() * pixelDensity;\r\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\r\n        maxWidth = currentElementWidth;\r\n        maxHeight = currentElementHeight;\r\n      }\r\n    }\r\n    if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\r\n      return;\r\n    }\r\n    this.lastDimensions = {\r\n      width: maxWidth,\r\n      height: maxHeight\r\n    };\r\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\r\n  }\r\n  getPixelDensity() {\r\n    var _a;\r\n    const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\r\n    if (pixelDensity === 'screen') {\r\n      return getDevicePixelRatio();\r\n    } else if (!pixelDensity) {\r\n      // when unset, we'll pick a sane default here.\r\n      // for higher pixel density devices (mobile phones, etc), we'll use 2\r\n      // otherwise it defaults to 1\r\n      const devicePixelRatio = getDevicePixelRatio();\r\n      if (devicePixelRatio > 2) {\r\n        return 2;\r\n      } else {\r\n        return 1;\r\n      }\r\n    }\r\n    return pixelDensity;\r\n  }\r\n}\r\nclass HTMLElementInfo {\r\n  get visible() {\r\n    return this.isPiP || this.isIntersecting;\r\n  }\r\n  get pictureInPicture() {\r\n    return this.isPiP;\r\n  }\r\n  constructor(element, visible) {\r\n    this.onVisibilityChanged = entry => {\r\n      var _a;\r\n      const {\r\n        target,\r\n        isIntersecting\r\n      } = entry;\r\n      if (target === this.element) {\r\n        this.isIntersecting = isIntersecting;\r\n        this.isPiP = isElementInPiP(this.element);\r\n        this.visibilityChangedAt = Date.now();\r\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\r\n      }\r\n    };\r\n    this.onEnterPiP = () => {\r\n      var _a, _b, _c;\r\n      (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener('pagehide', this.onLeavePiP);\r\n      this.isPiP = isElementInPiP(this.element);\r\n      (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\r\n    };\r\n    this.onLeavePiP = () => {\r\n      var _a;\r\n      this.isPiP = isElementInPiP(this.element);\r\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    };\r\n    this.element = element;\r\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\r\n    this.isPiP = isWeb() && isElementInPiP(element);\r\n    this.visibilityChangedAt = 0;\r\n  }\r\n  width() {\r\n    return this.element.clientWidth;\r\n  }\r\n  height() {\r\n    return this.element.clientHeight;\r\n  }\r\n  observe() {\r\n    var _a, _b, _c;\r\n    // make sure we update the current visible state once we start to observe\r\n    this.isIntersecting = isElementInViewport(this.element);\r\n    this.isPiP = isElementInPiP(this.element);\r\n    this.element.handleResize = () => {\r\n      var _a;\r\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    };\r\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\r\n    getIntersectionObserver().observe(this.element);\r\n    getResizeObserver().observe(this.element);\r\n    this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\r\n    this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\r\n    (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener('enter', this.onEnterPiP);\r\n    (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener('pagehide', this.onLeavePiP);\r\n  }\r\n  stopObserving() {\r\n    var _a, _b, _c, _d, _e;\r\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\r\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\r\n    this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\r\n    this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\r\n    (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener('enter', this.onEnterPiP);\r\n    (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener('pagehide', this.onLeavePiP);\r\n  }\r\n}\r\nfunction isElementInPiP(el) {\r\n  var _a, _b;\r\n  // Simple video PiP\r\n  if (document.pictureInPictureElement === el) return true;\r\n  // Document PiP\r\n  if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\r\n  return false;\r\n}\r\n// does not account for occlusion by other elements or opacity property\r\nfunction isElementInViewport(el, win) {\r\n  const viewportWindow = win || window;\r\n  let top = el.offsetTop;\r\n  let left = el.offsetLeft;\r\n  const width = el.offsetWidth;\r\n  const height = el.offsetHeight;\r\n  const {\r\n    hidden\r\n  } = el;\r\n  const {\r\n    display\r\n  } = getComputedStyle(el);\r\n  while (el.offsetParent) {\r\n    el = el.offsetParent;\r\n    top += el.offsetTop;\r\n    left += el.offsetLeft;\r\n  }\r\n  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== 'none';\r\n}\r\n\r\nclass TrackPublication extends eventsExports.EventEmitter {\r\n  constructor(kind, id, name, loggerOptions) {\r\n    var _a;\r\n    super();\r\n    this.metadataMuted = false;\r\n    this.encryption = Encryption_Type.NONE;\r\n    this.log = livekitLogger;\r\n    this.handleMuted = () => {\r\n      this.emit(TrackEvent.Muted);\r\n    };\r\n    this.handleUnmuted = () => {\r\n      this.emit(TrackEvent.Unmuted);\r\n    };\r\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\r\n    this.loggerContextCb = this.loggerContextCb;\r\n    this.setMaxListeners(100);\r\n    this.kind = kind;\r\n    this.trackSid = id;\r\n    this.trackName = name;\r\n    this.source = Track.Source.Unknown;\r\n  }\r\n  /** @internal */\r\n  setTrack(track) {\r\n    if (this.track) {\r\n      this.track.off(TrackEvent.Muted, this.handleMuted);\r\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\r\n    }\r\n    this.track = track;\r\n    if (track) {\r\n      // forward events\r\n      track.on(TrackEvent.Muted, this.handleMuted);\r\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\r\n    }\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\r\n  }\r\n  get isMuted() {\r\n    return this.metadataMuted;\r\n  }\r\n  get isEnabled() {\r\n    return true;\r\n  }\r\n  get isSubscribed() {\r\n    return this.track !== undefined;\r\n  }\r\n  get isEncrypted() {\r\n    return this.encryption !== Encryption_Type.NONE;\r\n  }\r\n  /**\r\n   * an [AudioTrack] if this publication holds an audio track\r\n   */\r\n  get audioTrack() {\r\n    if (isAudioTrack(this.track)) {\r\n      return this.track;\r\n    }\r\n  }\r\n  /**\r\n   * an [VideoTrack] if this publication holds a video track\r\n   */\r\n  get videoTrack() {\r\n    if (isVideoTrack(this.track)) {\r\n      return this.track;\r\n    }\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    this.trackSid = info.sid;\r\n    this.trackName = info.name;\r\n    this.source = Track.sourceFromProto(info.source);\r\n    this.mimeType = info.mimeType;\r\n    if (this.kind === Track.Kind.Video && info.width > 0) {\r\n      this.dimensions = {\r\n        width: info.width,\r\n        height: info.height\r\n      };\r\n      this.simulcasted = info.simulcast;\r\n    }\r\n    this.encryption = info.encryption;\r\n    this.trackInfo = info;\r\n    this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\r\n      info\r\n    }));\r\n  }\r\n}\r\n(function (TrackPublication) {\r\n  (function (SubscriptionStatus) {\r\n    SubscriptionStatus[\"Desired\"] = \"desired\";\r\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\r\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\r\n  })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\r\n  (function (PermissionStatus) {\r\n    PermissionStatus[\"Allowed\"] = \"allowed\";\r\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\r\n  })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\r\n})(TrackPublication || (TrackPublication = {}));\r\n\r\nclass LocalTrackPublication extends TrackPublication {\r\n  get isUpstreamPaused() {\r\n    var _a;\r\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\r\n  }\r\n  constructor(kind, ti, track, loggerOptions) {\r\n    super(kind, ti.sid, ti.name, loggerOptions);\r\n    this.track = undefined;\r\n    this.handleTrackEnded = () => {\r\n      this.emit(TrackEvent.Ended);\r\n    };\r\n    this.updateInfo(ti);\r\n    this.setTrack(track);\r\n  }\r\n  setTrack(track) {\r\n    if (this.track) {\r\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\r\n    }\r\n    super.setTrack(track);\r\n    if (track) {\r\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\r\n    }\r\n  }\r\n  get isMuted() {\r\n    if (this.track) {\r\n      return this.track.isMuted;\r\n    }\r\n    return super.isMuted;\r\n  }\r\n  get audioTrack() {\r\n    return super.audioTrack;\r\n  }\r\n  get videoTrack() {\r\n    return super.videoTrack;\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /**\r\n   * Mute the track associated with this publication\r\n   */\r\n  mute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\r\n    });\r\n  }\r\n  /**\r\n   * Unmute track associated with this publication\r\n   */\r\n  unmute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\r\n    });\r\n  }\r\n  /**\r\n   * Pauses the media stream track associated with this publication from being sent to the server\r\n   * and signals \"muted\" event to other participants\r\n   * Useful if you want to pause the stream without pausing the local media stream track\r\n   */\r\n  pauseUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\r\n    });\r\n  }\r\n  /**\r\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\r\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\r\n   */\r\n  resumeUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\r\n    });\r\n  }\r\n  getTrackFeatures() {\r\n    var _a;\r\n    if (isAudioTrack(this.track)) {\r\n      const settings = this.track.getSourceTrackSettings();\r\n      const features = new Set();\r\n      if (settings.autoGainControl) {\r\n        features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\r\n      }\r\n      if (settings.echoCancellation) {\r\n        features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\r\n      }\r\n      if (settings.noiseSuppression) {\r\n        features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\r\n      }\r\n      if (settings.channelCount && settings.channelCount > 1) {\r\n        features.add(AudioTrackFeature.TF_STEREO);\r\n      }\r\n      if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\r\n        features.add(AudioTrackFeature.TF_NO_DTX);\r\n      }\r\n      if (this.track.enhancedNoiseCancellation) {\r\n        features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\r\n      }\r\n      return Array.from(features.values());\r\n    } else return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a local video and audio track at the same time. When acquiring both\r\n * audio and video tracks together, it'll display a single permission prompt to\r\n * the user instead of two separate ones.\r\n * @param options\r\n */\r\nfunction createLocalTracks(options, loggerOptions) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    options !== null && options !== void 0 ? options : options = {};\r\n    let attemptExactMatch = false;\r\n    const {\r\n      audioProcessor,\r\n      videoProcessor,\r\n      optionsWithoutProcessor: internalOptions\r\n    } = extractProcessorsFromOptions(options);\r\n    let retryAudioOptions = internalOptions.audio;\r\n    let retryVideoOptions = internalOptions.video;\r\n    if (audioProcessor && typeof internalOptions.audio === 'object') {\r\n      internalOptions.audio.processor = audioProcessor;\r\n    }\r\n    if (videoProcessor && typeof internalOptions.video === 'object') {\r\n      internalOptions.video.processor = videoProcessor;\r\n    }\r\n    // if the user passes a device id as a string, we default to exact match\r\n    if (options.audio && typeof internalOptions.audio === 'object' && typeof internalOptions.audio.deviceId === 'string') {\r\n      const deviceId = internalOptions.audio.deviceId;\r\n      internalOptions.audio.deviceId = {\r\n        exact: deviceId\r\n      };\r\n      attemptExactMatch = true;\r\n      retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\r\n        deviceId: {\r\n          ideal: deviceId\r\n        }\r\n      });\r\n    }\r\n    if (internalOptions.video && typeof internalOptions.video === 'object' && typeof internalOptions.video.deviceId === 'string') {\r\n      const deviceId = internalOptions.video.deviceId;\r\n      internalOptions.video.deviceId = {\r\n        exact: deviceId\r\n      };\r\n      attemptExactMatch = true;\r\n      retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\r\n        deviceId: {\r\n          ideal: deviceId\r\n        }\r\n      });\r\n    }\r\n    if (internalOptions.audio === true || typeof internalOptions.audio === 'object' && !internalOptions.audio.deviceId) {\r\n      internalOptions.audio = {\r\n        deviceId: 'default'\r\n      };\r\n    }\r\n    if (internalOptions.video === true) {\r\n      internalOptions.video = {\r\n        deviceId: 'default'\r\n      };\r\n    } else if (typeof internalOptions.video === 'object' && !internalOptions.video.deviceId) {\r\n      internalOptions.video.deviceId = 'default';\r\n    }\r\n    const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\r\n    const constraints = constraintsForOptions(opts);\r\n    // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\r\n    // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\r\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\r\n    if (internalOptions.audio) {\r\n      DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\r\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('audioinput'));\r\n    }\r\n    if (internalOptions.video) {\r\n      DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\r\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('videoinput'));\r\n    }\r\n    try {\r\n      const stream = yield mediaPromise;\r\n      return yield Promise.all(stream.getTracks().map(mediaStreamTrack => __awaiter(this, void 0, void 0, function* () {\r\n        const isAudio = mediaStreamTrack.kind === 'audio';\r\n        let trackOptions = isAudio ? opts.audio : opts.video;\r\n        if (typeof trackOptions === 'boolean' || !trackOptions) {\r\n          trackOptions = {};\r\n        }\r\n        let trackConstraints;\r\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\r\n        if (typeof conOrBool !== 'boolean') {\r\n          trackConstraints = conOrBool;\r\n        }\r\n        // update the constraints with the device id the user gave permissions to in the permission prompt\r\n        // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\r\n        const newDeviceId = mediaStreamTrack.getSettings().deviceId;\r\n        if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\r\n          trackConstraints.deviceId = newDeviceId;\r\n        } else if (!trackConstraints) {\r\n          trackConstraints = {\r\n            deviceId: newDeviceId\r\n          };\r\n        }\r\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\r\n        if (track.kind === Track.Kind.Video) {\r\n          track.source = Track.Source.Camera;\r\n        } else if (track.kind === Track.Kind.Audio) {\r\n          track.source = Track.Source.Microphone;\r\n        }\r\n        track.mediaStream = stream;\r\n        if (isAudioTrack(track) && audioProcessor) {\r\n          yield track.setProcessor(audioProcessor);\r\n        } else if (isVideoTrack(track) && videoProcessor) {\r\n          yield track.setProcessor(videoProcessor);\r\n        }\r\n        return track;\r\n      })));\r\n    } catch (e) {\r\n      if (!attemptExactMatch) {\r\n        throw e;\r\n      }\r\n      return createLocalTracks(Object.assign(Object.assign({}, options), {\r\n        audio: retryAudioOptions,\r\n        video: retryVideoOptions\r\n      }), loggerOptions);\r\n    }\r\n  });\r\n}\r\n/**\r\n * Creates a [[LocalVideoTrack]] with getUserMedia()\r\n * @param options\r\n */\r\nfunction createLocalVideoTrack(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const tracks = yield createLocalTracks({\r\n      audio: false,\r\n      video: options !== null && options !== void 0 ? options : true\r\n    });\r\n    return tracks[0];\r\n  });\r\n}\r\nfunction createLocalAudioTrack(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const tracks = yield createLocalTracks({\r\n      audio: options !== null && options !== void 0 ? options : true,\r\n      video: false\r\n    });\r\n    return tracks[0];\r\n  });\r\n}\r\n/**\r\n * Creates a screen capture tracks with getDisplayMedia().\r\n * A LocalVideoTrack is always created and returned.\r\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\r\n */\r\nfunction createLocalScreenTracks(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    if (options === undefined) {\r\n      options = {};\r\n    }\r\n    if (options.resolution === undefined && !isSafari17()) {\r\n      options.resolution = ScreenSharePresets.h1080fps30.resolution;\r\n    }\r\n    if (navigator.mediaDevices.getDisplayMedia === undefined) {\r\n      throw new DeviceUnsupportedError('getDisplayMedia not supported');\r\n    }\r\n    const constraints = screenCaptureToDisplayMediaStreamOptions(options);\r\n    const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\r\n    const tracks = stream.getVideoTracks();\r\n    if (tracks.length === 0) {\r\n      throw new TrackInvalidError('no video track found');\r\n    }\r\n    const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\r\n    screenVideo.source = Track.Source.ScreenShare;\r\n    const localTracks = [screenVideo];\r\n    if (stream.getAudioTracks().length > 0) {\r\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\r\n      screenAudio.source = Track.Source.ScreenShareAudio;\r\n      localTracks.push(screenAudio);\r\n    }\r\n    return localTracks;\r\n  });\r\n}\r\n\r\nvar ConnectionQuality;\r\n(function (ConnectionQuality) {\r\n  ConnectionQuality[\"Excellent\"] = \"excellent\";\r\n  ConnectionQuality[\"Good\"] = \"good\";\r\n  ConnectionQuality[\"Poor\"] = \"poor\";\r\n  /**\r\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\r\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\r\n   */\r\n  ConnectionQuality[\"Lost\"] = \"lost\";\r\n  ConnectionQuality[\"Unknown\"] = \"unknown\";\r\n})(ConnectionQuality || (ConnectionQuality = {}));\r\nfunction qualityFromProto(q) {\r\n  switch (q) {\r\n    case ConnectionQuality$1.EXCELLENT:\r\n      return ConnectionQuality.Excellent;\r\n    case ConnectionQuality$1.GOOD:\r\n      return ConnectionQuality.Good;\r\n    case ConnectionQuality$1.POOR:\r\n      return ConnectionQuality.Poor;\r\n    case ConnectionQuality$1.LOST:\r\n      return ConnectionQuality.Lost;\r\n    default:\r\n      return ConnectionQuality.Unknown;\r\n  }\r\n}\r\nclass Participant extends eventsExports.EventEmitter {\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  get isEncrypted() {\r\n    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every(tr => tr.isEncrypted);\r\n  }\r\n  get isAgent() {\r\n    var _a;\r\n    return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\r\n  }\r\n  get isActive() {\r\n    var _a;\r\n    return ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) === ParticipantInfo_State.ACTIVE;\r\n  }\r\n  get kind() {\r\n    return this._kind;\r\n  }\r\n  /** participant attributes, similar to metadata, but as a key/value map */\r\n  get attributes() {\r\n    return Object.freeze(Object.assign({}, this._attributes));\r\n  }\r\n  /** @internal */\r\n  constructor(sid, identity, name, metadata, attributes, loggerOptions) {\r\n    let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\r\n    var _a;\r\n    super();\r\n    /** audio level between 0-1.0, 1 being loudest, 0 being softest */\r\n    this.audioLevel = 0;\r\n    /** if participant is currently speaking */\r\n    this.isSpeaking = false;\r\n    this._connectionQuality = ConnectionQuality.Unknown;\r\n    this.log = livekitLogger;\r\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\r\n    this.loggerOptions = loggerOptions;\r\n    this.setMaxListeners(100);\r\n    this.sid = sid;\r\n    this.identity = identity;\r\n    this.name = name;\r\n    this.metadata = metadata;\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.trackPublications = new Map();\r\n    this._kind = kind;\r\n    this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\r\n  }\r\n  getTrackPublications() {\r\n    return Array.from(this.trackPublications.values());\r\n  }\r\n  /**\r\n   * Finds the first track that matches the source filter, for example, getting\r\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\r\n   */\r\n  getTrackPublication(source) {\r\n    for (const [, pub] of this.trackPublications) {\r\n      if (pub.source === source) {\r\n        return pub;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Finds the first track that matches the track's name.\r\n   */\r\n  getTrackPublicationByName(name) {\r\n    for (const [, pub] of this.trackPublications) {\r\n      if (pub.trackName === name) {\r\n        return pub;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Waits until the participant is active and ready to receive data messages\r\n   * @returns a promise that resolves when the participant is active\r\n   */\r\n  waitUntilActive() {\r\n    if (this.isActive) {\r\n      return Promise.resolve();\r\n    }\r\n    if (this.activeFuture) {\r\n      return this.activeFuture.promise;\r\n    }\r\n    this.activeFuture = new Future();\r\n    this.once(ParticipantEvent.Active, () => {\r\n      var _a, _b;\r\n      (_b = (_a = this.activeFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n      this.activeFuture = undefined;\r\n    });\r\n    return this.activeFuture.promise;\r\n  }\r\n  get connectionQuality() {\r\n    return this._connectionQuality;\r\n  }\r\n  get isCameraEnabled() {\r\n    var _a;\r\n    const track = this.getTrackPublication(Track.Source.Camera);\r\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\r\n  }\r\n  get isMicrophoneEnabled() {\r\n    var _a;\r\n    const track = this.getTrackPublication(Track.Source.Microphone);\r\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\r\n  }\r\n  get isScreenShareEnabled() {\r\n    const track = this.getTrackPublication(Track.Source.ScreenShare);\r\n    return !!track;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /** when participant joined the room */\r\n  get joinedAt() {\r\n    if (this.participantInfo) {\r\n      return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\r\n    }\r\n    return new Date();\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    var _a;\r\n    // it's possible the update could be applied out of order due to await\r\n    // during reconnect sequences. when that happens, it's possible for server\r\n    // to have sent more recent version of participant info while JS is waiting\r\n    // to process the existing payload.\r\n    // when the participant sid remains the same, and we already have a later version\r\n    // of the payload, they can be safely skipped\r\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\r\n      return false;\r\n    }\r\n    this.identity = info.identity;\r\n    this.sid = info.sid;\r\n    this._setName(info.name);\r\n    this._setMetadata(info.metadata);\r\n    this._setAttributes(info.attributes);\r\n    if (info.state === ParticipantInfo_State.ACTIVE && ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) !== ParticipantInfo_State.ACTIVE) {\r\n      this.emit(ParticipantEvent.Active);\r\n    }\r\n    if (info.permission) {\r\n      this.setPermissions(info.permission);\r\n    }\r\n    // set this last so setMetadata can detect changes\r\n    this.participantInfo = info;\r\n    return true;\r\n  }\r\n  /**\r\n   * Updates metadata from server\r\n   **/\r\n  _setMetadata(md) {\r\n    const changed = this.metadata !== md;\r\n    const prevMetadata = this.metadata;\r\n    this.metadata = md;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\r\n    }\r\n  }\r\n  _setName(name) {\r\n    const changed = this.name !== name;\r\n    this.name = name;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\r\n    }\r\n  }\r\n  /**\r\n   * Updates metadata from server\r\n   **/\r\n  _setAttributes(attributes) {\r\n    const diff = diffAttributes(this.attributes, attributes);\r\n    this._attributes = attributes;\r\n    if (Object.keys(diff).length > 0) {\r\n      this.emit(ParticipantEvent.AttributesChanged, diff);\r\n    }\r\n  }\r\n  /** @internal */\r\n  setPermissions(permissions) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const prevPermissions = this.permissions;\r\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\r\n      var _a;\r\n      return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\r\n    }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\r\n    this.permissions = permissions;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\r\n    }\r\n    return changed;\r\n  }\r\n  /** @internal */\r\n  setIsSpeaking(speaking) {\r\n    if (speaking === this.isSpeaking) {\r\n      return;\r\n    }\r\n    this.isSpeaking = speaking;\r\n    if (speaking) {\r\n      this.lastSpokeAt = new Date();\r\n    }\r\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\r\n  }\r\n  /** @internal */\r\n  setConnectionQuality(q) {\r\n    const prevQuality = this._connectionQuality;\r\n    this._connectionQuality = qualityFromProto(q);\r\n    if (prevQuality !== this._connectionQuality) {\r\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setDisconnected() {\r\n    var _a, _b;\r\n    if (this.activeFuture) {\r\n      (_b = (_a = this.activeFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error('Participant disconnected'));\r\n      this.activeFuture = undefined;\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setAudioContext(ctx) {\r\n    this.audioContext = ctx;\r\n    this.audioTrackPublications.forEach(track => isAudioTrack(track.track) && track.track.setAudioContext(ctx));\r\n  }\r\n  addTrackPublication(publication) {\r\n    // forward publication driven events\r\n    publication.on(TrackEvent.Muted, () => {\r\n      this.emit(ParticipantEvent.TrackMuted, publication);\r\n    });\r\n    publication.on(TrackEvent.Unmuted, () => {\r\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\r\n    });\r\n    const pub = publication;\r\n    if (pub.track) {\r\n      pub.track.sid = publication.trackSid;\r\n    }\r\n    this.trackPublications.set(publication.trackSid, publication);\r\n    switch (publication.kind) {\r\n      case Track.Kind.Audio:\r\n        this.audioTrackPublications.set(publication.trackSid, publication);\r\n        break;\r\n      case Track.Kind.Video:\r\n        this.videoTrackPublications.set(publication.trackSid, publication);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction trackPermissionToProto(perms) {\r\n  var _a, _b, _c;\r\n  if (!perms.participantSid && !perms.participantIdentity) {\r\n    throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\r\n  }\r\n  return new TrackPermission({\r\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\r\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\r\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\r\n    trackSids: perms.allowedTrackSids || []\r\n  });\r\n}\r\n\r\nconst STREAM_CHUNK_SIZE = 15000;\r\nclass LocalParticipant extends Participant {\r\n  /** @internal */\r\n  constructor(sid, identity, engine, options, roomRpcHandlers) {\r\n    super(sid, identity, undefined, undefined, undefined, {\r\n      loggerName: options.loggerName,\r\n      loggerContextCb: () => this.engine.logContext\r\n    });\r\n    this.pendingPublishing = new Set();\r\n    this.pendingPublishPromises = new Map();\r\n    this.participantTrackPermissions = [];\r\n    this.allParticipantsAllowedToSubscribe = true;\r\n    this.encryptionType = Encryption_Type.NONE;\r\n    this.enabledPublishVideoCodecs = [];\r\n    this.pendingAcks = new Map();\r\n    this.pendingResponses = new Map();\r\n    this.handleReconnecting = () => {\r\n      if (!this.reconnectFuture) {\r\n        this.reconnectFuture = new Future();\r\n      }\r\n    };\r\n    this.handleReconnected = () => {\r\n      var _a, _b;\r\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n      this.reconnectFuture = undefined;\r\n      this.updateTrackSubscriptionPermissions();\r\n    };\r\n    this.handleDisconnected = () => {\r\n      var _a, _b, _c, _d, _e, _f;\r\n      if (this.reconnectFuture) {\r\n        this.reconnectFuture.promise.catch(e => this.log.warn(e.message, this.logContext));\r\n        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, 'Got disconnected during reconnection attempt');\r\n        this.reconnectFuture = undefined;\r\n      }\r\n      if (this.signalConnectedFuture) {\r\n        (_d = (_c = this.signalConnectedFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, 'Got disconnected without signal connected');\r\n        this.signalConnectedFuture = undefined;\r\n      }\r\n      (_f = (_e = this.activeAgentFuture) === null || _e === void 0 ? void 0 : _e.reject) === null || _f === void 0 ? void 0 : _f.call(_e, 'Got disconnected without active agent present');\r\n      this.activeAgentFuture = undefined;\r\n      this.firstActiveAgent = undefined;\r\n    };\r\n    this.handleSignalConnected = joinResponse => {\r\n      var _a, _b;\r\n      if (joinResponse.participant) {\r\n        this.updateInfo(joinResponse.participant);\r\n      }\r\n      if (!this.signalConnectedFuture) {\r\n        this.signalConnectedFuture = new Future();\r\n      }\r\n      (_b = (_a = this.signalConnectedFuture).resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    };\r\n    this.handleSignalRequestResponse = response => {\r\n      const {\r\n        requestId,\r\n        reason,\r\n        message\r\n      } = response;\r\n      const targetRequest = this.pendingSignalRequests.get(requestId);\r\n      if (targetRequest) {\r\n        if (reason !== RequestResponse_Reason.OK) {\r\n          targetRequest.reject(new SignalRequestError(message, reason));\r\n        }\r\n        this.pendingSignalRequests.delete(requestId);\r\n      }\r\n    };\r\n    this.handleDataPacket = packet => {\r\n      switch (packet.value.case) {\r\n        case 'rpcResponse':\r\n          let rpcResponse = packet.value.value;\r\n          let payload = null;\r\n          let error = null;\r\n          if (rpcResponse.value.case === 'payload') {\r\n            payload = rpcResponse.value.value;\r\n          } else if (rpcResponse.value.case === 'error') {\r\n            error = RpcError.fromProto(rpcResponse.value.value);\r\n          }\r\n          this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\r\n          break;\r\n        case 'rpcAck':\r\n          let rpcAck = packet.value.value;\r\n          this.handleIncomingRpcAck(rpcAck.requestId);\r\n          break;\r\n      }\r\n    };\r\n    this.updateTrackSubscriptionPermissions = () => {\r\n      this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\r\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\r\n        participantTrackPermissions: this.participantTrackPermissions\r\n      }));\r\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map(p => trackPermissionToProto(p)));\r\n    };\r\n    /** @internal */\r\n    this.onTrackUnmuted = track => {\r\n      this.onTrackMuted(track, track.isUpstreamPaused);\r\n    };\r\n    // when the local track changes in mute status, we'll notify server as such\r\n    /** @internal */\r\n    this.onTrackMuted = (track, muted) => {\r\n      if (muted === undefined) {\r\n        muted = true;\r\n      }\r\n      if (!track.sid) {\r\n        this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        return;\r\n      }\r\n      this.engine.updateMuteStatus(track.sid, muted);\r\n    };\r\n    this.onTrackUpstreamPaused = track => {\r\n      this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      this.onTrackMuted(track, true);\r\n    };\r\n    this.onTrackUpstreamResumed = track => {\r\n      this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      this.onTrackMuted(track, track.isMuted);\r\n    };\r\n    this.onTrackFeatureUpdate = track => {\r\n      const pub = this.audioTrackPublications.get(track.sid);\r\n      if (!pub) {\r\n        this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\r\n        return;\r\n      }\r\n      this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\r\n    };\r\n    this.handleSubscribedQualityUpdate = update => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      var _d;\r\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\r\n        return;\r\n      }\r\n      const pub = this.videoTrackPublications.get(update.trackSid);\r\n      if (!pub) {\r\n        this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: update.trackSid\r\n        }));\r\n        return;\r\n      }\r\n      if (!pub.videoTrack) {\r\n        return;\r\n      }\r\n      const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\r\n      try {\r\n        for (var _e = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _e = true) {\r\n          _c = newCodecs_1_1.value;\r\n          _e = false;\r\n          const codec = _c;\r\n          if (isBackupCodec(codec)) {\r\n            this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\r\n            yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\r\n          }\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n    });\r\n    this.handleLocalTrackUnpublished = unpublished => {\r\n      const track = this.trackPublications.get(unpublished.trackSid);\r\n      if (!track) {\r\n        this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: unpublished.trackSid\r\n        }));\r\n        return;\r\n      }\r\n      this.unpublishTrack(track.track);\r\n    };\r\n    this.handleTrackEnded = track => __awaiter(this, void 0, void 0, function* () {\r\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\r\n        this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        this.unpublishTrack(track);\r\n      } else if (track.isUserProvided) {\r\n        yield track.mute();\r\n      } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\r\n        try {\r\n          if (isWeb()) {\r\n            try {\r\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\r\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\r\n                // @ts-ignore\r\n                name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\r\n              });\r\n              if (currentPermissions && currentPermissions.state === 'denied') {\r\n                this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n                // detect granted change after permissions were denied to try and resume then\r\n                currentPermissions.onchange = () => {\r\n                  if (currentPermissions.state !== 'denied') {\r\n                    if (!track.isMuted) {\r\n                      track.restartTrack();\r\n                    }\r\n                    currentPermissions.onchange = null;\r\n                  }\r\n                };\r\n                throw new Error('GetUserMedia Permission denied');\r\n              }\r\n            } catch (e) {\r\n              // permissions query fails for firefox, we continue and try to restart the track\r\n            }\r\n          }\r\n          if (!track.isMuted) {\r\n            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n            if (isLocalAudioTrack(track)) {\r\n              // fall back to default device if available\r\n              yield track.restartTrack({\r\n                deviceId: 'default'\r\n              });\r\n            } else {\r\n              yield track.restartTrack();\r\n            }\r\n          }\r\n        } catch (e) {\r\n          this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          yield track.mute();\r\n        }\r\n      }\r\n    });\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.trackPublications = new Map();\r\n    this.engine = engine;\r\n    this.roomOptions = options;\r\n    this.setupEngine(engine);\r\n    this.activeDeviceMap = new Map([['audioinput', 'default'], ['videoinput', 'default'], ['audiooutput', 'default']]);\r\n    this.pendingSignalRequests = new Map();\r\n    this.rpcHandlers = roomRpcHandlers;\r\n  }\r\n  get lastCameraError() {\r\n    return this.cameraError;\r\n  }\r\n  get lastMicrophoneError() {\r\n    return this.microphoneError;\r\n  }\r\n  get isE2EEEnabled() {\r\n    return this.encryptionType !== Encryption_Type.NONE;\r\n  }\r\n  getTrackPublication(source) {\r\n    const track = super.getTrackPublication(source);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  getTrackPublicationByName(name) {\r\n    const track = super.getTrackPublicationByName(name);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setupEngine(engine) {\r\n    this.engine = engine;\r\n    this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {\r\n      const pub = this.trackPublications.get(trackSid);\r\n      if (!pub || !pub.track) {\r\n        return;\r\n      }\r\n      if (muted) {\r\n        pub.mute();\r\n      } else {\r\n        pub.unmute();\r\n      }\r\n    });\r\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalConnected, this.handleSignalConnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\r\n    this.signalConnectedFuture = undefined;\r\n  }\r\n  /**\r\n   * Sets and updates the metadata of the local participant.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * method will throw if the user doesn't have the required permissions\r\n   * @param metadata\r\n   */\r\n  setMetadata(metadata) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        metadata\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Sets and updates the name of the local participant.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * method will throw if the user doesn't have the required permissions\r\n   * @param metadata\r\n   */\r\n  setName(name) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        name\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Set or update participant attributes. It will make updates only to keys that\r\n   * are present in `attributes`, and will not override others.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * @param attributes attributes to update\r\n   */\r\n  setAttributes(attributes) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        attributes\r\n      });\r\n    });\r\n  }\r\n  requestMetadataUpdate(_a) {\r\n    return __awaiter(this, arguments, void 0, function (_ref) {\r\n      var _this = this;\r\n      let {\r\n        metadata,\r\n        name,\r\n        attributes\r\n      } = _ref;\r\n      return function* () {\r\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\r\n          var _a, _b;\r\n          try {\r\n            let isRejected = false;\r\n            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : '', (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : '', attributes);\r\n            const startTime = performance.now();\r\n            this.pendingSignalRequests.set(requestId, {\r\n              resolve,\r\n              reject: error => {\r\n                reject(error);\r\n                isRejected = true;\r\n              },\r\n              values: {\r\n                name,\r\n                metadata,\r\n                attributes\r\n              }\r\n            });\r\n            while (performance.now() - startTime < 5000 && !isRejected) {\r\n              if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every(_ref2 => {\r\n                let [key, value] = _ref2;\r\n                return this.attributes[key] === value || value === '' && !this.attributes[key];\r\n              }))) {\r\n                this.pendingSignalRequests.delete(requestId);\r\n                resolve();\r\n                return;\r\n              }\r\n              yield sleep(50);\r\n            }\r\n            reject(new SignalRequestError('Request to update local metadata timed out', 'TimeoutError'));\r\n          } catch (e) {\r\n            if (e instanceof Error) reject(e);\r\n          }\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Enable or disable a participant's camera track.\r\n   *\r\n   * If a track has already published, it'll mute or unmute the track.\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setCameraEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\r\n  }\r\n  /**\r\n   * Enable or disable a participant's microphone track.\r\n   *\r\n   * If a track has already published, it'll mute or unmute the track.\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setMicrophoneEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\r\n  }\r\n  /**\r\n   * Start or stop sharing a participant's screen\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setScreenShareEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\r\n  }\r\n  /** @internal */\r\n  setPermissions(permissions) {\r\n    const prevPermissions = this.permissions;\r\n    const changed = super.setPermissions(permissions);\r\n    if (changed && prevPermissions) {\r\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\r\n    }\r\n    return changed;\r\n  }\r\n  /** @internal */\r\n  setE2EEEnabled(enabled) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\r\n      yield this.republishAllTracks(undefined, false);\r\n    });\r\n  }\r\n  setTrackEnabled(source, enabled, options, publishOptions) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\r\n        source,\r\n        enabled\r\n      }));\r\n      if (this.republishPromise) {\r\n        yield this.republishPromise;\r\n      }\r\n      let track = this.getTrackPublication(source);\r\n      if (enabled) {\r\n        if (track) {\r\n          yield track.unmute();\r\n        } else {\r\n          let localTracks;\r\n          if (this.pendingPublishing.has(source)) {\r\n            const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\r\n            if (!pendingTrack) {\r\n              this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\r\n                source\r\n              }));\r\n            }\r\n            yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\r\n            return pendingTrack;\r\n          }\r\n          this.pendingPublishing.add(source);\r\n          try {\r\n            switch (source) {\r\n              case Track.Source.Camera:\r\n                localTracks = yield this.createTracks({\r\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\r\n                });\r\n                break;\r\n              case Track.Source.Microphone:\r\n                localTracks = yield this.createTracks({\r\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\r\n                });\r\n                break;\r\n              case Track.Source.ScreenShare:\r\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\r\n                break;\r\n              default:\r\n                throw new TrackInvalidError(source);\r\n            }\r\n          } catch (e) {\r\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\r\n              tr.stop();\r\n            });\r\n            if (e instanceof Error) {\r\n              this.emit(ParticipantEvent.MediaDevicesError, e, sourceToKind(source));\r\n            }\r\n            this.pendingPublishing.delete(source);\r\n            throw e;\r\n          }\r\n          for (const localTrack of localTracks) {\r\n            if (source === Track.Source.Microphone && isAudioTrack(localTrack) && (publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.preConnectBuffer)) {\r\n              this.log.info('starting preconnect buffer for microphone', Object.assign({}, this.logContext));\r\n              localTrack.startPreConnectBuffer();\r\n            }\r\n          }\r\n          try {\r\n            const publishPromises = [];\r\n            for (const localTrack of localTracks) {\r\n              this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\r\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\r\n            }\r\n            const publishedTracks = yield Promise.all(publishPromises);\r\n            // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\r\n            // revisit if we want to return an array of tracks instead for v2\r\n            [track] = publishedTracks;\r\n          } catch (e) {\r\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\r\n              tr.stop();\r\n            });\r\n            throw e;\r\n          } finally {\r\n            this.pendingPublishing.delete(source);\r\n          }\r\n        }\r\n      } else {\r\n        if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\r\n          // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\r\n          track = yield this.waitForPendingPublicationOfSource(source);\r\n          if (!track) {\r\n            this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\r\n              source\r\n            }));\r\n          }\r\n        }\r\n        if (track && track.track) {\r\n          // screenshare cannot be muted, unpublish instead\r\n          if (source === Track.Source.ScreenShare) {\r\n            track = yield this.unpublishTrack(track.track);\r\n            const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\r\n            if (screenAudioTrack && screenAudioTrack.track) {\r\n              this.unpublishTrack(screenAudioTrack.track);\r\n            }\r\n          } else {\r\n            yield track.mute();\r\n          }\r\n        }\r\n      }\r\n      return track;\r\n    });\r\n  }\r\n  /**\r\n   * Publish both camera and microphone at the same time. This is useful for\r\n   * displaying a single Permission Dialog box to the end user.\r\n   */\r\n  enableCameraAndMicrophone() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\r\n        // no-op it's already been requested\r\n        return;\r\n      }\r\n      this.pendingPublishing.add(Track.Source.Camera);\r\n      this.pendingPublishing.add(Track.Source.Microphone);\r\n      try {\r\n        const tracks = yield this.createTracks({\r\n          audio: true,\r\n          video: true\r\n        });\r\n        yield Promise.all(tracks.map(track => this.publishTrack(track)));\r\n      } finally {\r\n        this.pendingPublishing.delete(Track.Source.Camera);\r\n        this.pendingPublishing.delete(Track.Source.Microphone);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Create local camera and/or microphone tracks\r\n   * @param options\r\n   * @returns\r\n   */\r\n  createTracks(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      options !== null && options !== void 0 ? options : options = {};\r\n      const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\r\n      try {\r\n        const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\r\n          loggerName: this.roomOptions.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        const localTracks = tracks.map(track => {\r\n          if (isAudioTrack(track)) {\r\n            this.microphoneError = undefined;\r\n            track.setAudioContext(this.audioContext);\r\n            track.source = Track.Source.Microphone;\r\n            this.emit(ParticipantEvent.AudioStreamAcquired);\r\n          }\r\n          if (isVideoTrack(track)) {\r\n            this.cameraError = undefined;\r\n            track.source = Track.Source.Camera;\r\n          }\r\n          return track;\r\n        });\r\n        return localTracks;\r\n      } catch (err) {\r\n        if (err instanceof Error) {\r\n          if (options.audio) {\r\n            this.microphoneError = err;\r\n          }\r\n          if (options.video) {\r\n            this.cameraError = err;\r\n          }\r\n        }\r\n        throw err;\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Creates a screen capture tracks with getDisplayMedia().\r\n   * A LocalVideoTrack is always created and returned.\r\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\r\n   */\r\n  createScreenTracks(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (options === undefined) {\r\n        options = {};\r\n      }\r\n      if (navigator.mediaDevices.getDisplayMedia === undefined) {\r\n        throw new DeviceUnsupportedError('getDisplayMedia not supported');\r\n      }\r\n      if (options.resolution === undefined && !isSafari17()) {\r\n        // we need to constrain the dimensions, otherwise it could lead to low bitrate\r\n        // due to encoding a huge video. Encoding such large surfaces is really expensive\r\n        // unfortunately Safari 17 has a but and cannot be constrained by default\r\n        options.resolution = ScreenSharePresets.h1080fps30.resolution;\r\n      }\r\n      const constraints = screenCaptureToDisplayMediaStreamOptions(options);\r\n      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\r\n      const tracks = stream.getVideoTracks();\r\n      if (tracks.length === 0) {\r\n        throw new TrackInvalidError('no video track found');\r\n      }\r\n      const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\r\n        loggerName: this.roomOptions.loggerName,\r\n        loggerContextCb: () => this.logContext\r\n      });\r\n      screenVideo.source = Track.Source.ScreenShare;\r\n      if (options.contentHint) {\r\n        screenVideo.mediaStreamTrack.contentHint = options.contentHint;\r\n      }\r\n      const localTracks = [screenVideo];\r\n      if (stream.getAudioTracks().length > 0) {\r\n        this.emit(ParticipantEvent.AudioStreamAcquired);\r\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\r\n          loggerName: this.roomOptions.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        screenAudio.source = Track.Source.ScreenShareAudio;\r\n        localTracks.push(screenAudio);\r\n      }\r\n      return localTracks;\r\n    });\r\n  }\r\n  /**\r\n   * Publish a new track to the room\r\n   * @param track\r\n   * @param options\r\n   */\r\n  publishTrack(track, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.publishOrRepublishTrack(track, options);\r\n    });\r\n  }\r\n  publishOrRepublishTrack(track_1, options_1) {\r\n    return __awaiter(this, arguments, void 0, function (track, options) {\r\n      var _this2 = this;\r\n      let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      return function* () {\r\n        var _a, _b, _c, _d;\r\n        if (isLocalAudioTrack(track)) {\r\n          track.setAudioContext(_this2.audioContext);\r\n        }\r\n        yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\r\n        if (_this2.republishPromise && !isRepublish) {\r\n          yield _this2.republishPromise;\r\n        }\r\n        if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\r\n          yield _this2.pendingPublishPromises.get(track);\r\n        }\r\n        let defaultConstraints;\r\n        if (track instanceof MediaStreamTrack) {\r\n          defaultConstraints = track.getConstraints();\r\n        } else {\r\n          // we want to access constraints directly as `track.mediaStreamTrack`\r\n          // might be pointing to a non-device track (e.g. processed track) already\r\n          defaultConstraints = track.constraints;\r\n          let deviceKind = undefined;\r\n          switch (track.source) {\r\n            case Track.Source.Microphone:\r\n              deviceKind = 'audioinput';\r\n              break;\r\n            case Track.Source.Camera:\r\n              deviceKind = 'videoinput';\r\n          }\r\n          if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\r\n            defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\r\n              deviceId: _this2.activeDeviceMap.get(deviceKind)\r\n            });\r\n          }\r\n        }\r\n        // convert raw media track into audio or video track\r\n        if (track instanceof MediaStreamTrack) {\r\n          switch (track.kind) {\r\n            case 'audio':\r\n              track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\r\n                loggerName: _this2.roomOptions.loggerName,\r\n                loggerContextCb: () => _this2.logContext\r\n              });\r\n              break;\r\n            case 'video':\r\n              track = new LocalVideoTrack(track, defaultConstraints, true, {\r\n                loggerName: _this2.roomOptions.loggerName,\r\n                loggerContextCb: () => _this2.logContext\r\n              });\r\n              break;\r\n            default:\r\n              throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\r\n          }\r\n        } else {\r\n          track.updateLoggerOptions({\r\n            loggerName: _this2.roomOptions.loggerName,\r\n            loggerContextCb: () => _this2.logContext\r\n          });\r\n        }\r\n        // is it already published? if so skip\r\n        let existingPublication;\r\n        _this2.trackPublications.forEach(publication => {\r\n          if (!publication.track) {\r\n            return;\r\n          }\r\n          if (publication.track === track) {\r\n            existingPublication = publication;\r\n          }\r\n        });\r\n        if (existingPublication) {\r\n          _this2.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\r\n          return existingPublication;\r\n        }\r\n        const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() &&\r\n        // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\r\n        track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\r\n        const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\r\n        // disable dtx for stereo track if not enabled explicitly\r\n        if (isStereo) {\r\n          if (!options) {\r\n            options = {};\r\n          }\r\n          if (options.dtx === undefined) {\r\n            _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\r\n          }\r\n          if (options.red === undefined) {\r\n            _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\r\n          }\r\n          (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\r\n          (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\r\n        }\r\n        const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\r\n        if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\r\n          _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\r\n          opts.simulcast = false;\r\n        }\r\n        if (opts.source) {\r\n          track.source = opts.source;\r\n        }\r\n        const publishPromise = new Promise((resolve, reject) => __awaiter(_this2, void 0, void 0, function* () {\r\n          try {\r\n            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\r\n              this.log.debug('deferring track publication until signal is connected', Object.assign(Object.assign({}, this.logContext), {\r\n                track: getLogContextFromTrack(track)\r\n              }));\r\n              const timeout = setTimeout(() => {\r\n                reject(new PublishTrackError('publishing rejected as engine not connected within timeout', 408));\r\n              }, 15000);\r\n              yield this.waitUntilEngineConnected();\r\n              clearTimeout(timeout);\r\n              const publication = yield this.publish(track, opts, isStereo);\r\n              resolve(publication);\r\n            } else {\r\n              try {\r\n                const publication = yield this.publish(track, opts, isStereo);\r\n                resolve(publication);\r\n              } catch (e) {\r\n                reject(e);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        }));\r\n        _this2.pendingPublishPromises.set(track, publishPromise);\r\n        try {\r\n          const publication = yield publishPromise;\r\n          return publication;\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          _this2.pendingPublishPromises.delete(track);\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  waitUntilEngineConnected() {\r\n    if (!this.signalConnectedFuture) {\r\n      this.signalConnectedFuture = new Future();\r\n    }\r\n    return this.signalConnectedFuture.promise;\r\n  }\r\n  hasPermissionsToPublish(track) {\r\n    if (!this.permissions) {\r\n      this.log.warn('no permissions present for publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      return false;\r\n    }\r\n    const {\r\n      canPublish,\r\n      canPublishSources\r\n    } = this.permissions;\r\n    if (canPublish && (canPublishSources.length === 0 || canPublishSources.map(source => getTrackSourceFromProto(source)).includes(track.source))) {\r\n      return true;\r\n    }\r\n    this.log.warn('insufficient permissions to publish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n    return false;\r\n  }\r\n  publish(track, opts, isStereo) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n      if (!this.hasPermissionsToPublish(track)) {\r\n        throw new PublishTrackError('failed to publish track, insufficient permissions', 403);\r\n      }\r\n      const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => isLocalTrack(track) && publishedTrack.source === track.source);\r\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\r\n        this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      }\r\n      if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\r\n        track.stopOnMute = true;\r\n      }\r\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\r\n        // Firefox does not work well with simulcasted screen share\r\n        // we frequently get no data on layer 0 when enabled\r\n        opts.simulcast = false;\r\n      }\r\n      // require full AV1/VP9 SVC support prior to using it\r\n      if (opts.videoCodec === 'av1' && !supportsAV1()) {\r\n        opts.videoCodec = undefined;\r\n      }\r\n      if (opts.videoCodec === 'vp9' && !supportsVP9()) {\r\n        opts.videoCodec = undefined;\r\n      }\r\n      if (opts.videoCodec === undefined) {\r\n        opts.videoCodec = defaultVideoCodec;\r\n      }\r\n      if (this.enabledPublishVideoCodecs.length > 0) {\r\n        // fallback to a supported codec if it is not supported\r\n        if (!this.enabledPublishVideoCodecs.some(c => opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\r\n          opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\r\n        }\r\n      }\r\n      const videoCodec = opts.videoCodec;\r\n      // handle track actions\r\n      track.on(TrackEvent.Muted, this.onTrackMuted);\r\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\r\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\r\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\r\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\r\n      track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\r\n      const audioFeatures = [];\r\n      const disableDtx = !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true);\r\n      const settings = track.getSourceTrackSettings();\r\n      if (settings.autoGainControl) {\r\n        audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\r\n      }\r\n      if (settings.echoCancellation) {\r\n        audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);\r\n      }\r\n      if (settings.noiseSuppression) {\r\n        audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);\r\n      }\r\n      if (settings.channelCount && settings.channelCount > 1) {\r\n        audioFeatures.push(AudioTrackFeature.TF_STEREO);\r\n      }\r\n      if (disableDtx) {\r\n        audioFeatures.push(AudioTrackFeature.TF_NO_DTX);\r\n      }\r\n      if (isLocalAudioTrack(track) && track.hasPreConnectBuffer) {\r\n        audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);\r\n      }\r\n      // create track publication from track\r\n      const req = new AddTrackRequest({\r\n        // get local track id for use during publishing\r\n        cid: track.mediaStreamTrack.id,\r\n        name: opts.name,\r\n        type: Track.kindToProto(track.kind),\r\n        muted: track.isMuted,\r\n        source: Track.sourceToProto(track.source),\r\n        disableDtx,\r\n        encryption: this.encryptionType,\r\n        stereo: isStereo,\r\n        disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\r\n        stream: opts === null || opts === void 0 ? void 0 : opts.stream,\r\n        backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,\r\n        audioFeatures\r\n      });\r\n      // compute encodings and layers for video\r\n      let encodings;\r\n      if (track.kind === Track.Kind.Video) {\r\n        let dims = {\r\n          width: 0,\r\n          height: 0\r\n        };\r\n        try {\r\n          dims = yield track.waitForDimensions();\r\n        } catch (e) {\r\n          // use defaults, it's quite painful for congestion control without simulcast\r\n          // so using default dims according to publish settings\r\n          const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\r\n          dims = {\r\n            width: defaultRes.width,\r\n            height: defaultRes.height\r\n          };\r\n          // log failure\r\n          this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n            dims\r\n          }));\r\n        }\r\n        // width and height should be defined for video\r\n        req.width = dims.width;\r\n        req.height = dims.height;\r\n        // for svc codecs, disable simulcast and use vp8 for backup codec\r\n        if (isLocalVideoTrack(track)) {\r\n          if (isSVCCodec(videoCodec)) {\r\n            if (track.source === Track.Source.ScreenShare) {\r\n              // vp9 svc with screenshare cannot encode multiple spatial layers\r\n              // doing so reduces publish resolution to minimal resolution\r\n              opts.scalabilityMode = 'L1T3';\r\n              // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\r\n              // It has a different path for screenshare handling and it seems to be untested/buggy\r\n              // As a workaround, we are setting contentHint to force it to go through the same\r\n              // path as regular camera video. While this is not optimal, it delivers the performance\r\n              // that we need\r\n              if ('contentHint' in track.mediaStreamTrack) {\r\n                track.mediaStreamTrack.contentHint = 'motion';\r\n                this.log.info('forcing contentHint to motion for screenshare with SVC codecs', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              }\r\n            }\r\n            // set scalabilityMode to 'L3T3_KEY' by default\r\n            opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\r\n          }\r\n          req.simulcastCodecs = [new SimulcastCodec({\r\n            codec: videoCodec,\r\n            cid: track.mediaStreamTrack.id\r\n          })];\r\n          // set up backup\r\n          if (opts.backupCodec === true) {\r\n            opts.backupCodec = {\r\n              codec: defaultVideoCodec\r\n            };\r\n          }\r\n          if (opts.backupCodec && videoCodec !== opts.backupCodec.codec &&\r\n          // TODO remove this once e2ee is supported for backup codecs\r\n          req.encryption === Encryption_Type.NONE) {\r\n            // multi-codec simulcast requires dynacast\r\n            if (!this.roomOptions.dynacast) {\r\n              this.roomOptions.dynacast = true;\r\n            }\r\n            req.simulcastCodecs.push(new SimulcastCodec({\r\n              codec: opts.backupCodec.codec,\r\n              cid: ''\r\n            }));\r\n          }\r\n        }\r\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\r\n        req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\r\n      } else if (track.kind === Track.Kind.Audio) {\r\n        encodings = [{\r\n          maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\r\n          priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : 'high',\r\n          networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : 'high'\r\n        }];\r\n      }\r\n      if (!this.engine || this.engine.isClosed) {\r\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\r\n      }\r\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\r\n        var _a, _b, _c;\r\n        if (!this.engine.pcManager) {\r\n          throw new UnexpectedConnectionState('pcManager is not ready');\r\n        }\r\n        track.sender = yield this.engine.createSender(track, opts, encodings);\r\n        if (isLocalVideoTrack(track)) {\r\n          (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\r\n          track.setDegradationPreference(opts.degradationPreference);\r\n        }\r\n        if (encodings) {\r\n          if (isFireFox() && track.kind === Track.Kind.Audio) {\r\n            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\r\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\r\n               publish high quality audio track. But firefox always uses this value as the actual\r\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\r\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\r\n               fix the issue.\r\n             */\r\n            let trackTransceiver = undefined;\r\n            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\r\n              if (transceiver.sender === track.sender) {\r\n                trackTransceiver = transceiver;\r\n                break;\r\n              }\r\n            }\r\n            if (trackTransceiver) {\r\n              this.engine.pcManager.publisher.setTrackCodecBitrate({\r\n                transceiver: trackTransceiver,\r\n                codec: 'opus',\r\n                maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\r\n              });\r\n            }\r\n          } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\r\n            this.engine.pcManager.publisher.setTrackCodecBitrate({\r\n              cid: req.cid,\r\n              codec: track.codec,\r\n              maxbr: encodings[0].maxBitrate / 1000\r\n            });\r\n          }\r\n        }\r\n        yield this.engine.negotiate();\r\n      });\r\n      let ti;\r\n      const addTrackPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        var _a;\r\n        try {\r\n          ti = yield this.engine.addTrack(req);\r\n          resolve(ti);\r\n        } catch (err) {\r\n          if (track.sender && ((_a = this.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher)) {\r\n            this.engine.pcManager.publisher.removeTrack(track.sender);\r\n            yield this.engine.negotiate().catch(negotiateErr => {\r\n              this.log.error('failed to negotiate after removing track due to failed add track request', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n                error: negotiateErr\r\n              }));\r\n            });\r\n          }\r\n          reject(err);\r\n        }\r\n      }));\r\n      if (this.enabledPublishVideoCodecs.length > 0) {\r\n        const rets = yield Promise.all([addTrackPromise, negotiate()]);\r\n        ti = rets[0];\r\n      } else {\r\n        ti = yield addTrackPromise;\r\n        // server might not support the codec the client has requested, in that case, fallback\r\n        // to a supported codec\r\n        let primaryCodecMime;\r\n        ti.codecs.forEach(codec => {\r\n          if (primaryCodecMime === undefined) {\r\n            primaryCodecMime = codec.mimeType;\r\n          }\r\n        });\r\n        if (primaryCodecMime && track.kind === Track.Kind.Video) {\r\n          const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\r\n          if (updatedCodec !== videoCodec) {\r\n            this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n              codec: updatedCodec\r\n            }));\r\n            opts.videoCodec = updatedCodec;\r\n            // recompute encodings since bitrates/etc could have changed\r\n            encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\r\n          }\r\n        }\r\n        yield negotiate();\r\n      }\r\n      const publication = new LocalTrackPublication(track.kind, ti, track, {\r\n        loggerName: this.roomOptions.loggerName,\r\n        loggerContextCb: () => this.logContext\r\n      });\r\n      // save options for when it needs to be republished again\r\n      publication.options = opts;\r\n      track.sid = ti.sid;\r\n      this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\r\n        encodings,\r\n        trackInfo: ti\r\n      }));\r\n      if (isLocalVideoTrack(track)) {\r\n        track.startMonitor(this.engine.client);\r\n      } else if (isLocalAudioTrack(track)) {\r\n        track.startMonitor();\r\n      }\r\n      this.addTrackPublication(publication);\r\n      // send event for publication\r\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\r\n      if (isLocalAudioTrack(track) && ti.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)) {\r\n        const stream = track.getPreConnectBuffer();\r\n        // TODO: we're registering the listener after negotiation, so there might be a race\r\n        this.on(ParticipantEvent.LocalTrackSubscribed, pub => {\r\n          if (pub.trackSid === ti.sid) {\r\n            if (!track.hasPreConnectBuffer) {\r\n              this.log.warn('subscribe event came to late, buffer already closed', this.logContext);\r\n              return;\r\n            }\r\n            this.log.debug('finished recording preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n            track.stopPreConnectBuffer();\r\n          }\r\n        });\r\n        if (stream) {\r\n          const bufferStreamPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            var _a, e_2, _b, _c;\r\n            var _d, _e;\r\n            try {\r\n              this.log.debug('waiting for agent', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              const agentActiveTimeout = setTimeout(() => {\r\n                reject(new Error('agent not active within 10 seconds'));\r\n              }, 10000);\r\n              const agent = yield this.waitUntilActiveAgentPresent();\r\n              clearTimeout(agentActiveTimeout);\r\n              this.log.debug('sending preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              const writer = yield this.streamBytes({\r\n                name: 'preconnect-buffer',\r\n                mimeType: 'audio/opus',\r\n                topic: 'lk.agent.pre-connect-audio-buffer',\r\n                destinationIdentities: [agent.identity],\r\n                attributes: {\r\n                  trackId: publication.trackSid,\r\n                  sampleRate: String((_d = settings.sampleRate) !== null && _d !== void 0 ? _d : '48000'),\r\n                  channels: String((_e = settings.channelCount) !== null && _e !== void 0 ? _e : '1')\r\n                }\r\n              });\r\n              try {\r\n                for (var _f = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a = stream_1_1.done, !_a; _f = true) {\r\n                  _c = stream_1_1.value;\r\n                  _f = false;\r\n                  const chunk = _c;\r\n                  yield writer.write(chunk);\r\n                }\r\n              } catch (e_2_1) {\r\n                e_2 = {\r\n                  error: e_2_1\r\n                };\r\n              } finally {\r\n                try {\r\n                  if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);\r\n                } finally {\r\n                  if (e_2) throw e_2.error;\r\n                }\r\n              }\r\n              yield writer.close();\r\n              resolve();\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          }));\r\n          bufferStreamPromise.then(() => {\r\n            this.log.debug('preconnect buffer sent successfully', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          }).catch(e => {\r\n            this.log.error('error sending preconnect buffer', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n              error: e\r\n            }));\r\n          });\r\n        }\r\n      }\r\n      return publication;\r\n    });\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /** @internal\r\n   * publish additional codec to existing track\r\n   */\r\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      // TODO remove once e2ee is supported for backup tracks\r\n      if (this.encryptionType !== Encryption_Type.NONE) {\r\n        return;\r\n      }\r\n      // is it not published? if so skip\r\n      let existingPublication;\r\n      this.trackPublications.forEach(publication => {\r\n        if (!publication.track) {\r\n          return;\r\n        }\r\n        if (publication.track === track) {\r\n          existingPublication = publication;\r\n        }\r\n      });\r\n      if (!existingPublication) {\r\n        throw new TrackInvalidError('track is not published');\r\n      }\r\n      if (!isLocalVideoTrack(track)) {\r\n        throw new TrackInvalidError('track is not a video track');\r\n      }\r\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\r\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\r\n      if (!encodings) {\r\n        this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        return;\r\n      }\r\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\r\n      if (!simulcastTrack) {\r\n        return;\r\n      }\r\n      const req = new AddTrackRequest({\r\n        cid: simulcastTrack.mediaStreamTrack.id,\r\n        type: Track.kindToProto(track.kind),\r\n        muted: track.isMuted,\r\n        source: Track.sourceToProto(track.source),\r\n        sid: track.sid,\r\n        simulcastCodecs: [{\r\n          codec: opts.videoCodec,\r\n          cid: simulcastTrack.mediaStreamTrack.id\r\n        }]\r\n      });\r\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\r\n      if (!this.engine || this.engine.isClosed) {\r\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\r\n      }\r\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\r\n        yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\r\n        yield this.engine.negotiate();\r\n      });\r\n      const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);\r\n      const ti = rets[0];\r\n      this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\r\n        encodings,\r\n        trackInfo: ti\r\n      }));\r\n    });\r\n  }\r\n  unpublishTrack(track, stopOnUnpublish) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (isLocalTrack(track)) {\r\n        const publishPromise = this.pendingPublishPromises.get(track);\r\n        if (publishPromise) {\r\n          this.log.info('awaiting publish promise before attempting to unpublish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          yield publishPromise;\r\n        }\r\n      }\r\n      // look through all published tracks to find the right ones\r\n      const publication = this.getPublicationForTrack(track);\r\n      const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\r\n      this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\r\n      if (!publication || !publication.track) {\r\n        this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\r\n        return undefined;\r\n      }\r\n      track = publication.track;\r\n      track.off(TrackEvent.Muted, this.onTrackMuted);\r\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\r\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\r\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\r\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\r\n      track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\r\n      if (stopOnUnpublish === undefined) {\r\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\r\n      }\r\n      if (stopOnUnpublish) {\r\n        track.stop();\r\n      } else {\r\n        track.stopMonitor();\r\n      }\r\n      let negotiationNeeded = false;\r\n      const trackSender = track.sender;\r\n      track.sender = undefined;\r\n      if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\r\n        try {\r\n          for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\r\n            // if sender is not currently sending (after replaceTrack(null))\r\n            // removeTrack would have no effect.\r\n            // to ensure we end up successfully removing the track, manually set\r\n            // the transceiver to inactive\r\n            if (transceiver.sender === trackSender) {\r\n              transceiver.direction = 'inactive';\r\n              negotiationNeeded = true;\r\n            }\r\n          }\r\n          if (this.engine.removeTrack(trackSender)) {\r\n            negotiationNeeded = true;\r\n          }\r\n          if (isLocalVideoTrack(track)) {\r\n            for (const [, trackInfo] of track.simulcastCodecs) {\r\n              if (trackInfo.sender) {\r\n                if (this.engine.removeTrack(trackInfo.sender)) {\r\n                  negotiationNeeded = true;\r\n                }\r\n                trackInfo.sender = undefined;\r\n              }\r\n            }\r\n            track.simulcastCodecs.clear();\r\n          }\r\n        } catch (e) {\r\n          this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      // remove from our maps\r\n      this.trackPublications.delete(publication.trackSid);\r\n      switch (publication.kind) {\r\n        case Track.Kind.Audio:\r\n          this.audioTrackPublications.delete(publication.trackSid);\r\n          break;\r\n        case Track.Kind.Video:\r\n          this.videoTrackPublications.delete(publication.trackSid);\r\n          break;\r\n      }\r\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\r\n      publication.setTrack(undefined);\r\n      if (negotiationNeeded) {\r\n        yield this.engine.negotiate();\r\n      }\r\n      return publication;\r\n    });\r\n  }\r\n  unpublishTracks(tracks) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const results = yield Promise.all(tracks.map(track => this.unpublishTrack(track)));\r\n      return results.filter(track => !!track);\r\n    });\r\n  }\r\n  republishAllTracks(options_1) {\r\n    return __awaiter(this, arguments, void 0, function (options) {\r\n      var _this3 = this;\r\n      let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        if (_this3.republishPromise) {\r\n          yield _this3.republishPromise;\r\n        }\r\n        _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {\r\n          try {\r\n            const localPubs = [];\r\n            this.trackPublications.forEach(pub => {\r\n              if (pub.track) {\r\n                if (options) {\r\n                  pub.options = Object.assign(Object.assign({}, pub.options), options);\r\n                }\r\n                localPubs.push(pub);\r\n              }\r\n            });\r\n            yield Promise.all(localPubs.map(pub => __awaiter(this, void 0, void 0, function* () {\r\n              const track = pub.track;\r\n              yield this.unpublishTrack(track, false);\r\n              if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\r\n                // generally we need to restart the track before publishing, often a full reconnect\r\n                // is necessary because computer had gone to sleep.\r\n                this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\r\n                  track: pub.trackSid\r\n                }));\r\n                yield track.restartTrack();\r\n              }\r\n              yield this.publishOrRepublishTrack(track, pub.options, true);\r\n            })));\r\n            resolve();\r\n          } catch (error) {\r\n            reject(error);\r\n          } finally {\r\n            this.republishPromise = undefined;\r\n          }\r\n        }));\r\n        yield _this3.republishPromise;\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Publish a new data payload to the room. Data will be forwarded to each\r\n   * participant in the room if the destination field in publishOptions is empty\r\n   *\r\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\r\n   * @param options optionally specify a `reliable`, `topic` and `destination`\r\n   */\r\n  publishData(data_1) {\r\n    return __awaiter(this, arguments, void 0, function (data) {\r\n      var _this4 = this;\r\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      return function* () {\r\n        const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\r\n        const destinationIdentities = options.destinationIdentities;\r\n        const topic = options.topic;\r\n        const packet = new DataPacket({\r\n          kind: kind,\r\n          value: {\r\n            case: 'user',\r\n            value: new UserPacket({\r\n              participantIdentity: _this4.identity,\r\n              payload: data,\r\n              destinationIdentities,\r\n              topic\r\n            })\r\n          }\r\n        });\r\n        yield _this4.engine.sendDataPacket(packet, kind);\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Publish SIP DTMF message to the room.\r\n   *\r\n   * @param code DTMF code\r\n   * @param digit DTMF digit\r\n   */\r\n  publishDtmf(code, digit) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'sipDtmf',\r\n          value: new SipDTMF({\r\n            code: code,\r\n            digit: digit\r\n          })\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  sendChatMessage(text, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const msg = {\r\n        id: crypto.randomUUID(),\r\n        message: text,\r\n        timestamp: Date.now(),\r\n        attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\r\n      };\r\n      const packet = new DataPacket({\r\n        value: {\r\n          case: 'chatMessage',\r\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\r\n            timestamp: protoInt64.parse(msg.timestamp)\r\n          }))\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      this.emit(ParticipantEvent.ChatMessage, msg);\r\n      return msg;\r\n    });\r\n  }\r\n  editChatMessage(editText, originalMessage) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const msg = Object.assign(Object.assign({}, originalMessage), {\r\n        message: editText,\r\n        editTimestamp: Date.now()\r\n      });\r\n      const packet = new DataPacket({\r\n        value: {\r\n          case: 'chatMessage',\r\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\r\n            timestamp: protoInt64.parse(msg.timestamp),\r\n            editTimestamp: protoInt64.parse(msg.editTimestamp)\r\n          }))\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      this.emit(ParticipantEvent.ChatMessage, msg);\r\n      return msg;\r\n    });\r\n  }\r\n  sendText(text, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const streamId = crypto.randomUUID();\r\n      const textInBytes = new TextEncoder().encode(text);\r\n      const totalTextLength = textInBytes.byteLength;\r\n      const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => crypto.randomUUID());\r\n      const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\r\n      const handleProgress = (progress, idx) => {\r\n        var _a;\r\n        progresses[idx] = progress;\r\n        const totalProgress = progresses.reduce((acc, val) => acc + val, 0);\r\n        (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\r\n      };\r\n      const writer = yield this.streamText({\r\n        streamId,\r\n        totalSize: totalTextLength,\r\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\r\n        topic: options === null || options === void 0 ? void 0 : options.topic,\r\n        attachedStreamIds: fileIds,\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\r\n      });\r\n      yield writer.write(text);\r\n      // set text part of progress to 1\r\n      handleProgress(1, 0);\r\n      yield writer.close();\r\n      if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\r\n        yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {\r\n          return this._sendFile(fileIds[idx], file, {\r\n            topic: options.topic,\r\n            mimeType: file.type,\r\n            onProgress: progress => {\r\n              handleProgress(progress, idx + 1);\r\n            }\r\n          });\r\n        })));\r\n      }\r\n      return writer.info;\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental CAUTION, might get removed in a minor release\r\n   */\r\n  streamText(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\r\n      const info = {\r\n        id: streamId,\r\n        mimeType: 'text/plain',\r\n        timestamp: Date.now(),\r\n        topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : '',\r\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\r\n      };\r\n      const header = new DataStream_Header({\r\n        streamId,\r\n        mimeType: info.mimeType,\r\n        topic: info.topic,\r\n        timestamp: numberToBigInt(info.timestamp),\r\n        totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\r\n        attributes: info.attributes,\r\n        contentHeader: {\r\n          case: 'textHeader',\r\n          value: new DataStream_TextHeader({\r\n            version: options === null || options === void 0 ? void 0 : options.version,\r\n            attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\r\n            replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\r\n            operationType: (options === null || options === void 0 ? void 0 : options.type) === 'update' ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\r\n          })\r\n        }\r\n      });\r\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\r\n      const packet = new DataPacket({\r\n        destinationIdentities,\r\n        value: {\r\n          case: 'streamHeader',\r\n          value: header\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      let chunkId = 0;\r\n      const localP = this;\r\n      const writableStream = new WritableStream({\r\n        // Implement the sink\r\n        write(text) {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {\r\n              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\r\n              const chunk = new DataStream_Chunk({\r\n                content: textByteChunk,\r\n                streamId,\r\n                chunkIndex: numberToBigInt(chunkId)\r\n              });\r\n              const chunkPacket = new DataPacket({\r\n                destinationIdentities,\r\n                value: {\r\n                  case: 'streamChunk',\r\n                  value: chunk\r\n                }\r\n              });\r\n              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\r\n              chunkId += 1;\r\n            }\r\n          });\r\n        },\r\n        close() {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const trailer = new DataStream_Trailer({\r\n              streamId\r\n            });\r\n            const trailerPacket = new DataPacket({\r\n              destinationIdentities,\r\n              value: {\r\n                case: 'streamTrailer',\r\n                value: trailer\r\n              }\r\n            });\r\n            yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\r\n          });\r\n        },\r\n        abort(err) {\r\n          console.log('Sink error:', err);\r\n          // TODO handle aborts to signal something to receiver side\r\n        }\r\n      });\r\n      let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {\r\n        yield writer.close();\r\n      });\r\n      localP.engine.once(EngineEvent.Closing, onEngineClose);\r\n      const writer = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));\r\n      return writer;\r\n    });\r\n  }\r\n  sendFile(file, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const streamId = crypto.randomUUID();\r\n      yield this._sendFile(streamId, file, options);\r\n      return {\r\n        id: streamId\r\n      };\r\n    });\r\n  }\r\n  _sendFile(streamId, file, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const writer = yield this.streamBytes({\r\n        streamId,\r\n        totalSize: file.size,\r\n        name: file.name,\r\n        mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\r\n        topic: options === null || options === void 0 ? void 0 : options.topic,\r\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\r\n      });\r\n      const reader = file.stream().getReader();\r\n      while (true) {\r\n        const {\r\n          done,\r\n          value\r\n        } = yield reader.read();\r\n        if (done) {\r\n          break;\r\n        }\r\n        yield writer.write(value);\r\n      }\r\n      yield writer.close();\r\n      return writer.info;\r\n    });\r\n  }\r\n  streamBytes(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e;\r\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\r\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\r\n      const info = {\r\n        id: streamId,\r\n        mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : 'application/octet-stream',\r\n        topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : '',\r\n        timestamp: Date.now(),\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes,\r\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\r\n        name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : 'unknown'\r\n      };\r\n      const header = new DataStream_Header({\r\n        totalLength: numberToBigInt((_e = info.size) !== null && _e !== void 0 ? _e : 0),\r\n        mimeType: info.mimeType,\r\n        streamId,\r\n        topic: info.topic,\r\n        timestamp: numberToBigInt(Date.now()),\r\n        attributes: info.attributes,\r\n        contentHeader: {\r\n          case: 'byteHeader',\r\n          value: new DataStream_ByteHeader({\r\n            name: info.name\r\n          })\r\n        }\r\n      });\r\n      const packet = new DataPacket({\r\n        destinationIdentities,\r\n        value: {\r\n          case: 'streamHeader',\r\n          value: header\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      let chunkId = 0;\r\n      const writeMutex = new _();\r\n      const engine = this.engine;\r\n      const log = this.log;\r\n      const writableStream = new WritableStream({\r\n        write(chunk) {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const unlock = yield writeMutex.lock();\r\n            let byteOffset = 0;\r\n            try {\r\n              while (byteOffset < chunk.byteLength) {\r\n                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\r\n                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\r\n                const chunkPacket = new DataPacket({\r\n                  destinationIdentities,\r\n                  value: {\r\n                    case: 'streamChunk',\r\n                    value: new DataStream_Chunk({\r\n                      content: subChunk,\r\n                      streamId,\r\n                      chunkIndex: numberToBigInt(chunkId)\r\n                    })\r\n                  }\r\n                });\r\n                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\r\n                chunkId += 1;\r\n                byteOffset += subChunk.byteLength;\r\n              }\r\n            } finally {\r\n              unlock();\r\n            }\r\n          });\r\n        },\r\n        close() {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const trailer = new DataStream_Trailer({\r\n              streamId\r\n            });\r\n            const trailerPacket = new DataPacket({\r\n              destinationIdentities,\r\n              value: {\r\n                case: 'streamTrailer',\r\n                value: trailer\r\n              }\r\n            });\r\n            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\r\n          });\r\n        },\r\n        abort(err) {\r\n          log.error('Sink error:', err);\r\n        }\r\n      });\r\n      const byteWriter = new ByteStreamWriter(writableStream, info);\r\n      return byteWriter;\r\n    });\r\n  }\r\n  /**\r\n   * Initiate an RPC call to a remote participant\r\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\r\n   * @returns A promise that resolves with the response payload or rejects with an error.\r\n   * @throws Error on failure. Details in `message`.\r\n   */\r\n  performRpc(_a) {\r\n    return __awaiter(this, arguments, void 0, function (_ref3) {\r\n      var _this5 = this;\r\n      let {\r\n        destinationIdentity,\r\n        method,\r\n        payload,\r\n        responseTimeout = 10000\r\n      } = _ref3;\r\n      return function* () {\r\n        const maxRoundTripLatency = 2000;\r\n        return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {\r\n          var _a, _b, _c, _d;\r\n          if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\r\n            reject(RpcError.builtIn('REQUEST_PAYLOAD_TOO_LARGE'));\r\n            return;\r\n          }\r\n          if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, '1.8.0') < 0) {\r\n            reject(RpcError.builtIn('UNSUPPORTED_SERVER'));\r\n            return;\r\n          }\r\n          const id = crypto.randomUUID();\r\n          yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);\r\n          const ackTimeoutId = setTimeout(() => {\r\n            this.pendingAcks.delete(id);\r\n            reject(RpcError.builtIn('CONNECTION_TIMEOUT'));\r\n            this.pendingResponses.delete(id);\r\n            clearTimeout(responseTimeoutId);\r\n          }, maxRoundTripLatency);\r\n          this.pendingAcks.set(id, {\r\n            resolve: () => {\r\n              clearTimeout(ackTimeoutId);\r\n            },\r\n            participantIdentity: destinationIdentity\r\n          });\r\n          const responseTimeoutId = setTimeout(() => {\r\n            this.pendingResponses.delete(id);\r\n            reject(RpcError.builtIn('RESPONSE_TIMEOUT'));\r\n          }, responseTimeout);\r\n          this.pendingResponses.set(id, {\r\n            resolve: (responsePayload, responseError) => {\r\n              clearTimeout(responseTimeoutId);\r\n              if (this.pendingAcks.has(id)) {\r\n                console.warn('RPC response received before ack', id);\r\n                this.pendingAcks.delete(id);\r\n                clearTimeout(ackTimeoutId);\r\n              }\r\n              if (responseError) {\r\n                reject(responseError);\r\n              } else {\r\n                resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : '');\r\n              }\r\n            },\r\n            participantIdentity: destinationIdentity\r\n          });\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * @deprecated use `room.registerRpcMethod` instead\r\n   */\r\n  registerRpcMethod(method, handler) {\r\n    if (this.rpcHandlers.has(method)) {\r\n      this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\r\n    }\r\n    this.rpcHandlers.set(method, handler);\r\n  }\r\n  /**\r\n   * @deprecated use `room.unregisterRpcMethod` instead\r\n   */\r\n  unregisterRpcMethod(method) {\r\n    this.rpcHandlers.delete(method);\r\n  }\r\n  /**\r\n   * Control who can subscribe to LocalParticipant's published tracks.\r\n   *\r\n   * By default, all participants can subscribe. This allows fine-grained control over\r\n   * who is able to subscribe at a participant and track level.\r\n   *\r\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\r\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\r\n   * will not grant permissions to any participants and will require a subsequent\r\n   * permissions update to allow subscription.\r\n   *\r\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\r\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\r\n   *  By default this is set to true.\r\n   * @param participantTrackPermissions Full list of individual permissions per\r\n   *  participant/track. Any omitted participants will not receive any permissions.\r\n   */\r\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\r\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\r\n    this.participantTrackPermissions = participantTrackPermissions;\r\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\r\n    if (!this.engine.client.isDisconnected) {\r\n      this.updateTrackSubscriptionPermissions();\r\n    }\r\n  }\r\n  handleIncomingRpcAck(requestId) {\r\n    const handler = this.pendingAcks.get(requestId);\r\n    if (handler) {\r\n      handler.resolve();\r\n      this.pendingAcks.delete(requestId);\r\n    } else {\r\n      console.error('Ack received for unexpected RPC request', requestId);\r\n    }\r\n  }\r\n  handleIncomingRpcResponse(requestId, payload, error) {\r\n    const handler = this.pendingResponses.get(requestId);\r\n    if (handler) {\r\n      handler.resolve(payload, error);\r\n      this.pendingResponses.delete(requestId);\r\n    } else {\r\n      console.error('Response received for unexpected RPC request', requestId);\r\n    }\r\n  }\r\n  /** @internal */\r\n  publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcRequest',\r\n          value: new RpcRequest({\r\n            id: requestId,\r\n            method,\r\n            payload,\r\n            responseTimeoutMs: responseTimeout,\r\n            version: 1\r\n          })\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /** @internal */\r\n  handleParticipantDisconnected(participantIdentity) {\r\n    for (const [id, {\r\n      participantIdentity: pendingIdentity\r\n    }] of this.pendingAcks) {\r\n      if (pendingIdentity === participantIdentity) {\r\n        this.pendingAcks.delete(id);\r\n      }\r\n    }\r\n    for (const [id, {\r\n      participantIdentity: pendingIdentity,\r\n      resolve\r\n    }] of this.pendingResponses) {\r\n      if (pendingIdentity === participantIdentity) {\r\n        resolve(null, RpcError.builtIn('RECIPIENT_DISCONNECTED'));\r\n        this.pendingResponses.delete(id);\r\n      }\r\n    }\r\n  }\r\n  /** @internal */\r\n  setEnabledPublishCodecs(codecs) {\r\n    this.enabledPublishVideoCodecs = codecs.filter(c => c.mime.split('/')[0].toLowerCase() === 'video');\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    if (!super.updateInfo(info)) {\r\n      return false;\r\n    }\r\n    // reconcile track mute status.\r\n    // if server's track mute status doesn't match actual, we'll have to update\r\n    // the server's copy\r\n    info.tracks.forEach(ti => {\r\n      var _a, _b;\r\n      const pub = this.trackPublications.get(ti.sid);\r\n      if (pub) {\r\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\r\n        if (mutedOnServer !== ti.muted) {\r\n          this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\r\n            mutedOnServer\r\n          }));\r\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\r\n        }\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  setActiveAgent(agent) {\r\n    var _a, _b, _c, _d;\r\n    this.firstActiveAgent = agent;\r\n    if (agent && !this.firstActiveAgent) {\r\n      this.firstActiveAgent = agent;\r\n    }\r\n    if (agent) {\r\n      (_b = (_a = this.activeAgentFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a, agent);\r\n    } else {\r\n      (_d = (_c = this.activeAgentFuture) === null || _c === void 0 ? void 0 : _c.reject) === null || _d === void 0 ? void 0 : _d.call(_c, 'Agent disconnected');\r\n    }\r\n    this.activeAgentFuture = undefined;\r\n  }\r\n  waitUntilActiveAgentPresent() {\r\n    if (this.firstActiveAgent) {\r\n      return Promise.resolve(this.firstActiveAgent);\r\n    }\r\n    if (!this.activeAgentFuture) {\r\n      this.activeAgentFuture = new Future();\r\n    }\r\n    return this.activeAgentFuture.promise;\r\n  }\r\n  getPublicationForTrack(track) {\r\n    let publication;\r\n    this.trackPublications.forEach(pub => {\r\n      const localTrack = pub.track;\r\n      if (!localTrack) {\r\n        return;\r\n      }\r\n      // this looks overly complicated due to this object tree\r\n      if (track instanceof MediaStreamTrack) {\r\n        if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\r\n          if (localTrack.mediaStreamTrack === track) {\r\n            publication = pub;\r\n          }\r\n        }\r\n      } else if (track === localTrack) {\r\n        publication = pub;\r\n      }\r\n    });\r\n    return publication;\r\n  }\r\n  waitForPendingPublicationOfSource(source) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const waitForPendingTimeout = 10000;\r\n      const startTime = Date.now();\r\n      while (Date.now() < startTime + waitForPendingTimeout) {\r\n        const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(_ref4 => {\r\n          let [pendingTrack] = _ref4;\r\n          return pendingTrack.source === source;\r\n        });\r\n        if (publishPromiseEntry) {\r\n          return publishPromiseEntry[1];\r\n        }\r\n        yield sleep(20);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass RemoteTrackPublication extends TrackPublication {\r\n  constructor(kind, ti, autoSubscribe, loggerOptions) {\r\n    super(kind, ti.sid, ti.name, loggerOptions);\r\n    this.track = undefined;\r\n    /** @internal */\r\n    this.allowed = true;\r\n    this.disabled = false;\r\n    this.currentVideoQuality = VideoQuality.HIGH;\r\n    this.handleEnded = track => {\r\n      this.setTrack(undefined);\r\n      this.emit(TrackEvent.Ended, track);\r\n    };\r\n    this.handleVisibilityChange = visible => {\r\n      this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\r\n      this.disabled = !visible;\r\n      this.emitTrackUpdate();\r\n    };\r\n    this.handleVideoDimensionsChange = dimensions => {\r\n      this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\r\n      this.videoDimensions = dimensions;\r\n      this.emitTrackUpdate();\r\n    };\r\n    this.subscribed = autoSubscribe;\r\n    this.updateInfo(ti);\r\n  }\r\n  /**\r\n   * Subscribe or unsubscribe to this remote track\r\n   * @param subscribed true to subscribe to a track, false to unsubscribe\r\n   */\r\n  setSubscribed(subscribed) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    this.subscribed = subscribed;\r\n    // reset allowed status when desired subscription state changes\r\n    // server will notify client via signal message if it's not allowed\r\n    if (subscribed) {\r\n      this.allowed = true;\r\n    }\r\n    const sub = new UpdateSubscription({\r\n      trackSids: [this.trackSid],\r\n      subscribe: this.subscribed,\r\n      participantTracks: [new ParticipantTracks({\r\n        // sending an empty participant id since TrackPublication doesn't keep it\r\n        // this is filled in by the participant that receives this message\r\n        participantSid: '',\r\n        trackSids: [this.trackSid]\r\n      })]\r\n    });\r\n    this.emit(TrackEvent.UpdateSubscription, sub);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n  }\r\n  get subscriptionStatus() {\r\n    if (this.subscribed === false) {\r\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\r\n    }\r\n    if (!super.isSubscribed) {\r\n      return TrackPublication.SubscriptionStatus.Desired;\r\n    }\r\n    return TrackPublication.SubscriptionStatus.Subscribed;\r\n  }\r\n  get permissionStatus() {\r\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\r\n  }\r\n  /**\r\n   * Returns true if track is subscribed, and ready for playback\r\n   */\r\n  get isSubscribed() {\r\n    if (this.subscribed === false) {\r\n      return false;\r\n    }\r\n    return super.isSubscribed;\r\n  }\r\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\r\n  get isDesired() {\r\n    return this.subscribed !== false;\r\n  }\r\n  get isEnabled() {\r\n    return !this.disabled;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /**\r\n   * disable server from sending down data for this track. this is useful when\r\n   * the participant is off screen, you may disable streaming down their video\r\n   * to reduce bandwidth requirements\r\n   * @param enabled\r\n   */\r\n  setEnabled(enabled) {\r\n    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\r\n      return;\r\n    }\r\n    this.disabled = !enabled;\r\n    this.emitTrackUpdate();\r\n  }\r\n  /**\r\n   * for tracks that support simulcasting, adjust subscribed quality\r\n   *\r\n   * This indicates the highest quality the client can accept. if network\r\n   * bandwidth does not allow, server will automatically reduce quality to\r\n   * optimize for uninterrupted video\r\n   */\r\n  setVideoQuality(quality) {\r\n    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\r\n      return;\r\n    }\r\n    this.currentVideoQuality = quality;\r\n    this.videoDimensions = undefined;\r\n    this.emitTrackUpdate();\r\n  }\r\n  setVideoDimensions(dimensions) {\r\n    var _a, _b;\r\n    if (!this.isManualOperationAllowed()) {\r\n      return;\r\n    }\r\n    if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\r\n      return;\r\n    }\r\n    if (isRemoteVideoTrack(this.track)) {\r\n      this.videoDimensions = dimensions;\r\n    }\r\n    this.currentVideoQuality = undefined;\r\n    this.emitTrackUpdate();\r\n  }\r\n  setVideoFPS(fps) {\r\n    if (!this.isManualOperationAllowed()) {\r\n      return;\r\n    }\r\n    if (!isRemoteVideoTrack(this.track)) {\r\n      return;\r\n    }\r\n    if (this.fps === fps) {\r\n      return;\r\n    }\r\n    this.fps = fps;\r\n    this.emitTrackUpdate();\r\n  }\r\n  get videoQuality() {\r\n    return this.currentVideoQuality;\r\n  }\r\n  /** @internal */\r\n  setTrack(track) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    const prevTrack = this.track;\r\n    if (prevTrack === track) {\r\n      return;\r\n    }\r\n    if (prevTrack) {\r\n      // unregister listener\r\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\r\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\r\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\r\n      prevTrack.detach();\r\n      prevTrack.stopMonitor();\r\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\r\n    }\r\n    super.setTrack(track);\r\n    if (track) {\r\n      track.sid = this.trackSid;\r\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\r\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\r\n      track.on(TrackEvent.Ended, this.handleEnded);\r\n      this.emit(TrackEvent.Subscribed, track);\r\n    }\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n  }\r\n  /** @internal */\r\n  setAllowed(allowed) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    this.allowed = allowed;\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n  }\r\n  /** @internal */\r\n  setSubscriptionError(error) {\r\n    this.emit(TrackEvent.SubscriptionFailed, error);\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    super.updateInfo(info);\r\n    const prevMetadataMuted = this.metadataMuted;\r\n    this.metadataMuted = info.muted;\r\n    if (this.track) {\r\n      this.track.setMuted(info.muted);\r\n    } else if (prevMetadataMuted !== info.muted) {\r\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\r\n    }\r\n  }\r\n  emitSubscriptionUpdateIfChanged(previousStatus) {\r\n    const currentStatus = this.subscriptionStatus;\r\n    if (previousStatus === currentStatus) {\r\n      return;\r\n    }\r\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\r\n  }\r\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\r\n    const currentPermissionStatus = this.permissionStatus;\r\n    if (currentPermissionStatus !== previousPermissionStatus) {\r\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\r\n    }\r\n  }\r\n  isManualOperationAllowed() {\r\n    if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\r\n      this.log.warn('adaptive stream is enabled, cannot change video track settings', this.logContext);\r\n      return false;\r\n    }\r\n    if (!this.isDesired) {\r\n      this.log.warn('cannot update track settings when not subscribed', this.logContext);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  get isAdaptiveStream() {\r\n    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\r\n  }\r\n  /* @internal */\r\n  emitTrackUpdate() {\r\n    const settings = new UpdateTrackSettings({\r\n      trackSids: [this.trackSid],\r\n      disabled: this.disabled,\r\n      fps: this.fps\r\n    });\r\n    if (this.videoDimensions) {\r\n      settings.width = Math.ceil(this.videoDimensions.width);\r\n      settings.height = Math.ceil(this.videoDimensions.height);\r\n    } else if (this.currentVideoQuality !== undefined) {\r\n      settings.quality = this.currentVideoQuality;\r\n    } else {\r\n      // defaults to high quality\r\n      settings.quality = VideoQuality.HIGH;\r\n    }\r\n    this.emit(TrackEvent.UpdateSettings, settings);\r\n  }\r\n}\r\n\r\nclass RemoteParticipant extends Participant {\r\n  /** @internal */\r\n  static fromParticipantInfo(signalClient, pi, loggerOptions) {\r\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\r\n  }\r\n  get logContext() {\r\n    return Object.assign(Object.assign({}, super.logContext), {\r\n      rpID: this.sid,\r\n      remoteParticipant: this.identity\r\n    });\r\n  }\r\n  /** @internal */\r\n  constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {\r\n    let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\r\n    super(sid, identity || '', name, metadata, attributes, loggerOptions, kind);\r\n    this.signalClient = signalClient;\r\n    this.trackPublications = new Map();\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.volumeMap = new Map();\r\n  }\r\n  addTrackPublication(publication) {\r\n    super.addTrackPublication(publication);\r\n    // register action events\r\n    publication.on(TrackEvent.UpdateSettings, settings => {\r\n      this.log.debug('send update settings', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n      this.signalClient.sendUpdateTrackSettings(settings);\r\n    });\r\n    publication.on(TrackEvent.UpdateSubscription, sub => {\r\n      sub.participantTracks.forEach(pt => {\r\n        pt.participantSid = this.sid;\r\n      });\r\n      this.signalClient.sendUpdateSubscription(sub);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionPermissionChanged, status => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionStatusChanged, status => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\r\n    });\r\n    publication.on(TrackEvent.Subscribed, track => {\r\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\r\n    });\r\n    publication.on(TrackEvent.Unsubscribed, previousTrack => {\r\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionFailed, error => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\r\n    });\r\n  }\r\n  getTrackPublication(source) {\r\n    const track = super.getTrackPublication(source);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  getTrackPublicationByName(name) {\r\n    const track = super.getTrackPublicationByName(name);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  /**\r\n   * sets the volume on the participant's audio track\r\n   * by default, this affects the microphone publication\r\n   * a different source can be passed in as a second argument\r\n   * if no track exists the volume will be applied when the microphone track is added\r\n   */\r\n  setVolume(volume) {\r\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\r\n    this.volumeMap.set(source, volume);\r\n    const audioPublication = this.getTrackPublication(source);\r\n    if (audioPublication && audioPublication.track) {\r\n      audioPublication.track.setVolume(volume);\r\n    }\r\n  }\r\n  /**\r\n   * gets the volume on the participant's microphone track\r\n   */\r\n  getVolume() {\r\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\r\n    const audioPublication = this.getTrackPublication(source);\r\n    if (audioPublication && audioPublication.track) {\r\n      return audioPublication.track.getVolume();\r\n    }\r\n    return this.volumeMap.get(source);\r\n  }\r\n  /** @internal */\r\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\r\n    // find the track publication\r\n    // it's possible for the media track to arrive before participant info\r\n    let publication = this.getTrackPublicationBySid(sid);\r\n    // it's also possible that the browser didn't honor our original track id\r\n    // FireFox would use its own local uuid instead of server track id\r\n    if (!publication) {\r\n      if (!sid.startsWith('TR')) {\r\n        // find the first track that matches type\r\n        this.trackPublications.forEach(p => {\r\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\r\n            publication = p;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    // when we couldn't locate the track, it's possible that the metadata hasn't\r\n    // yet arrived. Wait a bit longer for it to arrive, or fire an error\r\n    if (!publication) {\r\n      if (triesLeft === 0) {\r\n        this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: sid\r\n        }));\r\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\r\n        return;\r\n      }\r\n      if (triesLeft === undefined) triesLeft = 20;\r\n      setTimeout(() => {\r\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\r\n      }, 150);\r\n      return;\r\n    }\r\n    if (mediaTrack.readyState === 'ended') {\r\n      this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\r\n      return;\r\n    }\r\n    const isVideo = mediaTrack.kind === 'video';\r\n    let track;\r\n    if (isVideo) {\r\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\r\n    } else {\r\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\r\n    }\r\n    // set track info\r\n    track.source = publication.source;\r\n    // keep publication's muted status\r\n    track.isMuted = publication.isMuted;\r\n    track.setMediaStream(mediaStream);\r\n    track.start();\r\n    publication.setTrack(track);\r\n    // set participant volumes on new audio tracks\r\n    if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\r\n      track.setVolume(this.volumeMap.get(publication.source));\r\n    }\r\n    return publication;\r\n  }\r\n  /** @internal */\r\n  get hasMetadata() {\r\n    return !!this.participantInfo;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  getTrackPublicationBySid(sid) {\r\n    return this.trackPublications.get(sid);\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    if (!super.updateInfo(info)) {\r\n      return false;\r\n    }\r\n    // we are getting a list of all available tracks, reconcile in here\r\n    // and send out events for changes\r\n    // reconcile track publications, publish events only if metadata is already there\r\n    // i.e. changes since the local participant has joined\r\n    const validTracks = new Map();\r\n    const newTracks = new Map();\r\n    info.tracks.forEach(ti => {\r\n      var _a, _b;\r\n      let publication = this.getTrackPublicationBySid(ti.sid);\r\n      if (!publication) {\r\n        // new publication\r\n        const kind = Track.kindFromProto(ti.type);\r\n        if (!kind) {\r\n          return;\r\n        }\r\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\r\n          loggerContextCb: () => this.logContext,\r\n          loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\r\n        });\r\n        publication.updateInfo(ti);\r\n        newTracks.set(ti.sid, publication);\r\n        const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\r\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\r\n          this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\r\n            oldTrack: getLogContextFromTrack(existingTrackOfSource),\r\n            newTrack: getLogContextFromTrack(publication)\r\n          }));\r\n        }\r\n        this.addTrackPublication(publication);\r\n      } else {\r\n        publication.updateInfo(ti);\r\n      }\r\n      validTracks.set(ti.sid, publication);\r\n    });\r\n    // detect removed tracks\r\n    this.trackPublications.forEach(publication => {\r\n      if (!validTracks.has(publication.trackSid)) {\r\n        this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n        this.unpublishTrack(publication.trackSid, true);\r\n      }\r\n    });\r\n    // always emit events for new publications, Room will not forward them unless it's ready\r\n    newTracks.forEach(publication => {\r\n      this.emit(ParticipantEvent.TrackPublished, publication);\r\n    });\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  unpublishTrack(sid, sendUnpublish) {\r\n    const publication = this.trackPublications.get(sid);\r\n    if (!publication) {\r\n      return;\r\n    }\r\n    // also send unsubscribe, if track is actively subscribed\r\n    const {\r\n      track\r\n    } = publication;\r\n    if (track) {\r\n      track.stop();\r\n      publication.setTrack(undefined);\r\n    }\r\n    // remove track from maps only after unsubscribed has been fired\r\n    this.trackPublications.delete(sid);\r\n    // remove from the right type map\r\n    switch (publication.kind) {\r\n      case Track.Kind.Audio:\r\n        this.audioTrackPublications.delete(sid);\r\n        break;\r\n      case Track.Kind.Video:\r\n        this.videoTrackPublications.delete(sid);\r\n        break;\r\n    }\r\n    if (sendUnpublish) {\r\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setAudioOutput(output) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.audioOutput = output;\r\n      const promises = [];\r\n      this.audioTrackPublications.forEach(pub => {\r\n        var _a;\r\n        if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\r\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\r\n        }\r\n      });\r\n      yield Promise.all(promises);\r\n    });\r\n  }\r\n  /** @internal */\r\n  emit(event) {\r\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      args[_key - 1] = arguments[_key];\r\n    }\r\n    this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\r\n      event,\r\n      args\r\n    }));\r\n    return super.emit(event, ...args);\r\n  }\r\n}\r\n\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n  ConnectionState[\"Disconnected\"] = \"disconnected\";\r\n  ConnectionState[\"Connecting\"] = \"connecting\";\r\n  ConnectionState[\"Connected\"] = \"connected\";\r\n  ConnectionState[\"Reconnecting\"] = \"reconnecting\";\r\n  ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nconst connectionReconcileFrequency = 4 * 1000;\r\n/**\r\n * In LiveKit, a room is the logical grouping for a list of participants.\r\n * Participants in a room can publish tracks, and subscribe to others' tracks.\r\n *\r\n * a Room fires [[RoomEvent | RoomEvents]].\r\n *\r\n * @noInheritDoc\r\n */\r\nclass Room extends eventsExports.EventEmitter {\r\n  /**\r\n   * Creates a new Room, the primary construct for a LiveKit session.\r\n   * @param options\r\n   */\r\n  constructor(options) {\r\n    var _this;\r\n    var _a, _b, _c;\r\n    super();\r\n    _this = this;\r\n    this.state = ConnectionState.Disconnected;\r\n    /**\r\n     * list of participants that are actively speaking. when this changes\r\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\r\n     */\r\n    this.activeSpeakers = [];\r\n    /** reflects the sender encryption status of the local participant */\r\n    this.isE2EEEnabled = false;\r\n    this.audioEnabled = true;\r\n    this.isVideoPlaybackBlocked = false;\r\n    this.log = livekitLogger;\r\n    this.bufferedEvents = [];\r\n    this.isResuming = false;\r\n    this.byteStreamControllers = new Map();\r\n    this.textStreamControllers = new Map();\r\n    this.byteStreamHandlers = new Map();\r\n    this.textStreamHandlers = new Map();\r\n    this.rpcHandlers = new Map();\r\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!isBrowserSupported()) {\r\n        if (isReactNative()) {\r\n          throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\r\n        } else {\r\n          throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\r\n        }\r\n      }\r\n      // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\r\n      const unlockDisconnect = yield this.disconnectLock.lock();\r\n      if (this.state === ConnectionState.Connected) {\r\n        // when the state is reconnecting or connected, this function returns immediately\r\n        this.log.info(\"already connected to room \".concat(this.name), this.logContext);\r\n        unlockDisconnect();\r\n        return Promise.resolve();\r\n      }\r\n      if (this.connectFuture) {\r\n        unlockDisconnect();\r\n        return this.connectFuture.promise;\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\r\n      if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\r\n        this.regionUrl = undefined;\r\n        this.regionUrlProvider = undefined;\r\n      }\r\n      if (isCloud(new URL(url))) {\r\n        if (this.regionUrlProvider === undefined) {\r\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\r\n        } else {\r\n          this.regionUrlProvider.updateToken(token);\r\n        }\r\n        // trigger the first fetch without waiting for a response\r\n        // if initial connection fails, this will speed up picking regional url\r\n        // on subsequent runs\r\n        this.regionUrlProvider.fetchRegionSettings().then(settings => {\r\n          var _a;\r\n          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\r\n        }).catch(e => {\r\n          this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        });\r\n      }\r\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\r\n        var _a, _b;\r\n        if (this.abortController) {\r\n          this.abortController.abort();\r\n        }\r\n        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\r\n        const abortController = new AbortController();\r\n        this.abortController = abortController;\r\n        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\r\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\r\n        try {\r\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\r\n          this.abortController = undefined;\r\n          resolve();\r\n        } catch (e) {\r\n          if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {\r\n            let nextUrl = null;\r\n            try {\r\n              nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\r\n            } catch (error) {\r\n              if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {\r\n                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\r\n                reject(error);\r\n                return;\r\n              }\r\n            }\r\n            if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\r\n              this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\r\n              this.recreateEngine();\r\n              yield connectFn(resolve, reject, nextUrl);\r\n            } else {\r\n              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));\r\n              reject(e);\r\n            }\r\n          } else {\r\n            let disconnectReason = DisconnectReason.UNKNOWN_REASON;\r\n            if (e instanceof ConnectionError) {\r\n              disconnectReason = getDisconnectReasonFromConnectionError(e);\r\n            }\r\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\r\n            reject(e);\r\n          }\r\n        }\r\n      });\r\n      const regionUrl = this.regionUrl;\r\n      this.regionUrl = undefined;\r\n      this.connectFuture = new Future((resolve, reject) => {\r\n        connectFn(resolve, reject, regionUrl);\r\n      }, () => {\r\n        this.clearConnectionFutures();\r\n      });\r\n      return this.connectFuture.promise;\r\n    });\r\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      const joinResponse = yield engine.join(url, token, {\r\n        autoSubscribe: connectOptions.autoSubscribe,\r\n        adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\r\n        maxRetries: connectOptions.maxRetries,\r\n        e2eeEnabled: !!this.e2eeManager,\r\n        websocketTimeout: connectOptions.websocketTimeout\r\n      }, abortController.signal);\r\n      let serverInfo = joinResponse.serverInfo;\r\n      if (!serverInfo) {\r\n        serverInfo = {\r\n          version: joinResponse.serverVersion,\r\n          region: joinResponse.serverRegion\r\n        };\r\n      }\r\n      this.serverInfo = serverInfo;\r\n      this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map(_ref => {\r\n        let [key, value] = _ref;\r\n        return \"\".concat(key, \": \").concat(value);\r\n      }).join(', ')), {\r\n        room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\r\n        roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\r\n        identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\r\n      });\r\n      if (!serverInfo.version) {\r\n        throw new UnsupportedServer('unknown server version');\r\n      }\r\n      if (serverInfo.version === '0.15.1' && this.options.dynacast) {\r\n        this.log.debug('disabling dynacast due to server version', this.logContext);\r\n        // dynacast has a bug in 0.15.1, so we cannot use it then\r\n        roomOptions.dynacast = false;\r\n      }\r\n      return joinResponse;\r\n    });\r\n    this.applyJoinResponse = joinResponse => {\r\n      const pi = joinResponse.participant;\r\n      this.localParticipant.sid = pi.sid;\r\n      this.localParticipant.identity = pi.identity;\r\n      this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\r\n      if (this.options.e2ee && this.e2eeManager) {\r\n        try {\r\n          this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\r\n        } catch (e) {\r\n          this.log.error(e instanceof Error ? e.message : 'Could not set SifTrailer', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      // populate remote participants, these should not trigger new events\r\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\r\n      if (joinResponse.room) {\r\n        this.handleRoomUpdate(joinResponse.room);\r\n      }\r\n    };\r\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\r\n        this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\r\n        // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\r\n        this.recreateEngine();\r\n      } else {\r\n        // create engine if previously disconnected\r\n        this.maybeCreateEngine();\r\n      }\r\n      if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\r\n        this.engine.setRegionUrlProvider(this.regionUrlProvider);\r\n      }\r\n      this.acquireAudioContext();\r\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\r\n      if (this.connOptions.rtcConfig) {\r\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\r\n      }\r\n      if (this.connOptions.peerConnectionTimeout) {\r\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\r\n      }\r\n      try {\r\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\r\n        this.applyJoinResponse(joinResponse);\r\n        // forward metadata changed for the local participant\r\n        this.setupLocalParticipantEvents();\r\n        this.emit(RoomEvent.SignalConnected);\r\n      } catch (err) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        const resultingError = new ConnectionError(\"could not establish signal connection\", ConnectionErrorReason.ServerUnreachable);\r\n        if (err instanceof Error) {\r\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\r\n        }\r\n        if (err instanceof ConnectionError) {\r\n          resultingError.reason = err.reason;\r\n          resultingError.status = err.status;\r\n        }\r\n        this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\r\n          error: err\r\n        }));\r\n        throw resultingError;\r\n      }\r\n      if (abortController.signal.aborted) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\r\n      }\r\n      try {\r\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\r\n      } catch (e) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        throw e;\r\n      }\r\n      // also hook unload event\r\n      if (isWeb() && this.options.disconnectOnPageLeave) {\r\n        // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\r\n        window.addEventListener('pagehide', this.onPageLeave);\r\n        window.addEventListener('beforeunload', this.onPageLeave);\r\n      }\r\n      if (isWeb()) {\r\n        document.addEventListener('freeze', this.onPageLeave);\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      this.emit(RoomEvent.Connected);\r\n      this.registerConnectionReconcile();\r\n    });\r\n    /**\r\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\r\n     */\r\n    this.disconnect = function () {\r\n      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args_1[_key] = arguments[_key];\r\n      }\r\n      return __awaiter(_this, [...args_1], void 0, function () {\r\n        var _this2 = this;\r\n        let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n        return function* () {\r\n          var _a, _b, _c, _d;\r\n          const unlock = yield _this2.disconnectLock.lock();\r\n          try {\r\n            if (_this2.state === ConnectionState.Disconnected) {\r\n              _this2.log.debug('already disconnected', _this2.logContext);\r\n              return;\r\n            }\r\n            _this2.log.info('disconnect from room', Object.assign({}, _this2.logContext));\r\n            if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\r\n              // try aborting pending connection attempt\r\n              _this2.log.warn('abort connection attempt', _this2.logContext);\r\n              (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();\r\n              // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\r\n              (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError('Client initiated disconnect', ConnectionErrorReason.Cancelled));\r\n              _this2.connectFuture = undefined;\r\n            }\r\n            // send leave\r\n            if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {\r\n              yield _this2.engine.client.sendLeave();\r\n            }\r\n            // close engine (also closes client)\r\n            if (_this2.engine) {\r\n              yield _this2.engine.close();\r\n            }\r\n            _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\r\n            /* @ts-ignore */\r\n            _this2.engine = undefined;\r\n          } finally {\r\n            unlock();\r\n          }\r\n        }();\r\n      });\r\n    };\r\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\r\n      this.log.info('Page leave detected, disconnecting', this.logContext);\r\n      yield this.disconnect();\r\n    });\r\n    /**\r\n     * Browsers have different policies regarding audio playback. Most requiring\r\n     * some form of user interaction (click/tap/etc).\r\n     * In those cases, audio will be silent until a click/tap triggering one of the following\r\n     * - `startAudio`\r\n     * - `getUserMedia`\r\n     */\r\n    this.startAudio = () => __awaiter(this, void 0, void 0, function* () {\r\n      const elements = [];\r\n      const browser = getBrowser();\r\n      if (browser && browser.os === 'iOS') {\r\n        /**\r\n         * iOS blocks audio element playback if\r\n         * - user is not publishing audio themselves and\r\n         * - no other audio source is playing\r\n         *\r\n         * as a workaround, we create an audio element with an empty track, so that\r\n         * silent audio is always playing\r\n         */\r\n        const audioId = 'livekit-dummy-audio-el';\r\n        let dummyAudioEl = document.getElementById(audioId);\r\n        if (!dummyAudioEl) {\r\n          dummyAudioEl = document.createElement('audio');\r\n          dummyAudioEl.id = audioId;\r\n          dummyAudioEl.autoplay = true;\r\n          dummyAudioEl.hidden = true;\r\n          const track = getEmptyAudioStreamTrack();\r\n          track.enabled = true;\r\n          const stream = new MediaStream([track]);\r\n          dummyAudioEl.srcObject = stream;\r\n          document.addEventListener('visibilitychange', () => {\r\n            if (!dummyAudioEl) {\r\n              return;\r\n            }\r\n            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\r\n            dummyAudioEl.srcObject = document.hidden ? null : stream;\r\n            if (!document.hidden) {\r\n              this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\r\n              this.startAudio();\r\n            }\r\n          });\r\n          document.body.append(dummyAudioEl);\r\n          this.once(RoomEvent.Disconnected, () => {\r\n            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\r\n            dummyAudioEl = null;\r\n          });\r\n        }\r\n        elements.push(dummyAudioEl);\r\n      }\r\n      this.remoteParticipants.forEach(p => {\r\n        p.audioTrackPublications.forEach(t => {\r\n          if (t.track) {\r\n            t.track.attachedElements.forEach(e => {\r\n              elements.push(e);\r\n            });\r\n          }\r\n        });\r\n      });\r\n      try {\r\n        yield Promise.all([this.acquireAudioContext(), ...elements.map(e => {\r\n          e.muted = false;\r\n          return e.play();\r\n        })]);\r\n        this.handleAudioPlaybackStarted();\r\n      } catch (err) {\r\n        this.handleAudioPlaybackFailed(err);\r\n        throw err;\r\n      }\r\n    });\r\n    this.startVideo = () => __awaiter(this, void 0, void 0, function* () {\r\n      const elements = [];\r\n      for (const p of this.remoteParticipants.values()) {\r\n        p.videoTrackPublications.forEach(tr => {\r\n          var _a;\r\n          (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach(el => {\r\n            if (!elements.includes(el)) {\r\n              elements.push(el);\r\n            }\r\n          });\r\n        });\r\n      }\r\n      yield Promise.all(elements.map(el => el.play())).then(() => {\r\n        this.handleVideoPlaybackStarted();\r\n      }).catch(e => {\r\n        if (e.name === 'NotAllowedError') {\r\n          this.handleVideoPlaybackFailed();\r\n        } else {\r\n          this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\r\n        }\r\n      });\r\n    });\r\n    this.handleRestarting = () => {\r\n      this.clearConnectionReconcile();\r\n      // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\r\n      this.isResuming = false;\r\n      // also unwind existing participants & existing subscriptions\r\n      for (const p of this.remoteParticipants.values()) {\r\n        this.handleParticipantDisconnected(p.identity, p);\r\n      }\r\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\r\n        this.emit(RoomEvent.Reconnecting);\r\n      }\r\n    };\r\n    this.handleSignalRestarted = joinResponse => __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\r\n        region: joinResponse.serverRegion\r\n      }));\r\n      this.bufferedEvents = [];\r\n      this.applyJoinResponse(joinResponse);\r\n      try {\r\n        // unpublish & republish tracks\r\n        yield this.localParticipant.republishAllTracks(undefined, true);\r\n      } catch (error) {\r\n        this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\r\n          error\r\n        }));\r\n      }\r\n      try {\r\n        yield this.engine.waitForRestarted();\r\n        this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\r\n          region: joinResponse.serverRegion\r\n        }));\r\n      } catch (_a) {\r\n        // reconnection failed, handleDisconnect is being invoked already, just return here\r\n        return;\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      this.emit(RoomEvent.Reconnected);\r\n      this.registerConnectionReconcile();\r\n      this.emitBufferedEvents();\r\n    });\r\n    this.handleParticipantUpdates = participantInfos => {\r\n      // handle changes to participant state, and send events\r\n      participantInfos.forEach(info => {\r\n        var _a;\r\n        if (info.identity === this.localParticipant.identity) {\r\n          this.localParticipant.updateInfo(info);\r\n          return;\r\n        }\r\n        // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\r\n        // so we try to map an empty identity to an already known sID manually\r\n        if (info.identity === '') {\r\n          info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : '';\r\n        }\r\n        let remoteParticipant = this.remoteParticipants.get(info.identity);\r\n        // when it's disconnected, send updates\r\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\r\n          this.handleParticipantDisconnected(info.identity, remoteParticipant);\r\n        } else {\r\n          // create participant if doesn't exist\r\n          remoteParticipant = this.getOrCreateParticipant(info.identity, info);\r\n        }\r\n      });\r\n    };\r\n    // updates are sent only when there's a change to speaker ordering\r\n    this.handleActiveSpeakersUpdate = speakers => {\r\n      const activeSpeakers = [];\r\n      const seenSids = {};\r\n      speakers.forEach(speaker => {\r\n        seenSids[speaker.sid] = true;\r\n        if (speaker.sid === this.localParticipant.sid) {\r\n          this.localParticipant.audioLevel = speaker.level;\r\n          this.localParticipant.setIsSpeaking(true);\r\n          activeSpeakers.push(this.localParticipant);\r\n        } else {\r\n          const p = this.getRemoteParticipantBySid(speaker.sid);\r\n          if (p) {\r\n            p.audioLevel = speaker.level;\r\n            p.setIsSpeaking(true);\r\n            activeSpeakers.push(p);\r\n          }\r\n        }\r\n      });\r\n      if (!seenSids[this.localParticipant.sid]) {\r\n        this.localParticipant.audioLevel = 0;\r\n        this.localParticipant.setIsSpeaking(false);\r\n      }\r\n      this.remoteParticipants.forEach(p => {\r\n        if (!seenSids[p.sid]) {\r\n          p.audioLevel = 0;\r\n          p.setIsSpeaking(false);\r\n        }\r\n      });\r\n      this.activeSpeakers = activeSpeakers;\r\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\r\n    };\r\n    // process list of changed speakers\r\n    this.handleSpeakersChanged = speakerUpdates => {\r\n      const lastSpeakers = new Map();\r\n      this.activeSpeakers.forEach(p => {\r\n        const remoteParticipant = this.remoteParticipants.get(p.identity);\r\n        if (remoteParticipant && remoteParticipant.sid !== p.sid) {\r\n          return;\r\n        }\r\n        lastSpeakers.set(p.sid, p);\r\n      });\r\n      speakerUpdates.forEach(speaker => {\r\n        let p = this.getRemoteParticipantBySid(speaker.sid);\r\n        if (speaker.sid === this.localParticipant.sid) {\r\n          p = this.localParticipant;\r\n        }\r\n        if (!p) {\r\n          return;\r\n        }\r\n        p.audioLevel = speaker.level;\r\n        p.setIsSpeaking(speaker.active);\r\n        if (speaker.active) {\r\n          lastSpeakers.set(speaker.sid, p);\r\n        } else {\r\n          lastSpeakers.delete(speaker.sid);\r\n        }\r\n      });\r\n      const activeSpeakers = Array.from(lastSpeakers.values());\r\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\r\n      this.activeSpeakers = activeSpeakers;\r\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\r\n    };\r\n    this.handleStreamStateUpdate = streamStateUpdate => {\r\n      streamStateUpdate.streamStates.forEach(streamState => {\r\n        const participant = this.getRemoteParticipantBySid(streamState.participantSid);\r\n        if (!participant) {\r\n          return;\r\n        }\r\n        const pub = participant.getTrackPublicationBySid(streamState.trackSid);\r\n        if (!pub || !pub.track) {\r\n          return;\r\n        }\r\n        const newStreamState = Track.streamStateFromProto(streamState.state);\r\n        if (newStreamState !== pub.track.streamState) {\r\n          pub.track.streamState = newStreamState;\r\n          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\r\n          this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\r\n        }\r\n      });\r\n    };\r\n    this.handleSubscriptionPermissionUpdate = update => {\r\n      const participant = this.getRemoteParticipantBySid(update.participantSid);\r\n      if (!participant) {\r\n        return;\r\n      }\r\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\r\n      if (!pub) {\r\n        return;\r\n      }\r\n      pub.setAllowed(update.allowed);\r\n    };\r\n    this.handleSubscriptionError = update => {\r\n      const participant = Array.from(this.remoteParticipants.values()).find(p => p.trackPublications.has(update.trackSid));\r\n      if (!participant) {\r\n        return;\r\n      }\r\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\r\n      if (!pub) {\r\n        return;\r\n      }\r\n      pub.setSubscriptionError(update.err);\r\n    };\r\n    this.handleDataPacket = packet => {\r\n      // find the participant\r\n      const participant = this.remoteParticipants.get(packet.participantIdentity);\r\n      if (packet.value.case === 'user') {\r\n        this.handleUserPacket(participant, packet.value.value, packet.kind);\r\n      } else if (packet.value.case === 'transcription') {\r\n        this.handleTranscription(participant, packet.value.value);\r\n      } else if (packet.value.case === 'sipDtmf') {\r\n        this.handleSipDtmf(participant, packet.value.value);\r\n      } else if (packet.value.case === 'chatMessage') {\r\n        this.handleChatMessage(participant, packet.value.value);\r\n      } else if (packet.value.case === 'metrics') {\r\n        this.handleMetrics(packet.value.value, participant);\r\n      } else if (packet.value.case === 'streamHeader') {\r\n        this.handleStreamHeader(packet.value.value, packet.participantIdentity);\r\n      } else if (packet.value.case === 'streamChunk') {\r\n        this.handleStreamChunk(packet.value.value);\r\n      } else if (packet.value.case === 'streamTrailer') {\r\n        this.handleStreamTrailer(packet.value.value);\r\n      } else if (packet.value.case === 'rpcRequest') {\r\n        const rpc = packet.value.value;\r\n        this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\r\n      }\r\n    };\r\n    this.handleUserPacket = (participant, userPacket, kind) => {\r\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\r\n      // also emit on the participant\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\r\n    };\r\n    this.handleSipDtmf = (participant, dtmf) => {\r\n      this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\r\n      // also emit on the participant\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\r\n    };\r\n    this.bufferedSegments = new Map();\r\n    this.handleTranscription = (_remoteParticipant, transcription) => {\r\n      // find the participant\r\n      const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\r\n      const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\r\n      const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\r\n      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\r\n      this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\r\n    };\r\n    this.handleChatMessage = (participant, chatMessage) => {\r\n      const msg = extractChatMessage(chatMessage);\r\n      this.emit(RoomEvent.ChatMessage, msg, participant);\r\n    };\r\n    this.handleMetrics = (metrics, participant) => {\r\n      this.emit(RoomEvent.MetricsReceived, metrics, participant);\r\n    };\r\n    this.handleAudioPlaybackStarted = () => {\r\n      if (this.canPlaybackAudio) {\r\n        return;\r\n      }\r\n      this.audioEnabled = true;\r\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\r\n    };\r\n    this.handleAudioPlaybackFailed = e => {\r\n      this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n      if (!this.canPlaybackAudio) {\r\n        return;\r\n      }\r\n      this.audioEnabled = false;\r\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\r\n    };\r\n    this.handleVideoPlaybackStarted = () => {\r\n      if (this.isVideoPlaybackBlocked) {\r\n        this.isVideoPlaybackBlocked = false;\r\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\r\n      }\r\n    };\r\n    this.handleVideoPlaybackFailed = () => {\r\n      if (!this.isVideoPlaybackBlocked) {\r\n        this.isVideoPlaybackBlocked = true;\r\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\r\n      }\r\n    };\r\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) !== 'iOS') {\r\n        // default devices are non deterministic on iOS, so we don't attempt to select them here\r\n        yield this.selectDefaultDevices();\r\n      }\r\n      this.emit(RoomEvent.MediaDevicesChanged);\r\n    });\r\n    this.handleRoomUpdate = room => {\r\n      const oldRoom = this.roomInfo;\r\n      this.roomInfo = room;\r\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\r\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\r\n      }\r\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\r\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\r\n      }\r\n    };\r\n    this.handleConnectionQualityUpdate = update => {\r\n      update.updates.forEach(info => {\r\n        if (info.participantSid === this.localParticipant.sid) {\r\n          this.localParticipant.setConnectionQuality(info.quality);\r\n          return;\r\n        }\r\n        const participant = this.getRemoteParticipantBySid(info.participantSid);\r\n        if (participant) {\r\n          participant.setConnectionQuality(info.quality);\r\n        }\r\n      });\r\n    };\r\n    this.onLocalParticipantMetadataChanged = metadata => {\r\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\r\n    };\r\n    this.onLocalParticipantNameChanged = name => {\r\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\r\n    };\r\n    this.onLocalAttributesChanged = changedAttributes => {\r\n      this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\r\n    };\r\n    this.onLocalTrackMuted = pub => {\r\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\r\n    };\r\n    this.onLocalTrackUnmuted = pub => {\r\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\r\n    };\r\n    this.onTrackProcessorUpdate = processor => {\r\n      var _a;\r\n      (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\r\n    };\r\n    this.onLocalTrackPublished = pub => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e, _f;\r\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\r\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\r\n      (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\r\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\r\n      if (isLocalAudioTrack(pub.track)) {\r\n        const trackIsSilent = yield pub.track.checkForSilence();\r\n        if (trackIsSilent) {\r\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\r\n        }\r\n      }\r\n      const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\r\n      const deviceKind = sourceToKind(pub.source);\r\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\r\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\r\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\r\n      }\r\n    });\r\n    this.onLocalTrackUnpublished = pub => {\r\n      var _a, _b;\r\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\r\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\r\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\r\n    };\r\n    this.onLocalTrackRestarted = track => __awaiter(this, void 0, void 0, function* () {\r\n      const deviceId = yield track.getDeviceId(false);\r\n      const deviceKind = sourceToKind(track.source);\r\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\r\n        this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\r\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\r\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\r\n      }\r\n    });\r\n    this.onLocalConnectionQualityChanged = quality => {\r\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\r\n    };\r\n    this.onMediaDevicesError = (e, kind) => {\r\n      this.emit(RoomEvent.MediaDevicesError, e, kind);\r\n    };\r\n    this.onLocalParticipantPermissionsChanged = prevPermissions => {\r\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\r\n    };\r\n    this.onLocalChatMessageSent = msg => {\r\n      this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\r\n    };\r\n    this.setMaxListeners(100);\r\n    this.remoteParticipants = new Map();\r\n    this.sidToIdentity = new Map();\r\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\r\n    this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\r\n    this.transcriptionReceivedTimes = new Map();\r\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\r\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\r\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\r\n    this.maybeCreateEngine();\r\n    this.disconnectLock = new _();\r\n    this.localParticipant = new LocalParticipant('', '', this.engine, this.options, this.rpcHandlers);\r\n    if (this.options.videoCaptureDefaults.deviceId) {\r\n      this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\r\n    }\r\n    if (this.options.audioCaptureDefaults.deviceId) {\r\n      this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\r\n    }\r\n    if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\r\n      this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\r\n    }\r\n    if (this.options.e2ee) {\r\n      this.setupE2EE();\r\n    }\r\n    if (isWeb()) {\r\n      const abortController = new AbortController();\r\n      // in order to catch device changes prior to room connection we need to register the event in the constructor\r\n      (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener('devicechange', this.handleDeviceChange, {\r\n        signal: abortController.signal\r\n      });\r\n      if (Room.cleanupRegistry) {\r\n        Room.cleanupRegistry.register(this, () => {\r\n          abortController.abort();\r\n        });\r\n      }\r\n    }\r\n  }\r\n  registerTextStreamHandler(topic, callback) {\r\n    if (this.textStreamHandlers.has(topic)) {\r\n      throw new TypeError(\"A text stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\r\n    }\r\n    this.textStreamHandlers.set(topic, callback);\r\n  }\r\n  unregisterTextStreamHandler(topic) {\r\n    this.textStreamHandlers.delete(topic);\r\n  }\r\n  registerByteStreamHandler(topic, callback) {\r\n    if (this.byteStreamHandlers.has(topic)) {\r\n      throw new TypeError(\"A byte stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\r\n    }\r\n    this.byteStreamHandlers.set(topic, callback);\r\n  }\r\n  unregisterByteStreamHandler(topic) {\r\n    this.byteStreamHandlers.delete(topic);\r\n  }\r\n  /**\r\n   * Establishes the participant as a receiver for calls of the specified RPC method.\r\n   *\r\n   * @param method - The name of the indicated RPC method\r\n   * @param handler - Will be invoked when an RPC request for this method is received\r\n   * @returns A promise that resolves when the method is successfully registered\r\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * room.localParticipant?.registerRpcMethod(\r\n   *   'greet',\r\n   *   async (data: RpcInvocationData) => {\r\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\r\n   *     return `Hello, ${data.callerIdentity}!`;\r\n   *   }\r\n   * );\r\n   * ```\r\n   *\r\n   * The handler should return a Promise that resolves to a string.\r\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\r\n   *\r\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\r\n   * and they will be received on the caller's side with the message intact.\r\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\r\n   */\r\n  registerRpcMethod(method, handler) {\r\n    if (this.rpcHandlers.has(method)) {\r\n      throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\r\n    }\r\n    this.rpcHandlers.set(method, handler);\r\n  }\r\n  /**\r\n   * Unregisters a previously registered RPC method.\r\n   *\r\n   * @param method - The name of the RPC method to unregister\r\n   */\r\n  unregisterRpcMethod(method) {\r\n    this.rpcHandlers.delete(method);\r\n  }\r\n  handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.engine.publishRpcAck(callerIdentity, requestId);\r\n      if (version !== 1) {\r\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_VERSION'));\r\n        return;\r\n      }\r\n      const handler = this.rpcHandlers.get(method);\r\n      if (!handler) {\r\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_METHOD'));\r\n        return;\r\n      }\r\n      let responseError = null;\r\n      let responsePayload = null;\r\n      try {\r\n        const response = yield handler({\r\n          requestId,\r\n          callerIdentity,\r\n          payload,\r\n          responseTimeout\r\n        });\r\n        if (byteLength(response) > MAX_PAYLOAD_BYTES) {\r\n          responseError = RpcError.builtIn('RESPONSE_PAYLOAD_TOO_LARGE');\r\n          console.warn(\"RPC Response payload too large for \".concat(method));\r\n        } else {\r\n          responsePayload = response;\r\n        }\r\n      } catch (error) {\r\n        if (error instanceof RpcError) {\r\n          responseError = error;\r\n        } else {\r\n          console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\r\n          responseError = RpcError.builtIn('APPLICATION_ERROR');\r\n        }\r\n      }\r\n      yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\r\n    });\r\n  }\r\n  /**\r\n   * @experimental\r\n   */\r\n  setE2EEEnabled(enabled) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.e2eeManager) {\r\n        yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);\r\n        if (this.localParticipant.identity !== '') {\r\n          this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\r\n        }\r\n      } else {\r\n        throw Error('e2ee not configured, please set e2ee settings within the room options');\r\n      }\r\n    });\r\n  }\r\n  setupE2EE() {\r\n    var _a;\r\n    if (this.options.e2ee) {\r\n      if ('e2eeManager' in this.options.e2ee) {\r\n        this.e2eeManager = this.options.e2ee.e2eeManager;\r\n      } else {\r\n        this.e2eeManager = new E2EEManager(this.options.e2ee);\r\n      }\r\n      this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {\r\n        if (isLocalParticipant(participant)) {\r\n          this.isE2EEEnabled = enabled;\r\n        }\r\n        this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\r\n      });\r\n      this.e2eeManager.on(EncryptionEvent.EncryptionError, error => this.emit(RoomEvent.EncryptionError, error));\r\n      (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\r\n    }\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return {\r\n      room: this.name,\r\n      roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\r\n      participant: this.localParticipant.identity,\r\n      pID: this.localParticipant.sid\r\n    };\r\n  }\r\n  /**\r\n   * if the current room has a participant with `recorder: true` in its JWT grant\r\n   **/\r\n  get isRecording() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\r\n  }\r\n  /**\r\n   * server assigned unique room id.\r\n   * returns once a sid has been issued by the server.\r\n   */\r\n  getSid() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state === ConnectionState.Disconnected) {\r\n        return '';\r\n      }\r\n      if (this.roomInfo && this.roomInfo.sid !== '') {\r\n        return this.roomInfo.sid;\r\n      }\r\n      return new Promise((resolve, reject) => {\r\n        const handleRoomUpdate = roomInfo => {\r\n          if (roomInfo.sid !== '') {\r\n            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n            resolve(roomInfo.sid);\r\n          }\r\n        };\r\n        this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n        this.once(RoomEvent.Disconnected, () => {\r\n          this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n          reject('Room disconnected before room server id was available');\r\n        });\r\n      });\r\n    });\r\n  }\r\n  /** user assigned name, derived from JWT token */\r\n  get name() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\r\n  }\r\n  /** room metadata */\r\n  get metadata() {\r\n    var _a;\r\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\r\n  }\r\n  get numParticipants() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\r\n  }\r\n  get numPublishers() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\r\n  }\r\n  maybeCreateEngine() {\r\n    if (this.engine && !this.engine.isClosed) {\r\n      return;\r\n    }\r\n    this.engine = new RTCEngine(this.options);\r\n    this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\r\n      this.onTrackAdded(mediaTrack, stream, receiver);\r\n    }).on(EngineEvent.Disconnected, reason => {\r\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\r\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\r\n      this.clearConnectionReconcile();\r\n      this.isResuming = true;\r\n      this.log.info('Resuming signal connection', this.logContext);\r\n      if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\r\n        this.emit(RoomEvent.SignalReconnecting);\r\n      }\r\n    }).on(EngineEvent.Resumed, () => {\r\n      this.registerConnectionReconcile();\r\n      this.isResuming = false;\r\n      this.log.info('Resumed signal connection', this.logContext);\r\n      this.updateSubscriptions();\r\n      this.emitBufferedEvents();\r\n      if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\r\n        this.emit(RoomEvent.Reconnected);\r\n      }\r\n    }).on(EngineEvent.SignalResumed, () => {\r\n      this.bufferedEvents = [];\r\n      if (this.state === ConnectionState.Reconnecting || this.isResuming) {\r\n        this.sendSyncState();\r\n      }\r\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {\r\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\r\n        this.emit(RoomEvent.Reconnecting);\r\n      }\r\n    }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\r\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\r\n    }).on(EngineEvent.LocalTrackSubscribed, subscribedSid => {\r\n      const trackPublication = this.localParticipant.getTrackPublications().find(_ref2 => {\r\n        let {\r\n          trackSid\r\n        } = _ref2;\r\n        return trackSid === subscribedSid;\r\n      });\r\n      if (!trackPublication) {\r\n        this.log.warn('could not find local track subscription for subscribed event', this.logContext);\r\n        return;\r\n      }\r\n      this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\r\n      this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\r\n    }).on(EngineEvent.RoomMoved, roomMoved => {\r\n      this.log.debug('room moved', roomMoved);\r\n      if (roomMoved.room) {\r\n        this.handleRoomUpdate(roomMoved.room);\r\n      }\r\n      this.remoteParticipants.forEach((participant, identity) => {\r\n        this.handleParticipantDisconnected(identity, participant);\r\n      });\r\n      this.emit(RoomEvent.Moved, roomMoved.room.name);\r\n      if (roomMoved.participant) {\r\n        this.handleParticipantUpdates([roomMoved.participant, ...roomMoved.otherParticipants]);\r\n      } else {\r\n        this.handleParticipantUpdates(roomMoved.otherParticipants);\r\n      }\r\n    });\r\n    if (this.localParticipant) {\r\n      this.localParticipant.setupEngine(this.engine);\r\n    }\r\n    if (this.e2eeManager) {\r\n      this.e2eeManager.setupEngine(this.engine);\r\n    }\r\n  }\r\n  /**\r\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\r\n   * In particular, it requests device permissions by default if needed\r\n   * and makes sure the returned device does not consist of dummy devices\r\n   * @param kind\r\n   * @returns a list of available local devices\r\n   */\r\n  static getLocalDevices(kind) {\r\n    let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\r\n  }\r\n  /**\r\n   * prepareConnection should be called as soon as the page is loaded, in order\r\n   * to speed up the connection attempt. This function will\r\n   * - perform DNS resolution and pre-warm the DNS cache\r\n   * - establish TLS connection and cache TLS keys\r\n   *\r\n   * With LiveKit Cloud, it will also determine the best edge data center for\r\n   * the current client to connect to if a token is provided.\r\n   */\r\n  prepareConnection(url, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state !== ConnectionState.Disconnected) {\r\n        return;\r\n      }\r\n      this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\r\n      try {\r\n        if (isCloud(new URL(url)) && token) {\r\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\r\n          const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\r\n          // we will not replace the regionUrl if an attempt had already started\r\n          // to avoid overriding regionUrl after a new connection attempt had started\r\n          if (regionUrl && this.state === ConnectionState.Disconnected) {\r\n            this.regionUrl = regionUrl;\r\n            yield fetch(toHttpUrl(regionUrl), {\r\n              method: 'HEAD'\r\n            });\r\n            this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\r\n          }\r\n        } else {\r\n          yield fetch(toHttpUrl(url), {\r\n            method: 'HEAD'\r\n          });\r\n        }\r\n      } catch (e) {\r\n        this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * retrieves a participant by identity\r\n   * @param identity\r\n   * @returns\r\n   */\r\n  getParticipantByIdentity(identity) {\r\n    if (this.localParticipant.identity === identity) {\r\n      return this.localParticipant;\r\n    }\r\n    return this.remoteParticipants.get(identity);\r\n  }\r\n  clearConnectionFutures() {\r\n    this.connectFuture = undefined;\r\n  }\r\n  /**\r\n   * @internal for testing\r\n   */\r\n  simulateScenario(scenario, arg) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let postAction = () => {};\r\n      let req;\r\n      switch (scenario) {\r\n        case 'signal-reconnect':\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate disconnect');\r\n          break;\r\n        case 'speaker':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'speakerUpdate',\r\n              value: 3\r\n            }\r\n          });\r\n          break;\r\n        case 'node-failure':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'nodeFailure',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'server-leave':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'serverLeave',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'migration':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'migration',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'resume-reconnect':\r\n          this.engine.failNext();\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          break;\r\n        case 'disconnect-signal-on-resume':\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            // @ts-expect-error function is private\r\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          });\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'disconnectSignalOnResume',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'disconnect-signal-on-resume-no-messages':\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            // @ts-expect-error function is private\r\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          });\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'disconnectSignalOnResumeNoMessages',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'full-reconnect':\r\n          this.engine.fullReconnectOnNext = true;\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate full-reconnect');\r\n          break;\r\n        case 'force-tcp':\r\n        case 'force-tls':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'switchCandidateProtocol',\r\n              value: scenario === 'force-tls' ? 2 : 1\r\n            }\r\n          });\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            const onLeave = this.engine.client.onLeave;\r\n            if (onLeave) {\r\n              onLeave(new LeaveRequest({\r\n                reason: DisconnectReason.CLIENT_INITIATED,\r\n                action: LeaveRequest_Action.RECONNECT\r\n              }));\r\n            }\r\n          });\r\n          break;\r\n        case 'subscriber-bandwidth':\r\n          if (arg === undefined || typeof arg !== 'number') {\r\n            throw new Error('subscriber-bandwidth requires a number as argument');\r\n          }\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'subscriberBandwidth',\r\n              value: numberToBigInt(arg)\r\n            }\r\n          });\r\n          break;\r\n        case 'leave-full-reconnect':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'leaveRequestFullReconnect',\r\n              value: true\r\n            }\r\n          });\r\n      }\r\n      if (req) {\r\n        yield this.engine.client.sendSimulateScenario(req);\r\n        yield postAction();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Returns true if audio playback is enabled\r\n   */\r\n  get canPlaybackAudio() {\r\n    return this.audioEnabled;\r\n  }\r\n  /**\r\n   * Returns true if video playback is enabled\r\n   */\r\n  get canPlaybackVideo() {\r\n    return !this.isVideoPlaybackBlocked;\r\n  }\r\n  getActiveDevice(kind) {\r\n    return this.localParticipant.activeDeviceMap.get(kind);\r\n  }\r\n  /**\r\n   * Switches all active devices used in this room to the given device.\r\n   *\r\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\r\n   *\r\n   * @param kind use `videoinput` for camera track,\r\n   *  `audioinput` for microphone track,\r\n   *  `audiooutput` to set speaker for all incoming audio tracks\r\n   * @param deviceId\r\n   */\r\n  switchActiveDevice(kind_1, deviceId_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind, deviceId) {\r\n      var _this3 = this;\r\n      let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      return function* () {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        var _h;\r\n        let success = true;\r\n        let needsUpdateWithoutTracks = false;\r\n        const deviceConstraint = exact ? {\r\n          exact: deviceId\r\n        } : deviceId;\r\n        if (kind === 'audioinput') {\r\n          needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;\r\n          const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\r\n          _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\r\n          const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter(track => track.source === Track.Source.Microphone);\r\n          try {\r\n            success = (yield Promise.all(tracks.map(t => {\r\n              var _a;\r\n              return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\r\n            }))).every(val => val === true);\r\n          } catch (e) {\r\n            _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        } else if (kind === 'videoinput') {\r\n          needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;\r\n          const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\r\n          _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\r\n          const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter(track => track.source === Track.Source.Camera);\r\n          try {\r\n            success = (yield Promise.all(tracks.map(t => {\r\n              var _a;\r\n              return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\r\n            }))).every(val => val === true);\r\n          } catch (e) {\r\n            _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        } else if (kind === 'audiooutput') {\r\n          if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !('setSinkId' in _this3.audioContext)) {\r\n            throw new Error('cannot switch audio output, setSinkId not supported');\r\n          }\r\n          if (_this3.options.webAudioMix) {\r\n            // setting `default` for web audio output doesn't work, so we need to normalize the id before\r\n            deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId('audiooutput', deviceId)) !== null && _c !== void 0 ? _c : '';\r\n          }\r\n          (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};\r\n          const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\r\n          _this3.options.audioOutput.deviceId = deviceId;\r\n          try {\r\n            if (_this3.options.webAudioMix) {\r\n              // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\r\n              (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\r\n            }\r\n            // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\r\n            // see https://issues.chromium.org/issues/40252911#comment7\r\n            yield Promise.all(Array.from(_this3.remoteParticipants.values()).map(p => p.setAudioOutput({\r\n              deviceId\r\n            })));\r\n          } catch (e) {\r\n            _this3.options.audioOutput.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        }\r\n        if (needsUpdateWithoutTracks || kind === 'audiooutput') {\r\n          // if there are not active tracks yet or we're switching audiooutput, we need to manually update the active device map here as changing audio output won't result in a track restart\r\n          _this3.localParticipant.activeDeviceMap.set(kind, kind === 'audiooutput' && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);\r\n          _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\r\n        }\r\n        return success;\r\n      }();\r\n    });\r\n  }\r\n  setupLocalParticipantEvents() {\r\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\r\n  }\r\n  recreateEngine() {\r\n    var _a;\r\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\r\n    /* @ts-ignore */\r\n    this.engine = undefined;\r\n    this.isResuming = false;\r\n    // clear out existing remote participants, since they may have attached\r\n    // the old engine\r\n    this.remoteParticipants.clear();\r\n    this.sidToIdentity.clear();\r\n    this.bufferedEvents = [];\r\n    this.maybeCreateEngine();\r\n  }\r\n  onTrackAdded(mediaTrack, stream, receiver) {\r\n    // don't fire onSubscribed when connecting\r\n    // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\r\n    // at that time, ICE connectivity has not been established so the track is not\r\n    // technically subscribed.\r\n    // We'll defer these events until when the room is connected or eventually disconnected.\r\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\r\n      const reconnectedHandler = () => {\r\n        this.onTrackAdded(mediaTrack, stream, receiver);\r\n        cleanup();\r\n      };\r\n      const cleanup = () => {\r\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\r\n        this.off(RoomEvent.Connected, reconnectedHandler);\r\n        this.off(RoomEvent.Disconnected, cleanup);\r\n      };\r\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\r\n      this.once(RoomEvent.Connected, reconnectedHandler);\r\n      this.once(RoomEvent.Disconnected, cleanup);\r\n      return;\r\n    }\r\n    if (this.state === ConnectionState.Disconnected) {\r\n      this.log.warn('skipping incoming track after Room disconnected', this.logContext);\r\n      return;\r\n    }\r\n    if (mediaTrack.readyState === 'ended') {\r\n      this.log.info('skipping incoming track as it already ended', this.logContext);\r\n      return;\r\n    }\r\n    const parts = unpackStreamId(stream.id);\r\n    const participantSid = parts[0];\r\n    let streamId = parts[1];\r\n    let trackId = mediaTrack.id;\r\n    // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\r\n    // and generates its own track id instead of infer from sdp track id.\r\n    if (streamId && streamId.startsWith('TR')) trackId = streamId;\r\n    if (participantSid === this.localParticipant.sid) {\r\n      this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\r\n      return;\r\n    }\r\n    const participant = Array.from(this.remoteParticipants.values()).find(p => p.sid === participantSid);\r\n    if (!participant) {\r\n      this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\r\n      return;\r\n    }\r\n    let adaptiveStreamSettings;\r\n    if (this.options.adaptiveStream) {\r\n      if (typeof this.options.adaptiveStream === 'object') {\r\n        adaptiveStreamSettings = this.options.adaptiveStream;\r\n      } else {\r\n        adaptiveStreamSettings = {};\r\n      }\r\n    }\r\n    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\r\n  }\r\n  handleDisconnect() {\r\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\r\n    var _a;\r\n    this.clearConnectionReconcile();\r\n    this.isResuming = false;\r\n    this.bufferedEvents = [];\r\n    this.transcriptionReceivedTimes.clear();\r\n    if (this.state === ConnectionState.Disconnected) {\r\n      return;\r\n    }\r\n    this.regionUrl = undefined;\r\n    try {\r\n      this.remoteParticipants.forEach(p => {\r\n        p.trackPublications.forEach(pub => {\r\n          p.unpublishTrack(pub.trackSid);\r\n        });\r\n      });\r\n      this.localParticipant.trackPublications.forEach(pub => {\r\n        var _a, _b, _c;\r\n        if (pub.track) {\r\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\r\n        }\r\n        if (shouldStopTracks) {\r\n          (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\r\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\r\n        } else {\r\n          (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\r\n        }\r\n      });\r\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\r\n      this.localParticipant.trackPublications.clear();\r\n      this.localParticipant.videoTrackPublications.clear();\r\n      this.localParticipant.audioTrackPublications.clear();\r\n      this.remoteParticipants.clear();\r\n      this.sidToIdentity.clear();\r\n      this.activeSpeakers = [];\r\n      if (this.audioContext && typeof this.options.webAudioMix === 'boolean') {\r\n        this.audioContext.close();\r\n        this.audioContext = undefined;\r\n      }\r\n      if (isWeb()) {\r\n        window.removeEventListener('beforeunload', this.onPageLeave);\r\n        window.removeEventListener('pagehide', this.onPageLeave);\r\n        window.removeEventListener('freeze', this.onPageLeave);\r\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\r\n      }\r\n    } finally {\r\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\r\n      this.emit(RoomEvent.Disconnected, reason);\r\n    }\r\n  }\r\n  handleParticipantDisconnected(identity, participant) {\r\n    var _a;\r\n    // remove and send event\r\n    this.remoteParticipants.delete(identity);\r\n    if (!participant) {\r\n      return;\r\n    }\r\n    participant.trackPublications.forEach(publication => {\r\n      participant.unpublishTrack(publication.trackSid, true);\r\n    });\r\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\r\n    participant.setDisconnected();\r\n    (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\r\n  }\r\n  handleStreamHeader(streamHeader, participantIdentity) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (streamHeader.contentHeader.case === 'byteHeader') {\r\n        const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\r\n        if (!streamHandlerCallback) {\r\n          this.log.debug('ignoring incoming byte stream due to no handler for topic', streamHeader.topic);\r\n          return;\r\n        }\r\n        let streamController;\r\n        const info = {\r\n          id: streamHeader.streamId,\r\n          name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : 'unknown',\r\n          mimeType: streamHeader.mimeType,\r\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\r\n          topic: streamHeader.topic,\r\n          timestamp: bigIntToNumber(streamHeader.timestamp),\r\n          attributes: streamHeader.attributes\r\n        };\r\n        const stream = new ReadableStream({\r\n          start: controller => {\r\n            streamController = controller;\r\n            this.byteStreamControllers.set(streamHeader.streamId, {\r\n              info,\r\n              controller: streamController,\r\n              startTime: Date.now()\r\n            });\r\n          }\r\n        });\r\n        streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\r\n          identity: participantIdentity\r\n        });\r\n      } else if (streamHeader.contentHeader.case === 'textHeader') {\r\n        const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\r\n        if (!streamHandlerCallback) {\r\n          this.log.debug('ignoring incoming text stream due to no handler for topic', streamHeader.topic);\r\n          return;\r\n        }\r\n        let streamController;\r\n        const info = {\r\n          id: streamHeader.streamId,\r\n          mimeType: streamHeader.mimeType,\r\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\r\n          topic: streamHeader.topic,\r\n          timestamp: Number(streamHeader.timestamp),\r\n          attributes: streamHeader.attributes\r\n        };\r\n        const stream = new ReadableStream({\r\n          start: controller => {\r\n            streamController = controller;\r\n            this.textStreamControllers.set(streamHeader.streamId, {\r\n              info,\r\n              controller: streamController,\r\n              startTime: Date.now()\r\n            });\r\n          }\r\n        });\r\n        streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\r\n          identity: participantIdentity\r\n        });\r\n      }\r\n    });\r\n  }\r\n  handleStreamChunk(chunk) {\r\n    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\r\n    if (fileBuffer) {\r\n      if (chunk.content.length > 0) {\r\n        fileBuffer.controller.enqueue(chunk);\r\n      }\r\n    }\r\n    const textBuffer = this.textStreamControllers.get(chunk.streamId);\r\n    if (textBuffer) {\r\n      if (chunk.content.length > 0) {\r\n        textBuffer.controller.enqueue(chunk);\r\n      }\r\n    }\r\n  }\r\n  handleStreamTrailer(trailer) {\r\n    const textBuffer = this.textStreamControllers.get(trailer.streamId);\r\n    if (textBuffer) {\r\n      textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\r\n      textBuffer.controller.close();\r\n      this.textStreamControllers.delete(trailer.streamId);\r\n    }\r\n    const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\r\n    if (fileBuffer) {\r\n      {\r\n        fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\r\n        fileBuffer.controller.close();\r\n        this.byteStreamControllers.delete(trailer.streamId);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * attempt to select the default devices if the previously selected devices are no longer available after a device change event\r\n   */\r\n  selectDefaultDevices() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      const previousDevices = DeviceManager.getInstance().previousDevices;\r\n      // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\r\n      const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\r\n      const browser = getBrowser();\r\n      if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && browser.os !== 'iOS') {\r\n        for (let availableDevice of availableDevices) {\r\n          const previousDevice = previousDevices.find(info => info.deviceId === availableDevice.deviceId);\r\n          if (previousDevice && previousDevice.label !== '' && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\r\n            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\r\n            if (this.getActiveDevice(availableDevice.kind) === 'default') {\r\n              // emit an active device change event only if the selected output device is actually on `default`\r\n              this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      const kinds = ['audiooutput', 'audioinput', 'videoinput'];\r\n      for (let kind of kinds) {\r\n        const targetSource = kindToSource(kind);\r\n        const targetPublication = this.localParticipant.getTrackPublication(targetSource);\r\n        if (targetPublication && ((_a = targetPublication.track) === null || _a === void 0 ? void 0 : _a.isUserProvided)) {\r\n          // if the track is user provided, we don't want to switch devices on behalf of the user\r\n          continue;\r\n        }\r\n        const devicesOfKind = availableDevices.filter(d => d.kind === kind);\r\n        const activeDevice = this.getActiveDevice(kind);\r\n        if (activeDevice === ((_b = previousDevices.filter(info => info.kind === kind)[0]) === null || _b === void 0 ? void 0 : _b.deviceId)) {\r\n          // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\r\n          // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\r\n          if (devicesOfKind.length > 0 && ((_c = devicesOfKind[0]) === null || _c === void 0 ? void 0 : _c.deviceId) !== activeDevice) {\r\n            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\r\n            continue;\r\n          }\r\n        }\r\n        if (kind === 'audioinput' && !isSafariBased() || kind === 'videoinput') {\r\n          // airpods on Safari need special handling for audioinput as the track doesn't end as soon as you take them out\r\n          continue;\r\n        }\r\n        // switch to first available device if previously active device is not available any more\r\n        if (devicesOfKind.length > 0 && !devicesOfKind.find(deviceInfo => deviceInfo.deviceId === this.getActiveDevice(kind)) && (\r\n        // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback\r\n        kind !== 'audiooutput' || !isSafariBased())) {\r\n          yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  acquireAudioContext() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (typeof this.options.webAudioMix !== 'boolean' && this.options.webAudioMix.audioContext) {\r\n        // override audio context with custom audio context if supplied by user\r\n        this.audioContext = this.options.webAudioMix.audioContext;\r\n      } else if (!this.audioContext || this.audioContext.state === 'closed') {\r\n        // by using an AudioContext, it reduces lag on audio elements\r\n        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\r\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\r\n      }\r\n      if (this.options.webAudioMix) {\r\n        this.remoteParticipants.forEach(participant => participant.setAudioContext(this.audioContext));\r\n      }\r\n      this.localParticipant.setAudioContext(this.audioContext);\r\n      if (this.audioContext && this.audioContext.state === 'suspended') {\r\n        // for iOS a newly created AudioContext is always in `suspended` state.\r\n        // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\r\n        try {\r\n          yield Promise.race([this.audioContext.resume(), sleep(200)]);\r\n        } catch (e) {\r\n          this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\r\n      if (newContextIsRunning !== this.canPlaybackAudio) {\r\n        this.audioEnabled = newContextIsRunning;\r\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\r\n      }\r\n    });\r\n  }\r\n  createParticipant(identity, info) {\r\n    var _a;\r\n    let participant;\r\n    if (info) {\r\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\r\n        loggerContextCb: () => this.logContext,\r\n        loggerName: this.options.loggerName\r\n      });\r\n    } else {\r\n      participant = new RemoteParticipant(this.engine.client, '', identity, undefined, undefined, undefined, {\r\n        loggerContextCb: () => this.logContext,\r\n        loggerName: this.options.loggerName\r\n      });\r\n    }\r\n    if (this.options.webAudioMix) {\r\n      participant.setAudioContext(this.audioContext);\r\n    }\r\n    if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\r\n      participant.setAudioOutput(this.options.audioOutput).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\r\n    }\r\n    return participant;\r\n  }\r\n  getOrCreateParticipant(identity, info) {\r\n    if (this.remoteParticipants.has(identity)) {\r\n      const existingParticipant = this.remoteParticipants.get(identity);\r\n      if (info) {\r\n        const wasUpdated = existingParticipant.updateInfo(info);\r\n        if (wasUpdated) {\r\n          this.sidToIdentity.set(info.sid, info.identity);\r\n        }\r\n      }\r\n      return existingParticipant;\r\n    }\r\n    const participant = this.createParticipant(identity, info);\r\n    this.remoteParticipants.set(identity, participant);\r\n    this.sidToIdentity.set(info.sid, info.identity);\r\n    // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\r\n    // firing here to make sure that `ParticipantConnected` fires before the initial track events\r\n    this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\r\n    // also forward events\r\n    // trackPublished is only fired for tracks added after both local participant\r\n    // and remote participant joined the room\r\n    participant.on(ParticipantEvent.TrackPublished, trackPublication => {\r\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\r\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\r\n      // monitor playback status\r\n      if (track.kind === Track.Kind.Audio) {\r\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\r\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\r\n      } else if (track.kind === Track.Kind.Video) {\r\n        track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\r\n        track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\r\n      }\r\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\r\n    }).on(ParticipantEvent.TrackUnpublished, publication => {\r\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\r\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\r\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\r\n    }).on(ParticipantEvent.TrackMuted, pub => {\r\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\r\n    }).on(ParticipantEvent.TrackUnmuted, pub => {\r\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\r\n    }).on(ParticipantEvent.ParticipantMetadataChanged, metadata => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\r\n    }).on(ParticipantEvent.ParticipantNameChanged, name => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\r\n    }).on(ParticipantEvent.AttributesChanged, changedAttributes => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\r\n    }).on(ParticipantEvent.ConnectionQualityChanged, quality => {\r\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\r\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\r\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\r\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\r\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {\r\n      this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\r\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\r\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\r\n    }).on(ParticipantEvent.Active, () => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantActive, participant);\r\n      if (participant.kind === ParticipantInfo_Kind.AGENT) {\r\n        this.localParticipant.setActiveAgent(participant);\r\n      }\r\n    });\r\n    // update info at the end after callbacks have been set up\r\n    if (info) {\r\n      participant.updateInfo(info);\r\n    }\r\n    return participant;\r\n  }\r\n  sendSyncState() {\r\n    const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {\r\n      acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\r\n      return acc;\r\n    }, []);\r\n    const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\r\n    this.engine.sendSyncState(remoteTracks, localTracks);\r\n  }\r\n  /**\r\n   * After resuming, we'll need to notify the server of the current\r\n   * subscription settings.\r\n   */\r\n  updateSubscriptions() {\r\n    for (const p of this.remoteParticipants.values()) {\r\n      for (const pub of p.videoTrackPublications.values()) {\r\n        if (pub.isSubscribed && isRemotePub(pub)) {\r\n          pub.emitTrackUpdate();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  getRemoteParticipantBySid(sid) {\r\n    const identity = this.sidToIdentity.get(sid);\r\n    if (identity) {\r\n      return this.remoteParticipants.get(identity);\r\n    }\r\n  }\r\n  registerConnectionReconcile() {\r\n    this.clearConnectionReconcile();\r\n    let consecutiveFailures = 0;\r\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\r\n      if (\r\n      // ensure we didn't tear it down\r\n      !this.engine ||\r\n      // engine detected close, but Room missed it\r\n      this.engine.isClosed ||\r\n      // transports failed without notifying engine\r\n      !this.engine.verifyTransport()) {\r\n        consecutiveFailures++;\r\n        this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\r\n          numFailures: consecutiveFailures,\r\n          engine: this.engine ? {\r\n            closed: this.engine.isClosed,\r\n            transportsConnected: this.engine.verifyTransport()\r\n          } : undefined\r\n        }));\r\n        if (consecutiveFailures >= 3) {\r\n          this.recreateEngine();\r\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\r\n        }\r\n      } else {\r\n        consecutiveFailures = 0;\r\n      }\r\n    }, connectionReconcileFrequency);\r\n  }\r\n  clearConnectionReconcile() {\r\n    if (this.connectionReconcileInterval) {\r\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\r\n    }\r\n  }\r\n  setAndEmitConnectionState(state) {\r\n    if (state === this.state) {\r\n      // unchanged\r\n      return false;\r\n    }\r\n    this.state = state;\r\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\r\n    return true;\r\n  }\r\n  emitBufferedEvents() {\r\n    this.bufferedEvents.forEach(_ref3 => {\r\n      let [ev, args] = _ref3;\r\n      this.emit(ev, ...args);\r\n    });\r\n    this.bufferedEvents = [];\r\n  }\r\n  emitWhenConnected(event) {\r\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n      args[_key2 - 1] = arguments[_key2];\r\n    }\r\n    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\r\n      // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\r\n      this.bufferedEvents.push([event, args]);\r\n    } else if (this.state === ConnectionState.Connected) {\r\n      return this.emit(event, ...args);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Allows to populate a room with simulated participants.\r\n   * No actual connection to a server will be established, all state is\r\n   * @experimental\r\n   */\r\n  simulateParticipants(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const publishOptions = Object.assign({\r\n        audio: true,\r\n        video: true,\r\n        useRealTracks: false\r\n      }, options.publish);\r\n      const participantOptions = Object.assign({\r\n        count: 9,\r\n        audio: false,\r\n        video: true,\r\n        aspectRatios: [1.66, 1.7, 1.3]\r\n      }, options.participants);\r\n      this.handleDisconnect();\r\n      this.roomInfo = new Room$1({\r\n        sid: 'RM_SIMULATED',\r\n        name: 'simulated-room',\r\n        emptyTimeout: 0,\r\n        maxParticipants: 0,\r\n        creationTime: protoInt64.parse(new Date().getTime()),\r\n        metadata: '',\r\n        numParticipants: 1,\r\n        numPublishers: 1,\r\n        turnPassword: '',\r\n        enabledCodecs: [],\r\n        activeRecording: false\r\n      });\r\n      this.localParticipant.updateInfo(new ParticipantInfo({\r\n        identity: 'simulated-local',\r\n        name: 'local-name'\r\n      }));\r\n      this.setupLocalParticipantEvents();\r\n      this.emit(RoomEvent.SignalConnected);\r\n      this.emit(RoomEvent.Connected);\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      if (publishOptions.video) {\r\n        const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\r\n          source: TrackSource.CAMERA,\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          type: TrackType.AUDIO,\r\n          name: 'video-dummy'\r\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\r\n          video: true\r\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        }), {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        // @ts-ignore\r\n        this.localParticipant.addTrackPublication(camPub);\r\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\r\n      }\r\n      if (publishOptions.audio) {\r\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\r\n          source: TrackSource.MICROPHONE,\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          type: TrackType.AUDIO\r\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\r\n          audio: true\r\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        }), {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        // @ts-ignore\r\n        this.localParticipant.addTrackPublication(audioPub);\r\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\r\n      }\r\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\r\n        let info = new ParticipantInfo({\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          identity: \"simulated-\".concat(i),\r\n          state: ParticipantInfo_State.ACTIVE,\r\n          tracks: [],\r\n          joinedAt: protoInt64.parse(Date.now())\r\n        });\r\n        const p = this.getOrCreateParticipant(info.identity, info);\r\n        if (participantOptions.video) {\r\n          const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\r\n          const videoTrack = new TrackInfo({\r\n            source: TrackSource.CAMERA,\r\n            sid: Math.floor(Math.random() * 10000).toString(),\r\n            type: TrackType.AUDIO\r\n          });\r\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());\r\n          info.tracks = [...info.tracks, videoTrack];\r\n        }\r\n        if (participantOptions.audio) {\r\n          const dummyTrack = getEmptyAudioStreamTrack();\r\n          const audioTrack = new TrackInfo({\r\n            source: TrackSource.MICROPHONE,\r\n            sid: Math.floor(Math.random() * 10000).toString(),\r\n            type: TrackType.AUDIO\r\n          });\r\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());\r\n          info.tracks = [...info.tracks, audioTrack];\r\n        }\r\n        p.updateInfo(info);\r\n      }\r\n    });\r\n  }\r\n  // /** @internal */\r\n  emit(event) {\r\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\r\n      args[_key3 - 1] = arguments[_key3];\r\n    }\r\n    // active speaker updates are too spammy\r\n    if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\r\n      // only extract logContext from arguments in order to avoid logging the whole object tree\r\n      const minimizedArgs = mapArgs(args).filter(arg => arg !== undefined);\r\n      this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\r\n        event,\r\n        args: minimizedArgs\r\n      }));\r\n    }\r\n    return super.emit(event, ...args);\r\n  }\r\n}\r\nRoom.cleanupRegistry = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(cleanup => {\r\n  cleanup();\r\n});\r\nfunction mapArgs(args) {\r\n  return args.map(arg => {\r\n    if (!arg) {\r\n      return;\r\n    }\r\n    if (Array.isArray(arg)) {\r\n      return mapArgs(arg);\r\n    }\r\n    if (typeof arg === 'object') {\r\n      return 'logContext' in arg ? arg.logContext : undefined;\r\n    }\r\n    return arg;\r\n  });\r\n}\r\n\r\n// This file was generated from JSON Schema using quicktype, do not modify it directly.\r\n// The code generation lives at https://github.com/livekit/attribute-definitions\r\n//\r\n// To parse this data:\r\n//\r\n//   import { Convert, AgentAttributes, TranscriptionAttributes } from \"./file\";\r\n//\r\n//   const agentAttributes = Convert.toAgentAttributes(json);\r\n//   const transcriptionAttributes = Convert.toTranscriptionAttributes(json);\r\n// Converts JSON strings to/from your types\r\nclass Convert {\r\n  static toAgentAttributes(json) {\r\n    return JSON.parse(json);\r\n  }\r\n  static agentAttributesToJson(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n  static toTranscriptionAttributes(json) {\r\n    return JSON.parse(json);\r\n  }\r\n  static transcriptionAttributesToJson(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n}\r\n\r\nvar attributeTypings = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  Convert: Convert\r\n});\r\n\r\nvar CheckStatus;\r\n(function (CheckStatus) {\r\n  CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\r\n  CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\r\n  CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\r\n  CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\r\n  CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\r\n})(CheckStatus || (CheckStatus = {}));\r\nclass Checker extends eventsExports.EventEmitter {\r\n  constructor(url, token) {\r\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    super();\r\n    this.status = CheckStatus.IDLE;\r\n    this.logs = [];\r\n    this.options = {};\r\n    this.url = url;\r\n    this.token = token;\r\n    this.name = this.constructor.name;\r\n    this.room = new Room(options.roomOptions);\r\n    this.connectOptions = options.connectOptions;\r\n    this.options = options;\r\n  }\r\n  run(onComplete) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.status !== CheckStatus.IDLE) {\r\n        throw Error('check is running already');\r\n      }\r\n      this.setStatus(CheckStatus.RUNNING);\r\n      try {\r\n        yield this.perform();\r\n      } catch (err) {\r\n        if (err instanceof Error) {\r\n          if (this.options.errorsAsWarnings) {\r\n            this.appendWarning(err.message);\r\n          } else {\r\n            this.appendError(err.message);\r\n          }\r\n        }\r\n      }\r\n      yield this.disconnect();\r\n      // sleep for a bit to ensure disconnect\r\n      yield new Promise(resolve => setTimeout(resolve, 500));\r\n      // @ts-ignore\r\n      if (this.status !== CheckStatus.SKIPPED) {\r\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\r\n      }\r\n      if (onComplete) {\r\n        onComplete();\r\n      }\r\n      return this.getInfo();\r\n    });\r\n  }\r\n  isSuccess() {\r\n    return !this.logs.some(l => l.level === 'error');\r\n  }\r\n  connect(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.room.state === ConnectionState.Connected) {\r\n        return this.room;\r\n      }\r\n      if (!url) {\r\n        url = this.url;\r\n      }\r\n      yield this.room.connect(url, this.token, this.connectOptions);\r\n      return this.room;\r\n    });\r\n  }\r\n  disconnect() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\r\n        yield this.room.disconnect();\r\n        // wait for it to go through\r\n        yield new Promise(resolve => setTimeout(resolve, 500));\r\n      }\r\n    });\r\n  }\r\n  skip() {\r\n    this.setStatus(CheckStatus.SKIPPED);\r\n  }\r\n  switchProtocol(protocol) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let hasReconnecting = false;\r\n      let hasReconnected = false;\r\n      this.room.on(RoomEvent.Reconnecting, () => {\r\n        hasReconnecting = true;\r\n      });\r\n      this.room.once(RoomEvent.Reconnected, () => {\r\n        hasReconnected = true;\r\n      });\r\n      this.room.simulateScenario(\"force-\".concat(protocol));\r\n      yield new Promise(resolve => setTimeout(resolve, 1000));\r\n      if (!hasReconnecting) {\r\n        // no need to wait for reconnection\r\n        return;\r\n      }\r\n      // wait for 10 seconds for reconnection\r\n      const timeout = Date.now() + 10000;\r\n      while (Date.now() < timeout) {\r\n        if (hasReconnected) {\r\n          return;\r\n        }\r\n        yield sleep(100);\r\n      }\r\n      throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\r\n    });\r\n  }\r\n  appendMessage(message) {\r\n    this.logs.push({\r\n      level: 'info',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  appendWarning(message) {\r\n    this.logs.push({\r\n      level: 'warning',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  appendError(message) {\r\n    this.logs.push({\r\n      level: 'error',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  setStatus(status) {\r\n    this.status = status;\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  get engine() {\r\n    var _a;\r\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\r\n  }\r\n  getInfo() {\r\n    return {\r\n      logs: this.logs,\r\n      name: this.name,\r\n      status: this.status,\r\n      description: this.description\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Checks for connections quality to closests Cloud regions and determining the best quality\r\n */\r\nclass CloudRegionCheck extends Checker {\r\n  get description() {\r\n    return 'Cloud regions';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const regionProvider = new RegionUrlProvider(this.url, this.token);\r\n      if (!regionProvider.isCloud()) {\r\n        this.skip();\r\n        return;\r\n      }\r\n      const regionStats = [];\r\n      const seenUrls = new Set();\r\n      for (let i = 0; i < 3; i++) {\r\n        const regionUrl = yield regionProvider.getNextBestRegionUrl();\r\n        if (!regionUrl) {\r\n          break;\r\n        }\r\n        if (seenUrls.has(regionUrl)) {\r\n          continue;\r\n        }\r\n        seenUrls.add(regionUrl);\r\n        const stats = yield this.checkCloudRegion(regionUrl);\r\n        this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\r\n        regionStats.push(stats);\r\n      }\r\n      regionStats.sort((a, b) => {\r\n        return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\r\n      });\r\n      const bestRegion = regionStats[0];\r\n      this.bestStats = bestRegion;\r\n      this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\r\n    });\r\n  }\r\n  getInfo() {\r\n    const info = super.getInfo();\r\n    info.data = this.bestStats;\r\n    return info;\r\n  }\r\n  checkCloudRegion(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      yield this.connect(url);\r\n      if (this.options.protocol === 'tcp') {\r\n        yield this.switchProtocol('tcp');\r\n      }\r\n      const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\r\n      if (!region) {\r\n        throw new Error('Region not found');\r\n      }\r\n      const writer = yield this.room.localParticipant.streamText({\r\n        topic: 'test'\r\n      });\r\n      const chunkSize = 1000; // each chunk is about 1000 bytes\r\n      const totalSize = 1000000; // approximately 1MB of data\r\n      const numChunks = totalSize / chunkSize; // will yield 1000 chunks\r\n      const chunkData = 'A'.repeat(chunkSize); // create a string of 1000 'A' characters\r\n      const startTime = Date.now();\r\n      for (let i = 0; i < numChunks; i++) {\r\n        yield writer.write(chunkData);\r\n      }\r\n      yield writer.close();\r\n      const endTime = Date.now();\r\n      const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\r\n      const regionStats = {\r\n        region: region,\r\n        rtt: 10000,\r\n        duration: endTime - startTime\r\n      };\r\n      stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\r\n        if (stat.type === 'candidate-pair' && stat.nominated) {\r\n          regionStats.rtt = stat.currentRoundTripTime * 1000;\r\n        }\r\n      });\r\n      yield this.disconnect();\r\n      return regionStats;\r\n    });\r\n  }\r\n}\r\n\r\nconst TEST_DURATION = 10000;\r\nclass ConnectionProtocolCheck extends Checker {\r\n  get description() {\r\n    return 'Connection via UDP vs TCP';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const udpStats = yield this.checkConnectionProtocol('udp');\r\n      const tcpStats = yield this.checkConnectionProtocol('tcp');\r\n      this.bestStats = udpStats;\r\n      // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\r\n      // 1. the bandwidth limitation is worse on UDP by 500ms\r\n      // 2. the packet loss is higher on UDP by 1%\r\n      if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\r\n        this.appendMessage('best connection quality via tcp');\r\n        this.bestStats = tcpStats;\r\n      } else {\r\n        this.appendMessage('best connection quality via udp');\r\n      }\r\n      const stats = this.bestStats;\r\n      this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\r\n      this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\r\n      this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\r\n      if (stats.packetsLost > 0) {\r\n        this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\r\n      }\r\n      if (stats.qualityLimitationDurations.bandwidth > 1) {\r\n        this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\r\n      }\r\n      if (stats.qualityLimitationDurations.cpu > 0) {\r\n        this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\r\n      }\r\n    });\r\n  }\r\n  getInfo() {\r\n    const info = super.getInfo();\r\n    info.data = this.bestStats;\r\n    return info;\r\n  }\r\n  checkConnectionProtocol(protocol) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.connect();\r\n      if (protocol === 'tcp') {\r\n        yield this.switchProtocol('tcp');\r\n      } else {\r\n        yield this.switchProtocol('udp');\r\n      }\r\n      // create a canvas with animated content\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = 1280;\r\n      canvas.height = 720;\r\n      const ctx = canvas.getContext('2d');\r\n      if (!ctx) {\r\n        throw new Error('Could not get canvas context');\r\n      }\r\n      let hue = 0;\r\n      const animate = () => {\r\n        hue = (hue + 1) % 360;\r\n        ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        requestAnimationFrame(animate);\r\n      };\r\n      animate();\r\n      // create video track from canvas\r\n      const stream = canvas.captureStream(30); // 30fps\r\n      const videoTrack = stream.getVideoTracks()[0];\r\n      // publish to room\r\n      const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\r\n        simulcast: false,\r\n        degradationPreference: 'maintain-resolution',\r\n        videoEncoding: {\r\n          maxBitrate: 2000000\r\n        }\r\n      });\r\n      const track = pub.track;\r\n      const protocolStats = {\r\n        protocol,\r\n        packetsLost: 0,\r\n        packetsSent: 0,\r\n        qualityLimitationDurations: {},\r\n        rttTotal: 0,\r\n        jitterTotal: 0,\r\n        bitrateTotal: 0,\r\n        count: 0\r\n      };\r\n      // gather stats once a second\r\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n        const stats = yield track.getRTCStatsReport();\r\n        stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\r\n          if (stat.type === 'outbound-rtp') {\r\n            protocolStats.packetsSent = stat.packetsSent;\r\n            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\r\n            protocolStats.bitrateTotal += stat.targetBitrate;\r\n            protocolStats.count++;\r\n          } else if (stat.type === 'remote-inbound-rtp') {\r\n            protocolStats.packetsLost = stat.packetsLost;\r\n            protocolStats.rttTotal += stat.roundTripTime;\r\n            protocolStats.jitterTotal += stat.jitter;\r\n          }\r\n        });\r\n      }), 1000);\r\n      // wait a bit to gather stats\r\n      yield new Promise(resolve => setTimeout(resolve, TEST_DURATION));\r\n      clearInterval(interval);\r\n      videoTrack.stop();\r\n      canvas.remove();\r\n      yield this.disconnect();\r\n      return protocolStats;\r\n    });\r\n  }\r\n}\r\n\r\nclass PublishAudioCheck extends Checker {\r\n  get description() {\r\n    return 'Can publish audio';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      const track = yield createLocalAudioTrack();\r\n      const trackIsSilent = yield detectSilence(track, 1000);\r\n      if (trackIsSilent) {\r\n        throw new Error('unable to detect audio from microphone');\r\n      }\r\n      this.appendMessage('detected audio from microphone');\r\n      room.localParticipant.publishTrack(track);\r\n      // wait for a few seconds to publish\r\n      yield new Promise(resolve => setTimeout(resolve, 3000));\r\n      // verify RTC stats that it's publishing\r\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\r\n      if (!stats) {\r\n        throw new Error('Could not get RTCStats');\r\n      }\r\n      let numPackets = 0;\r\n      stats.forEach(stat => {\r\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'audio' || !stat.kind && stat.mediaType === 'audio')) {\r\n          numPackets = stat.packetsSent;\r\n        }\r\n      });\r\n      if (numPackets === 0) {\r\n        throw new Error('Could not determine packets are sent');\r\n      }\r\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\r\n    });\r\n  }\r\n}\r\n\r\nclass PublishVideoCheck extends Checker {\r\n  get description() {\r\n    return 'Can publish video';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      const track = yield createLocalVideoTrack();\r\n      // check if we have video from camera\r\n      yield this.checkForVideo(track.mediaStreamTrack);\r\n      room.localParticipant.publishTrack(track);\r\n      // wait for a few seconds to publish\r\n      yield new Promise(resolve => setTimeout(resolve, 5000));\r\n      // verify RTC stats that it's publishing\r\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\r\n      if (!stats) {\r\n        throw new Error('Could not get RTCStats');\r\n      }\r\n      let numPackets = 0;\r\n      stats.forEach(stat => {\r\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'video' || !stat.kind && stat.mediaType === 'video')) {\r\n          numPackets += stat.packetsSent;\r\n        }\r\n      });\r\n      if (numPackets === 0) {\r\n        throw new Error('Could not determine packets are sent');\r\n      }\r\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\r\n    });\r\n  }\r\n  checkForVideo(track) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const stream = new MediaStream();\r\n      stream.addTrack(track.clone());\r\n      // Create video element to check frames\r\n      const video = document.createElement('video');\r\n      video.srcObject = stream;\r\n      video.muted = true;\r\n      yield new Promise(resolve => {\r\n        video.onplay = () => {\r\n          setTimeout(() => {\r\n            var _a, _b, _c, _d;\r\n            const canvas = document.createElement('canvas');\r\n            const settings = track.getSettings();\r\n            const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\r\n            const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            const ctx = canvas.getContext('2d');\r\n            // Draw video frame to canvas\r\n            ctx.drawImage(video, 0, 0);\r\n            // Get image data and check if all pixels are black\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const data = imageData.data;\r\n            let isAllBlack = true;\r\n            for (let i = 0; i < data.length; i += 4) {\r\n              if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\r\n                isAllBlack = false;\r\n                break;\r\n              }\r\n            }\r\n            if (isAllBlack) {\r\n              this.appendError('camera appears to be producing only black frames');\r\n            } else {\r\n              this.appendMessage('received video frames');\r\n            }\r\n            resolve();\r\n          }, 1000);\r\n        };\r\n        video.play();\r\n      });\r\n      video.remove();\r\n    });\r\n  }\r\n}\r\n\r\nclass ReconnectCheck extends Checker {\r\n  get description() {\r\n    return 'Resuming connection after interruption';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      let reconnectingTriggered = false;\r\n      let reconnected = false;\r\n      let reconnectResolver;\r\n      const reconnectTimeout = new Promise(resolve => {\r\n        setTimeout(resolve, 5000);\r\n        reconnectResolver = resolve;\r\n      });\r\n      const handleReconnecting = () => {\r\n        reconnectingTriggered = true;\r\n      };\r\n      room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {\r\n        reconnected = true;\r\n        reconnectResolver(true);\r\n      });\r\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\r\n      const onClose = room.engine.client.onClose;\r\n      if (onClose) {\r\n        onClose('');\r\n      }\r\n      yield reconnectTimeout;\r\n      if (!reconnectingTriggered) {\r\n        throw new Error('Did not attempt to reconnect');\r\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\r\n        this.appendWarning('reconnection is only possible in Redis-based configurations');\r\n        throw new Error('Not able to reconnect');\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass TURNCheck extends Checker {\r\n  get description() {\r\n    return 'Can connect via TURN';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const signalClient = new SignalClient();\r\n      const joinRes = yield signalClient.join(this.url, this.token, {\r\n        autoSubscribe: true,\r\n        maxRetries: 0,\r\n        e2eeEnabled: false,\r\n        websocketTimeout: 15000\r\n      });\r\n      let hasTLS = false;\r\n      let hasTURN = false;\r\n      let hasSTUN = false;\r\n      for (let iceServer of joinRes.iceServers) {\r\n        for (let url of iceServer.urls) {\r\n          if (url.startsWith('turn:')) {\r\n            hasTURN = true;\r\n            hasSTUN = true;\r\n          } else if (url.startsWith('turns:')) {\r\n            hasTURN = true;\r\n            hasSTUN = true;\r\n            hasTLS = true;\r\n          }\r\n          if (url.startsWith('stun:')) {\r\n            hasSTUN = true;\r\n          }\r\n        }\r\n      }\r\n      if (!hasSTUN) {\r\n        this.appendWarning('No STUN servers configured on server side.');\r\n      } else if (hasTURN && !hasTLS) {\r\n        this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\r\n      }\r\n      yield signalClient.close();\r\n      if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\r\n        yield this.room.connect(this.url, this.token, {\r\n          rtcConfig: {\r\n            iceTransportPolicy: 'relay'\r\n          }\r\n        });\r\n      } else {\r\n        this.appendWarning('No TURN servers configured.');\r\n        this.skip();\r\n        yield new Promise(resolve => setTimeout(resolve, 0));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass WebRTCCheck extends Checker {\r\n  get description() {\r\n    return 'Establishing WebRTC connection';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let hasTcp = false;\r\n      let hasIpv4Udp = false;\r\n      this.room.on(RoomEvent.SignalConnected, () => {\r\n        const prevTrickle = this.room.engine.client.onTrickle;\r\n        this.room.engine.client.onTrickle = (sd, target) => {\r\n          if (sd.candidate) {\r\n            const candidate = new RTCIceCandidate(sd);\r\n            let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\r\n            if (candidate.address) {\r\n              if (isIPPrivate(candidate.address)) {\r\n                str += ' (private)';\r\n              } else {\r\n                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\r\n                  hasTcp = true;\r\n                  str += ' (passive)';\r\n                } else if (candidate.protocol === 'udp') {\r\n                  hasIpv4Udp = true;\r\n                }\r\n              }\r\n            }\r\n            this.appendMessage(str);\r\n          }\r\n          if (prevTrickle) {\r\n            prevTrickle(sd, target);\r\n          }\r\n        };\r\n        if (this.room.engine.pcManager) {\r\n          this.room.engine.pcManager.subscriber.onIceCandidateError = ev => {\r\n            if (ev instanceof RTCPeerConnectionIceErrorEvent) {\r\n              this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\r\n            }\r\n          };\r\n        }\r\n      });\r\n      try {\r\n        yield this.connect();\r\n        livekitLogger.info('now the room is connected');\r\n      } catch (err) {\r\n        this.appendWarning('ports need to be open on firewall in order to connect.');\r\n        throw err;\r\n      }\r\n      if (!hasTcp) {\r\n        this.appendWarning('Server is not configured for ICE/TCP');\r\n      }\r\n      if (!hasIpv4Udp) {\r\n        this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction isIPPrivate(address) {\r\n  const parts = address.split('.');\r\n  if (parts.length === 4) {\r\n    if (parts[0] === '10') {\r\n      return true;\r\n    } else if (parts[0] === '192' && parts[1] === '168') {\r\n      return true;\r\n    } else if (parts[0] === '172') {\r\n      const second = parseInt(parts[1], 10);\r\n      if (second >= 16 && second <= 31) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nclass WebSocketCheck extends Checker {\r\n  get description() {\r\n    return 'Connecting to signal connection via WebSocket';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\r\n        this.appendWarning('Server is insecure, clients may block connections to it');\r\n      }\r\n      let signalClient = new SignalClient();\r\n      const joinRes = yield signalClient.join(this.url, this.token, {\r\n        autoSubscribe: true,\r\n        maxRetries: 0,\r\n        e2eeEnabled: false,\r\n        websocketTimeout: 15000\r\n      });\r\n      this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\r\n      if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\r\n        this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\r\n      }\r\n      yield signalClient.close();\r\n    });\r\n  }\r\n}\r\n\r\nclass ConnectionCheck extends eventsExports.EventEmitter {\r\n  constructor(url, token) {\r\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    super();\r\n    this.options = {};\r\n    this.checkResults = new Map();\r\n    this.url = url;\r\n    this.token = token;\r\n    this.options = options;\r\n  }\r\n  getNextCheckId() {\r\n    const nextId = this.checkResults.size;\r\n    this.checkResults.set(nextId, {\r\n      logs: [],\r\n      status: CheckStatus.IDLE,\r\n      name: '',\r\n      description: ''\r\n    });\r\n    return nextId;\r\n  }\r\n  updateCheck(checkId, info) {\r\n    this.checkResults.set(checkId, info);\r\n    this.emit('checkUpdate', checkId, info);\r\n  }\r\n  isSuccess() {\r\n    return Array.from(this.checkResults.values()).every(r => r.status !== CheckStatus.FAILED);\r\n  }\r\n  getResults() {\r\n    return Array.from(this.checkResults.values());\r\n  }\r\n  createAndRunCheck(check) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const checkId = this.getNextCheckId();\r\n      const test = new check(this.url, this.token, this.options);\r\n      const handleUpdate = info => {\r\n        this.updateCheck(checkId, info);\r\n      };\r\n      test.on('update', handleUpdate);\r\n      const result = yield test.run();\r\n      test.off('update', handleUpdate);\r\n      return result;\r\n    });\r\n  }\r\n  checkWebsocket() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(WebSocketCheck);\r\n    });\r\n  }\r\n  checkWebRTC() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(WebRTCCheck);\r\n    });\r\n  }\r\n  checkTURN() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(TURNCheck);\r\n    });\r\n  }\r\n  checkReconnect() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(ReconnectCheck);\r\n    });\r\n  }\r\n  checkPublishAudio() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(PublishAudioCheck);\r\n    });\r\n  }\r\n  checkPublishVideo() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(PublishVideoCheck);\r\n    });\r\n  }\r\n  checkConnectionProtocol() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\r\n      if (info.data && 'protocol' in info.data) {\r\n        const stats = info.data;\r\n        this.options.protocol = stats.protocol;\r\n      }\r\n      return info;\r\n    });\r\n  }\r\n  checkCloudRegion() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(CloudRegionCheck);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Try to analyze the local track to determine the facing mode of a track.\r\n *\r\n * @remarks\r\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\r\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\r\n * If both methods fail, the default facing mode will be used.\r\n *\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\r\n * @experimental\r\n */\r\nfunction facingModeFromLocalTrack(localTrack) {\r\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  var _a;\r\n  const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\r\n  const trackSettings = track.getSettings();\r\n  let result = {\r\n    facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\r\n    confidence: 'low'\r\n  };\r\n  // 1. Try to get facingMode from track settings.\r\n  if ('facingMode' in trackSettings) {\r\n    const rawFacingMode = trackSettings.facingMode;\r\n    livekitLogger.trace('rawFacingMode', {\r\n      rawFacingMode\r\n    });\r\n    if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\r\n      result = {\r\n        facingMode: rawFacingMode,\r\n        confidence: 'high'\r\n      };\r\n    }\r\n  }\r\n  // 2. If we don't have a high confidence we try to get the facing mode from the device label.\r\n  if (['low', 'medium'].includes(result.confidence)) {\r\n    livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\r\n    const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\r\n    if (labelAnalysisResult !== undefined) {\r\n      result = labelAnalysisResult;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nconst knownDeviceLabels = new Map([['obs virtual camera', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}]]);\r\nconst knownDeviceLabelSections = new Map([['iphone', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}], ['ipad', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}]]);\r\n/**\r\n * Attempt to analyze the device label to determine the facing mode.\r\n *\r\n * @experimental\r\n */\r\nfunction facingModeFromDeviceLabel(deviceLabel) {\r\n  var _a;\r\n  const label = deviceLabel.trim().toLowerCase();\r\n  // Empty string is a valid device label but we can't infer anything from it.\r\n  if (label === '') {\r\n    return undefined;\r\n  }\r\n  // Can we match against widely known device labels.\r\n  if (knownDeviceLabels.has(label)) {\r\n    return knownDeviceLabels.get(label);\r\n  }\r\n  // Can we match against sections of the device label.\r\n  return (_a = Array.from(knownDeviceLabelSections.entries()).find(_ref => {\r\n    let [section] = _ref;\r\n    return label.includes(section);\r\n  })) === null || _a === void 0 ? void 0 : _a[1];\r\n}\r\nfunction isFacingModeValue(item) {\r\n  const allowedValues = ['user', 'environment', 'left', 'right'];\r\n  return item === undefined || allowedValues.includes(item);\r\n}\r\n\r\n\r\n//# sourceMappingURL=livekit-client.esm.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TkFBdU4sT0FBTyx1QkFBdUIsT0FBTyxvQkFBb0IsT0FBTztBQUN2UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUcsU0FBUztBQUNqRSxVQUFVLE1BQU0sNkNBQTZDLE1BQU0sR0FBRyxJQUFJO0FBQzFFLElBQUksS0FBSyxHQUFHLElBQUksT0FBTyxLQUFLO0FBQzVCO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGVBQWUsSUFBSTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csYUFBYTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUNBQXVDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBNkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOERBQThEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRkFBb0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQXdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0IsZUFBZSx1QkFBdUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CLGVBQWUsdUJBQXVCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEVBQTBFO0FBQzFFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDLFVBQVU7QUFDbEQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxlQUFlLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsYUFBYTtBQUM3Qyw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQ0FBb0M7QUFDcEMsd0JBQXdCO0FBQ3hCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCw4Q0FBOEM7QUFDOUM7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOERBQThEO0FBQ2xIO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEhBQThIO0FBQzlIO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixpRkFBaUY7QUFDakY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlGQUF5RjtBQUN6RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUZBQXlGO0FBQ3pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix5Q0FBeUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Rix5Q0FBeUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsK0RBQStEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixnRkFBZ0Y7QUFDaEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEhBQThIO0FBQzlIO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUiwwR0FBMEc7QUFDMUc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0RUFBNEU7QUFDNUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyRkFBMkY7QUFDM0Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlDQUF5QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQseUNBQXlDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtGQUFrRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhFQUE4RTtBQUNqRixDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix3RUFBd0U7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkpBQTZKO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsNEtBQTRLO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUpBQXFKO0FBQ3JKO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0ZBQWtGLCtEQUErRDtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdHQUFnRztBQUNoRyxXQUFXO0FBQ1gsMEdBQTBHO0FBQzFHO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDBJQUEwSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxSEFBcUg7QUFDckg7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUdBQWlHO0FBQ2pHO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtLQUErSztBQUMvSztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixhQUFhO0FBQ3hHO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5RkFBeUY7QUFDekY7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9IQUFvSDtBQUNwSDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZHQUE2RztBQUM3RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0IsSUFBSSxhQUFhO0FBQ3BGLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSLG9GQUFvRjtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3RkFBd0Y7QUFDeEY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQSxLQUFLO0FBQ0wsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQywrQ0FBK0M7QUFDL0MsK0NBQStDO0FBQy9DO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrMUQ7QUFDLzFEIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGxpdmVraXQtY2xpZW50XFxkaXN0XFxsaXZla2l0LWNsaWVudC5lc20ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9tZXJnZU5hbWVzcGFjZXMobiwgbSkge1xyXG4gIG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xyXG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xyXG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xyXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcclxufVxyXG5cclxudmFyIGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbnZhciBoID0gKGksIHMsIHQpID0+IHMgaW4gaSA/IGUoaSwgcywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gIHdyaXRhYmxlOiB0cnVlLFxyXG4gIHZhbHVlOiB0XHJcbn0pIDogaVtzXSA9IHQ7XHJcbnZhciBvID0gKGksIHMsIHQpID0+IGgoaSwgdHlwZW9mIHMgIT0gXCJzeW1ib2xcIiA/IHMgKyBcIlwiIDogcywgdCk7XHJcbmNsYXNzIF8ge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbyh0aGlzLCBcIl9sb2NraW5nXCIpO1xyXG4gICAgbyh0aGlzLCBcIl9sb2Nrc1wiKTtcclxuICAgIHRoaXMuX2xvY2tpbmcgPSBQcm9taXNlLnJlc29sdmUoKSwgdGhpcy5fbG9ja3MgPSAwO1xyXG4gIH1cclxuICBpc0xvY2tlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+IDA7XHJcbiAgfVxyXG4gIGxvY2soKSB7XHJcbiAgICB0aGlzLl9sb2NrcyArPSAxO1xyXG4gICAgbGV0IHM7XHJcbiAgICBjb25zdCB0ID0gbmV3IFByb21pc2UobCA9PiBzID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2xvY2tzIC09IDEsIGwoKTtcclxuICAgICAgfSksXHJcbiAgICAgIGMgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gcyk7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9ja2luZyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiB0KSwgYztcclxuICB9XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBBc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1dGh5IG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gYm9vbGVhblxyXG4gIGlmICghY29uZGl0aW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICB9XHJcbn1cclxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsXHJcbiAgRkxPQVQzMl9NSU4gPSAtMzQwMjgyMzQ2NjM4NTI4ODZlMjIsXHJcbiAgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmYsXHJcbiAgSU5UMzJfTUFYID0gMHg3ZmZmZmZmZixcclxuICBJTlQzMl9NSU4gPSAtMjE0NzQ4MzY0ODtcclxuLyoqXHJcbiAqIEFzc2VydCBhIHZhbGlkIHNpZ25lZCBwcm90b2J1ZiAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydEludDMyKGFyZykge1xyXG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcclxuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBJTlQzMl9NQVggfHwgYXJnIDwgSU5UMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXHJcbn1cclxuLyoqXHJcbiAqIEFzc2VydCBhIHZhbGlkIHVuc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0VUludDMyKGFyZykge1xyXG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XHJcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gVUlOVDMyX01BWCB8fCBhcmcgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xyXG59XHJcbi8qKlxyXG4gKiBBc3NlcnQgYSB2YWxpZCBwcm90b2J1ZiBmbG9hdCB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydEZsb2F0MzIoYXJnKSB7XHJcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgdHlwZW9mIGFyZyk7XHJcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJnKSkgcmV0dXJuO1xyXG4gIGlmIChhcmcgPiBGTE9BVDMyX01BWCB8fCBhcmcgPCBGTE9BVDMyX01JTikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcclxuLyoqXHJcbiAqIEdldCByZWZsZWN0aW9uIGluZm9ybWF0aW9uIGZyb20gYSBnZW5lcmF0ZWQgZW51bS5cclxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcclxuICogZW51bSwgaXQgcmFpc2VzIGFuIGVycm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RW51bVR5cGUoZW51bU9iamVjdCkge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICBjb25zdCB0ID0gZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF07XHJcbiAgYXNzZXJ0KHQsIFwibWlzc2luZyBlbnVtIHR5cGUgb24gZW51bSBvYmplY3RcIik7XHJcbiAgcmV0dXJuIHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cclxufVxyXG4vKipcclxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uIG9uIGEgZ2VuZXJhdGVkIGVudW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgZW51bU9iamVjdFtlbnVtVHlwZVN5bWJvbF0gPSBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcy5tYXAodiA9PiAoe1xyXG4gICAgbm86IHYubm8sXHJcbiAgICBuYW1lOiB2Lm5hbWUsXHJcbiAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub11cclxuICB9KSkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuX29wdCkge1xyXG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcclxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcclxuICAgIC8vIGNvbnN0IHZhbHVlOiBFbnVtVmFsdWVJbmZvID0gey4uLnYsIG9wdGlvbnM6IHYub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0fTtcclxuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xyXG4gICAgbm9ybWFsVmFsdWVzLnB1c2gobik7XHJcbiAgICBuYW1lc1t2YWx1ZS5uYW1lXSA9IG47XHJcbiAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlTmFtZSxcclxuICAgIHZhbHVlczogbm9ybWFsVmFsdWVzLFxyXG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcclxuICAgIC8vIG9wdGlvbnM6IG9wdD8ub3B0aW9ucyA/PyBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgZmluZE5hbWUobmFtZSkge1xyXG4gICAgICByZXR1cm4gbmFtZXNbbmFtZV07XHJcbiAgICB9LFxyXG4gICAgZmluZE51bWJlcihubykge1xyXG4gICAgICByZXR1cm4gbnVtYmVyc1tub107XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IGVudW0gb2JqZWN0IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cclxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUVudW0odHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XHJcbiAgY29uc3QgZW51bU9iamVjdCA9IHt9O1xyXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcclxuICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcclxuICAgIGVudW1PYmplY3Rbbi5ub10gPSBuLmxvY2FsTmFtZTtcclxuICB9XHJcbiAgc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcyk7XHJcbiAgcmV0dXJuIGVudW1PYmplY3Q7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XHJcbiAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7XHJcbiAgICBsb2NhbE5hbWU6IHZhbHVlLm5hbWVcclxuICB9KTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIE1lc3NhZ2UgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgZXZlcnkgbWVzc2FnZSwgZ2VuZXJhdGVkLCBvciBjcmVhdGVkIGF0XHJcbiAqIHJ1bnRpbWUuXHJcbiAqXHJcbiAqIEl0IGlzIF9ub3RfIHNhZmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG1lc3NhZ2UgYXRcclxuICogcnVuIHRpbWUsIHVzZSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKCkuXHJcbiAqL1xyXG5jbGFzcyBNZXNzYWdlIHtcclxuICAvKipcclxuICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXHJcbiAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlzcmVnYXJkcyBleHRlbnNpb25zIGFuZCB1bmtub3duIGZpZWxkcy5cclxuICAgKi9cclxuICBlcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuZXF1YWxzKHRoaXMuZ2V0VHlwZSgpLCB0aGlzLCBvdGhlcik7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGRlZXAgY29weS5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS5ydW50aW1lLnV0aWwuY2xvbmUodGhpcyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGZyb20gYmluYXJ5IGRhdGEsIG1lcmdpbmcgZmllbGRzLlxyXG4gICAqXHJcbiAgICogUmVwZWF0ZWQgZmllbGRzIGFyZSBhcHBlbmRlZC4gTWFwIGVudHJpZXMgYXJlIGFkZGVkLCBvdmVyd3JpdGluZ1xyXG4gICAqIGV4aXN0aW5nIGtleXMuXHJcbiAgICpcclxuICAgKiBJZiBhIG1lc3NhZ2UgZmllbGQgaXMgYWxyZWFkeSBwcmVzZW50LCBpdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxyXG4gICAqIG5ldyBkYXRhLlxyXG4gICAqL1xyXG4gIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcclxuICAgICAgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmJpbixcclxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0aGlzLCBvcHQucmVhZGVyRmFjdG9yeShieXRlcyksIGJ5dGVzLmJ5dGVMZW5ndGgsIG9wdCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHZhbHVlLlxyXG4gICAqL1xyXG4gIGZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxyXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbixcclxuICAgICAgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0eXBlLCBqc29uVmFsdWUsIG9wdCwgdGhpcyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHN0cmluZy5cclxuICAgKi9cclxuICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XHJcbiAgICBsZXQganNvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIFwiLmNvbmNhdCh0aGlzLmdldFR5cGUoKS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZnJvbUpzb24oanNvbiwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBiaW5hcnkgZGF0YS5cclxuICAgKi9cclxuICB0b0JpbmFyeShvcHRpb25zKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXHJcbiAgICAgIGJpbiA9IHR5cGUucnVudGltZS5iaW4sXHJcbiAgICAgIG9wdCA9IGJpbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpLFxyXG4gICAgICB3cml0ZXIgPSBvcHQud3JpdGVyRmFjdG9yeSgpO1xyXG4gICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XHJcbiAgICByZXR1cm4gd3JpdGVyLmZpbmlzaCgpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHZhbHVlLCBhIEphdmFTY3JpcHQgdmFsdWUgdGhhdCBjYW4gYmVcclxuICAgKiBwYXNzZWQgdG8gSlNPTi5zdHJpbmdpZnkoKS5cclxuICAgKi9cclxuICB0b0pzb24ob3B0aW9ucykge1xyXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxyXG4gICAgICBqc29uID0gdHlwZS5ydW50aW1lLmpzb24sXHJcbiAgICAgIG9wdCA9IGpzb24ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cclxuICAgKi9cclxuICB0b0pzb25TdHJpbmcob3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvSnNvbihvcHRpb25zKTtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIGZvciBzZXJpYWxpemF0aW9uIGJlaGF2aW9yLiBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuIGNhbGxpbmdcclxuICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBzZXJpYWxpemUgZ29vZ2xlLnByb3RvYnVmLkFueSB3aXRoIGEgcGFja2VkXHJcbiAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxyXG4gICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXHJcbiAgICogbWVzc2FnZSB0eXBlLiAgQXMgYSByZXN1bHQsIGF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIGEgbWVzc2FnZSB3aXRoIHRoaXNcclxuICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBpcyBwcm90ZWN0ZWQgYmVjYXVzZSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGludm9rZSBpdFxyXG4gICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcclxuICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxyXG4gICAqIHVzZSB0b0pzb24uXHJcbiAgICovXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9Kc29uKHtcclxuICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWVcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXHJcbiAgICogdGhlIHByb3RvYnVmIG1lc3NhZ2UgZGVjbGFyYXRpb24gYW5kIHByb3ZpZGVzIG1ldGFkYXRhIGZvciByZWZsZWN0aW9uLVxyXG4gICAqIGJhc2VkIG9wZXJhdGlvbnMuXHJcbiAgICovXHJcbiAgZ2V0VHlwZSgpIHtcclxuICAgIC8vIEFueSBjbGFzcyB0aGF0IGV4dGVuZHMgTWVzc2FnZSBfbXVzdF8gcHJvdmlkZSBhIGNvbXBsZXRlIHN0YXRpY1xyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgTWVzc2FnZVR5cGUuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXHJcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtZXNzYWdlIHR5cGUgdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWVzc2FnZVR5cGUocnVudGltZSwgdHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IGxvY2FsTmFtZSA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5sb2NhbE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHR5cGVOYW1lLnN1YnN0cmluZyh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcclxuICBjb25zdCB0eXBlID0ge1xyXG4gICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0RmllbGRzKHRoaXMpO1xyXG4gICAgICBydW50aW1lLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfVtsb2NhbE5hbWVdO1xyXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0eXBlLnByb3RvdHlwZSwgbmV3IE1lc3NhZ2UoKSk7XHJcbiAgT2JqZWN0LmFzc2lnbih0eXBlLCB7XHJcbiAgICBydW50aW1lLFxyXG4gICAgdHlwZU5hbWUsXHJcbiAgICBmaWVsZHM6IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoZmllbGRzKSxcclxuICAgIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcclxuICAgIH0sXHJcbiAgICBlcXVhbHMoYSwgYikge1xyXG4gICAgICByZXR1cm4gcnVudGltZS51dGlsLmVxdWFscyh0eXBlLCBhLCBiKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gdHlwZTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vXHJcbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxyXG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXHJcbi8vIG1ldDpcclxuLy9cclxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxyXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXHJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcclxuLy8gZGlzdHJpYnV0aW9uLlxyXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcclxuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cclxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuLy9cclxuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxyXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcclxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxyXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcclxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXHJcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXHJcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbi8vXHJcbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBQcm90b2NvbCBCdWZmZXIgY29tcGlsZXIgaXMgb3duZWQgYnkgdGhlIG93bmVyXHJcbi8vIG9mIHRoZSBpbnB1dCBmaWxlIHVzZWQgd2hlbiBnZW5lcmF0aW5nIGl0LiAgVGhpcyBjb2RlIGlzIG5vdFxyXG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcclxuLy8gc3VwcG9ydCBsaWJyYXJ5IGlzIGl0c2VsZiBjb3ZlcmVkIGJ5IHRoZSBhYm92ZSBsaWNlbnNlLlxyXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItY29uc3QsQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgKi9cclxuLyoqXHJcbiAqIFJlYWQgYSA2NCBiaXQgdmFyaW50IGFzIHR3byBKUyBudW1iZXJzLlxyXG4gKlxyXG4gKiBSZXR1cm5zIHR1cGxlOlxyXG4gKiBbMF06IGxvdyBiaXRzXHJcbiAqIFsxXTogaGlnaCBiaXRzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcclxuICovXHJcbmZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcclxuICBsZXQgbG93Qml0cyA9IDA7XHJcbiAgbGV0IGhpZ2hCaXRzID0gMDtcclxuICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcclxuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgICBsb3dCaXRzIHw9IChiICYgMHg3ZikgPDwgc2hpZnQ7XHJcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XHJcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgbWlkZGxlQnl0ZSA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xyXG4gIC8vIGxhc3QgZm91ciBiaXRzIG9mIHRoZSBmaXJzdCAzMiBiaXQgbnVtYmVyXHJcbiAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xyXG4gIC8vIDMgdXBwZXIgYml0cyBhcmUgcGFydCBvZiB0aGUgbmV4dCAzMiBiaXQgbnVtYmVyXHJcbiAgaGlnaEJpdHMgPSAobWlkZGxlQnl0ZSAmIDB4NzApID4+IDQ7XHJcbiAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xyXG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xyXG4gIH1cclxuICBmb3IgKGxldCBzaGlmdCA9IDM7IHNoaWZ0IDw9IDMxOyBzaGlmdCArPSA3KSB7XHJcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xyXG4gICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcclxuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcclxuICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL3dyaXRlci5qcyNMMzQ0XHJcbiAqL1xyXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI4OyBpID0gaSArIDcpIHtcclxuICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XHJcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xyXG4gICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcclxuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XHJcbiAgICBpZiAoIWhhc05leHQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBzcGxpdEJpdHMgPSBsbyA+Pj4gMjggJiAweDBmIHwgKGhpICYgMHgwNykgPDwgNDtcclxuICBjb25zdCBoYXNNb3JlQml0cyA9ICEoaGkgPj4gMyA9PSAwKTtcclxuICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XHJcbiAgaWYgKCFoYXNNb3JlQml0cykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBmb3IgKGxldCBpID0gMzsgaSA8IDMxOyBpID0gaSArIDcpIHtcclxuICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XHJcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcclxuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XHJcbiAgICBieXRlcy5wdXNoKGJ5dGUpO1xyXG4gICAgaWYgKCFoYXNOZXh0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcbiAgYnl0ZXMucHVzaChoaSA+Pj4gMzEgJiAweDAxKTtcclxufVxyXG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXHJcbmNvbnN0IFRXT19QV1JfMzJfREJMID0gMHgxMDAwMDAwMDA7XHJcbi8qKlxyXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cclxuICpcclxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmLWphdmFzY3JpcHQvYmxvYi9hNDI4YzU4MjczYWJhZDA3YzY2MDcxZDk3NTNiYzRkMTI4OWRlNDI2L2V4cGVyaW1lbnRhbC9ydW50aW1lL2ludDY0LmpzI0wxMFxyXG4gKi9cclxuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xyXG4gIC8vIENoZWNrIGZvciBtaW51cyBzaWduLlxyXG4gIGNvbnN0IG1pbnVzID0gZGVjWzBdID09PSBcIi1cIjtcclxuICBpZiAobWludXMpIHtcclxuICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcclxuICB9XHJcbiAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxyXG4gIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxyXG4gIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxyXG4gIGNvbnN0IGJhc2UgPSAxZTY7XHJcbiAgbGV0IGxvd0JpdHMgPSAwO1xyXG4gIGxldCBoaWdoQml0cyA9IDA7XHJcbiAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xyXG4gICAgLy8gTm90ZTogTnVtYmVyKCcnKSBpcyAwLlxyXG4gICAgY29uc3QgZGlnaXQxZTYgPSBOdW1iZXIoZGVjLnNsaWNlKGJlZ2luLCBlbmQpKTtcclxuICAgIGhpZ2hCaXRzICo9IGJhc2U7XHJcbiAgICBsb3dCaXRzID0gbG93Qml0cyAqIGJhc2UgKyBkaWdpdDFlNjtcclxuICAgIC8vIENhcnJ5IGJpdHMgZnJvbSBsb3dCaXRzIHRvXHJcbiAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xyXG4gICAgICBoaWdoQml0cyA9IGhpZ2hCaXRzICsgKGxvd0JpdHMgLyBUV09fUFdSXzMyX0RCTCB8IDApO1xyXG4gICAgICBsb3dCaXRzID0gbG93Qml0cyAlIFRXT19QV1JfMzJfREJMO1xyXG4gICAgfVxyXG4gIH1cclxuICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XHJcbiAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xyXG4gIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xyXG4gIGFkZDFlNmRpZ2l0KC02KTtcclxuICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XHJcbn1cclxuLyoqXHJcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cclxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xyXG4gIGxldCBiaXRzID0gbmV3Qml0cyhsbywgaGkpO1xyXG4gIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cclxuICAvLyBhIG1hbnVhbCB0d28ncyBjb21wbGVtZW50IGNvbnZlcnNpb24gYmVmb3JlIHRoZSBkZWNpbWFsIGNvbnZlcnNpb24uXHJcbiAgY29uc3QgbmVnYXRpdmUgPSBiaXRzLmhpICYgMHg4MDAwMDAwMDtcclxuICBpZiAobmVnYXRpdmUpIHtcclxuICAgIGJpdHMgPSBuZWdhdGUoYml0cy5sbywgYml0cy5oaSk7XHJcbiAgfVxyXG4gIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xyXG4gIHJldHVybiBuZWdhdGl2ZSA/IFwiLVwiICsgcmVzdWx0IDogcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cclxuICogaW50byBhIGRlY2ltYWwgc3RyaW5nLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXHJcbiAqL1xyXG5mdW5jdGlvbiB1SW50NjRUb1N0cmluZyhsbywgaGkpIHtcclxuICAoe1xyXG4gICAgbG8sXHJcbiAgICBoaVxyXG4gIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xyXG4gIC8vIFNraXAgdGhlIGV4cGVuc2l2ZSBjb252ZXJzaW9uIGlmIHRoZSBudW1iZXIgaXMgc21hbGwgZW5vdWdoIHRvIHVzZSB0aGVcclxuICAvLyBidWlsdC1pbiBjb252ZXJzaW9ucy5cclxuICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXHJcbiAgLy8gaGlnaEJpdHMgPD0gMHgxRkZGRkYgY2FuIGJlIHNhZmVseSBleHByZXNzZWQgd2l0aCBhIGRvdWJsZSBhbmQgcmV0YWluXHJcbiAgLy8gaW50ZWdlciBwcmVjaXNpb24uXHJcbiAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cclxuICBpZiAoaGkgPD0gMHgxRkZGRkYpIHtcclxuICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcclxuICB9XHJcbiAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cclxuICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXHJcbiAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cclxuICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxyXG4gIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxyXG4gIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxyXG4gIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxyXG4gIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXHJcbiAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cclxuICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xyXG4gIGNvbnN0IG1pZCA9IChsbyA+Pj4gMjQgfCBoaSA8PCA4KSAmIDB4RkZGRkZGO1xyXG4gIGNvbnN0IGhpZ2ggPSBoaSA+PiAxNiAmIDB4RkZGRjtcclxuICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxyXG4gIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcclxuICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICBsZXQgZGlnaXRBID0gbG93ICsgbWlkICogNjc3NzIxNiArIGhpZ2ggKiA2NzEwNjU2O1xyXG4gIGxldCBkaWdpdEIgPSBtaWQgKyBoaWdoICogODE0NzQ5NztcclxuICBsZXQgZGlnaXRDID0gaGlnaCAqIDI7XHJcbiAgLy8gQXBwbHkgY2FycmllcyBmcm9tIEEgdG8gQiBhbmQgZnJvbSBCIHRvIEMuXHJcbiAgY29uc3QgYmFzZSA9IDEwMDAwMDAwO1xyXG4gIGlmIChkaWdpdEEgPj0gYmFzZSkge1xyXG4gICAgZGlnaXRCICs9IE1hdGguZmxvb3IoZGlnaXRBIC8gYmFzZSk7XHJcbiAgICBkaWdpdEEgJT0gYmFzZTtcclxuICB9XHJcbiAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XHJcbiAgICBkaWdpdEMgKz0gTWF0aC5mbG9vcihkaWdpdEIgLyBiYXNlKTtcclxuICAgIGRpZ2l0QiAlPSBiYXNlO1xyXG4gIH1cclxuICAvLyBJZiBkaWdpdEMgaXMgMCwgdGhlbiB3ZSBzaG91bGQgaGF2ZSByZXR1cm5lZCBpbiB0aGUgdHJpdmlhbCBjb2RlIHBhdGhcclxuICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxyXG4gIC8vIGFuZCBkaWdpdEEgbmVlZCBsZWFkaW5nIHplcm9zLlxyXG4gIHJldHVybiBkaWdpdEMudG9TdHJpbmcoKSArIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEIpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QSk7XHJcbn1cclxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbG86IGxvID4+PiAwLFxyXG4gICAgaGk6IGhpID4+PiAwXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdCaXRzKGxvLCBoaSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBsbzogbG8gfCAwLFxyXG4gICAgaGk6IGhpIHwgMFxyXG4gIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xyXG4gKi9cclxuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XHJcbiAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XHJcbiAgaWYgKGxvd0JpdHMpIHtcclxuICAgIGxvd0JpdHMgPSB+bG93Qml0cyArIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxyXG4gICAgLy8gYWRkaW5nIDEgdG8gdGhhdCwgcmVzdWx0cyBpbiAweDEwMDAwMDAwMCwgd2hpY2ggbGVhdmVzXHJcbiAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cclxuICAgIGhpZ2hCaXRzICs9IDE7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cclxuICovXHJcbmNvbnN0IGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyA9IGRpZ2l0MWU3ID0+IHtcclxuICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcclxuICByZXR1cm4gXCIwMDAwMDAwXCIuc2xpY2UocGFydGlhbC5sZW5ndGgpICsgcGFydGlhbDtcclxufTtcclxuLyoqXHJcbiAqIFdyaXRlIGEgMzIgYml0IHZhcmludCwgc2lnbmVkIG9yIHVuc2lnbmVkLiBTYW1lIGFzIGB2YXJpbnQ2NHdyaXRlKDAsIHZhbHVlLCBieXRlcylgXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzFiMTg4MzNmNGYyYTJmNjgxZjRlNGEyNWNkZjNiMGE0MzExNWVjMjYvanMvYmluYXJ5L2VuY29kZXIuanMjTDE0NFxyXG4gKi9cclxuZnVuY3Rpb24gdmFyaW50MzJ3cml0ZSh2YWx1ZSwgYnl0ZXMpIHtcclxuICBpZiAodmFsdWUgPj0gMCkge1xyXG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXHJcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XHJcbiAgICAgIGJ5dGVzLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XHJcbiAgICB9XHJcbiAgICBieXRlcy5wdXNoKHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcclxuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDEyNyB8IDEyOCk7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcclxuICAgIH1cclxuICAgIGJ5dGVzLnB1c2goMSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDIyMFxyXG4gKi9cclxuZnVuY3Rpb24gdmFyaW50MzJyZWFkKCkge1xyXG4gIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xyXG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcclxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcclxuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XHJcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xyXG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xyXG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcclxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XHJcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xyXG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIC8vIEV4dHJhY3Qgb25seSBsYXN0IDQgYml0c1xyXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcclxuICByZXN1bHQgfD0gKGIgJiAweDBmKSA8PCAyODtcclxuICBmb3IgKGxldCByZWFkQnl0ZXMgPSA1OyAoYiAmIDB4ODApICE9PSAwICYmIHJlYWRCeXRlcyA8IDEwOyByZWFkQnl0ZXMrKykgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xyXG4gIGlmICgoYiAmIDB4ODApICE9IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xyXG4gIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgLy8gUmVzdWx0IGNhbiBoYXZlIDMyIGJpdHMsIGNvbnZlcnQgaXQgdG8gdW5zaWduZWRcclxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5mdW5jdGlvbiBtYWtlSW50NjRTdXBwb3J0KCkge1xyXG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XHJcbiAgLy8gbm90ZSB0aGF0IFNhZmFyaSAxNCBpbXBsZW1lbnRzIEJpZ0ludCwgYnV0IG5vdCB0aGUgRGF0YVZpZXcgbWV0aG9kc1xyXG4gIGNvbnN0IG9rID0gdHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5nZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuc2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBwcm9jZXNzICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIHByb2Nlc3MuZW52ICE9IFwib2JqZWN0XCIgfHwgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XHJcbiAgaWYgKG9rKSB7XHJcbiAgICBjb25zdCBNSU4gPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSxcclxuICAgICAgTUFYID0gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxcclxuICAgICAgVU1JTiA9IEJpZ0ludChcIjBcIiksXHJcbiAgICAgIFVNQVggPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHplcm86IEJpZ0ludCgwKSxcclxuICAgICAgc3VwcG9ydGVkOiB0cnVlLFxyXG4gICAgICBwYXJzZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGJpID4gTUFYIHx8IGJpIDwgTUlOKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpO1xyXG4gICAgICB9LFxyXG4gICAgICB1UGFyc2UodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xyXG4gICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1aW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaTtcclxuICAgICAgfSxcclxuICAgICAgZW5jKHZhbHVlKSB7XHJcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy5wYXJzZSh2YWx1ZSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXHJcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICB1RW5jKHZhbHVlKSB7XHJcbiAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxyXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuICAgICAgZGVjKGxvLCBoaSkge1xyXG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcclxuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ0ludDY0KDAsIHRydWUpO1xyXG4gICAgICB9LFxyXG4gICAgICB1RGVjKGxvLCBoaSkge1xyXG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcclxuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgY29uc3QgYXNzZXJ0SW50NjRTdHJpbmcgPSB2YWx1ZSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xyXG4gIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcclxuICByZXR1cm4ge1xyXG4gICAgemVybzogXCIwXCIsXHJcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxyXG4gICAgcGFyc2UodmFsdWUpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIHVQYXJzZSh2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGVuYyh2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xyXG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICB1RW5jKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xyXG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBkZWMobG8sIGhpKSB7XHJcbiAgICAgIHJldHVybiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XHJcbiAgICB9LFxyXG4gICAgdURlYyhsbywgaGkpIHtcclxuICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5jb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpO1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIFNjYWxhciB2YWx1ZSB0eXBlcy4gVGhpcyBpcyBhIHN1YnNldCBvZiBmaWVsZCB0eXBlcyBkZWNsYXJlZCBieSBwcm90b2J1ZlxyXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxyXG4gKiBhcmUgb21pdHRlZCwgYnV0IHRoZSBudW1lcmljYWwgdmFsdWVzIGFyZSBpZGVudGljYWwuXHJcbiAqL1xyXG52YXIgU2NhbGFyVHlwZTtcclxuKGZ1bmN0aW9uIChTY2FsYXJUeXBlKSB7XHJcbiAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzLlxyXG4gIC8vIE9yZGVyIGlzIHdlaXJkIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRE9VQkxFXCJdID0gMV0gPSBcIkRPVUJMRVwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZMT0FUXCJdID0gMl0gPSBcIkZMT0FUXCI7XHJcbiAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXHJcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UNjRcIl0gPSAzXSA9IFwiSU5UNjRcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UNjRcIl0gPSA0XSA9IFwiVUlOVDY0XCI7XHJcbiAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDMyIGlmXHJcbiAgLy8gbmVnYXRpdmUgdmFsdWVzIGFyZSBsaWtlbHkuXHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UMzJcIl0gPSA1XSA9IFwiSU5UMzJcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDY0XCJdID0gNl0gPSBcIkZJWEVENjRcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJGSVhFRDMyXCJdID0gN10gPSBcIkZJWEVEMzJcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCT09MXCJdID0gOF0gPSBcIkJPT0xcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTVFJJTkdcIl0gPSA5XSA9IFwiU1RSSU5HXCI7XHJcbiAgLy8gVGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUuXHJcbiAgLy8gR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkIGFuZCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy4gSG93ZXZlciwgUHJvdG8zXHJcbiAgLy8gaW1wbGVtZW50YXRpb25zIHNob3VsZCBzdGlsbCBiZSBhYmxlIHRvIHBhcnNlIHRoZSBncm91cCB3aXJlIGZvcm1hdCBhbmRcclxuICAvLyB0cmVhdCBncm91cCBmaWVsZHMgYXMgdW5rbm93biBmaWVsZHMuXHJcbiAgLy8gVFlQRV9HUk9VUCA9IDEwLFxyXG4gIC8vIFRZUEVfTUVTU0FHRSA9IDExLCAgLy8gTGVuZ3RoLWRlbGltaXRlZCBhZ2dyZWdhdGUuXHJcbiAgLy8gTmV3IGluIHZlcnNpb24gMi5cclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UMzJcIl0gPSAxM10gPSBcIlVJTlQzMlwiO1xyXG4gIC8vIFRZUEVfRU5VTSA9IDE0LFxyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDMyXCJdID0gMTVdID0gXCJTRklYRUQzMlwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDY0XCJdID0gMTZdID0gXCJTRklYRUQ2NFwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNJTlQzMlwiXSA9IDE3XSA9IFwiU0lOVDMyXCI7XHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDY0XCJdID0gMThdID0gXCJTSU5UNjRcIjtcclxufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGZpZWxkcyB3aXRoIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcclxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXHJcbiAqXHJcbiAqIFRoaXMgaXMgYSBzdWJzZXQgb2YgZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5KU1R5cGUsIHdoaWNoIGRlZmluZXMgSlNfTk9STUFMLFxyXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxyXG4gKiBTdHJpbmcgaWYgYFtqc3R5cGUgPSBKU19TVFJJTkddYCBpcyBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIGBgYHByb3RvYnVmXHJcbiAqIHVpbnQ2NCBmaWVsZF9hID0gMTsgLy8gQmlnSW50XHJcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTk9STUFMXTsgLy8gQmlnSW50XHJcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XHJcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfU1RSSU5HXTsgLy8gU3RyaW5nXHJcbiAqIGBgYFxyXG4gKi9cclxudmFyIExvbmdUeXBlO1xyXG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XHJcbiAgLyoqXHJcbiAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxyXG4gICAqL1xyXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xyXG4gIC8qKlxyXG4gICAqIFVzZSBKYXZhU2NyaXB0IFN0cmluZy5cclxuICAgKlxyXG4gICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxyXG4gICAqL1xyXG4gIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xyXG59KShMb25nVHlwZSB8fCAoTG9uZ1R5cGUgPSB7fSkpO1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxyXG4gKi9cclxuZnVuY3Rpb24gc2NhbGFyRXF1YWxzKHR5cGUsIGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikge1xyXG4gICAgLy8gVGhpcyBjb3JyZWN0bHkgbWF0Y2hlcyBlcXVhbCB2YWx1ZXMgZXhjZXB0IEJZVEVTIGFuZCAocG9zc2libHkpIDY0LWJpdCBpbnRlZ2Vycy5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvLyBTcGVjaWFsIGNhc2UgQllURVMgLSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBieXRlIGluZGl2aWR1YWxseVxyXG4gIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcclxuICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIFNwZWNpYWwgY2FzZSA2NC1iaXQgaW50ZWdlcnMgLSB3ZSBzdXBwb3J0IG51bWJlciwgc3RyaW5nIGFuZCBiaWdpbnQgcmVwcmVzZW50YXRpb24uXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XHJcbiAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cclxuICAgICAgcmV0dXJuIGEgPT0gYjtcclxuICB9XHJcbiAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxyXG4gIC8vIEJZVEVTIGFuZCA2NC1iaXQgaW50ZWdlcnMgaXMgbm90IGVxdWFsLlxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgemVybyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXHJcbiAgICAgIHJldHVybiBsb25nVHlwZSA9PSAwID8gcHJvdG9JbnQ2NC56ZXJvIDogXCIwXCI7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxyXG4gICAgICByZXR1cm4gMC4wO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxyXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICByZXR1cm4gXCJcIjtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIC8vIEhhbmRsZXMgSU5UMzIsIFVJTlQzMiwgU0lOVDMyLCBGSVhFRDMyLCBTRklYRUQzMi5cclxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBpbmRpdmlkdWFsIGNhc2VzIHRvIHNhdmUgYSBmZXcgYnl0ZXMgY29kZSBzaXplLlxyXG4gICAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBmb3IgYSB6ZXJvLXZhbHVlLiBGb3IgZXhhbXBsZSwgYW4gaW50ZWdlciBoYXMgdGhlIHplcm8tdmFsdWUgYDBgLFxyXG4gKiBhIGJvb2xlYW4gaXMgYGZhbHNlYCwgYSBzdHJpbmcgaXMgYFwiXCJgLCBhbmQgYnl0ZXMgaXMgYW4gZW1wdHkgVWludDhBcnJheS5cclxuICpcclxuICogSW4gcHJvdG8zLCB6ZXJvLXZhbHVlcyBhcmUgbm90IHdyaXR0ZW4gdG8gdGhlIHdpcmUsIHVubGVzcyB0aGUgZmllbGQgaXNcclxuICogb3B0aW9uYWwgb3IgcmVwZWF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1NjYWxhclplcm9WYWx1ZSh0eXBlLCB2YWx1ZSkge1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IFwiXCI7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XHJcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgIXZhbHVlLmJ5dGVMZW5ndGg7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdmFsdWUgPT0gMDtcclxuICAgIC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcclxuICB9XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xyXG4vKipcclxuICogUHJvdG9idWYgYmluYXJ5IGZvcm1hdCB3aXJlIHR5cGVzLlxyXG4gKlxyXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXHJcbiAqIGZvbGxvd2luZyB2YWx1ZS5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcclxuICovXHJcbnZhciBXaXJlVHlwZTtcclxuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xyXG4gIC8qKlxyXG4gICAqIFVzZWQgZm9yIGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXHJcbiAgICovXHJcbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJWYXJpbnRcIl0gPSAwXSA9IFwiVmFyaW50XCI7XHJcbiAgLyoqXHJcbiAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cclxuICAgKiBBbHdheXMgOCBieXRlcyB3aXRoIGxpdHRsZS1lbmRpYW4gYnl0ZSBvcmRlci5cclxuICAgKi9cclxuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XHJcbiAgLyoqXHJcbiAgICogVXNlZCBmb3Igc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcclxuICAgKlxyXG4gICAqIE9ubHkgcmVwZWF0ZWQgbnVtZXJpYyB0eXBlcyAodHlwZXMgd2hpY2ggdXNlIHRoZSB2YXJpbnQsIDMyLWJpdCxcclxuICAgKiBvciA2NC1iaXQgd2lyZSB0eXBlcykgY2FuIGJlIHBhY2tlZC4gSW4gcHJvdG8zLCBzdWNoIGZpZWxkcyBhcmVcclxuICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cclxuICAgKi9cclxuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkxlbmd0aERlbGltaXRlZFwiXSA9IDJdID0gXCJMZW5ndGhEZWxpbWl0ZWRcIjtcclxuICAvKipcclxuICAgKiBTdGFydCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLCBzdWNoIGFzIGEgcHJvdG8yIGdyb3VwLCBvciBhIG1lc3NhZ2VcclxuICAgKiBpbiBlZGl0aW9ucyB3aXRoIG1lc3NhZ2VfZW5jb2RpbmcgPSBERUxJTUlURUQuXHJcbiAgICovXHJcbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJTdGFydEdyb3VwXCJdID0gM10gPSBcIlN0YXJ0R3JvdXBcIjtcclxuICAvKipcclxuICAgKiBFbmQgb2YgYSB0YWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cclxuICAgKi9cclxuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkVuZEdyb3VwXCJdID0gNF0gPSBcIkVuZEdyb3VwXCI7XHJcbiAgLyoqXHJcbiAgICogVXNlZCBmb3IgZml4ZWQzMiwgc2ZpeGVkMzIsIGZsb2F0LlxyXG4gICAqIEFsd2F5cyA0IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAqL1xyXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0MzJcIl0gPSA1XSA9IFwiQml0MzJcIjtcclxufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcclxuY2xhc3MgQmluYXJ5V3JpdGVyIHtcclxuICBjb25zdHJ1Y3Rvcih0ZXh0RW5jb2Rlcikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcclxuICAgIHRoaXMuYnVmID0gW107XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgYnl0ZXMgd3JpdHRlbiBhbmQgcmVzZXQgdGhpcyB3cml0ZXIuXHJcbiAgICovXHJcbiAgZmluaXNoKCkge1xyXG4gICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXHJcbiAgICBsZXQgbGVuID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIGxlbiArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XHJcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcclxuICAgICAgb2Zmc2V0ICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcclxuICAgIH1cclxuICAgIHRoaXMuY2h1bmtzID0gW107XHJcbiAgICByZXR1cm4gYnl0ZXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGEgbmV3IGZvcmsgZm9yIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBsaWtlIGEgbWVzc2FnZVxyXG4gICAqIG9yIGEgcGFja2VkIHJlcGVhdGVkIGZpZWxkLlxyXG4gICAqXHJcbiAgICogTXVzdCBiZSBqb2luZWQgbGF0ZXIgd2l0aCBgam9pbigpYC5cclxuICAgKi9cclxuICBmb3JrKCkge1xyXG4gICAgdGhpcy5zdGFjay5wdXNoKHtcclxuICAgICAgY2h1bmtzOiB0aGlzLmNodW5rcyxcclxuICAgICAgYnVmOiB0aGlzLmJ1ZlxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xyXG4gICAgdGhpcy5idWYgPSBbXTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBKb2luIHRoZSBsYXN0IGZvcmsuIFdyaXRlIGl0cyBsZW5ndGggYW5kIGJ5dGVzLCB0aGVuXHJcbiAgICogcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cclxuICAgKi9cclxuICBqb2luKCkge1xyXG4gICAgLy8gZ2V0IGNodW5rIG9mIGZvcmtcclxuICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XHJcbiAgICAvLyByZXN0b3JlIHByZXZpb3VzIHN0YXRlXHJcbiAgICBsZXQgcHJldiA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICBpZiAoIXByZXYpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc3RhdGUsIGZvcmsgc3RhY2sgZW1wdHlcIik7XHJcbiAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xyXG4gICAgdGhpcy5idWYgPSBwcmV2LmJ1ZjtcclxuICAgIC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcclxuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGVzIGEgdGFnIChmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZSkuXHJcbiAgICpcclxuICAgKiBFcXVpdmFsZW50IHRvIGB1aW50MzIoIChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCApYC5cclxuICAgKlxyXG4gICAqIEdlbmVyYXRlZCBjb2RlIHNob3VsZCBjb21wdXRlIHRoZSB0YWcgYWhlYWQgb2YgdGltZSBhbmQgY2FsbCBgdWludDMyKClgLlxyXG4gICAqL1xyXG4gIHRhZyhmaWVsZE5vLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXHJcbiAgICovXHJcbiAgcmF3KGNodW5rKSB7XHJcbiAgICBpZiAodGhpcy5idWYubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcclxuICAgICAgdGhpcy5idWYgPSBbXTtcclxuICAgIH1cclxuICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYHVpbnQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgdWludDMyKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xyXG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyLCBpbmxpbmVkIGZvciBzcGVlZFxyXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xyXG4gICAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlICYgMHg3ZiB8IDB4ODApO1xyXG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xyXG4gICAgfVxyXG4gICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgaW50MzJgIHZhbHVlLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIGludDMyKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XHJcbiAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgYm9vbGAgdmFsdWUsIGEgdmFyaWFudC5cclxuICAgKi9cclxuICBib29sKHZhbHVlKSB7XHJcbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlID8gMSA6IDApO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cclxuICAgKi9cclxuICBieXRlcyh2YWx1ZSkge1xyXG4gICAgdGhpcy51aW50MzIodmFsdWUuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcclxuICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYHN0cmluZ2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cclxuICAgKi9cclxuICBzdHJpbmcodmFsdWUpIHtcclxuICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcclxuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpOyAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XHJcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBmbG9hdGAgdmFsdWUsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXHJcbiAgICovXHJcbiAgZmxvYXQodmFsdWUpIHtcclxuICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xyXG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDMyKDAsIHZhbHVlLCB0cnVlKTtcclxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICAgKi9cclxuICBkb3VibGUodmFsdWUpIHtcclxuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpO1xyXG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cclxuICAgKi9cclxuICBmaXhlZDMyKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xyXG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgc2ZpeGVkMzJgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIHNmaXhlZDMyKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XHJcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcclxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYHNpbnQzMmAgdmFsdWUsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIHNpbnQzMih2YWx1ZSkge1xyXG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xyXG4gICAgLy8gemlnemFnIGVuY29kZVxyXG4gICAgdmFsdWUgPSAodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMDtcclxuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cclxuICAgKi9cclxuICBzZml4ZWQ2NCh2YWx1ZSkge1xyXG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXHJcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcclxuICAgICAgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XHJcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcclxuICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgZml4ZWQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXHJcbiAgICovXHJcbiAgZml4ZWQ2NCh2YWx1ZSkge1xyXG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCksXHJcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcclxuICAgICAgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xyXG4gICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XHJcbiAgICB2aWV3LnNldEludDMyKDQsIHRjLmhpLCB0cnVlKTtcclxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cclxuICAgKi9cclxuICBpbnQ2NCh2YWx1ZSkge1xyXG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xyXG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBzaW50NjRgIHZhbHVlLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgc2ludDY0KHZhbHVlKSB7XHJcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksXHJcbiAgICAgIC8vIHppZ3phZyBlbmNvZGVcclxuICAgICAgc2lnbiA9IHRjLmhpID4+IDMxLFxyXG4gICAgICBsbyA9IHRjLmxvIDw8IDEgXiBzaWduLFxyXG4gICAgICBoaSA9ICh0Yy5oaSA8PCAxIHwgdGMubG8gPj4+IDMxKSBeIHNpZ247XHJcbiAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYHVpbnQ2NGAgdmFsdWUsIGFuIHVuc2lnbmVkIDY0LWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgdWludDY0KHZhbHVlKSB7XHJcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xyXG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufVxyXG5jbGFzcyBCaW5hcnlSZWFkZXIge1xyXG4gIGNvbnN0cnVjdG9yKGJ1ZiwgdGV4dERlY29kZXIpIHtcclxuICAgIHRoaXMudmFyaW50NjQgPSB2YXJpbnQ2NHJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGEgYHVpbnQzMmAgZmllbGQsIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcclxuICAgIHRoaXMuYnVmID0gYnVmO1xyXG4gICAgdGhpcy5sZW4gPSBidWYubGVuZ3RoO1xyXG4gICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgdGhpcy52aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XHJcbiAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgIT09IG51bGwgJiYgdGV4dERlY29kZXIgIT09IHZvaWQgMCA/IHRleHREZWNvZGVyIDogbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWRzIGEgdGFnIC0gZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUuXHJcbiAgICovXHJcbiAgdGFnKCkge1xyXG4gICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksXHJcbiAgICAgIGZpZWxkTm8gPSB0YWcgPj4+IDMsXHJcbiAgICAgIHdpcmVUeXBlID0gdGFnICYgNztcclxuICAgIGlmIChmaWVsZE5vIDw9IDAgfHwgd2lyZVR5cGUgPCAwIHx8IHdpcmVUeXBlID4gNSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcclxuICAgIHJldHVybiBbZmllbGRObywgd2lyZVR5cGVdO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTa2lwIG9uZSBlbGVtZW50IGFuZCByZXR1cm4gdGhlIHNraXBwZWQgZGF0YS5cclxuICAgKlxyXG4gICAqIFdoZW4gc2tpcHBpbmcgU3RhcnRHcm91cCwgcHJvdmlkZSB0aGUgdGFncyBmaWVsZCBudW1iZXIgdG8gY2hlY2sgZm9yXHJcbiAgICogbWF0Y2hpbmcgZmllbGQgbnVtYmVyIGluIHRoZSBFbmRHcm91cCB0YWcuXHJcbiAgICovXHJcbiAgc2tpcCh3aXJlVHlwZSwgZmllbGRObykge1xyXG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XHJcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgIGNhc2UgV2lyZVR5cGUuVmFyaW50OlxyXG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDB4ODApIHtcclxuICAgICAgICAgIC8vIGlnbm9yZVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxyXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxyXG4gICAgICAgIHRoaXMucG9zICs9IDQ7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcclxuICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcclxuICAgICAgICB0aGlzLnBvcyArPSA0O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDpcclxuICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcclxuICAgICAgICB0aGlzLnBvcyArPSBsZW47XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgV2lyZVR5cGUuU3RhcnRHcm91cDpcclxuICAgICAgICBmb3IgKDs7KSB7XHJcbiAgICAgICAgICBjb25zdCBbZm4sIHd0XSA9IHRoaXMudGFnKCk7XHJcbiAgICAgICAgICBpZiAod3QgPT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZE5vICE9PSB1bmRlZmluZWQgJiYgZm4gIT09IGZpZWxkTm8pIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnNraXAod3QsIGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FudCBza2lwIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcclxuICAgIH1cclxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHRoaXMucG9zKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGhyb3dzIGVycm9yIGlmIHBvc2l0aW9uIGluIGJ5dGUgYXJyYXkgaXMgb3V0IG9mIHJhbmdlLlxyXG4gICAqL1xyXG4gIGFzc2VydEJvdW5kcygpIHtcclxuICAgIGlmICh0aGlzLnBvcyA+IHRoaXMubGVuKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInByZW1hdHVyZSBFT0ZcIik7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgaW50MzJgIGZpZWxkLCBhIHNpZ25lZCAzMiBiaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIGludDMyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYHNpbnQzMmAgZmllbGQsIGEgc2lnbmVkLCB6aWd6YWctZW5jb2RlZCAzMi1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIHNpbnQzMigpIHtcclxuICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xyXG4gICAgLy8gZGVjb2RlIHppZ3phZ1xyXG4gICAgcmV0dXJuIHp6ZSA+Pj4gMSBeIC0oenplICYgMSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIGludDY0KCkge1xyXG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cclxuICAgKi9cclxuICB1aW50NjQoKSB7XHJcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgc2ludDY0YCBmaWVsZCwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIHNpbnQ2NCgpIHtcclxuICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcclxuICAgIC8vIGRlY29kZSB6aWcgemFnXHJcbiAgICBsZXQgcyA9IC0obG8gJiAxKTtcclxuICAgIGxvID0gKGxvID4+PiAxIHwgKGhpICYgMSkgPDwgMzEpIF4gcztcclxuICAgIGhpID0gaGkgPj4+IDEgXiBzO1xyXG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKGxvLCBoaSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgYm9vbGAgZmllbGQsIGEgdmFyaWFudC5cclxuICAgKi9cclxuICBib29sKCkge1xyXG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xyXG4gICAgcmV0dXJuIGxvICE9PSAwIHx8IGhpICE9PSAwO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYGZpeGVkMzJgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIGZpeGVkMzIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBzZml4ZWQzMmAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXHJcbiAgICovXHJcbiAgc2ZpeGVkMzIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIGZpeGVkNjQoKSB7XHJcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cclxuICAgKi9cclxuICBzZml4ZWQ2NCgpIHtcclxuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgZmxvYXRgIGZpZWxkLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxyXG4gICAqL1xyXG4gIGZsb2F0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICAgKi9cclxuICBkb3VibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxyXG4gICAqL1xyXG4gIGJ5dGVzKCkge1xyXG4gICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCksXHJcbiAgICAgIHN0YXJ0ID0gdGhpcy5wb3M7XHJcbiAgICB0aGlzLnBvcyArPSBsZW47XHJcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbik7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgc3RyaW5nYCBmaWVsZCwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxyXG4gICAqL1xyXG4gIHN0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBleHRlbnNpb24gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlRXh0ZW5zaW9uKHJ1bnRpbWUsIHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpIHtcclxuICBsZXQgZmk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGVOYW1lLFxyXG4gICAgZXh0ZW5kZWUsXHJcbiAgICBnZXQgZmllbGQoKSB7XHJcbiAgICAgIGlmICghZmkpIHtcclxuICAgICAgICBjb25zdCBpID0gdHlwZW9mIGZpZWxkID09IFwiZnVuY3Rpb25cIiA/IGZpZWxkKCkgOiBmaWVsZDtcclxuICAgICAgICBpLm5hbWUgPSB0eXBlTmFtZS5zcGxpdChcIi5cIikucG9wKCk7XHJcbiAgICAgICAgaS5qc29uTmFtZSA9IFwiW1wiLmNvbmNhdCh0eXBlTmFtZSwgXCJdXCIpO1xyXG4gICAgICAgIGZpID0gcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChbaV0pLmxpc3QoKVswXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmk7XHJcbiAgICB9LFxyXG4gICAgcnVudGltZVxyXG4gIH07XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IGFsbG93cyB1cyB0byByZWFkIGV4dGVuc2lvbiBmaWVsZHMgaW50byBpdCB3aXRoIHRoZVxyXG4gKiBzYW1lIGxvZ2ljIGFzIHJlZ3VsYXIgZmllbGRzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyKGV4dGVuc2lvbikge1xyXG4gIGNvbnN0IGxvY2FsTmFtZSA9IGV4dGVuc2lvbi5maWVsZC5sb2NhbE5hbWU7XHJcbiAgY29uc3QgY29udGFpbmVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBjb250YWluZXJbbG9jYWxOYW1lXSA9IGluaXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24pO1xyXG4gIHJldHVybiBbY29udGFpbmVyLCAoKSA9PiBjb250YWluZXJbbG9jYWxOYW1lXV07XHJcbn1cclxuZnVuY3Rpb24gaW5pdEV4dGVuc2lvbkZpZWxkKGV4dCkge1xyXG4gIGNvbnN0IGZpZWxkID0gZXh0LmZpZWxkO1xyXG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gZmllbGQuZGVmYXVsdDtcclxuICB9XHJcbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XHJcbiAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICByZXR1cm4gZmllbGQuVC52YWx1ZXNbMF0ubm87XHJcbiAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgIHJldHVybiBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgZmllbGQuTCk7XHJcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY2FzZS1kZWNsYXJhdGlvbnNcclxuICAgICAgY29uc3QgVCA9IGZpZWxkLlQsXHJcbiAgICAgICAgdmFsdWUgPSBuZXcgVCgpO1xyXG4gICAgICByZXR1cm4gVC5maWVsZFdyYXBwZXIgPyBULmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgIGNhc2UgXCJtYXBcIjpcclxuICAgICAgdGhyb3cgXCJtYXAgZmllbGRzIGFyZSBub3QgYWxsb3dlZCB0byBiZSBleHRlbnNpb25zXCI7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZmlsdGVyIHVua25vd24gZmllbGRzLCBvcHRpbWl6ZWQgYmFzZWQgb24gZmllbGQgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGZpbHRlclVua25vd25GaWVsZHModW5rbm93bkZpZWxkcywgZmllbGQpIHtcclxuICBpZiAoIWZpZWxkLnJlcGVhdGVkICYmIChmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcclxuICAgIC8vIHNpbmd1bGFyIHNjYWxhciBmaWVsZHMgZG8gbm90IG1lcmdlLCB3ZSBwaWNrIHRoZSBsYXN0XHJcbiAgICBmb3IgKGxldCBpID0gdW5rbm93bkZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICBpZiAodW5rbm93bkZpZWxkc1tpXS5ubyA9PSBmaWVsZC5ubykge1xyXG4gICAgICAgIHJldHVybiBbdW5rbm93bkZpZWxkc1tpXV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKHVmID0+IHVmLm5vID09PSBmaWVsZC5ubyk7XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgcHJlZmVyLWNvbnN0ICovXHJcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgdG8gYnl0ZVxyXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcclxuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciAqY29kZSogdG8gYnl0ZSBiZWNhdXNlIGxvb2t1cCBieSBudW1iZXIgaXMgZmFzdFxyXG5sZXQgZGVjVGFibGUgPSBbXTtcclxuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKykgZGVjVGFibGVbZW5jVGFibGVbaV0uY2hhckNvZGVBdCgwKV0gPSBpO1xyXG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xyXG5kZWNUYWJsZVtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIrXCIpO1xyXG5kZWNUYWJsZVtcIl9cIi5jaGFyQ29kZUF0KDApXSA9IGVuY1RhYmxlLmluZGV4T2YoXCIvXCIpO1xyXG5jb25zdCBwcm90b0Jhc2U2NCA9IHtcclxuICAvKipcclxuICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXHJcbiAgICpcclxuICAgKiAtIGlnbm9yZXMgd2hpdGUtc3BhY2UsIGluY2x1ZGluZyBsaW5lIGJyZWFrcyBhbmQgdGFic1xyXG4gICAqIC0gYWxsb3dzIGlubmVyIHBhZGRpbmcgKGNhbiBkZWNvZGUgY29uY2F0ZW5hdGVkIGJhc2U2NCBzdHJpbmdzKVxyXG4gICAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXHJcbiAgICogLSB1bmRlcnN0YW5kcyBiYXNlNjR1cmwgZW5jb2Rpbmc6XHJcbiAgICogICBcIi1cIiBpbnN0ZWFkIG9mIFwiK1wiLFxyXG4gICAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcclxuICAgKiAgIG5vIHBhZGRpbmdcclxuICAgKi9cclxuICBkZWMoYmFzZTY0U3RyKSB7XHJcbiAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXHJcbiAgICBsZXQgZXMgPSBiYXNlNjRTdHIubGVuZ3RoICogMyAvIDQ7XHJcbiAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIikgZXMgLT0gMjtlbHNlIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDFdID09IFwiPVwiKSBlcyAtPSAxO1xyXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZXMpLFxyXG4gICAgICBieXRlUG9zID0gMCxcclxuICAgICAgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxyXG4gICAgICBncm91cFBvcyA9IDAsXHJcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxyXG4gICAgICBiLFxyXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcclxuICAgICAgcCA9IDA7IC8vIHByZXZpb3VzIGJ5dGVcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGIgPSBkZWNUYWJsZVtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV07XHJcbiAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXHJcbiAgICAgICAgICBjYXNlIFwiPVwiOlxyXG4gICAgICAgICAgICBncm91cFBvcyA9IDA7XHJcbiAgICAgICAgICAvLyByZXNldCBzdGF0ZSB3aGVuIHBhZGRpbmcgZm91bmRcclxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxyXG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxyXG4gICAgICAgICAgY2FzZSBcIlxcclwiOlxyXG4gICAgICAgICAgY2FzZSBcIlxcdFwiOlxyXG4gICAgICAgICAgY2FzZSBcIiBcIjpcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAvLyBza2lwIHdoaXRlLXNwYWNlLCBhbmQgcGFkZGluZ1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgcCA9IGI7XHJcbiAgICAgICAgICBncm91cFBvcyA9IDE7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gcCA8PCAyIHwgKGIgJiA0OCkgPj4gNDtcclxuICAgICAgICAgIHAgPSBiO1xyXG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMTUpIDw8IDQgfCAoYiAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgcCA9IGI7XHJcbiAgICAgICAgICBncm91cFBvcyA9IDM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAzKSA8PCA2IHwgYjtcclxuICAgICAgICAgIGdyb3VwUG9zID0gMDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xyXG4gICAgcmV0dXJuIGJ5dGVzLnN1YmFycmF5KDAsIGJ5dGVQb3MpO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICogRW5jb2RlIGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZW5jKGJ5dGVzKSB7XHJcbiAgICBsZXQgYmFzZTY0ID0gXCJcIixcclxuICAgICAgZ3JvdXBQb3MgPSAwLFxyXG4gICAgICAvLyBwb3NpdGlvbiBpbiBiYXNlNjQgZ3JvdXBcclxuICAgICAgYixcclxuICAgICAgLy8gY3VycmVudCBieXRlXHJcbiAgICAgIHAgPSAwOyAvLyBjYXJyeSBvdmVyIGZyb20gcHJldmlvdXMgYnl0ZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBiID0gYnl0ZXNbaV07XHJcbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcclxuICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XHJcbiAgICAgICAgICBncm91cFBvcyA9IDE7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNF07XHJcbiAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgIGdyb3VwUG9zID0gMjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA2XTtcclxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiICYgNjNdO1xyXG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGFkZCBvdXRwdXQgcGFkZGluZ1xyXG4gICAgaWYgKGdyb3VwUG9zKSB7XHJcbiAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwXTtcclxuICAgICAgYmFzZTY0ICs9IFwiPVwiO1xyXG4gICAgICBpZiAoZ3JvdXBQb3MgPT0gMSkgYmFzZTY0ICs9IFwiPVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhc2U2NDtcclxuICB9XHJcbn07XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogUmV0cmlldmUgYW4gZXh0ZW5zaW9uIHZhbHVlIGZyb20gYSBtZXNzYWdlLlxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gbmV2ZXIgcmV0dXJucyB1bmRlZmluZWQuIFVzZSBoYXNFeHRlbnNpb24oKSB0byBjaGVjayB3aGV0aGVyIGFuXHJcbiAqIGV4dGVuc2lvbiBpcyBzZXQuIElmIHRoZSBleHRlbnNpb24gaXMgbm90IHNldCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZVxyXG4gKiBkZWZhdWx0IHZhbHVlIChpZiBvbmUgd2FzIHNwZWNpZmllZCBpbiB0aGUgcHJvdG9idWYgc291cmNlKSwgb3IgdGhlIHplcm8gdmFsdWVcclxuICogKGZvciBleGFtcGxlIGAwYCBmb3IgbnVtZXJpYyB0eXBlcywgYFtdYCBmb3IgcmVwZWF0ZWQgZXh0ZW5zaW9uIGZpZWxkcywgYW5kXHJcbiAqIGFuIGVtcHR5IG1lc3NhZ2UgaW5zdGFuY2UgZm9yIG1lc3NhZ2UgZmllbGRzKS5cclxuICpcclxuICogRXh0ZW5zaW9ucyBhcmUgc3RvcmVkIGFzIHVua25vd24gZmllbGRzIG9uIGEgbWVzc2FnZS4gVG8gbXV0YXRlIGFuIGV4dGVuc2lvblxyXG4gKiB2YWx1ZSwgbWFrZSBzdXJlIHRvIHN0b3JlIHRoZSBuZXcgdmFsdWUgd2l0aCBzZXRFeHRlbnNpb24oKSBhZnRlciBtdXRhdGluZy5cclxuICpcclxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24sIG9wdGlvbnMpIHtcclxuICBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpO1xyXG4gIGNvbnN0IG9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgY29uc3QgdWZzID0gZmlsdGVyVW5rbm93bkZpZWxkcyhtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSwgZXh0ZW5zaW9uLmZpZWxkKTtcclxuICBjb25zdCBbY29udGFpbmVyLCBnZXRdID0gY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyKGV4dGVuc2lvbik7XHJcbiAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcclxuICAgIGV4dGVuc2lvbi5ydW50aW1lLmJpbi5yZWFkRmllbGQoY29udGFpbmVyLCBvcHQucmVhZGVyRmFjdG9yeSh1Zi5kYXRhKSwgZXh0ZW5zaW9uLmZpZWxkLCB1Zi53aXJlVHlwZSwgb3B0KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldCgpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXQgYW4gZXh0ZW5zaW9uIHZhbHVlIG9uIGEgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgYWxyZWFkeSBoYXMgYSB2YWx1ZSBmb3JcclxuICogdGhpcyBleHRlbnNpb24sIHRoZSB2YWx1ZSBpcyByZXBsYWNlZC5cclxuICpcclxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cclxuICovXHJcbmZ1bmN0aW9uIHNldEV4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24sIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKTtcclxuICBjb25zdCByZWFkT3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcclxuICBjb25zdCB3cml0ZU9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gIGlmIChoYXNFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uKSkge1xyXG4gICAgY29uc3QgdWZzID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkuZmlsdGVyKHVmID0+IHVmLm5vICE9IGV4dGVuc2lvbi5maWVsZC5ubyk7XHJcbiAgICBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5kaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKTtcclxuICAgIGZvciAoY29uc3QgdWYgb2YgdWZzKSB7XHJcbiAgICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIHVmLm5vLCB1Zi53aXJlVHlwZSwgdWYuZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHdyaXRlciA9IHdyaXRlT3B0LndyaXRlckZhY3RvcnkoKTtcclxuICBsZXQgZiA9IGV4dGVuc2lvbi5maWVsZDtcclxuICAvLyBJbXBsaWNpdCBwcmVzZW5jZSBkb2VzIG5vdCBhcHBseSB0byBleHRlbnNpb25zLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9pc3N1ZXMvODIzNFxyXG4gIC8vIFdlIHBhdGNoIHRoZSBmaWVsZCBpbmZvIHRvIHVzZSBleHBsaWNpdCBwcmVzZW5jZTpcclxuICBpZiAoIWYub3B0ICYmICFmLnJlcGVhdGVkICYmIChmLmtpbmQgPT0gXCJlbnVtXCIgfHwgZi5raW5kID09IFwic2NhbGFyXCIpKSB7XHJcbiAgICBmID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRlbnNpb24uZmllbGQpLCB7XHJcbiAgICAgIG9wdDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGV4dGVuc2lvbi5ydW50aW1lLmJpbi53cml0ZUZpZWxkKGYsIHZhbHVlLCB3cml0ZXIsIHdyaXRlT3B0KTtcclxuICBjb25zdCByZWFkZXIgPSByZWFkT3B0LnJlYWRlckZhY3Rvcnkod3JpdGVyLmZpbmlzaCgpKTtcclxuICB3aGlsZSAocmVhZGVyLnBvcyA8IHJlYWRlci5sZW4pIHtcclxuICAgIGNvbnN0IFtubywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xyXG4gICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlLCBubyk7XHJcbiAgICBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhbiBleHRlbnNpb24gaXMgc2V0IG9uIGEgbWVzc2FnZS5cclxuICovXHJcbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pIHtcclxuICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xyXG4gIHJldHVybiBleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT09IG1lc3NhZ2VUeXBlLnR5cGVOYW1lICYmICEhbWVzc2FnZVR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkuZmluZCh1ZiA9PiB1Zi5ubyA9PSBleHRlbnNpb24uZmllbGQubm8pO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSkge1xyXG4gIGFzc2VydChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT0gbWVzc2FnZS5nZXRUeXBlKCkudHlwZU5hbWUsIFwiZXh0ZW5zaW9uIFwiLmNvbmNhdChleHRlbnNpb24udHlwZU5hbWUsIFwiIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWVzc2FnZSBcIikuY29uY2F0KGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSkpO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWVsZCBpcyBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0ZpZWxkU2V0KGZpZWxkLCB0YXJnZXQpIHtcclxuICBjb25zdCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XHJcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0ubGVuZ3RoID4gMDtcclxuICB9XHJcbiAgaWYgKGZpZWxkLm9uZW9mKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0uY2FzZSA9PT0gbG9jYWxOYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xyXG4gIH1cclxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgIGlmIChmaWVsZC5vcHQgfHwgZmllbGQucmVxKSB7XHJcbiAgICAgICAgLy8gZXhwbGljaXQgcHJlc2VuY2VcclxuICAgICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICAvLyBpbXBsaWNpdCBwcmVzZW5jZVxyXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcImVudW1cIikge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gZmllbGQuVC52YWx1ZXNbMF0ubm87XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICFpc1NjYWxhclplcm9WYWx1ZShmaWVsZC5ULCB0YXJnZXRbbG9jYWxOYW1lXSk7XHJcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICByZXR1cm4gdGFyZ2V0W2xvY2FsTmFtZV0gIT09IHVuZGVmaW5lZDtcclxuICAgIGNhc2UgXCJtYXBcIjpcclxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldFtsb2NhbE5hbWVdKS5sZW5ndGggPiAwO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cclxuICovXHJcbmZ1bmN0aW9uIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCkge1xyXG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcclxuICBjb25zdCBpbXBsaWNpdFByZXNlbmNlID0gIWZpZWxkLm9wdCAmJiAhZmllbGQucmVxO1xyXG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xyXG4gICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBbXTtcclxuICB9IGVsc2UgaWYgKGZpZWxkLm9uZW9mKSB7XHJcbiAgICB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcclxuICAgICAgY2FzZTogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0ge307XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBpbXBsaWNpdFByZXNlbmNlID8gZmllbGQuVC52YWx1ZXNbMF0ubm8gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgZmllbGQuTCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFueSBzdWJ0eXBlIG9mIE1lc3NhZ2Ugb3IgaXMgYSBzcGVjaWZpY1xyXG4gKiBNZXNzYWdlIGJ5IHBhc3NpbmcgdGhlIHR5cGUuXHJcbiAqXHJcbiAqIEp1c3QgbGlrZSBgaW5zdGFuY2VvZmAsIGBpc01lc3NhZ2VgIG5hcnJvd3MgdGhlIHR5cGUuIFRoZSBhZHZhbnRhZ2Ugb2ZcclxuICogYGlzTWVzc2FnZWAgaXMgdGhhdCBpdCBjb21wYXJlcyBpZGVudGl0eSBieSB0aGUgbWVzc2FnZSB0eXBlIG5hbWUsIG5vdCBieVxyXG4gKiBjbGFzcyBpZGVudGl0eS4gVGhpcyBtYWtlcyBpdCByb2J1c3QgYWdhaW5zdCB0aGUgZHVhbCBwYWNrYWdlIGhhemFyZCBhbmRcclxuICogc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB0aGUgc2FtZSBtZXNzYWdlIGlzIGR1cGxpY2F0ZWQuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgX21vc3RseV8gZXF1aXZhbGVudCB0byB0aGUgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLiBGb3JcclxuICogZXhhbXBsZSwgYGlzTWVzc2FnZShmb28sIE15TWVzc2FnZSlgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNeU1lc3NhZ2VgLFxyXG4gKiBhbmQgYGlzTWVzc2FnZShmb28pYCBpcyB0aGUgc2FtZSBhcyBgZm9vIGluc3RhbmNlb2YgTWVzc2FnZWAuIEluIG1vc3QgY2FzZXMsXHJcbiAqIGBpc01lc3NhZ2VgIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBgaW5zdGFuY2VvZmAuXHJcbiAqXHJcbiAqIEhvd2V2ZXIsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IGBpc01lc3NhZ2VgIGRvZXMgbm90IHVzZSBjbGFzcyBpZGVudGl0eSwgdGhlcmVcclxuICogYXJlIHN1YnRsZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGBpbnN0YW5jZW9mYC4gTm90YWJseSxcclxuICogY2FsbGluZyBgaXNNZXNzYWdlYCBvbiBhbiBleHBsaWNpdCB0eXBlIG9mIE1lc3NhZ2Ugd2lsbCByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc01lc3NhZ2UoYXJnLCB0eXBlKSB7XHJcbiAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnICE9IFwib2JqZWN0XCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNZXNzYWdlLnByb3RvdHlwZSkuZXZlcnkobSA9PiBtIGluIGFyZyAmJiB0eXBlb2YgYXJnW21dID09IFwiZnVuY3Rpb25cIikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgYWN0dWFsVHlwZSA9IGFyZy5nZXRUeXBlKCk7XHJcbiAgaWYgKGFjdHVhbFR5cGUgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbFR5cGUgIT0gXCJmdW5jdGlvblwiIHx8ICEoXCJ0eXBlTmFtZVwiIGluIGFjdHVhbFR5cGUpIHx8IHR5cGVvZiBhY3R1YWxUeXBlLnR5cGVOYW1lICE9IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHR5cGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhY3R1YWxUeXBlLnR5cGVOYW1lID09IHR5cGUudHlwZU5hbWU7XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBXcmFwIGEgcHJpbWl0aXZlIG1lc3NhZ2UgZmllbGQgdmFsdWUgaW4gaXRzIGNvcnJlc3BvbmRpbmcgd3JhcHBlclxyXG4gKiBtZXNzYWdlLiBUaGlzIGZ1bmN0aW9uIGlzIGlkZW1wb3RlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwRmllbGQodHlwZSwgdmFsdWUpIHtcclxuICBpZiAoaXNNZXNzYWdlKHZhbHVlKSB8fCAhdHlwZS5maWVsZFdyYXBwZXIpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHR5cGUuZmllbGRXcmFwcGVyLndyYXBGaWVsZCh2YWx1ZSk7XHJcbn1cclxuKHtcclxuICBcImdvb2dsZS5wcm90b2J1Zi5Eb3VibGVWYWx1ZVwiOiBTY2FsYXJUeXBlLkRPVUJMRSxcclxuICBcImdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlXCI6IFNjYWxhclR5cGUuRkxPQVQsXHJcbiAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDY0LFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDY0LFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5JTlQzMixcclxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQzMixcclxuICBcImdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWVcIjogU2NhbGFyVHlwZS5CT09MLFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlXCI6IFNjYWxhclR5cGUuU1RSSU5HLFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogU2NhbGFyVHlwZS5CWVRFU1xyXG59KTtcclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwgKi9cclxuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXHJcbmNvbnN0IGpzb25SZWFkRGVmYXVsdHMgPSB7XHJcbiAgaWdub3JlVW5rbm93bkZpZWxkczogZmFsc2VcclxufTtcclxuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyB0byBKU09OLlxyXG5jb25zdCBqc29uV3JpdGVEZWZhdWx0cyA9IHtcclxuICBlbWl0RGVmYXVsdFZhbHVlczogZmFsc2UsXHJcbiAgZW51bUFzSW50ZWdlcjogZmFsc2UsXHJcbiAgdXNlUHJvdG9GaWVsZE5hbWU6IGZhbHNlLFxyXG4gIHByZXR0eVNwYWNlczogMFxyXG59O1xyXG5mdW5jdGlvbiBtYWtlUmVhZE9wdGlvbnMkMShvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XHJcbn1cclxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyQxKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xyXG59XHJcbmNvbnN0IHRva2VuTnVsbCA9IFN5bWJvbCgpO1xyXG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xyXG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbWFrZVJlYWRPcHRpb25zOiBtYWtlUmVhZE9wdGlvbnMkMSxcclxuICAgIG1ha2VXcml0ZU9wdGlvbnM6IG1ha2VXcml0ZU9wdGlvbnMkMSxcclxuICAgIHJlYWRNZXNzYWdlKHR5cGUsIGpzb24sIG9wdGlvbnMsIG1lc3NhZ2UpIHtcclxuICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xyXG4gICAgICBjb25zdCBvbmVvZlNlZW4gPSBuZXcgTWFwKCk7XHJcbiAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XHJcbiAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcclxuICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgIGlmIChmaWVsZC5vbmVvZikge1xyXG4gICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xyXG4gICAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBvbmVvZlNlZW4uZ2V0KGZpZWxkLm9uZW9mKTtcclxuICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBtdWx0aXBsZSBrZXlzIGZvciBvbmVvZiBcXFwiXCIpLmNvbmNhdChmaWVsZC5vbmVvZi5uYW1lLCBcIlxcXCIgcHJlc2VudDogXFxcIlwiKS5jb25jYXQoc2VlbiwgXCJcXFwiLCBcXFwiXCIpLmNvbmNhdChqc29uS2V5LCBcIlxcXCJcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVhZEZpZWxkJDEobWVzc2FnZSwganNvblZhbHVlLCBmaWVsZCwgb3B0aW9ucywgdHlwZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKChyZWdpc3RyeSA9PT0gbnVsbCB8fCByZWdpc3RyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVnaXN0cnkuZmluZEV4dGVuc2lvbikgJiYganNvbktleS5zdGFydHNXaXRoKFwiW1wiKSAmJiBqc29uS2V5LmVuZHNXaXRoKFwiXVwiKSkge1xyXG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKGpzb25LZXkuc3Vic3RyaW5nKDEsIGpzb25LZXkubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBpZiAoZXh0ICYmIGV4dC5leHRlbmRlZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcclxuICAgICAgICAgICAgICByZWFkRmllbGQkMShjb250YWluZXIsIGpzb25WYWx1ZSwgZXh0LmZpZWxkLCBvcHRpb25zLCBleHQpO1xyXG4gICAgICAgICAgICAgIC8vIFdlIHBhc3Mgb24gdGhlIG9wdGlvbnMgYXMgQmluYXJ5UmVhZE9wdGlvbnMvQmluYXJ5V3JpdGVPcHRpb25zLFxyXG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93biBiaW5hcnkgcmVhZGVyIGFuZCB3cml0ZXIgZmFjdG9yaWVzXHJcbiAgICAgICAgICAgICAgLy8gaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgIHNldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIGdldCgpLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFmb3VuZCAmJiAhb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBrZXkgXFxcIlwiKS5jb25jYXQoanNvbktleSwgXCJcXFwiIGlzIHVua25vd25cIikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH0sXHJcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XHJcbiAgICAgIGNvbnN0IGpzb24gPSB7fTtcclxuICAgICAgbGV0IGZpZWxkO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAoZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xyXG4gICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXEpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBcInJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZShmaWVsZCkpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZiA/IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXS52YWx1ZSA6IG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXTtcclxuICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHdyaXRlRmllbGQkMShmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGpzb25bb3B0aW9ucy51c2VQcm90b0ZpZWxkTmFtZSA/IGZpZWxkLm5hbWUgOiBmaWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XHJcbiAgICAgICAgaWYgKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IHVmIG9mIHR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XHJcbiAgICAgICAgICAgIGlmIChleHQgJiYgaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCkpIHtcclxuICAgICAgICAgICAgICAvLyBXZSBwYXNzIG9uIHRoZSBvcHRpb25zIGFzIEJpbmFyeVJlYWRPcHRpb25zLCBzbyB0aGF0IHVzZXJzIGNhbiBicmluZyB0aGVpciBvd25cclxuICAgICAgICAgICAgICAvLyBiaW5hcnkgcmVhZGVyIGZhY3RvcnkgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgY29uc3QganNvblZhbHVlID0gd3JpdGVGaWVsZCQxKGV4dC5maWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAganNvbltleHQuZmllbGQuanNvbk5hbWVdID0ganNvblZhbHVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IG0gPSBmaWVsZCA/IFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBKU09OXCIpIDogXCJjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIHRvIEpTT05cIik7XHJcbiAgICAgICAgY29uc3QgciA9IGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSArIChyLmxlbmd0aCA+IDAgPyBcIjogXCIuY29uY2F0KHIpIDogXCJcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBqc29uO1xyXG4gICAgfSxcclxuICAgIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcclxuICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQuIEZvciBiYWNrd2FyZHMtXHJcbiAgICAgIC8vIGNvbXBhdGliaWxpdHksIHdlIHN1cHBvcnQgdGhlIG9sZCBmb3JtIHRoYXQgaXMgcGFydCBvZiB0aGUgcHVibGljIEFQSVxyXG4gICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cclxuICAgICAgcmV0dXJuIHJlYWRTY2FsYXIkMSh0eXBlLCBqc29uLCBsb25nVHlwZSAhPT0gbnVsbCAmJiBsb25nVHlwZSAhPT0gdm9pZCAwID8gbG9uZ1R5cGUgOiBMb25nVHlwZS5CSUdJTlQsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0RGVmYXVsdFZhbHVlcykge1xyXG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZC4gRm9yIGJhY2t3YXJkcy1cclxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgIC8vIHRocm91Z2ggdGhlIGludGVyZmFjZSBKc29uRm9ybWF0LlxyXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVtaXREZWZhdWx0VmFsdWVzIHx8IGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNjYWxhciQxKHR5cGUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuICAgIGRlYnVnOiBkZWJ1Z0pzb25WYWx1ZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZGVidWdKc29uVmFsdWUoanNvbikge1xyXG4gIGlmIChqc29uID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgfVxyXG4gIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcclxuICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiO1xyXG4gICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogXCJcXFwiXCIuY29uY2F0KGpzb24uc3BsaXQoJ1wiJykuam9pbignXFxcXFwiJyksIFwiXFxcIlwiKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XHJcbiAgfVxyXG59XHJcbi8vIFJlYWQgYSBKU09OIHZhbHVlIGZvciBhIGZpZWxkLlxyXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXHJcbmZ1bmN0aW9uIHJlYWRGaWVsZCQxKHRhcmdldCwganNvblZhbHVlLCBmaWVsZCwgb3B0aW9ucywgcGFyZW50VHlwZSkge1xyXG4gIGxldCBsb2NhbE5hbWUgPSBmaWVsZC5sb2NhbE5hbWU7XHJcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XHJcbiAgICBhc3NlcnQoZmllbGQua2luZCAhPSBcIm1hcFwiKTtcclxuICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0QXJyYXkgPSB0YXJnZXRbbG9jYWxOYW1lXTtcclxuICAgIGZvciAoY29uc3QganNvbkl0ZW0gb2YganNvblZhbHVlKSB7XHJcbiAgICAgIGlmIChqc29uSXRlbSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25JdGVtKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGZpZWxkLlQuZnJvbUpzb24oanNvbkl0ZW0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uSXRlbSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcclxuICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHRva2VuSWdub3JlZFVua25vd25FbnVtKSB7XHJcbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2goZW51bVZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2gocmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25JdGVtLCBmaWVsZC5MLCB0cnVlKSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uSXRlbSkpO1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xyXG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGpzb25WYWx1ZSAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRNYXAgPSB0YXJnZXRbbG9jYWxOYW1lXTtcclxuICAgIGZvciAoY29uc3QgW2pzb25NYXBLZXksIGpzb25NYXBWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlKSkge1xyXG4gICAgICBpZiAoanNvbk1hcFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IG1hcCB2YWx1ZSBudWxsXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQga2V5O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGtleSA9IHJlYWRNYXBLZXkoZmllbGQuSywganNvbk1hcEtleSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xyXG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdG9rZW5JZ25vcmVkVW5rbm93bkVudW0pIHtcclxuICAgICAgICAgICAgdGFyZ2V0TWFwW2tleV0gPSBlbnVtVmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IHJlYWRTY2FsYXIkMShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgbWFwIHZhbHVlIGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoZmllbGQub25lb2YpIHtcclxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSB7XHJcbiAgICAgICAgY2FzZTogbG9jYWxOYW1lXHJcbiAgICAgIH07XHJcbiAgICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcclxuICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtsb2NhbE5hbWVdO1xyXG4gICAgICAgIGlmIChpc01lc3NhZ2UoY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgY3VycmVudFZhbHVlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gY3VycmVudFZhbHVlID0gbWVzc2FnZVR5cGUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKGN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25WYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCBmYWxzZSk7XHJcbiAgICAgICAgc3dpdGNoIChlbnVtVmFsdWUpIHtcclxuICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxyXG4gICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgdG9rZW5JZ25vcmVkVW5rbm93bkVudW06XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBlbnVtVmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBzY2FsYXJWYWx1ZSA9IHJlYWRTY2FsYXIkMShmaWVsZC5ULCBqc29uVmFsdWUsIGZpZWxkLkwsIGZhbHNlKTtcclxuICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcclxuICAgICAgICAgICAgY2FzZSB0b2tlbk51bGw6XHJcbiAgICAgICAgICAgICAgY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHNjYWxhclZhbHVlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcclxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByZWFkTWFwS2V5KHR5cGUsIGpzb24pIHtcclxuICBpZiAodHlwZSA9PT0gU2NhbGFyVHlwZS5CT09MKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xyXG4gICAgc3dpdGNoIChqc29uKSB7XHJcbiAgICAgIGNhc2UgXCJ0cnVlXCI6XHJcbiAgICAgICAganNvbiA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJmYWxzZVwiOlxyXG4gICAgICAgIGpzb24gPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlYWRTY2FsYXIkMSh0eXBlLCBqc29uLCBMb25nVHlwZS5CSUdJTlQsIHRydWUpLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcclxuICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgaWYgKG51bGxBc1plcm9WYWx1ZSkge1xyXG4gICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b2tlbk51bGw7XHJcbiAgfVxyXG4gIC8vIGV2ZXJ5IHZhbGlkIGNhc2UgaW4gdGhlIHN3aXRjaCBiZWxvdyByZXR1cm5zLCBhbmQgZXZlcnkgZmFsbFxyXG4gIC8vIHRocm91Z2ggaXMgcmVnYXJkZWQgYXMgYSBmYWlsdXJlLlxyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXHJcbiAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XHJcbiAgICAgIGlmIChqc29uID09PSBcIk5hTlwiKSByZXR1cm4gTnVtYmVyLk5hTjtcclxuICAgICAgaWYgKGpzb24gPT09IFwiSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgIGlmIChqc29uID09PSBcIlwiKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCBhIG51bWJlclxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcclxuICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGZsb2F0ID0gTnVtYmVyKGpzb24pO1xyXG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGZsb2F0KSkge1xyXG4gICAgICAgIC8vIG5vdCBhIG51bWJlclxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZsb2F0KSkge1xyXG4gICAgICAgIC8vIGluZmluaXR5IGFuZCAtaW5maW5pdHkgYXJlIGhhbmRsZWQgYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFib3ZlLCBzbyB0aGlzIGlzIGFuIGVycm9yXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVCkgYXNzZXJ0RmxvYXQzMihmbG9hdCk7XHJcbiAgICAgIHJldHVybiBmbG9hdDtcclxuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XHJcbiAgICAgIGxldCBpbnQzMjtcclxuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwibnVtYmVyXCIpIGludDMyID0ganNvbjtlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggPT09IGpzb24ubGVuZ3RoKSBpbnQzMiA9IE51bWJlcihqc29uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZCkgYnJlYWs7XHJcbiAgICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuVUlOVDMyIHx8IHR5cGUgPT0gU2NhbGFyVHlwZS5GSVhFRDMyKSBhc3NlcnRVSW50MzIoaW50MzIpO2Vsc2UgYXNzZXJ0SW50MzIoaW50MzIpO1xyXG4gICAgICByZXR1cm4gaW50MzI7XHJcbiAgICAvLyBpbnQ2NCwgZml4ZWQ2NCwgdWludDY0OiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcclxuICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICAgICAgcmV0dXJuIGxvbmdUeXBlID8gbG9uZy50b1N0cmluZygpIDogbG9uZztcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcclxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XHJcbiAgICAgIGNvbnN0IHVMb25nID0gcHJvdG9JbnQ2NC51UGFyc2UoanNvbik7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xyXG4gICAgLy8gYm9vbDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwiYm9vbGVhblwiKSBicmVhaztcclxuICAgICAgcmV0dXJuIGpzb247XHJcbiAgICAvLyBzdHJpbmc6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXHJcbiAgICAgIC8vIFdlIHZhbGlkYXRlIHdpdGggZW5jb2RlVVJJQ29tcG9uZW50LCB3aGljaCBhcHBlYXJzIHRvIGJlIHRoZSBmYXN0ZXN0IHdpZGVseSBhdmFpbGFibGUgb3B0aW9uLlxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqc29uKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgVVRGOFwiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ganNvbjtcclxuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cclxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcclxuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcclxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSBicmVhaztcclxuICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmRlYyhqc29uKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbn1cclxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcywgbnVsbEFzWmVyb1ZhbHVlKSB7XHJcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcclxuICAgIGlmICh0eXBlLnR5cGVOYW1lID09IFwiZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVwiKSB7XHJcbiAgICAgIHJldHVybiAwOyAvLyBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlLk5VTExfVkFMVUUgPSAwXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbEFzWmVyb1ZhbHVlID8gdHlwZS52YWx1ZXNbMF0ubm8gOiB0b2tlbk51bGw7XHJcbiAgfVxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXHJcbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xyXG4gICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihqc29uKSkge1xyXG4gICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICBjb25zdCB2YWx1ZSA9IHR5cGUuZmluZE5hbWUoanNvbik7XHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm5vO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuSWdub3JlZFVua25vd25FbnVtO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGVudW0gXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uKSkpO1xyXG59XHJcbi8vIERlY2lkZSB3aGV0aGVyIGFuIHVuc2V0IGZpZWxkIHNob3VsZCBiZSBlbWl0dGVkIHdpdGggSlNPTiB3cml0ZSBvcHRpb24gYGVtaXREZWZhdWx0VmFsdWVzYFxyXG5mdW5jdGlvbiBjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpIHtcclxuICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XHJcbiAgICAvLyBtYXBzIGFyZSB7fSwgcmVwZWF0ZWQgZmllbGRzIGFyZSBbXVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmIChmaWVsZC5vbmVvZikge1xyXG4gICAgLy8gb25lb2YgZmllbGRzIGFyZSBuZXZlciBlbWl0dGVkXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChmaWVsZC5raW5kID09IFwibWVzc2FnZVwiKSB7XHJcbiAgICAvLyBzaW5ndWxhciBtZXNzYWdlIGZpZWxkIGFyZSBhbGxvd2VkIHRvIGVtaXQgSlNPTiBudWxsLCBidXQgd2UgZG8gbm90XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xyXG4gICAgLy8gdGhlIGZpZWxkIHVzZXMgZXhwbGljaXQgcHJlc2VuY2UsIHNvIHdlIGNhbm5vdCBlbWl0IGEgemVybyB2YWx1ZVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB3cml0ZUZpZWxkJDEoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xyXG4gICAgY29uc3QganNvbk9iaiA9IHt9O1xyXG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcclxuICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XHJcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgZW50cmllcykge1xyXG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyJDEoZmllbGQuVi5ULCBlbnRyeVZhbHVlKTsgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgZW50cmllcykge1xyXG4gICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxyXG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICBjb25zdCBlbnVtVHlwZSA9IGZpZWxkLlYuVDtcclxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgZW50cmllcykge1xyXG4gICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxyXG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlRW51bShlbnVtVHlwZSwgZW50cnlWYWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBlbnRyaWVzLmxlbmd0aCA+IDAgPyBqc29uT2JqIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcclxuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XHJcbiAgICBjb25zdCBqc29uQXJyID0gW107XHJcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZVNjYWxhciQxKGZpZWxkLlQsIHZhbHVlW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBqc29uQXJyLnB1c2godmFsdWVbaV0udG9Kc29uKG9wdGlvbnMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBqc29uQXJyLmxlbmd0aCA+IDAgPyBqc29uQXJyIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyJDEoZmllbGQuVCwgdmFsdWUpO1xyXG4gICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgcmV0dXJuIHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcclxuICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgIHJldHVybiB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpLnRvSnNvbihvcHRpb25zKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gd3JpdGVFbnVtKHR5cGUsIHZhbHVlLCBlbnVtQXNJbnRlZ2VyKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XHJcbiAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAoZW51bUFzSW50ZWdlcikge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBjb25zdCB2YWwgPSB0eXBlLmZpbmROdW1iZXIodmFsdWUpO1xyXG4gIHJldHVybiAoX2EgPSB2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWwubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsdWU7IC8vIGlmIHdlIGRvbid0IGtub3cgdGhlIGVudW0gdmFsdWUsIGp1c3QgcmV0dXJuIHRoZSBudW1iZXJcclxufVxyXG5mdW5jdGlvbiB3cml0ZVNjYWxhciQxKHR5cGUsIHZhbHVlKSB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxyXG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cclxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxyXG4gICAgLy8gYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXHJcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XHJcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSByZXR1cm4gXCJOYU5cIjtcclxuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIkluZmluaXR5XCI7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSByZXR1cm4gXCItSW5maW5pdHlcIjtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgLy8gc3RyaW5nOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcclxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgLy8gYm9vbDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxyXG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgLy8gSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcclxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcclxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXHJcbiAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XHJcbiAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xyXG4gICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZW5jKHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cclxuY29uc3QgdW5rbm93bkZpZWxkc1N5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi91bmtub3duLWZpZWxkc1wiKTtcclxuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIGJpbmFyeSBkYXRhLlxyXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XHJcbiAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXHJcbiAgcmVhZGVyRmFjdG9yeTogYnl0ZXMgPT4gbmV3IEJpbmFyeVJlYWRlcihieXRlcylcclxufTtcclxuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyBiaW5hcnkgZGF0YS5cclxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcclxuICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXHJcbiAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpXHJcbn07XHJcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucykge1xyXG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VCaW5hcnlGb3JtYXQoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIG1ha2VSZWFkT3B0aW9ucyxcclxuICAgIG1ha2VXcml0ZU9wdGlvbnMsXHJcbiAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgcmV0dXJuIChfYSA9IG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgfSxcclxuICAgIGRpc2NhcmRVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcclxuICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XHJcbiAgICB9LFxyXG4gICAgd3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICBjb25zdCBtID0gbWVzc2FnZTtcclxuICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBmIG9mIGMpIHtcclxuICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgb25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKSB7XHJcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcclxuICAgICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdID0gW107XHJcbiAgICAgIH1cclxuICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHtcclxuICAgICAgICBubyxcclxuICAgICAgICB3aXJlVHlwZSxcclxuICAgICAgICBkYXRhXHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vLCBvcHRpb25zLCBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcpIHtcclxuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXHJcbiAgICAgIGNvbnN0IGVuZCA9IGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vO1xyXG4gICAgICBsZXQgZmllbGRObywgd2lyZVR5cGU7XHJcbiAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcclxuICAgICAgICBpZiAoZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nID09PSB0cnVlICYmIHdpcmVUeXBlID09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kKGZpZWxkTm8pO1xyXG4gICAgICAgIGlmICghZmllbGQpIHtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSwgZmllbGRObyk7XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkcykge1xyXG4gICAgICAgICAgICB0aGlzLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkYXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkRmllbGQobWVzc2FnZSwgcmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgJiYgKFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xyXG4gICAgICB3aXJlVHlwZSAhPSBXaXJlVHlwZS5FbmRHcm91cCB8fCBmaWVsZE5vICE9PSBsZW5ndGhPckVuZFRhZ0ZpZWxkTm8pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVhZEZpZWxkLFxyXG4gICAgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xyXG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XHJcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMuYnlOdW1iZXIoKSkge1xyXG4gICAgICAgIGlmICghaXNGaWVsZFNldChmaWVsZCwgbWVzc2FnZSkpIHtcclxuICAgICAgICAgIGlmIChmaWVsZC5yZXEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBiaW5hcnk6IHJlcXVpcmVkIGZpZWxkIG5vdCBzZXRcIikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQub25lb2YgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWUgOiBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV07XHJcbiAgICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgfSxcclxuICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcclxuICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZCwgaXQgZG9lcyBubyBsb25nZXJcclxuICAgICAgLy8gYWNjZXB0IGB1bmRlZmluZWRgIHZhbHVlcyBmb3Igc2luZ3VsYXIgc2NhbGFyIGFuZCBtYXAuXHJcbiAgICAgIC8vIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mXHJcbiAgICAgIC8vIHRoZSBwdWJsaWMgQVBJIHRocm91Z2ggdGhlIGludGVyZmFjZSBCaW5hcnlGb3JtYXQuXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRGaWVsZCh0YXJnZXQsXHJcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBgYW55YCBpcyB0aGUgYmVzdCBjaG9pY2UgZm9yIGR5bmFtaWMgYWNjZXNzXHJcbnJlYWRlciwgZmllbGQsIHdpcmVUeXBlLCBvcHRpb25zKSB7XHJcbiAgbGV0IHtcclxuICAgIHJlcGVhdGVkLFxyXG4gICAgbG9jYWxOYW1lXHJcbiAgfSA9IGZpZWxkO1xyXG4gIGlmIChmaWVsZC5vbmVvZikge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV07XHJcbiAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XHJcbiAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQuY2FzZSA9IGxvY2FsTmFtZTtcclxuICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcclxuICB9XHJcbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XHJcbiAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xyXG4gICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXI7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xyXG4gICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XHJcbiAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVwZWF0ZWQpIHtcclxuICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcclxuICAgICAgICBjb25zdCBpc1BhY2tlZCA9IHdpcmVUeXBlID09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCAmJiBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuU1RSSU5HICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5CWVRFUztcclxuICAgICAgICBpZiAoaXNQYWNrZWQpIHtcclxuICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcclxuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xyXG4gICAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhcnIucHVzaChyZWFkKHJlYWRlciwgc2NhbGFyVHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcclxuICAgICAgaWYgKHJlcGVhdGVkKSB7XHJcbiAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xyXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zLCBmaWVsZCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc01lc3NhZ2UodGFyZ2V0W2xvY2FsTmFtZV0pKSB7XHJcbiAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMsIGZpZWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMsIGZpZWxkKTtcclxuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mICYmICFmaWVsZC5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZCh0YXJnZXRbbG9jYWxOYW1lXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICBsZXQgW21hcEtleSwgbWFwVmFsXSA9IHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcclxuICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgbWFwIG9iamVjdCwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXHJcbiAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG4vLyBSZWFkIGEgbWVzc2FnZSwgYXZvaWRpbmcgTWVzc2FnZVR5cGUuZnJvbUJpbmFyeSgpIHRvIHJlLXVzZSB0aGVcclxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxyXG5mdW5jdGlvbiByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgZmllbGQpIHtcclxuICBjb25zdCBmb3JtYXQgPSBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbjtcclxuICBjb25zdCBkZWxpbWl0ZWQgPSBmaWVsZCA9PT0gbnVsbCB8fCBmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmllbGQuZGVsaW1pdGVkO1xyXG4gIGZvcm1hdC5yZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGRlbGltaXRlZCA/IGZpZWxkLm5vIDogcmVhZGVyLnVpbnQzMigpLFxyXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXHJcbiAgb3B0aW9ucywgZGVsaW1pdGVkKTtcclxuICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG4vLyBSZWFkIGEgbWFwIGZpZWxkLCBleHBlY3Rpbmcga2V5IGZpZWxkID0gMSwgdmFsdWUgZmllbGQgPSAyXHJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnVpbnQzMigpLFxyXG4gICAgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcclxuICBsZXQga2V5LCB2YWw7XHJcbiAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgIGNvbnN0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcclxuICAgIHN3aXRjaCAoZmllbGRObykge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDI6XHJcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcclxuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgICAgdmFsID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLlYuVCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICAgICAgdmFsID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucywgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgIGtleSA9IHNjYWxhclplcm9WYWx1ZShmaWVsZC5LLCBMb25nVHlwZS5CSUdJTlQpO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGtleSAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBrZXkgIT0gXCJudW1iZXJcIikge1xyXG4gICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XHJcbiAgfVxyXG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIHZhbCA9IHNjYWxhclplcm9WYWx1ZShmaWVsZC5WLlQsIExvbmdUeXBlLkJJR0lOVCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgdmFsID0gZmllbGQuVi5ULnZhbHVlc1swXS5ubztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICB2YWwgPSBuZXcgZmllbGQuVi5UKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBba2V5LCB2YWxdO1xyXG59XHJcbi8vIFJlYWQgYSBzY2FsYXIgdmFsdWUsIGJ1dCByZXR1cm4gNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxyXG4vLyBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KSBhcyBzdHJpbmcgaW5zdGVhZCBvZiBiaWdpbnQuXHJcbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcclxuICBjb25zdCB2ID0gcmVhZFNjYWxhcihyZWFkZXIsIHR5cGUpO1xyXG4gIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcclxufVxyXG4vLyBEb2VzIG5vdCB1c2Ugc2NhbGFyVHlwZUluZm8oKSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxyXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcclxuICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLmJvb2woKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XHJcbiAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XHJcbiAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcclxuICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxyXG4gICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxyXG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XHJcbiAgICAgIHJldHVybiByZWFkZXIuZml4ZWQ2NCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcclxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XHJcbiAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcclxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcclxuICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XHJcbiAgICAgIHJldHVybiByZWFkZXIudWludDMyKCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKSB7XHJcbiAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gIGNvbnN0IHJlcGVhdGVkID0gZmllbGQucmVwZWF0ZWQ7XHJcbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XHJcbiAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcclxuICAgICAgaWYgKHJlcGVhdGVkKSB7XHJcbiAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcclxuICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XHJcbiAgICAgICAgICB3cml0ZVBhY2tlZCh3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgaWYgKHJlcGVhdGVkKSB7XHJcbiAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcclxuICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwibWFwXCI6XHJcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsKTtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xyXG4gICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcclxuICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xyXG4gIHdyaXRlci5mb3JrKCk7XHJcbiAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xyXG4gIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcclxuICBsZXQga2V5VmFsdWUgPSBrZXk7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xyXG4gIHN3aXRjaCAoZmllbGQuSykge1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcclxuICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcclxuICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcclxuICAgICAga2V5VmFsdWUgPSBrZXkgPT0gXCJ0cnVlXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICAvLyB3cml0ZSBrZXksIGV4cGVjdGluZyBrZXkgZmllbGQgbnVtYmVyID0gMVxyXG4gIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuSywgMSwga2V5VmFsdWUpO1xyXG4gIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxyXG4gIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XHJcbiAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuYnl0ZXModmFsdWUudG9CaW5hcnkob3B0aW9ucykpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgd3JpdGVyLmpvaW4oKTtcclxufVxyXG4vLyBWYWx1ZSBtdXN0IG5vdCBiZSB1bmRlZmluZWRcclxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpIHtcclxuICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXHJcbiAgaWYgKGZpZWxkLmRlbGltaXRlZCkgd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuU3RhcnRHcm91cCkucmF3KG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuRW5kR3JvdXApO2Vsc2Ugd3JpdGVyLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKTtcclxufVxyXG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XHJcbiAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xyXG4gIGxldCBbd2lyZVR5cGUsIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcclxuICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB3cml0ZVBhY2tlZCh3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XHJcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcclxuICBsZXQgWywgbWV0aG9kXSA9IHNjYWxhclR5cGVJbmZvKHR5cGUpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcclxuICB9XHJcbiAgd3JpdGVyLmpvaW4oKTtcclxufVxyXG4vKipcclxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBSZXR1cm5zIHR1cGxlOlxyXG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXHJcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcclxuICogWzJdOiB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRlZmF1bHQgdmFsdWUgZm9yIHByb3RvMyBzZW1hbnRpY3NcclxuICpcclxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxyXG4gKi9cclxuLy8gVE9ETyByZXBsYWNlIGNhbGwtc2l0ZXMgd3JpdGVTY2FsYXIoKSBhbmQgd3JpdGVQYWNrZWQoKSwgdGhlbiByZW1vdmVcclxuZnVuY3Rpb24gc2NhbGFyVHlwZUluZm8odHlwZSkge1xyXG4gIGxldCB3aXJlVHlwZSA9IFdpcmVUeXBlLlZhcmludDtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBJTlQzMiwgVUlOVDMyLCBTSU5UMzIgYXJlIGNvdmVyZWQgYnkgdGhlIGRlZmF1bHRzXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XHJcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0NjQ7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XHJcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuQml0MzI7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICBjb25zdCBtZXRob2QgPSBTY2FsYXJUeXBlW3R5cGVdLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIFt3aXJlVHlwZSwgbWV0aG9kXTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cclxuZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNldEVudW1UeXBlLFxyXG4gICAgaW5pdFBhcnRpYWwoc291cmNlLCB0YXJnZXQpIHtcclxuICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQuZ2V0VHlwZSgpO1xyXG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gbWVtYmVyLmxvY2FsTmFtZSxcclxuICAgICAgICAgIHQgPSB0YXJnZXQsXHJcbiAgICAgICAgICBzID0gc291cmNlO1xyXG4gICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgLy8gVE9ETyBpZiBzb3VyY2UgaXMgYSBNZXNzYWdlIGluc3RhbmNlLCB3ZSBzaG91bGQgdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xyXG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XHJcbiAgICAgICAgICAgIGNvbnN0IHNrID0gc1tsb2NhbE5hbWVdLmNhc2U7XHJcbiAgICAgICAgICAgIGlmIChzayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBtZW1iZXIuZmluZEZpZWxkKHNrKTtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmIHNvdXJjZUZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIgJiYgIWlzTWVzc2FnZSh2YWwsIHNvdXJjZUZpZWxkLlQpKSB7XHJcbiAgICAgICAgICAgICAgdmFsID0gbmV3IHNvdXJjZUZpZWxkLlQodmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09PSBcInNjYWxhclwiICYmIHNvdXJjZUZpZWxkLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcclxuICAgICAgICAgICAgICB2YWwgPSB0b1U4QXJyKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0ge1xyXG4gICAgICAgICAgICAgIGNhc2U6IHNrLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICBsZXQgY29weSA9IHNbbG9jYWxOYW1lXTtcclxuICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XHJcbiAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZCA/IGNvcHkubWFwKHRvVThBcnIpIDogdG9VOEFycihjb3B5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBjb3B5O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJtYXBcIjpcclxuICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLlYuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdG9VOEFycih2KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0W2xvY2FsTmFtZV0sIHNbbG9jYWxOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtZW1iZXIuVi5UO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXVtrXTtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHRha2UgcGFydGlhbCBpbnB1dCBmb3IgbWVzc2FnZXMgdGhhdCBhcmUgbm90IGEgd3JhcHBlciB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aG9zZSBtZXNzYWdlcywgd2UgcmVjdXJzaXZlbHkgbm9ybWFsaXplIHRoZSBwYXJ0aWFsIGlucHV0LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBtZXNzYWdlVHlwZSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgICAgY29uc3QgbXQgPSBtZW1iZXIuVDtcclxuICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHNbbG9jYWxOYW1lXS5tYXAodmFsID0+IGlzTWVzc2FnZSh2YWwsIG10KSA/IHZhbCA6IG5ldyBtdCh2YWwpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XHJcbiAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIEJ5dGVzVmFsdWUudHlwZU5hbWUgYXMgdGhhdCB3aWxsIGNyZWF0ZSBhIGNpcmN1bGFyIGltcG9ydFxyXG4gICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xyXG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB0b1U4QXJyKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGlzTWVzc2FnZSh2YWwsIG10KSA/IHZhbCA6IG5ldyBtdCh2YWwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBUT0RPIHVzZSBpc0ZpZWxkU2V0KCkgaGVyZSB0byBzdXBwb3J0IGZ1dHVyZSBmaWVsZCBwcmVzZW5jZVxyXG4gICAgZXF1YWxzKHR5cGUsIGEsIGIpIHtcclxuICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWEgfHwgIWIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkuZXZlcnkobSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmEgPSBhW20ubG9jYWxOYW1lXTtcclxuICAgICAgICBjb25zdCB2YiA9IGJbbS5sb2NhbE5hbWVdO1xyXG4gICAgICAgIGlmIChtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICBpZiAodmEubGVuZ3RoICE9PSB2Yi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXHJcbiAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xyXG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMobS5ULCBhLCB2YltpXSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIGEsIHZiW2ldKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBlYXRlZCBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQobS5raW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAobS5raW5kKSB7XHJcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICBsZXQgYSA9IHZhO1xyXG4gICAgICAgICAgICBsZXQgYiA9IHZiO1xyXG4gICAgICAgICAgICBpZiAobS5ULmZpZWxkV3JhcHBlcikge1xyXG4gICAgICAgICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQgJiYgIWlzTWVzc2FnZShhKSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IG0uVC5maWVsZFdyYXBwZXIud3JhcEZpZWxkKGEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoYiAhPT0gdW5kZWZpbmVkICYmICFpc01lc3NhZ2UoYikpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBtLlQuZmllbGRXcmFwcGVyLndyYXBGaWVsZChiKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHMoYSwgYik7XHJcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLCB2Yik7XHJcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMobS5ULCB2YSwgdmIpO1xyXG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XHJcbiAgICAgICAgICAgIGlmICh2YS5jYXNlICE9PSB2Yi5jYXNlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtLmZpbmRGaWVsZCh2YS5jYXNlKTtcclxuICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxyXG4gICAgICAgICAgICBzd2l0Y2ggKHMua2luZCkge1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5ULmVxdWFscyh2YS52YWx1ZSwgdmIudmFsdWUpO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhzLlQsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25lb2YgY2Fubm90IGNvbnRhaW4gXCIuY29uY2F0KHMua2luZCkpO1xyXG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmEpLmNvbmNhdChPYmplY3Qua2V5cyh2YikpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbS5WLlQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcclxuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoayA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmFba10sIHZiW2tdKSk7XHJcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoayA9PiBzY2FsYXJFcXVhbHMoc2NhbGFyVHlwZSwgdmFba10sIHZiW2tdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBUT0RPIHVzZSBpc0ZpZWxkU2V0KCkgaGVyZSB0byBzdXBwb3J0IGZ1dHVyZSBmaWVsZCBwcmVzZW5jZVxyXG4gICAgY2xvbmUobWVzc2FnZSkge1xyXG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCksXHJcbiAgICAgICAgdGFyZ2V0ID0gbmV3IHR5cGUoKSxcclxuICAgICAgICBhbnkgPSB0YXJnZXQ7XHJcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xyXG4gICAgICAgIGxldCBjb3B5O1xyXG4gICAgICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcclxuICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKGNsb25lU2luZ3VsYXJGaWVsZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XHJcbiAgICAgICAgICBjb3B5ID0gYW55W21lbWJlci5sb2NhbE5hbWVdO1xyXG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lU2luZ3VsYXJGaWVsZCh2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xyXG4gICAgICAgICAgY29uc3QgZiA9IG1lbWJlci5maW5kRmllbGQoc291cmNlLmNhc2UpO1xyXG4gICAgICAgICAgY29weSA9IGYgPyB7XHJcbiAgICAgICAgICAgIGNhc2U6IHNvdXJjZS5jYXNlLFxyXG4gICAgICAgICAgICB2YWx1ZTogY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZS52YWx1ZSlcclxuICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbnlbbWVtYmVyLmxvY2FsTmFtZV0gPSBjb3B5O1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xyXG4gICAgICAgIHR5cGUucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQoYW55LCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG4vLyBjbG9uZSBhIHNpbmdsZSBmaWVsZCB2YWx1ZSAtIGkuZS4gdGhlIGVsZW1lbnQgdHlwZSBvZiByZXBlYXRlZCBmaWVsZHMsIHRoZSB2YWx1ZSB0eXBlIG9mIG1hcHNcclxuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgaWYgKGlzTWVzc2FnZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xyXG4gIH1cclxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XHJcbiAgICBjLnNldCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gYztcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cclxuZnVuY3Rpb24gdG9VOEFycihpbnB1dCkge1xyXG4gIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dCA6IG5ldyBVaW50OEFycmF5KGlucHV0KTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuZnVuY3Rpb24gbWFrZVByb3RvUnVudGltZShzeW50YXgsIG5ld0ZpZWxkTGlzdCwgaW5pdEZpZWxkcykge1xyXG4gIHJldHVybiB7XHJcbiAgICBzeW50YXgsXHJcbiAgICBqc29uOiBtYWtlSnNvbkZvcm1hdCgpLFxyXG4gICAgYmluOiBtYWtlQmluYXJ5Rm9ybWF0KCksXHJcbiAgICB1dGlsOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7XHJcbiAgICAgIG5ld0ZpZWxkTGlzdCxcclxuICAgICAgaW5pdEZpZWxkc1xyXG4gICAgfSksXHJcbiAgICBtYWtlTWVzc2FnZVR5cGUodHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XHJcbiAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcclxuICAgIH0sXHJcbiAgICBtYWtlRW51bSxcclxuICAgIG1ha2VFbnVtVHlwZSxcclxuICAgIGdldEVudW1UeXBlLFxyXG4gICAgbWFrZUV4dGVuc2lvbih0eXBlTmFtZSwgZXh0ZW5kZWUsIGZpZWxkKSB7XHJcbiAgICAgIHJldHVybiBtYWtlRXh0ZW5zaW9uKHRoaXMsIHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbmNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcclxuICBjb25zdHJ1Y3RvcihmaWVsZHMsIG5vcm1hbGl6ZXIpIHtcclxuICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcclxuICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xyXG4gIH1cclxuICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcclxuICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcclxuICAgICAgY29uc3QgdCA9IHt9O1xyXG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcclxuICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5qc29uTmFtZXNbanNvbk5hbWVdO1xyXG4gIH1cclxuICBmaW5kKGZpZWxkTm8pIHtcclxuICAgIGlmICghdGhpcy5udW1iZXJzKSB7XHJcbiAgICAgIGNvbnN0IHQgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XHJcbiAgICAgICAgdFtmLm5vXSA9IGY7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5udW1iZXJzID0gdDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm51bWJlcnNbZmllbGROb107XHJcbiAgfVxyXG4gIGxpc3QoKSB7XHJcbiAgICBpZiAoIXRoaXMuYWxsKSB7XHJcbiAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYWxsO1xyXG4gIH1cclxuICBieU51bWJlcigpIHtcclxuICAgIGlmICghdGhpcy5udW1iZXJzQXNjKSB7XHJcbiAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm51bWJlcnNBc2M7XHJcbiAgfVxyXG4gIGJ5TWVtYmVyKCkge1xyXG4gICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgdGhpcy5tZW1iZXJzID0gW107XHJcbiAgICAgIGNvbnN0IGEgPSB0aGlzLm1lbWJlcnM7XHJcbiAgICAgIGxldCBvO1xyXG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcclxuICAgICAgICBpZiAoZi5vbmVvZikge1xyXG4gICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcclxuICAgICAgICAgICAgbyA9IGYub25lb2Y7XHJcbiAgICAgICAgICAgIGEucHVzaChvKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYS5wdXNoKGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubWVtYmVycztcclxuICB9XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgcHJvdG9idWYgZWxlbWVudCBpbiBnZW5lcmF0ZWQgY29kZS5cclxuICpcclxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXHJcbiAqIG1lc3NhZ2VzLCBlbnVtZXJhdGlvbnMgYW5kIHNlcnZpY2VzLCB0aGUgcGFja2FnZSBuYW1lIGlzIHN0cmlwcGVkIGZyb21cclxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxyXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmaWVsZCBpbiBnZW5lcmF0ZWQgY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgaW5PbmVvZikge1xyXG4gIGNvbnN0IG5hbWUgPSBwcm90b0NhbWVsQ2FzZShwcm90b05hbWUpO1xyXG4gIGlmIChpbk9uZW9mKSB7XHJcbiAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxPbmVvZk5hbWUocHJvdG9OYW1lKSB7XHJcbiAgcmV0dXJuIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBKU09OIG5hbWUgZm9yIGEgcHJvdG9idWYgZmllbGQsIGV4YWN0bHkgbGlrZSBwcm90b2MgZG9lcy5cclxuICovXHJcbmNvbnN0IGZpZWxkSnNvbk5hbWUgPSBwcm90b0NhbWVsQ2FzZTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIHNuYWtlX2Nhc2UgdG8gcHJvdG9DYW1lbENhc2UgYWNjb3JkaW5nIHRvIHRoZSBjb252ZW50aW9uXHJcbiAqIHVzZWQgYnkgcHJvdG9jIHRvIGNvbnZlcnQgYSBmaWVsZCBuYW1lIHRvIGEgSlNPTiBuYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcHJvdG9DYW1lbENhc2Uoc25ha2VDYXNlKSB7XHJcbiAgbGV0IGNhcE5leHQgPSBmYWxzZTtcclxuICBjb25zdCBiID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbmFrZUNhc2UubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcclxuICAgIHN3aXRjaCAoYykge1xyXG4gICAgICBjYXNlIFwiX1wiOlxyXG4gICAgICAgIGNhcE5leHQgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiMFwiOlxyXG4gICAgICBjYXNlIFwiMVwiOlxyXG4gICAgICBjYXNlIFwiMlwiOlxyXG4gICAgICBjYXNlIFwiM1wiOlxyXG4gICAgICBjYXNlIFwiNFwiOlxyXG4gICAgICBjYXNlIFwiNVwiOlxyXG4gICAgICBjYXNlIFwiNlwiOlxyXG4gICAgICBjYXNlIFwiN1wiOlxyXG4gICAgICBjYXNlIFwiOFwiOlxyXG4gICAgICBjYXNlIFwiOVwiOlxyXG4gICAgICAgIGIucHVzaChjKTtcclxuICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKGNhcE5leHQpIHtcclxuICAgICAgICAgIGNhcE5leHQgPSBmYWxzZTtcclxuICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGIucHVzaChjKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGIuam9pbihcIlwiKTtcclxufVxyXG4vKipcclxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxyXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXHJcbiAqL1xyXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcclxuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxyXG5cImNvbnN0cnVjdG9yXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0pTT05cIiwgXCJ2YWx1ZU9mXCJdKTtcclxuLyoqXHJcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcclxuICogYnkgdGhlIHJ1bnRpbWUuXHJcbiAqL1xyXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXHJcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lXHJcblwiZ2V0VHlwZVwiLCBcImNsb25lXCIsIFwiZXF1YWxzXCIsIFwiZnJvbUJpbmFyeVwiLCBcImZyb21Kc29uXCIsIFwiZnJvbUpzb25TdHJpbmdcIiwgXCJ0b0JpbmFyeVwiLCBcInRvSnNvblwiLCBcInRvSnNvblN0cmluZ1wiLFxyXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZSBmb3IgdGhlIGZ1dHVyZVxyXG5cInRvT2JqZWN0XCJdKTtcclxuY29uc3QgZmFsbGJhY2sgPSBuYW1lID0+IFwiXCIuY29uY2F0KG5hbWUsIFwiJFwiKTtcclxuLyoqXHJcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcclxuICogZm9yIGBNZXNzYWdlYHMuXHJcbiAqL1xyXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gbmFtZSA9PiB7XHJcbiAgaWYgKHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XHJcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiBuYW1lO1xyXG59O1xyXG4vKipcclxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxyXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXHJcbiAqL1xyXG5jb25zdCBzYWZlT2JqZWN0UHJvcGVydHkgPSBuYW1lID0+IHtcclxuICBpZiAocmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xyXG4gICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xyXG4gIH1cclxuICByZXR1cm4gbmFtZTtcclxufTtcclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbmNsYXNzIEludGVybmFsT25lb2ZJbmZvIHtcclxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICB0aGlzLmtpbmQgPSBcIm9uZW9mXCI7XHJcbiAgICB0aGlzLnJlcGVhdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnBhY2tlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5vcHQgPSBmYWxzZTtcclxuICAgIHRoaXMucmVxID0gZmFsc2U7XHJcbiAgICB0aGlzLmRlZmF1bHQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmZpZWxkcyA9IFtdO1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIHRoaXMubG9jYWxOYW1lID0gbG9jYWxPbmVvZk5hbWUobmFtZSk7XHJcbiAgfVxyXG4gIGFkZEZpZWxkKGZpZWxkKSB7XHJcbiAgICBhc3NlcnQoZmllbGQub25lb2YgPT09IHRoaXMsIFwiZmllbGQgXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiIG5vdCBvbmUgb2YgXCIpLmNvbmNhdCh0aGlzLm5hbWUpKTtcclxuICAgIHRoaXMuZmllbGRzLnB1c2goZmllbGQpO1xyXG4gIH1cclxuICBmaW5kRmllbGQobG9jYWxOYW1lKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xyXG4gICAgICB0aGlzLl9sb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5fbG9va3VwW3RoaXMuZmllbGRzW2ldLmxvY2FsTmFtZV0gPSB0aGlzLmZpZWxkc1tpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2xvb2t1cFtsb2NhbE5hbWVdO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBjb2xsZWN0aW9uIG9mIGZpZWxkIGluZm8gdG8gYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCBGaWVsZEluZm8uXHJcbiAqXHJcbiAqIFRoZSBhcmd1bWVudCBgcGFja2VkQnlEZWZhdWx0YCBzcGVjaWZpZXMgd2hldGhlciBmaWVsZHMgdGhhdCBkbyBub3Qgc3BlY2lmeVxyXG4gKiBgcGFja2VkYCBzaG91bGQgYmUgcGFja2VkIChwcm90bzMpIG9yIHVucGFja2VkIChwcm90bzIpLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvcyhmaWVsZEluZm9zLCBwYWNrZWRCeURlZmF1bHQpIHtcclxuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICBjb25zdCByID0gW107XHJcbiAgbGV0IG87XHJcbiAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZEluZm9zKCkgOiBmaWVsZEluZm9zKSB7XHJcbiAgICBjb25zdCBmID0gZmllbGQ7XHJcbiAgICBmLmxvY2FsTmFtZSA9IGxvY2FsRmllbGROYW1lKGZpZWxkLm5hbWUsIGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpO1xyXG4gICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xyXG4gICAgZi5yZXBlYXRlZCA9IChfYiA9IGZpZWxkLnJlcGVhdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcclxuICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIpIHtcclxuICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xyXG4gICAgfVxyXG4gICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xyXG4gICAgZi5yZXEgPSAoX2UgPSBmaWVsZC5yZXEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xyXG4gICAgZi5vcHQgPSAoX2YgPSBmaWVsZC5vcHQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGZhbHNlO1xyXG4gICAgaWYgKGZpZWxkLnBhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHtcclxuICAgICAgICBmLnBhY2tlZCA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHwgZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5CWVRFUyAmJiBmaWVsZC5UICE9IFNjYWxhclR5cGUuU1RSSU5HO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxyXG4gICAgLy8gZi5vcHRpb25zID0gZmllbGQub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0O1xyXG4gICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3Qgb29uYW1lID0gdHlwZW9mIGZpZWxkLm9uZW9mID09IFwic3RyaW5nXCIgPyBmaWVsZC5vbmVvZiA6IGZpZWxkLm9uZW9mLm5hbWU7XHJcbiAgICAgIGlmICghbyB8fCBvLm5hbWUgIT0gb29uYW1lKSB7XHJcbiAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGYub25lb2YgPSBvO1xyXG4gICAgICBvLmFkZEZpZWxkKGYpO1xyXG4gICAgfVxyXG4gICAgci5wdXNoKGYpO1xyXG4gIH1cclxuICByZXR1cm4gcjtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1lc3NhZ2VzIGRlZmluZWQgd2l0aCB0aGUgcHJvdG8zIHN5bnRheC5cclxuICovXHJcbmNvbnN0IHByb3RvMyA9IG1ha2VQcm90b1J1bnRpbWUoXCJwcm90bzNcIiwgZmllbGRzID0+IHtcclxuICByZXR1cm4gbmV3IEludGVybmFsRmllbGRMaXN0KGZpZWxkcywgc291cmNlID0+IG5vcm1hbGl6ZUZpZWxkSW5mb3Moc291cmNlKSk7XHJcbn0sXHJcbi8vIFRPRE8gbWVyZ2Ugd2l0aCBwcm90bzIgYW5kIGluaXRFeHRlbnNpb25GaWVsZCwgYWxzbyBzZWUgaW5pdFBhcnRpYWwsIGVxdWFscywgY2xvbmVcclxudGFyZ2V0ID0+IHtcclxuICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XHJcbiAgICBpZiAobWVtYmVyLm9wdCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxyXG4gICAgICB0ID0gdGFyZ2V0O1xyXG4gICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xyXG4gICAgICB0W25hbWVdID0gW107XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xyXG4gICAgICBjYXNlIFwib25lb2ZcIjpcclxuICAgICAgICB0W25hbWVdID0ge1xyXG4gICAgICAgICAgY2FzZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICB0W25hbWVdID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICAgIHRbbmFtZV0gPSB7fTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIHRbbmFtZV0gPSBzY2FsYXJaZXJvVmFsdWUobWVtYmVyLlQsIG1lbWJlci5MKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIEEgVGltZXN0YW1wIHJlcHJlc2VudHMgYSBwb2ludCBpbiB0aW1lIGluZGVwZW5kZW50IG9mIGFueSB0aW1lIHpvbmUgb3IgbG9jYWxcclxuICogY2FsZW5kYXIsIGVuY29kZWQgYXMgYSBjb3VudCBvZiBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdFxyXG4gKiBuYW5vc2Vjb25kIHJlc29sdXRpb24uIFRoZSBjb3VudCBpcyByZWxhdGl2ZSB0byBhbiBlcG9jaCBhdCBVVEMgbWlkbmlnaHQgb25cclxuICogSmFudWFyeSAxLCAxOTcwLCBpbiB0aGUgcHJvbGVwdGljIEdyZWdvcmlhbiBjYWxlbmRhciB3aGljaCBleHRlbmRzIHRoZVxyXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLlxyXG4gKlxyXG4gKiBBbGwgbWludXRlcyBhcmUgNjAgc2Vjb25kcyBsb25nLiBMZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcFxyXG4gKiBzZWNvbmQgdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbiwgdXNpbmcgYSBbMjQtaG91ciBsaW5lYXJcclxuICogc21lYXJdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3RpbWUvc21lYXIpLlxyXG4gKlxyXG4gKiBUaGUgcmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouIEJ5XHJcbiAqIHJlc3RyaWN0aW5nIHRvIHRoYXQgcmFuZ2UsIHdlIGVuc3VyZSB0aGF0IHdlIGNhbiBjb252ZXJ0IHRvIGFuZCBmcm9tIFtSRkNcclxuICogMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBkYXRlIHN0cmluZ3MuXHJcbiAqXHJcbiAqICMgRXhhbXBsZXNcclxuICpcclxuICogRXhhbXBsZSAxOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGB0aW1lKClgLlxyXG4gKlxyXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0aW1lKE5VTEwpKTtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoMCk7XHJcbiAqXHJcbiAqIEV4YW1wbGUgMjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgZ2V0dGltZW9mZGF5KClgLlxyXG4gKlxyXG4gKiAgICAgc3RydWN0IHRpbWV2YWwgdHY7XHJcbiAqICAgICBnZXR0aW1lb2ZkYXkoJnR2LCBOVUxMKTtcclxuICpcclxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXA7XHJcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModHYudHZfc2VjKTtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3ModHYudHZfdXNlYyAqIDEwMDApO1xyXG4gKlxyXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gV2luMzIgYEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKClgLlxyXG4gKlxyXG4gKiAgICAgRklMRVRJTUUgZnQ7XHJcbiAqICAgICBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgmZnQpO1xyXG4gKiAgICAgVUlOVDY0IHRpY2tzID0gKCgoVUlOVDY0KWZ0LmR3SGlnaERhdGVUaW1lKSA8PCAzMikgfCBmdC5kd0xvd0RhdGVUaW1lO1xyXG4gKlxyXG4gKiAgICAgLy8gQSBXaW5kb3dzIHRpY2sgaXMgMTAwIG5hbm9zZWNvbmRzLiBXaW5kb3dzIGVwb2NoIDE2MDEtMDEtMDFUMDA6MDA6MDBaXHJcbiAqICAgICAvLyBpcyAxMTY0NDQ3MzYwMCBzZWNvbmRzIGJlZm9yZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxyXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcygoSU5UNjQpICgodGlja3MgLyAxMDAwMDAwMCkgLSAxMTY0NDQ3MzYwMExMKSk7XHJcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKChJTlQzMikgKCh0aWNrcyAlIDEwMDAwMDAwKSAqIDEwMCkpO1xyXG4gKlxyXG4gKiBFeGFtcGxlIDQ6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKClgLlxyXG4gKlxyXG4gKiAgICAgbG9uZyBtaWxsaXMgPSBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKTtcclxuICpcclxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPSBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobWlsbGlzIC8gMTAwMClcclxuICogICAgICAgICAuc2V0TmFub3MoKGludCkgKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApKS5idWlsZCgpO1xyXG4gKlxyXG4gKiBFeGFtcGxlIDU6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgSW5zdGFudC5ub3coKWAuXHJcbiAqXHJcbiAqICAgICBJbnN0YW50IG5vdyA9IEluc3RhbnQubm93KCk7XHJcbiAqXHJcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID1cclxuICogICAgICAgICBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobm93LmdldEVwb2NoU2Vjb25kKCkpXHJcbiAqICAgICAgICAgICAgIC5zZXROYW5vcyhub3cuZ2V0TmFubygpKS5idWlsZCgpO1xyXG4gKlxyXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cclxuICpcclxuICogICAgIHRpbWVzdGFtcCA9IFRpbWVzdGFtcCgpXHJcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxyXG4gKlxyXG4gKiAjIEpTT04gTWFwcGluZ1xyXG4gKlxyXG4gKiBJbiBKU09OIGZvcm1hdCwgdGhlIFRpbWVzdGFtcCB0eXBlIGlzIGVuY29kZWQgYXMgYSBzdHJpbmcgaW4gdGhlXHJcbiAqIFtSRkMgMzMzOV0oaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBmb3JtYXQuIFRoYXQgaXMsIHRoZVxyXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXHJcbiAqIHdoZXJlIHt5ZWFyfSBpcyBhbHdheXMgZXhwcmVzc2VkIHVzaW5nIGZvdXIgZGlnaXRzIHdoaWxlIHttb250aH0sIHtkYXl9LFxyXG4gKiB7aG91cn0sIHttaW59LCBhbmQge3NlY30gYXJlIHplcm8tcGFkZGVkIHRvIHR3byBkaWdpdHMgZWFjaC4gVGhlIGZyYWN0aW9uYWxcclxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcclxuICogYXJlIG9wdGlvbmFsLiBUaGUgXCJaXCIgc3VmZml4IGluZGljYXRlcyB0aGUgdGltZXpvbmUgKFwiVVRDXCIpOyB0aGUgdGltZXpvbmVcclxuICogaXMgcmVxdWlyZWQuIEEgcHJvdG8zIEpTT04gc2VyaWFsaXplciBzaG91bGQgYWx3YXlzIHVzZSBVVEMgKGFzIGluZGljYXRlZCBieVxyXG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxyXG4gKiBhYmxlIHRvIGFjY2VwdCBib3RoIFVUQyBhbmQgb3RoZXIgdGltZXpvbmVzIChhcyBpbmRpY2F0ZWQgYnkgYW4gb2Zmc2V0KS5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxyXG4gKiAwMTozMCBVVEMgb24gSmFudWFyeSAxNSwgMjAxNy5cclxuICpcclxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXHJcbiAqIHN0YW5kYXJkXHJcbiAqIFt0b0lTT1N0cmluZygpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nKVxyXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXHJcbiAqIHRvIHRoaXMgZm9ybWF0IHVzaW5nXHJcbiAqIFtgc3RyZnRpbWVgXShodHRwczovL2RvY3MucHl0aG9uLm9yZy8yL2xpYnJhcnkvdGltZS5odG1sI3RpbWUuc3RyZnRpbWUpIHdpdGhcclxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxyXG4gKiB0aGUgSm9kYSBUaW1lJ3MgW2BJU09EYXRlVGltZUZvcm1hdC5kYXRlVGltZSgpYF0oXHJcbiAqIGh0dHA6Ly9qb2RhLXRpbWUuc291cmNlZm9yZ2UubmV0L2FwaWRvY3Mvb3JnL2pvZGEvdGltZS9mb3JtYXQvSVNPRGF0ZVRpbWVGb3JtYXQuaHRtbCNkYXRlVGltZSgpXHJcbiAqICkgdG8gb2J0YWluIGEgZm9ybWF0dGVyIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0aW1lc3RhbXBzIGluIHRoaXMgZm9ybWF0LlxyXG4gKlxyXG4gKlxyXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXHJcbiAqL1xyXG5jbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcclxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxyXG4gICAgICogMTk3MC0wMS0wMVQwMDowMDowMFouIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xyXG4gICAgICogOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50NjQgc2Vjb25kcyA9IDE7XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQuemVybztcclxuICAgIC8qKlxyXG4gICAgICogTm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uIE5lZ2F0aXZlXHJcbiAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXHJcbiAgICAgKiB0aGF0IGNvdW50IGZvcndhcmQgaW4gdGltZS4gTXVzdCBiZSBmcm9tIDAgdG8gOTk5LDk5OSw5OTlcclxuICAgICAqIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDMyIG5hbm9zID0gMjtcclxuICAgICAqL1xyXG4gICAgdGhpcy5uYW5vcyA9IDA7XHJcbiAgICBwcm90bzMudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcclxuICB9XHJcbiAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IFwiLmNvbmNhdChwcm90bzMuanNvbi5kZWJ1Zyhqc29uKSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGpzb24ubWF0Y2goL14oWzAtOV17NH0pLShbMC05XXsyfSktKFswLTldezJ9KVQoWzAtOV17Mn0pOihbMC05XXsyfSk6KFswLTldezJ9KSg/Olp8XFwuKFswLTldezMsOX0pWnwoWystXVswLTldWzAtOV06WzAtOV1bMC05XSkpJC8pO1xyXG4gICAgaWYgKCFtYXRjaGVzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xyXG4gICAgaWYgKE51bWJlci5pc05hTihtcykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogaW52YWxpZCBSRkMgMzMzOSBzdHJpbmdcIik7XHJcbiAgICB9XHJcbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlXCIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZWNvbmRzID0gcHJvdG9JbnQ2NC5wYXJzZShtcyAvIDEwMDApO1xyXG4gICAgdGhpcy5uYW5vcyA9IDA7XHJcbiAgICBpZiAobWF0Y2hlc1s3XSkge1xyXG4gICAgICB0aGlzLm5hbm9zID0gcGFyc2VJbnQoXCIxXCIgKyBtYXRjaGVzWzddICsgXCIwXCIucmVwZWF0KDkgLSBtYXRjaGVzWzddLmxlbmd0aCkpIC0gMTAwMDAwMDAwMDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICB0b0pzb24ob3B0aW9ucykge1xyXG4gICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XHJcbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHRvIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5uYW5vcyA8IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIHRvIEpTT046IG5hbm9zIG11c3Qgbm90IGJlIG5lZ2F0aXZlXCIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHogPSBcIlpcIjtcclxuICAgIGlmICh0aGlzLm5hbm9zID4gMCkge1xyXG4gICAgICBjb25zdCBuYW5vc1N0ciA9ICh0aGlzLm5hbm9zICsgMTAwMDAwMDAwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09IFwiMDAwMDAwXCIpIHtcclxuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgMykgKyBcIlpcIjtcclxuICAgICAgfSBlbHNlIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoNikgPT09IFwiMDAwXCIpIHtcclxuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgNikgKyBcIlpcIjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ciArIFwiWlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xyXG4gIH1cclxuICB0b0RhdGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyKHRoaXMuc2Vjb25kcykgKiAxMDAwICsgTWF0aC5jZWlsKHRoaXMubmFub3MgLyAxMDAwMDAwKSk7XHJcbiAgfVxyXG4gIHN0YXRpYyBub3coKSB7XHJcbiAgICByZXR1cm4gVGltZXN0YW1wLmZyb21EYXRlKG5ldyBEYXRlKCkpO1xyXG4gIH1cclxuICBzdGF0aWMgZnJvbURhdGUoZGF0ZSkge1xyXG4gICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHtcclxuICAgICAgc2Vjb25kczogcHJvdG9JbnQ2NC5wYXJzZShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLFxyXG4gICAgICBuYW5vczogbXMgJSAxMDAwICogMTAwMDAwMFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xyXG4gIH1cclxuICBzdGF0aWMgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHN0YXRpYyBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xyXG4gIH1cclxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcclxuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZXN0YW1wLCBhLCBiKTtcclxuICB9XHJcbn1cclxuVGltZXN0YW1wLnJ1bnRpbWUgPSBwcm90bzM7XHJcblRpbWVzdGFtcC50eXBlTmFtZSA9IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiO1xyXG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzZWNvbmRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibmFub3NcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDUgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59XSk7XHJcblxyXG5jb25zdCBNZXRyaWNzQmF0Y2ggPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NZXRyaWNzQmF0Y2hcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRpbWVzdGFtcF9tc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibm9ybWFsaXplZF90aW1lc3RhbXBcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUaW1lc3RhbXBcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic3RyX2RhdGFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwidGltZV9zZXJpZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUaW1lU2VyaWVzTWV0cmljLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImV2ZW50c1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IEV2ZW50TWV0cmljLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVGltZVNlcmllc01ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVTZXJpZXNNZXRyaWNcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImxhYmVsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJzYW1wbGVzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogTWV0cmljU2FtcGxlLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcInJpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IE1ldHJpY1NhbXBsZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY1NhbXBsZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVzdGFtcFxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ2YWx1ZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMlxyXG4gIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cclxufV0pO1xyXG5jb25zdCBFdmVudE1ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkV2ZW50TWV0cmljXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJsYWJlbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwic3RhcnRfdGltZXN0YW1wX21zXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJlbmRfdGltZXN0YW1wX21zXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzLFxyXG4gIG9wdDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJub3JtYWxpemVkX3N0YXJ0X3RpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVzdGFtcFxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJub3JtYWxpemVkX2VuZF90aW1lc3RhbXBcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUaW1lc3RhbXAsXHJcbiAgb3B0OiB0cnVlXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwicmlkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgQmFja3VwQ29kZWNQb2xpY3kkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQmFja3VwQ29kZWNQb2xpY3lcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlBSRUZFUl9SRUdSRVNTSU9OXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiU0lNVUxDQVNUXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiUkVHUkVTU0lPTlwiXHJcbn1dKTtcclxuY29uc3QgVHJhY2tUeXBlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5UcmFja1R5cGVcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIkFVRElPXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiVklERU9cIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJEQVRBXCJcclxufV0pO1xyXG5jb25zdCBUcmFja1NvdXJjZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVHJhY2tTb3VyY2VcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlVOS05PV05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJDQU1FUkFcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJNSUNST1BIT05FXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiU0NSRUVOX1NIQVJFXCJcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiU0NSRUVOX1NIQVJFX0FVRElPXCJcclxufV0pO1xyXG5jb25zdCBWaWRlb1F1YWxpdHkkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVmlkZW9RdWFsaXR5XCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJMT1dcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJNRURJVU1cIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJISUdIXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiT0ZGXCJcclxufV0pO1xyXG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eSQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiUE9PUlwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkdPT0RcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJFWENFTExFTlRcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJMT1NUXCJcclxufV0pO1xyXG5jb25zdCBDbGllbnRDb25maWdTZXR0aW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJVTlNFVFwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkRJU0FCTEVEXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiRU5BQkxFRFwiXHJcbn1dKTtcclxuY29uc3QgRGlzY29ubmVjdFJlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiVU5LTk9XTl9SRUFTT05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJDTElFTlRfSU5JVElBVEVEXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiRFVQTElDQVRFX0lERU5USVRZXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiU0VSVkVSX1NIVVRET1dOXCJcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiUEFSVElDSVBBTlRfUkVNT1ZFRFwiXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIlJPT01fREVMRVRFRFwiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcIlNUQVRFX01JU01BVENIXCJcclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiSk9JTl9GQUlMVVJFXCJcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiTUlHUkFUSU9OXCJcclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwiU0lHTkFMX0NMT1NFXCJcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcIlJPT01fQ0xPU0VEXCJcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcIlVTRVJfVU5BVkFJTEFCTEVcIlxyXG59LCB7XHJcbiAgbm86IDEyLFxyXG4gIG5hbWU6IFwiVVNFUl9SRUpFQ1RFRFwiXHJcbn0sIHtcclxuICBubzogMTMsXHJcbiAgbmFtZTogXCJTSVBfVFJVTktfRkFJTFVSRVwiXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJDT05ORUNUSU9OX1RJTUVPVVRcIlxyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwiTUVESUFfRkFJTFVSRVwiXHJcbn1dKTtcclxuY29uc3QgUmVjb25uZWN0UmVhc29uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5SZWNvbm5lY3RSZWFzb25cIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlJSX1VOS05PV05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIlJSX1NVQlNDUklCRVJfRkFJTEVEXCJcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwiXHJcbn1dKTtcclxuY29uc3QgU3Vic2NyaXB0aW9uRXJyb3IgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN1YnNjcmlwdGlvbkVycm9yXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJTRV9VTktOT1dOXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiU0VfQ09ERUNfVU5TVVBQT1JURURcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJTRV9UUkFDS19OT1RGT1VORFwiXHJcbn1dKTtcclxuY29uc3QgQXVkaW9UcmFja0ZlYXR1cmUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkF1ZGlvVHJhY2tGZWF0dXJlXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJURl9TVEVSRU9cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJURl9OT19EVFhcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJURl9BVVRPX0dBSU5fQ09OVFJPTFwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OXCJcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiVEZfTk9JU0VfU1VQUFJFU1NJT05cIlxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJURl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT05cIlxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJURl9QUkVDT05ORUNUX0JVRkZFUlwiXHJcbn1dKTtcclxuY29uc3QgUm9vbSQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUm9vbVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcImRlcGFydHVyZV90aW1lb3V0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiY3JlYXRpb25fdGltZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInR1cm5fcGFzc3dvcmRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJlbmFibGVkX2NvZGVjc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENvZGVjLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwibnVtX3B1Ymxpc2hlcnNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcImFjdGl2ZV9yZWNvcmRpbmdcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcInZlcnNpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUaW1lZFZlcnNpb25cclxufV0pO1xyXG5jb25zdCBDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNvZGVjXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJtaW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiZm10cF9saW5lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudFBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiY2FuX3B1Ymxpc2hfZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9zb3VyY2VzXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJoaWRkZW5cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwicmVjb3JkZXJcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcImNhbl91cGRhdGVfbWV0YWRhdGFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcImFnZW50XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJjYW5fc3Vic2NyaWJlX21ldHJpY3NcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInNpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImlkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic3RhdGVcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX1N0YXRlKVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ0cmFja3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFja0luZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJqb2luZWRfYXRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogMTcsXHJcbiAgbmFtZTogXCJqb2luZWRfYXRfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcIm5hbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwicGVybWlzc2lvblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvblxyXG59LCB7XHJcbiAgbm86IDEyLFxyXG4gIG5hbWU6IFwicmVnaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcImlzX3B1Ymxpc2hlclwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDE0LFxyXG4gIG5hbWU6IFwia2luZFwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fS2luZClcclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcclxuICBraW5kOiBcIm1hcFwiLFxyXG4gIEs6IDksXHJcbiAgVjoge1xyXG4gICAga2luZDogXCJzY2FsYXJcIixcclxuICAgIFQ6IDlcclxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbiAgfVxyXG59LCB7XHJcbiAgbm86IDE2LFxyXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9yZWFzb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbilcclxufSwge1xyXG4gIG5vOiAxOCxcclxuICBuYW1lOiBcImtpbmRfZGV0YWlsc1wiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fS2luZERldGFpbCksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudEluZm9fU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiSk9JTklOR1wiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkpPSU5FRFwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkFDVElWRVwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIkRJU0NPTk5FQ1RFRFwiXHJcbn1dKTtcclxuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJTVEFOREFSRFwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIklOR1JFU1NcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJFR1JFU1NcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJTSVBcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJBR0VOVFwiXHJcbn1dKTtcclxuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmREZXRhaWwgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kRGV0YWlsXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJDTE9VRF9BR0VOVFwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkZPUldBUkRFRFwiXHJcbn1dKTtcclxuY29uc3QgRW5jcnlwdGlvbl9UeXBlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGVcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIk5PTkVcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJHQ01cIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJDVVNUT01cIlxyXG59XSk7XHJcbmNvbnN0IFNpbXVsY2FzdENvZGVjSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibWlkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiY2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwibGF5ZXJzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVmlkZW9MYXllcixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFRyYWNrSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrSW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidHlwZVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIm5hbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJtdXRlZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJ3aWR0aFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJoZWlnaHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwic2ltdWxjYXN0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcInNvdXJjZVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSlcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcImxheWVyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFZpZGVvTGF5ZXIsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJtaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwiY29kZWNzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2ltdWxjYXN0Q29kZWNJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJzdGVyZW9cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMTYsXHJcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcclxufSwge1xyXG4gIG5vOiAxNyxcclxuICBuYW1lOiBcInN0cmVhbVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTgsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVGltZWRWZXJzaW9uXHJcbn0sIHtcclxuICBubzogMTksXHJcbiAgbmFtZTogXCJhdWRpb19mZWF0dXJlc1wiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAyMCxcclxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQmFja3VwQ29kZWNQb2xpY3kkMSlcclxufV0pO1xyXG5jb25zdCBWaWRlb0xheWVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9MYXllclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkkMSlcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwid2lkdGhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImJpdHJhdGVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwic3NyY1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IERhdGFQYWNrZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhUGFja2V0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJraW5kXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFQYWNrZXRfS2luZClcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInVzZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBVc2VyUGFja2V0LFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic3BlYWtlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IEFjdGl2ZVNwZWFrZXJVcGRhdGUsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJzaXBfZHRtZlwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNpcERUTUYsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJ0cmFuc2NyaXB0aW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhbnNjcmlwdGlvbixcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcIm1ldHJpY3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBNZXRyaWNzQmF0Y2gsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJjaGF0X21lc3NhZ2VcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDaGF0TWVzc2FnZSxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJycGNfcmVxdWVzdFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJwY1JlcXVlc3QsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwicnBjX2Fja1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJwY0FjayxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJycGNfcmVzcG9uc2VcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBScGNSZXNwb25zZSxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTMsXHJcbiAgbmFtZTogXCJzdHJlYW1faGVhZGVyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRGF0YVN0cmVhbV9IZWFkZXIsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDE0LFxyXG4gIG5hbWU6IFwic3RyZWFtX2NodW5rXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRGF0YVN0cmVhbV9DaHVuayxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTUsXHJcbiAgbmFtZTogXCJzdHJlYW1fdHJhaWxlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IERhdGFTdHJlYW1fVHJhaWxlcixcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTYsXHJcbiAgbmFtZTogXCJzZXF1ZW5jZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDE3LFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBEYXRhUGFja2V0X0tpbmQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRhdGFQYWNrZXQuS2luZFwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiUkVMSUFCTEVcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJMT1NTWVwiXHJcbn1dKTtcclxuY29uc3QgQWN0aXZlU3BlYWtlclVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFjdGl2ZVNwZWFrZXJVcGRhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInNwZWFrZXJzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3BlYWtlckluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBTcGVha2VySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNwZWFrZXJJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJsZXZlbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMlxyXG4gIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiYWN0aXZlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn1dKTtcclxuY29uc3QgVXNlclBhY2tldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVzZXJQYWNrZXRcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTJcclxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImRlc3RpbmF0aW9uX3NpZHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ0b3BpY1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgb3B0OiB0cnVlXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcInN0YXJ0X3RpbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDQsXHJcbiAgb3B0OiB0cnVlXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJlbmRfdGltZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNCxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcIm5vbmNlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxMlxyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cclxufV0pO1xyXG5jb25zdCBTaXBEVE1GID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lwRFRNRlwiLCAoKSA9PiBbe1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiY29kZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJkaWdpdFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgVHJhbnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYW5zY3JpcHRpb25cIiwgKCkgPT4gW3tcclxuICBubzogMixcclxuICBuYW1lOiBcInRyYW5zY3JpYmVkX3BhcnRpY2lwYW50X2lkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidHJhY2tfaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJzZWdtZW50c1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYW5zY3JpcHRpb25TZWdtZW50LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVHJhbnNjcmlwdGlvblNlZ21lbnQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFuc2NyaXB0aW9uU2VnbWVudFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0ZXh0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNFxyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImVuZF90aW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA0XHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiZmluYWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwibGFuZ3VhZ2VcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IENoYXRNZXNzYWdlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2hhdE1lc3NhZ2VcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImlkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJlZGl0X3RpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMyxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwibWVzc2FnZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImRlbGV0ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn1dKTtcclxuY29uc3QgUnBjUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1JlcXVlc3RcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImlkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibWV0aG9kXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInJlc3BvbnNlX3RpbWVvdXRfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IFJwY0FjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY0Fja1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgUnBjUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNSZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInBheWxvYWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJlcnJvclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJwY0Vycm9yJDEsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59XSk7XHJcbmNvbnN0IFJwY0Vycm9yJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNFcnJvclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY29kZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgUGFydGljaXBhbnRUcmFja3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFNlcnZlckluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TZXJ2ZXJJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJlZGl0aW9uXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInByb3RvY29sXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA1XHJcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJyZWdpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJub2RlX2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiZGVidWdfaW5mb1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImFnZW50X3Byb3RvY29sXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA1XHJcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IFNlcnZlckluZm9fRWRpdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2VydmVySW5mby5FZGl0aW9uXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJTdGFuZGFyZFwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkNsb3VkXCJcclxufV0pO1xyXG5jb25zdCBDbGllbnRJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2xpZW50SW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic2RrXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDVcclxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIm9zXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwib3NfdmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcImRldmljZV9tb2RlbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImJyb3dzZXJcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJhZGRyZXNzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcIm5ldHdvcmtcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwib3RoZXJfc2Rrc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgQ2xpZW50SW5mb19TREsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudEluZm8uU0RLXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJVTktOT1dOXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiSlNcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJTV0lGVFwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIkFORFJPSURcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJGTFVUVEVSXCJcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiR09cIlxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJVTklUWVwiXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcIlJFQUNUX05BVElWRVwiXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcIlJVU1RcIlxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJQWVRIT05cIlxyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwiQ1BQXCJcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcIlVOSVRZX1dFQlwiXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJOT0RFXCJcclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcIlVOUkVBTFwiXHJcbn1dKTtcclxuY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInZpZGVvXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInNjcmVlblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFZpZGVvQ29uZmlndXJhdGlvblxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJyZXN1bWVfY29ubmVjdGlvblwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJkaXNhYmxlZF9jb2RlY3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEaXNhYmxlZENvZGVjc1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJmb3JjZV9yZWxheVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxyXG59XSk7XHJcbmNvbnN0IFZpZGVvQ29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlZpZGVvQ29uZmlndXJhdGlvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiaGFyZHdhcmVfZW5jb2RlclwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxyXG59XSk7XHJcbmNvbnN0IERpc2FibGVkQ29kZWNzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGlzYWJsZWRDb2RlY3NcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNvZGVjc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENvZGVjLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInB1Ymxpc2hcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDb2RlYyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFRpbWVkVmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVkVmVyc2lvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidW5peF9taWNyb1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidGlja3NcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDVcclxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn1dKTtcclxuY29uc3QgRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5EYXRhU3RyZWFtLk9wZXJhdGlvblR5cGVcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIkNSRUFURVwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIlVQREFURVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkRFTEVURVwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIlJFQUNUSU9OXCJcclxufV0pO1xyXG5jb25zdCBEYXRhU3RyZWFtX1RleHRIZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLlRleHRIZWFkZXJcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcIm9wZXJhdGlvbl90eXBlXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSlcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwicmVwbHlfdG9fc3RyZWFtX2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiYXR0YWNoZWRfc3RyZWFtX2lkc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJnZW5lcmF0ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0sIHtcclxuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9UZXh0SGVhZGVyXCJcclxufSk7XHJcbmNvbnN0IERhdGFTdHJlYW1fQnl0ZUhlYWRlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uQnl0ZUhlYWRlclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dLCB7XHJcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQnl0ZUhlYWRlclwiXHJcbn0pO1xyXG5jb25zdCBEYXRhU3RyZWFtX0hlYWRlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uSGVhZGVyXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzdHJlYW1faWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInRvcGljXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwidG90YWxfbGVuZ3RoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA0LFxyXG4gIG9wdDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJlbmNyeXB0aW9uX3R5cGVcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXHJcbiAga2luZDogXCJtYXBcIixcclxuICBLOiA5LFxyXG4gIFY6IHtcclxuICAgIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgICBUOiA5XHJcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG4gIH1cclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwidGV4dF9oZWFkZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEYXRhU3RyZWFtX1RleHRIZWFkZXIsXHJcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwiYnl0ZV9oZWFkZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEYXRhU3RyZWFtX0J5dGVIZWFkZXIsXHJcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxyXG59XSwge1xyXG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0hlYWRlclwiXHJcbn0pO1xyXG5jb25zdCBEYXRhU3RyZWFtX0NodW5rID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5DaHVua1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiY2h1bmtfaW5kZXhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDRcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJjb250ZW50XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxMlxyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiaXZcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEyLFxyXG4gIG9wdDogdHJ1ZVxyXG59XSwge1xyXG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX0NodW5rXCJcclxufSk7XHJcbmNvbnN0IERhdGFTdHJlYW1fVHJhaWxlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uVHJhaWxlclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicmVhc29uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxyXG4gIGtpbmQ6IFwibWFwXCIsXHJcbiAgSzogOSxcclxuICBWOiB7XHJcbiAgICBraW5kOiBcInNjYWxhclwiLFxyXG4gICAgVDogOVxyXG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxuICB9XHJcbn1dLCB7XHJcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fVHJhaWxlclwiXHJcbn0pO1xyXG5jb25zdCBTaWduYWxUYXJnZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlNpZ25hbFRhcmdldFwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiUFVCTElTSEVSXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiU1VCU0NSSUJFUlwiXHJcbn1dKTtcclxuY29uc3QgU3RyZWFtU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJBQ1RJVkVcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJQQVVTRURcIlxyXG59XSk7XHJcbmNvbnN0IENhbmRpZGF0ZVByb3RvY29sID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5DYW5kaWRhdGVQcm90b2NvbFwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiVURQXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiVENQXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiVExTXCJcclxufV0pO1xyXG5jb25zdCBTaWduYWxSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lnbmFsUmVxdWVzdFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwib2ZmZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImFuc3dlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidHJpY2tsZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJhZGRfdHJhY2tcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBBZGRUcmFja1JlcXVlc3QsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIm11dGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb24sXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcInRyYWNrX3NldHRpbmdcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBVcGRhdGVUcmFja1NldHRpbmdzLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJsZWF2ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IExlYXZlUmVxdWVzdCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcInVwZGF0ZV9sYXllcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBVcGRhdGVWaWRlb0xheWVycyxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvbixcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcInN5bmNfc3RhdGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTeW5jU3RhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTMsXHJcbiAgbmFtZTogXCJzaW11bGF0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNpbXVsYXRlU2NlbmFyaW8sXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJwaW5nXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNixcclxuICBuYW1lOiBcInBpbmdfcmVxXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGluZyxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNyxcclxuICBuYW1lOiBcInVwZGF0ZV9hdWRpb190cmFja1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxOCxcclxuICBuYW1lOiBcInVwZGF0ZV92aWRlb190cmFja1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufV0pO1xyXG5jb25zdCBTaWduYWxSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpZ25hbFJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJqb2luXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogSm9pblJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJhbnN3ZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIm9mZmVyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ0cmlja2xlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJpY2tsZVJlcXVlc3QsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcInVwZGF0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFBhcnRpY2lwYW50VXBkYXRlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJ0cmFja19wdWJsaXNoZWRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJsZWF2ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IExlYXZlUmVxdWVzdCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwibXV0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJzcGVha2Vyc19jaGFuZ2VkXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3BlYWtlcnNDaGFuZ2VkLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwicm9vbV91cGRhdGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBSb29tVXBkYXRlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDEyLFxyXG4gIG5hbWU6IFwiY29ubmVjdGlvbl9xdWFsaXR5XCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTMsXHJcbiAgbmFtZTogXCJzdHJlYW1fc3RhdGVfdXBkYXRlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3RyZWFtU3RhdGVVcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdHlfdXBkYXRlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTUsXHJcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE2LFxyXG4gIG5hbWU6IFwicmVmcmVzaF90b2tlblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNyxcclxuICBuYW1lOiBcInRyYWNrX3VucHVibGlzaGVkXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE4LFxyXG4gIG5hbWU6IFwicG9uZ1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMyxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxOSxcclxuICBuYW1lOiBcInJlY29ubmVjdFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJlY29ubmVjdFJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDIwLFxyXG4gIG5hbWU6IFwicG9uZ19yZXNwXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUG9uZyxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAyMSxcclxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9yZXNwb25zZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN1YnNjcmlwdGlvblJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDIyLFxyXG4gIG5hbWU6IFwicmVxdWVzdF9yZXNwb25zZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJlcXVlc3RSZXNwb25zZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAyMyxcclxuICBuYW1lOiBcInRyYWNrX3N1YnNjcmliZWRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFja1N1YnNjcmliZWQsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMjQsXHJcbiAgbmFtZTogXCJyb29tX21vdmVkXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUm9vbU1vdmVkUmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn1dKTtcclxuY29uc3QgU2ltdWxjYXN0Q29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY29kZWNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJjaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IEFkZFRyYWNrUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkFkZFRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInR5cGVcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ3aWR0aFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJoZWlnaHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwibXV0ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwic291cmNlXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJsYXllcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBWaWRlb0xheWVyLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJzaW11bGNhc3RfY29kZWNzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2ltdWxjYXN0Q29kZWMsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcInNpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJzdGVyZW9cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcImRpc2FibGVfcmVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJlbmNyeXB0aW9uXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcInN0cmVhbVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTYsXHJcbiAgbmFtZTogXCJiYWNrdXBfY29kZWNfcG9saWN5XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5JDEpXHJcbn0sIHtcclxuICBubzogMTcsXHJcbiAgbmFtZTogXCJhdWRpb19mZWF0dXJlc1wiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBUcmlja2xlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidGFyZ2V0XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZmluYWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBNdXRlVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibXV0ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBKb2luUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Kb2luUmVzcG9uc2VcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInJvb21cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBSb29tJDFcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQYXJ0aWNpcGFudEluZm9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInNlcnZlcl92ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBJQ0VTZXJ2ZXIsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwic3Vic2NyaWJlcl9wcmltYXJ5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImFsdGVybmF0aXZlX3VybFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImNsaWVudF9jb25maWd1cmF0aW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogQ2xpZW50Q29uZmlndXJhdGlvblxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcInBpbmdfdGltZW91dFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAxMSxcclxuICBuYW1lOiBcInBpbmdfaW50ZXJ2YWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDVcclxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNlcnZlckluZm9cclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcInNpZl90cmFpbGVyXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxMlxyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcImVuYWJsZWRfcHVibGlzaF9jb2RlY3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDb2RlYyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwiZmFzdF9wdWJsaXNoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn1dKTtcclxuY29uc3QgUmVjb25uZWN0UmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBJQ0VTZXJ2ZXIsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInNlcnZlcl9pbmZvXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2VydmVySW5mb1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJsYXN0X21lc3NhZ2Vfc2VxXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrUHVibGlzaGVkUmVzcG9uc2VcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRyYWNrXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhY2tJbmZvXHJcbn1dKTtcclxuY29uc3QgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IFNlc3Npb25EZXNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNlc3Npb25EZXNjcmlwdGlvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHlwZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInNkcFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgUGFydGljaXBhbnRVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInN1YnNjcmliZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQYXJ0aWNpcGFudFRyYWNrcyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFVwZGF0ZVRyYWNrU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVUcmFja1NldHRpbmdzXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImRpc2FibGVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInF1YWxpdHlcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIndpZHRoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcImhlaWdodFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJmcHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwicHJpb3JpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBVcGRhdGVMb2NhbEF1ZGlvVHJhY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVMb2NhbEF1ZGlvVHJhY2tcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImZlYXR1cmVzXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsVmlkZW9UcmFja1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwid2lkdGhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgTGVhdmVSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuTGVhdmVSZXF1ZXN0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInJlYXNvblwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJhY3Rpb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoTGVhdmVSZXF1ZXN0X0FjdGlvbilcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicmVnaW9uc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJlZ2lvblNldHRpbmdzXHJcbn1dKTtcclxuY29uc3QgTGVhdmVSZXF1ZXN0X0FjdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuTGVhdmVSZXF1ZXN0LkFjdGlvblwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiRElTQ09OTkVDVFwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIlJFU1VNRVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIlJFQ09OTkVDVFwiXHJcbn1dKTtcclxuY29uc3QgVXBkYXRlVmlkZW9MYXllcnMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibGF5ZXJzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVmlkZW9MYXllcixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIm5hbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXHJcbiAga2luZDogXCJtYXBcIixcclxuICBLOiA5LFxyXG4gIFY6IHtcclxuICAgIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgICBUOiA5XHJcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG4gIH1cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IElDRVNlcnZlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LklDRVNlcnZlclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidXJsc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ1c2VybmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImNyZWRlbnRpYWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IFNwZWFrZXJzQ2hhbmdlZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTcGVha2VySW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFJvb21VcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tVXBkYXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyb29tXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUm9vbSQxXHJcbn1dKTtcclxuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJxdWFsaXR5XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5JDEpXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInNjb3JlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAyXHJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xyXG59XSk7XHJcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInVwZGF0ZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBTdHJlYW1TdGF0ZUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInN0YXRlXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN0cmVhbVN0YXRlKVxyXG59XSk7XHJcbmNvbnN0IFN0cmVhbVN0YXRlVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdHJlYW1TdGF0ZUluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBTdWJzY3JpYmVkUXVhbGl0eSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJxdWFsaXR5XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJlbmFibGVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn1dKTtcclxuY29uc3QgU3Vic2NyaWJlZENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZENvZGVjXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjb2RlY1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInF1YWxpdGllc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9xdWFsaXRpZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJzdWJzY3JpYmVkX2NvZGVjc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN1YnNjcmliZWRDb2RlYyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFRyYWNrUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrUGVybWlzc2lvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiYWxsX3RyYWNrc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBTdWJzY3JpcHRpb25QZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0cmFja19wZXJtaXNzaW9uc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYWNrUGVybWlzc2lvbixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJhbGxvd2VkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn1dKTtcclxuY29uc3QgUm9vbU1vdmVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tTW92ZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicm9vbVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJvb20kMVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0b2tlblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRJbmZvXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFN5bmNTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN5bmNTdGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiYW5zd2VyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvblxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJwdWJsaXNoX3RyYWNrc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiZGF0YV9jaGFubmVsc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IERhdGFDaGFubmVsSW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJvZmZlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvblxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRzX2Rpc2FibGVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImRhdGFjaGFubmVsX3JlY2VpdmVfc3RhdGVzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRGF0YUNoYW5uZWxSZWNlaXZlU3RhdGUsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBEYXRhQ2hhbm5lbFJlY2VpdmVTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFDaGFubmVsUmVjZWl2ZVN0YXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwdWJsaXNoZXJfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibGFzdF9zZXFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBEYXRhQ2hhbm5lbEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhQ2hhbm5lbEluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImxhYmVsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidGFyZ2V0XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldClcclxufV0pO1xyXG5jb25zdCBTaW11bGF0ZVNjZW5hcmlvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDUsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJub2RlX2ZhaWx1cmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDgsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJtaWdyYXRpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDgsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJzZXJ2ZXJfbGVhdmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDgsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENhbmRpZGF0ZVByb3RvY29sKSxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInN1YnNjcmliZXJfYmFuZHdpZHRoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzLFxyXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4LFxyXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4LFxyXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwibGVhdmVfcmVxdWVzdF9mdWxsX3JlY29ubmVjdFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOCxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn1dKTtcclxuY29uc3QgUGluZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBpbmdcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicnR0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59XSk7XHJcbmNvbnN0IFBvbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Qb25nXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJsYXN0X3BpbmdfdGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn1dKTtcclxuY29uc3QgUmVnaW9uU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWdpb25TZXR0aW5nc1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicmVnaW9uc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJlZ2lvbkluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBSZWdpb25JbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVnaW9uSW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicmVnaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidXJsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZGlzdGFuY2VcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn1dKTtcclxuY29uc3QgU3Vic2NyaXB0aW9uUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiZXJyXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFN1YnNjcmlwdGlvbkVycm9yKVxyXG59XSk7XHJcbmNvbnN0IFJlcXVlc3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJyZWFzb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUmVxdWVzdFJlc3BvbnNlX1JlYXNvbilcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwibWVzc2FnZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlLlJlYXNvblwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiT0tcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJOT1RfRk9VTkRcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJOT1RfQUxMT1dFRFwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIkxJTUlUX0VYQ0VFREVEXCJcclxufV0pO1xyXG5jb25zdCBUcmFja1N1YnNjcmliZWQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1N1YnNjcmliZWRcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuXHJcbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XHJcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcclxufVxyXG5cclxudmFyIGxvZ2xldmVsJDEgPSB7ZXhwb3J0czoge319O1xyXG5cclxuLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxudmFyIGxvZ2xldmVsID0gbG9nbGV2ZWwkMS5leHBvcnRzO1xyXG52YXIgaGFzUmVxdWlyZWRMb2dsZXZlbDtcclxuZnVuY3Rpb24gcmVxdWlyZUxvZ2xldmVsKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZExvZ2xldmVsKSByZXR1cm4gbG9nbGV2ZWwkMS5leHBvcnRzO1xyXG4gIGhhc1JlcXVpcmVkTG9nbGV2ZWwgPSAxO1xyXG4gIChmdW5jdGlvbiAobW9kdWxlKSB7XHJcbiAgICAoZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcclxuXHJcbiAgICAgIGlmIChtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9KShsb2dsZXZlbCwgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxyXG4gICAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XHJcbiAgICAgIHZhciBpc0lFID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSAmJiAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgIHZhciBsb2dNZXRob2RzID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XHJcbiAgICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG51bGw7XHJcblxyXG4gICAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XHJcbiAgICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxyXG4gICAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xyXG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xyXG4gICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXHJcbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcclxuICAgICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXHJcbiAgICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XHJcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcclxuICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XHJcblxyXG4gICAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMoKSB7XHJcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cclxuICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmdldExldmVsKCk7XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xyXG4gICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGkgPCBsZXZlbCA/IG5vb3AgOiB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXHJcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gYW55IGltcG9ydGFudCB3YXJuaW5ncy5cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCB0aGlzLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXHJcbiAgICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXHJcbiAgICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxyXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxyXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XHJcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cclxuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fCBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcclxuICAgICAgICAvLyBQcml2YXRlIGluc3RhbmNlIHZhcmlhYmxlcy5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxldmVsIGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IGxvZ2dlciAob3IgYSBnbG9iYWwgZGVmYXVsdCkuIFdlXHJcbiAgICAgICAgICogY2FjaGUgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGRlbGVnYXRpbmcgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IHN0YXlzXHJcbiAgICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxyXG4gICAgICAgICAqIHBhcmVudCBjb3VsZCBjaGFuZ2UgbGV2ZWxzIGJ1dCB3ZSBtaWdodCBub3QgaGF2ZSByZWJ1aWx0IHRoZSBsb2dnZXJzXHJcbiAgICAgICAgICogaW4gdGhpcyBjaGlsZCB5ZXQpLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGluaGVyaXRlZExldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGZvciB0aGlzIGxvZ2dlciwgaWYgYW55LiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXHJcbiAgICAgICAgICogYGluaGVyaXRlZExldmVsYC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGRlZmF1bHRMZXZlbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHVzZXItc3BlY2lmaWMgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXHJcbiAgICAgICAgICogYGRlZmF1bHRMZXZlbGAuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB1c2VyTGV2ZWw7XHJcbiAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XHJcbiAgICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XHJcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xyXG4gICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xyXG4gICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKGNvb2tpZU5hbWUgKyBcIj1cIik7XHJcbiAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKSlbMV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cclxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcclxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcclxuICAgICAgICAgIHZhciBsZXZlbCA9IGlucHV0O1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZXZlbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGlucHV0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBzZWxmLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHNlbGYubGV2ZWxzID0ge1xyXG4gICAgICAgICAgXCJUUkFDRVwiOiAwLFxyXG4gICAgICAgICAgXCJERUJVR1wiOiAxLFxyXG4gICAgICAgICAgXCJJTkZPXCI6IDIsXHJcbiAgICAgICAgICBcIldBUk5cIjogMyxcclxuICAgICAgICAgIFwiRVJST1JcIjogNCxcclxuICAgICAgICAgIFwiU0lMRU5UXCI6IDVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XHJcbiAgICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICh1c2VyTGV2ZWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlckxldmVsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExldmVsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xyXG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xyXG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZSh1c2VyTGV2ZWwpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5PVEU6IGluIHYyLCB0aGlzIHNob3VsZCBjYWxsIHJlYnVpbGQoKSwgd2hpY2ggdXBkYXRlcyBjaGlsZHJlbi5cclxuICAgICAgICAgIHJldHVybiByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XHJcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcclxuICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcclxuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcclxuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xyXG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbiAocGVyc2lzdCkge1xyXG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5yZWJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcclxuICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XHJcbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciA9PT0gc2VsZikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjaGlsZE5hbWUgaW4gX2xvZ2dlcnNCeU5hbWUpIHtcclxuICAgICAgICAgICAgICBfbG9nZ2Vyc0J5TmFtZVtjaGlsZE5hbWVdLnJlYnVpbGQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIHRoZSBpbnRlcm5hbCBsZXZlbHMuXHJcbiAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyID8gZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpIDogXCJXQVJOXCIpO1xyXG4gICAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgICAgIGlmIChpbml0aWFsTGV2ZWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwoaW5pdGlhbExldmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRvcC1sZXZlbCBBUElcclxuICAgICAgICpcclxuICAgICAgICovXHJcblxyXG4gICAgICBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xyXG4gICAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XHJcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcclxuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihuYW1lLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgIHZhciBfbG9nID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XHJcbiAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XHJcbiAgICAgIH07XHJcbiAgICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxyXG4gICAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xyXG4gICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcclxuICAgIH0pO1xyXG4gIH0pKGxvZ2xldmVsJDEpO1xyXG4gIHJldHVybiBsb2dsZXZlbCQxLmV4cG9ydHM7XHJcbn1cclxuXHJcbnZhciBsb2dsZXZlbEV4cG9ydHMgPSByZXF1aXJlTG9nbGV2ZWwoKTtcclxuXHJcbnZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gIExvZ0xldmVsW0xvZ0xldmVsW1widHJhY2VcIl0gPSAwXSA9IFwidHJhY2VcIjtcclxuICBMb2dMZXZlbFtMb2dMZXZlbFtcImRlYnVnXCJdID0gMV0gPSBcImRlYnVnXCI7XHJcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJpbmZvXCJdID0gMl0gPSBcImluZm9cIjtcclxuICBMb2dMZXZlbFtMb2dMZXZlbFtcIndhcm5cIl0gPSAzXSA9IFwid2FyblwiO1xyXG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcclxuICBMb2dMZXZlbFtMb2dMZXZlbFtcInNpbGVudFwiXSA9IDVdID0gXCJzaWxlbnRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxudmFyIExvZ2dlck5hbWVzO1xyXG4oZnVuY3Rpb24gKExvZ2dlck5hbWVzKSB7XHJcbiAgTG9nZ2VyTmFtZXNbXCJEZWZhdWx0XCJdID0gXCJsaXZla2l0XCI7XHJcbiAgTG9nZ2VyTmFtZXNbXCJSb29tXCJdID0gXCJsaXZla2l0LXJvb21cIjtcclxuICBMb2dnZXJOYW1lc1tcIlBhcnRpY2lwYW50XCJdID0gXCJsaXZla2l0LXBhcnRpY2lwYW50XCI7XHJcbiAgTG9nZ2VyTmFtZXNbXCJUcmFja1wiXSA9IFwibGl2ZWtpdC10cmFja1wiO1xyXG4gIExvZ2dlck5hbWVzW1wiUHVibGljYXRpb25cIl0gPSBcImxpdmVraXQtdHJhY2stcHVibGljYXRpb25cIjtcclxuICBMb2dnZXJOYW1lc1tcIkVuZ2luZVwiXSA9IFwibGl2ZWtpdC1lbmdpbmVcIjtcclxuICBMb2dnZXJOYW1lc1tcIlNpZ25hbFwiXSA9IFwibGl2ZWtpdC1zaWduYWxcIjtcclxuICBMb2dnZXJOYW1lc1tcIlBDTWFuYWdlclwiXSA9IFwibGl2ZWtpdC1wYy1tYW5hZ2VyXCI7XHJcbiAgTG9nZ2VyTmFtZXNbXCJQQ1RyYW5zcG9ydFwiXSA9IFwibGl2ZWtpdC1wYy10cmFuc3BvcnRcIjtcclxuICBMb2dnZXJOYW1lc1tcIkUyRUVcIl0gPSBcImxrLWUyZWVcIjtcclxufSkoTG9nZ2VyTmFtZXMgfHwgKExvZ2dlck5hbWVzID0ge30pKTtcclxubGV0IGxpdmVraXRMb2dnZXIgPSBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsaXZla2l0Jyk7XHJcbmNvbnN0IGxpdmVraXRMb2dnZXJzID0gT2JqZWN0LnZhbHVlcyhMb2dnZXJOYW1lcykubWFwKG5hbWUgPT4gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKSk7XHJcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xyXG4gIGNvbnN0IGxvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIobmFtZSk7XHJcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xyXG4gIHJldHVybiBsb2dnZXI7XHJcbn1cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcclxuICBpZiAobG9nZ2VyTmFtZSkge1xyXG4gICAgbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihsb2dnZXJOYW1lKS5zZXRMZXZlbChsZXZlbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGZvciAoY29uc3QgbG9nZ2VyIG9mIGxpdmVraXRMb2dnZXJzKSB7XHJcbiAgICAgIGxvZ2dlci5zZXRMZXZlbChsZXZlbCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcclxuICogaWYgc2V0LCB0aGUgYnJvd3NlciBsb2dzIHdpbGwgbG9zZSB0aGVpciBzdGFja3RyYWNlIGluZm9ybWF0aW9uIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsI3dyaXRpbmctcGx1Z2lucylcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0V4dGVuc2lvbihleHRlbnNpb24sIGxvZ2dlcikge1xyXG4gIGNvbnN0IGxvZ2dlcnMgPSBsb2dnZXIgPyBbbG9nZ2VyXSA6IGxpdmVraXRMb2dnZXJzO1xyXG4gIGxvZ2dlcnMuZm9yRWFjaChsb2dSID0+IHtcclxuICAgIGNvbnN0IG9yaWdpbmFsRmFjdG9yeSA9IGxvZ1IubWV0aG9kRmFjdG9yeTtcclxuICAgIGxvZ1IubWV0aG9kRmFjdG9yeSA9IChtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSkgPT4ge1xyXG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xyXG4gICAgICBjb25zdCBsb2dMZXZlbCA9IExvZ0xldmVsW21ldGhvZE5hbWVdO1xyXG4gICAgICBjb25zdCBuZWVkTG9nID0gbG9nTGV2ZWwgPj0gY29uZmlnTGV2ZWwgJiYgbG9nTGV2ZWwgPCBMb2dMZXZlbC5zaWxlbnQ7XHJcbiAgICAgIHJldHVybiAobXNnLCBjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbnRleHQpIHJhd01ldGhvZChtc2csIGNvbnRleHQpO2Vsc2UgcmF3TWV0aG9kKG1zZyk7XHJcbiAgICAgICAgaWYgKG5lZWRMb2cpIHtcclxuICAgICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgbG9nUi5zZXRMZXZlbChsb2dSLmdldExldmVsKCkpO1xyXG4gIH0pO1xyXG59XHJcbmNvbnN0IHdvcmtlckxvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xrLWUyZWUnKTtcclxuXHJcbmNvbnN0IG1heFJldHJ5RGVsYXkgPSA3MDAwO1xyXG5jb25zdCBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyA9IFswLCAzMDAsIDIgKiAyICogMzAwLCAzICogMyAqIDMwMCwgNCAqIDQgKiAzMDAsIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXksIG1heFJldHJ5RGVsYXldO1xyXG5jbGFzcyBEZWZhdWx0UmVjb25uZWN0UG9saWN5IHtcclxuICBjb25zdHJ1Y3RvcihyZXRyeURlbGF5cykge1xyXG4gICAgdGhpcy5fcmV0cnlEZWxheXMgPSByZXRyeURlbGF5cyAhPT0gdW5kZWZpbmVkID8gWy4uLnJldHJ5RGVsYXlzXSA6IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TO1xyXG4gIH1cclxuICBuZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCkge1xyXG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA+PSB0aGlzLl9yZXRyeURlbGF5cy5sZW5ndGgpIHJldHVybiBudWxsO1xyXG4gICAgY29uc3QgcmV0cnlEZWxheSA9IHRoaXMuX3JldHJ5RGVsYXlzW2NvbnRleHQucmV0cnlDb3VudF07XHJcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50IDw9IDEpIHJldHVybiByZXRyeURlbGF5O1xyXG4gICAgcmV0dXJuIHJldHJ5RGVsYXkgKyBNYXRoLnJhbmRvbSgpICogMTAwMDtcclxuICB9XHJcbn1cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wsIEl0ZXJhdG9yICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XHJcblxyXG52YXIgZXZlbnRzID0ge2V4cG9ydHM6IHt9fTtcclxuXHJcbnZhciBoYXNSZXF1aXJlZEV2ZW50cztcclxuZnVuY3Rpb24gcmVxdWlyZUV2ZW50cygpIHtcclxuICBpZiAoaGFzUmVxdWlyZWRFdmVudHMpIHJldHVybiBldmVudHMuZXhwb3J0cztcclxuICBoYXNSZXF1aXJlZEV2ZW50cyA9IDE7XHJcbiAgdmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbDtcclxuICB2YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJyA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xyXG4gIH07XHJcbiAgdmFyIFJlZmxlY3RPd25LZXlzO1xyXG4gIGlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzO1xyXG4gIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xyXG4gICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XHJcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcclxuICB9XHJcbiAgdmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xyXG4gIH07XHJcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG4gICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcclxuICB9XHJcbiAgZXZlbnRzLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcbiAgZXZlbnRzLmV4cG9ydHMub25jZSA9IG9uY2U7XHJcblxyXG4gIC8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxyXG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxyXG4gIC8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXHJcbiAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcclxuICBmdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xyXG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xyXG4gIH07XHJcblxyXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xyXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcclxuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcclxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcclxuICAgIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xyXG4gICAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XHJcbiAgICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcclxuICB9O1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcclxuICAgIHZhciBkb0Vycm9yID0gdHlwZSA9PT0gJ2Vycm9yJztcclxuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XHJcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxyXG4gICAgaWYgKGRvRXJyb3IpIHtcclxuICAgICAgdmFyIGVyO1xyXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSBlciA9IGFyZ3NbMF07XHJcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XHJcbiAgICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cclxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcclxuICAgICAgfVxyXG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXHJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xyXG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xyXG4gICAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XHJcbiAgICB9XHJcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcclxuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcclxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XHJcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xyXG4gICAgdmFyIG07XHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgdmFyIGV4aXN0aW5nO1xyXG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcclxuICAgICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxyXG4gICAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXHJcbiAgICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxyXG4gICAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xyXG4gICAgICB9XHJcbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXHJcbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XHJcbiAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cclxuICAgICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xyXG4gICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cclxuICAgICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXHJcbiAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XHJcbiAgICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcclxuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XHJcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcclxuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcclxuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XHJcbiAgICAgICAgdy50eXBlID0gdHlwZTtcclxuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xyXG4gICAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgfTtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcclxuICAgIGlmICghdGhpcy5maXJlZCkge1xyXG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcclxuICAgICAgdGhpcy5maXJlZCA9IHRydWU7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcclxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgc3RhdGUgPSB7XHJcbiAgICAgIGZpcmVkOiBmYWxzZSxcclxuICAgICAgd3JhcEZuOiB1bmRlZmluZWQsXHJcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcclxuICAgIH07XHJcbiAgICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xyXG4gICAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcclxuICAgIHJldHVybiB3cmFwcGVkO1xyXG4gIH1cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XHJcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XHJcbiAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XHJcbiAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcclxuICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcG9zaXRpb24gPSAtMTtcclxuICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XHJcbiAgICAgICAgICBwb3NpdGlvbiA9IGk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBvc2l0aW9uIDwgMCkgcmV0dXJuIHRoaXM7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpO2Vsc2Uge1xyXG4gICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xyXG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcclxuICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxyXG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIGRlbGV0ZSBldmVudHNbdHlwZV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XHJcbiAgICAgIHZhciBrZXk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xyXG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xyXG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBMSUZPIG9yZGVyXHJcbiAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XHJcbiAgICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XHJcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcclxuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xyXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XHJcbiAgICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XHJcbiAgfVxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcclxuICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xyXG4gIH07XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xyXG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xyXG4gIH07XHJcbiAgRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xyXG4gIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xyXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcclxuICAgICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XHJcbiAgfTtcclxuICBmdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xyXG4gICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgY29weVtpXSA9IGFycltpXTtcclxuICAgIHJldHVybiBjb3B5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcclxuICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XHJcbiAgICBsaXN0LnBvcCgpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XHJcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcclxuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuICAgICAgfVxyXG4gICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHtcclxuICAgICAgICBvbmNlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xyXG4gICAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHtcclxuICAgICAgICAgIG9uY2U6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XHJcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xyXG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XHJcbiAgICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXHJcbiAgICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXHJcbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XHJcbiAgICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxyXG4gICAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXHJcbiAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcclxuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXN0ZW5lcihhcmcpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBldmVudHMuZXhwb3J0cztcclxufVxyXG5cclxudmFyIGV2ZW50c0V4cG9ydHMgPSByZXF1aXJlRXZlbnRzKCk7XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcblxyXG5sZXQgbG9nRGlzYWJsZWRfID0gdHJ1ZTtcclxubGV0IGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0geyFzdHJpbmd9IHVhc3RyaW5nIHVzZXJBZ2VudCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cclxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBicm93c2VyIHZlcnNpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XHJcbiAgY29uc3QgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcclxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUZsb2F0KG1hdGNoW3Bvc10sIDEwKTtcclxufVxyXG5cclxuLy8gV3JhcHMgdGhlIHBlZXJjb25uZWN0aW9uIGV2ZW50IGV2ZW50TmFtZVRvV3JhcCBpbiBhIGZ1bmN0aW9uXHJcbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxyXG4vLyB0aGUgZXZlbnQpLlxyXG5mdW5jdGlvbiB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csIGV2ZW50TmFtZVRvV3JhcCwgd3JhcHBlcikge1xyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxuICBjb25zdCBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcjtcclxuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcclxuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCkge1xyXG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xyXG4gICAgICBpZiAobW9kaWZpZWRFdmVudCkge1xyXG4gICAgICAgIGlmIChjYi5oYW5kbGVFdmVudCkge1xyXG4gICAgICAgICAgY2IuaGFuZGxlRXZlbnQobW9kaWZpZWRFdmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuX2V2ZW50TWFwID0gdGhpcy5fZXZlbnRNYXAgfHwge307XHJcbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcclxuICAgICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2V0KGNiLCB3cmFwcGVkQ2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XHJcbiAgfTtcclxuICBjb25zdCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcclxuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXAgfHwgIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcclxuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5oYXMoY2IpKSB7XHJcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1bndyYXBwZWRDYiA9IHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZ2V0KGNiKTtcclxuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZGVsZXRlKGNiKTtcclxuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcclxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF07XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB1bndyYXBwZWRDYl0pO1xyXG4gIH07XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb24nICsgZXZlbnROYW1lVG9XcmFwLCB7XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcclxuICAgIH0sXHJcbiAgICBzZXQoY2IpIHtcclxuICAgICAgaWYgKHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCwgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2IpIHtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSA9IGNiKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBkaXNhYmxlTG9nKGJvb2wpIHtcclxuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xyXG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XHJcbiAgfVxyXG4gIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XHJcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xyXG4gKiBAcGFyYW0geyFib29sZWFufSBib29sIHNldCB0byB0cnVlIHRvIGRpc2FibGUgd2FybmluZ3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBkaXNhYmxlV2FybmluZ3MoYm9vbCkge1xyXG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcclxuICB9XHJcbiAgZGVwcmVjYXRpb25XYXJuaW5nc18gPSAhYm9vbDtcclxuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gbG9nKCkge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xyXG4gICAgaWYgKGxvZ0Rpc2FibGVkXykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3dzIGEgZGVwcmVjYXRpb24gd2FybmluZyBzdWdnZXN0aW5nIHRoZSBtb2Rlcm4gYW5kIHNwZWMtY29tcGF0aWJsZSBBUEkuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXByZWNhdGVkKG9sZE1ldGhvZCwgbmV3TWV0aG9kKSB7XHJcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdzXykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zb2xlLndhcm4ob2xkTWV0aG9kICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdNZXRob2QgKyAnIGluc3RlYWQuJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCcm93c2VyIGRldGVjdG9yLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cclxuICogICAgIHByb3BlcnRpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZXRlY3RCcm93c2VyKHdpbmRvdykge1xyXG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXHJcbiAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgYnJvd3NlcjogbnVsbCxcclxuICAgIHZlcnNpb246IG51bGxcclxuICB9O1xyXG5cclxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHtcclxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGNvbnN0IHtcclxuICAgIG5hdmlnYXRvclxyXG4gIH0gPSB3aW5kb3c7XHJcblxyXG4gIC8vIFByZWZlciBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5cclxuICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzKSB7XHJcbiAgICBjb25zdCBjaHJvbWl1bSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcy5maW5kKGJyYW5kID0+IHtcclxuICAgICAgcmV0dXJuIGJyYW5kLmJyYW5kID09PSAnQ2hyb21pdW0nO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoY2hyb21pdW0pIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBicm93c2VyOiAnY2hyb21lJyxcclxuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludChjaHJvbWl1bS52ZXJzaW9uLCAxMClcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcclxuICAgIC8vIEZpcmVmb3guXHJcbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcclxuICAgIHJlc3VsdC52ZXJzaW9uID0gcGFyc2VJbnQoZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKSk7XHJcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgPT09IGZhbHNlICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXHJcbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxyXG4gICAgLy8gQ2hyb21lIDc0IHJlbW92ZWQgd2Via2l0R2V0VXNlck1lZGlhIG9uIGh0dHAgYXMgd2VsbCBzbyB3ZSBuZWVkIHRoZVxyXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cclxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XHJcbiAgICByZXN1bHQudmVyc2lvbiA9IHBhcnNlSW50KGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9DaHJvbShlfGl1bSlcXC8oXFxkKylcXC4vLCAyKSk7XHJcbiAgfSBlbHNlIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKSkge1xyXG4gICAgLy8gU2FmYXJpLlxyXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcclxuICAgIHJlc3VsdC52ZXJzaW9uID0gcGFyc2VJbnQoZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLywgMSkpO1xyXG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiYgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XHJcbiAgICAvLyBPbmx5IGZvciBpbnRlcm5hbCB1c2FnZS5cclxuICAgIHJlc3VsdC5fc2FmYXJpVmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9WZXJzaW9uXFwvKFxcZCsoXFwuP1xcZCspKS8sIDEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxyXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cclxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xyXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcclxuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxyXG4gKiBvZiBMb2Rhc2gncyBgY29tcGFjdGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcclxuICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGtleSkge1xyXG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xyXG4gICAgY29uc3QgdmFsdWUgPSBpc09iaiA/IGNvbXBhY3RPYmplY3QoZGF0YVtrZXldKSA6IGRhdGFba2V5XTtcclxuICAgIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcclxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtcclxuICAgICAgW2tleV06IHZhbHVlXHJcbiAgICB9KTtcclxuICB9LCB7fSk7XHJcbn1cclxuXHJcbi8qIGl0ZXJhdGVzIHRoZSBzdGF0cyBncmFwaCByZWN1cnNpdmVseS4gKi9cclxuZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcclxuICBpZiAoIWJhc2UgfHwgcmVzdWx0U2V0LmhhcyhiYXNlLmlkKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICByZXN1bHRTZXQuc2V0KGJhc2UuaWQsIGJhc2UpO1xyXG4gIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xyXG4gICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChiYXNlW25hbWVdKSwgcmVzdWx0U2V0KTtcclxuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcclxuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGlkID0+IHtcclxuICAgICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChpZCksIHJlc3VsdFNldCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKiBmaWx0ZXIgZ2V0U3RhdHMgZm9yIGEgc2VuZGVyL3JlY2VpdmVyIHRyYWNrLiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xyXG4gIGNvbnN0IHN0cmVhbVN0YXRzVHlwZSA9IG91dGJvdW5kID8gJ291dGJvdW5kLXJ0cCcgOiAnaW5ib3VuZC1ydHAnO1xyXG4gIGNvbnN0IGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xyXG4gIH1cclxuICBjb25zdCB0cmFja1N0YXRzID0gW107XHJcbiAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiYgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xyXG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xyXG4gICAgcmVzdWx0LmZvckVhY2goc3RhdHMgPT4ge1xyXG4gICAgICBpZiAoc3RhdHMudHlwZSA9PT0gc3RyZWFtU3RhdHNUeXBlICYmIHN0YXRzLnRyYWNrSWQgPT09IHRyYWNrU3RhdC5pZCkge1xyXG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcclxufVxyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcbi8qIGVzbGludC1lbnYgbm9kZSAqL1xyXG5jb25zdCBsb2dnaW5nID0gbG9nO1xyXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xyXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcclxuICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjYyA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByID0gdHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7XHJcbiAgICAgICAgaWRlYWw6IGNba2V5XVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24gKHByZWZpeCwgbmFtZSkge1xyXG4gICAgICAgIGlmIChwcmVmaXgpIHtcclxuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdkZXZpY2VJZCcgPyAnc291cmNlSWQnIDogbmFtZTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XHJcbiAgICAgICAgbGV0IG9jID0ge307XHJcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcclxuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xyXG4gICAgICAgICAgb2MgPSB7fTtcclxuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XHJcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcclxuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcclxuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKG1peCA9PiB7XHJcbiAgICAgICAgICBpZiAoclttaXhdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xyXG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xyXG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNjO1xyXG4gIH07XHJcbiAgY29uc3Qgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgZnVuYykge1xyXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcclxuICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xyXG4gICAgfVxyXG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XHJcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLmF1ZGlvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcclxuICAgICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcclxuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcclxuICAgICAgICAgIGRlbGV0ZSBvYmpbYV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcclxuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnZ29vZ0F1dG9HYWluQ29udHJvbCcpO1xyXG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcclxuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy5hdWRpbyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxyXG4gICAgICBsZXQgZmFjZSA9IGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XHJcbiAgICAgIGZhY2UgPSBmYWNlICYmICh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcgPyBmYWNlIDoge1xyXG4gICAgICAgIGlkZWFsOiBmYWNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcclxuICAgICAgaWYgKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSAmJiAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUgJiYgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xyXG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xyXG4gICAgICAgIGxldCBtYXRjaGVzO1xyXG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcclxuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJykge1xyXG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXHJcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihkZXZpY2VzID0+IHtcclxuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xyXG4gICAgICAgICAgICBsZXQgZGV2ID0gZGV2aWNlcy5maW5kKGQgPT4gbWF0Y2hlcy5zb21lKG1hdGNoID0+IGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaCkpKTtcclxuICAgICAgICAgICAgaWYgKCFkZXYgJiYgZGV2aWNlcy5sZW5ndGggJiYgbWF0Y2hlcy5pbmNsdWRlcygnYmFjaycpKSB7XHJcbiAgICAgICAgICAgICAgZGV2ID0gZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdOyAvLyBtb3JlIGxpa2VseSB0aGUgYmFjayBjYW1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGV2KSB7XHJcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge1xyXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGRldi5kZXZpY2VJZFxyXG4gICAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgICBpZGVhbDogZGV2LmRldmljZUlkXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcclxuICAgICAgICAgICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xyXG4gICAgfVxyXG4gICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcclxuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcclxuICB9O1xyXG4gIGNvbnN0IHNoaW1FcnJvcl8gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjQpIHtcclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7XHJcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcclxuICAgICAgICBQZXJtaXNzaW9uRGlzbWlzc2VkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxyXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcclxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxyXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJyxcclxuICAgICAgICBUcmFja1N0YXJ0RXJyb3I6ICdOb3RSZWFkYWJsZUVycm9yJyxcclxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxyXG4gICAgICAgIE1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uOiAnTm90QWxsb3dlZEVycm9yJyxcclxuICAgICAgICBUYWJDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcclxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcclxuICAgICAgICBEZXZpY2VDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJ1xyXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxyXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXHJcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCB8fCBlLmNvbnN0cmFpbnROYW1lLFxyXG4gICAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgYyA9PiB7XHJcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBlID0+IHtcclxuICAgICAgICBpZiAob25FcnJvcikge1xyXG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXy5iaW5kKG5hdmlnYXRvcik7XHJcblxyXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcclxuICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcclxuICAvLyBjb25zdHJhaW50cy5cclxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcclxuICAgIGNvbnN0IG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xyXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY3MpIHtcclxuICAgICAgcmV0dXJuIHNoaW1Db25zdHJhaW50c18oY3MsIGMgPT4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKHN0cmVhbSA9PiB7XHJcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcclxuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90Rm91bmRFcnJvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyZWFtO1xyXG4gICAgICB9LCBlID0+IFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpKSk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcbi8qIGVzbGludC1lbnYgbm9kZSAqL1xyXG5mdW5jdGlvbiBzaGltTWVkaWFTdHJlYW0od2luZG93KSB7XHJcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcclxufVxyXG5mdW5jdGlvbiBzaGltT25UcmFjayQxKHdpbmRvdykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQoZikge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XHJcbiAgICAgIH0sXHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XHJcbiAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSBlID0+IHtcclxuICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXHJcbiAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cclxuICAgICAgICAgIGUuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVjZWl2ZXI7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xyXG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0ZS50cmFjay5pZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjazogdGUudHJhY2tcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xyXG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xyXG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcclxuICAgICAgICAgICAgICByZWNlaXZlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XHJcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRyYWNrLmlkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcclxuICAgICAgICAgICAgICAgIHRyYWNrXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcclxuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcclxuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcclxuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7XHJcbiAgICAgICAgICAgICAgcmVjZWl2ZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIGV2ZW4gaWYgUlRDUnRwVHJhbnNjZWl2ZXIgaXMgaW4gd2luZG93LCBpdCBpcyBvbmx5IHVzZWQgYW5kXHJcbiAgICAvLyBlbWl0dGVkIGluIHVuaWZpZWQtcGxhbi4gVW5mb3J0dW5hdGVseSB0aGlzIG1lYW5zIHdlIG5lZWRcclxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cclxuICAgIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XHJcbiAgICAgIGlmICghZS50cmFuc2NlaXZlcikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLCB7XHJcbiAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICByZWNlaXZlcjogZS5yZWNlaXZlclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XHJcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcclxuICAgIGNvbnN0IHNoaW1TZW5kZXJXaXRoRHRtZiA9IGZ1bmN0aW9uIChwYywgdHJhY2spIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0cmFjayxcclxuICAgICAgICBnZXQgZHRtZigpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gcGMuY3JlYXRlRFRNRlNlbmRlcih0cmFjayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3BjOiBwY1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxyXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMpIHtcclxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcclxuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZGVycy5zbGljZSgpOyAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcclxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcclxuICAgICAgICBsZXQgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcclxuICAgICAgICAgIHNlbmRlciA9IHNoaW1TZW5kZXJXaXRoRHRtZih0aGlzLCB0cmFjayk7XHJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcclxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgICAgIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcclxuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XHJcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcclxuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XHJcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICBjb25zdCBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XHJcbiAgICAgICAgaWYgKHNlbmRlcikge1xyXG4gICAgICAgICAgLy8gcmVtb3ZlIHNlbmRlclxyXG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UodGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlciksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XHJcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XHJcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XHJcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xyXG4gICAgICByZXR1cm4gc2VuZGVycztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUsICdkdG1mJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xyXG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIHNoaW0gc2VuZGVyIHN0YXRzLlxyXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XHJcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcclxuICAgIGlmIChvcmlnR2V0U2VuZGVycykge1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XHJcbiAgICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xyXG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXM7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XHJcbiAgICAgIC8qIE5vdGU6IHRoaXMgd2lsbCBpbmNsdWRlIHN0YXRzIG9mIGFsbCBzZW5kZXJzIHRoYXRcclxuICAgICAgICogICBzZW5kIGEgdHJhY2sgd2l0aCB0aGUgc2FtZSBpZCBhcyBzZW5kZXIudHJhY2sgYXNcclxuICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cclxuICAgICAgICovXHJcbiAgICAgIGZpbHRlclN0YXRzKHJlc3VsdCwgc2VuZGVyLnRyYWNrLCB0cnVlKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cclxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XHJcbiAgICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XHJcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcclxuICAgICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcclxuICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcclxuICAgICAgICByZXR1cm4gcmVjZWl2ZXJzO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcclxuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSk7XHJcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcclxuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT4gZmlsdGVyU3RhdHMocmVzdWx0LCByZWNlaXZlci50cmFjaywgZmFsc2UpKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXHJcbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcclxuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgIGxldCBzZW5kZXI7XHJcbiAgICAgIGxldCByZWNlaXZlcjtcclxuICAgICAgbGV0IGVycjtcclxuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzID0+IHtcclxuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcclxuICAgICAgICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKHIgPT4ge1xyXG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xyXG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgIGVyciA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChlcnIgfHwgc2VuZGVyICYmIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2VuZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLmdldFN0YXRzKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XHJcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXHJcbiAgLy8gdGhlIGludGVyYWN0aW9ucyB3aXRoIGxlZ2FjeSBnZXRMb2NhbFN0cmVhbXMgYmVoYXZlIGFzIGluIG90aGVyIGJyb3dzZXJzLlxyXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcclxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLm1hcChzdHJlYW1JZCA9PiB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXSk7XHJcbiAgfTtcclxuICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XHJcbiAgICBpZiAoIXN0cmVhbSkge1xyXG4gICAgICByZXR1cm4gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcclxuICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcclxuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLmluZGV4T2Yoc2VuZGVyKSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZW5kZXI7XHJcbiAgfTtcclxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcclxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XHJcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xyXG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbHRlcihuZXdTZW5kZXIgPT4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTEpO1xyXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xyXG4gIH07XHJcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XHJcbiAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xyXG4gICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG4gIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XHJcbiAgICBpZiAoc2VuZGVyKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goc3RyZWFtSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmluZGV4T2Yoc2VuZGVyKTtcclxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxyXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcclxuICAgIHJldHVybiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KTtcclxuICB9XHJcblxyXG4gIC8vIGFsc28gc2hpbSBwYy5nZXRMb2NhbFN0cmVhbXMgd2hlbiBhZGRUcmFjayBpcyBzaGltbWVkXHJcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxyXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcztcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcclxuICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xyXG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcclxuICAgIHJldHVybiBuYXRpdmVTdHJlYW1zLm1hcChzdHJlYW0gPT4gdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XHJcbiAgfTtcclxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcclxuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XHJcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xyXG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xyXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBBZGQgaWRlbnRpdHkgbWFwcGluZyBmb3IgY29uc2lzdGVuY3kgd2l0aCBhZGRUcmFjay5cclxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxyXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XHJcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oc3RyZWFtLmdldFRyYWNrcygpKTtcclxuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xyXG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xyXG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XHJcbiAgICB9XHJcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcclxuICB9O1xyXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcclxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xyXG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcclxuICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW1dKTtcclxuICAgIGRlbGV0ZSB0aGlzLl9yZXZlcnNlU3RyZWFtc1t0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPyB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0uaWQgOiBzdHJlYW0uaWRdO1xyXG4gICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcclxuICB9O1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XHJcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8ICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQodCA9PiB0ID09PSB0cmFjaykpIHtcclxuICAgICAgLy8gdGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCBidXQgYWxsIHdlIGNhbiBtYW5hZ2Ugd2l0aG91dFxyXG4gICAgICAvLyBbW2Fzc29jaWF0ZWQgTWVkaWFTdHJlYW1zXV0gaW50ZXJuYWwgc2xvdC5cclxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICsgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJywgJ05vdFN1cHBvcnRlZEVycm9yJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcclxuICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xyXG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcclxuICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcclxuICAgIGlmIChvbGRTdHJlYW0pIHtcclxuICAgICAgLy8gdGhpcyBpcyB1c2luZyBvZGQgQ2hyb21lIGJlaGF2aW91ciwgdXNlIHdpdGggY2F1dGlvbjpcclxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcclxuICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cclxuICAgICAgLy8gY3JlYXRlIHRoZSBzZW5kZXIgd2l0aCBhIGR0bWYgc2VuZGVyLlxyXG4gICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xyXG5cclxuICAgICAgLy8gVHJpZ2dlciBPTk4gYXN5bmMuXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XHJcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcclxuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcclxuICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xyXG4gIH07XHJcblxyXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXHJcbiAgLy8gdmljZSB2ZXJzYS5cclxuICBmdW5jdGlvbiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcclxuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XHJcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XHJcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xyXG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcclxuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgZXh0ZXJuYWxTdHJlYW0uaWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XHJcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXHJcbiAgICAgIHNkcFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xyXG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcclxuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcclxuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XHJcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xyXG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLCBpbnRlcm5hbFN0cmVhbS5pZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcclxuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcclxuICAgICAgc2RwXHJcbiAgICB9KTtcclxuICB9XHJcbiAgWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcclxuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcclxuICAgICAgW21ldGhvZF0oKSB7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XHJcbiAgICAgICAgaWYgKGlzTGVnYWN5Q2FsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICBhcmdzWzBdLmFwcGx5KG51bGwsIFtkZXNjXSk7XHJcbiAgICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xyXG4gICAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCwgZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSwgYXJndW1lbnRzWzJdXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGRlc2NyaXB0aW9uID0+IHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcclxuICB9KTtcclxuICBjb25zdCBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xyXG4gICAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XHJcbiAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG5cclxuICAvLyBUT0RPOiBtYW5nbGUgZ2V0U3RhdHM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNtZWRpYXN0cmVhbXN0YXRzLXN0cmVhbWlkZW50aWZpZXJcclxuXHJcbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJywge1xyXG4gICAgZ2V0KCkge1xyXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcclxuICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxyXG4gICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxyXG4gICAgaWYgKCFzZW5kZXIuX3BjKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc0xvY2FsID0gc2VuZGVyLl9wYyA9PT0gdGhpcztcclxuICAgIGlmICghaXNMb2NhbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxyXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XHJcbiAgICBsZXQgc3RyZWFtO1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XHJcbiAgICAgIGNvbnN0IGhhc1RyYWNrID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF0uZ2V0VHJhY2tzKCkuZmluZCh0cmFjayA9PiBzZW5kZXIudHJhY2sgPT09IHRyYWNrKTtcclxuICAgICAgaWYgKGhhc1RyYWNrKSB7XHJcbiAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKHN0cmVhbSkge1xyXG4gICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcclxuICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxyXG4gICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtKHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXHJcbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHNlbmRlci50cmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24kMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcclxuICB9XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxyXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcclxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xyXG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XHJcbiAgICAgICAgW21ldGhvZF0oKSB7XHJcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBdHRlbXB0IHRvIGZpeCBPTk4gaW4gcGxhbi1iIG1vZGUuXHJcbmZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcclxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xyXG4gICAgY29uc3QgcGMgPSBlLnRhcmdldDtcclxuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgcGMuZ2V0Q29uZmlndXJhdGlvbiAmJiBwYy5nZXRDb25maWd1cmF0aW9uKCkuc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xyXG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZTtcclxuICB9KTtcclxufVxyXG5cclxudmFyIGNocm9tZVNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIGZpeE5lZ290aWF0aW9uTmVlZGVkOiBmaXhOZWdvdGlhdGlvbk5lZWRlZCxcclxuICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjazogc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2ssXHJcbiAgc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUsXHJcbiAgc2hpbUdldFNlbmRlcnNXaXRoRHRtZjogc2hpbUdldFNlbmRlcnNXaXRoRHRtZixcclxuICBzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDIsXHJcbiAgc2hpbU1lZGlhU3RyZWFtOiBzaGltTWVkaWFTdHJlYW0sXHJcbiAgc2hpbU9uVHJhY2s6IHNoaW1PblRyYWNrJDEsXHJcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24kMSxcclxuICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0czogc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHNcclxufSk7XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XHJcbiAgY29uc3QgTWVkaWFTdHJlYW1UcmFjayA9IHdpbmRvdyAmJiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaztcclxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxyXG4gICAgZGVwcmVjYXRlZCgnbmF2aWdhdG9yLmdldFVzZXJNZWRpYScsICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xyXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcclxuICB9O1xyXG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJiAnYXV0b0dhaW5Db250cm9sJyBpbiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkpKSB7XHJcbiAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcclxuICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XHJcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xyXG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xyXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICBpZiAodHlwZW9mIGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjLmF1ZGlvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcclxuICAgICAgICByZW1hcChjLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xyXG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmF0aXZlR2V0VXNlck1lZGlhKGMpO1xyXG4gICAgfTtcclxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XHJcbiAgICAgIGNvbnN0IG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XHJcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xyXG4gICAgICAgIHJlbWFwKG9iaiwgJ21vek5vaXNlU3VwcHJlc3Npb24nLCAnbm9pc2VTdXBwcmVzc2lvbicpO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XHJcbiAgICAgIGNvbnN0IG5hdGl2ZUFwcGx5Q29uc3RyYWludHMgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzO1xyXG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xyXG4gICAgICAgICAgcmVtYXAoYywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcclxuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUFwcGx5Q29uc3RyYWludHMuYXBwbHkodGhpcywgW2NdKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcblxyXG5mdW5jdGlvbiBzaGltR2V0RGlzcGxheU1lZGlhKHdpbmRvdywgcHJlZmVycmVkTWVkaWFTb3VyY2UpIHtcclxuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcclxuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xyXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdnZXREaXNwbGF5TWVkaWEgd2l0aG91dCB2aWRlbyAnICsgJ2NvbnN0cmFpbnRzIGlzIHVuZGVmaW5lZCcpO1xyXG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcclxuICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXHJcbiAgICAgIGVyci5jb2RlID0gODtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XHJcbiAgICB9XHJcbiAgICBpZiAoY29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcclxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7XHJcbiAgICAgICAgbWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcbi8qIGVzbGludC1lbnYgbm9kZSAqL1xyXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XHJcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXHJcbiAgfVxyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb247XHJcbiAgfVxyXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcclxuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxyXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XHJcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcclxuICAgICAgICBbbWV0aG9kXSgpIHtcclxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uc3QgbW9kZXJuU3RhdHNUeXBlcyA9IHtcclxuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXHJcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXHJcbiAgICBjYW5kaWRhdGVwYWlyOiAnY2FuZGlkYXRlLXBhaXInLFxyXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxyXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcclxuICB9O1xyXG4gIGNvbnN0IG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICBjb25zdCBbc2VsZWN0b3IsIG9uU3VjYywgb25FcnJdID0gYXJndW1lbnRzO1xyXG4gICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSkudGhlbihzdGF0cyA9PiB7XHJcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMgJiYgIW9uU3VjYykge1xyXG4gICAgICAgIC8vIFNoaW0gb25seSBwcm9taXNlIGdldFN0YXRzIHdpdGggc3BlYy1oeXBoZW5zIGluIHR5cGUgbmFtZXNcclxuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXHJcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKChzdGF0LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRzLnNldChpLCBPYmplY3QuYXNzaWduKHt9LCBzdGF0LCB7XHJcbiAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0YXRzO1xyXG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpIHtcclxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcclxuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XHJcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XHJcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xyXG4gICAgICByZXR1cm4gc2VuZGVycztcclxuICAgIH07XHJcbiAgfVxyXG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XHJcbiAgaWYgKG9yaWdBZGRUcmFjaykge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xyXG4gICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XHJcbiAgICAgIHJldHVybiBzZW5kZXI7XHJcbiAgICB9O1xyXG4gIH1cclxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2sgPyB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKSA6IFByb21pc2UucmVzb2x2ZShuZXcgTWFwKCkpO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XHJcbiAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xyXG4gICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcclxuICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XHJcbiAgICAgIHJldHVybiByZWNlaXZlcnM7XHJcbiAgICB9O1xyXG4gIH1cclxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xyXG4gICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XHJcbiAgICByZXR1cm4gZTtcclxuICB9KTtcclxuICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjayk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdykge1xyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICBkZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcclxuICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcclxuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KSB7XHJcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcclxuICBpZiAod2luZG93LkRhdGFDaGFubmVsICYmICF3aW5kb3cuUlRDRGF0YUNoYW5uZWwpIHtcclxuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdykge1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xyXG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxyXG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3Qgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcclxuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyID0gZnVuY3Rpb24gYWRkVHJhbnNjZWl2ZXIoKSB7XHJcbiAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XHJcbiAgICAgIC8vIFdlYklETCBpbnB1dCBjb2VyY2lvbiBhbmQgdmFsaWRhdGlvblxyXG4gICAgICBsZXQgc2VuZEVuY29kaW5ncyA9IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc2VuZEVuY29kaW5ncztcclxuICAgICAgaWYgKHNlbmRFbmNvZGluZ3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBzZW5kRW5jb2RpbmdzID0gWy4uLnNlbmRFbmNvZGluZ3NdO1xyXG4gICAgICBjb25zdCBzaG91bGRQZXJmb3JtQ2hlY2sgPSBzZW5kRW5jb2RpbmdzLmxlbmd0aCA+IDA7XHJcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcclxuICAgICAgICAvLyBJZiBzZW5kRW5jb2RpbmdzIHBhcmFtcyBhcmUgcHJvdmlkZWQsIHZhbGlkYXRlIGdyYW1tYXJcclxuICAgICAgICBzZW5kRW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmdQYXJhbSA9PiB7XHJcbiAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xyXG4gICAgICAgICAgICBjb25zdCByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XHJcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFJJRCB2YWx1ZSBwcm92aWRlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCdzY2FsZVJlc29sdXRpb25Eb3duQnknIGluIGVuY29kaW5nUGFyYW0pIHtcclxuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcclxuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLm1heEZyYW1lcmF0ZSkgPj0gMCkpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBpbml0IG9wdGlvbnMgd2VyZSBhcHBsaWVkLiBJZiBub3Qgd2UgZG8gdGhpcyBpbiBhblxyXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cclxuICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cclxuICAgICAgICAvLyBjaGVja2luZyB0aGUgc2VuZGVyIHBhcmFtZXRlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3JlYXRlT2ZmZXJcclxuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXHJcbiAgICAgICAgLy8gb3Bwb3J0dW5pdHkgdG8gcmVjcmVhdGUgb2ZmZXIuXHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgc2VuZGVyXHJcbiAgICAgICAgfSA9IHRyYW5zY2VpdmVyO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSB8fFxyXG4gICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cclxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJiBPYmplY3Qua2V5cyhwYXJhbXMuZW5jb2RpbmdzWzBdKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xyXG4gICAgICAgICAgc2VuZGVyLnNlbmRFbmNvZGluZ3MgPSBzZW5kRW5jb2RpbmdzO1xyXG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgc2VuZGVyLnNlbmRFbmNvZGluZ3M7XHJcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3Qgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xyXG4gIGlmIChvcmlnR2V0UGFyYW1ldGVycykge1xyXG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldFBhcmFtZXRlcnMoKSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG9yaWdHZXRQYXJhbWV0ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykpIHtcclxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW10uY29uY2F0KHRoaXMuc2VuZEVuY29kaW5ncyB8fCBbe31dKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdykge1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xyXG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxyXG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XHJcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KSB7XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XHJcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XHJcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBmaXJlZm94U2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgc2hpbUFkZFRyYW5zY2VpdmVyOiBzaGltQWRkVHJhbnNjZWl2ZXIsXHJcbiAgc2hpbUNyZWF0ZUFuc3dlcjogc2hpbUNyZWF0ZUFuc3dlcixcclxuICBzaGltQ3JlYXRlT2ZmZXI6IHNoaW1DcmVhdGVPZmZlcixcclxuICBzaGltR2V0RGlzcGxheU1lZGlhOiBzaGltR2V0RGlzcGxheU1lZGlhLFxyXG4gIHNoaW1HZXRQYXJhbWV0ZXJzOiBzaGltR2V0UGFyYW1ldGVycyxcclxuICBzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDEsXHJcbiAgc2hpbU9uVHJhY2s6IHNoaW1PblRyYWNrLFxyXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogc2hpbVBlZXJDb25uZWN0aW9uLFxyXG4gIHNoaW1SVENEYXRhQ2hhbm5lbDogc2hpbVJUQ0RhdGFDaGFubmVsLFxyXG4gIHNoaW1SZWNlaXZlckdldFN0YXRzOiBzaGltUmVjZWl2ZXJHZXRTdGF0cyxcclxuICBzaGltUmVtb3ZlU3RyZWFtOiBzaGltUmVtb3ZlU3RyZWFtLFxyXG4gIHNoaW1TZW5kZXJHZXRTdGF0czogc2hpbVNlbmRlckdldFN0YXRzXHJcbn0pO1xyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKCEoJ2dldExvY2FsU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0cmVhbXM7XHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgY29uc3QgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcclxuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFRyeSB0byBlbXVsYXRlIENocm9tZSdzIGJlaGF2aW91ciBvZiBhZGRpbmcgaW4gYXVkaW8tdmlkZW8gb3JkZXIuXHJcbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXHJcbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xyXG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLCBzdHJlYW0pKTtcclxuICAgIH07XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcclxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICAgIHN0cmVhbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHJlYW1zKSB7XHJcbiAgICAgICAgc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9hZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKCEoJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcclxuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9sb2NhbFN0cmVhbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xyXG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XHJcbiAgICAgICAgaWYgKHRyYWNrcy5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID0gZnVuY3Rpb24gZ2V0UmVtb3RlU3RyZWFtcygpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoISgnb25hZGRzdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQoZikge1xyXG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xyXG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBlID0+IHtcclxuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XHJcbiAgICAgIGNvbnN0IHBjID0gdGhpcztcclxuICAgICAgaWYgKCF0aGlzLl9vbmFkZHN0cmVhbXBvbHkpIHtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcclxuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcclxuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XHJcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xyXG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSBwcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xyXG4gIGNvbnN0IHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcclxuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcclxuICBjb25zdCBhZGRJY2VDYW5kaWRhdGUgPSBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xyXG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xyXG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH07XHJcbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcclxuICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XHJcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfTtcclxuICBsZXQgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XHJcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfTtcclxuICBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcclxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XHJcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfTtcclxuICBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XHJcbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xyXG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH07XHJcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcclxufVxyXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xyXG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xyXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XHJcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcclxuICAgIGNvbnN0IG1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XHJcbiAgICBjb25zdCBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XHJcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGNvbnN0cmFpbnRzID0+IHtcclxuICAgICAgcmV0dXJuIF9nZXRVc2VyTWVkaWEoc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xyXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XHJcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGNiLCBlcnJjYik7XHJcbiAgICB9LmJpbmQobmF2aWdhdG9yKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XHJcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cywge1xyXG4gICAgICB2aWRlbzogY29tcGFjdE9iamVjdChjb25zdHJhaW50cy52aWRlbylcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gY29uc3RyYWludHM7XHJcbn1cclxuZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gbWlncmF0ZSBmcm9tIG5vbi1zcGVjIFJUQ0ljZVNlcnZlci51cmwgdG8gUlRDSWNlU2VydmVyLnVybHNcclxuICBjb25zdCBPcmlnUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcclxuICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XHJcbiAgICAgIGNvbnN0IG5ld0ljZVNlcnZlcnMgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XHJcbiAgICAgICAgaWYgKHNlcnZlci51cmxzID09PSB1bmRlZmluZWQgJiYgc2VydmVyLnVybCkge1xyXG4gICAgICAgICAgZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xyXG4gICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcclxuICAgICAgICAgIHNlcnZlci51cmxzID0gc2VydmVyLnVybDtcclxuICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xyXG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE9yaWdQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XHJcbiAgfTtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gT3JpZ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxuICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxyXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XHJcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcclxuICAgICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByZWNlaXZlcjogdGhpcy5yZWNlaXZlclxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XHJcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKSB7XHJcbiAgICBpZiAob2ZmZXJPcHRpb25zKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXHJcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGF1ZGlvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJyk7XHJcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xyXG4gICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xyXG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcclxuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUgJiYgIWF1ZGlvVHJhbnNjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHtcclxuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXHJcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQodHJhbnNjZWl2ZXIgPT4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ3ZpZGVvJyk7XHJcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xyXG4gICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xyXG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcclxuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IHRydWUgJiYgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycsIHtcclxuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltQXVkaW9Db250ZXh0KHdpbmRvdykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCB3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG59XHJcblxyXG52YXIgc2FmYXJpU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgc2hpbUF1ZGlvQ29udGV4dDogc2hpbUF1ZGlvQ29udGV4dCxcclxuICBzaGltQ2FsbGJhY2tzQVBJOiBzaGltQ2FsbGJhY2tzQVBJLFxyXG4gIHNoaW1Db25zdHJhaW50czogc2hpbUNvbnN0cmFpbnRzLFxyXG4gIHNoaW1DcmVhdGVPZmZlckxlZ2FjeTogc2hpbUNyZWF0ZU9mZmVyTGVnYWN5LFxyXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEsXHJcbiAgc2hpbUxvY2FsU3RyZWFtc0FQSTogc2hpbUxvY2FsU3RyZWFtc0FQSSxcclxuICBzaGltUlRDSWNlU2VydmVyVXJsczogc2hpbVJUQ0ljZVNlcnZlclVybHMsXHJcbiAgc2hpbVJlbW90ZVN0cmVhbXNBUEk6IHNoaW1SZW1vdGVTdHJlYW1zQVBJLFxyXG4gIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXI6IHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXJcclxufSk7XHJcblxyXG52YXIgc2RwJDEgPSB7ZXhwb3J0czoge319O1xyXG5cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbnZhciBoYXNSZXF1aXJlZFNkcDtcclxuZnVuY3Rpb24gcmVxdWlyZVNkcCgpIHtcclxuICBpZiAoaGFzUmVxdWlyZWRTZHApIHJldHVybiBzZHAkMS5leHBvcnRzO1xyXG4gIGhhc1JlcXVpcmVkU2RwID0gMTtcclxuICAoZnVuY3Rpb24gKG1vZHVsZSkge1xyXG5cclxuICAgIC8vIFNEUCBoZWxwZXJzLlxyXG4gICAgY29uc3QgU0RQVXRpbHMgPSB7fTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cclxuICAgIC8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXHJcbiAgICBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cclxuICAgIFNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcclxuXHJcbiAgICAvLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxyXG4gICAgU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uIChibG9iKSB7XHJcbiAgICAgIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xyXG4gICAgfTtcclxuICAgIC8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxyXG4gICAgU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uIChibG9iKSB7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcclxuICAgICAgcmV0dXJuIHBhcnRzLm1hcCgocGFydCwgaW5kZXgpID0+IChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cclxuICAgIFNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xyXG4gICAgICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJldHVybnMgdGhlIGluZGl2aWR1YWwgbWVkaWEgc2VjdGlvbnMuXHJcbiAgICBTRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zID0gZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xyXG4gICAgICBzZWN0aW9ucy5zaGlmdCgpO1xyXG4gICAgICByZXR1cm4gc2VjdGlvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXHJcbiAgICBTRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChibG9iLCBwcmVmaXgpIHtcclxuICAgICAgcmV0dXJuIFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYikuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKHByZWZpeCkgPT09IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XHJcbiAgICAvLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44LjhcclxuICAgIC8vIHJwb3J0IDU1OTk2XCJcclxuICAgIC8vIElucHV0IGNhbiBiZSBwcmVmaXhlZCB3aXRoIGE9LlxyXG4gICAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBsZXQgcGFydHM7XHJcbiAgICAgIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXHJcbiAgICAgIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XHJcbiAgICAgICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHtcclxuICAgICAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcclxuICAgICAgICBjb21wb25lbnQ6IHtcclxuICAgICAgICAgIDE6ICdydHAnLFxyXG4gICAgICAgICAgMjogJ3J0Y3AnXHJcbiAgICAgICAgfVtwYXJ0c1sxXV0gfHwgcGFydHNbMV0sXHJcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXHJcbiAgICAgICAgaXA6IHBhcnRzWzRdLFxyXG4gICAgICAgIGFkZHJlc3M6IHBhcnRzWzRdLFxyXG4gICAgICAgIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxyXG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXHJcbiAgICAgICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xyXG4gICAgICAgIHR5cGU6IHBhcnRzWzddXHJcbiAgICAgIH07XHJcbiAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XHJcbiAgICAgICAgICBjYXNlICdyYWRkcic6XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdycG9ydCc6XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RjcHR5cGUnOlxyXG4gICAgICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd1ZnJhZyc6XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZy4gRG9uJ3Qgb3ZlcndyaXRlLlxyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cclxuICAgIC8vIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgYT0gcHJlZml4IVxyXG4gICAgU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgIGNvbnN0IHNkcCA9IFtdO1xyXG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XHJcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNhbmRpZGF0ZS5jb21wb25lbnQ7XHJcbiAgICAgIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XHJcbiAgICAgICAgc2RwLnB1c2goMSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50ID09PSAncnRjcCcpIHtcclxuICAgICAgICBzZHAucHVzaCgyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZHAucHVzaChjb21wb25lbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcclxuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcclxuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcclxuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xyXG4gICAgICBjb25zdCB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XHJcbiAgICAgIHNkcC5wdXNoKCd0eXAnKTtcclxuICAgICAgc2RwLnB1c2godHlwZSk7XHJcbiAgICAgIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xyXG4gICAgICAgIHNkcC5wdXNoKCdyYWRkcicpO1xyXG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XHJcbiAgICAgICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XHJcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XHJcbiAgICAgICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcclxuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xyXG4gICAgICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xyXG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxyXG4gICAgLy8gU2FtcGxlIGlucHV0OlxyXG4gICAgLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXHJcbiAgICBTRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcclxuICAgIFNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcclxuICAgICAgY29uc3QgcGFyc2VkID0ge1xyXG4gICAgICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxyXG4gICAgICB9O1xyXG4gICAgICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XHJcbiAgICAgIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XHJcbiAgICAgIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxyXG4gICAgICBwYXJzZWQuY2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcclxuICAgICAgLy8gbGVnYWN5IGFsaWFzLCBnb3QgcmVuYW1lZCBiYWNrIHRvIGNoYW5uZWxzIGluIE9SVEMuXHJcbiAgICAgIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnNlZC5jaGFubmVscztcclxuICAgICAgcmV0dXJuIHBhcnNlZDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3JcclxuICAgIC8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cclxuICAgIFNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24gKGNvZGVjKSB7XHJcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xyXG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2hhbm5lbHMgPSBjb2RlYy5jaGFubmVscyB8fCBjb2RlYy5udW1DaGFubmVscyB8fCAxO1xyXG4gICAgICByZXR1cm4gJ2E9cnRwbWFwOicgKyBwdCArICcgJyArIGNvZGVjLm5hbWUgKyAnLycgKyBjb2RlYy5jbG9ja1JhdGUgKyAoY2hhbm5lbHMgIT09IDEgPyAnLycgKyBjaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgYSBleHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XHJcbiAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcclxuICAgIC8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxyXG4gICAgU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXHJcbiAgICAgICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXHJcbiAgICAgICAgdXJpOiBwYXJ0c1sxXSxcclxuICAgICAgICBhdHRyaWJ1dGVzOiBwYXJ0cy5zbGljZSgyKS5qb2luKCcgJylcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGVzIGFuIGV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxyXG4gICAgLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxyXG4gICAgU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbiAoaGVhZGVyRXh0ZW5zaW9uKSB7XHJcbiAgICAgIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uIDogJycpICsgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICsgJ1xcclxcbic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XHJcbiAgICAvLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxyXG4gICAgLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXHJcbiAgICBTRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB7fTtcclxuICAgICAgbGV0IGt2O1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyc2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxyXG4gICAgU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24gKGNvZGVjKSB7XHJcbiAgICAgIGxldCBsaW5lID0gJyc7XHJcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xyXG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XHJcbiAgICAgICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChwYXJhbSA9PiB7XHJcbiAgICAgICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSArICc9JyArIGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaW5lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcclxuICAgIFNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogcGFydHMuc2hpZnQoKSxcclxuICAgICAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxyXG4gICAgU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbiAoY29kZWMpIHtcclxuICAgICAgbGV0IGxpbmVzID0gJyc7XHJcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xyXG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XHJcbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xyXG4gICAgICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICsgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICsgJ1xcclxcbic7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgYSBSRkMgNTU3NiBzc3JjIG1lZGlhIGF0dHJpYnV0ZS4gU2FtcGxlIGlucHV0OlxyXG4gICAgLy8gYT1zc3JjOjM3MzU5Mjg1NTkgY25hbWU6c29tZXRoaW5nXHJcbiAgICBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIGNvbnN0IHNwID0gbGluZS5pbmRleE9mKCcgJyk7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0ge1xyXG4gICAgICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGNvbG9uID0gbGluZS5pbmRleE9mKCc6Jywgc3ApO1xyXG4gICAgICBpZiAoY29sb24gPiAtMSkge1xyXG4gICAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSwgY29sb24pO1xyXG4gICAgICAgIHBhcnRzLnZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb24gKyAxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJ0cztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2UgYSBzc3JjLWdyb3VwIGxpbmUgKHNlZSBSRkMgNTU3NikuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGE9c3NyYy1ncm91cDpzZW1hbnRpY3MgMTIgMzRcclxuICAgIFNEUFV0aWxzLnBhcnNlU3NyY0dyb3VwID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzZW1hbnRpY3M6IHBhcnRzLnNoaWZ0KCksXHJcbiAgICAgICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSlcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXHJcbiAgICBTRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xyXG4gICAgICBpZiAobWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG1pZC5zdWJzdHJpbmcoNik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIGEgZmluZ2VycHJpbnQgbGluZSBmb3IgRFRMUy1TUlRQLlxyXG4gICAgU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxyXG4gICAgICAgIHZhbHVlOiBwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpIC8vIHRoZSBkZWZpbml0aW9uIGlzIHVwcGVyLWNhc2UgaW4gUkZDIDQ1NzIuXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxyXG4gICAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XHJcbiAgICAvLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cclxuICAgIFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9ZmluZ2VycHJpbnQ6Jyk7XHJcbiAgICAgIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUgaW4gRWRnZS5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByb2xlOiAnYXV0bycsXHJcbiAgICAgICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludClcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxyXG4gICAgU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMsIHNldHVwVHlwZSkge1xyXG4gICAgICBsZXQgc2RwID0gJ2E9c2V0dXA6JyArIHNldHVwVHlwZSArICdcXHJcXG4nO1xyXG4gICAgICBwYXJhbXMuZmluZ2VycHJpbnRzLmZvckVhY2goZnAgPT4ge1xyXG4gICAgICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBzZHA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXHJcbiAgICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xyXG4gICAgU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcclxuICAgICAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXHJcbiAgICAgICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcclxuICAgICAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgIHJldHVybiAnYT1jcnlwdG86JyArIHBhcmFtZXRlcnMudGFnICsgJyAnICsgcGFyYW1ldGVycy5jcnlwdG9TdWl0ZSArICcgJyArICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnID8gU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMocGFyYW1ldGVycy5rZXlQYXJhbXMpIDogcGFyYW1ldGVycy5rZXlQYXJhbXMpICsgKHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcyA/ICcgJyArIHBhcmFtZXRlcnMuc2Vzc2lvblBhcmFtcy5qb2luKCcgJykgOiAnJykgKyAnXFxyXFxuJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIHRoZSBjcnlwdG8ga2V5IHBhcmFtZXRlcnMgaW50b1xyXG4gICAgLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcclxuICAgIFNEUFV0aWxzLnBhcnNlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xyXG4gICAgICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5UGFyYW1zLnN1YnN0cmluZyg3KS5zcGxpdCgnfCcpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleU1ldGhvZDogJ2lubGluZScsXHJcbiAgICAgICAga2V5U2FsdDogcGFydHNbMF0sXHJcbiAgICAgICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxyXG4gICAgICAgIG1raVZhbHVlOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMF0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbWtpTGVuZ3RoOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCc6JylbMV0gOiB1bmRlZmluZWRcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcclxuICAgICAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOicgKyBrZXlQYXJhbXMua2V5U2FsdCArIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgKyAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGggPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoIDogJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxyXG4gICAgU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XHJcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWNyeXB0bzonKTtcclxuICAgICAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXHJcbiAgICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcclxuICAgIC8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXHJcbiAgICBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcclxuICAgICAgY29uc3QgdWZyYWcgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9aWNlLXVmcmFnOicpWzBdO1xyXG4gICAgICBjb25zdCBwd2QgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9aWNlLXB3ZDonKVswXTtcclxuICAgICAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogdWZyYWcuc3Vic3RyaW5nKDEyKSxcclxuICAgICAgICBwYXNzd29yZDogcHdkLnN1YnN0cmluZygxMClcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXHJcbiAgICBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgKyAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcclxuICAgICAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XHJcbiAgICAgICAgc2RwICs9ICdhPWljZS1saXRlXFxyXFxuJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2RwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xyXG4gICAgICAgIGNvZGVjczogW10sXHJcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXHJcbiAgICAgICAgZmVjTWVjaGFuaXNtczogW10sXHJcbiAgICAgICAgcnRjcDogW11cclxuICAgICAgfTtcclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcclxuICAgICAgZGVzY3JpcHRpb24ucHJvZmlsZSA9IG1saW5lWzJdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxyXG4gICAgICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XHJcbiAgICAgICAgY29uc3QgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRwbWFwOicgKyBwdCArICcgJylbMF07XHJcbiAgICAgICAgaWYgKHJ0cG1hcGxpbmUpIHtcclxuICAgICAgICAgIGNvbnN0IGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XHJcbiAgICAgICAgICBjb25zdCBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xyXG4gICAgICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cclxuICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XHJcbiAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKS5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xyXG4gICAgICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xyXG4gICAgICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXHJcbiAgICAgICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlICdSRUQnOlxyXG4gICAgICAgICAgICBjYXNlICdVTFBGRUMnOlxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGxpbmUgPT4ge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uLmhlYWRlckV4dGVuc2lvbnMucHVzaChTRFBVdGlscy5wYXJzZUV4dG1hcChsaW5lKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCB3aWxkY2FyZFJ0Y3BGYiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjoqICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XHJcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcclxuICAgICAgICB3aWxkY2FyZFJ0Y3BGYi5mb3JFYWNoKGZiID0+IHtcclxuICAgICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IGNvZGVjLnJ0Y3BGZWVkYmFjay5maW5kKGV4aXN0aW5nRmVlZGJhY2sgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdGZWVkYmFjay50eXBlID09PSBmYi50eXBlICYmIGV4aXN0aW5nRmVlZGJhY2sucGFyYW1ldGVyID09PSBmYi5wYXJhbWV0ZXI7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlmICghZHVwbGljYXRlKSB7XHJcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxyXG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cclxuICAgIC8vIHBhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGtpbmQsIGNhcHMpIHtcclxuICAgICAgbGV0IHNkcCA9ICcnO1xyXG5cclxuICAgICAgLy8gQnVpbGQgdGhlIG1saW5lLlxyXG4gICAgICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XHJcbiAgICAgIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxyXG4gICAgICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcclxuICAgICAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChjb2RlYyA9PiB7XHJcbiAgICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xyXG4gICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcclxuICAgICAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcclxuICAgICAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XHJcblxyXG4gICAgICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cclxuICAgICAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XHJcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcclxuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVGbXRwKGNvZGVjKTtcclxuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdGNwRmIoY29kZWMpO1xyXG4gICAgICB9KTtcclxuICAgICAgbGV0IG1heHB0aW1lID0gMDtcclxuICAgICAgY2Fwcy5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XHJcbiAgICAgICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcclxuICAgICAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKG1heHB0aW1lID4gMCkge1xyXG4gICAgICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XHJcbiAgICAgICAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcclxuICAgICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxyXG4gICAgICByZXR1cm4gc2RwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXHJcbiAgICAvLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xyXG4gICAgICBjb25zdCBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcclxuXHJcbiAgICAgIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcclxuICAgICAgY29uc3Qgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihwYXJ0cyA9PiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xyXG4gICAgICBjb25zdCBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcclxuICAgICAgbGV0IHNlY29uZGFyeVNzcmM7XHJcbiAgICAgIGNvbnN0IGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpLm1hcChsaW5lID0+IHtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDE3KS5zcGxpdCgnICcpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcclxuICAgICAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XHJcbiAgICAgIH1cclxuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xyXG4gICAgICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XHJcbiAgICAgICAgICBsZXQgZW5jUGFyYW0gPSB7XHJcbiAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxyXG4gICAgICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcclxuICAgICAgICAgICAgZW5jUGFyYW0ucnR4ID0ge1xyXG4gICAgICAgICAgICAgIHNzcmM6IHNlY29uZGFyeVNzcmNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcclxuICAgICAgICAgIGlmIChoYXNSZWQpIHtcclxuICAgICAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XHJcbiAgICAgICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcclxuICAgICAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcclxuICAgICAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xyXG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcclxuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxyXG4gICAgICBsZXQgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcclxuICAgICAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xyXG4gICAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg3KSwgMTApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcclxuICAgICAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cclxuICAgICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNSksIDEwKSAqIDEwMDAgKiAwLjk1IC0gNTAgKiA0MCAqIDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2gocGFyYW1zID0+IHtcclxuICAgICAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxyXG4gICAgU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgcnRjcFBhcmFtZXRlcnMgPSB7fTtcclxuXHJcbiAgICAgIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxyXG4gICAgICAvLyBTU1JDcy5cclxuICAgICAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcclxuICAgICAgaWYgKHJlbW90ZVNzcmMpIHtcclxuICAgICAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XHJcbiAgICAgICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxyXG4gICAgICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcclxuICAgICAgY29uc3QgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcclxuICAgICAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xyXG4gICAgICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgICAgIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cclxuICAgICAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXHJcbiAgICAgIGNvbnN0IG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcclxuICAgICAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XHJcbiAgICAgIHJldHVybiBydGNwUGFyYW1ldGVycztcclxuICAgIH07XHJcbiAgICBTRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHJ0Y3BQYXJhbWV0ZXJzKSB7XHJcbiAgICAgIGxldCBzZHAgPSAnJztcclxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplKSB7XHJcbiAgICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGNwUGFyYW1ldGVycy5tdXgpIHtcclxuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChydGNwUGFyYW1ldGVycy5zc3JjICE9PSB1bmRlZmluZWQgJiYgcnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcclxuICAgICAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNkcDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xyXG4gICAgLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cclxuICAgIFNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgbGV0IHBhcnRzO1xyXG4gICAgICBjb25zdCBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xyXG4gICAgICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0cmVhbTogcGFydHNbMF0sXHJcbiAgICAgICAgICB0cmFjazogcGFydHNbMV1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XHJcbiAgICAgIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxyXG4gICAgICAgICAgdHJhY2s6IHBhcnRzWzFdXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTQ1RQXHJcbiAgICAvLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcclxuICAgIC8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XHJcbiAgICBTRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGNvbnN0IG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xyXG4gICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XHJcbiAgICAgIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xyXG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcclxuICAgICAgaWYgKHNjdHBQb3J0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxyXG4gICAgICAgICAgcHJvdG9jb2w6IG1saW5lLmZtdCxcclxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XHJcbiAgICAgIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gc2N0cE1hcExpbmVzWzBdLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcclxuICAgICAgICAgIHByb3RvY29sOiBwYXJ0c1sxXSxcclxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTQ1RQXHJcbiAgICAvLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXHJcbiAgICAvLyBzdXBwb3J0IGJ5IG5vdyByZWNlaXZpbmcgaW4gdGhpcyBmb3JtYXQsIHVubGVzcyB3ZSBvcmlnaW5hbGx5IHBhcnNlZFxyXG4gICAgLy8gYXMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1IGZvcm1hdCAoaW5kaWNhdGVkIGJ5IHRoZSBtLWxpbmVcclxuICAgIC8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcclxuICAgIFNEUFV0aWxzLndyaXRlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG1lZGlhLCBzY3RwKSB7XHJcbiAgICAgIGxldCBvdXRwdXQgPSBbXTtcclxuICAgICAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xyXG4gICAgICAgIG91dHB1dCA9IFsnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJ1xcclxcbicsICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJywgJ2E9c2N0cC1wb3J0OicgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJ107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXHJcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXHJcbiAgICAvLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcclxuICAgIC8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxyXG4gICAgU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIyKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gV3JpdGUgYm9pbGVyIHBsYXRlIGZvciBzdGFydCBvZiBTRFBcclxuICAgIC8vIHNlc3NJZCBhcmd1bWVudCBpcyBvcHRpb25hbCAtIGlmIG5vdCBzdXBwbGllZCBpdCB3aWxsXHJcbiAgICAvLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcclxuICAgIC8vIHNlc3NWZXJzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAyXHJcbiAgICAvLyBzZXNzVXNlciBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gJ3RoaXNpc2FkYXB0ZXJvcnRjJ1xyXG4gICAgU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbiAoc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xyXG4gICAgICBsZXQgc2Vzc2lvbklkO1xyXG4gICAgICBjb25zdCB2ZXJzaW9uID0gc2Vzc1ZlciAhPT0gdW5kZWZpbmVkID8gc2Vzc1ZlciA6IDI7XHJcbiAgICAgIGlmIChzZXNzSWQpIHtcclxuICAgICAgICBzZXNzaW9uSWQgPSBzZXNzSWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcclxuICAgICAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXHJcbiAgICAgIHJldHVybiAndj0wXFxyXFxuJyArICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgKyAncz0tXFxyXFxuJyArICd0PTAgMFxcclxcbic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxyXG4gICAgU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcclxuICAgICAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXHJcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3dpdGNoIChsaW5lc1tpXSkge1xyXG4gICAgICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XHJcbiAgICAgICAgICBjYXNlICdhPXNlbmRvbmx5JzpcclxuICAgICAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxyXG4gICAgICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHJpbmcoMik7XHJcbiAgICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXNzaW9ucGFydCkge1xyXG4gICAgICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAnc2VuZHJlY3YnO1xyXG4gICAgfTtcclxuICAgIFNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xyXG4gICAgICBjb25zdCBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiBtbGluZVswXS5zdWJzdHJpbmcoMik7XHJcbiAgICB9O1xyXG4gICAgU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XHJcbiAgICB9O1xyXG4gICAgU0RQVXRpbHMucGFyc2VNTGluZSA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAga2luZDogcGFydHNbMF0sXHJcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcclxuICAgICAgICBwcm90b2NvbDogcGFydHNbMl0sXHJcbiAgICAgICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJylcclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcclxuICAgICAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxyXG4gICAgICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxyXG4gICAgICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxyXG4gICAgICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcclxuICAgICAgICBhZGRyZXNzOiBwYXJ0c1s1XVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXHJcbiAgICBTRFBVdGlscy5pc1ZhbGlkU0RQID0gZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMoYmxvYik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAobGluZXNbaV0ubGVuZ3RoIDwgMiB8fCBsaW5lc1tpXS5jaGFyQXQoMSkgIT09ICc9Jykge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGUgbW9kaWZpZXIgYSBiaXQgbW9yZS5cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxyXG4gICAge1xyXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IFNEUFV0aWxzO1xyXG4gICAgfVxyXG4gIH0pKHNkcCQxKTtcclxuICByZXR1cm4gc2RwJDEuZXhwb3J0cztcclxufVxyXG5cclxudmFyIHNkcEV4cG9ydHMgPSByZXF1aXJlU2RwKCk7XHJcbnZhciBTRFBVdGlscyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZHBFeHBvcnRzKTtcclxuXHJcbnZhciBzZHAgPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIGRlZmF1bHQ6IFNEUFV0aWxzXHJcbn0sIFtzZHBFeHBvcnRzXSk7XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XHJcbiAgLy8gZm91bmRhdGlvbiBpcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgYW4gaW5kaWNhdG9yIGZvciBmdWxsIHN1cHBvcnQgZm9yXHJcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1wYy8jcnRjaWNlY2FuZGlkYXRlLWludGVyZmFjZVxyXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xyXG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xyXG4gICAgLy8gUmVtb3ZlIHRoZSBhPSB3aGljaCBzaG91bGRuJ3QgYmUgcGFydCBvZiB0aGUgY2FuZGlkYXRlIHN0cmluZy5cclxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xyXG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XHJcbiAgICAgIGFyZ3MuY2FuZGlkYXRlID0gYXJncy5jYW5kaWRhdGUuc3Vic3RyaW5nKDIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xyXG4gICAgICAvLyBBdWdtZW50IHRoZSBuYXRpdmUgY2FuZGlkYXRlIHdpdGggdGhlIHBhcnNlZCBmaWVsZHMuXHJcbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XHJcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyc2VkQ2FuZGlkYXRlKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYW5kaWRhdGUsIGtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VkQ2FuZGlkYXRlW2tleV1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3ZlcnJpZGUgc2VyaWFsaXplciB0byBub3Qgc2VyaWFsaXplIHRoZSBleHRyYSBhdHRyaWJ1dGVzLlxyXG4gICAgICBuYXRpdmVDYW5kaWRhdGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBjYW5kaWRhdGU6IG5hdGl2ZUNhbmRpZGF0ZS5jYW5kaWRhdGUsXHJcbiAgICAgICAgICBzZHBNaWQ6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNaWQsXHJcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcclxuICAgICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IG5hdGl2ZUNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG5hdGl2ZUNhbmRpZGF0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xyXG4gIH07XHJcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUgPSBOYXRpdmVSVENJY2VDYW5kaWRhdGUucHJvdG90eXBlO1xyXG5cclxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxyXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcclxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcclxuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2NhbmRpZGF0ZScsIHtcclxuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxyXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGU7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ3JlbGF5UHJvdG9jb2wnIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxyXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcclxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcclxuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xyXG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZS5jYW5kaWRhdGUpO1xyXG4gICAgICBpZiAocGFyc2VkQ2FuZGlkYXRlLnR5cGUgPT09ICdyZWxheScpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXHJcbiAgICAgICAgLy8gdG8gcmVsYXlQcm90b2NvbC5cclxuICAgICAgICBlLmNhbmRpZGF0ZS5yZWxheVByb3RvY29sID0ge1xyXG4gICAgICAgICAgMDogJ3RscycsXHJcbiAgICAgICAgICAxOiAndGNwJyxcclxuICAgICAgICAgIDI6ICd1ZHAnXHJcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghKCdzY3RwJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdzY3RwJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uc3Qgc2N0cEluRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcclxuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcclxuICAgIHNlY3Rpb25zLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4gc2VjdGlvbnMuc29tZShtZWRpYVNlY3Rpb24gPT4ge1xyXG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcclxuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiYgbUxpbmUucHJvdG9jb2wuaW5kZXhPZignU0NUUCcpICE9PSAtMTtcclxuICAgIH0pO1xyXG4gIH07XHJcbiAgY29uc3QgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcclxuICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHNvbHV0aW9uIGZvciBkZXRlY3RpbmcgRmlyZWZveD9cclxuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xyXG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XHJcbiAgICAvLyBUZXN0IGZvciBOYU4gKHllcywgdGhpcyBpcyB1Z2x5KVxyXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XHJcbiAgfTtcclxuICBjb25zdCBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiAocmVtb3RlSXNGaXJlZm94KSB7XHJcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cclxuICAgIC8vIE5vdGU6IEFsdGhvdWdoIENocm9tZSBpcyB0ZWNobmljYWxseSBhYmxlIHRvIHNlbmQgdXAgdG8gMjU2IEtpQiwgdGhlXHJcbiAgICAvLyAgICAgICBkYXRhIGRvZXMgbm90IHJlYWNoIHRoZSBvdGhlciBwZWVyIHJlbGlhYmx5LlxyXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxyXG4gICAgbGV0IGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xyXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94Jykge1xyXG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XHJcbiAgICAgICAgaWYgKHJlbW90ZUlzRmlyZWZveCA9PT0gLTEpIHtcclxuICAgICAgICAgIC8vIEZGIDwgNTcgd2lsbCBzZW5kIGluIDE2IEtpQiBjaHVua3MgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgUFBJRFxyXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cclxuICAgICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDE2Mzg0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXHJcbiAgICAgICAgICAvLyBtZXNzYWdlcy4gVGh1cywgc3VwcG9ydGluZyB+MiBHaUIgd2hlbiBzZW5kaW5nLlxyXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDYwKSB7XHJcbiAgICAgICAgLy8gQ3VycmVudGx5LCBhbGwgRkYgPj0gNTcgd2lsbCByZXNldCB0aGUgcmVtb3RlIG1heGltdW0gbWVzc2FnZSBzaXplXHJcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcclxuICAgICAgICAvLyBzdGFnZS4gOihcclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcclxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRkYgPj0gNjAgc3VwcG9ydHMgc2VuZGluZyB+MiBHaUJcclxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xyXG4gIH07XHJcbiAgY29uc3QgZ2V0TWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHJlbW90ZUlzRmlyZWZveCkge1xyXG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXHJcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cclxuICAgIGxldCBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xyXG5cclxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xyXG4gICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgaXQgaGVyZSB0byBhdm9pZCBhIGZhaWx1cmUgd2hlbiBzZW5kaW5nLlxyXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XHJcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3KSB7XHJcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcclxuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xyXG4gICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xyXG4gICAgICAvLyBJZiB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJlbW90ZSBTRFAgYW5kXHJcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXHJcbiAgICAgIC8vIH4yIEdpQi5cclxuICAgICAgbWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xyXG4gIH07XHJcbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XHJcbiAgICB0aGlzLl9zY3RwID0gbnVsbDtcclxuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXHJcbiAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXHJcbiAgICAvLyB0byBjb3ZlciB1cCB0aGUgbWVzcy5cclxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBzZHBTZW1hbnRpY3NcclxuICAgICAgfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xyXG4gICAgICBpZiAoc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2N0cCcsIHtcclxuICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjdHBJbkRlc2NyaXB0aW9uKGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cclxuICAgICAgY29uc3QgaXNGaXJlZm94ID0gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oYXJndW1lbnRzWzBdKTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXHJcbiAgICAgIGNvbnN0IGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxyXG4gICAgICBjb25zdCByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcclxuICAgICAgbGV0IG1heE1lc3NhZ2VTaXplO1xyXG4gICAgICBpZiAoY2FuU2VuZE1NUyA9PT0gMCAmJiByZW1vdGVNTVMgPT09IDApIHtcclxuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgfSBlbHNlIGlmIChjYW5TZW5kTU1TID09PSAwIHx8IHJlbW90ZU1NUyA9PT0gMCkge1xyXG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5tYXgoY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWluKGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xyXG4gICAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICAgIGNvbnN0IHNjdHAgPSB7fTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjdHAsICdtYXhNZXNzYWdlU2l6ZScsIHtcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdykge1xyXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBOb3RlOiBBbHRob3VnaCBGaXJlZm94ID49IDU3IGhhcyBhIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgdGhlIG1heGltdW1cclxuICAvLyAgICAgICBtZXNzYWdlIHNpemUgY2FuIGJlIHJlc2V0IGZvciBhbGwgZGF0YSBjaGFubmVscyBhdCBhIGxhdGVyIHN0YWdlLlxyXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxyXG5cclxuICBmdW5jdGlvbiB3cmFwRGNTZW5kKGRjLCBwYykge1xyXG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XHJcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgaWYgKGRjLnJlYWR5U3RhdGUgPT09ICdvcGVuJyAmJiBwYy5zY3RwICYmIGxlbmd0aCA+IHBjLnNjdHAubWF4TWVzc2FnZVNpemUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSAoY2FuIHNlbmQgYSBtYXhpbXVtIG9mICcgKyBwYy5zY3RwLm1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3JpZ0RhdGFDaGFubmVsU2VuZC5hcHBseShkYywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGNvbnN0IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKCkge1xyXG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xyXG4gICAgcmV0dXJuIGRhdGFDaGFubmVsO1xyXG4gIH07XHJcbiAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnZGF0YWNoYW5uZWwnLCBlID0+IHtcclxuICAgIHdyYXBEY1NlbmQoZS5jaGFubmVsLCBlLnRhcmdldCk7XHJcbiAgICByZXR1cm4gZTtcclxuICB9KTtcclxufVxyXG5cclxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxyXG4gKiBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTYxNDUjYzEyXHJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxyXG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXHJcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNjU4MjdcclxuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cclxuICovXHJcbmZ1bmN0aW9uIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xyXG4gICAgZ2V0KCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXHJcbiAgICAgICAgY2hlY2tpbmc6ICdjb25uZWN0aW5nJ1xyXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcclxuICAgIH0sXHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgfSk7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB7XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xyXG4gICAgfSxcclxuICAgIHNldChjYikge1xyXG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICBjb25zdCBvcmlnTWV0aG9kID0gcHJvdG9bbWV0aG9kXTtcclxuICAgIHByb3RvW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkgPSBlID0+IHtcclxuICAgICAgICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xyXG4gICAgICAgICAgICBwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSA9IHBjLmNvbm5lY3Rpb25TdGF0ZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgRXZlbnQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGUpO1xyXG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcclxuICAvKiByZW1vdmUgYT1leHRtYXAtYWxsb3ctbWl4ZWQgZm9yIHdlYnJ0Yy5vcmcgPCBNNzEgKi9cclxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMuX3NhZmFyaVZlcnNpb24gPj0gMTMuMSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbihkZXNjKSB7XHJcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xyXG4gICAgICBjb25zdCBzZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xyXG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcclxuICAgICAgfSkuam9pbignXFxuJyk7XHJcbiAgICAgIC8vIFNhZmFyaSBlbmZvcmNlcyByZWFkLW9ubHktbmVzcyBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24gZmllbGRzLlxyXG4gICAgICBpZiAod2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiAmJiBkZXNjIGluc3RhbmNlb2Ygd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcclxuICAgICAgICAgIHR5cGU6IGRlc2MudHlwZSxcclxuICAgICAgICAgIHNkcFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlc2Muc2RwID0gc2RwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIC8vIFN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcclxuICAvLyBhcyB3ZWxsIGFzIGFkZEljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOiBcIlwiLCAuLi59KVxyXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk3ODU4MlxyXG4gIC8vIE5vdGU6IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBwb2x5ZmlsbHMgd2hpY2ggY2hhbmdlIHRoZSBzaWduYXR1cmUuXHJcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xyXG4gIGlmICghbmF0aXZlQWRkSWNlQ2FuZGlkYXRlIHx8IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBhZGRJY2VDYW5kaWRhdGUoKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xyXG4gICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XHJcbiAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXHJcbiAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy5cclxuICAgIC8vIE5hdGl2ZSBzdXBwb3J0IGZvciBpZ25vcmluZyBleGlzdHMgZm9yIENocm9tZSBNNzcrLlxyXG4gICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxyXG4gICAgLy8gdmVyc2lvbiB0aGF0IGFsc28gaWdub3JlcyBhZGRJY2VDYW5kaWRhdGUobnVsbCkuXHJcbiAgICBpZiAoKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3OCB8fCBicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdzYWZhcmknKSAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxyXG4vLyBzZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aFxyXG5mdW5jdGlvbiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xyXG4gIGlmICghbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbiB8fCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xyXG4gICAgbGV0IGRlc2MgPSBhcmd1bWVudHNbMF0gfHwge307XHJcbiAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnIHx8IGRlc2MudHlwZSAmJiBkZXNjLnNkcCkge1xyXG4gICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHJlbWFpbmluZyBzdGVwcyBzaG91bGQgdGVjaG5pY2FsbHkgaGFwcGVuIHdoZW4gU0xEIGNvbWVzIG9mZiB0aGVcclxuICAgIC8vIFJUQ1BlZXJDb25uZWN0aW9uJ3Mgb3BlcmF0aW9ucyBjaGFpbiAobm90IGFoZWFkIG9mIGdvaW5nIG9uIGl0KSwgYnV0XHJcbiAgICAvLyB0aGlzIGlzIHRvbyBkaWZmaWN1bHQgdG8gc2hpbS4gSW5zdGVhZCwgdGhpcyBzaGltIG9ubHkgY292ZXJzIHRoZVxyXG4gICAgLy8gY29tbW9uIGNhc2Ugd2hlcmUgdGhlIG9wZXJhdGlvbnMgY2hhaW4gaXMgZW1wdHkuIFRoaXMgaXMgaW1wZXJmZWN0LCBidXRcclxuICAgIC8vIHNob3VsZCBjb3ZlciBtYW55IGNhc2VzLiBSYXRpb25hbGU6IEV2ZW4gaWYgd2UgY2FuJ3QgcmVkdWNlIHRoZSBnbGFyZVxyXG4gICAgLy8gd2luZG93IHRvIHplcm8gb24gaW1wZXJmZWN0IGltcGxlbWVudGF0aW9ucywgdGhlcmUncyB2YWx1ZSBpbiB0YXBwaW5nXHJcbiAgICAvLyBpbnRvIHRoZSBwZXJmZWN0IG5lZ290aWF0aW9uIHBhdHRlcm4gdGhhdCBzZXZlcmFsIGJyb3dzZXJzIHN1cHBvcnQuXHJcbiAgICBkZXNjID0ge1xyXG4gICAgICB0eXBlOiBkZXNjLnR5cGUsXHJcbiAgICAgIHNkcDogZGVzYy5zZHBcclxuICAgIH07XHJcbiAgICBpZiAoIWRlc2MudHlwZSkge1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuc2lnbmFsaW5nU3RhdGUpIHtcclxuICAgICAgICBjYXNlICdzdGFibGUnOlxyXG4gICAgICAgIGNhc2UgJ2hhdmUtbG9jYWwtb2ZmZXInOlxyXG4gICAgICAgIGNhc2UgJ2hhdmUtcmVtb3RlLXByYW5zd2VyJzpcclxuICAgICAgICAgIGRlc2MudHlwZSA9ICdvZmZlcic7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgZGVzYy50eXBlID0gJ2Fuc3dlcic7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRlc2Muc2RwIHx8IGRlc2MudHlwZSAhPT0gJ29mZmVyJyAmJiBkZXNjLnR5cGUgIT09ICdhbnN3ZXInKSB7XHJcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmdW5jID0gZGVzYy50eXBlID09PSAnb2ZmZXInID8gdGhpcy5jcmVhdGVPZmZlciA6IHRoaXMuY3JlYXRlQW5zd2VyO1xyXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcykudGhlbihkID0+IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2RdKSk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIGNvbW1vblNoaW0gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQ6IHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQsXHJcbiAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5OiBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHksXHJcbiAgc2hpbUNvbm5lY3Rpb25TdGF0ZTogc2hpbUNvbm5lY3Rpb25TdGF0ZSxcclxuICBzaGltTWF4TWVzc2FnZVNpemU6IHNoaW1NYXhNZXNzYWdlU2l6ZSxcclxuICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb246IHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbixcclxuICBzaGltUlRDSWNlQ2FuZGlkYXRlOiBzaGltUlRDSWNlQ2FuZGlkYXRlLFxyXG4gIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sOiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCxcclxuICBzaGltU2VuZFRocm93VHlwZUVycm9yOiBzaGltU2VuZFRocm93VHlwZUVycm9yXHJcbn0pO1xyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcblxyXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cclxuZnVuY3Rpb24gYWRhcHRlckZhY3RvcnkoKSB7XHJcbiAgbGV0IHtcclxuICAgIHdpbmRvd1xyXG4gIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XHJcbiAgICBzaGltQ2hyb21lOiB0cnVlLFxyXG4gICAgc2hpbUZpcmVmb3g6IHRydWUsXHJcbiAgICBzaGltU2FmYXJpOiB0cnVlXHJcbiAgfTtcclxuICAvLyBVdGlscy5cclxuICBjb25zdCBsb2dnaW5nID0gbG9nO1xyXG4gIGNvbnN0IGJyb3dzZXJEZXRhaWxzID0gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xyXG4gIGNvbnN0IGFkYXB0ZXIgPSB7XHJcbiAgICBicm93c2VyRGV0YWlscyxcclxuICAgIGNvbW1vblNoaW0sXHJcbiAgICBleHRyYWN0VmVyc2lvbjogZXh0cmFjdFZlcnNpb24sXHJcbiAgICBkaXNhYmxlTG9nOiBkaXNhYmxlTG9nLFxyXG4gICAgZGlzYWJsZVdhcm5pbmdzOiBkaXNhYmxlV2FybmluZ3MsXHJcbiAgICAvLyBFeHBvc2Ugc2RwIGFzIGEgY29udmVuaWVuY2UuIEZvciBwcm9kdWN0aW9uIGFwcHMgaW5jbHVkZSBkaXJlY3RseS5cclxuICAgIHNkcFxyXG4gIH07XHJcblxyXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cclxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcclxuICAgIGNhc2UgJ2Nocm9tZSc6XHJcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhc2hpbVBlZXJDb25uZWN0aW9uJDEgfHwgIW9wdGlvbnMuc2hpbUNocm9tZSkge1xyXG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcclxuICAgICAgICByZXR1cm4gYWRhcHRlcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGNhbiBub3QgZGV0ZXJtaW5lIHZlcnNpb24sIG5vdCBzaGltbWluZy4nKTtcclxuICAgICAgICByZXR1cm4gYWRhcHRlcjtcclxuICAgICAgfVxyXG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcclxuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cclxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XHJcblxyXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxyXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xyXG4gICAgICBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpO1xyXG4gICAgICBzaGltUGVlckNvbm5lY3Rpb24kMSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbU9uVHJhY2skMSh3aW5kb3cpO1xyXG4gICAgICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpO1xyXG4gICAgICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xyXG4gICAgICBmaXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xyXG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xyXG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xyXG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2ZpcmVmb3gnOlxyXG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24gfHwgIW9wdGlvbnMuc2hpbUZpcmVmb3gpIHtcclxuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcclxuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cclxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xyXG5cclxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1QZWVyQ29ubmVjdGlvbi5cclxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcclxuICAgICAgc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1PblRyYWNrKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcclxuICAgICAgc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xyXG4gICAgICBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KTtcclxuICAgICAgc2hpbUdldFBhcmFtZXRlcnMod2luZG93KTtcclxuICAgICAgc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KTtcclxuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xyXG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ3NhZmFyaSc6XHJcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XHJcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xyXG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxyXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcclxuXHJcbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltQ2FsbGJhY2tBUEkuXHJcbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpO1xyXG4gICAgICBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KTtcclxuICAgICAgc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KTtcclxuICAgICAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpO1xyXG4gICAgICBzaGltR2V0VXNlck1lZGlhKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1BdWRpb0NvbnRleHQod2luZG93KTtcclxuICAgICAgc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xyXG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xyXG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcclxuICAgICAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIGFkYXB0ZXI7XHJcbn1cclxuXHJcbi8qXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXHJcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcclxuICogIHRyZWUuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxuXHJcbmFkYXB0ZXJGYWN0b3J5KHtcclxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogd2luZG93XHJcbn0pO1xyXG5cclxuY29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XHJcbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcclxuY29uc3QgREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSA9IDEwO1xyXG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcclxuY29uc3QgRTJFRV9GTEFHID0gJ2xrX2UyZWUnO1xyXG5jb25zdCBTQUxUID0gJ0xLRnJhbWVFbmNyeXB0aW9uS2V5JztcclxuY29uc3QgS0VZX1BST1ZJREVSX0RFRkFVTFRTID0ge1xyXG4gIHNoYXJlZEtleTogZmFsc2UsXHJcbiAgcmF0Y2hldFNhbHQ6IFNBTFQsXHJcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXHJcbiAgZmFpbHVyZVRvbGVyYW5jZTogREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSxcclxuICBrZXlyaW5nU2l6ZTogMTZcclxufTtcclxuXHJcbnZhciBLZXlQcm92aWRlckV2ZW50O1xyXG4oZnVuY3Rpb24gKEtleVByb3ZpZGVyRXZlbnQpIHtcclxuICBLZXlQcm92aWRlckV2ZW50W1wiU2V0S2V5XCJdID0gXCJzZXRLZXlcIjtcclxuICAvKiogRXZlbnQgZm9yIHJlcXVlc3RpbmcgdG8gcmF0Y2hldCB0aGUga2V5IHVzZWQgdG8gZW5jcnlwdCB0aGUgc3RyZWFtICovXHJcbiAgS2V5UHJvdmlkZXJFdmVudFtcIlJhdGNoZXRSZXF1ZXN0XCJdID0gXCJyYXRjaGV0UmVxdWVzdFwiO1xyXG4gIC8qKiBFbWl0dGVkIHdoZW4gYSBrZXkgaXMgcmF0Y2hldGVkLiBDb3VsZCBiZSBhZnRlciBhdXRvLXJhdGNoZXRpbmcgb24gZGVjcnlwdGlvbiBmYWlsdXJlIG9yXHJcbiAgICogIGZvbGxvd2luZyBhIGBSYXRjaGV0UmVxdWVzdGAsIHdpbGwgY29udGFpbiB0aGUgcmF0Y2hldGVkIGtleSBtYXRlcmlhbCAqL1xyXG4gIEtleVByb3ZpZGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xyXG59KShLZXlQcm92aWRlckV2ZW50IHx8IChLZXlQcm92aWRlckV2ZW50ID0ge30pKTtcclxudmFyIEtleUhhbmRsZXJFdmVudDtcclxuKGZ1bmN0aW9uIChLZXlIYW5kbGVyRXZlbnQpIHtcclxuICAvKiogRW1pdHRlZCB3aGVuIGEga2V5IGhhcyBiZWVuIHJhdGNoZXRlZC4gSXMgZW1pdHRlZCB3aGVuIGFueSBrZXkgaGFzIGJlZW4gcmF0Y2hldGVkXHJcbiAgICogaS5lLiB3aGVuIHRoZSBGcmFtZUNyeXB0b3IgdHJpZWQgdG8gcmF0Y2hldCB3aGVuIGRlY3J5cHRpb24gaXMgZmFpbGluZyAgKi9cclxuICBLZXlIYW5kbGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xyXG59KShLZXlIYW5kbGVyRXZlbnQgfHwgKEtleUhhbmRsZXJFdmVudCA9IHt9KSk7XHJcbnZhciBFbmNyeXB0aW9uRXZlbnQ7XHJcbihmdW5jdGlvbiAoRW5jcnlwdGlvbkV2ZW50KSB7XHJcbiAgRW5jcnlwdGlvbkV2ZW50W1wiUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xyXG4gIEVuY3J5cHRpb25FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XHJcbn0pKEVuY3J5cHRpb25FdmVudCB8fCAoRW5jcnlwdGlvbkV2ZW50ID0ge30pKTtcclxudmFyIENyeXB0b3JFdmVudDtcclxuKGZ1bmN0aW9uIChDcnlwdG9yRXZlbnQpIHtcclxuICBDcnlwdG9yRXZlbnRbXCJFcnJvclwiXSA9IFwiY3J5cHRvckVycm9yXCI7XHJcbn0pKENyeXB0b3JFdmVudCB8fCAoQ3J5cHRvckV2ZW50ID0ge30pKTtcclxuXHJcbmZ1bmN0aW9uIGlzRTJFRVN1cHBvcnRlZCgpIHtcclxuICByZXR1cm4gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkgfHwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKTtcclxufVxyXG5mdW5jdGlvbiBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpIHtcclxuICAvLyBAdHMtaWdub3JlXHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gIC8vIEB0cy1pZ25vcmVcclxuICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuY3JlYXRlRW5jb2RlZFN0cmVhbXMgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmZ1bmN0aW9uIGlzVmlkZW9GcmFtZShmcmFtZSkge1xyXG4gIHJldHVybiAndHlwZScgaW4gZnJhbWU7XHJcbn1cclxuZnVuY3Rpb24gaW1wb3J0S2V5KGtleUJ5dGVzXzEpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2V5Qnl0ZXMpIHtcclxuICAgIGxldCBhbGdvcml0aG0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcclxuICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE1cclxuICAgIH07XHJcbiAgICBsZXQgdXNhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdlbmNyeXB0JztcclxuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2ltcG9ydEtleVxyXG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleUJ5dGVzLCBhbGdvcml0aG0sIGZhbHNlLCB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcclxuICAgIH0oKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcocGFzc3dvcmQpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShwYXNzd29yZCksIHtcclxuICAgICAgbmFtZTogJ1BCS0RGMidcclxuICAgIH0sIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xyXG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXIpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10pO1xyXG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWUsIHNhbHQpIHtcclxuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xyXG4gIHN3aXRjaCAoYWxnb3JpdGhtTmFtZSkge1xyXG4gICAgY2FzZSAnSEtERic6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogJ0hLREYnLFxyXG4gICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxyXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcclxuICAgICAgICBpbmZvOiBuZXcgQXJyYXlCdWZmZXIoMTI4KVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSAnUEJLREYyJzpcclxuICAgICAge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBuYW1lOiAnUEJLREYyJyxcclxuICAgICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxyXG4gICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxyXG4gICAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxnb3JpdGhtIFwiLmNvbmNhdChhbGdvcml0aG1OYW1lLCBcIiBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRcIikpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogRGVyaXZlcyBhIHNldCBvZiBrZXlzIGZyb20gdGhlIG1hc3RlciBrZXkuXHJcbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjFcclxuICovXHJcbmZ1bmN0aW9uIGRlcml2ZUtleXMobWF0ZXJpYWwsIHNhbHQpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlS2V5I0hLREZcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXHJcbiAgICBjb25zdCBlbmNyeXB0aW9uS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIHtcclxuICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0sXHJcbiAgICAgIGxlbmd0aDogMTI4XHJcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtYXRlcmlhbCxcclxuICAgICAgZW5jcnlwdGlvbktleVxyXG4gICAgfTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCkge1xyXG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpO1xyXG59XHJcbi8qKlxyXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXHJcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuNS4xXHJcbiAqL1xyXG5mdW5jdGlvbiByYXRjaGV0KG1hdGVyaWFsLCBzYWx0KSB7XHJcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUJpdHNcclxuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbmVlZHNSYnNwVW5lc2NhcGluZyhmcmFtZURhdGEpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcclxuICAgIGlmIChmcmFtZURhdGFbaV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDFdID09IDAgJiYgZnJhbWVEYXRhW2kgKyAyXSA9PSAzKSByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmJzcChzdHJlYW0pIHtcclxuICBjb25zdCBkYXRhT3V0ID0gW107XHJcbiAgdmFyIGxlbmd0aCA9IHN0cmVhbS5sZW5ndGg7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOykge1xyXG4gICAgLy8gQmUgY2FyZWZ1bCBhYm91dCBvdmVyL3VuZGVyZmxvdyBoZXJlLiBieXRlX2xlbmd0aF8gLSAzIGNhbiB1bmRlcmZsb3csIGFuZFxyXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXHJcbiAgICAvLyBhYm92ZSwgYW5kIHRoYXQgZXhwcmVzc2lvbiB3aWxsIHByb2R1Y2UgdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IGluXHJcbiAgICAvLyB0aGUgc3RyZWFtIGluY2x1ZGluZyB0aGUgYnl0ZSBhdCBpLlxyXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xyXG4gICAgICAvLyBUd28gcmJzcCBieXRlcy5cclxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcclxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcclxuICAgICAgLy8gU2tpcCB0aGUgZW11bGF0aW9uIGJ5dGUuXHJcbiAgICAgIGkrKztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFNpbmdsZSByYnNwIGJ5dGUuXHJcbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcclxufVxyXG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xyXG5jb25zdCBrRW11bGF0aW9uQnl0ZSA9IDM7XHJcbmZ1bmN0aW9uIHdyaXRlUmJzcChkYXRhX2luKSB7XHJcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xyXG4gIHZhciBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBieXRlID0gZGF0YV9pbltpXTtcclxuICAgIGlmIChieXRlIDw9IGtFbXVsYXRpb25CeXRlICYmIG51bUNvbnNlY3V0aXZlWmVyb3MgPj0ga1plcm9zSW5TdGFydFNlcXVlbmNlKSB7XHJcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxyXG4gICAgICBkYXRhT3V0LnB1c2goa0VtdWxhdGlvbkJ5dGUpO1xyXG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcclxuICAgIH1cclxuICAgIGRhdGFPdXQucHVzaChieXRlKTtcclxuICAgIGlmIChieXRlID09IDApIHtcclxuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhT3V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmNsYXNzIEJhc2VLZXlQcm92aWRlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGJlaW5nIGludm9rZWQgYWZ0ZXIgYSBrZXkgaGFzIGJlZW4gcmF0Y2hldGVkLlxyXG4gICAgICogQ2FuIGhhcHBlbiB3aGVuOlxyXG4gICAgICogLSBBIGRlY3J5cHRpb24gZmFpbHVyZSBvY2N1cnMgYW5kIHRoZSBrZXkgaXMgYXV0by1yYXRjaGV0ZWRcclxuICAgICAqIC0gQSByYXRjaGV0IHJlcXVlc3QgaXMgc2VudCAoc2VlIHtAbGluayByYXRjaGV0S2V5KCl9KVxyXG4gICAgICogQHBhcmFtIHJhdGNoZXRSZXN1bHQgQ29udGFpbnMgdGhlIHJhdGNoZXRlZCBjaGFpbiBrZXkgKGV4cG9ydGFibGUgdG8gb3RoZXIgcGFydGljaXBhbnRzKSBhbmQgdGhlIGRlcml2ZWQgbmV3IGtleSBtYXRlcmlhbC5cclxuICAgICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkXHJcbiAgICAgKiBAcGFyYW0ga2V5SW5kZXhcclxuICAgICAqL1xyXG4gICAgdGhpcy5vbktleVJhdGNoZXRlZCA9IChyYXRjaGV0UmVzdWx0LCBwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4ge1xyXG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdrZXkgcmF0Y2hldGVkIGV2ZW50IHJlY2VpdmVkJywge1xyXG4gICAgICAgIHJhdGNoZXRSZXN1bHQsXHJcbiAgICAgICAgcGFydGljaXBhbnRJZCxcclxuICAgICAgICBrZXlJbmRleFxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0aGlzLmtleUluZm9NYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEtFWV9QUk9WSURFUl9ERUZBVUxUUyksIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIGEga2V5IGhhcyBiZWVuIHNldCBmb3IgYSBwYXJ0aWNpcGFudFxyXG4gICAqIEBwYXJhbSBrZXlcclxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAqIEBwYXJhbSBrZXlJbmRleFxyXG4gICAqL1xyXG4gIG9uU2V0RW5jcnlwdGlvbktleShrZXksIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XHJcbiAgICBjb25zdCBrZXlJbmZvID0ge1xyXG4gICAgICBrZXksXHJcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXHJcbiAgICAgIGtleUluZGV4XHJcbiAgICB9O1xyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hhcmVkS2V5ICYmICFwYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGljaXBhbnQgaWRlbnRpdHkgbmVlZHMgdG8gYmUgcGFzc2VkIGZvciBlbmNyeXB0aW9uIGtleSBpZiBzaGFyZWRLZXkgb3B0aW9uIGlzIGZhbHNlJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmtleUluZm9NYXAuc2V0KFwiXCIuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkgIT09IG51bGwgJiYgcGFydGljaXBhbnRJZGVudGl0eSAhPT0gdm9pZCAwID8gcGFydGljaXBhbnRJZGVudGl0eSA6ICdzaGFyZWQnLCBcIi1cIikuY29uY2F0KGtleUluZGV4ICE9PSBudWxsICYmIGtleUluZGV4ICE9PSB2b2lkIDAgPyBrZXlJbmRleCA6IDApLCBrZXlJbmZvKTtcclxuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XHJcbiAgfVxyXG4gIGdldEtleXMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleUluZm9NYXAudmFsdWVzKCkpO1xyXG4gIH1cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICB9XHJcbiAgcmF0Y2hldEtleShwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xyXG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYmFzaWMgS2V5UHJvdmlkZXIgaW1wbGVtZW50YXRpb24gaW50ZW5kZWQgZm9yIGEgc2luZ2xlIHNoYXJlZFxyXG4gKiBwYXNzcGhyYXNlIGJldHdlZW4gYWxsIHBhcnRpY2lwYW50c1xyXG4gKiBAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG5jbGFzcyBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciBleHRlbmRzIEJhc2VLZXlQcm92aWRlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xyXG4gICAgICBzaGFyZWRLZXk6IHRydWUsXHJcbiAgICAgIC8vIGZvciBhIHNoYXJlZCBrZXkgcHJvdmlkZXIgZmFpbGluZyB0byBkZWNyeXB0IGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50XHJcbiAgICAgIC8vIHNob3VsZCBub3QgbWFyayB0aGUga2V5IGFzIGludmFsaWQsIHNvIHdlIGFjY2VwdCB3cm9uZyBrZXlzIGZvcmV2ZXJcclxuICAgICAgLy8gYW5kIHdvbid0IHRyeSB0byBhdXRvLXJhdGNoZXRcclxuICAgICAgcmF0Y2hldFdpbmRvd1NpemU6IDAsXHJcbiAgICAgIGZhaWx1cmVUb2xlcmFuY2U6IC0xXHJcbiAgICB9KTtcclxuICAgIHN1cGVyKG9wdHMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBY2NlcHRzIGEgcGFzc3BocmFzZSB0aGF0J3MgdXNlZCB0byBjcmVhdGUgdGhlIGNyeXB0byBrZXlzLlxyXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXHJcbiAgICogV2hlbiBwYXNzaW5nIGluIGFuIEFycmF5IGJ1ZmZlciBvZiBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gbnVtYmVycywgSEtERiBpcyBiZWluZyB1c2VkLiAocmVjb21tZW5kZWQpXHJcbiAgICogQHBhcmFtIGtleVxyXG4gICAqL1xyXG4gIHNldEtleShrZXkpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHlpZWxkIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhrZXkpIDogeWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGtleSk7XHJcbiAgICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSB8fCAnYW4gZXJyb3IgaGFzIG9jY3VyZWQnKTtcclxuICAgIHRoaXMubmFtZSA9ICdMaXZlS2l0RXJyb3InO1xyXG4gICAgdGhpcy5jb2RlID0gY29kZTtcclxuICB9XHJcbn1cclxudmFyIENvbm5lY3Rpb25FcnJvclJlYXNvbjtcclxuKGZ1bmN0aW9uIChDb25uZWN0aW9uRXJyb3JSZWFzb24pIHtcclxuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiTm90QWxsb3dlZFwiXSA9IDBdID0gXCJOb3RBbGxvd2VkXCI7XHJcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIlNlcnZlclVucmVhY2hhYmxlXCJdID0gMV0gPSBcIlNlcnZlclVucmVhY2hhYmxlXCI7XHJcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkludGVybmFsRXJyb3JcIl0gPSAyXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xyXG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJDYW5jZWxsZWRcIl0gPSAzXSA9IFwiQ2FuY2VsbGVkXCI7XHJcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkxlYXZlUmVxdWVzdFwiXSA9IDRdID0gXCJMZWF2ZVJlcXVlc3RcIjtcclxuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiVGltZW91dFwiXSA9IDVdID0gXCJUaW1lb3V0XCI7XHJcbn0pKENvbm5lY3Rpb25FcnJvclJlYXNvbiB8fCAoQ29ubmVjdGlvbkVycm9yUmVhc29uID0ge30pKTtcclxuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24sIHN0YXR1cywgY29udGV4dCkge1xyXG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XHJcbiAgICB0aGlzLm5hbWUgPSAnQ29ubmVjdGlvbkVycm9yJztcclxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5yZWFzb25OYW1lID0gQ29ubmVjdGlvbkVycm9yUmVhc29uW3JlYXNvbl07XHJcbiAgfVxyXG59XHJcbmNsYXNzIERldmljZVVuc3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgIHN1cGVyKDIxLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnZGV2aWNlIGlzIHVuc3VwcG9ydGVkJyk7XHJcbiAgICB0aGlzLm5hbWUgPSAnRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcic7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICBzdXBlcigyMCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3RyYWNrIGlzIGludmFsaWQnKTtcclxuICAgIHRoaXMubmFtZSA9ICdUcmFja0ludmFsaWRFcnJvcic7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICBzdXBlcigxMCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3Vuc3VwcG9ydGVkIHNlcnZlcicpO1xyXG4gICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkU2VydmVyJztcclxuICB9XHJcbn1cclxuY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmV4cGVjdGVkIGNvbm5lY3Rpb24gc3RhdGUnKTtcclxuICAgIHRoaXMubmFtZSA9ICdVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlJztcclxuICB9XHJcbn1cclxuY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgc3VwZXIoMTMsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmFibGUgdG8gbmVnb3RpYXRlJyk7XHJcbiAgICB0aGlzLm5hbWUgPSAnTmVnb3RpYXRpb25FcnJvcic7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFB1Ymxpc2hEYXRhRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgIHN1cGVyKDE0LCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xyXG4gICAgdGhpcy5uYW1lID0gJ1B1Ymxpc2hEYXRhRXJyb3InO1xyXG4gIH1cclxufVxyXG5jbGFzcyBQdWJsaXNoVHJhY2tFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XHJcbiAgICBzdXBlcigxNSwgbWVzc2FnZSk7XHJcbiAgICB0aGlzLm5hbWUgPSAnUHVibGlzaFRyYWNrRXJyb3InO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFNpZ25hbFJlcXVlc3RFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVhc29uKSB7XHJcbiAgICBzdXBlcigxNSwgbWVzc2FnZSk7XHJcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcclxuICAgIHRoaXMucmVhc29uTmFtZSA9IHR5cGVvZiByZWFzb24gPT09ICdzdHJpbmcnID8gcmVhc29uIDogUmVxdWVzdFJlc3BvbnNlX1JlYXNvbltyZWFzb25dO1xyXG4gIH1cclxufVxyXG52YXIgTWVkaWFEZXZpY2VGYWlsdXJlO1xyXG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xyXG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcclxuICBNZWRpYURldmljZUZhaWx1cmVbXCJQZXJtaXNzaW9uRGVuaWVkXCJdID0gXCJQZXJtaXNzaW9uRGVuaWVkXCI7XHJcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcclxuICBNZWRpYURldmljZUZhaWx1cmVbXCJOb3RGb3VuZFwiXSA9IFwiTm90Rm91bmRcIjtcclxuICAvLyBkZXZpY2UgaXMgaW4gdXNlLiBPbiBXaW5kb3dzLCBvbmx5IGEgc2luZ2xlIHRhYiBtYXkgZ2V0IGFjY2VzcyB0byBhIGRldmljZSBhdCBhIHRpbWUuXHJcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiRGV2aWNlSW5Vc2VcIl0gPSBcIkRldmljZUluVXNlXCI7XHJcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiT3RoZXJcIl0gPSBcIk90aGVyXCI7XHJcbn0pKE1lZGlhRGV2aWNlRmFpbHVyZSB8fCAoTWVkaWFEZXZpY2VGYWlsdXJlID0ge30pKTtcclxuKGZ1bmN0aW9uIChNZWRpYURldmljZUZhaWx1cmUpIHtcclxuICBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IgJiYgJ25hbWUnIGluIGVycm9yKSB7XHJcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xyXG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuTm90Rm91bmQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5QZXJtaXNzaW9uRGVuaWVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcclxuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLkRldmljZUluVXNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlID0gZ2V0RmFpbHVyZTtcclxufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xyXG5cclxudmFyIENyeXB0b3JFcnJvclJlYXNvbjtcclxuKGZ1bmN0aW9uIChDcnlwdG9yRXJyb3JSZWFzb24pIHtcclxuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiSW52YWxpZEtleVwiXSA9IDBdID0gXCJJbnZhbGlkS2V5XCI7XHJcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIk1pc3NpbmdLZXlcIl0gPSAxXSA9IFwiTWlzc2luZ0tleVwiO1xyXG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJJbnRlcm5hbEVycm9yXCJdID0gMl0gPSBcIkludGVybmFsRXJyb3JcIjtcclxufSkoQ3J5cHRvckVycm9yUmVhc29uIHx8IChDcnlwdG9yRXJyb3JSZWFzb24gPSB7fSkpO1xyXG5jbGFzcyBDcnlwdG9yRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgIGxldCByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IENyeXB0b3JFcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yO1xyXG4gICAgbGV0IHBhcnRpY2lwYW50SWRlbnRpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcclxuICAgIHN1cGVyKDQwLCBtZXNzYWdlKTtcclxuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xyXG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFdmVudHMgYXJlIHRoZSBwcmltYXJ5IHdheSBMaXZlS2l0IG5vdGlmaWVzIHlvdXIgYXBwbGljYXRpb24gb2YgY2hhbmdlcy5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyBhcmUgZXZlbnRzIGVtaXR0ZWQgYnkgW1tSb29tXV0sIGxpc3RlbiB0byByb29tIGV2ZW50cyBsaWtlXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSA9PiB7fSlcclxuICogYGBgXHJcbiAqL1xyXG52YXIgUm9vbUV2ZW50O1xyXG4oZnVuY3Rpb24gKFJvb21FdmVudCkge1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkIGFuZCBpdCdzIGF0dGVtcHRpbmdcclxuICAgKiB0byByZWNvbm5lY3QuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcclxuICAvKipcclxuICAgKiBXaGVuIHRoZSBzaWduYWwgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkLiBUaGlzIGlzbid0IG5vdGljZWFibGUgdG8gdXNlcnMgbW9zdCBvZiB0aGUgdGltZS5cclxuICAgKiBJdCB3aWxsIHJlc29sdmUgd2l0aCBhIGBSb29tRXZlbnQuUmVjb25uZWN0ZWRgIG9uY2UgdGhlIHNpZ25hbCBjb25uZWN0aW9uIGhhcyBiZWVuIHJlLWVzdGFibGlzaGVkLlxyXG4gICAqIElmIG1lZGlhIGZhaWxzIGFkZGl0aW9uYWxseSBpdCBhbiBhZGRpdGlvbmFsIGBSb29tRXZlbnQuUmVjb25uZWN0aW5nYCB3aWxsIGJlIGVtaXR0ZWQuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiU2lnbmFsUmVjb25uZWN0aW5nXCJdID0gXCJzaWduYWxSZWNvbm5lY3RpbmdcIjtcclxuICAvKipcclxuICAgKiBGaXJlcyB3aGVuIGEgcmVjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUmVjb25uZWN0ZWRcIl0gPSBcInJlY29ubmVjdGVkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBkaXNjb25uZWN0ZWQgZnJvbSByb29tLiBUaGlzIGZpcmVzIHdoZW4gcm9vbS5kaXNjb25uZWN0KCkgaXMgY2FsbGVkIG9yXHJcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWQuXHJcbiAgICpcclxuICAgKiBEaXNjb25uZWN0UmVhc29uIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aHkgdGhlIHBhcnRpY2lwYW50IHdhcyBkaXNjb25uZWN0ZWQuIE5vdGFibGUgcmVhc29ucyBhcmVcclxuICAgKiAtIERVUExJQ0FURV9JREVOVElUWTogYW5vdGhlciBjbGllbnQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eSBoYXMgam9pbmVkIHRoZSByb29tXHJcbiAgICogLSBQQVJUSUNJUEFOVF9SRU1PVkVEOiBwYXJ0aWNpcGFudCB3YXMgcmVtb3ZlZCBieSBSZW1vdmVQYXJ0aWNpcGFudCBBUElcclxuICAgKiAtIFJPT01fREVMRVRFRDogdGhlIHJvb20gaGFzIGVuZGVkIHZpYSBEZWxldGVSb29tIEFQSVxyXG4gICAqXHJcbiAgICogYXJnczogKFtbRGlzY29ubmVjdFJlYXNvbl1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbmV2ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgb2YgdGhlIHJvb20gY2hhbmdlc1xyXG4gICAqXHJcbiAgICogYXJnczogKFtbQ29ubmVjdGlvblN0YXRlXV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblN0YXRlQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gcGFydGljaXBhbnQgaGFzIGJlZW4gbW92ZWQgdG8gYSBkaWZmZXJlbnQgcm9vbSBieSB0aGUgc2VydmljZSByZXF1ZXN0LlxyXG4gICAqIFRoZSBiZWhhdmlvciBsb29rcyBsaWtlIHRoZSBwYXJ0aWNpcGFudCBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgYW5kIHJlY29ubmVjdGVkIHRvIGEgZGlmZmVyZW50IHJvb21cclxuICAgKiBzZWFtbGVzc2x5IHdpdGhvdXQgY29ubmVjdGlvbiBzdGF0ZSB0cmFuc2l0aW9uLlxyXG4gICAqIEEgbmV3IHRva2VuIHdpbGwgYmUgcHJvdmlkZWQgZm9yIHJlY29ubmVjdGluZyB0byB0aGUgbmV3IHJvb20gaWYgbmVlZGVkLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbcm9vbTogc3RyaW5nLCB0b2tlbjogc3RyaW5nXV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTW92ZWRcIl0gPSBcIm1vdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBpbnB1dCBvciBvdXRwdXQgZGV2aWNlcyBvbiB0aGUgbWFjaGluZSBoYXZlIGNoYW5nZWQuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzQ2hhbmdlZFwiXSA9IFwibWVkaWFEZXZpY2VzQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcclxuICAgKiBwYXJ0aWNpcGFudC4gSXQgd2lsbCBub3QgZW1pdCBldmVudHMgZm9yIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhbHJlYWR5XHJcbiAgICogaW4gdGhlIHJvb21cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBsZWF2ZXMgKmFmdGVyKiB0aGUgbG9jYWxcclxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZFwiXSA9IFwicGFydGljaXBhbnREaXNjb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXHJcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxyXG4gICAqXHJcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xyXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBbW0xvY2FsUGFydGljaXBhbnRdXSBoYXMgc3Vic2NyaWJlZCB0byBhIG5ldyB0cmFjay4gVGhpcyBldmVudCB3aWxsICoqYWx3YXlzKipcclxuICAgKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcclxuICAvKipcclxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcclxuICAgKlxyXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQsIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcclxuICAvKipcclxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xyXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1Vuc3Vic2NyaWJlZFwiXSA9IFwidHJhY2tVbnN1YnNjcmliZWRcIjtcclxuICAvKipcclxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1VubXV0ZWRcIl0gPSBcInRyYWNrVW5tdXRlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XHJcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxyXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXHJcbiAgICpcclxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxyXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIGEgbG9jYWwgYXVkaW8gdHJhY2sgaXMgcHVibGlzaGVkIHRoZSBTREsgY2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgY29tcGxldGUgc2lsZW5jZVxyXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cclxuICAgKiBUaGlzIGFsbG93cyBmb3IgYXBwbGljYXRpb25zIHRvIHNob3cgVUkgaW5mb3JtaW5nIHVzZXJzIHRoYXQgdGhleSBtaWdodCBoYXZlIHRvXHJcbiAgICogcmVzZXQgdGhlaXIgYXVkaW8gaGFyZHdhcmUgb3IgY2hlY2sgZm9yIHByb3BlciBkZXZpY2UgY29ubmVjdGl2aXR5LlxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIl0gPSBcImxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cclxuICAgKiBsb3VkZXN0IHNwZWFrZXJzIGZpcnN0LiBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgTG9jYWxQYXJ0aWNpcGFudCB0b28uXHJcbiAgICpcclxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoQXJyYXk8W1tQYXJ0aWNpcGFudF1dPilcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJBY3RpdmVTcGVha2Vyc0NoYW5nZWRcIl0gPSBcImFjdGl2ZVNwZWFrZXJzQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xyXG4gICAqIGFsbCB1c2Vycy5cclxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcclxuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxyXG4gICAqXHJcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cclxuICAgKiBhbGwgdXNlcnMuXHJcbiAgICogV2hlbiBhIHBhcnRpY2lwYW50J3MgYXR0cmlidXRlcyBjaGFuZ2VkLCB0aGlzIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXMgYW5kIHRoZSBwYXJ0aWNpcGFudFxyXG4gICAqIGFyZ3M6IChjaGFuZ2VkQXR0cmlidXRlczogW1tSZWNvcmQ8c3RyaW5nLCBzdHJpbmddXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBwYXJ0aWNpcGFudCdzIHN0YXRlIGNoYW5nZXMgdG8gQUNUSVZFIGFuZCBpcyByZWFkeSB0byBzZW5kL3JlY2VpdmUgZGF0YSBtZXNzYWdlc1xyXG4gICAqXHJcbiAgICogYXJnczogKHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRBY3RpdmVcIl0gPSBcInBhcnRpY2lwYW50QWN0aXZlXCI7XHJcbiAgLyoqXHJcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cclxuICAgKiBhbGwgdXNlcnMuXHJcbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVSb29tTWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHJvb20ncyBzdGF0ZSxcclxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxyXG4gICAqXHJcbiAgICogYXJnczogKHN0cmluZylcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJSb29tTWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJyb29tTWV0YWRhdGFDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXHJcbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXHJcbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXHJcbiAgICpcclxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSwgdG9waWM/OiBzdHJpbmcpXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcclxuICAvKipcclxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSwgZHRtZjogW1tEYXRhUGFja2V0X0tpbmRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSBhIHBhcnRpY2lwYW50J3MgdHJhY2suXHJcbiAgICogQGJldGFcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWRcIl0gPSBcInRyYW5zY3JpcHRpb25SZWNlaXZlZFwiO1xyXG4gIC8qKlxyXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXHJcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcclxuICAgKiBzdWJzY3JpYmVkIHRvLlxyXG4gICAqXHJcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIChyZW1vdGUpIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXHJcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxyXG4gICAqXHJcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxyXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxyXG4gICAqXHJcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0sXHJcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XHJcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXHJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxyXG4gICAqIGJlIGVtaXR0ZWQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcclxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1c11dLFxyXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBzdGF0dXMgZm9yIHRoZSBjdXJyZW50XHJcbiAgICogcGFydGljaXBhbnQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcclxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0sXHJcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgYXVkaW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXHJcbiAgICogYXVkaW8gZWxlbWVudHMuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxyXG4gICAqIGBSb29tLmNhblBsYXliYWNrQXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJhdWRpb1BsYXliYWNrQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCB2aWRlbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cclxuICAgKiBhIHZpZGVvIGVsZW1lbnQuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxyXG4gICAqIENhbGxpbmcgYHJvb20uc3RhcnRWaWRlbygpYCBpbiBhIHVzZXIgZ2VzdHVyZSBldmVudCBoYW5kbGVyIHdpbGwgcmVzdW1lIHRoZSB2aWRlbyBwbGF5YmFjay5cclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZFwiXSA9IFwidmlkZW9QbGF5YmFja0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIHdlIGhhdmUgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgYXR0ZW1wdGluZyB0byBjcmVhdGUgYSB0cmFjay5cclxuICAgKiBUaGUgZXJyb3JzIHRha2UgcGxhY2UgaW4gZ2V0VXNlck1lZGlhKCkuXHJcbiAgICogVXNlIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlKGVycm9yKSB0byBnZXQgdGhlIHJlYXNvbiBvZiBmYWlsdXJlLlxyXG4gICAqIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0Q2FtZXJhRXJyb3JdXSBhbmQgW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RNaWNyb3Bob25lRXJyb3JdXVxyXG4gICAqIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhdWRpbyBvciB2aWRlbyB0cmFjayByZXNwZWN0aXZlbHkuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoZXJyb3I6IEVycm9yKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xyXG4gIC8qKlxyXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxyXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogU2lnbmFsIGNvbm5lY3RlZCwgY2FuIHB1Ymxpc2ggdHJhY2tzLlxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlNpZ25hbENvbm5lY3RlZFwiXSA9IFwic2lnbmFsQ29ubmVjdGVkXCI7XHJcbiAgLyoqXHJcbiAgICogUmVjb3JkaW5nIG9mIGEgcm9vbSBoYXMgc3RhcnRlZC9zdG9wcGVkLiBSb29tLmlzUmVjb3JkaW5nIHdpbGwgYmUgdXBkYXRlZCB0b28uXHJcbiAgICogYXJnczogKGlzUmVjb3JkaW5nOiBib29sZWFuKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIl0gPSBcInJlY29yZGluZ1N0YXR1c0NoYW5nZWRcIjtcclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XHJcbiAgUm9vbUV2ZW50W1wiRW5jcnlwdGlvbkVycm9yXCJdID0gXCJlbmNyeXB0aW9uRXJyb3JcIjtcclxuICAvKipcclxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgY3VycmVudCBidWZmZXIgc3RhdHVzIG9mIGEgZGF0YSBjaGFubmVsIGNoYW5nZXNcclxuICAgKiBhcmdzOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBUcmlnZ2VyZWQgYnkgYSBjYWxsIHRvIHJvb20uc3dpdGNoQWN0aXZlRGV2aWNlXHJcbiAgICogYXJnczogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZylcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJBY3RpdmVEZXZpY2VDaGFuZ2VkXCJdID0gXCJhY3RpdmVEZXZpY2VDaGFuZ2VkXCI7XHJcbiAgUm9vbUV2ZW50W1wiQ2hhdE1lc3NhZ2VcIl0gPSBcImNoYXRNZXNzYWdlXCI7XHJcbiAgLyoqXHJcbiAgICogZmlyZWQgd2hlbiB0aGUgZmlyc3QgcmVtb3RlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIHRoZSBsb2NhbFBhcnRpY2lwYW50J3MgdHJhY2tcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrU3Vic2NyaWJlZFwiXSA9IFwibG9jYWxUcmFja1N1YnNjcmliZWRcIjtcclxuICAvKipcclxuICAgKiBmaXJlZCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gb3RoZXIgcGFydGljaXBhbnRzXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTWV0cmljc1JlY2VpdmVkXCJdID0gXCJtZXRyaWNzUmVjZWl2ZWRcIjtcclxufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xyXG52YXIgUGFydGljaXBhbnRFdmVudDtcclxuKGZ1bmN0aW9uIChQYXJ0aWNpcGFudEV2ZW50KSB7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxyXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cclxuICAgKlxyXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcclxuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFN1Y2Nlc3NmdWxseSBzdWJzY3JpYmVkIHRvIHRoZSBbW1JlbW90ZVBhcnRpY2lwYW50XV0ncyB0cmFjay5cclxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrXV0sIFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmliZWRcIl0gPSBcInRyYWNrU3Vic2NyaWJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xyXG4gICAqXHJcbiAgICogYXJnczogKHRyYWNrIHNpZClcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xyXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5zdWJzY3JpYmVkXCJdID0gXCJ0cmFja1Vuc3Vic2NyaWJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxyXG4gICAqXHJcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1VubXV0ZWRcIl0gPSBcInRyYWNrVW5tdXRlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XHJcbiAgICogd2hlbiB0byB1cGRhdGUgeW91ciBsb2NhbCBVSSB3aXRoIHRoZSBuZXdseSBwdWJsaXNoZWQgdHJhY2suXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHVucHVibGlzaGVkLiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vdyB3aGVuIHRvIHJlbW92ZVxyXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXHJcbiAgICpcclxuICAgKiBXaGVuIGEgdXNlciBzdG9wcyBzaGFyaW5nIHRoZWlyIHNjcmVlbiBieSBwcmVzc2luZyBcIkVuZFwiIG9uIHRoZSBicm93c2VyIFVJLFxyXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcclxuICAvKipcclxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cclxuICAgKiBhbGwgdXNlcnMuXHJcbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXHJcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXHJcbiAgICogVG8gYWNjZXNzIHRoZSBjdXJyZW50IG1ldGFkYXRhLCBzZWUgW1tQYXJ0aWNpcGFudC5tZXRhZGF0YV1dLlxyXG4gICAqXHJcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcclxuICAgKlxyXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcclxuICAgKlxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxyXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxyXG4gICAqIEFsbCBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCByZWNlaXZlIHRoZSBtZXNzYWdlcyBzZW50IHRvIHRoZSByb29tLlxyXG4gICAqXHJcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogU0lQIERUTUYgdG9uZXMgcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIHNlbmRlci5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChkdG1mOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIGRhdGEgc291cmNlLlxyXG4gICAqIEBiZXRhXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogSGFzIHNwZWFraW5nIHN0YXR1cyBjaGFuZ2VkIGZvciB0aGUgY3VycmVudCBwYXJ0aWNpcGFudFxyXG4gICAqXHJcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJJc1NwZWFraW5nQ2hhbmdlZFwiXSA9IFwiaXNTcGVha2luZ0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xyXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXHJcbiAgICogc3Vic2NyaWJlZCB0by5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcclxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXHJcbiAgICpcclxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXHJcbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XHJcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXHJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxyXG4gICAqIGJlIGVtaXR0ZWQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcclxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XHJcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJNZWRpYURldmljZXNFcnJvclwiXSA9IFwibWVkaWFEZXZpY2VzRXJyb3JcIjtcclxuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcclxuICAvKiogQGludGVybmFsICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIkF1ZGlvU3RyZWFtQWNxdWlyZWRcIl0gPSBcImF1ZGlvU3RyZWFtQWNxdWlyZWRcIjtcclxuICAvKipcclxuICAgKiBBIHBhcnRpY2lwYW50J3MgcGVybWlzc2lvbiBoYXMgY2hhbmdlZC5cclxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlBDVHJhY2tBZGRlZFwiXSA9IFwicGNUcmFja0FkZGVkXCI7XHJcbiAgLyoqXHJcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xyXG4gICAqIGFsbCB1c2Vycy5cclxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xyXG4gICAqIGFyZ3M6IChjaGFuZ2VkQXR0cmlidXRlczogW1tSZWNvcmQ8c3RyaW5nLCBzdHJpbmddXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXR0cmlidXRlc0NoYW5nZWRcIl0gPSBcImF0dHJpYnV0ZXNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogZmlyZWQgb24gbG9jYWwgcGFydGljaXBhbnQgb25seSwgd2hlbiB0aGUgZmlyc3QgcmVtb3RlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIHRoZSB0cmFjayBzcGVjaWZpZWQgaW4gdGhlIHBheWxvYWRcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XHJcbiAgLyoqIG9ubHkgZW1pdHRlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJDaGF0TWVzc2FnZVwiXSA9IFwiY2hhdE1lc3NhZ2VcIjtcclxuICAvKipcclxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHBhcnRpY2lwYW50J3Mgc3RhdGUgY2hhbmdlcyB0byBBQ1RJVkUgYW5kIGlzIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBkYXRhIG1lc3NhZ2VzXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIkFjdGl2ZVwiXSA9IFwiYWN0aXZlXCI7XHJcbn0pKFBhcnRpY2lwYW50RXZlbnQgfHwgKFBhcnRpY2lwYW50RXZlbnQgPSB7fSkpO1xyXG4vKiogQGludGVybmFsICovXHJcbnZhciBFbmdpbmVFdmVudDtcclxuKGZ1bmN0aW9uIChFbmdpbmVFdmVudCkge1xyXG4gIEVuZ2luZUV2ZW50W1wiVHJhbnNwb3J0c0NyZWF0ZWRcIl0gPSBcInRyYW5zcG9ydHNDcmVhdGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIlJlc3VtaW5nXCJdID0gXCJyZXN1bWluZ1wiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1lZFwiXSA9IFwicmVzdW1lZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGluZ1wiXSA9IFwicmVzdGFydGluZ1wiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUmVzdGFydGVkXCJdID0gXCJyZXN0YXJ0ZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlc3VtZWRcIl0gPSBcInNpZ25hbFJlc3VtZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlc3RhcnRlZFwiXSA9IFwic2lnbmFsUmVzdGFydGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJNZWRpYVRyYWNrQWRkZWRcIl0gPSBcIm1lZGlhVHJhY2tBZGRlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNVcGRhdGVcIl0gPSBcImFjdGl2ZVNwZWFrZXJzVXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJEYXRhUGFja2V0UmVjZWl2ZWRcIl0gPSBcImRhdGFQYWNrZXRSZWNlaXZlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUlRQVmlkZW9NYXBVcGRhdGVcIl0gPSBcInJ0cFZpZGVvTWFwVXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWRcIl0gPSBcImRjQnVmZmVyU3RhdHVzQ2hhbmdlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUGFydGljaXBhbnRVcGRhdGVcIl0gPSBcInBhcnRpY2lwYW50VXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSb29tVXBkYXRlXCJdID0gXCJyb29tVXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTcGVha2Vyc0NoYW5nZWRcIl0gPSBcInNwZWFrZXJzQ2hhbmdlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiU3RyZWFtU3RhdGVDaGFuZ2VkXCJdID0gXCJzdHJlYW1TdGF0ZUNoYW5nZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiU3Vic2NyaXB0aW9uRXJyb3JcIl0gPSBcInN1YnNjcmlwdGlvbkVycm9yXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSZW1vdGVNdXRlXCJdID0gXCJyZW1vdGVNdXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiXSA9IFwic3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJMb2NhbFRyYWNrU3Vic2NyaWJlZFwiXSA9IFwibG9jYWxUcmFja1N1YnNjcmliZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIk9mZmxpbmVcIl0gPSBcIm9mZmxpbmVcIjtcclxuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlcXVlc3RSZXNwb25zZVwiXSA9IFwic2lnbmFsUmVxdWVzdFJlc3BvbnNlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxDb25uZWN0ZWRcIl0gPSBcInNpZ25hbENvbm5lY3RlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUm9vbU1vdmVkXCJdID0gXCJyb29tTW92ZWRcIjtcclxufSkoRW5naW5lRXZlbnQgfHwgKEVuZ2luZUV2ZW50ID0ge30pKTtcclxudmFyIFRyYWNrRXZlbnQ7XHJcbihmdW5jdGlvbiAoVHJhY2tFdmVudCkge1xyXG4gIFRyYWNrRXZlbnRbXCJNZXNzYWdlXCJdID0gXCJtZXNzYWdlXCI7XHJcbiAgVHJhY2tFdmVudFtcIk11dGVkXCJdID0gXCJtdXRlZFwiO1xyXG4gIFRyYWNrRXZlbnRbXCJVbm11dGVkXCJdID0gXCJ1bm11dGVkXCI7XHJcbiAgLyoqXHJcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xyXG4gIFRyYWNrRXZlbnRbXCJFbmRlZFwiXSA9IFwiZW5kZWRcIjtcclxuICBUcmFja0V2ZW50W1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xyXG4gIFRyYWNrRXZlbnRbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBUcmFja0V2ZW50W1wiVXBkYXRlU2V0dGluZ3NcIl0gPSBcInVwZGF0ZVNldHRpbmdzXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTdWJzY3JpcHRpb25cIl0gPSBcInVwZGF0ZVN1YnNjcmlwdGlvblwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXJ0ZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tTdGFydGVkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrRmFpbGVkXCJdID0gXCJhdWRpb1BsYXliYWNrRmFpbGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbEF1ZGlvVHJhY2sgaW5zdGFuY2VzXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIkF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJhdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBUcmFja0V2ZW50W1wiVmlzaWJpbGl0eUNoYW5nZWRcIl0gPSBcInZpc2liaWxpdHlDaGFuZ2VkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCJdID0gXCJ2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJWaWRlb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwidmlkZW9QbGF5YmFja1N0YXJ0ZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIlZpZGVvUGxheWJhY2tGYWlsZWRcIl0gPSBcInZpZGVvUGxheWJhY2tGYWlsZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIkVsZW1lbnRBdHRhY2hlZFwiXSA9IFwiZWxlbWVudEF0dGFjaGVkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJFbGVtZW50RGV0YWNoZWRcIl0gPSBcImVsZW1lbnREZXRhY2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1QYXVzZWRcIl0gPSBcInVwc3RyZWFtUGF1c2VkXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVJlc3VtZWRcIl0gPSBcInVwc3RyZWFtUmVzdW1lZFwiO1xyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInN1YnNjcmlwdGlvbkZhaWxlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJUcmFja1Byb2Nlc3NvclVwZGF0ZVwiXSA9IFwidHJhY2tQcm9jZXNzb3JVcGRhdGVcIjtcclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGVcIl0gPSBcImF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlXCI7XHJcbiAgLyoqXHJcbiAgICogQGJldGFcclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcclxuICAvKipcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlRpbWVTeW5jVXBkYXRlXCJdID0gXCJ0aW1lU3luY1VwZGF0ZVwiO1xyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJQcmVDb25uZWN0QnVmZmVyRmx1c2hlZFwiXSA9IFwicHJlQ29ubmVjdEJ1ZmZlckZsdXNoZWRcIjtcclxufSkoVHJhY2tFdmVudCB8fCAoVHJhY2tFdmVudCA9IHt9KSk7XHJcblxyXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG5vdCBhIHByb3h5IGJ5IHNwcmVhZGluZyBpdFxyXG4gICAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHZhbHVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRpbnksIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbGFuY2VkaWtzb24vYm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9wYXJzZXItYnJvd3NlcnMuanNcclxuLy8gcmVkdWNlZCB0byBvbmx5IGRpZmZlcmVudGlhdGUgQ2hyb21lKGl1bSkgYmFzZWQgYnJvd3NlcnMgLyBGaXJlZm94IC8gU2FmYXJpXHJcbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XHJcbmxldCBicm93c2VyRGV0YWlscztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQpIHtcclxuICBsZXQgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XHJcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCAhPT0gbnVsbCAmJiB1c2VyQWdlbnQgIT09IHZvaWQgMCA/IHVzZXJBZ2VudCA6IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKGJyb3dzZXJEZXRhaWxzID09PSB1bmRlZmluZWQgfHwgZm9yY2UpIHtcclxuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZChfcmVmID0+IHtcclxuICAgICAgbGV0IHtcclxuICAgICAgICB0ZXN0XHJcbiAgICAgIH0gPSBfcmVmO1xyXG4gICAgICByZXR1cm4gdGVzdC50ZXN0KHVhKTtcclxuICAgIH0pO1xyXG4gICAgYnJvd3NlckRldGFpbHMgPSBicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIuZGVzY3JpYmUodWEpO1xyXG4gIH1cclxuICByZXR1cm4gYnJvd3NlckRldGFpbHM7XHJcbn1cclxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW3tcclxuICB0ZXN0OiAvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaSxcclxuICBkZXNjcmliZSh1YSkge1xyXG4gICAgY29uc3QgYnJvd3NlciA9IHtcclxuICAgICAgbmFtZTogJ0ZpcmVmb3gnLFxyXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXHJcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXHJcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBicm93c2VyO1xyXG4gIH1cclxufSwge1xyXG4gIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXHJcbiAgZGVzY3JpYmUodWEpIHtcclxuICAgIGNvbnN0IGJyb3dzZXIgPSB7XHJcbiAgICAgIG5hbWU6ICdDaHJvbWUnLFxyXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86Y2hyb21lfGNocm9taXVtfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXHJcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXHJcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxyXG4gICAgfTtcclxuICAgIHJldHVybiBicm93c2VyO1xyXG4gIH1cclxufSwgLyogU2FmYXJpICovXHJcbntcclxuICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXHJcbiAgZGVzY3JpYmUodWEpIHtcclxuICAgIGNvbnN0IGJyb3dzZXIgPSB7XHJcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxyXG4gICAgICB2ZXJzaW9uOiBnZXRNYXRjaChjb21tb25WZXJzaW9uSWRlbnRpZmllciwgdWEpLFxyXG4gICAgICBvczogdWEuaW5jbHVkZXMoJ21vYmlsZS8nKSA/ICdpT1MnIDogJ21hY09TJyxcclxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJyb3dzZXI7XHJcbiAgfVxyXG59XTtcclxuZnVuY3Rpb24gZ2V0TWF0Y2goZXhwLCB1YSkge1xyXG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcclxuICBjb25zdCBtYXRjaCA9IHVhLm1hdGNoKGV4cCk7XHJcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBpZCAmJiBtYXRjaFtpZF0gfHwgJyc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T1NWZXJzaW9uKHVhKSB7XHJcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKCdtYWMgb3MnKSA/IGdldE1hdGNoKC9cXCguKz8oXFxkK19cXGQrKDo/X1xcZCspPykvLCB1YSwgMSkucmVwbGFjZSgvXy9nLCAnLicpIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG52YXIgdmVyc2lvbiQxID0gXCIyLjEzLjVcIjtcclxuXHJcbmNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uJDE7XHJcbmNvbnN0IHByb3RvY29sVmVyc2lvbiA9IDE2O1xyXG5cclxuLyoqXHJcbiAqIFRpbWVycyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIHdpdGggcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zXHJcbiAqIHRoYXQgZW5zdXJlIHRoYXQgdGhleSBhcmUgZmlyZWQuIFRoZXNlIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgY3JpdGljYWxcclxuICogdGhhdCB0aGUgdGltZXIgZmlyZXMgb24gdGltZS5cclxuICovXHJcbmNsYXNzIENyaXRpY2FsVGltZXJzIHt9XHJcbkNyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHNldFRpbWVvdXQoLi4uYXJndW1lbnRzKTtcclxufTtcclxuQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwgPVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxyXG5mdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHNldEludGVydmFsKC4uLmFyZ3VtZW50cyk7XHJcbn07XHJcbkNyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gY2xlYXJUaW1lb3V0KC4uLmFyZ3VtZW50cyk7XHJcbn07XHJcbkNyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmNvbnN0IEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkgPSA1MDAwO1xyXG4vLyBrZWVwIG9sZCBhdWRpbyBlbGVtZW50cyB3aGVuIGRldGFjaGVkLCB3ZSB3b3VsZCByZS11c2UgdGhlbSBzaW5jZSBvbiBpT1NcclxuLy8gU2FmYXJpIHRyYWNrcyB3aGljaCBhdWRpbyBlbGVtZW50cyBoYXZlIGJlZW4gXCJibGVzc2VkXCIgYnkgdGhlIHVzZXIuXHJcbmNvbnN0IHJlY3ljbGVkRWxlbWVudHMgPSBbXTtcclxudmFyIFZpZGVvUXVhbGl0eTtcclxuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcclxuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XXCJdID0gMF0gPSBcIkxPV1wiO1xyXG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJNRURJVU1cIl0gPSAxXSA9IFwiTUVESVVNXCI7XHJcbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkhJR0hcIl0gPSAyXSA9IFwiSElHSFwiO1xyXG59KShWaWRlb1F1YWxpdHkgfHwgKFZpZGVvUXVhbGl0eSA9IHt9KSk7XHJcbmNsYXNzIFRyYWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQpIHtcclxuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICAgIHZhciBfYTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMuaXNNdXRlZCA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBpbmRpY2F0ZXMgY3VycmVudCBzdGF0ZSBvZiBzdHJlYW0sIGl0J2xsIGluZGljYXRlIGBwYXVzZWRgIGlmIHRoZSB0cmFja1xyXG4gICAgICogaGFzIGJlZW4gcGF1c2VkIGJ5IGNvbmdlc3Rpb24gY29udHJvbGxlclxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0cmVhbVN0YXRlID0gVHJhY2suU3RyZWFtU3RhdGUuQWN0aXZlO1xyXG4gICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xyXG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xyXG4gICAgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyID0gKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmJhY2tncm91bmRUaW1lb3V0KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cclxuICAgICAgLy8gdXBkYXRlIGltbWVkaWF0ZWx5IGlmIGl0IGNvbWVzIGJhY2sgdG8gZm9jdXNcclxuICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuVHJhY2spO1xyXG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcclxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XHJcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhVHJhY2s7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbUlEID0gbWVkaWFUcmFjay5pZDtcclxuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XHJcbiAgfVxyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XHJcbiAgfVxyXG4gIC8qKiBjdXJyZW50IHJlY2VpdmUgYml0cyBwZXIgc2Vjb25kICovXHJcbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCaXRyYXRlO1xyXG4gIH1cclxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiB1c2VkIGZvciBrZWVwIG1lZGlhU3RyZWFtJ3MgZmlyc3QgaWQsIHNpbmNlIGl0J3MgaWQgbWlnaHQgY2hhbmdlXHJcbiAgICogaWYgd2UgZGlzYWJsZS9lbmFibGUgYSB0cmFja1xyXG4gICAqL1xyXG4gIGdldCBtZWRpYVN0cmVhbUlEKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XHJcbiAgfVxyXG4gIGF0dGFjaChlbGVtZW50KSB7XHJcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xyXG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICBlbGVtZW50VHlwZSA9ICd2aWRlbyc7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcclxuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcclxuICAgIH1cclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICBpZiAoZS5wYXJlbnRFbGVtZW50ID09PSBudWxsICYmICFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBwb29sXHJcbiAgICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnNwbGljZShyZWN5Y2xlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XHJcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxyXG4gICAgLy8gdGhlIGVsZW1lbnQncyBzcmNPYmplY3Qgd2FzIHNldCB0byBzb21ldGhpbmcgZWxzZSBvdXQgb2YgYmFuZC5cclxuICAgIC8vIHdlJ2xsIHdhbnQgdG8gcmUtYXR0YWNoIGl0IGluIHRoYXQgY2FzZVxyXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XHJcbiAgICAvLyBoYW5kbGUgYXV0byBwbGF5YmFjayBmYWlsdXJlc1xyXG4gICAgY29uc3QgYWxsTWVkaWFTdHJlYW1UcmFja3MgPSBlbGVtZW50LnNyY09iamVjdC5nZXRUcmFja3MoKTtcclxuICAgIGNvbnN0IGhhc0F1ZGlvID0gYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcclxuICAgIC8vIG1hbnVhbGx5IHBsYXkgbWVkaWEgdG8gZGV0ZWN0IGF1dG8gcGxheWJhY2sgc3RhdHVzXHJcbiAgICBlbGVtZW50LnBsYXkoKS50aGVuKCgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCA6IFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xyXG4gICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcclxuICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xyXG4gICAgICAgIC8vIGNvbW1vbmx5IHRyaWdnZXJlZCBieSBhbm90aGVyIGBwbGF5YCByZXF1ZXN0LCBvbmx5IGxvZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIlwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nLCBcIiBwbGF5YmFjayBhYm9ydGVkLCBsaWtlbHkgZHVlIHRvIG5ldyBwbGF5IHJlcXVlc3RcIikpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImNvdWxkIG5vdCBwbGF5YmFjayBcIi5jb25jYXQoaGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJyksIGUpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIGF1ZGlvIHBsYXliYWNrIGlzbid0IGFsbG93ZWQgbWFrZSBzdXJlIHdlIHN0aWxsIHBsYXkgYmFjayB0aGUgdmlkZW9cclxuICAgICAgaWYgKGhhc0F1ZGlvICYmIGVsZW1lbnQgJiYgYWxsTWVkaWFTdHJlYW1UcmFja3Muc29tZSh0ciA9PiB0ci5raW5kID09PSAndmlkZW8nKSAmJiBlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XHJcbiAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XHJcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgLy8gY2F0Y2ggZm9yIFNhZmFyaSwgZXhjZWVkZWQgb3B0aW9ucyBhdCB0aGlzIHBvaW50IHRvIGF1dG9tYXRpY2FsbHkgcGxheSB0aGUgbWVkaWEgZWxlbWVudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbiAgZGV0YWNoKGVsZW1lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcclxuICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgIGlmIChpZHggPj0gMCkge1xyXG4gICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRldGFjaGVkID0gW107XHJcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsbSA9PiB7XHJcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbG0pO1xyXG4gICAgICAgIGRldGFjaGVkLnB1c2goZWxtKTtcclxuICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsbSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbG0pO1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCB0cmFja3NcclxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XHJcbiAgICAgIHJldHVybiBkZXRhY2hlZDtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xyXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XHJcbiAgfVxyXG4gIGVuYWJsZSgpIHtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XHJcbiAgfVxyXG4gIGRpc2FibGUoKSB7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgc3RvcE1vbml0b3IoKSB7XHJcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcclxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vbml0b3JJbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy50aW1lU3luY0hhbmRsZSkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnRpbWVTeW5jSGFuZGxlKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHVwZGF0ZUxvZ2dlck9wdGlvbnMobG9nZ2VyT3B0aW9ucykge1xyXG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkge1xyXG4gICAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJlY3ljbGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xyXG4gICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gcmUtdXNlIGEgc2luZ2xlIGVsZW1lbnRcclxuICAgICAgbGV0IHNob3VsZENhY2hlID0gdHJ1ZTtcclxuICAgICAgZWxlbWVudC5wYXVzZSgpO1xyXG4gICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgaWYgKCFlLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgIHNob3VsZENhY2hlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XHJcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XHJcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnBsYXkoKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAvKiogY2F0Y2ggY2xhdXNlIG5lY2Vzc2FyeSBmb3IgU2FmYXJpICovXHJcbiAgICAgICAgfSkpLCAwKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcclxuICAgIGlmIChpc1dlYigpKSB7XHJcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xyXG4gICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGF0dGFjaFRvRWxlbWVudCh0cmFjaywgZWxlbWVudCkge1xyXG4gIGxldCBtZWRpYVN0cmVhbTtcclxuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xyXG4gICAgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcclxuICB9IGVsc2Uge1xyXG4gICAgbWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICB9XHJcbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xyXG4gIGxldCBleGlzdGluZ1RyYWNrcztcclxuICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XHJcbiAgfVxyXG4gIGlmICghZXhpc3RpbmdUcmFja3MuaW5jbHVkZXModHJhY2spKSB7XHJcbiAgICBleGlzdGluZ1RyYWNrcy5mb3JFYWNoKGV0ID0+IHtcclxuICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2soZXQpO1xyXG4gICAgfSk7XHJcbiAgICBtZWRpYVN0cmVhbS5hZGRUcmFjayh0cmFjayk7XHJcbiAgfVxyXG4gIGlmICghaXNTYWZhcmkoKSB8fCAhKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xyXG4gICAgLy8gd2hlbiBpbiBsb3cgcG93ZXIgbW9kZSAoYXBwbGllcyB0byBib3RoIG1hY09TIGFuZCBpT1MpLCBTYWZhcmkgd2lsbCBzaG93IGEgcGxheS9wYXVzZSBvdmVybGF5XHJcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXHJcbiAgICAvLyB3ZSB3b3JrIGFyb3VuZCB0aGlzIGJ5IF9ub3RfIHNldHRpbmcgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZSBvbiBzYWZhcmkgYW5kIGluc3RlYWQgY2FsbCBgc2V0VGltZW91dCgoKSA9PiBlbC5wbGF5KCksMClgIGZ1cnRoZXIgZG93blxyXG4gICAgZWxlbWVudC5hdXRvcGxheSA9IHRydWU7XHJcbiAgfVxyXG4gIC8vIEluIGNhc2UgdGhlcmUgYXJlIG5vIGF1ZGlvIHRyYWNrcyBwcmVzZW50IG9uIHRoZSBtZWRpYXN0cmVhbSwgd2Ugc2V0IHRoZSBlbGVtZW50IGFzIG11dGVkIHRvIGVuc3VyZSBhdXRvcGxheSB3b3Jrc1xyXG4gIGVsZW1lbnQubXV0ZWQgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA9PT0gMDtcclxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQucGxheXNJbmxpbmUgPSB0cnVlO1xyXG4gIH1cclxuICAvLyBhdm9pZCBmbGlja2VyXHJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0ICE9PSBtZWRpYVN0cmVhbSkge1xyXG4gICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcclxuICAgIGlmICgoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcclxuICAgICAgLy8gRmlyZWZveCBhbHNvIGhhcyBhIHRpbWluZyBpc3N1ZSB3aGVyZSB2aWRlbyBkb2Vzbid0IGFjdHVhbGx5IGdldCBhdHRhY2hlZCB1bmxlc3NcclxuICAgICAgLy8gcGVyZm9ybWVkIG91dC1vZi1iYW5kXHJcbiAgICAgIC8vIFNhZmFyaSAxNSBoYXMgYSBidWcgd2hlcmUgaW4gY2VydGFpbiBsYXlvdXRzLCB2aWRlbyBlbGVtZW50IHJlbmRlcnNcclxuICAgICAgLy8gYmxhY2sgdW50aWwgdGhlIHBhZ2UgaXMgcmVzaXplZCBvciBvdGhlciBjaGFuZ2VzIHRha2UgcGxhY2UuXHJcbiAgICAgIC8vIFJlc2V0dGluZyB0aGUgc3JjIHRyaWdnZXJzIGl0IHRvIHJlbmRlci5cclxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjkwNTIzXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XHJcbiAgICAgICAgLy8gU2FmYXJpIDE1IHNvbWV0aW1lcyBmYWlscyB0byBzdGFydCBhIHZpZGVvXHJcbiAgICAgICAgLy8gd2hlbiB0aGUgd2luZG93IGlzIGJhY2tncm91bmRlZCBiZWZvcmUgdGhlIGZpcnN0IGZyYW1lIGlzIGRyYXduXHJcbiAgICAgICAgLy8gbWFudWFsbHkgY2FsbGluZyBwbGF5IGhlcmUgc2VlbXMgdG8gZml4IHRoYXRcclxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAvKiogZG8gbm90aGluZyAqL1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBkZXRhY2hUcmFjayh0cmFjaywgZWxlbWVudCkge1xyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XHJcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xyXG4gICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xyXG4gICAgaWYgKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuKGZ1bmN0aW9uIChUcmFjaykge1xyXG4gIGxldCBLaW5kO1xyXG4gIChmdW5jdGlvbiAoS2luZCkge1xyXG4gICAgS2luZFtcIkF1ZGlvXCJdID0gXCJhdWRpb1wiO1xyXG4gICAgS2luZFtcIlZpZGVvXCJdID0gXCJ2aWRlb1wiO1xyXG4gICAgS2luZFtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcclxuICB9KShLaW5kID0gVHJhY2suS2luZCB8fCAoVHJhY2suS2luZCA9IHt9KSk7XHJcbiAgbGV0IFNvdXJjZTtcclxuICAoZnVuY3Rpb24gKFNvdXJjZSkge1xyXG4gICAgU291cmNlW1wiQ2FtZXJhXCJdID0gXCJjYW1lcmFcIjtcclxuICAgIFNvdXJjZVtcIk1pY3JvcGhvbmVcIl0gPSBcIm1pY3JvcGhvbmVcIjtcclxuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlXCJdID0gXCJzY3JlZW5fc2hhcmVcIjtcclxuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlQXVkaW9cIl0gPSBcInNjcmVlbl9zaGFyZV9hdWRpb1wiO1xyXG4gICAgU291cmNlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xyXG4gIH0pKFNvdXJjZSA9IFRyYWNrLlNvdXJjZSB8fCAoVHJhY2suU291cmNlID0ge30pKTtcclxuICBsZXQgU3RyZWFtU3RhdGUkMTtcclxuICAoZnVuY3Rpb24gKFN0cmVhbVN0YXRlKSB7XHJcbiAgICBTdHJlYW1TdGF0ZVtcIkFjdGl2ZVwiXSA9IFwiYWN0aXZlXCI7XHJcbiAgICBTdHJlYW1TdGF0ZVtcIlBhdXNlZFwiXSA9IFwicGF1c2VkXCI7XHJcbiAgICBTdHJlYW1TdGF0ZVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcclxuICB9KShTdHJlYW1TdGF0ZSQxID0gVHJhY2suU3RyZWFtU3RhdGUgfHwgKFRyYWNrLlN0cmVhbVN0YXRlID0ge30pKTtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgZnVuY3Rpb24ga2luZFRvUHJvdG8oaykge1xyXG4gICAgc3dpdGNoIChrKSB7XHJcbiAgICAgIGNhc2UgS2luZC5BdWRpbzpcclxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xyXG4gICAgICBjYXNlIEtpbmQuVmlkZW86XHJcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5WSURFTztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBGSVhNRSB0aGlzIHdhcyBVTlJFQ09HTklaRUQgYmVmb3JlXHJcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5EQVRBO1xyXG4gICAgfVxyXG4gIH1cclxuICBUcmFjay5raW5kVG9Qcm90byA9IGtpbmRUb1Byb3RvO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQpIHtcclxuICAgIHN3aXRjaCAodCkge1xyXG4gICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcclxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcclxuICAgICAgY2FzZSBUcmFja1R5cGUuVklERU86XHJcbiAgICAgICAgcmV0dXJuIEtpbmQuVmlkZW87XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIEtpbmQuVW5rbm93bjtcclxuICAgIH1cclxuICB9XHJcbiAgVHJhY2sua2luZEZyb21Qcm90byA9IGtpbmRGcm9tUHJvdG87XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGZ1bmN0aW9uIHNvdXJjZVRvUHJvdG8ocykge1xyXG4gICAgc3dpdGNoIChzKSB7XHJcbiAgICAgIGNhc2UgU291cmNlLkNhbWVyYTpcclxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuQ0FNRVJBO1xyXG4gICAgICBjYXNlIFNvdXJjZS5NaWNyb3Bob25lOlxyXG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5NSUNST1BIT05FO1xyXG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZTpcclxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFO1xyXG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvOlxyXG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU87XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlVOS05PV047XHJcbiAgICB9XHJcbiAgfVxyXG4gIFRyYWNrLnNvdXJjZVRvUHJvdG8gPSBzb3VyY2VUb1Byb3RvO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBmdW5jdGlvbiBzb3VyY2VGcm9tUHJvdG8ocykge1xyXG4gICAgc3dpdGNoIChzKSB7XHJcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxyXG4gICAgICAgIHJldHVybiBTb3VyY2UuQ2FtZXJhO1xyXG4gICAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XHJcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5NaWNyb3Bob25lO1xyXG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTpcclxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlO1xyXG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcclxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlQXVkaW87XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5Vbmtub3duO1xyXG4gICAgfVxyXG4gIH1cclxuICBUcmFjay5zb3VyY2VGcm9tUHJvdG8gPSBzb3VyY2VGcm9tUHJvdG87XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGZ1bmN0aW9uIHN0cmVhbVN0YXRlRnJvbVByb3RvKHMpIHtcclxuICAgIHN3aXRjaCAocykge1xyXG4gICAgICBjYXNlIFN0cmVhbVN0YXRlLkFDVElWRTpcclxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5BY3RpdmU7XHJcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuUEFVU0VEOlxyXG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlBhdXNlZDtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5Vbmtub3duO1xyXG4gICAgfVxyXG4gIH1cclxuICBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byA9IHN0cmVhbVN0YXRlRnJvbVByb3RvO1xyXG59KShUcmFjayB8fCAoVHJhY2sgPSB7fSkpO1xyXG5cclxuY2xhc3MgVmlkZW9QcmVzZXQge1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoT3JPcHRpb25zLCBoZWlnaHQsIG1heEJpdHJhdGUsIG1heEZyYW1lcmF0ZSwgcHJpb3JpdHkpIHtcclxuICAgIGlmICh0eXBlb2Ygd2lkdGhPck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aE9yT3B0aW9ucy53aWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSB3aWR0aE9yT3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB3aWR0aE9yT3B0aW9ucy5hc3BlY3RSYXRpbztcclxuICAgICAgdGhpcy5lbmNvZGluZyA9IHtcclxuICAgICAgICBtYXhCaXRyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhCaXRyYXRlLFxyXG4gICAgICAgIG1heEZyYW1lcmF0ZTogd2lkdGhPck9wdGlvbnMubWF4RnJhbWVyYXRlLFxyXG4gICAgICAgIHByaW9yaXR5OiB3aWR0aE9yT3B0aW9ucy5wcmlvcml0eVxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBtYXhCaXRyYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHdpZHRoT3JPcHRpb25zIC8gaGVpZ2h0O1xyXG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xyXG4gICAgICAgIG1heEJpdHJhdGUsXHJcbiAgICAgICAgbWF4RnJhbWVyYXRlLFxyXG4gICAgICAgIHByaW9yaXR5XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBvcHRpb25zOiBwcm92aWRlIGF0IGxlYXN0IHdpZHRoLCBoZWlnaHQgYW5kIG1heEJpdHJhdGUnKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IHJlc29sdXRpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgZnJhbWVSYXRlOiB0aGlzLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcclxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuYXNwZWN0UmF0aW9cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmNvbnN0IGJhY2t1cENvZGVjcyA9IFsndnA4JywgJ2gyNjQnXTtcclxuY29uc3QgdmlkZW9Db2RlY3MgPSBbJ3ZwOCcsICdoMjY0JywgJ3ZwOScsICdhdjEnXTtcclxuZnVuY3Rpb24gaXNCYWNrdXBDb2RlYyhjb2RlYykge1xyXG4gIHJldHVybiAhIWJhY2t1cENvZGVjcy5maW5kKGJhY2t1cCA9PiBiYWNrdXAgPT09IGNvZGVjKTtcclxufVxyXG52YXIgQmFja3VwQ29kZWNQb2xpY3k7XHJcbihmdW5jdGlvbiAoQmFja3VwQ29kZWNQb2xpY3kpIHtcclxuICAvLyBjb2RlYyByZWdyZXNzaW9uIGlzIHByZWZlcnJlZCwgdGhlIHNmdSB3aWxsIHRyeSB0byByZWdyZXNzIGNvZGVjIGlmIHBvc3NpYmxlIGJ1dCBub3QgZ3VhcmFudGVlZFxyXG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiUFJFRkVSX1JFR1JFU1NJT05cIl0gPSAwXSA9IFwiUFJFRkVSX1JFR1JFU1NJT05cIjtcclxuICAvLyBtdWx0aS1jb2RlYyBzaW11bGNhc3QsIHB1Ymxpc2ggYm90aCBwcmltYXJ5IGFuZCBiYWNrdXAgY29kZWMgYXQgdGhlIHNhbWUgdGltZVxyXG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiU0lNVUxDQVNUXCJdID0gMV0gPSBcIlNJTVVMQ0FTVFwiO1xyXG4gIC8vIGFsd2F5cyB1c2UgYmFja3VwIGNvZGVjIG9ubHlcclxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlJFR1JFU1NJT05cIl0gPSAyXSA9IFwiUkVHUkVTU0lPTlwiO1xyXG59KShCYWNrdXBDb2RlY1BvbGljeSB8fCAoQmFja3VwQ29kZWNQb2xpY3kgPSB7fSkpO1xyXG52YXIgQXVkaW9QcmVzZXRzO1xyXG4oZnVuY3Rpb24gKEF1ZGlvUHJlc2V0cykge1xyXG4gIEF1ZGlvUHJlc2V0cy50ZWxlcGhvbmUgPSB7XHJcbiAgICBtYXhCaXRyYXRlOiAxMjAwMFxyXG4gIH07XHJcbiAgQXVkaW9QcmVzZXRzLnNwZWVjaCA9IHtcclxuICAgIG1heEJpdHJhdGU6IDI0MDAwXHJcbiAgfTtcclxuICBBdWRpb1ByZXNldHMubXVzaWMgPSB7XHJcbiAgICBtYXhCaXRyYXRlOiA0ODAwMFxyXG4gIH07XHJcbiAgQXVkaW9QcmVzZXRzLm11c2ljU3RlcmVvID0ge1xyXG4gICAgbWF4Qml0cmF0ZTogNjQwMDBcclxuICB9O1xyXG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5ID0ge1xyXG4gICAgbWF4Qml0cmF0ZTogOTYwMDBcclxuICB9O1xyXG4gIEF1ZGlvUHJlc2V0cy5tdXNpY0hpZ2hRdWFsaXR5U3RlcmVvID0ge1xyXG4gICAgbWF4Qml0cmF0ZTogMTI4MDAwXHJcbiAgfTtcclxufSkoQXVkaW9QcmVzZXRzIHx8IChBdWRpb1ByZXNldHMgPSB7fSkpO1xyXG4vKipcclxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXHJcbiAqL1xyXG5jb25zdCBWaWRlb1ByZXNldHMgPSB7XHJcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTAwMDAsIDIwKSxcclxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAxODAsIDE2MDAwMCwgMjApLFxyXG4gIGgyMTY6IG5ldyBWaWRlb1ByZXNldCgzODQsIDIxNiwgMTgwMDAwLCAyMCksXHJcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTAwMDAsIDIwKSxcclxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA1NDAsIDgwMDAwMCwgMjUpLFxyXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDE3MDAwMDAsIDMwKSxcclxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcclxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDI1NjAsIDE0NDAsIDUwMDAwMDAsIDMwKSxcclxuICBoMjE2MDogbmV3IFZpZGVvUHJlc2V0KDM4NDAsIDIxNjAsIDgwMDAwMDAsIDMwKVxyXG59O1xyXG4vKipcclxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXHJcbiAqL1xyXG5jb25zdCBWaWRlb1ByZXNldHM0MyA9IHtcclxuICBoMTIwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCAxMjAsIDcwMDAwLCAyMCksXHJcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjUwMDAsIDIwKSxcclxuICBoMjQwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAyNDAsIDE0MDAwMCwgMjApLFxyXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg0ODAsIDM2MCwgMzMwMDAwLCAyMCksXHJcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDAwMDAsIDIwKSxcclxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoNzIwLCA1NDAsIDYwMDAwMCwgMjUpLFxyXG4gIGg3MjA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDcyMCwgMTMwMDAwMCwgMzApLFxyXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTQ0MCwgMTA4MCwgMjMwMDAwMCwgMzApLFxyXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTQ0MCwgMzgwMDAwMCwgMzApXHJcbn07XHJcbmNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcclxuICBoMzYwZnBzMzogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCAyMDAwMDAsIDMsICdtZWRpdW0nKSxcclxuICBoMzYwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDAwMDAwLCAxNSwgJ21lZGl1bScpLFxyXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDAwMDAsIDUsICdtZWRpdW0nKSxcclxuICBoNzIwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDE1MDAwMDAsIDE1LCAnbWVkaXVtJyksXHJcbiAgaDcyMGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAyMDAwMDAwLCAzMCwgJ21lZGl1bScpLFxyXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxyXG4gIGgxMDgwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCA1MDAwMDAwLCAzMCwgJ21lZGl1bScpLFxyXG4gIC8vIG9yaWdpbmFsIHJlc29sdXRpb24sIHdpdGhvdXQgcmVzaXppbmdcclxuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDcwMDAwMDAsIDMwLCAnbWVkaXVtJylcclxufTtcclxuXHJcbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcclxuY29uc3QgZGRFeHRlbnNpb25VUkkgPSAnaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1ydHAtc3BlYy8jZGVwZW5kZW5jeS1kZXNjcmlwdG9yLXJ0cC1oZWFkZXItZXh0ZW5zaW9uJztcclxuZnVuY3Rpb24gdW5wYWNrU3RyZWFtSWQocGFja2VkKSB7XHJcbiAgY29uc3QgcGFydHMgPSBwYWNrZWQuc3BsaXQoc2VwYXJhdG9yKTtcclxuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgcmV0dXJuIFtwYXJ0c1swXSwgcGFja2VkLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggKyAxKV07XHJcbiAgfVxyXG4gIHJldHVybiBbcGFja2VkLCAnJ107XHJcbn1cclxuZnVuY3Rpb24gc2xlZXAoZHVyYXRpb24pIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xyXG4gIH0pO1xyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcclxuICByZXR1cm4gJ2FkZFRyYW5zY2VpdmVyJyBpbiBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBzdXBwb3J0c0FkZFRyYWNrKCkge1xyXG4gIHJldHVybiAnYWRkVHJhY2snIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxufVxyXG5mdW5jdGlvbiBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtKCkge1xyXG4gIHJldHVybiB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBzdXBwb3J0c0R5bmFjYXN0KCkge1xyXG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCk7XHJcbn1cclxuZnVuY3Rpb24gc3VwcG9ydHNBVjEoKSB7XHJcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoaXNTYWZhcmkoKSkge1xyXG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XHJcbiAgbGV0IGhhc0FWMSA9IGZhbHNlO1xyXG4gIGlmIChjYXBhYmlsaXRpZXMpIHtcclxuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xyXG4gICAgICBpZiAoY29kZWMubWltZVR5cGUgPT09ICd2aWRlby9BVjEnKSB7XHJcbiAgICAgICAgaGFzQVYxID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaGFzQVYxO1xyXG59XHJcbmZ1bmN0aW9uIHN1cHBvcnRzVlA5KCkge1xyXG4gIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGlzRmlyZUZveCgpKSB7XHJcbiAgICAvLyB0ZWNobmljYWxseSBzcGVha2luZyBGaXJlRm94IHN1cHBvcnRzIFZQOSwgYnV0IFNWQyBwdWJsaXNoaW5nIGlzIGJyb2tlblxyXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoaXNTYWZhcmkoKSkge1xyXG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgIGlmICgoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxNicpIDwgMCkge1xyXG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcclxuICBsZXQgaGFzVlA5ID0gZmFsc2U7XHJcbiAgaWYgKGNhcGFiaWxpdGllcykge1xyXG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XHJcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL1ZQOScpIHtcclxuICAgICAgICBoYXNWUDkgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBoYXNWUDk7XHJcbn1cclxuZnVuY3Rpb24gaXNTVkNDb2RlYyhjb2RlYykge1xyXG4gIHJldHVybiBjb2RlYyA9PT0gJ2F2MScgfHwgY29kZWMgPT09ICd2cDknO1xyXG59XHJcbmZ1bmN0aW9uIHN1cHBvcnRzU2V0U2lua0lkKGVsbSkge1xyXG4gIGlmICghZG9jdW1lbnQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKCFlbG0pIHtcclxuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XHJcbiAgfVxyXG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbG07XHJcbn1cclxuZnVuY3Rpb24gaXNCcm93c2VyU3VwcG9ydGVkKCkge1xyXG4gIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkgfHwgc3VwcG9ydHNBZGRUcmFjaygpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRmlyZUZveCgpIHtcclxuICB2YXIgX2E7XHJcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0ZpcmVmb3gnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xyXG4gIHZhciBfYTtcclxuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnU2FmYXJpJztcclxufVxyXG5mdW5jdGlvbiBpc1NhZmFyaUJhc2VkKCkge1xyXG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XHJcbiAgcmV0dXJuIChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIubmFtZSkgPT09ICdTYWZhcmknIHx8IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIub3MpID09PSAnaU9TJztcclxufVxyXG5mdW5jdGlvbiBpc1NhZmFyaTE3KCkge1xyXG4gIGNvbnN0IGIgPSBnZXRCcm93c2VyKCk7XHJcbiAgcmV0dXJuIChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIubmFtZSkgPT09ICdTYWZhcmknICYmIGIudmVyc2lvbi5zdGFydHNXaXRoKCcxNy4nKTtcclxufVxyXG5mdW5jdGlvbiBpc1NhZmFyaVN2Y0FwaShicm93c2VyKSB7XHJcbiAgaWYgKCFicm93c2VyKSB7XHJcbiAgICBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xyXG4gIH1cclxuICAvLyBTYWZhcmkgMTguNCByZXF1aXJlcyBsZWdhY3kgc3ZjIGFwaSBhbmQgc2NhbGVSZXNvbHV0aW9uRG93biB0byBiZSBzZXRcclxuICByZXR1cm4gKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE4LjMnKSA+IDA7XHJcbn1cclxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XHJcbiAgdmFyIF9hLCBfYjtcclxuICBpZiAoIWlzV2ViKCkpIHJldHVybiBmYWxzZTtcclxuICByZXR1cm4gKFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgdXNlckFnZW50RGF0YWAgaXMgbm90IHlldCBwYXJ0IG9mIHR5cGVzY3JpcHRcclxuICAgIChfYiA9IChfYSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9iaWxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAvVGFibGV0fGlQYWR8TW9iaWxlfEFuZHJvaWR8QmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gaXNFMkVFU2ltdWxjYXN0U3VwcG9ydGVkKCkge1xyXG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgY29uc3Qgc3VwcG9ydGVkU2FmYXJpVmVyc2lvbiA9ICcxNy4yJzsgLy8gc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNTc4MDNcclxuICBpZiAoYnJvd3Nlcikge1xyXG4gICAgaWYgKGJyb3dzZXIubmFtZSAhPT0gJ1NhZmFyaScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXIub3MgPT09ICdpT1MnICYmIGJyb3dzZXIub3NWZXJzaW9uICYmIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLm9zVmVyc2lvbikgPj0gMCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoYnJvd3Nlci5uYW1lID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoc3VwcG9ydGVkU2FmYXJpVmVyc2lvbiwgYnJvd3Nlci52ZXJzaW9uKSA+PSAwKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc1dlYigpIHtcclxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xyXG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXHJcbiAgcmV0dXJuIG5hdmlnYXRvci5wcm9kdWN0ID09ICdSZWFjdE5hdGl2ZSc7XHJcbn1cclxuZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmwpIHtcclxuICByZXR1cm4gc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5jbG91ZCcpIHx8IHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQucnVuJyk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKSB7XHJcbiAgLy8gZ2xvYmFsIGRlZmluZWQgb25seSBmb3IgUmVhY3ROYXRpdmUuXHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIGdsb2JhbC5MaXZlS2l0UmVhY3ROYXRpdmVHbG9iYWw7XHJcbiAgfVxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpIHtcclxuICBpZiAoIWlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgbGV0IGluZm8gPSBnZXRMS1JlYWN0TmF0aXZlSW5mbygpO1xyXG4gIGlmIChpbmZvKSB7XHJcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcclxuICB9XHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xyXG4gIGlmIChpc1dlYigpKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgfVxyXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcclxuICAgIGlmIChpbmZvKSB7XHJcbiAgICAgIHJldHVybiBpbmZvLmRldmljZVBpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAxO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcclxuICBjb25zdCBwYXJ0czEgPSB2MS5zcGxpdCgnLicpO1xyXG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgayA9IE1hdGgubWluKHBhcnRzMS5sZW5ndGgsIHBhcnRzMi5sZW5ndGgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgKytpKSB7XHJcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xyXG4gICAgY29uc3QgcDIgPSBwYXJzZUludChwYXJ0czJbaV0sIDEwKTtcclxuICAgIGlmIChwMSA+IHAyKSByZXR1cm4gMTtcclxuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XHJcbiAgICBpZiAoaSA9PT0gayAtIDEgJiYgcDEgPT09IHAyKSByZXR1cm4gMDtcclxuICB9XHJcbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcclxuICAgIHJldHVybiAtMTtcclxuICB9IGVsc2UgaWYgKHYyID09PSAnJykge1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG4gIHJldHVybiBwYXJ0czEubGVuZ3RoID09IHBhcnRzMi5sZW5ndGggPyAwIDogcGFydHMxLmxlbmd0aCA8IHBhcnRzMi5sZW5ndGggPyAtMSA6IDE7XHJcbn1cclxuZnVuY3Rpb24gcm9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXMpIHtcclxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVSZXNpemUoZW50cnkpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xyXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgZW50cnkudGFyZ2V0LmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKGVudHJ5KTtcclxuICB9XHJcbn1cclxubGV0IHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcclxuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XHJcbiAgaWYgKCFyZXNpemVPYnNlcnZlcikgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocm9EaXNwYXRjaENhbGxiYWNrKTtcclxuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XHJcbn07XHJcbmxldCBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG51bGw7XHJcbmNvbnN0IGdldEludGVyc2VjdGlvbk9ic2VydmVyID0gKCkgPT4ge1xyXG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcclxuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGlvRGlzcGF0Y2hDYWxsYmFjaywge1xyXG4gICAgICByb290OiBudWxsLFxyXG4gICAgICByb290TWFyZ2luOiAnMHB4J1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcclxufTtcclxuZnVuY3Rpb24gZ2V0Q2xpZW50SW5mbygpIHtcclxuICB2YXIgX2E7XHJcbiAgY29uc3QgaW5mbyA9IG5ldyBDbGllbnRJbmZvKHtcclxuICAgIHNkazogQ2xpZW50SW5mb19TREsuSlMsXHJcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxyXG4gICAgdmVyc2lvblxyXG4gIH0pO1xyXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgIGluZm8ub3MgPSAoX2EgPSBnZXRSZWFjdE5hdGl2ZU9zKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xyXG4gIH1cclxuICByZXR1cm4gaW5mbztcclxufVxyXG5sZXQgZW1wdHlWaWRlb1N0cmVhbVRyYWNrO1xyXG5mdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XHJcbiAgaWYgKCFlbXB0eVZpZGVvU3RyZWFtVHJhY2spIHtcclxuICAgIGVtcHR5VmlkZW9TdHJlYW1UcmFjayA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpO1xyXG4gIH1cclxuICByZXR1cm4gZW1wdHlWaWRlb1N0cmVhbVRyYWNrLmNsb25lKCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCkge1xyXG4gIGxldCB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTY7XHJcbiAgbGV0IGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XHJcbiAgbGV0IGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xyXG4gIGxldCBwYWludENvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xyXG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXHJcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICBpZiAocGFpbnRDb250ZW50ICYmIGN0eCkge1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDUwLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xyXG4gICAgY3R4LmZpbGwoKTtcclxuICB9XHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIGNvbnN0IGR1bW15U3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oKTtcclxuICBjb25zdCBbZHVtbXlUcmFja10gPSBkdW1teVN0cmVhbS5nZXRUcmFja3MoKTtcclxuICBpZiAoIWR1bW15VHJhY2spIHtcclxuICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSB2aWRlbyB0cmFjaycpO1xyXG4gIH1cclxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xyXG4gIHJldHVybiBkdW1teVRyYWNrO1xyXG59XHJcbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s7XHJcbmZ1bmN0aW9uIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpIHtcclxuICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xyXG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cclxuICAgIGNvbnN0IGN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICAgIGNvbnN0IG9zY2lsbGF0b3IgPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xyXG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XHJcbiAgICBnYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgMCk7XHJcbiAgICBjb25zdCBkc3QgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpO1xyXG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xyXG4gICAgZ2Fpbi5jb25uZWN0KGRzdCk7XHJcbiAgICBvc2NpbGxhdG9yLnN0YXJ0KCk7XHJcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcclxuICAgIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSBhdWRpbyB0cmFjaycpO1xyXG4gICAgfVxyXG4gICAgZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xyXG59XHJcbmNsYXNzIEZ1dHVyZSB7XHJcbiAgY29uc3RydWN0b3IoZnV0dXJlQmFzZSwgb25GaW5hbGx5KSB7XHJcbiAgICB0aGlzLm9uRmluYWxseSA9IG9uRmluYWxseTtcclxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgIGlmIChmdXR1cmVCYXNlKSB7XHJcbiAgICAgICAgeWllbGQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICB9XHJcbiAgICB9KSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgcmV0dXJuIChfYSA9IHRoaXMub25GaW5hbGx5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhbmFseXNlciB3ZWIgYXVkaW8gbm9kZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB0cmFjay5cclxuICogQWRkaXRpb25hbGx5IHJldHVybnMgYSBjb252ZW5pZW5jZSBtZXRob2QgYGNhbGN1bGF0ZVZvbHVtZWAgdG8gcGVyZm9ybSBpbnN0YW50IHZvbHVtZSByZWFkaW5ncyBvbiB0aGF0IHRyYWNrLlxyXG4gKiBDYWxsIHRoZSByZXR1cm5lZCBgY2xlYW51cGAgZnVuY3Rpb24gdG8gY2xvc2UgdGhlIGF1ZGlvQ29udGV4dCB0aGF0IGhhcyBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBpbnN0YW5jZSBvZiB0aGlzIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXVkaW9BbmFseXNlcih0cmFjaywgb3B0aW9ucykge1xyXG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcclxuICAgIGNsb25lVHJhY2s6IGZhbHNlLFxyXG4gICAgZmZ0U2l6ZTogMjA0OCxcclxuICAgIHNtb290aGluZ1RpbWVDb25zdGFudDogMC44LFxyXG4gICAgbWluRGVjaWJlbHM6IC0xMDAsXHJcbiAgICBtYXhEZWNpYmVsczogLTgwXHJcbiAgfSwgb3B0aW9ucyk7XHJcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XHJcbiAgaWYgKCFhdWRpb0NvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQXVkaW8gQ29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xyXG4gIH1cclxuICBjb25zdCBzdHJlYW1UcmFjayA9IG9wdHMuY2xvbmVUcmFjayA/IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSA6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XHJcbiAgY29uc3QgbWVkaWFTdHJlYW1Tb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFtzdHJlYW1UcmFja10pKTtcclxuICBjb25zdCBhbmFseXNlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xyXG4gIGFuYWx5c2VyLm1pbkRlY2liZWxzID0gb3B0cy5taW5EZWNpYmVscztcclxuICBhbmFseXNlci5tYXhEZWNpYmVscyA9IG9wdHMubWF4RGVjaWJlbHM7XHJcbiAgYW5hbHlzZXIuZmZ0U2l6ZSA9IG9wdHMuZmZ0U2l6ZTtcclxuICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvcHRzLnNtb290aGluZ1RpbWVDb25zdGFudDtcclxuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcclxuICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIHRyYWNrIGluIHRoZSByYW5nZSBmcm9tIDAgdG8gMVxyXG4gICAqL1xyXG4gIGNvbnN0IGNhbGN1bGF0ZVZvbHVtZSA9ICgpID0+IHtcclxuICAgIGFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGRhdGFBcnJheSk7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAoY29uc3QgYW1wbGl0dWRlIG9mIGRhdGFBcnJheSkge1xyXG4gICAgICBzdW0gKz0gTWF0aC5wb3coYW1wbGl0dWRlIC8gMjU1LCAyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZvbHVtZSA9IE1hdGguc3FydChzdW0gLyBkYXRhQXJyYXkubGVuZ3RoKTtcclxuICAgIHJldHVybiB2b2x1bWU7XHJcbiAgfTtcclxuICBjb25zdCBjbGVhbnVwID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgeWllbGQgYXVkaW9Db250ZXh0LmNsb3NlKCk7XHJcbiAgICBpZiAob3B0cy5jbG9uZVRyYWNrKSB7XHJcbiAgICAgIHN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4ge1xyXG4gICAgY2FsY3VsYXRlVm9sdW1lLFxyXG4gICAgYW5hbHlzZXIsXHJcbiAgICBjbGVhbnVwXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1ZpZGVvQ29kZWMobWF5YmVDb2RlYykge1xyXG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjKTtcclxufVxyXG5mdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcclxuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb25zdHJhaW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIGNvbnN0cmFpbnQ7XHJcbiAgfVxyXG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XHJcbiAgICByZXR1cm4gY29uc3RyYWludFswXTtcclxuICB9XHJcbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuZXhhY3QpKSB7XHJcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0WzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3Q7XHJcbiAgfVxyXG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmlkZWFsKSkge1xyXG4gICAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbFswXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsO1xyXG4gIH1cclxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XHJcbn1cclxuZnVuY3Rpb24gdG9XZWJzb2NrZXRVcmwodXJsKSB7XHJcbiAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcclxuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXihodHRwKS8sICd3cycpO1xyXG4gIH1cclxuICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIHRvSHR0cFVybCh1cmwpIHtcclxuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3dzJykpIHtcclxuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xyXG4gIH1cclxuICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2NyaXB0aW9uU2VnbWVudHModHJhbnNjcmlwdGlvbiwgZmlyc3RSZWNlaXZlZFRpbWVzTWFwKSB7XHJcbiAgcmV0dXJuIHRyYW5zY3JpcHRpb24uc2VnbWVudHMubWFwKF9yZWYgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgaWQsXHJcbiAgICAgIHRleHQsXHJcbiAgICAgIGxhbmd1YWdlLFxyXG4gICAgICBzdGFydFRpbWUsXHJcbiAgICAgIGVuZFRpbWUsXHJcbiAgICAgIGZpbmFsXHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IGZpcnN0UmVjZWl2ZWRUaW1lID0gKF9hID0gZmlyc3RSZWNlaXZlZFRpbWVzTWFwLmdldChpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBsYXN0UmVjZWl2ZWRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgIGlmIChmaW5hbCkge1xyXG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZGVsZXRlKGlkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5zZXQoaWQsIGZpcnN0UmVjZWl2ZWRUaW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkLFxyXG4gICAgICB0ZXh0LFxyXG4gICAgICBzdGFydFRpbWU6IE51bWJlci5wYXJzZUludChzdGFydFRpbWUudG9TdHJpbmcoKSksXHJcbiAgICAgIGVuZFRpbWU6IE51bWJlci5wYXJzZUludChlbmRUaW1lLnRvU3RyaW5nKCkpLFxyXG4gICAgICBmaW5hbCxcclxuICAgICAgbGFuZ3VhZ2UsXHJcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lLFxyXG4gICAgICBsYXN0UmVjZWl2ZWRUaW1lXHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RDaGF0TWVzc2FnZShtc2cpIHtcclxuICBjb25zdCB7XHJcbiAgICBpZCxcclxuICAgIHRpbWVzdGFtcCxcclxuICAgIG1lc3NhZ2UsXHJcbiAgICBlZGl0VGltZXN0YW1wXHJcbiAgfSA9IG1zZztcclxuICByZXR1cm4ge1xyXG4gICAgaWQsXHJcbiAgICB0aW1lc3RhbXA6IE51bWJlci5wYXJzZUludCh0aW1lc3RhbXAudG9TdHJpbmcoKSksXHJcbiAgICBlZGl0VGltZXN0YW1wOiBlZGl0VGltZXN0YW1wID8gTnVtYmVyLnBhcnNlSW50KGVkaXRUaW1lc3RhbXAudG9TdHJpbmcoKSkgOiB1bmRlZmluZWQsXHJcbiAgICBtZXNzYWdlXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKSB7XHJcbiAgc3dpdGNoIChlLnJlYXNvbikge1xyXG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0OlxyXG4gICAgICByZXR1cm4gZS5jb250ZXh0O1xyXG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkOlxyXG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEO1xyXG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZDpcclxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uVVNFUl9SRUpFQ1RFRDtcclxuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlOlxyXG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5KT0lOX0ZBSUxVUkU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5VTktOT1dOX1JFQVNPTjtcclxuICB9XHJcbn1cclxuLyoqIGNvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzIHByZXNlcnZpbmcgdW5kZWZpbmVkIHZhbHVlcyAqL1xyXG5mdW5jdGlvbiBiaWdJbnRUb051bWJlcih2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKHZhbHVlKSA6IHVuZGVmaW5lZDtcclxufVxyXG4vKiogY29udmVydCBudW1iZXJzIHRvIGJpZ2ludHMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXHJcbmZ1bmN0aW9uIG51bWJlclRvQmlnSW50KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBCaWdJbnQodmFsdWUpIDogdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGlzTG9jYWxUcmFjayh0cmFjaykge1xyXG4gIHJldHVybiAhIXRyYWNrICYmICEodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSAmJiB0cmFjay5pc0xvY2FsO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXVkaW9UcmFjayh0cmFjaykge1xyXG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5BdWRpbztcclxufVxyXG5mdW5jdGlvbiBpc1ZpZGVvVHJhY2sodHJhY2spIHtcclxuICByZXR1cm4gISF0cmFjayAmJiB0cmFjay5raW5kID09IFRyYWNrLktpbmQuVmlkZW87XHJcbn1cclxuZnVuY3Rpb24gaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spIHtcclxuICByZXR1cm4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB7XHJcbiAgcmV0dXJuIGlzTG9jYWxUcmFjayh0cmFjaykgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlbW90ZVRyYWNrKHRyYWNrKSB7XHJcbiAgcmV0dXJuICEhdHJhY2sgJiYgIXRyYWNrLmlzTG9jYWw7XHJcbn1cclxuZnVuY3Rpb24gaXNSZW1vdGVQdWIocHViKSB7XHJcbiAgcmV0dXJuICEhcHViICYmICFwdWIuaXNMb2NhbDtcclxufVxyXG5mdW5jdGlvbiBpc1JlbW90ZVZpZGVvVHJhY2sodHJhY2spIHtcclxuICByZXR1cm4gaXNSZW1vdGVUcmFjayh0cmFjaykgJiYgaXNWaWRlb1RyYWNrKHRyYWNrKTtcclxufVxyXG5mdW5jdGlvbiBpc0xvY2FsUGFydGljaXBhbnQocCkge1xyXG4gIHJldHVybiBwLmlzTG9jYWw7XHJcbn1cclxuZnVuY3Rpb24gaXNSZW1vdGVQYXJ0aWNpcGFudChwKSB7XHJcbiAgcmV0dXJuICFwLmlzTG9jYWw7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRVdGY4KHMsIG4pIHtcclxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYwNDM3OTdcclxuICBjb25zdCByZXN1bHQgPSBbXTtcclxuICBsZXQgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKTtcclxuICB3aGlsZSAoZW5jb2RlZC5sZW5ndGggPiBuKSB7XHJcbiAgICBsZXQgayA9IG47XHJcbiAgICB3aGlsZSAoayA+IDApIHtcclxuICAgICAgY29uc3QgYnl0ZSA9IGVuY29kZWRba107XHJcbiAgICAgIGlmIChieXRlICE9PSB1bmRlZmluZWQgJiYgKGJ5dGUgJiAweGMwKSAhPT0gMHg4MCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGstLTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQuc2xpY2UoMCwgaykpO1xyXG4gICAgZW5jb2RlZCA9IGVuY29kZWQuc2xpY2Uoayk7XHJcbiAgfVxyXG4gIGlmIChlbmNvZGVkLmxlbmd0aCA+IDApIHtcclxuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpIHtcclxuICB2YXIgX2EsIF9iO1xyXG4gIHZhciBfYywgX2Q7XHJcbiAgY29uc3Qge1xyXG4gICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IsXHJcbiAgICBhdWRpb1Byb2Nlc3NvcixcclxuICAgIHZpZGVvUHJvY2Vzc29yXHJcbiAgfSA9IGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xyXG4gIGNvbnN0IGRlZmF1bHRBdWRpb1Byb2Nlc3NvciA9IGF1ZGlvRGVmYXVsdHMgPT09IG51bGwgfHwgYXVkaW9EZWZhdWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXVkaW9EZWZhdWx0cy5wcm9jZXNzb3I7XHJcbiAgY29uc3QgZGVmYXVsdFZpZGVvUHJvY2Vzc29yID0gdmlkZW9EZWZhdWx0cyA9PT0gbnVsbCB8fCB2aWRlb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb0RlZmF1bHRzLnByb2Nlc3NvcjtcclxuICBjb25zdCBjbG9uZWRPcHRpb25zID0gb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgIT09IG51bGwgJiYgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgIT09IHZvaWQgMCA/IG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yIDoge307XHJcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8gPT09IHRydWUpIGNsb25lZE9wdGlvbnMuYXVkaW8gPSB7fTtcclxuICBpZiAoY2xvbmVkT3B0aW9ucy52aWRlbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy52aWRlbyA9IHt9O1xyXG4gIC8vIHVzZSBkZWZhdWx0c1xyXG4gIGlmIChjbG9uZWRPcHRpb25zLmF1ZGlvKSB7XHJcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLmF1ZGlvLCBhdWRpb0RlZmF1bHRzKTtcclxuICAgIChfYSA9IChfYyA9IGNsb25lZE9wdGlvbnMuYXVkaW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfYy5kZXZpY2VJZCA9IHtcclxuICAgICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gICAgfTtcclxuICAgIGlmIChhdWRpb1Byb2Nlc3NvciB8fCBkZWZhdWx0QXVkaW9Qcm9jZXNzb3IpIHtcclxuICAgICAgY2xvbmVkT3B0aW9ucy5hdWRpby5wcm9jZXNzb3IgPSBhdWRpb1Byb2Nlc3NvciAhPT0gbnVsbCAmJiBhdWRpb1Byb2Nlc3NvciAhPT0gdm9pZCAwID8gYXVkaW9Qcm9jZXNzb3IgOiBkZWZhdWx0QXVkaW9Qcm9jZXNzb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChjbG9uZWRPcHRpb25zLnZpZGVvKSB7XHJcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhjbG9uZWRPcHRpb25zLnZpZGVvLCB2aWRlb0RlZmF1bHRzKTtcclxuICAgIChfYiA9IChfZCA9IGNsb25lZE9wdGlvbnMudmlkZW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfZC5kZXZpY2VJZCA9IHtcclxuICAgICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gICAgfTtcclxuICAgIGlmICh2aWRlb1Byb2Nlc3NvciB8fCBkZWZhdWx0VmlkZW9Qcm9jZXNzb3IpIHtcclxuICAgICAgY2xvbmVkT3B0aW9ucy52aWRlby5wcm9jZXNzb3IgPSB2aWRlb1Byb2Nlc3NvciAhPT0gbnVsbCAmJiB2aWRlb1Byb2Nlc3NvciAhPT0gdm9pZCAwID8gdmlkZW9Qcm9jZXNzb3IgOiBkZWZhdWx0VmlkZW9Qcm9jZXNzb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjbG9uZWRPcHRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG1haW5PYmplY3QsIG9iamVjdFRvTWVyZ2UpIHtcclxuICBPYmplY3Qua2V5cyhvYmplY3RUb01lcmdlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBpZiAobWFpbk9iamVjdFtrZXldID09PSB1bmRlZmluZWQpIG1haW5PYmplY3Rba2V5XSA9IG9iamVjdFRvTWVyZ2Vba2V5XTtcclxuICB9KTtcclxuICByZXR1cm4gbWFpbk9iamVjdDtcclxufVxyXG5mdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9ucykge1xyXG4gIHZhciBfYSwgX2I7XHJcbiAgdmFyIF9jLCBfZDtcclxuICBjb25zdCBjb25zdHJhaW50cyA9IHt9O1xyXG4gIGlmIChvcHRpb25zLnZpZGVvKSB7XHJcbiAgICAvLyBkZWZhdWx0IHZpZGVvIG9wdGlvbnNcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3QgdmlkZW9PcHRpb25zID0ge307XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IHZpZGVvT3B0aW9ucztcclxuICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbztcclxuICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgIGNhc2UgJ3Jlc29sdXRpb24nOlxyXG4gICAgICAgICAgICAvLyBmbGF0dGVuIFZpZGVvUmVzb2x1dGlvbiBmaWVsZHNcclxuICAgICAgICAgICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcodGFyZ2V0LCBzb3VyY2UucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHZpZGVvT3B0aW9ucztcclxuICAgICAgKF9hID0gKF9jID0gY29uc3RyYWludHMudmlkZW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfYy5kZXZpY2VJZCA9IHtcclxuICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IG9wdGlvbnMudmlkZW8gPyB7XHJcbiAgICAgICAgZGV2aWNlSWQ6IHtcclxuICAgICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICAgICAgICB9XHJcbiAgICAgIH0gOiBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3RyYWludHMudmlkZW8gPSBmYWxzZTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xyXG4gICAgICAoX2IgPSAoX2QgPSBjb25zdHJhaW50cy5hdWRpbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9kLmRldmljZUlkID0ge1xyXG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0ge1xyXG4gICAgICAgIGRldmljZUlkOiB7XHJcbiAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gY29uc3RyYWludHM7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBzaWxlbmNlIG9uIGEgZ2l2ZW4gW1tUcmFja11dIGluc3RhbmNlLlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYWNrIHNlZW1zIHRvIGJlIGVudGlyZWx5IHNpbGVudC5cclxuICovXHJcbmZ1bmN0aW9uIGRldGVjdFNpbGVuY2UodHJhY2tfMSkge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh0cmFjaykge1xyXG4gICAgbGV0IHRpbWVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDIwMDtcclxuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBjdHggPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcclxuICAgICAgaWYgKGN0eCkge1xyXG4gICAgICAgIGNvbnN0IGFuYWx5c2VyID0gY3R4LmNyZWF0ZUFuYWx5c2VyKCk7XHJcbiAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XHJcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFt0cmFjay5tZWRpYVN0cmVhbVRyYWNrXSkpO1xyXG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcclxuICAgICAgICB5aWVsZCBzbGVlcCh0aW1lT2Zmc2V0KTtcclxuICAgICAgICBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoZGF0YUFycmF5KTtcclxuICAgICAgICBjb25zdCBzb21lTm9pc2UgPSBkYXRhQXJyYXkuc29tZShzYW1wbGUgPT4gc2FtcGxlICE9PSAxMjggJiYgc2FtcGxlICE9PSAwKTtcclxuICAgICAgICBjdHguY2xvc2UoKTtcclxuICAgICAgICByZXR1cm4gIXNvbWVOb2lzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KCk7XHJcbiAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmV3QXVkaW9Db250ZXh0KCkge1xyXG4gIHZhciBfYTtcclxuICBjb25zdCBBdWRpb0NvbnRleHQgPVxyXG4gIC8vIEB0cy1pZ25vcmVcclxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KTtcclxuICBpZiAoQXVkaW9Db250ZXh0KSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcclxuICAgICAgbGF0ZW5jeUhpbnQ6ICdpbnRlcmFjdGl2ZSdcclxuICAgIH0pO1xyXG4gICAgLy8gSWYgdGhlIGF1ZGlvIGNvbnRleHQgaXMgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHJlc3VtZSBpdCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgcGFnZVxyXG4gICAgaWYgKGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHdpbmRvdy5kb2N1bWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvZHkpKSB7XHJcbiAgICAgIGNvbnN0IGhhbmRsZVJlc3VtZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHRyeWluZyB0byBhdXRvLXJlc3VtZSBhdWRpbyBjb250ZXh0JywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xyXG4gICAgICB9KTtcclxuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF1ZGlvQ29udGV4dDtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24ga2luZFRvU291cmNlKGtpbmQpIHtcclxuICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XHJcbiAgICByZXR1cm4gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW9pbnB1dCcpIHtcclxuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gVHJhY2suU291cmNlLlVua25vd247XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHNvdXJjZVRvS2luZChzb3VyY2UpIHtcclxuICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkge1xyXG4gICAgcmV0dXJuICdhdWRpb2lucHV0JztcclxuICB9IGVsc2UgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xyXG4gICAgcmV0dXJuICd2aWRlb2lucHV0JztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgdmFyIF9hLCBfYjtcclxuICBsZXQgdmlkZW9Db25zdHJhaW50cyA9IChfYSA9IG9wdGlvbnMudmlkZW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgLy8gdHJlYXQgMCBhcyB1bmNhcHBlZFxyXG4gIGlmIChvcHRpb25zLnJlc29sdXRpb24gJiYgb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoID4gMCAmJiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0ID4gMCkge1xyXG4gICAgdmlkZW9Db25zdHJhaW50cyA9IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzID09PSAnYm9vbGVhbicgPyB7fSA6IHZpZGVvQ29uc3RyYWludHM7XHJcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xyXG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0NvbnN0cmFpbnRzKSwge1xyXG4gICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XHJcbiAgICAgICAgd2lkdGg6IHtcclxuICAgICAgICAgIGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlaWdodDoge1xyXG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zLmF1ZGlvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcclxuICAgIHZpZGVvOiB2aWRlb0NvbnN0cmFpbnRzLFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IGZvciBleHBlcmltZW50YWwgZGlzcGxheSBtZWRpYSBmZWF0dXJlc1xyXG4gICAgY29udHJvbGxlcjogb3B0aW9ucy5jb250cm9sbGVyLFxyXG4gICAgc2VsZkJyb3dzZXJTdXJmYWNlOiBvcHRpb25zLnNlbGZCcm93c2VyU3VyZmFjZSxcclxuICAgIHN1cmZhY2VTd2l0Y2hpbmc6IG9wdGlvbnMuc3VyZmFjZVN3aXRjaGluZyxcclxuICAgIHN5c3RlbUF1ZGlvOiBvcHRpb25zLnN5c3RlbUF1ZGlvLFxyXG4gICAgcHJlZmVyQ3VycmVudFRhYjogb3B0aW9ucy5wcmVmZXJDdXJyZW50VGFiXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZSkge1xyXG4gIHJldHVybiBtaW1lVHlwZS5zcGxpdCgnLycpWzFdLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8odHJhY2tzKSB7XHJcbiAgY29uc3QgaW5mb3MgPSBbXTtcclxuICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICBpZiAodHJhY2sudHJhY2sgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpbmZvcy5wdXNoKG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcclxuICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXHJcbiAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mb1xyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGluZm9zO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spIHtcclxuICBpZiAoJ21lZGlhU3RyZWFtVHJhY2snIGluIHRyYWNrKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0cmFja0lEOiB0cmFjay5zaWQsXHJcbiAgICAgIHNvdXJjZTogdHJhY2suc291cmNlLFxyXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcclxuICAgICAgZW5hYmxlZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5lbmFibGVkLFxyXG4gICAgICBraW5kOiB0cmFjay5raW5kLFxyXG4gICAgICBzdHJlYW1JRDogdHJhY2subWVkaWFTdHJlYW1JRCxcclxuICAgICAgc3RyZWFtVHJhY2tJRDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHJhY2tJRDogdHJhY2sudHJhY2tTaWQsXHJcbiAgICAgIGVuYWJsZWQ6IHRyYWNrLmlzRW5hYmxlZCxcclxuICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXHJcbiAgICAgIHRyYWNrSW5mbzogT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgbWltZVR5cGU6IHRyYWNrLm1pbWVUeXBlLFxyXG4gICAgICAgIG5hbWU6IHRyYWNrLnRyYWNrTmFtZSxcclxuICAgICAgICBlbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxyXG4gICAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXHJcbiAgICAgICAgc291cmNlOiB0cmFjay5zb3VyY2VcclxuICAgICAgfSwgdHJhY2sudHJhY2sgPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrLnRyYWNrKSA6IHt9KVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzKCkge1xyXG4gIHJldHVybiB0eXBlb2YgUlRDUnRwUmVjZWl2ZXIgIT09ICd1bmRlZmluZWQnICYmICdnZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzJyBpbiBSVENSdHBSZWNlaXZlcjtcclxufVxyXG5mdW5jdGlvbiBkaWZmQXR0cmlidXRlcyhvbGRWYWx1ZXMsIG5ld1ZhbHVlcykge1xyXG4gIHZhciBfYTtcclxuICBpZiAob2xkVmFsdWVzID09PSB1bmRlZmluZWQpIHtcclxuICAgIG9sZFZhbHVlcyA9IHt9O1xyXG4gIH1cclxuICBpZiAobmV3VmFsdWVzID09PSB1bmRlZmluZWQpIHtcclxuICAgIG5ld1ZhbHVlcyA9IHt9O1xyXG4gIH1cclxuICBjb25zdCBhbGxLZXlzID0gWy4uLk9iamVjdC5rZXlzKG5ld1ZhbHVlcyksIC4uLk9iamVjdC5rZXlzKG9sZFZhbHVlcyldO1xyXG4gIGNvbnN0IGRpZmYgPSB7fTtcclxuICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XHJcbiAgICBpZiAob2xkVmFsdWVzW2tleV0gIT09IG5ld1ZhbHVlc1trZXldKSB7XHJcbiAgICAgIGRpZmZba2V5XSA9IChfYSA9IG5ld1ZhbHVlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGRpZmY7XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMpIHtcclxuICBjb25zdCBuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgbGV0IGF1ZGlvUHJvY2Vzc29yO1xyXG4gIGxldCB2aWRlb1Byb2Nlc3NvcjtcclxuICBpZiAodHlwZW9mIG5ld09wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yKSB7XHJcbiAgICBhdWRpb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yO1xyXG4gICAgbmV3T3B0aW9ucy5hdWRpbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3T3B0aW9ucy5hdWRpbyksIHtcclxuICAgICAgcHJvY2Vzc29yOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIG5ld09wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmIG5ld09wdGlvbnMudmlkZW8ucHJvY2Vzc29yKSB7XHJcbiAgICB2aWRlb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMudmlkZW8ucHJvY2Vzc29yO1xyXG4gICAgbmV3T3B0aW9ucy52aWRlbyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV3T3B0aW9ucy52aWRlbyksIHtcclxuICAgICAgcHJvY2Vzc29yOiB1bmRlZmluZWRcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgYXVkaW9Qcm9jZXNzb3IsXHJcbiAgICB2aWRlb1Byb2Nlc3NvcixcclxuICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yOiBjbG9uZURlZXAobmV3T3B0aW9ucylcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYWNrU291cmNlRnJvbVByb3RvKHNvdXJjZSkge1xyXG4gIHN3aXRjaCAoc291cmNlKSB7XHJcbiAgICBjYXNlIFRyYWNrU291cmNlLkNBTUVSQTpcclxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XHJcbiAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XHJcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcclxuICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxyXG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xyXG4gICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU86XHJcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG5jbGFzcyBFMkVFTWFuYWdlciBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5vbldvcmtlck1lc3NhZ2UgPSBldiA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBraW5kLFxyXG4gICAgICAgIGRhdGFcclxuICAgICAgfSA9IGV2LmRhdGE7XHJcbiAgICAgIHN3aXRjaCAoa2luZCkge1xyXG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcclxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZXJyb3IoZGF0YS5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBkYXRhLmVycm9yKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2luaXRBY2snOlxyXG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdlbmFibGUnOlxyXG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5lbmNyeXB0aW9uRW5hYmxlZCAhPT0gZGF0YS5lbmFibGVkICYmIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSA9PT0gKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBkYXRhLmVuYWJsZWQ7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IChfYiA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiY291bGRuJ3Qgc2V0IGVuY3J5cHRpb24gc3RhdHVzLCBwYXJ0aWNpcGFudCBub3QgZm91bmRcIi5jb25jYXQoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBkYXRhLmVuYWJsZWQsIHBhcnRpY2lwYW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3JhdGNoZXRLZXknOlxyXG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLnJhdGNoZXRSZXN1bHQsIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSwgZGF0YS5rZXlJbmRleCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMub25Xb3JrZXJFcnJvciA9IGV2ID0+IHtcclxuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6Jywge1xyXG4gICAgICAgIGVycm9yOiBldi5lcnJvclxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmtleVByb3ZpZGVyID0gb3B0aW9ucy5rZXlQcm92aWRlcjtcclxuICAgIHRoaXMud29ya2VyID0gb3B0aW9ucy53b3JrZXI7XHJcbiAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZmFsc2U7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldHVwKHJvb20pIHtcclxuICAgIGlmICghaXNFMkVFU3VwcG9ydGVkKCkpIHtcclxuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyk7XHJcbiAgICB9XHJcbiAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ3NldHRpbmcgdXAgZTJlZScpO1xyXG4gICAgaWYgKHJvb20gIT09IHRoaXMucm9vbSkge1xyXG4gICAgICB0aGlzLnJvb20gPSByb29tO1xyXG4gICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwgdGhpcy5rZXlQcm92aWRlcik7XHJcbiAgICAgIC8vIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcignJyk7XHJcbiAgICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAgICBraW5kOiAnaW5pdCcsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAga2V5UHJvdmlkZXJPcHRpb25zOiB0aGlzLmtleVByb3ZpZGVyLmdldE9wdGlvbnMoKSxcclxuICAgICAgICAgIGxvZ2xldmVsOiB3b3JrZXJMb2dnZXIuZ2V0TGV2ZWwoKVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgaWYgKHRoaXMud29ya2VyKSB7XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiaW5pdGlhbGl6aW5nIHdvcmtlclwiLCB7XHJcbiAgICAgICAgICB3b3JrZXI6IHRoaXMud29ya2VyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbldvcmtlck1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMub25Xb3JrZXJFcnJvcjtcclxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xyXG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNldCBlMmVlIHRvIFwiLmNvbmNhdChlbmFibGVkLCBcIiBmb3IgcGFydGljaXBhbnQgXCIpLmNvbmNhdChwYXJ0aWNpcGFudElkZW50aXR5KSk7XHJcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcikge1xyXG4gICAgaWYgKCF0cmFpbGVyIHx8IHRyYWlsZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGxpdmVraXRMb2dnZXIud2FybihcImlnbm9yaW5nIHNlcnZlciBzZW50IHRyYWlsZXIgYXMgaXQncyBlbXB0eVwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucG9zdFNpZlRyYWlsZXIodHJhaWxlcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xyXG4gICAgZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXAgPT4ge1xyXG4gICAgICB0aGlzLnBvc3RSVFBNYXAocnRwTWFwKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIGtleVByb3ZpZGVyKSB7XHJcbiAgICByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHB1YiwgcGFydGljaXBhbnQpID0+IHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChwdWIudHJhY2tJbmZvLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLCBwYXJ0aWNpcGFudC5pZGVudGl0eSkpO1xyXG4gICAgcm9vbS5vbihSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgc3RhdGUgPT4ge1xyXG4gICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgICByb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHtcclxuICAgICAgICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsICh0cmFjaywgXywgcGFydGljaXBhbnQpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAga2luZDogJ3JlbW92ZVRyYW5zZm9ybScsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnQuaWRlbnRpdHksXHJcbiAgICAgICAgICB0cmFja0lkOiB0cmFjay5tZWRpYVN0cmVhbUlEXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICAoX2EgPSB0aGlzLndvcmtlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgICB9KS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YiwgcGFydGljaXBhbnQpID0+IHtcclxuICAgICAgdGhpcy5zZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcGFydGljaXBhbnQuaWRlbnRpdHksIHB1Yi50cmFja0luZm8pO1xyXG4gICAgfSkub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMucm9vbSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCByb29tIHRvIGJlIHByZXNlbnQgb24gc2lnbmFsIGNvbm5lY3RcIik7XHJcbiAgICAgIH1cclxuICAgICAga2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XHJcbiAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlzRTJFRUVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcclxuICAgIH0pO1xyXG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24gPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnNldHVwRTJFRVNlbmRlcihwdWJsaWNhdGlvbi50cmFjaywgcHVibGljYXRpb24udHJhY2suc2VuZGVyKTtcclxuICAgIH0pKTtcclxuICAgIGtleVByb3ZpZGVyLm9uKEtleVByb3ZpZGVyRXZlbnQuU2V0S2V5LCBrZXlJbmZvID0+IHRoaXMucG9zdEtleShrZXlJbmZvKSkub24oS2V5UHJvdmlkZXJFdmVudC5SYXRjaGV0UmVxdWVzdCwgKHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSA9PiB0aGlzLnBvc3RSYXRjaGV0UmVxdWVzdChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkpO1xyXG4gIH1cclxuICBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcclxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCByYXRjaGV0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAga2luZDogJ3JhdGNoZXRSZXF1ZXN0JyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXHJcbiAgICAgICAga2V5SW5kZXhcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgfVxyXG4gIHBvc3RLZXkoX3JlZikge1xyXG4gICAgbGV0IHtcclxuICAgICAga2V5LFxyXG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxyXG4gICAgICBrZXlJbmRleFxyXG4gICAgfSA9IF9yZWY7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdjb3VsZCBub3Qgc2V0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAga2luZDogJ3NldEtleScsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxyXG4gICAgICAgIGlzUHVibGlzaGVyOiBwYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSksXHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIGtleUluZGV4XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xyXG4gIH1cclxuICBwb3N0RW5hYmxlKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgIGlmICh0aGlzLndvcmtlcikge1xyXG4gICAgICBjb25zdCBlbmFibGVNc2cgPSB7XHJcbiAgICAgICAga2luZDogJ2VuYWJsZScsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgZW5hYmxlZCxcclxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHlcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGVuYWJsZU1zZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ2ZhaWxlZCB0byBlbmFibGUgZTJlZSwgd29ya2VyIGlzIG5vdCByZWFkeScpO1xyXG4gICAgfVxyXG4gIH1cclxuICBwb3N0UlRQTWFwKG1hcCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xyXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSkge1xyXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAga2luZDogJ3NldFJUUE1hcCcsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBtYXAsXHJcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHlcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgfVxyXG4gIHBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpIHtcclxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IFNJRiB0cmFpbGVyLCB3b3JrZXIgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXNnID0ge1xyXG4gICAgICBraW5kOiAnc2V0U2lmVHJhaWxlcicsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICB0cmFpbGVyXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xyXG4gIH1cclxuICBzZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcmVtb3RlSWQsIHRyYWNrSW5mbykge1xyXG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoISh0cmFja0luZm8gPT09IG51bGwgfHwgdHJhY2tJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0luZm8ubWltZVR5cGUpIHx8IHRyYWNrSW5mby5taW1lVHlwZSA9PT0gJycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWltZVR5cGUgbWlzc2luZyBmcm9tIHRyYWNrSW5mbywgY2Fubm90IHNldCB1cCBFMkVFIGNyeXB0b3InKTtcclxuICAgIH1cclxuICAgIHRoaXMuaGFuZGxlUmVjZWl2ZXIodHJhY2sucmVjZWl2ZXIsIHRyYWNrLm1lZGlhU3RyZWFtSUQsIHJlbW90ZUlkLCB0cmFjay5raW5kID09PSAndmlkZW8nID8gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodHJhY2tJbmZvLm1pbWVUeXBlKSA6IHVuZGVmaW5lZCk7XHJcbiAgfVxyXG4gIHNldHVwRTJFRVNlbmRlcih0cmFjaywgc2VuZGVyKSB7XHJcbiAgICBpZiAoIWlzTG9jYWxUcmFjayh0cmFjaykgfHwgIXNlbmRlcikge1xyXG4gICAgICBpZiAoIXNlbmRlcikgbGl2ZWtpdExvZ2dlci53YXJuKCdlYXJseSByZXR1cm4gYmVjYXVzZSBzZW5kZXIgaXMgbm90IHJlYWR5Jyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgdW5kZWZpbmVkKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4ge0Bjb2RlIFJUQ1J0cFJlY2VpdmVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XHJcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxyXG4gICAqXHJcbiAgICovXHJcbiAgaGFuZGxlUmVjZWl2ZXIocmVjZWl2ZXIsIHRyYWNrSWQsIHBhcnRpY2lwYW50SWRlbnRpdHksIGNvZGVjKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMud29ya2VyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgIGtpbmQ6ICdkZWNvZGUnLFxyXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcclxuICAgICAgICAgIHRyYWNrSWQsXHJcbiAgICAgICAgICBjb2RlY1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHJlY2VpdmVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChFMkVFX0ZMQUcgaW4gcmVjZWl2ZXIgJiYgY29kZWMpIHtcclxuICAgICAgICAgIC8vIG9ubHkgdXBkYXRlIGNvZGVjXHJcbiAgICAgICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICB0cmFja0lkLFxyXG4gICAgICAgICAgICAgIGNvZGVjLFxyXG4gICAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBsZXQgd3JpdGFibGUgPSByZWNlaXZlci53cml0YWJsZVN0cmVhbTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbGV0IHJlYWRhYmxlID0gcmVjZWl2ZXIucmVhZGFibGVTdHJlYW07XHJcbiAgICAgICAgaWYgKCF3cml0YWJsZSB8fCAhcmVhZGFibGUpIHtcclxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgIGNvbnN0IHJlY2VpdmVyU3RyZWFtcyA9IHJlY2VpdmVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICByZWNlaXZlci53cml0YWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy53cml0YWJsZTtcclxuICAgICAgICAgIHdyaXRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgcmVjZWl2ZXIucmVhZGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMucmVhZGFibGU7XHJcbiAgICAgICAgICByZWFkYWJsZSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbXNnID0ge1xyXG4gICAgICAgICAga2luZDogJ2RlY29kZScsXHJcbiAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcclxuICAgICAgICAgICAgd3JpdGFibGVTdHJlYW06IHdyaXRhYmxlLFxyXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxyXG4gICAgICAgICAgICBjb2RlYyxcclxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbcmVhZGFibGUsIHdyaXRhYmxlXSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZWNlaXZlcltFMkVFX0ZMQUddID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XHJcbiAgICogYSBmcmFtZSBlbmNvZGVyLlxyXG4gICAqXHJcbiAgICovXHJcbiAgaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2tJZCwgY29kZWMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB8fCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gJycpIHtcclxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcclxuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIHNjcmlwdCB0cmFuc2Zvcm0nKTtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICBraW5kOiAnZW5jb2RlJyxcclxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcclxuICAgICAgICB0cmFja0lkLFxyXG4gICAgICAgIGNvZGVjXHJcbiAgICAgIH07XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgc2VuZGVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdpbml0aWFsaXplIGVuY29kZWQgc3RyZWFtcycpO1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGNvbnN0IHNlbmRlclN0cmVhbXMgPSBzZW5kZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcclxuICAgICAgY29uc3QgbXNnID0ge1xyXG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiBzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLFxyXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXHJcbiAgICAgICAgICBjb2RlYyxcclxuICAgICAgICAgIHRyYWNrSWQsXHJcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSwgc2VuZGVyU3RyZWFtcy53cml0YWJsZV0pO1xyXG4gICAgfVxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgc2VuZGVyW0UyRUVfRkxBR10gPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgZGVmYXVsdElkID0gJ2RlZmF1bHQnO1xyXG5jbGFzcyBEZXZpY2VNYW5hZ2VyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX3ByZXZpb3VzRGV2aWNlcyA9IFtdO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICBpZiAodGhpcy5pbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgfVxyXG4gIGdldCBwcmV2aW91c0RldmljZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEZXZpY2VzO1xyXG4gIH1cclxuICBnZXREZXZpY2VzKGtpbmRfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGtpbmQpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgbGV0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoKF9hID0gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgPiAwKSB7XHJcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdhd2FpdGluZyBnZXRVc2VyTWVkaWEgcHJvbWlzZScpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGtpbmQpIHtcclxuICAgICAgICAgICAgICB5aWVsZCBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZ2V0KGtpbmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdlcnJvciB3YWl0aW5nIGZvciBtZWRpYSBwZXJtaXNzb25zJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3RQZXJtaXNzaW9ucyAmJlxyXG4gICAgICAgIC8vIGZvciBzYWZhcmkgd2UgbmVlZCB0byBza2lwIHRoaXMgY2hlY2ssIGFzIG90aGVyd2lzZSBpdCB3aWxsIHJlLWFjcXVpcmUgdXNlciBtZWRpYSBhbmQgZmFpbCBvbiBpT1MgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xyXG4gICAgICAgICEoaXNTYWZhcmkoKSAmJiBfdGhpcy5oYXNEZXZpY2VJblVzZShraW5kKSkpIHtcclxuICAgICAgICAgIGNvbnN0IGlzRHVtbXlEZXZpY2VPckVtcHR5ID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09IGtpbmQpLmxlbmd0aCA9PT0gMCB8fCBkZXZpY2VzLnNvbWUoZGV2aWNlID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBraW5kID8gZGV2aWNlLmtpbmQgPT09IGtpbmQgOiB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9MYWJlbCAmJiBpc1JlbGV2YW50O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAoaXNEdW1teURldmljZU9yRW1wdHkpIHtcclxuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnNUb0FjcXVpcmUgPSB7XHJcbiAgICAgICAgICAgICAgdmlkZW86IGtpbmQgIT09ICdhdWRpb2lucHV0JyAmJiBraW5kICE9PSAnYXVkaW9vdXRwdXQnLFxyXG4gICAgICAgICAgICAgIGF1ZGlvOiBraW5kICE9PSAndmlkZW9pbnB1dCcgJiYge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHtcclxuICAgICAgICAgICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xyXG4gICAgICAgICAgICBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XHJcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5fcHJldmlvdXNEZXZpY2VzID0gZGV2aWNlcztcclxuICAgICAgICBpZiAoa2luZCkge1xyXG4gICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXZpY2VzO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XHJcbiAgICAgICAgcmV0dXJuIGRldmljZUlkO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlc29sdmUgYWN0dWFsIGRldmljZSBpZCBpZiBpdCdzICdkZWZhdWx0JzogQ2hyb21lIHJldHVybnMgaXQgd2hlbiBub1xyXG4gICAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXHJcbiAgICAgIGNvbnN0IGRldmljZXMgPSB5aWVsZCB0aGlzLmdldERldmljZXMoa2luZCk7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHREZXZpY2UgPSBkZXZpY2VzLmZpbmQoZCA9PiBkLmRldmljZUlkID09PSBkZWZhdWx0SWQpO1xyXG4gICAgICBpZiAoIWRlZmF1bHREZXZpY2UpIHtcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZWxpYWJseSBkZXRlcm1pbmUgZGVmYXVsdCBkZXZpY2UnKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRldmljZSA9IGRldmljZXMuZmluZChkID0+IGQuZGV2aWNlSWQgIT09IGRlZmF1bHRJZCAmJiBkLmdyb3VwSWQgPT09IChncm91cElkICE9PSBudWxsICYmIGdyb3VwSWQgIT09IHZvaWQgMCA/IGdyb3VwSWQgOiBkZWZhdWx0RGV2aWNlLmdyb3VwSWQpKTtcclxuICAgICAgaWYgKCFkZXZpY2UpIHtcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZWxpYWJseSBkZXRlcm1pbmUgZGVmYXVsdCBkZXZpY2UnKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkZXZpY2UgPT09IG51bGwgfHwgZGV2aWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXZpY2UuZGV2aWNlSWQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaGFzRGV2aWNlSW5Vc2Uoa2luZCkge1xyXG4gICAgcmV0dXJuIGtpbmQgPyBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuaGFzKGtpbmQpIDogRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNpemUgPiAwO1xyXG4gIH1cclxufVxyXG5EZXZpY2VNYW5hZ2VyLm1lZGlhRGV2aWNlS2luZHMgPSBbJ2F1ZGlvaW5wdXQnLCAnYXVkaW9vdXRwdXQnLCAndmlkZW9pbnB1dCddO1xyXG5EZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAgPSBuZXcgTWFwKCk7XHJcblxyXG52YXIgUXVldWVUYXNrU3RhdHVzO1xyXG4oZnVuY3Rpb24gKFF1ZXVlVGFza1N0YXR1cykge1xyXG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJXQUlUSU5HXCJdID0gMF0gPSBcIldBSVRJTkdcIjtcclxuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XHJcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIkNPTVBMRVRFRFwiXSA9IDJdID0gXCJDT01QTEVURURcIjtcclxufSkoUXVldWVUYXNrU3RhdHVzIHx8IChRdWV1ZVRhc2tTdGF0dXMgPSB7fSkpO1xyXG5jbGFzcyBBc3luY1F1ZXVlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy50YXNrTXV0ZXggPSBuZXcgXygpO1xyXG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcclxuICB9XHJcbiAgcnVuKHRhc2spIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHRhc2tJbmZvID0ge1xyXG4gICAgICAgIGlkOiB0aGlzLm5leHRUYXNrSW5kZXgrKyxcclxuICAgICAgICBlbnF1ZXVlZEF0OiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHN0YXR1czogUXVldWVUYXNrU3RhdHVzLldBSVRJTkdcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMudGFza011dGV4LmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuUlVOTklORztcclxuICAgICAgICByZXR1cm4geWllbGQgdGFzaygpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5DT01QTEVURUQ7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFza3MuZGVsZXRlKHRhc2tJbmZvLmlkKTtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZsdXNoKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucnVuKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHt9KSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc25hcHNob3QoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVSdGNVcmwodXJsLCBzZWFyY2hQYXJhbXMpIHtcclxuICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHRvV2Vic29ja2V0VXJsKHVybCkpO1xyXG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICB1cmxPYmouc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcclxuICB9KTtcclxuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICdydGMnKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0ZVVybChydGNXc1VybCkge1xyXG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9IdHRwVXJsKHJ0Y1dzVXJsKSk7XHJcbiAgcmV0dXJuIGFwcGVuZFVybFBhdGgodXJsT2JqLCAndmFsaWRhdGUnKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHBhdGgpIHtcclxuICByZXR1cm4gcGF0aC5lbmRzV2l0aCgnLycpID8gcGF0aCA6IFwiXCIuY29uY2F0KHBhdGgsIFwiL1wiKTtcclxufVxyXG5mdW5jdGlvbiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgcGF0aCkge1xyXG4gIHVybE9iai5wYXRobmFtZSA9IFwiXCIuY29uY2F0KGVuc3VyZVRyYWlsaW5nU2xhc2godXJsT2JqLnBhdGhuYW1lKSkuY29uY2F0KHBhdGgpO1xyXG4gIHJldHVybiB1cmxPYmoudG9TdHJpbmcoKTtcclxufVxyXG5cclxuY29uc3QgcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMgPSBbJ3N5bmNTdGF0ZScsICd0cmlja2xlJywgJ29mZmVyJywgJ2Fuc3dlcicsICdzaW11bGF0ZScsICdsZWF2ZSddO1xyXG5mdW5jdGlvbiBjYW5QYXNzVGhyb3VnaFF1ZXVlKHJlcSkge1xyXG4gIGNvbnN0IGNhblBhc3MgPSBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscy5pbmRleE9mKHJlcS5jYXNlKSA+PSAwO1xyXG4gIGxpdmVraXRMb2dnZXIudHJhY2UoJ3JlcXVlc3QgYWxsb3dlZCB0byBieXBhc3MgcXVldWU6Jywge1xyXG4gICAgY2FuUGFzcyxcclxuICAgIHJlcVxyXG4gIH0pO1xyXG4gIHJldHVybiBjYW5QYXNzO1xyXG59XHJcbnZhciBTaWduYWxDb25uZWN0aW9uU3RhdGU7XHJcbihmdW5jdGlvbiAoU2lnbmFsQ29ubmVjdGlvblN0YXRlKSB7XHJcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xyXG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJDT05ORUNURURcIl0gPSAxXSA9IFwiQ09OTkVDVEVEXCI7XHJcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcclxuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVElOR1wiXSA9IDNdID0gXCJESVNDT05ORUNUSU5HXCI7XHJcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkRJU0NPTk5FQ1RFRFwiXSA9IDRdID0gXCJESVNDT05ORUNURURcIjtcclxufSkoU2lnbmFsQ29ubmVjdGlvblN0YXRlIHx8IChTaWduYWxDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIFNpZ25hbENsaWVudCB7XHJcbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gIH1cclxuICBnZXQgaXNEaXNjb25uZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcclxuICB9XHJcbiAgZ2V0IGlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORyB8fCB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xyXG4gIH1cclxuICBnZXROZXh0UmVxdWVzdElkKCkge1xyXG4gICAgdGhpcy5fcmVxdWVzdElkICs9IDE7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdElkO1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGxldCB1c2VKU09OID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcclxuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICAgIHZhciBfYTtcclxuICAgIC8qKiBzaWduYWwgcnR0IGluIG1pbGxpc2Vjb25kcyAqL1xyXG4gICAgdGhpcy5ydHQgPSAwO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSAwO1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgdGhpcy5yZXNldENhbGxiYWNrcyA9ICgpID0+IHtcclxuICAgICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbkxlYXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbk5lZ290aWF0ZVJlcXVlc3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbk9mZmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vblRva2VuUmVmcmVzaCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMub25DbG9zZSA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlNpZ25hbCk7XHJcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xyXG4gICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcclxuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcclxuICAgIHRoaXMucXVldWVkUmVxdWVzdHMgPSBbXTtcclxuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcclxuICB9XHJcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XHJcbiAgfVxyXG4gIGpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIC8vIGR1cmluZyBhIGZ1bGwgcmVjb25uZWN0LCB3ZSdkIHdhbnQgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIGV2ZW4gaWYgY3VycmVudGx5XHJcbiAgICAgIC8vIGNvbm5lY3RlZFxyXG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkc7XHJcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XHJcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVjb25uZWN0KHVybCwgdG9rZW4sIHNpZCwgcmVhc29uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBiZWluZyBzZXQsIGlnbm9yaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XHJcbiAgICAgIC8vIGNsZWFyIHBpbmcgaW50ZXJ2YWwgYW5kIHJlc3RhcnQgaXQgb25jZSByZWNvbm5lY3RlZFxyXG4gICAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XHJcbiAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuY29ubmVjdCh1cmwsIHRva2VuLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIHtcclxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXHJcbiAgICAgICAgc2lkLFxyXG4gICAgICAgIHJlY29ubmVjdFJlYXNvbjogcmVhc29uXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlY29ubmVjdFJlc3BvbnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xyXG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdHM7XHJcbiAgICBjb25zdCBjbGllbnRJbmZvID0gZ2V0Q2xpZW50SW5mbygpO1xyXG4gICAgY29uc3QgcGFyYW1zID0gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cyk7XHJcbiAgICBjb25zdCBydGNVcmwgPSBjcmVhdGVSdGNVcmwodXJsLCBwYXJhbXMpO1xyXG4gICAgY29uc3QgdmFsaWRhdGVVcmwgPSBjcmVhdGVWYWxpZGF0ZVVybChydGNVcmwpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XHJcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCAoc2lnbmFsKScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB3c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIHRpbWVkIG91dCAoc2lnbmFsKScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSkpO1xyXG4gICAgICAgIH0sIG9wdHMud2Vic29ja2V0VGltZW91dCk7XHJcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICBhYm9ydEhhbmRsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICBjb25zdCByZWRhY3RlZFVybCA9IG5ldyBVUkwocnRjVXJsKTtcclxuICAgICAgICBpZiAocmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLmhhcygnYWNjZXNzX3Rva2VuJykpIHtcclxuICAgICAgICAgIHJlZGFjdGVkVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FjY2Vzc190b2tlbicsICc8cmVkYWN0ZWQ+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGluZyB0byBcIi5jb25jYXQocmVkYWN0ZWRVcmwpLCBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICAgIHJlY29ubmVjdDogb3B0cy5yZWNvbm5lY3QsXHJcbiAgICAgICAgICByZWNvbm5lY3RSZWFzb246IG9wdHMucmVjb25uZWN0UmVhc29uXHJcbiAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XHJcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChydGNVcmwpO1xyXG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IGV2ID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCByZXNwID0geWllbGQgZmV0Y2godmFsaWRhdGVVcmwpO1xyXG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1cy50b0ZpeGVkKDApLnN0YXJ0c1dpdGgoJzQnKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihtc2csIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkLCByZXNwLnN0YXR1cykpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihcIkVuY291bnRlcmVkIHVua25vd24gd2Vic29ja2V0IGVycm9yIGR1cmluZyBjb25uZWN0aW9uOiBcIi5jb25jYXQoZXYudG9TdHJpbmcoKSksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yLCByZXNwLnN0YXR1cykpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdzZXJ2ZXIgd2FzIG5vdCByZWFjaGFibGUnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMsIGhhbmRsZVxyXG4gICAgICAgICAgdGhpcy5oYW5kbGVXU0Vycm9yKGV2KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGV2ID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgICAgLy8gbm90IGNvbnNpZGVyZWQgY29ubmVjdGVkIHVudGlsIEpvaW5SZXNwb25zZSBpcyByZWNlaXZlZFxyXG4gICAgICAgICAgbGV0IHJlc3A7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGV2LmRhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xyXG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUpzb24oanNvbiwge1xyXG4gICAgICAgICAgICAgIGlnbm9yZVVua25vd25GaWVsZHM6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShldi5kYXRhKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcihcImNvdWxkIG5vdCBkZWNvZGUgd2Vic29ja2V0IG1lc3NhZ2U6IFwiLmNvbmNhdCh0eXBlb2YgZXYuZGF0YSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICAgIGxldCBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgam9pbiBtZXNzYWdlIG9ubHlcclxuICAgICAgICAgICAgaWYgKCgoX2EgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYXNlKSA9PT0gJ2pvaW4nKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XHJcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ1RpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGluZyBjb25maWcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5waW5nVGltZW91dER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFBpbmdJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORyAmJiByZXNwLm1lc3NhZ2UuY2FzZSAhPT0gJ2xlYXZlJykge1xyXG4gICAgICAgICAgICAgIC8vIGluIHJlY29ubmVjdGluZywgYW55IG1lc3NhZ2UgcmVjZWl2ZWQgbWVhbnMgc2lnbmFsIHJlY29ubmVjdGVkXHJcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XHJcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0UGluZ0ludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3JlY29ubmVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlY2xhcmluZyBzaWduYWwgcmVjb25uZWN0ZWQgd2l0aG91dCByZWNvbm5lY3QgcmVzcG9uc2UgcmVjZWl2ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiAmJiByZXNwLm1lc3NhZ2UuY2FzZSA9PT0gJ2xlYXZlJykge1xyXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdSZWNlaXZlZCBsZWF2ZSByZXF1ZXN0IHdoaWxlIHRyeWluZyB0byAocmUpY29ubmVjdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QsIHVuZGVmaW5lZCwgcmVzcC5tZXNzYWdlLnZhbHVlLnJlYXNvbikpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnJlY29ubmVjdCkge1xyXG4gICAgICAgICAgICAgIC8vIG5vbi1yZWNvbm5lY3QgY2FzZSwgc2hvdWxkIHJlY2VpdmUgam9pbiByZXNwb25zZSBmaXJzdFxyXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKFwiZGlkIG5vdCByZWNlaXZlIGpvaW4gcmVzcG9uc2UsIGdvdCBcIi5jb25jYXQoKF9jID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FzZSwgXCIgaW5zdGVhZFwiKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXNob3VsZFByb2Nlc3NNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5zaWduYWxMYXRlbmN5KSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKHRoaXMuc2lnbmFsTGF0ZW5jeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlc3ApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IGV2ID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignV2Vic29ja2V0IGdvdCBjbG9zZWQgZHVyaW5nIGEgKHJlKWNvbm5lY3Rpb24gYXR0ZW1wdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwid2Vic29ja2V0IGNsb3NlZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgcmVhc29uOiBldi5yZWFzb24sXHJcbiAgICAgICAgICAgIGNvZGU6IGV2LmNvZGUsXHJcbiAgICAgICAgICAgIHdhc0NsZWFuOiBldi53YXNDbGVhbixcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIHRoaXMuaGFuZGxlT25DbG9zZShldi5yZWFzb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9XHJcbiAgY2xvc2UoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIGxldCB1cGRhdGVTdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgX3RoaXMuY2xvc2luZ0xvY2subG9jaygpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBfdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoX3RoaXMud3MpIHtcclxuICAgICAgICAgICAgX3RoaXMud3Mub25tZXNzYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMud3Mub25vcGVuID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMud3Mub25jbG9zZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYHdzLmNsb3NlKClgIG9ubHkgc3RhcnRzIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSAoQ0xPU0lORyBzdGF0ZSksIHByZWZlciB0byB3YWl0IHVudGlsIHN0YXRlIGlzIGFjdHVhbGx5IENMT1NFRFxyXG4gICAgICAgICAgICBjb25zdCBjbG9zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICBpZiAoX3RoaXMud3MpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLndzLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMud3MucmVhZHlTdGF0ZSA8IF90aGlzLndzLkNMT1NJTkcpIHtcclxuICAgICAgICAgICAgICBfdGhpcy53cy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgIC8vIDI1MG1zIGdyYWNlIHBlcmlvZCBmb3Igd3MgdG8gY2xvc2UgZ3JhY2VmdWxseVxyXG4gICAgICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbY2xvc2VQcm9taXNlLCBzbGVlcCgyNTApXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMud3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB1bmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBpbml0aWFsIG9mZmVyIGFmdGVyIGpvaW5pbmdcclxuICBzZW5kT2ZmZXIob2ZmZXIpIHtcclxuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIG9mZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIG9mZmVyU2RwOiBvZmZlci5zZHBcclxuICAgIH0pKTtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnb2ZmZXInLFxyXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlcilcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBhbnN3ZXIgYSBzZXJ2ZXItaW5pdGlhdGVkIG9mZmVyXHJcbiAgc2VuZEFuc3dlcihhbnN3ZXIpIHtcclxuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICBhbnN3ZXJTZHA6IGFuc3dlci5zZHBcclxuICAgIH0pKTtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ2Fuc3dlcicsXHJcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKGFuc3dlcilcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XHJcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBpY2UgY2FuZGlkYXRlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIGNhbmRpZGF0ZVxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAndHJpY2tsZScsXHJcbiAgICAgIHZhbHVlOiBuZXcgVHJpY2tsZVJlcXVlc3Qoe1xyXG4gICAgICAgIGNhbmRpZGF0ZUluaXQ6IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSksXHJcbiAgICAgICAgdGFyZ2V0XHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ211dGUnLFxyXG4gICAgICB2YWx1ZTogbmV3IE11dGVUcmFja1JlcXVlc3Qoe1xyXG4gICAgICAgIHNpZDogdHJhY2tTaWQsXHJcbiAgICAgICAgbXV0ZWRcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kQWRkVHJhY2socmVxKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICdhZGRUcmFjaycsXHJcbiAgICAgIHZhbHVlOiByZXFcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShtZXRhZGF0YV8xLCBuYW1lXzEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChtZXRhZGF0YSwgbmFtZSkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBfdGhpczIuZ2V0TmV4dFJlcXVlc3RJZCgpO1xyXG4gICAgICAgIHlpZWxkIF90aGlzMi5zZW5kUmVxdWVzdCh7XHJcbiAgICAgICAgICBjYXNlOiAndXBkYXRlTWV0YWRhdGEnLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcclxuICAgICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgICBtZXRhZGF0YSxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYXR0cmlidXRlc1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdElkO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpIHtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAndHJhY2tTZXR0aW5nJyxcclxuICAgICAgdmFsdWU6IHNldHRpbmdzXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvbicsXHJcbiAgICAgIHZhbHVlOiBzdWJcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kU3luY1N0YXRlKHN5bmMpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3N5bmNTdGF0ZScsXHJcbiAgICAgIHZhbHVlOiBzeW5jXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFVwZGF0ZVZpZGVvTGF5ZXJzKHRyYWNrU2lkLCBsYXllcnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3VwZGF0ZUxheWVycycsXHJcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoe1xyXG4gICAgICAgIHRyYWNrU2lkLFxyXG4gICAgICAgIGxheWVyc1xyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHMsIHRyYWNrUGVybWlzc2lvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvblBlcm1pc3Npb24nLFxyXG4gICAgICB2YWx1ZTogbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oe1xyXG4gICAgICAgIGFsbFBhcnRpY2lwYW50cyxcclxuICAgICAgICB0cmFja1Blcm1pc3Npb25zXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8pIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3NpbXVsYXRlJyxcclxuICAgICAgdmFsdWU6IHNjZW5hcmlvXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFBpbmcoKSB7XHJcbiAgICAvKiogc2VuZCBib3RoIG9mIHBpbmcgYW5kIHBpbmdSZXEgZm9yIGNvbXBhdGliaWxpdHkgdG8gb2xkIGFuZCBuZXcgc2VydmVyICovXHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAncGluZycsXHJcbiAgICAgIHZhbHVlOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXHJcbiAgICB9KSwgdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICdwaW5nUmVxJyxcclxuICAgICAgdmFsdWU6IG5ldyBQaW5nKHtcclxuICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXHJcbiAgICAgICAgcnR0OiBwcm90b0ludDY0LnBhcnNlKHRoaXMucnR0KVxyXG4gICAgICB9KVxyXG4gICAgfSldKTtcclxuICB9XHJcbiAgc2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh0cmFja1NpZCwgZmVhdHVyZXMpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3VwZGF0ZUF1ZGlvVHJhY2snLFxyXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayh7XHJcbiAgICAgICAgdHJhY2tTaWQsXHJcbiAgICAgICAgZmVhdHVyZXNcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kTGVhdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICdsZWF2ZScsXHJcbiAgICAgIHZhbHVlOiBuZXcgTGVhdmVSZXF1ZXN0KHtcclxuICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCxcclxuICAgICAgICAvLyBzZXJ2ZXIgZG9lc24ndCBwcm9jZXNzIHRoaXMgZmllbGQsIGtlZXBpbmcgaXQgaGVyZSB0byBpbmRpY2F0ZSB0aGUgaW50ZW50IG9mIGEgZnVsbCBkaXNjb25uZWN0XHJcbiAgICAgICAgYWN0aW9uOiBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1RcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kUmVxdWVzdChtZXNzYWdlXzEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG4gICAgICBsZXQgZnJvbVF1ZXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgLy8gY2FwdHVyZSBhbGwgcmVxdWVzdHMgd2hpbGUgcmVjb25uZWN0aW5nIGFuZCBwdXQgdGhlbSBpbiBhIHF1ZXVlXHJcbiAgICAgICAgLy8gdW5sZXNzIHRoZSByZXF1ZXN0IG9yaWdpbmF0ZXMgZnJvbSB0aGUgcXVldWUsIHRoZW4gZG9uJ3QgZW5xdWV1ZSBhZ2FpblxyXG4gICAgICAgIGNvbnN0IGNhblF1ZXVlID0gIWZyb21RdWV1ZSAmJiAhY2FuUGFzc1Rocm91Z2hRdWV1ZShtZXNzYWdlKTtcclxuICAgICAgICBpZiAoY2FuUXVldWUgJiYgX3RoaXMzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XHJcbiAgICAgICAgICBfdGhpczMucXVldWVkUmVxdWVzdHMucHVzaCgoKSA9PiBfX2F3YWl0ZXIoX3RoaXMzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5zZW5kUmVxdWVzdChtZXNzYWdlLCB0cnVlKTtcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHByZXZpb3VzbHkgcXVldWVkIHJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGZpcnN0XHJcbiAgICAgICAgaWYgKCFmcm9tUXVldWUpIHtcclxuICAgICAgICAgIHlpZWxkIF90aGlzMy5yZXF1ZXN0UXVldWUuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzMy5zaWduYWxMYXRlbmN5KSB7XHJcbiAgICAgICAgICB5aWVsZCBzbGVlcChfdGhpczMuc2lnbmFsTGF0ZW5jeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghX3RoaXMzLndzIHx8IF90aGlzMy53cy5yZWFkeVN0YXRlICE9PSBfdGhpczMud3MuT1BFTikge1xyXG4gICAgICAgICAgX3RoaXMzLmxvZy5lcnJvcihcImNhbm5vdCBzZW5kIHNpZ25hbCByZXF1ZXN0IGJlZm9yZSBjb25uZWN0ZWQsIHR5cGU6IFwiLmNvbmNhdChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UuY2FzZSksIF90aGlzMy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxID0gbmV3IFNpZ25hbFJlcXVlc3Qoe1xyXG4gICAgICAgICAgbWVzc2FnZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoX3RoaXMzLnVzZUpTT04pIHtcclxuICAgICAgICAgICAgX3RoaXMzLndzLnNlbmQocmVxLnRvSnNvblN0cmluZygpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGlzMy53cy5zZW5kKHJlcS50b0JpbmFyeSgpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBfdGhpczMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHNpZ25hbCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBoYW5kbGVTaWduYWxSZXNwb25zZShyZXMpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBjb25zdCBtc2cgPSByZXMubWVzc2FnZTtcclxuICAgIGlmIChtc2cgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnN1cHBvcnRlZCBtZXNzYWdlJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHBpbmdIYW5kbGVkID0gZmFsc2U7XHJcbiAgICBpZiAobXNnLmNhc2UgPT09ICdhbnN3ZXInKSB7XHJcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XHJcbiAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XHJcbiAgICAgICAgdGhpcy5vbkFuc3dlcihzZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdvZmZlcicpIHtcclxuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcclxuICAgICAgaWYgKHRoaXMub25PZmZlcikge1xyXG4gICAgICAgIHRoaXMub25PZmZlcihzZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmlja2xlJykge1xyXG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcclxuICAgICAgaWYgKHRoaXMub25Ucmlja2xlKSB7XHJcbiAgICAgICAgdGhpcy5vblRyaWNrbGUoY2FuZGlkYXRlLCBtc2cudmFsdWUudGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3VwZGF0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSkge1xyXG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1B1Ymxpc2hlZCcpIHtcclxuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XHJcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcclxuICAgICAgaWYgKHRoaXMub25TcGVha2Vyc0NoYW5nZWQpIHtcclxuICAgICAgICB0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKChfYiA9IG1zZy52YWx1ZS5zcGVha2VycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbGVhdmUnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uTGVhdmUpIHtcclxuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ211dGUnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcclxuICAgICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQobXNnLnZhbHVlLnNpZCwgbXNnLnZhbHVlLm11dGVkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uUm9vbVVwZGF0ZSAmJiBtc2cudmFsdWUucm9vbSkge1xyXG4gICAgICAgIHRoaXMub25Sb29tVXBkYXRlKG1zZy52YWx1ZS5yb29tKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2Nvbm5lY3Rpb25RdWFsaXR5Jykge1xyXG4gICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdHJlYW1TdGF0ZVVwZGF0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xyXG4gICAgICAgIHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZShtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpIHtcclxuICAgICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkge1xyXG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZWZyZXNoVG9rZW4nKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XHJcbiAgICAgICAgdGhpcy5vblRva2VuUmVmcmVzaChtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcclxuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpIHtcclxuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25SZXNwb25zZScpIHtcclxuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25FcnJvcikge1xyXG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncG9uZycpIDsgZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nUmVzcCcpIHtcclxuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcclxuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XHJcbiAgICAgIHBpbmdIYW5kbGVkID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZXF1ZXN0UmVzcG9uc2UnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5vblJlcXVlc3RSZXNwb25zZShtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tTdWJzY3JpYmVkJykge1xyXG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKSB7XHJcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKG1zZy52YWx1ZS50cmFja1NpZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyb29tTW92ZWQnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XHJcbiAgICAgICAgdGhpcy5vblRva2VuUmVmcmVzaChtc2cudmFsdWUudG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm9uUm9vbU1vdmVkKSB7XHJcbiAgICAgICAgdGhpcy5vblJvb21Nb3ZlZChtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5zdXBwb3J0ZWQgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIG1zZ0Nhc2U6IG1zZy5jYXNlXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGlmICghcGluZ0hhbmRsZWQpIHtcclxuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHNldFJlY29ubmVjdGVkKCkge1xyXG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCByZXEgPSB0aGlzLnF1ZXVlZFJlcXVlc3RzLnNoaWZ0KCk7XHJcbiAgICAgIGlmIChyZXEpIHtcclxuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBoYW5kbGVPbkNsb3NlKHJlYXNvbikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpIHJldHVybjtcclxuICAgICAgY29uc3Qgb25DbG9zZUNhbGxiYWNrID0gdGhpcy5vbkNsb3NlO1xyXG4gICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkOiBcIi5jb25jYXQocmVhc29uKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgcmVhc29uXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKG9uQ2xvc2VDYWxsYmFjaykge1xyXG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaGFuZGxlV1NFcnJvcihldikge1xyXG4gICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICBlcnJvcjogZXZcclxuICAgIH0pKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHRoZSBwaW5nIHRpbWVvdXQgYW5kIHN0YXJ0cyBhIG5ldyB0aW1lb3V0LlxyXG4gICAqIENhbGwgdGhpcyBhZnRlciByZWNlaXZpbmcgYSBwb25nIG1lc3NhZ2VcclxuICAgKi9cclxuICByZXNldFBpbmdUaW1lb3V0KCkge1xyXG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XHJcbiAgICBpZiAoIXRoaXMucGluZ1RpbWVvdXREdXJhdGlvbikge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIHRpbWVvdXQgZHVyYXRpb24gbm90IHNldCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMucGluZ1RpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5sb2cud2FybihcInBpbmcgdGltZW91dCB0cmlnZ2VyZWQuIGxhc3QgcG9uZyByZWNlaXZlZCBhdDogXCIuY29uY2F0KG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKS50b1VUQ1N0cmluZygpKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcclxuICAgIH0sIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDbGVhcnMgcGluZyB0aW1lb3V0IChkb2VzIG5vdCBzdGFydCBhIG5ldyB0aW1lb3V0KVxyXG4gICAqL1xyXG4gIGNsZWFyUGluZ1RpbWVvdXQoKSB7XHJcbiAgICBpZiAodGhpcy5waW5nVGltZW91dCkge1xyXG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0YXJ0UGluZ0ludGVydmFsKCkge1xyXG4gICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xyXG4gICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XHJcbiAgICBpZiAoIXRoaXMucGluZ0ludGVydmFsRHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5sb2cud2FybigncGluZyBpbnRlcnZhbCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0IHBpbmcgaW50ZXJ2YWwnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2VuZFBpbmcoKTtcclxuICAgIH0sIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gKiAxMDAwKTtcclxuICB9XHJcbiAgY2xlYXJQaW5nSW50ZXJ2YWwoKSB7XHJcbiAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcclxuICAgIGlmICh0aGlzLnBpbmdJbnRlcnZhbCkge1xyXG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHNkKSB7XHJcbiAgY29uc3QgcnNkID0ge1xyXG4gICAgdHlwZTogJ29mZmVyJyxcclxuICAgIHNkcDogc2Quc2RwXHJcbiAgfTtcclxuICBzd2l0Y2ggKHNkLnR5cGUpIHtcclxuICAgIGNhc2UgJ2Fuc3dlcic6XHJcbiAgICBjYXNlICdvZmZlcic6XHJcbiAgICBjYXNlICdwcmFuc3dlcic6XHJcbiAgICBjYXNlICdyb2xsYmFjayc6XHJcbiAgICAgIHJzZC50eXBlID0gc2QudHlwZTtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiByc2Q7XHJcbn1cclxuZnVuY3Rpb24gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihyc2QpIHtcclxuICBjb25zdCBzZCA9IG5ldyBTZXNzaW9uRGVzY3JpcHRpb24oe1xyXG4gICAgc2RwOiByc2Quc2RwLFxyXG4gICAgdHlwZTogcnNkLnR5cGVcclxuICB9KTtcclxuICByZXR1cm4gc2Q7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgaW5mbywgb3B0cykge1xyXG4gIHZhciBfYTtcclxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgcGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgdG9rZW4pO1xyXG4gIC8vIG9wdHNcclxuICBpZiAob3B0cy5yZWNvbm5lY3QpIHtcclxuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdCcsICcxJyk7XHJcbiAgICBpZiAob3B0cy5zaWQpIHtcclxuICAgICAgcGFyYW1zLnNldCgnc2lkJywgb3B0cy5zaWQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBwYXJhbXMuc2V0KCdhdXRvX3N1YnNjcmliZScsIG9wdHMuYXV0b1N1YnNjcmliZSA/ICcxJyA6ICcwJyk7XHJcbiAgLy8gQ2xpZW50SW5mb1xyXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcclxuICBwYXJhbXMuc2V0KCd2ZXJzaW9uJywgaW5mby52ZXJzaW9uKTtcclxuICBwYXJhbXMuc2V0KCdwcm90b2NvbCcsIGluZm8ucHJvdG9jb2wudG9TdHJpbmcoKSk7XHJcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcclxuICAgIHBhcmFtcy5zZXQoJ2RldmljZV9tb2RlbCcsIGluZm8uZGV2aWNlTW9kZWwpO1xyXG4gIH1cclxuICBpZiAoaW5mby5vcykge1xyXG4gICAgcGFyYW1zLnNldCgnb3MnLCBpbmZvLm9zKTtcclxuICB9XHJcbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XHJcbiAgICBwYXJhbXMuc2V0KCdvc192ZXJzaW9uJywgaW5mby5vc1ZlcnNpb24pO1xyXG4gIH1cclxuICBpZiAoaW5mby5icm93c2VyKSB7XHJcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyJywgaW5mby5icm93c2VyKTtcclxuICB9XHJcbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcclxuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXJfdmVyc2lvbicsIGluZm8uYnJvd3NlclZlcnNpb24pO1xyXG4gIH1cclxuICBpZiAob3B0cy5hZGFwdGl2ZVN0cmVhbSkge1xyXG4gICAgcGFyYW1zLnNldCgnYWRhcHRpdmVfc3RyZWFtJywgJzEnKTtcclxuICB9XHJcbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XHJcbiAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3RfcmVhc29uJywgb3B0cy5yZWNvbm5lY3RSZWFzb24udG9TdHJpbmcoKSk7XHJcbiAgfVxyXG4gIC8vIEB0cy1pZ25vcmVcclxuICBpZiAoKF9hID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBwYXJhbXMuc2V0KCduZXR3b3JrJywgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSk7XHJcbiAgfVxyXG4gIHJldHVybiBwYXJhbXM7XHJcbn1cclxuXHJcbmNsYXNzIERhdGFQYWNrZXRCdWZmZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5idWZmZXIgPSBbXTtcclxuICAgIHRoaXMuX3RvdGFsU2l6ZSA9IDA7XHJcbiAgfVxyXG4gIHB1c2goaXRlbSkge1xyXG4gICAgdGhpcy5idWZmZXIucHVzaChpdGVtKTtcclxuICAgIHRoaXMuX3RvdGFsU2l6ZSArPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcclxuICB9XHJcbiAgcG9wKCkge1xyXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuYnVmZmVyLnNoaWZ0KCk7XHJcbiAgICBpZiAoaXRlbSkge1xyXG4gICAgICB0aGlzLl90b3RhbFNpemUgLT0gaXRlbS5kYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXRlbTtcclxuICB9XHJcbiAgZ2V0QWxsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKCk7XHJcbiAgfVxyXG4gIHBvcFRvU2VxdWVuY2Uoc2VxdWVuY2UpIHtcclxuICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5idWZmZXJbMF07XHJcbiAgICAgIGlmIChmaXJzdC5zZXF1ZW5jZSA8PSBzZXF1ZW5jZSkge1xyXG4gICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgYWxpZ25CdWZmZXJlZEFtb3VudChidWZmZXJlZEFtb3VudCkge1xyXG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcclxuICAgICAgaWYgKHRoaXMuX3RvdGFsU2l6ZSAtIGZpcnN0LmRhdGEuYnl0ZUxlbmd0aCA8PSBidWZmZXJlZEFtb3VudCkge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucG9wKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldCBsZW5ndGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgVFRMTWFwIHtcclxuICAvKipcclxuICAgKiBAcGFyYW0gdHRsIHR0bCBvZiB0aGUga2V5IChtcylcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0dGwpIHtcclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2xhc3RDbGVhbnVwID0gMDtcclxuICAgIHRoaXMudHRsID0gdHRsO1xyXG4gIH1cclxuICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGlmIChub3cgLSB0aGlzLl9sYXN0Q2xlYW51cCA+IHRoaXMudHRsIC8gMikge1xyXG4gICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5vdyArIHRoaXMudHRsO1xyXG4gICAgdGhpcy5fbWFwLnNldChrZXksIHtcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIGV4cGlyZXNBdFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgZ2V0KGtleSkge1xyXG4gICAgY29uc3QgZW50cnkgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XHJcbiAgICBpZiAoIWVudHJ5KSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgaWYgKGVudHJ5LmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHtcclxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xyXG4gIH1cclxuICBoYXMoa2V5KSB7XHJcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcclxuICAgIGlmICghZW50cnkpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPCBEYXRlLm5vdygpKSB7XHJcbiAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGRlbGV0ZShrZXkpIHtcclxuICAgIHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgfVxyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XHJcbiAgfVxyXG4gIGNsZWFudXAoKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5fbWFwLmVudHJpZXMoKSkge1xyXG4gICAgICBpZiAoZW50cnkuZXhwaXJlc0F0IDwgbm93KSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9sYXN0Q2xlYW51cCA9IG5vdztcclxuICB9XHJcbiAgZ2V0IHNpemUoKSB7XHJcbiAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcclxuICB9XHJcbiAgZm9yRWFjaChjYWxsYmFjaykge1xyXG4gICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XHJcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPj0gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIGNhbGxiYWNrKGVudHJ5LnZhbHVlLCBrZXksIHRoaXMuYXNWYWx1ZU1hcCgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBtYXAoY2FsbGJhY2spIHtcclxuICAgIHRoaXMuY2xlYW51cCgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCB2YWx1ZU1hcCA9IHRoaXMuYXNWYWx1ZU1hcCgpO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdmFsdWVNYXAuZW50cmllcygpKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKHZhbHVlLCBrZXksIHZhbHVlTWFwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBhc1ZhbHVlTWFwKCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5fbWFwLmVudHJpZXMoKSkge1xyXG4gICAgICBpZiAoZW50cnkuZXhwaXJlc0F0ID49IERhdGUubm93KCkpIHtcclxuICAgICAgICByZXN1bHQuc2V0KGtleSwgZW50cnkudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG5cclxudmFyIGxpYiA9IHt9O1xyXG5cclxudmFyIHBhcnNlciA9IHt9O1xyXG5cclxudmFyIGdyYW1tYXIgPSB7ZXhwb3J0czoge319O1xyXG5cclxudmFyIGhhc1JlcXVpcmVkR3JhbW1hcjtcclxuZnVuY3Rpb24gcmVxdWlyZUdyYW1tYXIoKSB7XHJcbiAgaWYgKGhhc1JlcXVpcmVkR3JhbW1hcikgcmV0dXJuIGdyYW1tYXIuZXhwb3J0cztcclxuICBoYXNSZXF1aXJlZEdyYW1tYXIgPSAxO1xyXG4gIHZhciBncmFtbWFyJDEgPSBncmFtbWFyLmV4cG9ydHMgPSB7XHJcbiAgICB2OiBbe1xyXG4gICAgICBuYW1lOiAndmVyc2lvbicsXHJcbiAgICAgIHJlZzogL14oXFxkKikkL1xyXG4gICAgfV0sXHJcbiAgICBvOiBbe1xyXG4gICAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcclxuICAgICAgLy8gTkI6IHNlc3Npb25JZCB3aWxsIGJlIGEgU3RyaW5nIGluIG1vc3QgY2FzZXMgYmVjYXVzZSBpdCBpcyBodWdlXHJcbiAgICAgIG5hbWU6ICdvcmlnaW4nLFxyXG4gICAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcclxuICAgICAgbmFtZXM6IFsndXNlcm5hbWUnLCAnc2Vzc2lvbklkJywgJ3Nlc3Npb25WZXJzaW9uJywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxyXG4gICAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xyXG4gICAgfV0sXHJcbiAgICAvLyBkZWZhdWx0IHBhcnNpbmcgb2YgdGhlc2Ugb25seSAodGhvdWdoIHNvbWUgb2YgdGhlc2UgZmVlbCBvdXRkYXRlZClcclxuICAgIHM6IFt7XHJcbiAgICAgIG5hbWU6ICduYW1lJ1xyXG4gICAgfV0sXHJcbiAgICBpOiBbe1xyXG4gICAgICBuYW1lOiAnZGVzY3JpcHRpb24nXHJcbiAgICB9XSxcclxuICAgIHU6IFt7XHJcbiAgICAgIG5hbWU6ICd1cmknXHJcbiAgICB9XSxcclxuICAgIGU6IFt7XHJcbiAgICAgIG5hbWU6ICdlbWFpbCdcclxuICAgIH1dLFxyXG4gICAgcDogW3tcclxuICAgICAgbmFtZTogJ3Bob25lJ1xyXG4gICAgfV0sXHJcbiAgICB6OiBbe1xyXG4gICAgICBuYW1lOiAndGltZXpvbmVzJ1xyXG4gICAgfV0sXHJcbiAgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXHJcbiAgICByOiBbe1xyXG4gICAgICBuYW1lOiAncmVwZWF0cydcclxuICAgIH1dLFxyXG4gICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XHJcbiAgICAvLyBrOiBbe31dLCAvLyBvdXRkYXRlZCB0aGluZyBpZ25vcmVkXHJcbiAgICB0OiBbe1xyXG4gICAgICAvLyB0PTAgMFxyXG4gICAgICBuYW1lOiAndGltaW5nJyxcclxuICAgICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxyXG4gICAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXHJcbiAgICAgIGZvcm1hdDogJyVkICVkJ1xyXG4gICAgfV0sXHJcbiAgICBjOiBbe1xyXG4gICAgICAvLyBjPUlOIElQNCAxMC40Ny4xOTcuMjZcclxuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxyXG4gICAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxyXG4gICAgICBuYW1lczogWyd2ZXJzaW9uJywgJ2lwJ10sXHJcbiAgICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXHJcbiAgICB9XSxcclxuICAgIGI6IFt7XHJcbiAgICAgIC8vIGI9QVM6NDAwMFxyXG4gICAgICBwdXNoOiAnYmFuZHdpZHRoJyxcclxuICAgICAgcmVnOiAvXihUSUFTfEFTfENUfFJSfFJTKTooXFxkKikvLFxyXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXHJcbiAgICAgIGZvcm1hdDogJyVzOiVzJ1xyXG4gICAgfV0sXHJcbiAgICBtOiBbe1xyXG4gICAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXHJcbiAgICAgIC8vIE5COiBzcGVjaWFsIC0gcHVzaGVzIHRvIHNlc3Npb25cclxuICAgICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xyXG4gICAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcclxuICAgICAgbmFtZXM6IFsndHlwZScsICdwb3J0JywgJ3Byb3RvY29sJywgJ3BheWxvYWRzJ10sXHJcbiAgICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xyXG4gICAgfV0sXHJcbiAgICBhOiBbe1xyXG4gICAgICAvLyBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXHJcbiAgICAgIHB1c2g6ICdydHAnLFxyXG4gICAgICByZWc6IC9ecnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vLFxyXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvZGVjJywgJ3JhdGUnLCAnZW5jb2RpbmcnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvLmVuY29kaW5nID8gJ3J0cG1hcDolZCAlcy8lcy8lcycgOiBvLnJhdGUgPyAncnRwbWFwOiVkICVzLyVzJyA6ICdydHBtYXA6JWQgJXMnO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxyXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxyXG4gICAgICBwdXNoOiAnZm10cCcsXHJcbiAgICAgIHJlZzogL15mbXRwOihcXGQqKSAoW1xcU3wgXSopLyxcclxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcclxuICAgICAgZm9ybWF0OiAnZm10cDolZCAlcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1jb250cm9sOnN0cmVhbWlkPTBcclxuICAgICAgbmFtZTogJ2NvbnRyb2wnLFxyXG4gICAgICByZWc6IC9eY29udHJvbDooLiopLyxcclxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1ydGNwOjY1MTc5IElOIElQNCAxOTMuODQuNzcuMTk0XHJcbiAgICAgIG5hbWU6ICdydGNwJyxcclxuICAgICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcclxuICAgICAgbmFtZXM6IFsncG9ydCcsICduZXRUeXBlJywgJ2lwVmVyJywgJ2FkZHJlc3MnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvLmFkZHJlc3MgIT0gbnVsbCA/ICdydGNwOiVkICVzIElQJWQgJXMnIDogJ3J0Y3A6JWQnO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCB0cnItaW50IDEwMFxyXG4gICAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcclxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndmFsdWUnXSxcclxuICAgICAgZm9ybWF0OiAncnRjcC1mYjolcyB0cnItaW50ICVkJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXHJcbiAgICAgIHB1c2g6ICdydGNwRmInLFxyXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIChbXFx3LV9dKikoPzogKFtcXHctX10qKSk/LyxcclxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd0eXBlJywgJ3N1YnR5cGUnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvLnN1YnR5cGUgIT0gbnVsbCA/ICdydGNwLWZiOiVzICVzICVzJyA6ICdydGNwLWZiOiVzICVzJztcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcclxuICAgICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xyXG4gICAgICAvLyBhPWV4dG1hcDozIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6c21wdGUtdGMgMjVANjAwLzI0XHJcbiAgICAgIHB1c2g6ICdleHQnLFxyXG4gICAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJywgJ2RpcmVjdGlvbicsICdlbmNyeXB0LXVyaScsICd1cmknLCAnY29uZmlnJ10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gJ2V4dG1hcDolZCcgKyAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICsgKG9bJ2VuY3J5cHQtdXJpJ10gPyAnICVzJyA6ICcldicpICsgJyAlcycgKyAoby5jb25maWcgPyAnICVzJyA6ICcnKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWV4dG1hcC1hbGxvdy1taXhlZFxyXG4gICAgICBuYW1lOiAnZXh0bWFwQWxsb3dNaXhlZCcsXHJcbiAgICAgIHJlZzogL14oZXh0bWFwLWFsbG93LW1peGVkKS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1jcnlwdG86MSBBRVNfQ01fMTI4X0hNQUNfU0hBMV84MCBpbmxpbmU6UFMxdVFDVmVlQ0ZDYW5WbWNqa3BQeXdqTldoY1lEMG1YWHR4YVZCUnwyXjIwfDE6MzJcclxuICAgICAgcHVzaDogJ2NyeXB0bycsXHJcbiAgICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxyXG4gICAgICBuYW1lczogWydpZCcsICdzdWl0ZScsICdjb25maWcnLCAnc2Vzc2lvbkNvbmZpZyddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8uc2Vzc2lvbkNvbmZpZyAhPSBudWxsID8gJ2NyeXB0bzolZCAlcyAlcyAlcycgOiAnY3J5cHRvOiVkICVzICVzJztcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXNldHVwOmFjdHBhc3NcclxuICAgICAgbmFtZTogJ3NldHVwJyxcclxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXHJcbiAgICAgIGZvcm1hdDogJ3NldHVwOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWNvbm5lY3Rpb246bmV3XHJcbiAgICAgIG5hbWU6ICdjb25uZWN0aW9uVHlwZScsXHJcbiAgICAgIHJlZzogL15jb25uZWN0aW9uOihuZXd8ZXhpc3RpbmcpLyxcclxuICAgICAgZm9ybWF0OiAnY29ubmVjdGlvbjolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1taWQ6MVxyXG4gICAgICBuYW1lOiAnbWlkJyxcclxuICAgICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxyXG4gICAgICBmb3JtYXQ6ICdtaWQ6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9bXNpZDowYzhiMDY0ZC1kODA3LTQzYjQtYjQzNC1mOTJhODg5ZDg1ODcgOTgxNzg2ODUtZDQwOS00NmUwLThlMTYtN2VmMGRiMGRiNjRhXHJcbiAgICAgIG5hbWU6ICdtc2lkJyxcclxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXHJcbiAgICAgIGZvcm1hdDogJ21zaWQ6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9cHRpbWU6MjBcclxuICAgICAgbmFtZTogJ3B0aW1lJyxcclxuICAgICAgcmVnOiAvXnB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXHJcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPW1heHB0aW1lOjYwXHJcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXHJcbiAgICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxyXG4gICAgICBmb3JtYXQ6ICdtYXhwdGltZTolZCdcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1zZW5kcmVjdlxyXG4gICAgICBuYW1lOiAnZGlyZWN0aW9uJyxcclxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9aWNlLWxpdGVcclxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxyXG4gICAgICByZWc6IC9eKGljZS1saXRlKS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxyXG4gICAgICBuYW1lOiAnaWNlVWZyYWcnLFxyXG4gICAgICByZWc6IC9eaWNlLXVmcmFnOihcXFMqKS8sXHJcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1pY2UtcHdkOng5Y21sL1l6aWNoVjIrWGxoaU11OGdcclxuICAgICAgbmFtZTogJ2ljZVB3ZCcsXHJcbiAgICAgIHJlZzogL15pY2UtcHdkOihcXFMqKS8sXHJcbiAgICAgIGZvcm1hdDogJ2ljZS1wd2Q6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9ZmluZ2VycHJpbnQ6U0hBLTEgMDA6MTE6MjI6MzM6NDQ6NTU6NjY6Nzc6ODg6OTk6QUE6QkI6Q0M6REQ6RUU6RkY6MDA6MTE6MjI6MzNcclxuICAgICAgbmFtZTogJ2ZpbmdlcnByaW50JyxcclxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxyXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2hhc2gnXSxcclxuICAgICAgZm9ybWF0OiAnZmluZ2VycHJpbnQ6JXMgJXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxyXG4gICAgICAvLyBhPWNhbmRpZGF0ZToxMTYyODc1MDgxIDEgdWRwIDIxMTM5MzcxNTEgMTkyLjE2OC4zNC43NSA2MDAxNyB0eXAgaG9zdCBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxyXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxyXG4gICAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxyXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdGNwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyB0Y3B0eXBlIHBhc3NpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcclxuICAgICAgcHVzaDogJ2NhbmRpZGF0ZXMnLFxyXG4gICAgICByZWc6IC9eY2FuZGlkYXRlOihcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIHR5cCAoXFxTKikoPzogcmFkZHIgKFxcUyopIHJwb3J0IChcXGQqKSk/KD86IHRjcHR5cGUgKFxcUyopKT8oPzogZ2VuZXJhdGlvbiAoXFxkKikpPyg/OiBuZXR3b3JrLWlkIChcXGQqKSk/KD86IG5ldHdvcmstY29zdCAoXFxkKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgc3RyID0gJ2NhbmRpZGF0ZTolcyAlZCAlcyAlZCAlcyAlZCB0eXAgJXMnO1xyXG4gICAgICAgIHN0ciArPSBvLnJhZGRyICE9IG51bGwgPyAnIHJhZGRyICVzIHJwb3J0ICVkJyA6ICcldiV2JztcclxuXHJcbiAgICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcclxuICAgICAgICBzdHIgKz0gby50Y3B0eXBlICE9IG51bGwgPyAnIHRjcHR5cGUgJXMnIDogJyV2JztcclxuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcclxuICAgICAgICAgIHN0ciArPSAnIGdlbmVyYXRpb24gJWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHIgKz0gb1snbmV0d29yay1pZCddICE9IG51bGwgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcclxuICAgICAgICBzdHIgKz0gb1snbmV0d29yay1jb3N0J10gIT0gbnVsbCA/ICcgbmV0d29yay1jb3N0ICVkJyA6ICcldic7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWVuZC1vZi1jYW5kaWRhdGVzIChrZWVwIGFmdGVyIHRoZSBjYW5kaWRhdGVzIGxpbmUgZm9yIHJlYWRhYmlsaXR5KVxyXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcclxuICAgICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxyXG4gICAgICBuYW1lOiAncmVtb3RlQ2FuZGlkYXRlcycsXHJcbiAgICAgIHJlZzogL15yZW1vdGUtY2FuZGlkYXRlczooLiopLyxcclxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9aWNlLW9wdGlvbnM6Z29vZ2xlLWljZVxyXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXHJcbiAgICAgIHJlZzogL15pY2Utb3B0aW9uczooXFxTKikvLFxyXG4gICAgICBmb3JtYXQ6ICdpY2Utb3B0aW9uczolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxyXG4gICAgICBwdXNoOiAnc3NyY3MnLFxyXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxyXG4gICAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XHJcbiAgICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcclxuICAgICAgICAgIHN0ciArPSAnICVzJztcclxuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyICs9ICc6JXMnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMgMSAyXHJcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMtRlIgMzAwNDM2NDE5NSAxMDgwNzcyMjQxXHJcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcclxuICAgICAgLy8gdG9rZW4tY2hhciA9ICV4MjEgLyAleDIzLTI3IC8gJXgyQS0yQiAvICV4MkQtMkUgLyAleDMwLTM5IC8gJXg0MS01QSAvICV4NUUtN0VcclxuICAgICAgcmVnOiAvXnNzcmMtZ3JvdXA6KFtcXHgyMVxceDIzXFx4MjRcXHgyNVxceDI2XFx4MjdcXHgyQVxceDJCXFx4MkRcXHgyRVxcd10qKSAoLiopLyxcclxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXHJcbiAgICAgIGZvcm1hdDogJ3NzcmMtZ3JvdXA6JXMgJXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxyXG4gICAgICBuYW1lOiAnbXNpZFNlbWFudGljJyxcclxuICAgICAgcmVnOiAvXm1zaWQtc2VtYW50aWM6XFxzPyhcXHcqKSAoXFxTKikvLFxyXG4gICAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxyXG4gICAgICBmb3JtYXQ6ICdtc2lkLXNlbWFudGljOiAlcyAlcycgLy8gc3BhY2UgYWZ0ZXIgJzonIGlzIG5vdCBhY2NpZGVudGFsXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXHJcbiAgICAgIHB1c2g6ICdncm91cHMnLFxyXG4gICAgICByZWc6IC9eZ3JvdXA6KFxcdyopICguKikvLFxyXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcclxuICAgICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9cnRjcC1tdXhcclxuICAgICAgbmFtZTogJ3J0Y3BNdXgnLFxyXG4gICAgICByZWc6IC9eKHJ0Y3AtbXV4KS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1ydGNwLXJzaXplXHJcbiAgICAgIG5hbWU6ICdydGNwUnNpemUnLFxyXG4gICAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXNjdHBtYXA6NTAwMCB3ZWJydGMtZGF0YWNoYW5uZWwgMTAyNFxyXG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXHJcbiAgICAgIHJlZzogL15zY3RwbWFwOihbXFx3Xy9dKikgKFxcUyopKD86IChcXFMqKSk/LyxcclxuICAgICAgbmFtZXM6IFsnc2N0cG1hcE51bWJlcicsICdhcHAnLCAnbWF4TWVzc2FnZVNpemUnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvLm1heE1lc3NhZ2VTaXplICE9IG51bGwgPyAnc2N0cG1hcDolcyAlcyAlcycgOiAnc2N0cG1hcDolcyAlcyc7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT14LWdvb2dsZS1mbGFnOmNvbmZlcmVuY2VcclxuICAgICAgbmFtZTogJ3hHb29nbGVGbGFnJyxcclxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcclxuICAgICAgZm9ybWF0OiAneC1nb29nbGUtZmxhZzolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcclxuICAgICAgcHVzaDogJ3JpZHMnLFxyXG4gICAgICByZWc6IC9ecmlkOihbXFxkXFx3XSspIChcXHcrKSg/OiAoW1xcU3wgXSopKT8vLFxyXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gby5wYXJhbXMgPyAncmlkOiVzICVzICVzJyA6ICdyaWQ6JXMgJXMnO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3IHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF0gcmVjdiBbeD0zMzAseT0yNTBdXHJcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxyXG4gICAgICAvLyBhPWltYWdlYXR0cjoxMDAgcmVjdiBbeD0zMjAseT0yNDBdXHJcbiAgICAgIHB1c2g6ICdpbWFnZWF0dHJzJyxcclxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxyXG4gICAgICAvLyBhPWltYWdlYXR0cjo5N1xyXG4gICAgICAnXmltYWdlYXR0cjooXFxcXGQrfFxcXFwqKScgK1xyXG4gICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXHJcbiAgICAgICdbXFxcXHNcXFxcdF0rKHNlbmR8cmVjdilbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKScgK1xyXG4gICAgICAvLyByZWN2IFt4PTMzMCx5PTI1MF1cclxuICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nKSxcclxuICAgICAgbmFtZXM6IFsncHQnLCAnZGlyMScsICdhdHRyczEnLCAnZGlyMicsICdhdHRyczInXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxyXG4gICAgICAvLyBhPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XHJcbiAgICAgIG5hbWU6ICdzaW11bGNhc3QnLFxyXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXHJcbiAgICAgIC8vIGE9c2ltdWxjYXN0OlxyXG4gICAgICAnXnNpbXVsY2FzdDonICtcclxuICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxyXG4gICAgICAnKHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKyknICtcclxuICAgICAgLy8gc3BhY2UgKyByZWN2IDY7fjcsfjhcclxuICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcclxuICAgICAgLy8gZW5kXHJcbiAgICAgICckJyksXHJcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuICdzaW11bGNhc3Q6JXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIG9sZCBzaW11bGNhc3QgZHJhZnQgMDMgKGltcGxlbWVudGVkIGJ5IEZpcmVmb3gpXHJcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcclxuICAgICAgLy8gYT1zaW11bGNhc3Q6IHJlY3YgcHQ9OTc7OTggc2VuZCBwdD05N1xyXG4gICAgICAvLyBhPXNpbXVsY2FzdDogc2VuZCByaWQ9NTs2OzcgcGF1c2VkPTYsN1xyXG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcclxuICAgICAgcmVnOiAvXnNpbXVsY2FzdDpbXFxzXFx0XSsoW1xcUytcXHNcXHRdKykkLyxcclxuICAgICAgbmFtZXM6IFsndmFsdWUnXSxcclxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjVcclxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcclxuICAgICAgbmFtZTogJ2ZyYW1lcmF0ZScsXHJcbiAgICAgIHJlZzogL15mcmFtZXJhdGU6KFxcZCsoPzokfFxcLlxcZCspKS8sXHJcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gUkZDNDU3MFxyXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XHJcbiAgICAgIG5hbWU6ICdzb3VyY2VGaWx0ZXInLFxyXG4gICAgICByZWc6IC9ec291cmNlLWZpbHRlcjogKihleGNsfGluY2wpIChcXFMqKSAoSVA0fElQNnxcXCopIChcXFMqKSAoLiopLyxcclxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXHJcbiAgICAgIGZvcm1hdDogJ3NvdXJjZS1maWx0ZXI6ICVzICVzICVzICVzICVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XHJcbiAgICAgIG5hbWU6ICdidW5kbGVPbmx5JyxcclxuICAgICAgcmVnOiAvXihidW5kbGUtb25seSkvXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9bGFiZWw6MVxyXG4gICAgICBuYW1lOiAnbGFiZWwnLFxyXG4gICAgICByZWc6IC9ebGFiZWw6KC4rKS8sXHJcbiAgICAgIGZvcm1hdDogJ2xhYmVsOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcclxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNVxyXG4gICAgICBuYW1lOiAnc2N0cFBvcnQnLFxyXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxyXG4gICAgICBmb3JtYXQ6ICdzY3RwLXBvcnQ6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xyXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi02XHJcbiAgICAgIG5hbWU6ICdtYXhNZXNzYWdlU2l6ZScsXHJcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxyXG4gICAgICBmb3JtYXQ6ICdtYXgtbWVzc2FnZS1zaXplOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBSRkM3MjczXHJcbiAgICAgIC8vIGE9dHMtcmVmY2xrOnB0cD1JRUVFMTU4OC0yMDA4OjM5LUE3LTk0LUZGLUZFLTA3LUNCLUQwOjM3XHJcbiAgICAgIHB1c2g6ICd0c1JlZkNsb2NrcycsXHJcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ2Nsa3NyYycsICdjbGtzcmNFeHQnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gUkZDNzI3M1xyXG4gICAgICAvLyBhPW1lZGlhY2xrOmRpcmVjdD05NjMyMTQ0MjRcclxuICAgICAgbmFtZTogJ21lZGlhQ2xrJyxcclxuICAgICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcclxuICAgICAgbmFtZXM6IFsnaWQnLCAnbWVkaWFDbG9ja05hbWUnLCAnbWVkaWFDbG9ja1ZhbHVlJywgJ3JhdGVOdW1lcmF0b3InLCAncmF0ZURlbm9taW5hdG9yJ10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XHJcbiAgICAgICAgc3RyICs9IG8uaWQgIT0gbnVsbCA/ICdpZD0lcyAlcycgOiAnJXYlcyc7XHJcbiAgICAgICAgc3RyICs9IG8ubWVkaWFDbG9ja1ZhbHVlICE9IG51bGwgPyAnPSVzJyA6ICcnO1xyXG4gICAgICAgIHN0ciArPSBvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJztcclxuICAgICAgICBzdHIgKz0gby5yYXRlRGVub21pbmF0b3IgIT0gbnVsbCA/ICcvJXMnIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWtleXdkczprZXl3b3Jkc1xyXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxyXG4gICAgICByZWc6IC9ea2V5d2RzOiguKykkLyxcclxuICAgICAgZm9ybWF0OiAna2V5d2RzOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWNvbnRlbnQ6bWFpblxyXG4gICAgICBuYW1lOiAnY29udGVudCcsXHJcbiAgICAgIHJlZzogL15jb250ZW50OiguKykvLFxyXG4gICAgICBmb3JtYXQ6ICdjb250ZW50OiVzJ1xyXG4gICAgfSxcclxuICAgIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcclxuICAgIHtcclxuICAgICAgLy8gYT1mbG9vcmN0cmw6Yy1zXHJcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcclxuICAgICAgcmVnOiAvXmZsb29yY3RybDooYy1vbmx5fHMtb25seXxjLXMpLyxcclxuICAgICAgZm9ybWF0OiAnZmxvb3JjdHJsOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWNvbmZpZDoxXHJcbiAgICAgIG5hbWU6ICdiZmNwQ29uZklkJyxcclxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxyXG4gICAgICBmb3JtYXQ6ICdjb25maWQ6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9dXNlcmlkOjFcclxuICAgICAgbmFtZTogJ2JmY3BVc2VySWQnLFxyXG4gICAgICByZWc6IC9edXNlcmlkOihcXGQrKS8sXHJcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1mbG9vcmlkOjFcclxuICAgICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcclxuICAgICAgcmVnOiAvXmZsb29yaWQ6KC4rKSAoPzptLXN0cmVhbXxtc3RybSk6KC4rKS8sXHJcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21TdHJlYW0nXSxcclxuICAgICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYW55IGE9IHRoYXQgd2UgZG9uJ3QgdW5kZXJzdGFuZCBpcyBrZXB0IHZlcmJhdGltIG9uIG1lZGlhLmludmFsaWRcclxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxyXG4gICAgICBuYW1lczogWyd2YWx1ZSddXHJcbiAgICB9XVxyXG4gIH07XHJcblxyXG4gIC8vIHNldCBzZW5zaWJsZSBkZWZhdWx0cyB0byBhdm9pZCBwb2xsdXRpbmcgdGhlIGdyYW1tYXIgd2l0aCBib3JpbmcgZGV0YWlsc1xyXG4gIE9iamVjdC5rZXlzKGdyYW1tYXIkMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICB2YXIgb2JqcyA9IGdyYW1tYXIkMVtrZXldO1xyXG4gICAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgaWYgKCFvYmoucmVnKSB7XHJcbiAgICAgICAgb2JqLnJlZyA9IC8oLiopLztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIW9iai5mb3JtYXQpIHtcclxuICAgICAgICBvYmouZm9ybWF0ID0gJyVzJztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGdyYW1tYXIuZXhwb3J0cztcclxufVxyXG5cclxudmFyIGhhc1JlcXVpcmVkUGFyc2VyO1xyXG5mdW5jdGlvbiByZXF1aXJlUGFyc2VyKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZFBhcnNlcikgcmV0dXJuIHBhcnNlcjtcclxuICBoYXNSZXF1aXJlZFBhcnNlciA9IDE7XHJcbiAgKGZ1bmN0aW9uIChleHBvcnRzKSB7XHJcbiAgICB2YXIgdG9JbnRJZkludCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIHJldHVybiBTdHJpbmcoTnVtYmVyKHYpKSA9PT0gdiA/IE51bWJlcih2KSA6IHY7XHJcbiAgICB9O1xyXG4gICAgdmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xyXG4gICAgICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcclxuICAgICAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgIGlmIChtYXRjaFtpICsgMV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbltuYW1lc1tpXV0gPSB0b0ludElmSW50KG1hdGNoW2kgKyAxXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHBhcnNlUmVnID0gZnVuY3Rpb24gKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpIHtcclxuICAgICAgdmFyIG5lZWRzQmxhbmsgPSBvYmoubmFtZSAmJiBvYmoubmFtZXM7XHJcbiAgICAgIGlmIChvYmoucHVzaCAmJiAhbG9jYXRpb25bb2JqLnB1c2hdKSB7XHJcbiAgICAgICAgbG9jYXRpb25bb2JqLnB1c2hdID0gW107XHJcbiAgICAgIH0gZWxzZSBpZiAobmVlZHNCbGFuayAmJiAhbG9jYXRpb25bb2JqLm5hbWVdKSB7XHJcbiAgICAgICAgbG9jYXRpb25bb2JqLm5hbWVdID0ge307XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGtleUxvY2F0aW9uID0gb2JqLnB1c2ggPyB7fSA6XHJcbiAgICAgIC8vIGJsYW5rIG9iamVjdCB0aGF0IHdpbGwgYmUgcHVzaGVkXHJcbiAgICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XHJcblxyXG4gICAgICBhdHRhY2hQcm9wZXJ0aWVzKGNvbnRlbnQubWF0Y2gob2JqLnJlZyksIGtleUxvY2F0aW9uLCBvYmoubmFtZXMsIG9iai5uYW1lKTtcclxuICAgICAgaWYgKG9iai5wdXNoKSB7XHJcbiAgICAgICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGdyYW1tYXIgPSByZXF1aXJlR3JhbW1hcigpO1xyXG4gICAgdmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XHJcbiAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xyXG4gICAgICB2YXIgc2Vzc2lvbiA9IHt9LFxyXG4gICAgICAgIG1lZGlhID0gW10sXHJcbiAgICAgICAgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcclxuXHJcbiAgICAgIC8vIHBhcnNlIGxpbmVzIHdlIHVuZGVyc3RhbmRcclxuICAgICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xyXG4gICAgICAgIHZhciB0eXBlID0gbFswXTtcclxuICAgICAgICB2YXIgY29udGVudCA9IGwuc2xpY2UoMik7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xyXG4gICAgICAgICAgbWVkaWEucHVzaCh7XHJcbiAgICAgICAgICAgIHJ0cDogW10sXHJcbiAgICAgICAgICAgIGZtdHA6IFtdXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGxvY2F0aW9uID0gbWVkaWFbbWVkaWEubGVuZ3RoIC0gMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKGdyYW1tYXJbdHlwZV0gfHwgW10pLmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICB2YXIgb2JqID0gZ3JhbW1hclt0eXBlXVtqXTtcclxuICAgICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVnKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHNlc3Npb24ubWVkaWEgPSBtZWRpYTsgLy8gbGluayBpdCB1cFxyXG4gICAgICByZXR1cm4gc2Vzc2lvbjtcclxuICAgIH07XHJcbiAgICB2YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xyXG4gICAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XHJcbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgYWNjW3NbMF1dID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXHJcbiAgICBleHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IGV4cG9ydHMucGFyc2VQYXJhbXM7XHJcbiAgICBleHBvcnRzLnBhcnNlUGF5bG9hZHMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xyXG4gICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAodG9JbnRJZkludCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xyXG4gICAgICAgICAgY29tcG9uZW50OiBwYXJ0c1tpXSxcclxuICAgICAgICAgIGlwOiBwYXJ0c1tpICsgMV0sXHJcbiAgICAgICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FuZGlkYXRlcztcclxuICAgIH07XHJcbiAgICBleHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uc3Vic3RyaW5nKDEsIGl0ZW0ubGVuZ3RoIC0gMSkuc3BsaXQoJywnKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICAgIHZhciBzY2lkLFxyXG4gICAgICAgICAgICBwYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xyXG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY2lkOiBzY2lkLFxyXG4gICAgICAgICAgICBwYXVzZWQ6IHBhdXNlZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0pKHBhcnNlcik7XHJcbiAgcmV0dXJuIHBhcnNlcjtcclxufVxyXG5cclxudmFyIHdyaXRlcjtcclxudmFyIGhhc1JlcXVpcmVkV3JpdGVyO1xyXG5mdW5jdGlvbiByZXF1aXJlV3JpdGVyKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZFdyaXRlcikgcmV0dXJuIHdyaXRlcjtcclxuICBoYXNSZXF1aXJlZFdyaXRlciA9IDE7XHJcbiAgdmFyIGdyYW1tYXIgPSByZXF1aXJlR3JhbW1hcigpO1xyXG5cclxuICAvLyBjdXN0b21pemVkIHV0aWwuZm9ybWF0IC0gZGlzY2FyZHMgZXhjZXNzIGFyZ3VtZW50cyBhbmQgY2FuIHZvaWQgbWlkZGxlIG9uZXNcclxuICB2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2R2JV0vZztcclxuICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xyXG4gICAgdmFyIGkgPSAxO1xyXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XHJcbiAgICByZXR1cm4gZm9ybWF0U3RyLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICBpZiAoaSA+PSBsZW4pIHtcclxuICAgICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxyXG4gICAgICB9XHJcbiAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xyXG4gICAgICBpICs9IDE7XHJcbiAgICAgIHN3aXRjaCAoeCkge1xyXG4gICAgICAgIGNhc2UgJyUlJzpcclxuICAgICAgICAgIHJldHVybiAnJSc7XHJcbiAgICAgICAgY2FzZSAnJXMnOlxyXG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcpO1xyXG4gICAgICAgIGNhc2UgJyVkJzpcclxuICAgICAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcclxuICAgICAgICBjYXNlICcldic6XHJcbiAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gTkI6IHdlIGRpc2NhcmQgZXhjZXNzIGFyZ3VtZW50cyAtIHRoZXkgYXJlIHR5cGljYWxseSB1bmRlZmluZWQgZnJvbSBtYWtlTGluZVxyXG4gIH07XHJcbiAgdmFyIG1ha2VMaW5lID0gZnVuY3Rpb24gKHR5cGUsIG9iaiwgbG9jYXRpb24pIHtcclxuICAgIHZhciBzdHIgPSBvYmouZm9ybWF0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBvYmouZm9ybWF0KG9iai5wdXNoID8gbG9jYXRpb24gOiBsb2NhdGlvbltvYmoubmFtZV0pIDogb2JqLmZvcm1hdDtcclxuICAgIHZhciBhcmdzID0gW3R5cGUgKyAnPScgKyBzdHJdO1xyXG4gICAgaWYgKG9iai5uYW1lcykge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIHZhciBuID0gb2JqLm5hbWVzW2ldO1xyXG4gICAgICAgIGlmIChvYmoubmFtZSkge1xyXG4gICAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIGZvciBtTGluZSBhbmQgcHVzaCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVzW2ldXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUkZDIHNwZWNpZmllZCBvcmRlclxyXG4gIC8vIFRPRE86IGV4dGVuZCB0aGlzIHdpdGggYWxsIHRoZSByZXN0XHJcbiAgdmFyIGRlZmF1bHRPdXRlck9yZGVyID0gWyd2JywgJ28nLCAncycsICdpJywgJ3UnLCAnZScsICdwJywgJ2MnLCAnYicsICd0JywgJ3InLCAneicsICdhJ107XHJcbiAgdmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XHJcbiAgd3JpdGVyID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdHMpIHtcclxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xyXG4gICAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxyXG4gICAgaWYgKHNlc3Npb24udmVyc2lvbiA9PSBudWxsKSB7XHJcbiAgICAgIHNlc3Npb24udmVyc2lvbiA9IDA7IC8vICd2PTAnIG11c3QgYmUgdGhlcmUgKG9ubHkgZGVmaW5lZCB2ZXJzaW9uIGF0bSlcclxuICAgIH1cclxuICAgIGlmIChzZXNzaW9uLm5hbWUgPT0gbnVsbCkge1xyXG4gICAgICBzZXNzaW9uLm5hbWUgPSAnICc7IC8vICdzPSAnIG11c3QgYmUgdGhlcmUgaWYgbm8gbWVhbmluZ2Z1bCBuYW1lIHNldFxyXG4gICAgfVxyXG4gICAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xyXG4gICAgICBpZiAobUxpbmUucGF5bG9hZHMgPT0gbnVsbCkge1xyXG4gICAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIG91dGVyT3JkZXIgPSBvcHRzLm91dGVyT3JkZXIgfHwgZGVmYXVsdE91dGVyT3JkZXI7XHJcbiAgICB2YXIgaW5uZXJPcmRlciA9IG9wdHMuaW5uZXJPcmRlciB8fCBkZWZhdWx0SW5uZXJPcmRlcjtcclxuICAgIHZhciBzZHAgPSBbXTtcclxuXHJcbiAgICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXHJcbiAgICBvdXRlck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgZ3JhbW1hclt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIHNlc3Npb24pKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG9iai5wdXNoIGluIHNlc3Npb24gJiYgc2Vzc2lvbltvYmoucHVzaF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHRoZW4gZm9yIGVhY2ggbWVkaWEgbGluZSwgZm9sbG93IHRoZSBpbm5lck9yZGVyXHJcbiAgICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XHJcbiAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xyXG4gICAgICBpbm5lck9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgaWYgKG9iai5uYW1lIGluIG1MaW5lICYmIG1MaW5lW29iai5uYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgbUxpbmUpKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbUxpbmVbb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcclxuICB9O1xyXG4gIHJldHVybiB3cml0ZXI7XHJcbn1cclxuXHJcbnZhciBoYXNSZXF1aXJlZExpYjtcclxuZnVuY3Rpb24gcmVxdWlyZUxpYigpIHtcclxuICBpZiAoaGFzUmVxdWlyZWRMaWIpIHJldHVybiBsaWI7XHJcbiAgaGFzUmVxdWlyZWRMaWIgPSAxO1xyXG4gIHZhciBwYXJzZXIgPSByZXF1aXJlUGFyc2VyKCk7XHJcbiAgdmFyIHdyaXRlciA9IHJlcXVpcmVXcml0ZXIoKTtcclxuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XHJcbiAgbGliLmdyYW1tYXIgPSBncmFtbWFyO1xyXG4gIGxpYi53cml0ZSA9IHdyaXRlcjtcclxuICBsaWIucGFyc2UgPSBwYXJzZXIucGFyc2U7XHJcbiAgbGliLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xyXG4gIGxpYi5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxyXG4gIGxpYi5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XHJcbiAgbGliLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XHJcbiAgbGliLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xyXG4gIGxpYi5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xyXG4gIHJldHVybiBsaWI7XHJcbn1cclxuXHJcbnZhciBsaWJFeHBvcnRzID0gcmVxdWlyZUxpYigpO1xyXG5cclxuZnVuY3Rpb24gcihyLCBlLCBuKSB7XHJcbiAgdmFyIGksIHQsIG87XHJcbiAgdm9pZCAwID09PSBlICYmIChlID0gNTApLCB2b2lkIDAgPT09IG4gJiYgKG4gPSB7fSk7XHJcbiAgdmFyIGEgPSBudWxsICE9IChpID0gbi5pc0ltbWVkaWF0ZSkgJiYgaSxcclxuICAgIHUgPSBudWxsICE9ICh0ID0gbi5jYWxsYmFjaykgJiYgdCxcclxuICAgIGMgPSBuLm1heFdhaXQsXHJcbiAgICB2ID0gRGF0ZS5ub3coKSxcclxuICAgIGwgPSBbXTtcclxuICBmdW5jdGlvbiBmKCkge1xyXG4gICAgaWYgKHZvaWQgMCAhPT0gYykge1xyXG4gICAgICB2YXIgciA9IERhdGUubm93KCkgLSB2O1xyXG4gICAgICBpZiAociArIGUgPj0gYykgcmV0dXJuIGMgLSByO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGU7XHJcbiAgfVxyXG4gIHZhciBkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGUgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgIG4gPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCB0KSB7XHJcbiAgICAgIHZhciBjID0gYSAmJiB2b2lkIDAgPT09IG87XHJcbiAgICAgIGlmICh2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG8gPSB2b2lkIDAsIHYgPSBEYXRlLm5vdygpLCAhYSkge1xyXG4gICAgICAgICAgdmFyIGkgPSByLmFwcGx5KG4sIGUpO1xyXG4gICAgICAgICAgdSAmJiB1KGkpLCBsLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgwLCByLnJlc29sdmUpKGkpO1xyXG4gICAgICAgICAgfSksIGwgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGYoKSksIGMpIHtcclxuICAgICAgICB2YXIgZCA9IHIuYXBwbHkobiwgZSk7XHJcbiAgICAgICAgcmV0dXJuIHUgJiYgdShkKSwgaShkKTtcclxuICAgICAgfVxyXG4gICAgICBsLnB1c2goe1xyXG4gICAgICAgIHJlc29sdmU6IGksXHJcbiAgICAgICAgcmVqZWN0OiB0XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICByZXR1cm4gZC5jYW5jZWwgPSBmdW5jdGlvbiAocikge1xyXG4gICAgdm9pZCAwICE9PSBvICYmIGNsZWFyVGltZW91dChvKSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHJldHVybiAoMCwgZS5yZWplY3QpKHIpO1xyXG4gICAgfSksIGwgPSBbXTtcclxuICB9LCBkO1xyXG59XHJcblxyXG4vKiBUaGUgc3ZjIGNvZGVjIChhdjEvdnA5KSB3b3VsZCB1c2UgYSB2ZXJ5IGxvdyBiaXRyYXRlIGF0IHRoZSBiZWdpbmluZyBhbmRcclxuaW5jcmVhc2Ugc2xvd2x5IGJ5IHRoZSBiYW5kd2lkdGggZXN0aW1hdG9yIHVudGlsIGl0IHJlYWNoIHRoZSB0YXJnZXQgYml0cmF0ZS4gVGhlXHJcbnByb2Nlc3MgY29tbW9ubHkgY29zdCBtb3JlIHRoYW4gMTAgc2Vjb25kcyBjYXVzZSBzdWJzY3JpYmVyIHdpbGwgZ2V0IGJsdXIgdmlkZW8gYXRcclxudGhlIGZpcnN0IGZldyBzZWNvbmRzLiBTbyB3ZSB1c2UgYSA3MCUgb2YgdGFyZ2V0IGJpdHJhdGUgaGVyZSBhcyB0aGUgc3RhcnQgYml0cmF0ZSB0b1xyXG5lbGltaW5hdGUgdGhpcyBpc3N1ZS5cclxuKi9cclxuY29uc3Qgc3RhcnRCaXRyYXRlRm9yU1ZDID0gMC43O1xyXG5jb25zdCBkZWJvdW5jZUludGVydmFsID0gMjA7XHJcbmNvbnN0IFBDRXZlbnRzID0ge1xyXG4gIE5lZ290aWF0aW9uU3RhcnRlZDogJ25lZ290aWF0aW9uU3RhcnRlZCcsXHJcbiAgTmVnb3RpYXRpb25Db21wbGV0ZTogJ25lZ290aWF0aW9uQ29tcGxldGUnLFxyXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnXHJcbn07XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgZ2V0IHBjKCkge1xyXG4gICAgaWYgKCF0aGlzLl9wYykge1xyXG4gICAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9wYztcclxuICB9XHJcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICB2YXIgX2E7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xyXG4gICAgdGhpcy5kZEV4dElEID0gMDtcclxuICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcclxuICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy50cmFja0JpdHJhdGVzID0gW107XHJcbiAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBbXTtcclxuICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBbXTtcclxuICAgIC8vIGRlYm91bmNlZCBuZWdvdGlhdGUgaW50ZXJmYWNlXHJcbiAgICB0aGlzLm5lZ290aWF0ZSA9IHIob25FcnJvciA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAob25FcnJvcikge1xyXG4gICAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pLCBkZWJvdW5jZUludGVydmFsKTtcclxuICAgIHRoaXMuY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5fcGMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcclxuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbnRyYWNrID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjID0gbnVsbDtcclxuICAgIH07XHJcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDVHJhbnNwb3J0KTtcclxuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xyXG4gIH1cclxuICBjcmVhdGVQQygpIHtcclxuICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKTtcclxuICAgIHBjLm9uaWNlY2FuZGlkYXRlID0gZXYgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XHJcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2LmNhbmRpZGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcGMub25pY2VjYW5kaWRhdGVlcnJvciA9IGV2ID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICBwYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xyXG4gICAgfTtcclxuICAgIHBjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vblNpZ25hbGluZ1N0YXRlY2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5zaWduYWxpbmdTdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuY29ubmVjdGlvblN0YXRlKTtcclxuICAgIH07XHJcbiAgICBwYy5vbmRhdGFjaGFubmVsID0gZXYgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIHBjLm9udHJhY2sgPSBldiA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vblRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHBjO1xyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XHJcbiAgfVxyXG4gIGdldCBpc0lDRUNvbm5lY3RlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYyAhPT0gbnVsbCAmJiAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJyk7XHJcbiAgfVxyXG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbihzZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBsZXQgbXVuZ2VkU0RQID0gdW5kZWZpbmVkO1xyXG4gICAgICBpZiAoc2QudHlwZSA9PT0gJ29mZmVyJykge1xyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICBzdGVyZW9NaWRzLFxyXG4gICAgICAgICAgbmFja01pZHNcclxuICAgICAgICB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdGVyZW9NaWRzID0gc3RlcmVvTWlkcztcclxuICAgICAgICB0aGlzLnJlbW90ZU5hY2tNaWRzID0gbmFja01pZHM7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcclxuICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IHNkLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xyXG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcclxuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XHJcbiAgICAgICAgICAgIC8vIG11bmcgc2RwIGZvciBvcHVzIGJpdHJhdGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKCF0cmFja2JyLnRyYW5zY2VpdmVyIHx8IG1lZGlhLm1pZCAhPSB0cmFja2JyLnRyYW5zY2VpdmVyLm1pZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcclxuICAgICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgY29kZWNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyA9IGZtdHAuY29uZmlnLnNwbGl0KCc7JykuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaW5jbHVkZXMoJ21heGF2ZXJhZ2ViaXRyYXRlJykpLmpvaW4oJzsnKTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gXCI7bWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKCFmbXRwRm91bmQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICBtZWRpYS5mbXRwLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjUGF5bG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IFwibWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKVxyXG4gICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG11bmdlZFNEUCA9IGxpYkV4cG9ydHMud3JpdGUoc2RwUGFyc2VkKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChzZCwgbXVuZ2VkU0RQLCB0cnVlKTtcclxuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMgPSBbXTtcclxuICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnJlbmVnb3RpYXRlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcclxuICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XHJcbiAgICAgICAgaWYgKHNkLnNkcCkge1xyXG4gICAgICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZShzZC5zZHApO1xyXG4gICAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgbWVkaWEucnRwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKHRoaXMub25PZmZlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIElDRScsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xyXG4gICAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSBwZWVyIHRvIGFjY2VwdCBvdXIgb2ZmZXIsIHNvIHdlJ2xsIGp1c3Qgd2FpdFxyXG4gICAgICAgIC8vIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIHdoZW4gSUNFIHJlc3RhcnQgaXMgbmVlZGVkXHJcbiAgICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XHJcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWNlUmVzdGFydCkgJiYgY3VycmVudFNEKSB7XHJcbiAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWQgYnV0IHdlIGRvbid0IGhhdmUgYSByZW1vdGUgZGVzY3JpcHRpb25cclxuICAgICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxyXG4gICAgICAgICAgeWllbGQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oY3VycmVudFNEKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gYWN0dWFsbHkgbmVnb3RpYXRlXHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzdGFydGluZyB0byBuZWdvdGlhdGUnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICBjb25zdCBvZmZlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdvcmlnaW5hbCBvZmZlcicsIE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIHNkcDogb2ZmZXIuc2RwXHJcbiAgICAgIH0sIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IG9mZmVyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xyXG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XHJcbiAgICAgICAgZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKTtcclxuICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBbXSwgW10pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xyXG4gICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XHJcbiAgICAgICAgICAgIGlmICghbWVkaWEubXNpZCB8fCAhdHJhY2tici5jaWQgfHwgIW1lZGlhLm1zaWQuaW5jbHVkZXModHJhY2tici5jaWQpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xyXG4gICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY29kZWNQYXlsb2FkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU1ZDQ29kZWModHJhY2tici5jb2RlYykpIHtcclxuICAgICAgICAgICAgICB0aGlzLmVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcFBhcnNlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogYXYxIHNsb3cgc3RhcnRpbmcgaXNzdWUgYWxyZWFkeSBmaXhlZCBpbiBjaHJvbWUgMTI0LCBjbGVhbiB0aGlzIGFmdGVyIHNvbWUgdmVyc2lvbnNcclxuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIGF2MSBiaXRyYXRlIHNldHRpbmcgdGhhdCBjYW4ndCBhcHBseSBieSBzZW5kRW5jb2RpbmdcclxuICAgICAgICAgICAgaWYgKHRyYWNrYnIuY29kZWMgIT09ICdhdjEnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRCaXRyYXRlID0gTWF0aC5yb3VuZCh0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcclxuICAgICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGFub3RoZXIgdHJhY2sncyBmbXRwIGFscmVhZHkgaXMgc2V0LCB3ZSBjYW5ub3Qgb3ZlcnJpZGUgdGhlIGJpdHJhdGVcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHRoZSB1bmZvcnR1bmF0ZSBjb25zZXF1ZW5jZSBvZiBiZWluZyBmb3JjZWQgdG8gdXNlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbCB0cmFjaydzIGJpdHJhdGUgZm9yIGFsbCB0cmFja3NcclxuICAgICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjt4LWdvb2dsZS1zdGFydC1iaXRyYXRlPVwiLmNvbmNhdChzdGFydEJpdHJhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAob2ZmZXIsIGxpYkV4cG9ydHMud3JpdGUoc2RwUGFyc2VkKSk7XHJcbiAgICAgIHRoaXMub25PZmZlcihvZmZlcik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlQW5kU2V0QW5zd2VyKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnBjLmNyZWF0ZUFuc3dlcigpO1xyXG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IGFuc3dlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcclxuICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xyXG4gICAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XHJcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgICAgIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgdGhpcy5yZW1vdGVTdGVyZW9NaWRzLCB0aGlzLnJlbW90ZU5hY2tNaWRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChhbnN3ZXIsIGxpYkV4cG9ydHMud3JpdGUoc2RwUGFyc2VkKSk7XHJcbiAgICAgIHJldHVybiBhbnN3ZXI7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XHJcbiAgfVxyXG4gIGFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcclxuICB9XHJcbiAgYWRkVHJhY2sodHJhY2spIHtcclxuICAgIGlmICghdGhpcy5fcGMpIHtcclxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGFkZCB0cmFjaycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcclxuICB9XHJcbiAgc2V0VHJhY2tDb2RlY0JpdHJhdGUoaW5mbykge1xyXG4gICAgdGhpcy50cmFja0JpdHJhdGVzLnB1c2goaW5mbyk7XHJcbiAgfVxyXG4gIHNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoIXRoaXMuX3BjKSB7XHJcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBjb25maWd1cmUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcclxuICB9XHJcbiAgY2FuUmVtb3ZlVHJhY2soKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gISEoKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVUcmFjayk7XHJcbiAgfVxyXG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2soc2VuZGVyKTtcclxuICB9XHJcbiAgZ2V0Q29ubmVjdGlvblN0YXRlKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XHJcbiAgfVxyXG4gIGdldElDRUNvbm5lY3Rpb25TdGF0ZSgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pY2VDb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xyXG4gIH1cclxuICBnZXRTaWduYWxsaW5nU3RhdGUoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsaW5nU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xyXG4gIH1cclxuICBnZXRUcmFuc2NlaXZlcnMoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNjZWl2ZXJzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xyXG4gIH1cclxuICBnZXRTZW5kZXJzKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNlbmRlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgfVxyXG4gIGdldExvY2FsRGVzY3JpcHRpb24oKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uO1xyXG4gIH1cclxuICBnZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSB0aGlzLnBjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3RlRGVzY3JpcHRpb247XHJcbiAgfVxyXG4gIGdldFN0YXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGMuZ2V0U3RhdHMoKTtcclxuICB9XHJcbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKCF0aGlzLl9wYykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcclxuICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgIC8vIGlkIC0+IGNhbmRpZGF0ZSBpcFxyXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuX3BjLmdldFN0YXRzKCk7XHJcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgc3dpdGNoICh2LnR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgJ3RyYW5zcG9ydCc6XHJcbiAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjYW5kaWRhdGUtcGFpcic6XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAncmVtb3RlLWNhbmRpZGF0ZSc6XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIFwiXCIuY29uY2F0KHYuYWRkcmVzcywgXCI6XCIpLmNvbmNhdCh2LnBvcnQpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2VsZWN0ZWRJRCA9IChfYSA9IGNhbmRpZGF0ZVBhaXJzLmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVDYW5kaWRhdGVJZDtcclxuICAgICAgaWYgKHNlbGVjdGVkSUQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXMuZ2V0KHNlbGVjdGVkSUQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldE11bmdlZFNEUChzZCwgbXVuZ2VkLCByZW1vdGUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmIChtdW5nZWQpIHtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFNkcCA9IHNkLnNkcDtcclxuICAgICAgICBzZC5zZHAgPSBtdW5nZWQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBtdW5nZWQgXCIuY29uY2F0KHJlbW90ZSA/ICdyZW1vdGUnIDogJ2xvY2FsJywgXCIgZGVzY3JpcHRpb25cIiksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICBpZiAocmVtb3RlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwibm90IGFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlLCBcIiwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGUsXHJcbiAgICAgICAgICAgIHNkcDogbXVuZ2VkXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICBzZC5zZHAgPSBvcmlnaW5hbFNkcDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAocmVtb3RlKSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsZXQgbXNnID0gJ3Vua25vd24gZXJyb3InO1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgIG1zZyA9IGUubWVzc2FnZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgbXNnID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0ge1xyXG4gICAgICAgICAgZXJyb3I6IG1zZyxcclxuICAgICAgICAgIHNkcDogc2Quc2RwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIXJlbW90ZSAmJiB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBmaWVsZHNcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IGRkRm91bmQgPSAoX2EgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGV4dCA9PiB7XHJcbiAgICAgIGlmIChleHQudXJpID09PSBkZEV4dGVuc2lvblVSSSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFkZEZvdW5kKSB7XHJcbiAgICAgIGlmICh0aGlzLmRkRXh0SUQgPT09IDApIHtcclxuICAgICAgICBsZXQgbWF4SUQgPSAwO1xyXG4gICAgICAgIHNkcC5tZWRpYS5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgaWYgKG0udHlwZSAhPT0gJ3ZpZGVvJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAoX2EgPSBtLmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZXh0ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV4dC52YWx1ZSA+IG1heElEKSB7XHJcbiAgICAgICAgICAgICAgbWF4SUQgPSBleHQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGRFeHRJRCA9IG1heElEICsgMTtcclxuICAgICAgfVxyXG4gICAgICAoX2IgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdXNoKHtcclxuICAgICAgICB2YWx1ZTogdGhpcy5kZEV4dElELFxyXG4gICAgICAgIHVyaTogZGRFeHRlbnNpb25VUklcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyhtZWRpYSwgc3RlcmVvTWlkcywgbmFja01pZHMpIHtcclxuICAvLyBmb3VuZCBvcHVzIGNvZGVjIHRvIGFkZCBuYWNrIGZiXHJcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcclxuICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xyXG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XHJcbiAgICAgIG9wdXNQYXlsb2FkID0gcnRwLnBheWxvYWQ7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0pO1xyXG4gIC8vIGFkZCBuYWNrIHJ0Y3BmYiBpZiBub3QgZXhpc3RcclxuICBpZiAob3B1c1BheWxvYWQgPiAwKSB7XHJcbiAgICBpZiAoIW1lZGlhLnJ0Y3BGYikge1xyXG4gICAgICBtZWRpYS5ydGNwRmIgPSBbXTtcclxuICAgIH1cclxuICAgIGlmIChuYWNrTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpICYmICFtZWRpYS5ydGNwRmIuc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XHJcbiAgICAgIG1lZGlhLnJ0Y3BGYi5wdXNoKHtcclxuICAgICAgICBwYXlsb2FkOiBvcHVzUGF5bG9hZCxcclxuICAgICAgICB0eXBlOiAnbmFjaydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RlcmVvTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQpKSB7XHJcbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcclxuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xyXG4gICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3RlcmVvPTEnKSkge1xyXG4gICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnO3N0ZXJlbz0xJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKG9mZmVyKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IHN0ZXJlb01pZHMgPSBbXTtcclxuICBjb25zdCBuYWNrTWlkcyA9IFtdO1xyXG4gIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XHJcbiAgbGV0IG9wdXNQYXlsb2FkID0gMDtcclxuICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xyXG4gICAgICAgIGlmIChydHAuY29kZWMgPT09ICdvcHVzJykge1xyXG4gICAgICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoKF9hID0gbWVkaWEucnRjcEZiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZShmYiA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpKSB7XHJcbiAgICAgICAgbmFja01pZHMucHVzaChtZWRpYS5taWQpO1xyXG4gICAgICB9XHJcbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcclxuICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCkge1xyXG4gICAgICAgICAgaWYgKGZtdHAuY29uZmlnLmluY2x1ZGVzKCdzcHJvcC1zdGVyZW89MScpKSB7XHJcbiAgICAgICAgICAgIHN0ZXJlb01pZHMucHVzaChtZWRpYS5taWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0ZXJlb01pZHMsXHJcbiAgICBuYWNrTWlkc1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKSB7XHJcbiAgLy8gQ2hyb21lIGNvdWxkIGdlbmVyYXRlIHNkcCB3aXRoIGMgPSBJTiBJUDQgPGlwdjYgYWRkcj5cclxuICAvLyBpbiBlZGdlIGNhc2UgYW5kIHJldHVybiBlcnJvciB3aGVuIHNldCBzZHAuVGhpcyBpcyBub3QgYVxyXG4gIC8vIHNkayBlcnJvciBidXQgY29ycmVjdCBpdCBpZiB0aGUgaXNzdWUgZGV0ZWN0ZWQuXHJcbiAgaWYgKG1lZGlhLmNvbm5lY3Rpb24pIHtcclxuICAgIGNvbnN0IGlzVjYgPSBtZWRpYS5jb25uZWN0aW9uLmlwLmluZGV4T2YoJzonKSA+PSAwO1xyXG4gICAgaWYgKG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9PT0gNCAmJiBpc1Y2IHx8IG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9PT0gNiAmJiAhaXNWNikge1xyXG4gICAgICAvLyBmYWxsYmFjayB0byBkdW1teSBhZGRyZXNzXHJcbiAgICAgIG1lZGlhLmNvbm5lY3Rpb24uaXAgPSAnMC4wLjAuMCc7XHJcbiAgICAgIG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9IDQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0VmlkZW9Db2RlYyA9ICd2cDgnO1xyXG5jb25zdCBwdWJsaXNoRGVmYXVsdHMgPSB7XHJcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcclxuICBkdHg6IHRydWUsXHJcbiAgcmVkOiB0cnVlLFxyXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcclxuICBzaW11bGNhc3Q6IHRydWUsXHJcbiAgc2NyZWVuU2hhcmVFbmNvZGluZzogU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMTUuZW5jb2RpbmcsXHJcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcclxuICB2aWRlb0NvZGVjOiBkZWZhdWx0VmlkZW9Db2RlYyxcclxuICBiYWNrdXBDb2RlYzogdHJ1ZSxcclxuICBwcmVDb25uZWN0QnVmZmVyOiBmYWxzZVxyXG59O1xyXG5jb25zdCBhdWRpb0RlZmF1bHRzID0ge1xyXG4gIGRldmljZUlkOiB7XHJcbiAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgfSxcclxuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXHJcbiAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcclxuICBub2lzZVN1cHByZXNzaW9uOiB0cnVlLFxyXG4gIHZvaWNlSXNvbGF0aW9uOiB0cnVlXHJcbn07XHJcbmNvbnN0IHZpZGVvRGVmYXVsdHMgPSB7XHJcbiAgZGV2aWNlSWQ6IHtcclxuICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICB9LFxyXG4gIHJlc29sdXRpb246IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb25cclxufTtcclxuY29uc3Qgcm9vbU9wdGlvbkRlZmF1bHRzID0ge1xyXG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcclxuICBkeW5hY2FzdDogZmFsc2UsXHJcbiAgc3RvcExvY2FsVHJhY2tPblVucHVibGlzaDogdHJ1ZSxcclxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXHJcbiAgZGlzY29ubmVjdE9uUGFnZUxlYXZlOiB0cnVlLFxyXG4gIHdlYkF1ZGlvTWl4OiBmYWxzZVxyXG59O1xyXG5jb25zdCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzID0ge1xyXG4gIGF1dG9TdWJzY3JpYmU6IHRydWUsXHJcbiAgbWF4UmV0cmllczogMSxcclxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1MDAwLFxyXG4gIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXHJcbn07XHJcblxyXG52YXIgUENUcmFuc3BvcnRTdGF0ZTtcclxuKGZ1bmN0aW9uIChQQ1RyYW5zcG9ydFN0YXRlKSB7XHJcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiTkVXXCJdID0gMF0gPSBcIk5FV1wiO1xyXG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xyXG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDJdID0gXCJDT05ORUNURURcIjtcclxuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJGQUlMRURcIl0gPSAzXSA9IFwiRkFJTEVEXCI7XHJcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0lOR1wiXSA9IDRdID0gXCJDTE9TSU5HXCI7XHJcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ0xPU0VEXCJdID0gNV0gPSBcIkNMT1NFRFwiO1xyXG59KShQQ1RyYW5zcG9ydFN0YXRlIHx8IChQQ1RyYW5zcG9ydFN0YXRlID0ge30pKTtcclxuY2xhc3MgUENUcmFuc3BvcnRNYW5hZ2VyIHtcclxuICBnZXQgbmVlZHNQdWJsaXNoZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDtcclxuICB9XHJcbiAgZ2V0IG5lZWRzU3Vic2NyaWJlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDtcclxuICB9XHJcbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcihydGNDb25maWcsIHN1YnNjcmliZXJQcmltYXJ5LCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xyXG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xyXG4gICAgdGhpcy51cGRhdGVTdGF0ZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlcyA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzLm1hcCh0ciA9PiB0ci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XHJcbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY29ubmVjdGVkJykpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnZmFpbGVkJykpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY29ubmVjdGluZycpKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVElORztcclxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLmV2ZXJ5KHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TRUQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICduZXcnKSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicGMgc3RhdGUgY2hhbmdlOiBmcm9tIFwiLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3ByZXZpb3VzU3RhdGVdLCBcIiB0byBcIikuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbdGhpcy5zdGF0ZV0pLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIChfYSA9IHRoaXMub25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgdGhpcy5zdGF0ZSwgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksIHRoaXMuc3Vic2NyaWJlci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDTWFuYWdlcik7XHJcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xyXG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9ICFzdWJzY3JpYmVyUHJpbWFyeTtcclxuICAgIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkID0gc3Vic2NyaWJlclByaW1hcnk7XHJcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBQQ1RyYW5zcG9ydChydGNDb25maWcsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xyXG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcclxuICAgIHRoaXMucHVibGlzaGVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xyXG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcclxuICAgIH07XHJcbiAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25EYXRhQ2hhbm5lbCA9IGV2ID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25UcmFjayA9IGV2ID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICB0aGlzLnB1Ymxpc2hlci5vbk9mZmVyID0gb2ZmZXIgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25QdWJsaXNoZXJPZmZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgb2ZmZXIpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcclxuICAgIHRoaXMuY29ubmVjdGlvbkxvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5yZW1vdGVPZmZlckxvY2sgPSBuZXcgXygpO1xyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XHJcbiAgfVxyXG4gIHJlcXVpcmVQdWJsaXNoZXIoKSB7XHJcbiAgICBsZXQgcmVxdWlyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcclxuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xyXG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG4gIH1cclxuICByZXF1aXJlU3Vic2NyaWJlcigpIHtcclxuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xyXG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG4gIH1cclxuICBjcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcclxuICB9XHJcbiAgc2V0UHVibGlzaGVyQW5zd2VyKHNkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xyXG4gIH1cclxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcclxuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xyXG4gIH1cclxuICBjbG9zZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnB1Ymxpc2hlciAmJiB0aGlzLnB1Ymxpc2hlci5nZXRTaWduYWxsaW5nU3RhdGUoKSAhPT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLnB1Ymxpc2hlcjtcclxuICAgICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZWFjdC1uYXRpdmUtd2VicnRjIGRvZXNuJ3QgaGF2ZSByZW1vdmVUcmFjayB5ZXQuXHJcbiAgICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xyXG4gICAgICAgICAgICAgIHB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCByZW1vdmVUcmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW3RoaXMucHVibGlzaGVyLmNsb3NlKCksIHRoaXMuc3Vic2NyaWJlci5jbG9zZSgpXSk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB0cmlnZ2VySWNlUmVzdGFydCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcclxuICAgICAgLy8gb25seSByZXN0YXJ0IHB1Ymxpc2hlciBpZiBpdCdzIG5lZWRlZFxyXG4gICAgICBpZiAodGhpcy5uZWVkc1B1Ymxpc2hlcikge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKHtcclxuICAgICAgICAgIGljZVJlc3RhcnQ6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUikge1xyXG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxyXG4gICAgICAgIHNkcDogc2Quc2RwLFxyXG4gICAgICAgIHNpZ25hbGluZ1N0YXRlOiB0aGlzLnN1YnNjcmliZXIuZ2V0U2lnbmFsbGluZ1N0YXRlKCkudG9TdHJpbmcoKVxyXG4gICAgICB9KSk7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucmVtb3RlT2ZmZXJMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB5aWVsZCB0aGlzLnN1YnNjcmliZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xyXG4gICAgICAgIC8vIGFuc3dlciB0aGUgb2ZmZXJcclxuICAgICAgICBjb25zdCBhbnN3ZXIgPSB5aWVsZCB0aGlzLnN1YnNjcmliZXIuY3JlYXRlQW5kU2V0QW5zd2VyKCk7XHJcbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnLCBpY2VSZXN0YXJ0KSB7XHJcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XHJcbiAgICB0aGlzLnN1YnNjcmliZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xyXG4gICAgaWYgKGljZVJlc3RhcnQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VySWNlUmVzdGFydCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbkxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnbmVnb3RpYXRpb24gcmVxdWlyZWQsIHN0YXJ0IG5lZ290aWF0aW5nJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCgoX2EgPSB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCh0cmFuc3BvcnQgPT4gdGhpcy5lbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQodHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpKSk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBuZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IG5lZ290aWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgcmVqZWN0KCduZWdvdGlhdGlvbiB0aW1lZCBvdXQnKTtcclxuICAgICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XHJcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkLCAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKGUgPT4ge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBhZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XHJcbiAgfVxyXG4gIGFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuYWRkVHJhY2sodHJhY2spO1xyXG4gIH1cclxuICBjcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHJlcXVpcmVkIHRyYW5zcG9ydCdzIGFkZHJlc3MgaWYgbm8gZXhwbGljaXQgdGFyZ2V0IGlzIHNwZWNpZmllZFxyXG4gICAqL1xyXG4gIGdldENvbm5lY3RlZEFkZHJlc3ModGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0c1swXS5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XHJcbiAgfVxyXG4gIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XHJcbiAgICBjb25zdCB0cmFuc3BvcnRzID0gW107XHJcbiAgICBpZiAodGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCkge1xyXG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XHJcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyYW5zcG9ydHM7XHJcbiAgfVxyXG4gIGVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZChwY1RyYW5zcG9ydF8xLCBhYm9ydENvbnRyb2xsZXJfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHBjVHJhbnNwb3J0LCBhYm9ydENvbnRyb2xsZXIpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGUgPSBwY1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUoKTtcclxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XHJcbiAgICAgICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ2NvdWxkIG5vdCBlc3RhYmxpc2ggcGMgY29ubmVjdGlvbicsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKSk7XHJcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xyXG4gICAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcclxuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiAyMDI0IExpdmVLaXQsIEluYy5cclxuLy9cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcclxuLyoqXHJcbiAqIFNwZWNpYWxpemVkIGVycm9yIGhhbmRsaW5nIGZvciBSUEMgbWV0aG9kcy5cclxuICpcclxuICogSW5zdGFuY2VzIG9mIHRoaXMgdHlwZSwgd2hlbiB0aHJvd24gaW4gYSBtZXRob2QgaGFuZGxlciwgd2lsbCBoYXZlIHRoZWlyIGBtZXNzYWdlYFxyXG4gKiBzZXJpYWxpemVkIGFuZCBzZW50IGFjcm9zcyB0aGUgd2lyZS4gVGhlIHNlbmRlciB3aWxsIHJlY2VpdmUgYW4gZXF1aXZhbGVudCBlcnJvciBvbiB0aGUgb3RoZXIgc2lkZS5cclxuICpcclxuICogQnVpbHQtaW4gdHlwZXMgYXJlIGluY2x1ZGVkIGJ1dCBkZXZlbG9wZXJzIG1heSB1c2UgYW55IHN0cmluZywgd2l0aCBhIG1heCBsZW5ndGggb2YgMjU2IGJ5dGVzLlxyXG4gKi9cclxuY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29kZSBhbmQgbWVzc2FnZSwgcGx1cyBhbiBvcHRpb25hbCBkYXRhIHBheWxvYWQuXHJcbiAgICpcclxuICAgKiBJZiB0aHJvd24gaW4gYW4gUlBDIG1ldGhvZCBoYW5kbGVyLCB0aGUgZXJyb3Igd2lsbCBiZSBzZW50IGJhY2sgdG8gdGhlIGNhbGxlci5cclxuICAgKlxyXG4gICAqIEVycm9yIGNvZGVzIDEwMDEtMTk5OSBhcmUgcmVzZXJ2ZWQgZm9yIGJ1aWx0LWluIGVycm9ycyAoc2VlIFJwY0Vycm9yLkVycm9yQ29kZSBmb3IgdGhlaXIgbWVhbmluZ3MpLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcclxuICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgIHRoaXMubWVzc2FnZSA9IHRydW5jYXRlQnl0ZXMobWVzc2FnZSwgUnBjRXJyb3IuTUFYX01FU1NBR0VfQllURVMpO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IHRydW5jYXRlQnl0ZXMoZGF0YSwgUnBjRXJyb3IuTUFYX0RBVEFfQllURVMpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBzdGF0aWMgZnJvbVByb3RvKHByb3RvKSB7XHJcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKHByb3RvLmNvZGUsIHByb3RvLm1lc3NhZ2UsIHByb3RvLmRhdGEpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICB0b1Byb3RvKCkge1xyXG4gICAgcmV0dXJuIG5ldyBScGNFcnJvciQxKHtcclxuICAgICAgY29kZTogdGhpcy5jb2RlLFxyXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IGZyb20gdGhlIGNvZGUsIHdpdGggYW4gYXV0by1wb3B1bGF0ZWQgbWVzc2FnZS5cclxuICAgKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHN0YXRpYyBidWlsdEluKGtleSwgZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyBScGNFcnJvcihScGNFcnJvci5FcnJvckNvZGVba2V5XSwgUnBjRXJyb3IuRXJyb3JNZXNzYWdlW2tleV0sIGRhdGEpO1xyXG4gIH1cclxufVxyXG5ScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyA9IDI1NjtcclxuUnBjRXJyb3IuTUFYX0RBVEFfQllURVMgPSAxNTM2MDsgLy8gMTUgS0JcclxuUnBjRXJyb3IuRXJyb3JDb2RlID0ge1xyXG4gIEFQUExJQ0FUSU9OX0VSUk9SOiAxNTAwLFxyXG4gIENPTk5FQ1RJT05fVElNRU9VVDogMTUwMSxcclxuICBSRVNQT05TRV9USU1FT1VUOiAxNTAyLFxyXG4gIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6IDE1MDMsXHJcbiAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6IDE1MDQsXHJcbiAgU0VORF9GQUlMRUQ6IDE1MDUsXHJcbiAgVU5TVVBQT1JURURfTUVUSE9EOiAxNDAwLFxyXG4gIFJFQ0lQSUVOVF9OT1RfRk9VTkQ6IDE0MDEsXHJcbiAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogMTQwMixcclxuICBVTlNVUFBPUlRFRF9TRVJWRVI6IDE0MDMsXHJcbiAgVU5TVVBQT1JURURfVkVSU0lPTjogMTQwNFxyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5ScGNFcnJvci5FcnJvck1lc3NhZ2UgPSB7XHJcbiAgQVBQTElDQVRJT05fRVJST1I6ICdBcHBsaWNhdGlvbiBlcnJvciBpbiBtZXRob2QgaGFuZGxlcicsXHJcbiAgQ09OTkVDVElPTl9USU1FT1VUOiAnQ29ubmVjdGlvbiB0aW1lb3V0JyxcclxuICBSRVNQT05TRV9USU1FT1VUOiAnUmVzcG9uc2UgdGltZW91dCcsXHJcbiAgUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRDogJ1JlY2lwaWVudCBkaXNjb25uZWN0ZWQnLFxyXG4gIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFOiAnUmVzcG9uc2UgcGF5bG9hZCB0b28gbGFyZ2UnLFxyXG4gIFNFTkRfRkFJTEVEOiAnRmFpbGVkIHRvIHNlbmQnLFxyXG4gIFVOU1VQUE9SVEVEX01FVEhPRDogJ01ldGhvZCBub3Qgc3VwcG9ydGVkIGF0IGRlc3RpbmF0aW9uJyxcclxuICBSRUNJUElFTlRfTk9UX0ZPVU5EOiAnUmVjaXBpZW50IG5vdCBmb3VuZCcsXHJcbiAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnLFxyXG4gIFVOU1VQUE9SVEVEX1NFUlZFUjogJ1JQQyBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZlcicsXHJcbiAgVU5TVVBQT1JURURfVkVSU0lPTjogJ1Vuc3VwcG9ydGVkIFJQQyB2ZXJzaW9uJ1xyXG59O1xyXG4vKlxyXG4gKiBNYXhpbXVtIHBheWxvYWQgc2l6ZSBmb3IgUlBDIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuIElmIGEgcGF5bG9hZCBleGNlZWRzIHRoaXMgc2l6ZSxcclxuICogdGhlIFJQQyBjYWxsIHdpbGwgZmFpbCB3aXRoIGEgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRSgxNDAyKSBvciBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRSgxNTA0KSBlcnJvci5cclxuICovXHJcbmNvbnN0IE1BWF9QQVlMT0FEX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyKSB7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIpLmxlbmd0aDtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB0cnVuY2F0ZUJ5dGVzKHN0ciwgbWF4Qnl0ZXMpIHtcclxuICBpZiAoYnl0ZUxlbmd0aChzdHIpIDw9IG1heEJ5dGVzKSB7XHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuICBsZXQgbG93ID0gMDtcclxuICBsZXQgaGlnaCA9IHN0ci5sZW5ndGg7XHJcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoICsgMSkgLyAyKTtcclxuICAgIGlmIChlbmNvZGVyLmVuY29kZShzdHIuc2xpY2UoMCwgbWlkKSkubGVuZ3RoIDw9IG1heEJ5dGVzKSB7XHJcbiAgICAgIGxvdyA9IG1pZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpZ2ggPSBtaWQgLSAxO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RyLnNsaWNlKDAsIGxvdyk7XHJcbn1cclxuXHJcbmNvbnN0IG1vbml0b3JGcmVxdWVuY3kgPSAyMDAwO1xyXG5mdW5jdGlvbiBjb21wdXRlQml0cmF0ZShjdXJyZW50U3RhdHMsIHByZXZTdGF0cykge1xyXG4gIGlmICghcHJldlN0YXRzKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgbGV0IGJ5dGVzTm93O1xyXG4gIGxldCBieXRlc1ByZXY7XHJcbiAgaWYgKCdieXRlc1JlY2VpdmVkJyBpbiBjdXJyZW50U3RhdHMpIHtcclxuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XHJcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNSZWNlaXZlZDtcclxuICB9IGVsc2UgaWYgKCdieXRlc1NlbnQnIGluIGN1cnJlbnRTdGF0cykge1xyXG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNTZW50O1xyXG4gICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzU2VudDtcclxuICB9XHJcbiAgaWYgKGJ5dGVzTm93ID09PSB1bmRlZmluZWQgfHwgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWQgfHwgY3VycmVudFN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8IHByZXZTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIHJldHVybiAoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDAgLyAoY3VycmVudFN0YXRzLnRpbWVzdGFtcCAtIHByZXZTdGF0cy50aW1lc3RhbXApO1xyXG59XHJcblxyXG4vLyBDaGVjayBpZiBNZWRpYVJlY29yZGVyIGlzIGF2YWlsYWJsZVxyXG5jb25zdCBpc01lZGlhUmVjb3JkZXJBdmFpbGFibGUgPSB0eXBlb2YgTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8vIEZhbGxiYWNrIGNsYXNzIGZvciBlbnZpcm9ubWVudHMgd2l0aG91dCBNZWRpYVJlY29yZGVyXHJcbmNsYXNzIEZhbGxiYWNrUmVjb3JkZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZWRpYVJlY29yZGVyIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xyXG4gIH1cclxufVxyXG4vLyBVc2UgY29uZGl0aW9uYWwgaW5oZXJpdGFuY2UgdG8gYXZvaWQgcGFyc2UtdGltZSBlcnJvcnNcclxuY29uc3QgUmVjb3JkZXJCYXNlID0gaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlID8gTWVkaWFSZWNvcmRlciA6IEZhbGxiYWNrUmVjb3JkZXI7XHJcbmNsYXNzIExvY2FsVHJhY2tSZWNvcmRlciBleHRlbmRzIFJlY29yZGVyQmFzZSB7XHJcbiAgY29uc3RydWN0b3IodHJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGlmICghaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVkaWFSZWNvcmRlciBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcclxuICAgIH1cclxuICAgIHN1cGVyKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pLCBvcHRpb25zKTtcclxuICAgIGxldCBkYXRhTGlzdGVuZXI7XHJcbiAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjtcclxuICAgIGNvbnN0IGlzQ2xvc2VkID0gKCkgPT4gc3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgb25TdG9wID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCBkYXRhTGlzdGVuZXIpO1xyXG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3AnLCBvblN0b3ApO1xyXG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPT09IG51bGwgfHwgc3RyZWFtQ29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xyXG4gICAgICBzdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRXJyb3IgPSBldmVudCA9PiB7XHJcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPT09IG51bGwgfHwgc3RyZWFtQ29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RyZWFtQ29udHJvbGxlci5lcnJvcihldmVudCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGRhdGFMaXN0ZW5lcik7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcCcsIG9uU3RvcCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgc3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB0aGlzLmJ5dGVTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xyXG4gICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XHJcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgZGF0YUxpc3RlbmVyID0gZXZlbnQgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBldmVudC5kYXRhLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICBpZiAoaXNDbG9zZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RhdGFhdmFpbGFibGUnLCBkYXRhTGlzdGVuZXIpO1xyXG4gICAgICB9LFxyXG4gICAgICBjYW5jZWw6ICgpID0+IHtcclxuICAgICAgICBvblN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCBvblN0b3ApO1xyXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gIH1cclxufVxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgcmVjb3JkaW5nIGlzIHN1cHBvcnRlZFxyXG5mdW5jdGlvbiBpc1JlY29yZGluZ1N1cHBvcnRlZCgpIHtcclxuICByZXR1cm4gaXNNZWRpYVJlY29yZGVyQXZhaWxhYmxlO1xyXG59XHJcblxyXG5jb25zdCBERUZBVUxUX0RJTUVOU0lPTlNfVElNRU9VVCA9IDEwMDA7XHJcbmNvbnN0IFBSRV9DT05ORUNUX0JVRkZFUl9USU1FT1VUID0gMTAwMDA7XHJcbmNsYXNzIExvY2FsVHJhY2sgZXh0ZW5kcyBUcmFjayB7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGdldCBzZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0IHNlbmRlcihzZW5kZXIpIHtcclxuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcclxuICB9XHJcbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xyXG4gIH1cclxuICBnZXQgaGFzUHJlQ29ubmVjdEJ1ZmZlcigpIHtcclxuICAgIHJldHVybiAhIXRoaXMubG9jYWxUcmFja1JlY29yZGVyO1xyXG4gIH1cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXHJcbiAgICogQHBhcmFtIGtpbmRcclxuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xyXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XHJcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xyXG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQgPSAoKSA9PiB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIoKS5jYXRjaCgoKSA9PiB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgbXV0ZSBib3VuY2UgZ290IGNhbmNlbGxlZCBieSBhbiB1bm11dGUgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciA9IHIoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcclxuICAgIH0pLCA1MDAwKTtcclxuICAgIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgndW5tdXRlJyk7XHJcbiAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9ICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQpIHtcclxuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcclxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xyXG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xyXG4gICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrO1xyXG4gICAgdGhpcy5tdXRlTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMucHJvY2Vzc29yTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLnJlc3RhcnRMb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayhtZWRpYVRyYWNrLCB0cnVlKTtcclxuICAgIC8vIGFkZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIsIGNvbnN0cmFpbnRzIGFyZSBzeW5jZWQgd2l0aCBNZWRpYVN0cmVhbVRyYWNrXHJcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcclxuICAgIGlmIChjb25zdHJhaW50cykge1xyXG4gICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5pZDtcclxuICB9XHJcbiAgZ2V0IGRpbWVuc2lvbnMoKSB7XHJcbiAgICBpZiAodGhpcy5raW5kICE9PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHdpZHRoLFxyXG4gICAgICBoZWlnaHRcclxuICAgIH0gPSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XHJcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBnZXQgaXNVcHN0cmVhbVBhdXNlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkO1xyXG4gIH1cclxuICBnZXQgaXNVc2VyUHJvdmlkZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlZEJ5VXNlcjtcclxuICB9XHJcbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvY2Vzc2VkVHJhY2spICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XHJcbiAgfVxyXG4gIGdldCBpc0xvY2FsKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIHJldHVybnMgbWVkaWFTdHJlYW1UcmFjayBzZXR0aW5ncyBvZiB0aGUgY2FwdHVyaW5nIG1lZGlhc3RyZWFtdHJhY2sgc291cmNlIC0gaWdub3JpbmcgcHJvY2Vzc29yc1xyXG4gICAqL1xyXG4gIGdldFNvdXJjZVRyYWNrU2V0dGluZ3MoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xyXG4gIH1cclxuICBzZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrLCBmb3JjZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAobmV3VHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgJiYgIWZvcmNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XHJcbiAgICAgICAgLy8gZGV0YWNoXHJcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ25ldy10cmFjaycpO1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcclxuICAgICAgaWYgKG5ld1RyYWNrKSB7XHJcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcclxuICAgICAgICAvLyB0byBwcm9kdWNlIG1lZGlhLiBJbiB0aGlzIGNhc2Ugd2UnbGwgbmVlZCB0byBzaWduYWwgd2l0aCByZW1vdGUgdGhhdFxyXG4gICAgICAgIC8vIHRoZSB0cmFjayBpcyBcIm11dGVkXCJcclxuICAgICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cclxuICAgICAgICAvLyB0b3VjaCBNZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWRcclxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XHJcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcclxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IG5ld1RyYWNrLmdldENvbnN0cmFpbnRzKCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHByb2Nlc3NlZFRyYWNrO1xyXG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3IgJiYgbmV3VHJhY2spIHtcclxuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ3Vua25vd24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3JFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChuZXdUcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBwcm9jZXNzb3JFbGVtZW50IGl0c2VsZiBzdGF5cyBtdXRlZFxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgeWllbGQgdGhpcy5wcm9jZXNzb3IucmVzdGFydCh7XHJcbiAgICAgICAgICAgIHRyYWNrOiBuZXdUcmFjayxcclxuICAgICAgICAgICAga2luZDogdGhpcy5raW5kLFxyXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLnByb2Nlc3NvckVsZW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcHJvY2Vzc2VkVHJhY2sgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaztcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbmRlciAmJiAoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjayk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaWYgYG5ld1RyYWNrYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdHJhY2ssIHN0b3AgdGhlXHJcbiAgICAgIC8vIG9sZGVyIHRyYWNrIGp1c3QgYmVmb3JlIHJlcGxhY2luZyBpdFxyXG4gICAgICBpZiAoIXRoaXMucHJvdmlkZWRCeVVzZXIgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAhPT0gbmV3VHJhY2spIHtcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrID0gbmV3VHJhY2s7XHJcbiAgICAgIGlmIChuZXdUcmFjaykge1xyXG4gICAgICAgIC8vIHN5bmMgbXV0ZWQgc3RhdGUgd2l0aCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbmV3bHkgcHJvdmlkZWQgdHJhY2tcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhdGhpcy5pc011dGVkO1xyXG4gICAgICAgIC8vIHdoZW4gYSB2YWxpZCB0cmFjayBpcyByZXBsYWNlLCB3ZSdkIHdhbnQgdG8gc3RhcnQgcHJvZHVjaW5nXHJcbiAgICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xyXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjaywgZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgd2FpdEZvckRpbWVuc2lvbnMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBERUZBVUxUX0RJTUVOU0lPTlNfVElNRU9VVDtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChfdGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZGltZW5zaW9ucyBmb3IgYXVkaW8gdHJhY2tzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3MpID09PSAnaU9TJykge1xyXG4gICAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXHJcbiAgICAgICAgICAvLyB3aGVuIHNsaWdodGx5IGRlbGF5aW5nIHRoZSBjYWxsIHRvIC5nZXRTZXR0aW5ncygpLCB0aGUgY29ycmVjdCByZXNvbHV0aW9uIGlzIGJlaW5nIHJlcG9ydGVkXHJcbiAgICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcclxuICAgICAgICAgIGNvbnN0IGRpbXMgPSBfdGhpcy5kaW1lbnNpb25zO1xyXG4gICAgICAgICAgaWYgKGRpbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpbXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIGdldCB0cmFjayBkaW1lbnNpb25zIGFmdGVyIHRpbWVvdXQnKTtcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldERldmljZUlkKGRldmljZUlkKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xyXG4gICAgICAvLyB3aGVuIHRyYWNrIGlzIG11dGVkLCB1bmRlcmx5aW5nIG1lZGlhIHN0cmVhbSB0cmFjayBpcyBzdG9wcGVkIGFuZFxyXG4gICAgICAvLyB3aWxsIGJlIHJlc3RhcnRlZCBsYXRlclxyXG4gICAgICBpZiAodGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcclxuICAgICAgcmV0dXJuIHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgRGV2aWNlSUQgb2YgdGhlIGRldmljZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIGZvciB0aGlzIHRyYWNrXHJcbiAgICovXHJcbiAgZ2V0RGV2aWNlSWQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICBsZXQgbm9ybWFsaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxyXG4gICAgICAgIGlmIChfdGhpczIuc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgZGV2aWNlSWQsXHJcbiAgICAgICAgICBncm91cElkXHJcbiAgICAgICAgfSA9IF90aGlzMi5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xyXG4gICAgICAgIGNvbnN0IGtpbmQgPSBfdGhpczIua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbyA/ICdhdWRpb2lucHV0JyA6ICd2aWRlb2lucHV0JztcclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplID8gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSA6IGRldmljZUlkO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbXV0ZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZCh0cnVlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdW5tdXRlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5zZXRUcmFja011dGVkKGZhbHNlKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVwbGFjZVRyYWNrKHRyYWNrLCB1c2VyUHJvdmlkZWRPck9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3VuYWJsZSB0byByZXBsYWNlIGFuIHVucHVibGlzaGVkIHRyYWNrJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrO1xyXG4gICAgICBsZXQgc3RvcFByb2Nlc3NvcjtcclxuICAgICAgaWYgKHR5cGVvZiB1c2VyUHJvdmlkZWRPck9wdGlvbnMgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdXNlclByb3ZpZGVkT3JPcHRpb25zO1xyXG4gICAgICB9IGVsc2UgaWYgKHVzZXJQcm92aWRlZE9yT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdXNlclByb3ZpZGVkVHJhY2sgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMudXNlclByb3ZpZGVkVHJhY2s7XHJcbiAgICAgICAgc3RvcFByb2Nlc3NvciA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy5zdG9wUHJvY2Vzc29yO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJvdmlkZWRCeVVzZXIgPSB1c2VyUHJvdmlkZWRUcmFjayAhPT0gbnVsbCAmJiB1c2VyUHJvdmlkZWRUcmFjayAhPT0gdm9pZCAwID8gdXNlclByb3ZpZGVkVHJhY2sgOiB0cnVlO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKHRyYWNrKTtcclxuICAgICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXHJcbiAgICAgIC8vIG9uIHRoZSBwcmV2aW91cyBzdGF0ZSBpbiBvcmRlciB0byBjbGVhbnVwXHJcbiAgICAgIGlmIChzdG9wUHJvY2Vzc29yICYmIHRoaXMucHJvY2Vzc29yKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVzdGFydChjb25zdHJhaW50cykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5yZXN0YXJ0TG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFjb25zdHJhaW50cykge1xyXG4gICAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLl9jb25zdHJhaW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBkZXZpY2VJZCxcclxuICAgICAgICAgICAgZmFjaW5nTW9kZVxyXG4gICAgICAgICAgfSA9IGNvbnN0cmFpbnRzLFxyXG4gICAgICAgICAgb3RoZXJDb25zdHJhaW50cyA9IF9fcmVzdChjb25zdHJhaW50cywgW1wiZGV2aWNlSWRcIiwgXCJmYWNpbmdNb2RlXCJdKTtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyB0cmFjayB3aXRoIGNvbnN0cmFpbnRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBjb25zdHJhaW50c1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IHtcclxuICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcclxuICAgICAgICAgIHZpZGVvOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICAgICAgc3RyZWFtQ29uc3RyYWludHMudmlkZW8gPSBkZXZpY2VJZCB8fCBmYWNpbmdNb2RlID8ge1xyXG4gICAgICAgICAgICBkZXZpY2VJZCxcclxuICAgICAgICAgICAgZmFjaW5nTW9kZVxyXG4gICAgICAgICAgfSA6IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvID0gZGV2aWNlSWQgPyB7XHJcbiAgICAgICAgICAgIGRldmljZUlkXHJcbiAgICAgICAgICB9IDogdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlc2Ugc3RlcHMgYXJlIGR1cGxpY2F0ZWQgZnJvbSBzZXRNZWRpYVN0cmVhbVRyYWNrIGJlY2F1c2Ugd2UgbXVzdCBzdG9wXHJcbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHRyYWNrcyBiZWZvcmUgbmV3IHRyYWNrcyBjYW4gYmUgYWNxdWlyZWRcclxuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XHJcbiAgICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXHJcbiAgICAgICAgLy8gdGhlIG5ldyB0cmFjaywgb3RoZXJ3aXNlIHRoZSBuZXcgdHJhY2sgd2lsbCBzdG9wIHdpdGhcclxuICAgICAgICAvLyAnQSBNZWRpYVN0cmVhbVRyYWNrIGVuZGVkIGR1ZSB0byBhIGNhcHR1cmUgZmFpbHVyZWBcclxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IHRyYWNrIGFuZCBhdHRhY2hcclxuICAgICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcclxuICAgICAgICBjb25zdCBuZXdUcmFjayA9IG1lZGlhU3RyZWFtLmdldFRyYWNrcygpWzBdO1xyXG4gICAgICAgIHlpZWxkIG5ld1RyYWNrLmFwcGx5Q29uc3RyYWludHMob3RoZXJDb25zdHJhaW50cyk7XHJcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmUtYWNxdWlyZWQgTWVkaWFTdHJlYW1UcmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcclxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xyXG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubWFudWFsbHlTdG9wcGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgc3RvcHBlZCBkdXJpbmcgYSByZXN0YXJ0LCBzdG9wcGluZyByZXN0YXJ0ZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xyXG4gICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIFwiLmNvbmNhdCh0aGlzLmtpbmQsIFwiIHRyYWNrIFwiKS5jb25jYXQobXV0ZWQgPyAnbXV0ZWQnIDogJ3VubXV0ZWQnKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgIGlmICh0aGlzLmlzTXV0ZWQgPT09IG11dGVkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCAhPT0gbXV0ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XHJcbiAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcclxuICB9XHJcbiAgZ2V0IG5lZWRzUmVBY3F1aXNpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlYWR5U3RhdGUgIT09ICdsaXZlJyB8fCB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLm11dGVkIHx8ICF0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgfHwgdGhpcy5yZWFjcXVpcmVUcmFjaztcclxuICB9XHJcbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XHJcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInZpc2liaWxpdHkgY2hhbmdlZCwgaXMgaW4gQmFja2dyb3VuZDogXCIuY29uY2F0KHRoaXMuaXNJbkJhY2tncm91bmQpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICBpZiAoIXRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5uZWVkc1JlQWNxdWlzaXRpb24gJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQgJiYgIXRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyBcIi5jb25jYXQodGhpcy5zb3VyY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xyXG4gICAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHN0b3AoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IHRydWU7XHJcbiAgICBzdXBlci5zdG9wKCk7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcclxuICAgIChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHBhdXNlcyBwdWJsaXNoaW5nIHRvIHRoZSBzZXJ2ZXIgd2l0aG91dCBkaXNhYmxpbmcgdGhlIGxvY2FsIE1lZGlhU3RyZWFtVHJhY2tcclxuICAgKiB0aGlzIGlzIHVzZWQgdG8gZGlzcGxheSBhIHVzZXIncyBvd24gdmlkZW8gbG9jYWxseSB3aGlsZSBwYXVzaW5nIHB1Ymxpc2hpbmcgdG9cclxuICAgKiB0aGUgc2VydmVyLlxyXG4gICAqIHRoaXMgQVBJIGlzIHVuc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyIGR1ZSB0byBhIGJ1Z1xyXG4gICAqKi9cclxuICBwYXVzZVVwc3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcGF1c2UgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XHJcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0OTExXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigncGF1c2VVcHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXN1bWVVcHN0cmVhbSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBub29wIGlmIG1lZGlhc3RyZWFtdHJhY2sgaXMgYWxyZWFkeSBiZWluZyBzZW50XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRlci5yZXBsYWNlVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIExvY2FsVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFNlbmRlclxyXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDU3RhdHNSZXBvcnRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNldHMgYSBwcm9jZXNzb3Igb24gdGhpcyB0cmFjay5cclxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxyXG4gICAqXHJcbiAgICogQGV4cGVyaW1lbnRhbFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByb2Nlc3NvclxyXG4gICAqIEBwYXJhbSBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseVxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcl8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG4gICAgICBsZXQgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpczMucHJvY2Vzc29yTG9jay5sb2NrKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgY29uc3QgcHJvY2Vzc29yRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoX3RoaXMzLmtpbmQpO1xyXG4gICAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2luZDogX3RoaXMzLmtpbmQsXHJcbiAgICAgICAgICAgIHRyYWNrOiBfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IHByb2Nlc3NvckVsZW1lbnQsXHJcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogX3RoaXMzLmF1ZGlvQ29udGV4dFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHlpZWxkIHByb2Nlc3Nvci5pbml0KHByb2Nlc3Nvck9wdGlvbnMpO1xyXG4gICAgICAgICAgX3RoaXMzLmxvZy5kZWJ1ZygncHJvY2Vzc29yIGluaXRpYWxpemVkJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgaWYgKF90aGlzMy5wcm9jZXNzb3IpIHtcclxuICAgICAgICAgICAgeWllbGQgX3RoaXMzLnN0b3BQcm9jZXNzb3IoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChfdGhpczMua2luZCA9PT0gJ3Vua25vd24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLCBwcm9jZXNzb3JFbGVtZW50KTtcclxuICAgICAgICAgIHByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyb3IgPT4gX3RoaXMzLmxvZy5lcnJvcignZmFpbGVkIHRvIHBsYXkgcHJvY2Vzc29yIGVsZW1lbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgfSkpKTtcclxuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XHJcbiAgICAgICAgICBfdGhpczMucHJvY2Vzc29yRWxlbWVudCA9IHByb2Nlc3NvckVsZW1lbnQ7XHJcbiAgICAgICAgICBpZiAoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIF90aGlzMy5hdHRhY2hlZEVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVsICE9PSBfdGhpczMucHJvY2Vzc29yRWxlbWVudCAmJiBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSkge1xyXG4gICAgICAgICAgICAgICAgZGV0YWNoVHJhY2soX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVRyYWNrKF90aGlzMy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX3RoaXMzLmVtaXQoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgX3RoaXMzLnByb2Nlc3Nvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHVubG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldFByb2Nlc3NvcigpIHtcclxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NvcjtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIHRyYWNrIHByb2Nlc3NvclxyXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXHJcbiAgICpcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICogQHJldHVybnNcclxuICAgKi9cclxuICBzdG9wUHJvY2Vzc29yKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuICAgICAgbGV0IGtlZXBFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICghX3RoaXM0LnByb2Nlc3NvcikgcmV0dXJuO1xyXG4gICAgICAgIF90aGlzNC5sb2cuZGVidWcoJ3N0b3BwaW5nIHByb2Nlc3NvcicsIF90aGlzNC5sb2dDb250ZXh0KTtcclxuICAgICAgICAoX2EgPSBfdGhpczQucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xyXG4gICAgICAgIHlpZWxkIF90aGlzNC5wcm9jZXNzb3IuZGVzdHJveSgpO1xyXG4gICAgICAgIF90aGlzNC5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCFrZWVwRWxlbWVudCkge1xyXG4gICAgICAgICAgKF9iID0gX3RoaXM0LnByb2Nlc3NvckVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZW1vdmUoKTtcclxuICAgICAgICAgIF90aGlzNC5wcm9jZXNzb3JFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhcHBseSBvcmlnaW5hbCB0cmFjayBjb25zdHJhaW50cyBpbiBjYXNlIHRoZSBwcm9jZXNzb3IgY2hhbmdlZCB0aGVtXHJcbiAgICAgICAgeWllbGQgX3RoaXM0Ll9tZWRpYVN0cmVhbVRyYWNrLmFwcGx5Q29uc3RyYWludHMoX3RoaXM0Ll9jb25zdHJhaW50cyk7XHJcbiAgICAgICAgLy8gZm9yY2UgcmUtc2V0dGluZyBvZiB0aGUgbWVkaWFTdHJlYW1UcmFjayBvbiB0aGUgc2VuZGVyXHJcbiAgICAgICAgeWllbGQgX3RoaXM0LnNldE1lZGlhU3RyZWFtVHJhY2soX3RoaXM0Ll9tZWRpYVN0cmVhbVRyYWNrLCB0cnVlKTtcclxuICAgICAgICBfdGhpczQuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGFydFByZUNvbm5lY3RCdWZmZXIoKSB7XHJcbiAgICBsZXQgdGltZXNsaWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxMDA7XHJcbiAgICBpZiAoIWlzUmVjb3JkaW5nU3VwcG9ydGVkKCkpIHtcclxuICAgICAgdGhpcy5sb2cud2FybignTWVkaWFSZWNvcmRlciBpcyBub3QgYXZhaWxhYmxlLCBjYW5ub3Qgc3RhcnQgcHJlY29ubmVjdCBidWZmZXInLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIXRoaXMubG9jYWxUcmFja1JlY29yZGVyKSB7XHJcbiAgICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyID0gbmV3IExvY2FsVHJhY2tSZWNvcmRlcih0aGlzLCB7XHJcbiAgICAgICAgbWltZVR5cGU6ICdhdWRpby93ZWJtO2NvZGVjcz1vcHVzJ1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3ByZWNvbm5lY3QgYnVmZmVyIGFscmVhZHkgc3RhcnRlZCcpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlci5zdGFydCh0aW1lc2xpY2UpO1xyXG4gICAgdGhpcy5hdXRvU3RvcFByZUNvbm5lY3RCdWZmZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy5sb2cud2FybigncHJlY29ubmVjdCBidWZmZXIgdGltZWQgb3V0LCBzdG9wcGluZyByZWNvcmRpbmcgYXV0b21hdGljYWxseScsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMuc3RvcFByZUNvbm5lY3RCdWZmZXIoKTtcclxuICAgIH0sIFBSRV9DT05ORUNUX0JVRkZFUl9USU1FT1VUKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0b3BQcmVDb25uZWN0QnVmZmVyKCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b1N0b3BQcmVDb25uZWN0QnVmZmVyKTtcclxuICAgIGlmICh0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikge1xyXG4gICAgICB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlci5zdG9wKCk7XHJcbiAgICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZ2V0UHJlQ29ubmVjdEJ1ZmZlcigpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSB0aGlzLmxvY2FsVHJhY2tSZWNvcmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJ5dGVTdHJlYW07XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBMb2NhbEF1ZGlvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcclxuICAvKipcclxuICAgKiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBlbmhhbmNlZCBub2lzZSBjYW5jZWxsYXRpb24gaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgb24gdGhpcyB0cmFja1xyXG4gICAqL1xyXG4gIGdldCBlbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xyXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXHJcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcclxuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcclxuICAgIGxldCBhdWRpb0NvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcclxuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XHJcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLkF1ZGlvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHN0YXRzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSA9ICgpID0+IHtcclxuICAgICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJLcmlzcCBub2lzZSBmaWx0ZXIgZW5hYmxlZFwiLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJEaXNhYmxlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJLcmlzcCBub2lzZSBmaWx0ZXIgZGlzYWJsZWRcIiwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMsIEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTiwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xyXG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcclxuICB9XHJcbiAgbXV0ZSgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICBtdXRlOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5tdXRlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgbXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRpc2FibGVkIHNwZWNpYWwgaGFuZGxpbmcgYXMgaXQgd2lsbCBjYXVzZSBCVCBoZWFkc2V0cyB0byBzd2l0Y2ggY29tbXVuaWNhdGlvbiBtb2Rlc1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RvcHBpbmcgbWljIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgbWljcm9waG9uZSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxyXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICB1bm11dGUoKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgdW5tdXRlOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgdW5tdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGV2aWNlSGFzQ2hhbmdlZCA9IHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCAhPT0gdW53cmFwQ29uc3RyYWludCh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiAodGhpcy5zdG9wT25NdXRlIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJyB8fCBkZXZpY2VIYXNDaGFuZ2VkKSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXN0YXJ0VHJhY2sob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xyXG4gICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKHtcclxuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICByZXN0YXJ0OiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBfc3VwZXIucmVzdGFydC5jYWxsKHRoaXMsIGNvbnN0cmFpbnRzKTtcclxuICAgICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcclxuICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXJ0TW9uaXRvcigpIHtcclxuICAgIGlmICghaXNXZWIoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xyXG4gICAgfSwgbW9uaXRvckZyZXF1ZW5jeSk7XHJcbiAgfVxyXG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWlzUmVhY3ROYXRpdmUoKSAmJiAhdGhpcy5hdWRpb0NvbnRleHQpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yKCdBdWRpbyBjb250ZXh0IG5lZWRzIHRvIGJlIHNldCBvbiBMb2NhbEF1ZGlvVHJhY2sgaW4gb3JkZXIgdG8gZW5hYmxlIHByb2Nlc3NvcnMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcclxuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcclxuICAgICAgICAgIHRyYWNrOiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLFxyXG4gICAgICAgICAgLy8gUk4gd29uJ3QgaGF2ZSBvciB1c2UgQXVkaW9Db250ZXh0XHJcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuYXVkaW9Db250ZXh0XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgdXAgYXVkaW8gcHJvY2Vzc29yIFwiLmNvbmNhdChwcm9jZXNzb3IubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XHJcbiAgICAgICAgICB5aWVsZCAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XHJcbiAgICAgICAgICB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJywgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRW5hYmxlKTtcclxuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc2FibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJywgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRGlzYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCB0aGlzLnByb2Nlc3Nvcik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICovXHJcbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XHJcbiAgfVxyXG4gIGdldFNlbmRlclN0YXRzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xyXG4gICAgICBsZXQgYXVkaW9TdGF0cztcclxuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcclxuICAgICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xyXG4gICAgICAgICAgYXVkaW9TdGF0cyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcclxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXHJcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxyXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcclxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcm91bmRUcmlwVGltZTogdi5yb3VuZFRyaXBUaW1lLFxyXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBhdWRpb1N0YXRzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrRm9yU2lsZW5jZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBkZXRlY3RTaWxlbmNlKHRoaXMpO1xyXG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdzaWxlbmNlIGRldGVjdGVkIG9uIGxvY2FsIGF1ZGlvIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cmFja0lzU2lsZW50O1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpIHtcclxuICBzd2l0Y2ggKG1lZGlhU3RyZWFtVHJhY2sua2luZCkge1xyXG4gICAgY2FzZSAnYXVkaW8nOlxyXG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIHVuZGVmaW5lZCwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICBjYXNlICd2aWRlbyc6XHJcbiAgICAgIHJldHVybiBuZXcgTG9jYWxWaWRlb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCB0cmFjayB0eXBlOiBcIi5jb25jYXQobWVkaWFTdHJlYW1UcmFjay5raW5kKSk7XHJcbiAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5jb25zdCBwcmVzZXRzMTY5ID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHMpO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuY29uc3QgcHJlc2V0czQzID0gT2JqZWN0LnZhbHVlcyhWaWRlb1ByZXNldHM0Myk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5jb25zdCBwcmVzZXRzU2NyZWVuU2hhcmUgPSBPYmplY3QudmFsdWVzKFNjcmVlblNoYXJlUHJlc2V0cyk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSA9IFtWaWRlb1ByZXNldHMuaDE4MCwgVmlkZW9QcmVzZXRzLmgzNjBdO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuY29uc3QgZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MyA9IFtWaWRlb1ByZXNldHM0My5oMTgwLCBWaWRlb1ByZXNldHM0My5oMzYwXTtcclxuLyogQGludGVybmFsICovXHJcbmNvbnN0IGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzID0gZnJvbVByZXNldCA9PiB7XHJcbiAgY29uc3QgbGF5ZXJzID0gW3tcclxuICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMixcclxuICAgIGZwczogZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcclxuICB9XTtcclxuICByZXR1cm4gbGF5ZXJzLm1hcCh0ID0+IHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gbmV3IFZpZGVvUHJlc2V0KE1hdGguZmxvb3IoZnJvbVByZXNldC53aWR0aCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmhlaWdodCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSwgTWF0aC5tYXgoMTUwMDAwLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZSAvIChNYXRoLnBvdyh0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSwgMikgKiAoKChfYSA9IGZyb21QcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMCkgLyAoKF9iID0gdC5mcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDMwKSkpKSksIHQuZnBzLCBmcm9tUHJlc2V0LmVuY29kaW5nLnByaW9yaXR5KTtcclxuICB9KTtcclxufTtcclxuLy8gLyoqXHJcbi8vICAqXHJcbi8vICAqIEBpbnRlcm5hbFxyXG4vLyAgKiBAZXhwZXJpbWVudGFsXHJcbi8vICAqL1xyXG4vLyBjb25zdCBjb21wdXRlRGVmYXVsdE11bHRpQ29kZWNTaW11bGNhc3RFbmNvZGluZ3MgPSAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcclxuLy8gICAvLyB1c2UgdnA4IGFzIGEgZGVmYXVsdFxyXG4vLyAgIGNvbnN0IHZwOCA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoZmFsc2UsIHdpZHRoLCBoZWlnaHQpO1xyXG4vLyAgIGNvbnN0IHZwOSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuOSB9O1xyXG4vLyAgIGNvbnN0IGgyNjQgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAxLjEgfTtcclxuLy8gICBjb25zdCBhdjEgPSB7IC4uLnZwOCwgbWF4Qml0cmF0ZTogdnA4Lm1heEJpdHJhdGUgKiAwLjcgfTtcclxuLy8gICByZXR1cm4ge1xyXG4vLyAgICAgdnA4LFxyXG4vLyAgICAgdnA5LFxyXG4vLyAgICAgaDI2NCxcclxuLy8gICAgIGF2MSxcclxuLy8gICB9O1xyXG4vLyB9O1xyXG5jb25zdCB2aWRlb1JpZHMgPSBbJ3EnLCAnaCcsICdmJ107XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBjb21wdXRlVmlkZW9FbmNvZGluZ3MoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xyXG4gIHZhciBfYSwgX2I7XHJcbiAgbGV0IHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9FbmNvZGluZztcclxuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xyXG4gICAgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZUVuY29kaW5nO1xyXG4gIH1cclxuICBjb25zdCB1c2VTaW11bGNhc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2ltdWxjYXN0O1xyXG4gIGNvbnN0IHNjYWxhYmlsaXR5TW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY2FsYWJpbGl0eU1vZGU7XHJcbiAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NvZGVjO1xyXG4gIGlmICghdmlkZW9FbmNvZGluZyAmJiAhdXNlU2ltdWxjYXN0ICYmICFzY2FsYWJpbGl0eU1vZGUgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcclxuICAgIC8vIHdoZW4gd2UgYXJlbid0IHNpbXVsY2FzdGluZyBvciBzdmMsIHdpbGwgbmVlZCB0byByZXR1cm4gYSBzaW5nbGUgZW5jb2Rpbmcgd2l0aG91dFxyXG4gICAgLy8gY2FwcGluZyBiYW5kd2lkdGguIHdlIGFsd2F5cyByZXF1aXJlIGEgZW5jb2RpbmcgZm9yIGR5bmFjYXN0XHJcbiAgICByZXR1cm4gW3t9XTtcclxuICB9XHJcbiAgaWYgKCF2aWRlb0VuY29kaW5nKSB7XHJcbiAgICAvLyBmaW5kIHRoZSByaWdodCBlbmNvZGluZyBiYXNlZCBvbiB3aWR0aC9oZWlnaHRcclxuICAgIHZpZGVvRW5jb2RpbmcgPSBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIHZpZGVvQ29kZWMpO1xyXG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygndXNpbmcgdmlkZW8gZW5jb2RpbmcnLCB2aWRlb0VuY29kaW5nKTtcclxuICB9XHJcbiAgY29uc3Qgc291cmNlRnJhbWVyYXRlID0gdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGU7XHJcbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQod2lkdGgsIGhlaWdodCwgdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLCB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSwgdmlkZW9FbmNvZGluZy5wcmlvcml0eSk7XHJcbiAgaWYgKHNjYWxhYmlsaXR5TW9kZSAmJiBpc1NWQ0NvZGVjKHZpZGVvQ29kZWMpKSB7XHJcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2NhbGFiaWxpdHlNb2RlKTtcclxuICAgIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xyXG4gICAgaWYgKHNtLnNwYXRpYWwgPiAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogXCIuY29uY2F0KHNjYWxhYmlsaXR5TW9kZSkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmVmb3JlIE0xMTMgaW4gQ2hyb21lLCBkZWZpbmluZyBtdWx0aXBsZSBlbmNvZGluZ3Mgd2l0aCBhbiBTVkMgY29kZWMgaW5kaWNhdGVkXHJcbiAgICAvLyB0aGF0IFNWQyBtb2RlIHNob3VsZCBiZSB1c2VkLiBTYWZhcmkgc3RpbGwgd29ya3MgdGhpcyB3YXkuXHJcbiAgICAvLyBUaGlzIGlzIGEgYml0IGNvbmZ1c2luZyBidXQgaXMgZHVlIHRvIGhvdyBsaWJ3ZWJydGMgaW50ZXJwcmV0ZWQgdGhlIGVuY29kaW5ncyBmaWVsZFxyXG4gICAgLy8gYmVmb3JlIE0xMTMuXHJcbiAgICAvLyBBbm5vdW5jZWQgaGVyZTogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9nL2Rpc2N1c3Mtd2VicnRjL2MvLVFRM3B4cmwtZnc/cGxpPTFcclxuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgICBpZiAoaXNTYWZhcmkoKSB8fFxyXG4gICAgLy8gRXZlbiB0aG8gUk4gcnVucyBNMTE0LCBpdCBkb2VzIG5vdCBwcm9kdWNlIFNWQyBsYXllcnMgd2hlbiBhIHNpbmdsZSBlbmNvZGluZ1xyXG4gICAgLy8gaXMgcHJvdmlkZWQuIFNvIHdlJ2xsIHVzZSB0aGUgbGVnYWN5IFNWQyBzcGVjaWZpY2F0aW9uIGZvciBub3cuXHJcbiAgICAvLyBUT0RPOiB3aGVuIHdlIHVwc3RyZWFtIGxpYndlYnJ0YywgdGhpcyB3aWxsIG5lZWQgYWRkaXRpb25hbCB2ZXJpZmljYXRpb25cclxuICAgIGlzUmVhY3ROYXRpdmUoKSB8fCAoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnQ2hyb21lJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24sICcxMTMnKSA8IDApIHtcclxuICAgICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcclxuICAgICAgLy8gc2FmYXJpIDE4LjQgdXNlcyBhIGRpZmZlcmVudCBzdmMgQVBJIHRoYXQgcmVxdWlyZXMgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IHRvIGJlIHNldC5cclxuICAgICAgY29uc3QgcmVxdWlyZVNjYWxlID0gaXNTYWZhcmlTdmNBcGkoYnJvd3Nlcik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XHJcbiAgICAgICAgLy8gaW4gbGVnYWN5IFNWQywgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IGNhbm5vdCBiZSBzZXRcclxuICAgICAgICBlbmNvZGluZ3MucHVzaCh7XHJcbiAgICAgICAgICByaWQ6IHZpZGVvUmlkc1syIC0gaV0sXHJcbiAgICAgICAgICBtYXhCaXRyYXRlOiB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUgLyBNYXRoLnBvdyhiaXRyYXRlc1JhdGlvLCBpKSxcclxuICAgICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxyXG4gICAgICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiByZXF1aXJlU2NhbGUgPyBNYXRoLnBvdygyLCBpKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGxlZ2FjeSBTVkMsIHNjYWxhYmlsaXR5TW9kZSBpcyBzZXQgb25seSBvbiB0aGUgZmlyc3QgZW5jb2RpbmdcclxuICAgICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgICBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlID0gc2NhbGFiaWxpdHlNb2RlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW5jb2RpbmdzLnB1c2goe1xyXG4gICAgICAgIG1heEJpdHJhdGU6IHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSxcclxuICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcclxuICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgc2NhbGFiaWxpdHlNb2RlOiBzY2FsYWJpbGl0eU1vZGVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHkpIHtcclxuICAgICAgZW5jb2RpbmdzWzBdLnByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XHJcbiAgICAgIGVuY29kaW5nc1swXS5uZXR3b3JrUHJpb3JpdHkgPSBvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eTtcclxuICAgIH1cclxuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ1c2luZyBzdmMgZW5jb2RpbmdcIiwge1xyXG4gICAgICBlbmNvZGluZ3NcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGVuY29kaW5ncztcclxuICB9XHJcbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcclxuICAgIHJldHVybiBbdmlkZW9FbmNvZGluZ107XHJcbiAgfVxyXG4gIGxldCBwcmVzZXRzID0gW107XHJcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcclxuICAgIHByZXNldHMgPSAoX2EgPSBzb3J0UHJlc2V0cyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcHJlc2V0cyA9IChfYiA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb1NpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xyXG4gIH1cclxuICBsZXQgbWlkUHJlc2V0O1xyXG4gIGlmIChwcmVzZXRzLmxlbmd0aCA+IDApIHtcclxuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XHJcbiAgICBpZiAocHJlc2V0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIFssIG1pZFByZXNldF0gPSBwcmVzZXRzO1xyXG4gICAgfVxyXG4gICAgLy8gTk9URTpcclxuICAgIC8vICAgMS4gT3JkZXJpbmcgb2YgdGhlc2UgZW5jb2RpbmdzIGlzIGltcG9ydGFudC4gQ2hyb21lIHNlZW1zXHJcbiAgICAvLyAgICAgIHRvIHVzZSB0aGUgaW5kZXggaW50byBlbmNvZGluZ3MgdG8gZGVjaWRlIHdoaWNoIGxheWVyXHJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXHJcbiAgICAvLyAgICAgIFNvIGVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWxcclxuICAgIC8vICAgICAgcmVzb2x1dGlvbiBvcmRlci5cclxuICAgIC8vICAgMi4gbGl2ZWtpdC1zZXJ2ZXIgdHJhbnNsYXRlcyByaWRzIGludG8gbGF5ZXJzLiBTbywgYWxsIGVuY29kaW5nc1xyXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxyXG4gICAgLy8gICAgICBiYXNlZCBvbiBvdGhlciBjb25kaXRpb25zLlxyXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xyXG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgbWlkUHJlc2V0LCBvcmlnaW5hbF0sIHNvdXJjZUZyYW1lcmF0ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2l6ZSA+PSA0ODApIHtcclxuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG9yaWdpbmFsXSwgc291cmNlRnJhbWVyYXRlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtvcmlnaW5hbF0pO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cykge1xyXG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAvLyBiYWNrdXBDb2RlYyBzaG91bGQgbm90IGJlIHRydWUgYW55bW9yZSwgZGVmYXVsdCBjb2RlYyBpcyBzZXQgaW4gTG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoXHJcbiAgaWYgKCFvcHRzLmJhY2t1cENvZGVjIHx8IG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUgfHwgb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyA9PT0gb3B0cy52aWRlb0NvZGVjKSB7XHJcbiAgICAvLyBiYWNrdXAgY29kZWMgcHVibGlzaGluZyBpcyBkaXNhYmxlZFxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAodmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYykge1xyXG4gICAgbGl2ZWtpdExvZ2dlci53YXJuKCdyZXF1ZXN0ZWQgYSBkaWZmZXJlbnQgY29kZWMgdGhhbiBzcGVjaWZpZWQgYXMgYmFja3VwJywge1xyXG4gICAgICBzZXJ2ZXJSZXF1ZXN0ZWQ6IHZpZGVvQ29kZWMsXHJcbiAgICAgIGJhY2t1cDogb3B0cy5iYWNrdXBDb2RlYy5jb2RlY1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG9wdHMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XHJcbiAgLy8gdXNlIGJhY2t1cCBlbmNvZGluZyBzZXR0aW5nIGFzIHZpZGVvRW5jb2RpbmcgZm9yIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nXHJcbiAgb3B0cy52aWRlb0VuY29kaW5nID0gb3B0cy5iYWNrdXBDb2RlYy5lbmNvZGluZztcclxuICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcclxuICBjb25zdCB3aWR0aCA9IChfYSA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2lkdGg7XHJcbiAgY29uc3QgaGVpZ2h0ID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0O1xyXG4gIC8vIGRpc2FibGUgc2ltdWxjYXN0IGZvciBzY3JlZW5zaGFyZSBiYWNrdXAgY29kZWMgc2luY2UgTDFUeCBpcyB1c2VkIGJ5IHByaW1hcnkgY29kZWNcclxuICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgb3B0cy5zaW11bGNhc3QpIHtcclxuICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XHJcbiAgfVxyXG4gIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0cyk7XHJcbiAgcmV0dXJuIGVuY29kaW5ncztcclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBjb2RlYykge1xyXG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcclxuICBsZXQge1xyXG4gICAgZW5jb2RpbmdcclxuICB9ID0gcHJlc2V0c1swXTtcclxuICAvLyBoYW5kbGUgcG9ydHJhaXQgYnkgc3dhcHBpbmcgZGltZW5zaW9uc1xyXG4gIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXNldHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XHJcbiAgICBlbmNvZGluZyA9IHByZXNldC5lbmNvZGluZztcclxuICAgIGlmIChwcmVzZXQud2lkdGggPj0gc2l6ZSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgLy8gcHJlc2V0cyBhcmUgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gb2YgdnA4IGFzIGEgY29kZWNcclxuICAvLyBmb3Igb3RoZXIgY29kZWNzIHdlIGFkanVzdCB0aGUgbWF4Qml0cmF0ZSBpZiBubyBzcGVjaWZpYyB2aWRlb0VuY29kaW5nIGhhcyBiZWVuIHByb3ZpZGVkXHJcbiAgLy8gdXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRoZXNlIHdpdGggb25lcyB0aGF0IGFyZSBvcHRpbWl6ZWQgZm9yIHRoZWlyIHVzZSBjYXNlXHJcbiAgLy8gTk9URTogU1ZDIGNvZGVjIGJpdHJhdGVzIGFyZSBpbmNsdXNpdmUgb2YgYWxsIHNjYWxhYmlsaXR5IGxheWVycy4gd2hpbGVcclxuICAvLyBiaXRyYXRlIGZvciBub24tU1ZDIGNvZGVjcyBkb2VzIG5vdCBpbmNsdWRlIG90aGVyIHNpbXVsY2FzdCBsYXllcnMuXHJcbiAgaWYgKGNvZGVjKSB7XHJcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XHJcbiAgICAgIGNhc2UgJ2F2MSc6XHJcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XHJcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3ZwOSc6XHJcbiAgICAgICAgZW5jb2RpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyk7XHJcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjg1O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZW5jb2Rpbmc7XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpIHtcclxuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xyXG4gICAgcmV0dXJuIHByZXNldHNTY3JlZW5TaGFyZTtcclxuICB9XHJcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xyXG4gIGlmIChNYXRoLmFicyhhc3BlY3QgLSAxNi4wIC8gOSkgPCBNYXRoLmFicyhhc3BlY3QgLSA0LjAgLyAzKSkge1xyXG4gICAgcmV0dXJuIHByZXNldHMxNjk7XHJcbiAgfVxyXG4gIHJldHVybiBwcmVzZXRzNDM7XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpIHtcclxuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xyXG4gICAgcmV0dXJuIGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzKG9yaWdpbmFsKTtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgd2lkdGgsXHJcbiAgICBoZWlnaHRcclxuICB9ID0gb3JpZ2luYWw7XHJcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xyXG4gIGlmIChNYXRoLmFicyhhc3BlY3QgLSAxNi4wIC8gOSkgPCBNYXRoLmFicyhhc3BlY3QgLSA0LjAgLyAzKSkge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5O1xyXG4gIH1cclxuICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0MztcclxufVxyXG4vLyBwcmVzZXRzIHNob3VsZCBiZSBvcmRlcmVkIGJ5IGxvdywgbWVkaXVtLCBoaWdoXHJcbmZ1bmN0aW9uIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIHByZXNldHMsIHNvdXJjZUZyYW1lcmF0ZSkge1xyXG4gIGNvbnN0IGVuY29kaW5ncyA9IFtdO1xyXG4gIHByZXNldHMuZm9yRWFjaCgocHJlc2V0LCBpZHgpID0+IHtcclxuICAgIGlmIChpZHggPj0gdmlkZW9SaWRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XHJcbiAgICBjb25zdCByaWQgPSB2aWRlb1JpZHNbaWR4XTtcclxuICAgIGNvbnN0IGVuY29kaW5nID0ge1xyXG4gICAgICByaWQsXHJcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxyXG4gICAgICBtYXhCaXRyYXRlOiBwcmVzZXQuZW5jb2RpbmcubWF4Qml0cmF0ZVxyXG4gICAgfTtcclxuICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBzb3VyY2VGcmFtZXJhdGUgaXMgdGhlIGhpZ2hlc3QgZnJhbWVyYXRlIGFwcGxpZWQgYWNyb3NzIGFsbCBsYXllcnMgc28gdGhhdCB0aGVcclxuICAgIC8vIG9yaWdpbmFsIGVuY29kaW5nIGRvZXNuJ3QgZ2V0IGJ1bXBlZCB1bmludGVudGlvbmFsbHkgYnkgYW55IG9mIHRoZSBvdGhlciBsYXllcnNcclxuICAgIGNvbnN0IG1heEZyYW1lcmF0ZSA9IHNvdXJjZUZyYW1lcmF0ZSAmJiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlID8gTWF0aC5taW4oc291cmNlRnJhbWVyYXRlLCBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSA6IHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGU7XHJcbiAgICBpZiAobWF4RnJhbWVyYXRlKSB7XHJcbiAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IG1heEZyYW1lcmF0ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNhblNldFByaW9yaXR5ID0gaXNGaXJlRm94KCkgfHwgaWR4ID09PSAwO1xyXG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xyXG4gICAgICBlbmNvZGluZy5wcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcclxuICAgICAgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID0gcHJlc2V0LmVuY29kaW5nLnByaW9yaXR5O1xyXG4gICAgfVxyXG4gICAgZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xyXG4gIH0pO1xyXG4gIC8vIFJOIGlvcyBzaW11bGNhc3QgcmVxdWlyZXMgYWxsIHNhbWUgZnJhbWVyYXRlcy5cclxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcclxuICAgIGxldCB0b3BGcmFtZXJhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XHJcbiAgICAgIGlmICghdG9wRnJhbWVyYXRlKSB7XHJcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xyXG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcclxuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xyXG4gICAgZW5jb2RpbmdzLmZvckVhY2goZW5jb2RpbmcgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmIChlbmNvZGluZy5tYXhGcmFtZXJhdGUgIT0gdG9wRnJhbWVyYXRlKSB7XHJcbiAgICAgICAgaWYgKG5vdGlmeU9uY2UpIHtcclxuICAgICAgICAgIG5vdGlmeU9uY2UgPSBmYWxzZTtcclxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIlNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2V0dGluZyBmcmFtZXJhdGUgb2YgZW5jb2RpbmcgXFxcIlwiLmNvbmNhdCgoX2EgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCBcIlxcXCIgdG8gXCIpLmNvbmNhdCh0b3BGcmFtZXJhdGUpKTtcclxuICAgICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSB0b3BGcmFtZXJhdGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gZW5jb2RpbmdzO1xyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gc29ydFByZXNldHMocHJlc2V0cykge1xyXG4gIGlmICghcHJlc2V0cykgcmV0dXJuO1xyXG4gIHJldHVybiBwcmVzZXRzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgZW5jb2Rpbmc6IGFFbmNcclxuICAgIH0gPSBhO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBlbmNvZGluZzogYkVuY1xyXG4gICAgfSA9IGI7XHJcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID4gYkVuYy5tYXhCaXRyYXRlKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA8IGJFbmMubWF4Qml0cmF0ZSkgcmV0dXJuIC0xO1xyXG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XHJcbiAgICAgIHJldHVybiBhRW5jLm1heEZyYW1lcmF0ZSA+IGJFbmMubWF4RnJhbWVyYXRlID8gMSA6IC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSk7XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5jbGFzcyBTY2FsYWJpbGl0eU1vZGUge1xyXG4gIGNvbnN0cnVjdG9yKHNjYWxhYmlsaXR5TW9kZSkge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHNjYWxhYmlsaXR5TW9kZS5tYXRjaCgvXkwoXFxkKVQoXFxkKShofF9LRVl8X0tFWV9TSElGVCl7MCwxfSQvKTtcclxuICAgIGlmICghcmVzdWx0cykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFiaWxpdHkgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zcGF0aWFsID0gcGFyc2VJbnQocmVzdWx0c1sxXSk7XHJcbiAgICB0aGlzLnRlbXBvcmFsID0gcGFyc2VJbnQocmVzdWx0c1syXSk7XHJcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgIHN3aXRjaCAocmVzdWx0c1szXSkge1xyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgIGNhc2UgJ19LRVknOlxyXG4gICAgICAgIGNhc2UgJ19LRVlfU0hJRlQnOlxyXG4gICAgICAgICAgdGhpcy5zdWZmaXggPSByZXN1bHRzWzNdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIFwiTFwiLmNvbmNhdCh0aGlzLnNwYXRpYWwsIFwiVFwiKS5jb25jYXQodGhpcy50ZW1wb3JhbCkuY29uY2F0KChfYSA9IHRoaXMuc3VmZml4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHREZWdyYWRhdGlvblByZWZlcmVuY2UodHJhY2spIHtcclxuICAvLyBhIGZldyBvZiByZWFzb25zIHdlIGhhdmUgZGlmZmVyZW50IGRlZmF1bHQgcGF0aHM6XHJcbiAgLy8gMS4gd2l0aG91dCB0aGlzLCBDaHJvbWUgc2VlbXMgdG8gYWdncmVzc2l2ZWx5IHJlc2l6ZSB0aGUgU1ZDIHZpZGVvIHN0YXRpbmcgYHF1YWxpdHktbGltaXRhdGlvbjogYmFuZHdpZHRoYCBldmVuIHdoZW4gQlcgaXNuJ3QgYW4gaXNzdWVcclxuICAvLyAyLiBzaW5jZSB3ZSBhcmUgb3ZlcnJpZGluZyBjb250ZW50SGludCB0byBtb3Rpb24gKHRvIHdvcmthcm91bmQgTDFUMyBwdWJsaXNoaW5nKSwgaXQgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGRlZ3JhZGF0aW9uUHJlZmVyZW5jZSB0byBgYmFsYW5jZWRgXHJcbiAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCAmJiB1bndyYXBDb25zdHJhaW50KHRyYWNrLmNvbnN0cmFpbnRzLmhlaWdodCkgPj0gMTA4MCkge1xyXG4gICAgcmV0dXJuICdtYWludGFpbi1yZXNvbHV0aW9uJztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuICdiYWxhbmNlZCc7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyA9IDUwMDA7XHJcbmNsYXNzIExvY2FsVmlkZW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xyXG4gIGdldCBzZW5kZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xyXG4gIH1cclxuICBzZXQgc2VuZGVyKHNlbmRlcikge1xyXG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgaWYgKHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlKSB7XHJcbiAgICAgIHRoaXMuc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xyXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXHJcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcclxuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcclxuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XHJcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBUcmFjay5LaW5kLlZpZGVvLCBjb25zdHJhaW50cywgdXNlclByb3ZpZGVkVHJhY2ssIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gJ2JhbGFuY2VkJztcclxuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHN0YXRzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHNNYXAgPSBuZXcgTWFwKHN0YXRzLm1hcChzID0+IFtzLnJpZCwgc10pKTtcclxuICAgICAgaWYgKHRoaXMucHJldlN0YXRzKSB7XHJcbiAgICAgICAgbGV0IHRvdGFsQml0cmF0ZSA9IDA7XHJcbiAgICAgICAgc3RhdHNNYXAuZm9yRWFjaCgocywga2V5KSA9PiB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICBjb25zdCBwcmV2ID0gKF9hID0gdGhpcy5wcmV2U3RhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcclxuICAgICAgICAgIHRvdGFsQml0cmF0ZSArPSBjb21wdXRlQml0cmF0ZShzLCBwcmV2KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IHRvdGFsQml0cmF0ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNlbmRlckxvY2sgPSBuZXcgXygpO1xyXG4gIH1cclxuICBnZXQgaXNTaW11bGNhc3QoKSB7XHJcbiAgICBpZiAodGhpcy5zZW5kZXIgJiYgdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpLmVuY29kaW5ncy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcclxuICAgIGlmICghaXNXZWIoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBzYXZlIG9yaWdpbmFsIGVuY29kaW5nc1xyXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcclxuICAgIGNvbnN0IHBhcmFtcyA9IChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGFyYW1ldGVycygpO1xyXG4gICAgaWYgKHBhcmFtcykge1xyXG4gICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xyXG4gICAgfSwgbW9uaXRvckZyZXF1ZW5jeSk7XHJcbiAgfVxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCk7XHJcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5mb3JFYWNoKHRyYWNrSW5mbyA9PiB7XHJcbiAgICAgIHRyYWNrSW5mby5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgIH0pO1xyXG4gICAgc3VwZXIuc3RvcCgpO1xyXG4gIH1cclxuICBwYXVzZVVwc3RyZWFtKCkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIHBhdXNlVXBzdHJlYW06IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnBhdXNlVXBzdHJlYW1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xyXG4gICAgICB2YXIgX2Q7XHJcbiAgICAgIHlpZWxkIF9zdXBlci5wYXVzZVVwc3RyZWFtLmNhbGwodGhpcyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcclxuICAgICAgICAgIF9jID0gX2cudmFsdWU7XHJcbiAgICAgICAgICBfZSA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcclxuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XHJcbiAgICAgICAgZV8xID0ge1xyXG4gICAgICAgICAgZXJyb3I6IGVfMV8xXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXN1bWVVcHN0cmVhbSgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICByZXN1bWVVcHN0cmVhbToge1xyXG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucmVzdW1lVXBzdHJlYW1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xyXG4gICAgICB2YXIgX2Q7XHJcbiAgICAgIHlpZWxkIF9zdXBlci5yZXN1bWVVcHN0cmVhbS5jYWxsKHRoaXMpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xyXG4gICAgICAgICAgX2UgPSBmYWxzZTtcclxuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XHJcbiAgICAgICAgICB5aWVsZCAoX2QgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xyXG4gICAgICAgIGVfMiA9IHtcclxuICAgICAgICAgIGVycm9yOiBlXzJfMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbXV0ZSgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICBtdXRlOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5tdXRlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgbXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAvLyBhbHNvIHN0b3AgdGhlIHRyYWNrLCBzbyB0aGF0IGNhbWVyYSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxyXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIF9zdXBlci5tdXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICB1bm11dGUoKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgdW5tdXRlOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgdW5tdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVhY3F1aXJpbmcgY2FtZXJhIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIF9zdXBlci51bm11dGUuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldFRyYWNrTXV0ZWQobXV0ZWQpIHtcclxuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xyXG4gICAgZm9yIChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xyXG4gICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFNlbmRlclN0YXRzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XHJcbiAgICAgICAgICBjb25zdCB2cyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcclxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXHJcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxyXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXHJcbiAgICAgICAgICAgIGZyYW1lc1BlclNlY29uZDogdi5mcmFtZXNQZXJTZWNvbmQsXHJcbiAgICAgICAgICAgIGZyYW1lc1NlbnQ6IHYuZnJhbWVzU2VudCxcclxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXHJcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxyXG4gICAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxyXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogdi5wYWNrZXRzU2VudCxcclxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcclxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb246IHYucXVhbGl0eUxpbWl0YXRpb25SZWFzb24sXHJcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB2LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLFxyXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXHJcbiAgICAgICAgICAgIHJpZDogKF9hID0gdi5yaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHYuaWQsXHJcbiAgICAgICAgICAgIHJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudDogdi5yZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQsXHJcbiAgICAgICAgICAgIHRhcmdldEJpdHJhdGU6IHYudGFyZ2V0Qml0cmF0ZSxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIC8vwqBsb2NhdGUgdGhlIGFwcHJvcHJpYXRlIHJlbW90ZS1pbmJvdW5kLXJ0cCBpdGVtXHJcbiAgICAgICAgICBjb25zdCByID0gc3RhdHMuZ2V0KHYucmVtb3RlSWQpO1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgdnMuaml0dGVyID0gci5qaXR0ZXI7XHJcbiAgICAgICAgICAgIHZzLnBhY2tldHNMb3N0ID0gci5wYWNrZXRzTG9zdDtcclxuICAgICAgICAgICAgdnMucm91bmRUcmlwVGltZSA9IHIucm91bmRUcmlwVGltZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGl0ZW1zLnB1c2godnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBoaWdoZXN0IHJlcyBsYXllciBpcyBhbHdheXMgZmlyc3RcclxuICAgICAgaXRlbXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuICgoX2EgPSBiLmZyYW1lV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC0gKChfYiA9IGEuZnJhbWVXaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eSkge1xyXG4gICAgY29uc3QgcXVhbGl0aWVzID0gW107XHJcbiAgICBmb3IgKGxldCBxID0gVmlkZW9RdWFsaXR5LkxPVzsgcSA8PSBWaWRlb1F1YWxpdHkuSElHSDsgcSArPSAxKSB7XHJcbiAgICAgIHF1YWxpdGllcy5wdXNoKG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XHJcbiAgICAgICAgcXVhbGl0eTogcSxcclxuICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHlcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIHB1Ymxpc2hpbmcgcXVhbGl0eS4gbWF4IHF1YWxpdHkgXCIuY29uY2F0KG1heFF1YWxpdHkpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU1ZDQ29kZWModGhpcy5jb2RlYyksIHF1YWxpdGllcyk7XHJcbiAgfVxyXG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xyXG4gICAgICB2YXIgX2Q7XHJcbiAgICAgIGxldCBjb25zdHJhaW50cztcclxuICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7XHJcbiAgICAgICAgICB2aWRlbzogb3B0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyZWFtQ29uc3RyYWludHMudmlkZW8gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgY29uc3RyYWludHMgPSBzdHJlYW1Db25zdHJhaW50cy52aWRlbztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xyXG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcclxuICAgICAgICAgIF9lID0gZmFsc2U7XHJcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xyXG4gICAgICAgICAgaWYgKHNjLnNlbmRlciAmJiAoKF9kID0gc2Muc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgICAgc2MubWVkaWFTdHJlYW1UcmFjayA9IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpO1xyXG4gICAgICAgICAgICB5aWVsZCBzYy5zZW5kZXIucmVwbGFjZVRyYWNrKHNjLm1lZGlhU3RyZWFtVHJhY2spO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZV8zXzEpIHtcclxuICAgICAgICBlXzMgPSB7XHJcbiAgICAgICAgICBlcnJvcjogZV8zXzFcclxuICAgICAgICB9O1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3JfMSkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIHNldFByb2Nlc3Nvcjoge1xyXG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuc2V0UHJvY2Vzc29yXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHByb2Nlc3Nvcikge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICBsZXQgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYSwgZV80LCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIF9kLCBfZTtcclxuICAgICAgICB5aWVsZCBfc3VwZXIuc2V0UHJvY2Vzc29yLmNhbGwoX3RoaXMsIHByb2Nlc3Nvciwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpO1xyXG4gICAgICAgIGlmICgoX2QgPSBfdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wcm9jZXNzZWRUcmFjaykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMoX3RoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2g7IF9oID0geWllbGQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgX2MgPSBfaC52YWx1ZTtcclxuICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHNjID0gX2M7XHJcbiAgICAgICAgICAgICAgeWllbGQgKF9lID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVwbGFjZVRyYWNrKF90aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGVfNF8xKSB7XHJcbiAgICAgICAgICAgIGVfNCA9IHtcclxuICAgICAgICAgICAgICBlcnJvcjogZV80XzFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZyk7XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKHByZWZlcmVuY2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gcHJlZmVyZW5jZTtcclxuICAgICAgaWYgKHRoaXMuc2VuZGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBkZWdyYWRhdGlvblByZWZlcmVuY2UgdG8gXCIuY29uY2F0KHByZWZlcmVuY2UpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xyXG4gICAgICAgICAgcGFyYW1zLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA9IHByZWZlcmVuY2U7XHJcbiAgICAgICAgICB0aGlzLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgdGhpcy5sb2cud2FybihcImZhaWxlZCB0byBzZXQgZGVncmFkYXRpb25QcmVmZXJlbmNlXCIsIE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkU2ltdWxjYXN0VHJhY2soY29kZWMsIGVuY29kaW5ncykge1xyXG4gICAgaWYgKHRoaXMuc2ltdWxjYXN0Q29kZWNzLmhhcyhjb2RlYykpIHtcclxuICAgICAgdGhpcy5sb2cuZXJyb3IoXCJcIi5jb25jYXQoY29kZWMsIFwiIGFscmVhZHkgYWRkZWQsIHNraXBwaW5nIGFkZGluZyBzaW11bGNhc3QgY29kZWNcIiksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHtcclxuICAgICAgY29kZWMsXHJcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxyXG4gICAgICBzZW5kZXI6IHVuZGVmaW5lZCxcclxuICAgICAgZW5jb2RpbmdzXHJcbiAgICB9O1xyXG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3Muc2V0KGNvZGVjLCBzaW11bGNhc3RDb2RlY0luZm8pO1xyXG4gICAgcmV0dXJuIHNpbXVsY2FzdENvZGVjSW5mbztcclxuICB9XHJcbiAgc2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIoY29kZWMsIHNlbmRlcikge1xyXG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjKTtcclxuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XHJcbiAgICAvLyBicm93c2VyIHdpbGwgcmVlbmFibGUgZGlzYWJsZWQgY29kZWMvbGF5ZXJzIGFmdGVyIG5ldyBjb2RlYyBoYXMgYmVlbiBwdWJsaXNoZWQsXHJcbiAgICAvLyBzbyByZWZyZXNoIHN1YnNjcmliZWRDb2RlY3MgYWZ0ZXIgcHVibGlzaCBhIG5ldyBjb2RlY1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZWRDb2RlY3MpIHtcclxuICAgICAgICB0aGlzLnNldFB1Ymxpc2hpbmdDb2RlY3ModGhpcy5zdWJzY3JpYmVkQ29kZWNzKTtcclxuICAgICAgfVxyXG4gICAgfSwgcmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBTZXRzIGNvZGVjcyB0aGF0IHNob3VsZCBiZSBwdWJsaXNoaW5nLCByZXR1cm5zIG5ldyBjb2RlY3MgdGhhdCBoYXZlIG5vdCB5ZXRcclxuICAgKiBiZWVuIHB1Ymxpc2hlZFxyXG4gICAqL1xyXG4gIHNldFB1Ymxpc2hpbmdDb2RlY3MoY29kZWNzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGNvZGVjc18xLCBjb2RlY3NfMV8xO1xyXG4gICAgICB2YXIgX2IsIGVfNSwgX2MsIF9kO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGNvZGVjcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGNvZGVjcyxcclxuICAgICAgICBjdXJyZW50Q29kZWM6IHRoaXMuY29kZWNcclxuICAgICAgfSkpO1xyXG4gICAgICAvLyBvbmx5IGVuYWJsZSBzaW11bGNhc3QgY29kZWMgZm9yIHByZWZlcmVuY2UgY29kZWMgc2V0dGVkXHJcbiAgICAgIGlmICghdGhpcy5jb2RlYyAmJiBjb2RlY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhpc1NWQ0NvZGVjKGNvZGVjc1swXS5jb2RlYyksIGNvZGVjc1swXS5xdWFsaXRpZXMpO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN1YnNjcmliZWRDb2RlY3MgPSBjb2RlY3M7XHJcbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IFtdO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAoX2EgPSB0cnVlLCBjb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMoY29kZWNzKTsgY29kZWNzXzFfMSA9IHlpZWxkIGNvZGVjc18xLm5leHQoKSwgX2IgPSBjb2RlY3NfMV8xLmRvbmUsICFfYjsgX2EgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfZCA9IGNvZGVjc18xXzEudmFsdWU7XHJcbiAgICAgICAgICBfYSA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3QgY29kZWMgPSBfZDtcclxuICAgICAgICAgIGlmICghdGhpcy5jb2RlYyB8fCB0aGlzLmNvZGVjID09PSBjb2RlYy5jb2RlYykge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoaXNTVkNDb2RlYyhjb2RlYy5jb2RlYyksIGNvZGVjLnF1YWxpdGllcyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMuY29kZWMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInRyeSBzZXRQdWJsaXNoaW5nQ29kZWMgZm9yIFwiLmNvbmNhdChjb2RlYy5jb2RlYyksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mb1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvIHx8ICFzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBxIG9mIGNvZGVjLnF1YWxpdGllcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICBuZXdDb2RlY3MucHVzaChjb2RlYy5jb2RlYyk7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cnkgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlciBcIi5jb25jYXQoY29kZWMuY29kZWMpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgIHlpZWxkIHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciwgc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncywgY29kZWMucXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2ssIGlzU1ZDQ29kZWMoY29kZWMuY29kZWMpLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZV81XzEpIHtcclxuICAgICAgICBlXzUgPSB7XHJcbiAgICAgICAgICBlcnJvcjogZV81XzFcclxuICAgICAgICB9O1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIV9hICYmICFfYiAmJiAoX2MgPSBjb2RlY3NfMS5yZXR1cm4pKSB5aWVsZCBfYy5jYWxsKGNvZGVjc18xKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3Q29kZWNzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIFNldHMgbGF5ZXJzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmdcclxuICAgKi9cclxuICBzZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU3ZjLCBxdWFsaXRpZXMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgcXVhbGl0aWVzXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKCF0aGlzLnNlbmRlciB8fCAhdGhpcy5lbmNvZGluZ3MpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcih0aGlzLnNlbmRlciwgdGhpcy5lbmNvZGluZ3MsIHF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCBpc1N2YywgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XHJcbiAgICAgIGlmICghaXNNb2JpbGUoKSkgcmV0dXJuO1xyXG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzZW5kZXIsIHNlbmRlckVuY29kaW5ncywgcXVhbGl0aWVzLCBzZW5kZXJMb2NrLCBpc1NWQywgbG9nLCBsb2dDb250ZXh0KSB7XHJcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHNlbmRlckxvY2subG9jaygpO1xyXG4gICAgbG9nLmRlYnVnKCdzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xyXG4gICAgICBzZW5kZXIsXHJcbiAgICAgIHF1YWxpdGllcyxcclxuICAgICAgc2VuZGVyRW5jb2RpbmdzXHJcbiAgICB9KSk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgZW5jb2RpbmdzXHJcbiAgICAgIH0gPSBwYXJhbXM7XHJcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoICE9PSBzZW5kZXJFbmNvZGluZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVuY29kaW5ncyxcclxuICAgICAgICAgIHNlbmRlckVuY29kaW5nc1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgICAgY29uc3QgY2xvc2FibGVTcGF0aWFsID0gKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uLCAnMTMzJykgPiAwO1xyXG4gICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgIGlmIChjbG9zYWJsZVNwYXRpYWwgJiYgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSkge1xyXG4gICAgICAgIC8vIHN2YyBkeW5hY2FzdCBlbmNvZGluZ3NcclxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGVuY29kaW5nc1swXTtcclxuICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgY29uc3QgbW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlKTtcclxuICAgICAgICBsZXQgbWF4UXVhbGl0eSA9IFZpZGVvUXVhbGl0eSQxLk9GRjtcclxuICAgICAgICBxdWFsaXRpZXMuZm9yRWFjaChxID0+IHtcclxuICAgICAgICAgIGlmIChxLmVuYWJsZWQgJiYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eSQxLk9GRiB8fCBxLnF1YWxpdHkgPiBtYXhRdWFsaXR5KSkge1xyXG4gICAgICAgICAgICBtYXhRdWFsaXR5ID0gcS5xdWFsaXR5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChtYXhRdWFsaXR5ID09PSBWaWRlb1F1YWxpdHkkMS5PRkYpIHtcclxuICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIWVuY29kaW5nLmFjdGl2ZSB8fCBtb2RlLnNwYXRpYWwgIT09IG1heFF1YWxpdHkgKyAxKSB7XHJcbiAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbE1vZGUgPSBuZXcgU2NhbGFiaWxpdHlNb2RlKHNlbmRlckVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpO1xyXG4gICAgICAgICAgbW9kZS5zcGF0aWFsID0gbWF4UXVhbGl0eSArIDE7XHJcbiAgICAgICAgICBtb2RlLnN1ZmZpeCA9IG9yaWdpbmFsTW9kZS5zdWZmaXg7XHJcbiAgICAgICAgICBpZiAobW9kZS5zcGF0aWFsID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHN1ZmZpeCBmb3IgTDFUeFxyXG4gICAgICAgICAgICBtb2RlLnN1ZmZpeCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcclxuICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IE1hdGgucG93KDIsIDIgLSBtYXhRdWFsaXR5KTtcclxuICAgICAgICAgIGlmIChzZW5kZXJFbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSkge1xyXG4gICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gc2VuZGVyRW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAoZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ICogZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzU1ZDKSB7XHJcbiAgICAgICAgICBjb25zdCBoYXNFbmFibGVkRW5jb2RpbmcgPSBxdWFsaXRpZXMuc29tZShxID0+IHEuZW5hYmxlZCk7XHJcbiAgICAgICAgICBpZiAoaGFzRW5hYmxlZEVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgIHF1YWxpdGllcy5mb3JFYWNoKHEgPT4gcS5lbmFibGVkID0gdHJ1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNpbXVsY2FzdCBkeW5hY2FzdCBlbmNvZGluZ3NcclxuICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgbGV0IHJpZCA9IChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XHJcbiAgICAgICAgICBpZiAocmlkID09PSAnJykge1xyXG4gICAgICAgICAgICByaWQgPSAncSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCk7XHJcbiAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVhbGl0eSA9IHF1YWxpdGllcy5maW5kKHEgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcclxuICAgICAgICAgIGlmICghc3Vic2NyaWJlZFF1YWxpdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSAhPT0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcclxuICAgICAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBsYXllciBcIi5jb25jYXQoc3Vic2NyaWJlZFF1YWxpdHkucXVhbGl0eSwgXCIgdG8gXCIpLmNvbmNhdChlbmNvZGluZy5hY3RpdmUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnKSwgbG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgIC8vIEZpcmVGb3ggZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIGVuY29kaW5nLmFjdGl2ZSB0byBmYWxzZSwgc28gd2VcclxuICAgICAgICAgICAgLy8gaGF2ZSBhIHdvcmthcm91bmQgb2YgbG93ZXJpbmcgaXRzIGJpdHJhdGUgYW5kIHJlc29sdXRpb24gdG8gdGhlIG1pbi5cclxuICAgICAgICAgICAgaWYgKGlzRmlyZUZveCgpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xyXG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0ubWF4RnJhbWVSYXRlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSA0O1xyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IDEwO1xyXG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaGFzQ2hhbmdlZCkge1xyXG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XHJcbiAgICAgICAgbG9nLmRlYnVnKFwic2V0dGluZyBlbmNvZGluZ3NcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZW5jb2RpbmdzOiBwYXJhbXMuZW5jb2RpbmdzXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHlpZWxkIHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHVubG9jaygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZGVvUXVhbGl0eUZvclJpZChyaWQpIHtcclxuICBzd2l0Y2ggKHJpZCkge1xyXG4gICAgY2FzZSAnZic6XHJcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcclxuICAgIGNhc2UgJ2gnOlxyXG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5Lk1FRElVTTtcclxuICAgIGNhc2UgJ3EnOlxyXG4gICAgICByZXR1cm4gVmlkZW9RdWFsaXR5LkxPVztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHdpZHRoLCBoZWlnaHQsIGVuY29kaW5ncywgc3ZjKSB7XHJcbiAgLy8gZGVmYXVsdCB0byBhIHNpbmdsZSBsYXllciwgSFFcclxuICBpZiAoIWVuY29kaW5ncykge1xyXG4gICAgcmV0dXJuIFtuZXcgVmlkZW9MYXllcih7XHJcbiAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdILFxyXG4gICAgICB3aWR0aCxcclxuICAgICAgaGVpZ2h0LFxyXG4gICAgICBiaXRyYXRlOiAwLFxyXG4gICAgICBzc3JjOiAwXHJcbiAgICB9KV07XHJcbiAgfVxyXG4gIGlmIChzdmMpIHtcclxuICAgIC8vIHN2YyBsYXllcnNcclxuICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlO1xyXG4gICAgY29uc3Qgc20gPSBuZXcgU2NhbGFiaWxpdHlNb2RlKGVuY29kaW5nU00pO1xyXG4gICAgY29uc3QgbGF5ZXJzID0gW107XHJcbiAgICBjb25zdCByZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAxLjUgOiAyO1xyXG4gICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XHJcbiAgICAgIGxheWVycy5wdXNoKG5ldyBWaWRlb0xheWVyKHtcclxuICAgICAgICBxdWFsaXR5OiBNYXRoLm1pbihWaWRlb1F1YWxpdHkuSElHSCwgc20uc3BhdGlhbCAtIDEpIC0gaSxcclxuICAgICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoIC8gTWF0aC5wb3cocmVzUmF0aW8sIGkpKSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxyXG4gICAgICAgIGJpdHJhdGU6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlID8gTWF0aC5jZWlsKGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gTWF0aC5wb3coYml0cmF0ZXNSYXRpbywgaSkpIDogMCxcclxuICAgICAgICBzc3JjOiAwXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXllcnM7XHJcbiAgfVxyXG4gIHJldHVybiBlbmNvZGluZ3MubWFwKGVuY29kaW5nID0+IHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgY29uc3Qgc2NhbGUgPSAoX2EgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XHJcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZCgoX2IgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTtcclxuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XHJcbiAgICAgIHF1YWxpdHksXHJcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBzY2FsZSksXHJcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcclxuICAgICAgYml0cmF0ZTogKF9jID0gZW5jb2RpbmcubWF4Qml0cmF0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCxcclxuICAgICAgc3NyYzogMFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcclxuY29uc3QgcmVsaWFibGVEYXRhQ2hhbm5lbCA9ICdfcmVsaWFibGUnO1xyXG5jb25zdCBtaW5SZWNvbm5lY3RXYWl0ID0gMiAqIDEwMDA7XHJcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XHJcbmNvbnN0IHJlbGlhYmVSZWNlaXZlU3RhdGVUVEwgPSAzMDAwMDtcclxudmFyIFBDU3RhdGU7XHJcbihmdW5jdGlvbiAoUENTdGF0ZSkge1xyXG4gIFBDU3RhdGVbUENTdGF0ZVtcIk5ld1wiXSA9IDBdID0gXCJOZXdcIjtcclxuICBQQ1N0YXRlW1BDU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSAxXSA9IFwiQ29ubmVjdGVkXCI7XHJcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMl0gPSBcIkRpc2Nvbm5lY3RlZFwiO1xyXG4gIFBDU3RhdGVbUENTdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IDNdID0gXCJSZWNvbm5lY3RpbmdcIjtcclxuICBQQ1N0YXRlW1BDU3RhdGVbXCJDbG9zZWRcIl0gPSA0XSA9IFwiQ2xvc2VkXCI7XHJcbn0pKFBDU3RhdGUgfHwgKFBDU3RhdGUgPSB7fSkpO1xyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIFJUQ0VuZ2luZSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICBnZXQgaXNDbG9zZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNDbG9zZWQ7XHJcbiAgfVxyXG4gIGdldCBwZW5kaW5nUmVjb25uZWN0KCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5yZWNvbm5lY3RUaW1lb3V0O1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMucnRjQ29uZmlnID0ge307XHJcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xyXG4gICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XHJcbiAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XHJcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLk5ldztcclxuICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcclxuICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzID0ge307XHJcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgIHRoaXMucmVjb25uZWN0U3RhcnQgPSAwO1xyXG4gICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XHJcbiAgICAvKioga2VlcHMgdHJhY2sgb2YgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGhhcyBiZWVuIHRyaWVkICovXHJcbiAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDA7XHJcbiAgICAvKiogc3BlY2lmaWVzIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIHJldHJ5ICovXHJcbiAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IDE7XHJcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlID0gMTtcclxuICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyID0gbmV3IERhdGFQYWNrZXRCdWZmZXIoKTtcclxuICAgIHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlID0gbmV3IFRUTE1hcChyZWxpYWJlUmVjZWl2ZVN0YXRlVFRMKTtcclxuICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5uZWwgPSBfYSA9PiBfX2F3YWl0ZXIodGhpcywgW19hXSwgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIGNoYW5uZWxcclxuICAgICAgfSA9IF9yZWY7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlmICghY2hhbm5lbCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gcmVsaWFibGVEYXRhQ2hhbm5lbCkge1xyXG4gICAgICAgICAgX3RoaXMucmVsaWFibGVEQ1N1YiA9IGNoYW5uZWw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsLmxhYmVsID09PSBsb3NzeURhdGFDaGFubmVsKSB7XHJcbiAgICAgICAgICBfdGhpcy5sb3NzeURDU3ViID0gY2hhbm5lbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJvbiBkYXRhIGNoYW5uZWwgXCIuY29uY2F0KGNoYW5uZWwuaWQsIFwiLCBcIikuY29uY2F0KGNoYW5uZWwubGFiZWwpLCBfdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICBjaGFubmVsLm9ubWVzc2FnZSA9IF90aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2UgPSBtZXNzYWdlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc3BlY3QgaW5jb21pbmcgZGF0YSBtZXNzYWdlIG9yZGVyIGJ5IHByb2Nlc3NpbmcgbWVzc2FnZSBldmVudHMgb25lIGFmdGVyIHRoZSBvdGhlclxyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmRhdGFQcm9jZXNzTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gZGVjb2RlXHJcbiAgICAgICAgbGV0IGJ1ZmZlcjtcclxuICAgICAgICBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgIGJ1ZmZlciA9IG1lc3NhZ2UuZGF0YTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcclxuICAgICAgICAgIGJ1ZmZlciA9IHlpZWxkIG1lc3NhZ2UuZGF0YS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcigndW5zdXBwb3J0ZWQgZGF0YSB0eXBlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkcCA9IERhdGFQYWNrZXQuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShidWZmZXIpKTtcclxuICAgICAgICBpZiAoZHAuc2VxdWVuY2UgPiAwICYmIGRwLnBhcnRpY2lwYW50U2lkICE9PSAnJykge1xyXG4gICAgICAgICAgY29uc3QgbGFzdFNlcSA9IHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlLmdldChkcC5wYXJ0aWNpcGFudFNpZCk7XHJcbiAgICAgICAgICBpZiAobGFzdFNlcSAmJiBkcC5zZXF1ZW5jZSA8PSBsYXN0U2VxKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSBkdXBsaWNhdGUgb3Igb3V0LW9mLW9yZGVyIHBhY2tldHMgaW4gcmVsaWFibGUgY2hhbm5lbFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnJlbGlhYmxlUmVjZWl2ZWRTdGF0ZS5zZXQoZHAucGFydGljaXBhbnRTaWQsIGRwLnNlcXVlbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2EgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnc3BlYWtlcicpIHtcclxuICAgICAgICAgIC8vIGRpc3BhdGNoIHNwZWFrZXIgdXBkYXRlc1xyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCBkcC52YWx1ZS52YWx1ZS5zcGVha2Vycyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICgoKF9iID0gZHAudmFsdWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXNlKSA9PT0gJ3VzZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgYXBwbHlVc2VyRGF0YUNvbXBhdChkcCwgZHAudmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgZHApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmhhbmRsZURhdGFFcnJvciA9IGV2ZW50ID0+IHtcclxuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/ICdsb3NzeScgOiAncmVsaWFibGUnO1xyXG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFcnJvckV2ZW50ICYmIGV2ZW50LmVycm9yKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgZXJyb3JcclxuICAgICAgICB9ID0gZXZlbnQuZXJyb3I7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQsIFwiOiBcIikuY29uY2F0KGV2ZW50Lm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwiVW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGV2ZW50XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdyA9IGV2ZW50ID0+IHtcclxuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcbiAgICAgIGNvbnN0IGNoYW5uZWxLaW5kID0gY2hhbm5lbC5tYXhSZXRyYW5zbWl0cyA9PT0gMCA/IERhdGFQYWNrZXRfS2luZC5MT1NTWSA6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRTtcclxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoY2hhbm5lbEtpbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIHdlYnNvY2tldCByZWNvbm5lY3QgYmVoYXZpb3IuIGlmIHdlYnNvY2tldCBpcyBpbnRlcnJ1cHRlZCwgYW5kIHRoZSBQZWVyQ29ubmVjdGlvblxyXG4gICAgLy8gY29udGludWVzIHRvIHdvcmssIHdlIGNhbiByZWNvbm5lY3QgdG8gd2Vic29ja2V0IHRvIGNvbnRpbnVlIHRoZSBzZXNzaW9uXHJcbiAgICAvLyBhZnRlciBhIG51bWJlciBvZiByZXRyaWVzLCB3ZSdsbCBjbG9zZSBhbmQgZ2l2ZSB1cCBwZXJtYW5lbnRseVxyXG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0ID0gKGNvbm5lY3Rpb24sIGRpc2Nvbm5lY3RSZWFzb24pID0+IHtcclxuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9nLndhcm4oXCJcIi5jb25jYXQoY29ubmVjdGlvbiwgXCIgZGlzY29ubmVjdGVkXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9PT0gMCkge1xyXG4gICAgICAgIC8vIG9ubHkgcmVzZXQgc3RhcnQgdGltZSBvbiB0aGUgZmlyc3QgdHJ5XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGlzY29ubmVjdCA9IGR1cmF0aW9uID0+IHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlY292ZXIgY29ubmVjdGlvbiBhZnRlciBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgXCIgYXR0ZW1wdHMsIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXMuIGdpdmluZyB1cFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHRoaXMucmVjb25uZWN0U3RhcnQ7XHJcbiAgICAgIGxldCBkZWxheSA9IHRoaXMuZ2V0TmV4dFJldHJ5RGVsYXkoe1xyXG4gICAgICAgIGVsYXBzZWRNczogZHVyYXRpb24sXHJcbiAgICAgICAgcmV0cnlDb3VudDogdGhpcy5yZWNvbm5lY3RBdHRlbXB0c1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XHJcbiAgICAgICAgZGlzY29ubmVjdChkdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjb25uZWN0aW9uID09PSBsZWF2ZVJlY29ubmVjdCkge1xyXG4gICAgICAgIGRlbGF5ID0gMDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY29ubmVjdGluZyBpbiBcIi5jb25jYXQoZGVsYXksIFwibXNcIiksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XHJcbiAgICAgIGlmICh0aGlzLnRva2VuICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcclxuICAgICAgICAvLyB0b2tlbiBtYXkgaGF2ZSBiZWVuIHJlZnJlc2hlZCwgd2UgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhlIHJlZ2lvblVybFByb3ZpZGVyXHJcbiAgICAgICAgLy8gc2luY2UgdGhlIGN1cnJlbnQgZW5naW5lIG1heSBoYXZlIGluaGVyaXRlZCBhIHJlZ2lvbmFsIHVybFxyXG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlVG9rZW4odGhpcy50b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoZGlzY29ubmVjdFJlYXNvbikuZmluYWxseSgoKSA9PiB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQpLCBkZWxheSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy53YWl0Rm9yUmVzdGFydGVkID0gKCkgPT4ge1xyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9uUmVzdGFydGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZCA9ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xyXG4gICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XHJcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyA9IGtpbmQgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpO1xyXG4gICAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdHVzICE9PSB0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xyXG4gICAgICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMuc2V0KGtpbmQsIHN0YXR1cyk7XHJcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaXNCdWZmZXJTdGF0dXNMb3cgPSBraW5kID0+IHtcclxuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcclxuICAgICAgaWYgKGRjKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xyXG4gICAgICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIuYWxpZ25CdWZmZXJlZEFtb3VudChkYy5idWZmZXJlZEFtb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYy5idWZmZXJlZEFtb3VudCA8PSBkYy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSA9ICgpID0+IHtcclxuICAgICAgLy8gaW4gY2FzZSB0aGUgZW5naW5lIGlzIGN1cnJlbnRseSByZWNvbm5lY3RpbmcsIGF0dGVtcHQgYSByZWNvbm5lY3QgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGJyb3dzZXIgc3RhdGUgaGFzIGNoYW5nZWQgdG8gJ29uTGluZSdcclxuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xyXG4gICAgICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0UmVjb25uZWN0KFJlY29ubmVjdFJlYXNvbi5SUl9TSUdOQUxfRElTQ09OTkVDVEVEKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IG9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuRW5naW5lKTtcclxuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IHtcclxuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCh1bmRlZmluZWQsIHRoaXMubG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLmNsaWVudC5zaWduYWxMYXRlbmN5ID0gdGhpcy5vcHRpb25zLmV4cFNpZ25hbExhdGVuY3k7XHJcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XHJcbiAgICB0aGlzLnJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcclxuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5kY0J1ZmZlclN0YXR1cyA9IG5ldyBNYXAoW1tEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWVdLCBbRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlXV0pO1xyXG4gICAgdGhpcy5jbGllbnQub25QYXJ0aWNpcGFudFVwZGF0ZSA9IHVwZGF0ZXMgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB1cGRhdGVzKTtcclxuICAgIHRoaXMuY2xpZW50Lm9uQ29ubmVjdGlvblF1YWxpdHkgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB1cGRhdGUpO1xyXG4gICAgdGhpcy5jbGllbnQub25Sb29tVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB1cGRhdGUpO1xyXG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25FcnJvciA9IHJlc3AgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCByZXNwKTtcclxuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcclxuICAgIHRoaXMuY2xpZW50Lm9uU3BlYWtlcnNDaGFuZ2VkID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHVwZGF0ZSk7XHJcbiAgICB0aGlzLmNsaWVudC5vblN0cmVhbVN0YXRlVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHVwZGF0ZSk7XHJcbiAgICB0aGlzLmNsaWVudC5vblJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXF1ZXN0UmVzcG9uc2UsIHJlc3BvbnNlKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByb29tOiAoX2IgPSAoX2EgPSB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lLFxyXG4gICAgICByb29tSUQ6IChfZCA9IChfYyA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mucm9vbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnNpZCxcclxuICAgICAgcGFydGljaXBhbnQ6IChfZiA9IChfZSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5pZGVudGl0eSxcclxuICAgICAgcElEOiB0aGlzLnBhcnRpY2lwYW50U2lkXHJcbiAgICB9O1xyXG4gIH1cclxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnVybCA9IHVybDtcclxuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgICB0aGlzLnNpZ25hbE9wdHMgPSBvcHRzO1xyXG4gICAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IG9wdHMubWF4UmV0cmllcztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmpvaW5BdHRlbXB0cyArPSAxO1xyXG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcclxuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNsaWVudC5qb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcclxuICAgICAgICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlID0gam9pblJlc3BvbnNlO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIG9mZmVyXHJcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJQcmltYXJ5IHx8IGpvaW5SZXNwb25zZS5mYXN0UHVibGlzaCkge1xyXG4gICAgICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uID0gam9pblJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgam9pblJlc3BvbnNlKTtcclxuICAgICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcclxuICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5qb2luQXR0ZW1wdHMsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5tYXhKb2luQXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5qb2luQXR0ZW1wdHMgPCB0aGlzLm1heEpvaW5BdHRlbXB0cykge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBjbG9zZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xyXG4gICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmpvaW5BdHRlbXB0cyA9IDA7XHJcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkNsb3NpbmcpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5kZXJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcclxuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2xlYW51cFBlZXJDb25uZWN0aW9ucygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgeWllbGQgKF9hID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xyXG4gICAgICB0aGlzLnBjTWFuYWdlciA9IHVuZGVmaW5lZDtcclxuICAgICAgY29uc3QgZGNDbGVhbnVwID0gZGMgPT4ge1xyXG4gICAgICAgIGlmICghZGMpIHJldHVybjtcclxuICAgICAgICBkYy5jbG9zZSgpO1xyXG4gICAgICAgIGRjLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xyXG4gICAgICAgIGRjLm9uY2xvc2UgPSBudWxsO1xyXG4gICAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XHJcbiAgICAgICAgZGMub25lcnJvciA9IG51bGw7XHJcbiAgICAgICAgZGMub25tZXNzYWdlID0gbnVsbDtcclxuICAgICAgICBkYy5vbm9wZW4gPSBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDKTtcclxuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XHJcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlREMpO1xyXG4gICAgICBkY0NsZWFudXAodGhpcy5yZWxpYWJsZURDU3ViKTtcclxuICAgICAgdGhpcy5sb3NzeURDID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmxvc3N5RENTdWIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMucmVsaWFibGVEQyA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5yZWxpYWJsZURDU3ViID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLnJlbGlhYmxlTWVzc2FnZUJ1ZmZlciA9IG5ldyBEYXRhUGFja2V0QnVmZmVyKCk7XHJcbiAgICAgIHRoaXMucmVsaWFibGVEYXRhU2VxdWVuY2UgPSAxO1xyXG4gICAgICB0aGlzLnJlbGlhYmxlUmVjZWl2ZWRTdGF0ZS5jbGVhcigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNsZWFudXBDbGllbnQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLmNsaWVudC5jbG9zZSgpO1xyXG4gICAgICB0aGlzLmNsaWVudC5yZXNldENhbGxiYWNrcygpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZFRyYWNrKHJlcSkge1xyXG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdKSB7XHJcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBjb25zdCBwdWJsaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XHJcbiAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uVGltZW91dCkpO1xyXG4gICAgICB9LCAxMDAwMCk7XHJcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdID0ge1xyXG4gICAgICAgIHJlc29sdmU6IGluZm8gPT4ge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHB1YmxpY2F0aW9uVGltZW91dCk7XHJcbiAgICAgICAgICByZXNvbHZlKGluZm8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVqZWN0OiAoKSA9PiB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NhbmNlbGxlZCBwdWJsaWNhdGlvbiBieSBjYWxsaW5nIHVucHVibGlzaCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRBZGRUcmFjayhyZXEpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgc2VuZGVyIGZyb20gUGVlckNvbm5lY3Rpb24sIHJldHVybmluZyB0cnVlIGlmIGl0IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseVxyXG4gICAqIGFuZCBhIG5lZ290aWF0aW9uIGlzIG5lY2Vzc2FyeVxyXG4gICAqIEBwYXJhbSBzZW5kZXJcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgaWYgKHNlbmRlci50cmFjayAmJiB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByZWplY3RcclxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF07XHJcbiAgICAgIGlmIChyZWplY3QpIHtcclxuICAgICAgICByZWplY3QoKTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucGNNYW5hZ2VyLnJlbW92ZVRyYWNrKHNlbmRlcik7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdmYWlsZWQgdG8gcmVtb3ZlIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgZXJyb3I6IGVcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICB1cGRhdGVNdXRlU3RhdHVzKHRyYWNrU2lkLCBtdXRlZCkge1xyXG4gICAgdGhpcy5jbGllbnQuc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpO1xyXG4gIH1cclxuICBnZXQgZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMucmVsaWFibGVEQ1N1YikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGU7XHJcbiAgfVxyXG4gIGdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICBzZXRSZWdpb25VcmxQcm92aWRlcihwcm92aWRlcikge1xyXG4gICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gIH1cclxuICBjb25maWd1cmUoam9pblJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAvLyBhbHJlYWR5IGNvbmZpZ3VyZWRcclxuICAgICAgaWYgKHRoaXMucGNNYW5hZ2VyICYmIHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcclxuICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihqb2luUmVzcG9uc2UpO1xyXG4gICAgICB0aGlzLnBjTWFuYWdlciA9IG5ldyBQQ1RyYW5zcG9ydE1hbmFnZXIocnRjQ29uZmlnLCBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnksIHRoaXMubG9nZ2VyT3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5UcmFuc3BvcnRzQ3JlYXRlZCwgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLCB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyKTtcclxuICAgICAgdGhpcy5wY01hbmFnZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcclxuICAgICAgICB0aGlzLmNsaWVudC5zZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wY01hbmFnZXIub25QdWJsaXNoZXJPZmZlciA9IG9mZmVyID0+IHtcclxuICAgICAgICB0aGlzLmNsaWVudC5zZW5kT2ZmZXIob2ZmZXIpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkRhdGFDaGFubmVsID0gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbDtcclxuICAgICAgdGhpcy5wY01hbmFnZXIub25TdGF0ZUNoYW5nZSA9IChjb25uZWN0aW9uU3RhdGUsIHB1Ymxpc2hlclN0YXRlLCBzdWJzY3JpYmVyU3RhdGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByaW1hcnkgUEMgc3RhdGUgY2hhbmdlZCBcIi5jb25jYXQoY29ubmVjdGlvblN0YXRlKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICBpZiAoWydjbG9zZWQnLCAnZGlzY29ubmVjdGVkJywgJ2ZhaWxlZCddLmluY2x1ZGVzKHB1Ymxpc2hlclN0YXRlKSkge1xyXG4gICAgICAgICAgLy8gcmVzZXQgcHVibGlzaGVyIGNvbm5lY3Rpb24gcHJvbWlzZVxyXG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcclxuICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSB0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuTmV3O1xyXG4gICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XHJcbiAgICAgICAgICBpZiAoc2hvdWxkRW1pdCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCkge1xyXG4gICAgICAgICAgLy8gb24gU2FmYXJpLCBQZWVyQ29ubmVjdGlvbiB3aWxsIHN3aXRjaCB0byAnZGlzY29ubmVjdGVkJyBkdXJpbmcgcmVuZWdvdGlhdGlvblxyXG4gICAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncGVlcmNvbm5lY3Rpb24gZmFpbGVkJywgc3Vic2NyaWJlclN0YXRlID09PSAnZmFpbGVkJyA/IFJlY29ubmVjdFJlYXNvbi5SUl9TVUJTQ1JJQkVSX0ZBSUxFRCA6IFJlY29ubmVjdFJlYXNvbi5SUl9QVUJMSVNIRVJfRkFJTEVEKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGV0ZWN0IGNhc2VzIHdoZXJlIGJvdGggc2lnbmFsIGNsaWVudCBhbmQgcGVlciBjb25uZWN0aW9uIGFyZSBzZXZlcmVkIGFuZCBhc3N1bWUgdGhhdCB1c2VyIGhhcyBsb3N0IG5ldHdvcmsgY29ubmVjdGlvblxyXG4gICAgICAgIGNvbnN0IGlzU2lnbmFsU2V2ZXJlZCA9IHRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkIHx8IHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcclxuICAgICAgICBjb25zdCBpc1BDU2V2ZXJlZCA9IFtQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCwgUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HLCBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRF0uaW5jbHVkZXMoY29ubmVjdGlvblN0YXRlKTtcclxuICAgICAgICBpZiAoaXNTaWduYWxTZXZlcmVkICYmIGlzUENTZXZlcmVkICYmICF0aGlzLl9pc0Nsb3NlZCkge1xyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk9mZmxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSBldiA9PiB7XHJcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgZXYudHJhY2ssIGV2LnN0cmVhbXNbMF0sIGV2LnJlY2VpdmVyKTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKCFzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbCgoX2IgPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnByb3RvY29sKSkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpIHtcclxuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XHJcbiAgICB0aGlzLmNsaWVudC5vbkFuc3dlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgc2VydmVyIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGVcclxuICAgICAgfSkpO1xyXG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5zZXRQdWJsaXNoZXJBbnN3ZXIoc2QpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBhZGQgY2FuZGlkYXRlIG9uIHRyaWNrbGVcclxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdnb3QgSUNFIGNhbmRpZGF0ZSBmcm9tIHBlZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBjYW5kaWRhdGUsXHJcbiAgICAgICAgdGFyZ2V0XHJcbiAgICAgIH0pKTtcclxuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICAvLyB3aGVuIHNlcnZlciBjcmVhdGVzIGFuIG9mZmVyIGZvciB0aGUgY2xpZW50XHJcbiAgICB0aGlzLmNsaWVudC5vbk9mZmVyID0gc2QgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QpO1xyXG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHJlcyA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHRyYWNrUHVibGlzaGVkUmVzcG9uc2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBjaWQ6IHJlcy5jaWQsXHJcbiAgICAgICAgdHJhY2s6IChfYSA9IHJlcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZFxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmICghdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF0pIHtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIm1pc3NpbmcgdHJhY2sgcmVzb2x2ZXIgZm9yIFwiLmNvbmNhdChyZXMuY2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBjaWQ6IHJlcy5jaWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByZXNvbHZlXHJcbiAgICAgIH0gPSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXTtcclxuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xyXG4gICAgICByZXNvbHZlKHJlcy50cmFjayk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSByZXNwb25zZSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHJlc3BvbnNlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkID0gdHJhY2tTaWQgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrU2lkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9IHRva2VuID0+IHtcclxuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQsIG11dGVkKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25Sb29tTW92ZWQgPSByZXMgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHRoaXMucGFydGljaXBhbnRTaWQgPSAoX2EgPSByZXMucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWQ7XHJcbiAgICAgIGlmICh0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkge1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlLnJvb20gPSByZXMucm9vbTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUm9vbU1vdmVkLCByZXMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uQ2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uTGVhdmUgPSBsZWF2ZSA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdjbGllbnQgbGVhdmUgcmVxdWVzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIHJlYXNvbjogbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvblxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmIChsZWF2ZS5yZWdpb25zICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgcmVnaW9ucycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5zZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMobGVhdmUucmVnaW9ucyk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChsZWF2ZS5hY3Rpb24pIHtcclxuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uRElTQ09OTkVDVDpcclxuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIGxlYXZlID09PSBudWxsIHx8IGxlYXZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZS5yZWFzb24pO1xyXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLlJFQ09OTkVDVDpcclxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcclxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVTVU1FOlxyXG4gICAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbmV4dCBhdHRlbXB0XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBtYWtlUlRDQ29uZmlndXJhdGlvbihzZXJ2ZXJSZXNwb25zZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcnRjQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ydGNDb25maWcpO1xyXG4gICAgaWYgKChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmUyZWVFbmFibGVkKSB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdFMkVFIC0gc2V0dGluZyB1cCB0cmFuc3BvcnRzIHdpdGggaW5zZXJ0YWJsZSBzdHJlYW1zJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgLy8gIHRoaXMgbWFrZXMgc3VyZSB0aGF0IG5vIGRhdGEgaXMgc2VudCBiZWZvcmUgdGhlIHRyYW5zZm9ybXMgYXJlIHJlYWR5XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgcnRjQ29uZmlnLmVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyB1cGRhdGUgSUNFIHNlcnZlcnMgYmVmb3JlIGNyZWF0aW5nIFBlZXJDb25uZWN0aW9uXHJcbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycyAmJiAhcnRjQ29uZmlnLmljZVNlcnZlcnMpIHtcclxuICAgICAgY29uc3QgcnRjSWNlU2VydmVycyA9IFtdO1xyXG4gICAgICBzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzLmZvckVhY2goaWNlU2VydmVyID0+IHtcclxuICAgICAgICBjb25zdCBydGNJY2VTZXJ2ZXIgPSB7XHJcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJsc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGljZVNlcnZlci51c2VybmFtZSkgcnRjSWNlU2VydmVyLnVzZXJuYW1lID0gaWNlU2VydmVyLnVzZXJuYW1lO1xyXG4gICAgICAgIGlmIChpY2VTZXJ2ZXIuY3JlZGVudGlhbCkge1xyXG4gICAgICAgICAgcnRjSWNlU2VydmVyLmNyZWRlbnRpYWwgPSBpY2VTZXJ2ZXIuY3JlZGVudGlhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcnRjSWNlU2VydmVycy5wdXNoKHJ0Y0ljZVNlcnZlcik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBydGNDb25maWcuaWNlU2VydmVycyA9IHJ0Y0ljZVNlcnZlcnM7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbiAmJiBzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uLmZvcmNlUmVsYXkgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRU5BQkxFRCkge1xyXG4gICAgICBydGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5ID0gJ3JlbGF5JztcclxuICAgIH1cclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJ0Y0NvbmZpZy5zZHBTZW1hbnRpY3MgPSAndW5pZmllZC1wbGFuJztcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHJ0Y0NvbmZpZy5jb250aW51YWxHYXRoZXJpbmdQb2xpY3kgPSAnZ2F0aGVyX2NvbnRpbnVhbGx5JztcclxuICAgIHJldHVybiBydGNDb25maWc7XHJcbiAgfVxyXG4gIGNyZWF0ZURhdGFDaGFubmVscygpIHtcclxuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gY2xlYXIgb2xkIGRhdGEgY2hhbm5lbCBjYWxsYmFja3MgaWYgcmVjcmVhdGVcclxuICAgIGlmICh0aGlzLmxvc3N5REMpIHtcclxuICAgICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IG51bGw7XHJcbiAgICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnJlbGlhYmxlREMpIHtcclxuICAgICAgdGhpcy5yZWxpYWJsZURDLm9ubWVzc2FnZSA9IG51bGw7XHJcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIGNyZWF0ZSBkYXRhIGNoYW5uZWxzXHJcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XHJcbiAgICAgIG9yZGVyZWQ6IGZhbHNlLFxyXG4gICAgICBtYXhSZXRyYW5zbWl0czogMFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnJlbGlhYmxlREMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChyZWxpYWJsZURhdGFDaGFubmVsLCB7XHJcbiAgICAgIG9yZGVyZWQ6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLy8gYWxzbyBoYW5kbGUgbWVzc2FnZXMgb3ZlciB0aGUgcHViIGNoYW5uZWwsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG4gICAgdGhpcy5sb3NzeURDLm9ubWVzc2FnZSA9IHRoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XHJcbiAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcclxuICAgIC8vIGhhbmRsZSBkYXRhY2hhbm5lbCBlcnJvcnNcclxuICAgIHRoaXMubG9zc3lEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XHJcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xyXG4gICAgLy8gc2V0IHVwIGRjIGJ1ZmZlciB0aHJlc2hvbGQsIHNldCB0byA2NGtCIChvdGhlcndpc2UgMCBieSBkZWZhdWx0KVxyXG4gICAgdGhpcy5sb3NzeURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XHJcbiAgICB0aGlzLnJlbGlhYmxlREMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcclxuICAgIC8vIGhhbmRsZSBidWZmZXIgYW1vdW50IGxvdyBldmVudHNcclxuICAgIHRoaXMubG9zc3lEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcclxuICAgIHRoaXMucmVsaWFibGVEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcclxuICB9XHJcbiAgY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcclxuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xyXG4gICAgICAgIHJldHVybiBzZW5kZXI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyID0geWllbGQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgLy8gc3RvcmUgUlRDUnRwU2VuZGVyXHJcbiAgICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN1cHBvcnRzQWRkVHJhY2soKSkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnQ2Fubm90IHN0cmVhbSBvbiB0aGlzIGRldmljZScpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcclxuICAgICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XHJcbiAgICAgICAgc3RyZWFtcy5wdXNoKHRyYWNrLm1lZGlhU3RyZWFtKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgIHRyYWNrLmNvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcclxuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXHJcbiAgICAgICAgc3RyZWFtc1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XHJcbiAgICAgIH1cclxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxyXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XHJcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdCA9IHtcclxuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seSdcclxuICAgICAgfTtcclxuICAgICAgaWYgKGVuY29kaW5ncykge1xyXG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cclxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcihzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xyXG4gICAgICBpZiAoIW9wdHMudmlkZW9Db2RlYykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XHJcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBpcyBjbG9zZWQnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhY2sodHJhY2spO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcclxuICAgICAgaWYgKHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCkge1xyXG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignYWxyZWFkeSBhdHRlbXB0aW5nIHJlY29ubmVjdCwgcmV0dXJuaW5nIGVhcmx5JywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCgoX2EgPSB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN1bWVDb25uZWN0aW9uKSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5ESVNBQkxFRCB8fFxyXG4gICAgICAvLyBzaWduYWxpbmcgc3RhdGUgY291bGQgY2hhbmdlIHRvIGNsb3NlZCBkdWUgdG8gaGFyZHdhcmUgc2xlZXBcclxuICAgICAgLy8gdGhvc2UgY29ubmVjdGlvbnMgY2Fubm90IGJlIHJlc3VtZWRcclxuICAgICAgKChfYyA9IChfYiA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY3VycmVudFN0YXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBQQ1RyYW5zcG9ydFN0YXRlLk5FVykgPT09IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSB7XHJcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCkge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcclxuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcclxuICAgICAgICBsZXQgcmVjb3ZlcmFibGUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVucmVjb3ZlcmFibGUgZXJyb3InLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIC8vIHVucmVjb3ZlcmFibGVcclxuICAgICAgICAgIHJlY292ZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmICghKGUgaW5zdGFuY2VvZiBTaWduYWxSZWNvbm5lY3RFcnJvcikpIHtcclxuICAgICAgICAgIC8vIGNhbm5vdCByZXN1bWVcclxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdyZWNvbm5lY3QnLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydCwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0TmV4dFJldHJ5RGVsYXkoY29udGV4dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVjb25uZWN0UG9saWN5Lm5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdGhpcy5sb2cud2FybignZW5jb3VudGVyZWQgZXJyb3IgaW4gcmVjb25uZWN0IHBvbGljeScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGVycm9yOiBlXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8vIGVycm9yIGluIHVzZXIgY29kZSB3aXRoIHByb3ZpZGVkIHJlY29ubmVjdCBwb2xpY3ksIHN0b3AgcmVjb25uZWN0aW5nXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmVzdGFydENvbm5lY3Rpb24ocmVnaW9uVXJsKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XHJcbiAgICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cclxuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJyZWNvbm5lY3RpbmcsIGF0dGVtcHQ6IFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGluZyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuc2VuZExlYXZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xyXG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cENsaWVudCgpO1xyXG4gICAgICAgIGxldCBqb2luUmVzcG9uc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghdGhpcy5zaWduYWxPcHRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2F0dGVtcHRlZCBjb25uZWN0aW9uIHJlc3RhcnQsIHdpdGhvdXQgc2lnbmFsIG9wdGlvbnMgcHJlc2VudCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gaW4gY2FzZSBhIHJlZ2lvblVybCBpcyBwYXNzZWQsIHRoZSByZWdpb24gVVJMIHRha2VzIHByZWNlZGVuY2VcclxuICAgICAgICAgIGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuam9pbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xyXG4gICAgICAgICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsaWVudC5zZXRSZWNvbm5lY3RlZCgpO1xyXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIGpvaW5SZXNwb25zZSk7XHJcbiAgICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xyXG4gICAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXHJcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldEF0dGVtcHRzKCk7XHJcbiAgICAgICAgLy8gcmVjb25uZWN0IHN1Y2Nlc3NcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGVkKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBuZXh0UmVnaW9uVXJsID0geWllbGQgKF9iID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XHJcbiAgICAgICAgaWYgKG5leHRSZWdpb25VcmwpIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydENvbm5lY3Rpb24obmV4dFJlZ2lvblVybCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIG5vIG1vcmUgcmVnaW9ucyB0byB0cnkgKG9yIHdlJ3JlIG5vdCBvbiBjbG91ZClcclxuICAgICAgICAgIChfYyA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNldEF0dGVtcHRzKCk7XHJcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXN1bWVDb25uZWN0aW9uKHJlYXNvbikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XHJcbiAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXHJcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyB0cmlnZ2VyIHB1Ymxpc2hlciByZWNvbm5lY3RcclxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgYW5kIHN1YnNjcmliZXIgY29ubmVjdGlvbnMgdW5zZXQnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxvZy5pbmZvKFwicmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24sIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1pbmcpO1xyXG4gICAgICBsZXQgcmVzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcclxuICAgICAgICByZXMgPSB5aWVsZCB0aGlzLmNsaWVudC5yZWNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMucGFydGljaXBhbnRTaWQsIHJlYXNvbik7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcihlcnJvci5tZXNzYWdlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QpIHtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IobWVzc2FnZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQpO1xyXG4gICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xyXG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnVwZGF0ZUNvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcclxuICAgICAgICBpZiAodGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpIHtcclxuICAgICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlLnNlcnZlckluZm8gPSByZXMuc2VydmVySW5mbztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignRGlkIG5vdCByZWNlaXZlIHJlY29ubmVjdCByZXNwb25zZScsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcclxuICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XHJcbiAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcclxuICAgICAgLy8gcmUtY2hlY2sgc2lnbmFsIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgZW5naW5lIGFzIHJlc3VtZWRcclxuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xyXG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XHJcbiAgICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXHJcbiAgICAgIC8vIChmb3Igc2FmYXJpIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ2ODgpXHJcbiAgICAgIGlmICgoKF9hID0gdGhpcy5yZWxpYWJsZURDKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJyAmJiB0aGlzLnJlbGlhYmxlREMuaWQgPT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMubGFzdE1lc3NhZ2VTZXEpIHtcclxuICAgICAgICB0aGlzLnJlc2VuZFJlbGlhYmxlTWVzc2FnZXNGb3JSZXN1bWUocmVzLmxhc3RNZXNzYWdlU2VxKTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZXN1bWUgc3VjY2Vzc1xyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdW1lZCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dCwgYWJvcnRDb250cm9sbGVyKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgd2FpdEZvclBDUmVjb25uZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3dhaXRpbmcgZm9yIHBlZXIgY29ubmVjdGlvbiB0byByZWNvbm5lY3QnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHNsZWVwKG1pblJlY29ubmVjdFdhaXQpOyAvLyBGSVhNRSBzZXRUaW1lb3V0IGFnYWluIG5vdCBpZGVhbCBmb3IgYSBjb25uZWN0aW9uIGNyaXRpY2FsIHBhdGhcclxuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIuZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKHVuZGVmaW5lZCwgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xyXG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xyXG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sIFwiLmNvbmNhdChlLm1lc3NhZ2UpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHVibGlzaFJwY1Jlc3BvbnNlKGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcclxuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIGNhc2U6ICdycGNSZXNwb25zZScsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY1Jlc3BvbnNlKHtcclxuICAgICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgICB2YWx1ZTogZXJyb3IgPyB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ2Vycm9yJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogZXJyb3IudG9Qcm90bygpXHJcbiAgICAgICAgICAgIH0gOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ3BheWxvYWQnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBwYXlsb2FkICE9PSBudWxsICYmIHBheWxvYWQgIT09IHZvaWQgMCA/IHBheWxvYWQgOiAnJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwdWJsaXNoUnBjQWNrKGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxyXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ3JwY0FjaycsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY0Fjayh7XHJcbiAgICAgICAgICAgIHJlcXVlc3RJZFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICBzZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkbyBoYXZlIGEgZGF0YSBjb25uZWN0aW9uXHJcbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpO1xyXG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XHJcbiAgICAgICAgcGFja2V0LnNlcXVlbmNlID0gdGhpcy5yZWxpYWJsZURhdGFTZXF1ZW5jZTtcclxuICAgICAgICB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlICs9IDE7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbXNnID0gcGFja2V0LnRvQmluYXJ5KCk7XHJcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XHJcbiAgICAgIGlmIChkYykge1xyXG4gICAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcclxuICAgICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnB1c2goe1xyXG4gICAgICAgICAgICBkYXRhOiBtc2csXHJcbiAgICAgICAgICAgIHNlcXVlbmNlOiBwYWNrZXQuc2VxdWVuY2VcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRjLnNlbmQobXNnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhraW5kKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXNlbmRSZWxpYWJsZU1lc3NhZ2VzRm9yUmVzdW1lKGxhc3RNZXNzYWdlU2VxKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgIGlmIChkYykge1xyXG4gICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLnBvcFRvU2VxdWVuY2UobGFzdE1lc3NhZ2VTZXEpO1xyXG4gICAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyLmdldEFsbCgpLmZvckVhY2gobXNnID0+IHtcclxuICAgICAgICAgIGRjLnNlbmQobXNnLmRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgd2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhraW5kKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5pc0J1ZmZlclN0YXR1c0xvdyhraW5kKSkge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBvbkNsb3NpbmcgPSAoKSA9PiByZWplY3QoJ0VuZ2luZSBjbG9zZWQnKTtcclxuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuQ2xvc2luZywgb25DbG9zaW5nKTtcclxuICAgICAgICB3aGlsZSAoIXRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XHJcbiAgICAgICAgICB5aWVsZCBzbGVlcCgxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uQ2xvc2luZyk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZF8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgbGV0IHN1YnNjcmliZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc3Vic2NyaWJlclByaW1hcnk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIV90aGlzMi5wY01hbmFnZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBzdWJzY3JpYmVyID8gX3RoaXMyLnBjTWFuYWdlci5zdWJzY3JpYmVyIDogX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXI7XHJcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHN1YnNjcmliZXIgPyAnU3Vic2NyaWJlcicgOiAnUHVibGlzaGVyJztcclxuICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIlwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uIG5vdCBzZXRcIiksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5lZWROZWdvdGlhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghc3Vic2NyaWJlciAmJiAhX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkge1xyXG4gICAgICAgICAgX3RoaXMyLmNyZWF0ZURhdGFDaGFubmVscygpO1xyXG4gICAgICAgICAgbmVlZE5lZ290aWF0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZWVkTmVnb3RpYXRpb24gJiYgIXN1YnNjcmliZXIgJiYgIV90aGlzMi5wY01hbmFnZXIucHVibGlzaGVyLmlzSUNFQ29ubmVjdGVkICYmIF90aGlzMi5wY01hbmFnZXIucHVibGlzaGVyLmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY2hlY2tpbmcnKSB7XHJcbiAgICAgICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZE5lZ290aWF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBzdGFydCBuZWdvdGlhdGlvblxyXG4gICAgICAgICAgX3RoaXMyLm5lZ290aWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRDaGFubmVsID0gX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKTtcclxuICAgICAgICBpZiAoKHRhcmdldENoYW5uZWwgPT09IG51bGwgfHwgdGFyZ2V0Q2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2hhbm5lbC5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhaXQgdW50aWwgSUNFIGNvbm5lY3RlZFxyXG4gICAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIF90aGlzMi5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgd2hpbGUgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIDwgZW5kVGltZSkge1xyXG4gICAgICAgICAgaWYgKHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJiAoKF9hID0gX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBcIi5jb25jYXQodHJhbnNwb3J0TmFtZSwgXCIgY29ubmVjdGlvbiwgc3RhdGU6IFwiKS5jb25jYXQodHJhbnNwb3J0LmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSkge1xyXG4gICAgICAgIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2UgPSB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2U7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgdmVyaWZ5VHJhbnNwb3J0KCkge1xyXG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBwcmltYXJ5IGNvbm5lY3Rpb25cclxuICAgIGlmICh0aGlzLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIGVuc3VyZSBzaWduYWwgaXMgY29ubmVjdGVkXHJcbiAgICBpZiAoIXRoaXMuY2xpZW50LndzIHx8IHRoaXMuY2xpZW50LndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBuZWdvdGlhdGUoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAvLyBvYnNlcnZlIHNpZ25hbCBzdGF0ZVxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICAgIHJlamVjdChuZXcgTmVnb3RpYXRpb25FcnJvcignUEMgbWFuYWdlciBpcyBjbG9zZWQnKSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnJlcXVpcmVQdWJsaXNoZXIoKTtcclxuICAgICAgICAvLyBkb24ndCBuZWdvdGlhdGUgd2l0aG91dCBhbnkgdHJhbnNjZWl2ZXJzIG9yIGRhdGEgY2hhbm5lbCwgaXQgd2lsbCBnZW5lcmF0ZSBzZHAgd2l0aG91dCBpY2UgZnJhZyB0aGVuIG5lZ290aWF0ZSBmYWlsZWRcclxuICAgICAgICBpZiAodGhpcy5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpLmxlbmd0aCA9PSAwICYmICF0aGlzLmxvc3N5REMgJiYgIXRoaXMucmVsaWFibGVEQykge1xyXG4gICAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlZCA9ICgpID0+IHtcclxuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2VuZ2luZSBkaXNjb25uZWN0ZWQgd2hpbGUgbmVnb3RpYXRpb24gd2FzIG9uZ29pbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcclxuICAgICAgICAgIHJlamVjdCgnY2Fubm90IG5lZ290aWF0ZSBvbiBjbG9zZWQgZW5naW5lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub24oRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcclxuICAgICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgcnRwVHlwZXMgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcnRwTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgcnRwVHlwZXMuZm9yRWFjaChydHAgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IHJ0cC5jb2RlYy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNWaWRlb0NvZGVjKGNvZGVjKSkge1xyXG4gICAgICAgICAgICAgIHJ0cE1hcC5zZXQocnRwLnBheWxvYWQsIGNvZGVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLm5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgTmVnb3RpYXRpb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCduZWdvdGlhdGlvbicsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcclxuICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBkYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3ViKSB7XHJcbiAgICBpZiAoIXN1Yikge1xyXG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQztcclxuICAgICAgfVxyXG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5MT1NTWSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5RENTdWI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlRENTdWI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgdGhpcy5sb2cud2Fybignc3luYyBzdGF0ZSBjYW5ub3QgYmUgc2VudCB3aXRob3V0IHBlZXIgY29ubmVjdGlvbiBzZXR1cCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHByZXZpb3VzQW5zd2VyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRMb2NhbERlc2NyaXB0aW9uKCk7XHJcbiAgICBjb25zdCBwcmV2aW91c09mZmVyID0gdGhpcy5wY01hbmFnZXIuc3Vic2NyaWJlci5nZXRSZW1vdGVEZXNjcmlwdGlvbigpO1xyXG4gICAgLyogMS4gYXV0b3N1YnNjcmliZSBvbiwgc28gc3Vic2NyaWJlZCB0cmFja3MgPSBhbGwgdHJhY2tzIC0gdW5zdWIgdHJhY2tzLFxyXG4gICAgICAgICAgaW4gdGhpcyBjYXNlLCB3ZSBzZW5kIHVuc3ViIHRyYWNrcywgc28gc2VydmVyIGFkZCBhbGwgdHJhY2tzIHRvIHRoaXNcclxuICAgICAgICAgIHN1YnNjcmliZSBwYyBhbmQgdW5zdWIgc3BlY2lhbCB0cmFja3MgZnJvbSBpdC5cclxuICAgICAgIDIuIGF1dG9zdWJzY3JpYmUgb2ZmLCB3ZSBzZW5kIHN1YnNjcmliZWQgdHJhY2tzLlxyXG4gICAgKi9cclxuICAgIGNvbnN0IGF1dG9TdWJzY3JpYmUgPSAoX2IgPSAoX2EgPSB0aGlzLnNpZ25hbE9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XHJcbiAgICBjb25zdCB0cmFja1NpZHNEaXNhYmxlZCA9IG5ldyBBcnJheSgpO1xyXG4gICAgcmVtb3RlVHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XHJcbiAgICAgICAgdHJhY2tTaWRzLnB1c2godHJhY2sudHJhY2tTaWQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdHJhY2suaXNFbmFibGVkKSB7XHJcbiAgICAgICAgdHJhY2tTaWRzRGlzYWJsZWQucHVzaCh0cmFjay50cmFja1NpZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5jbGllbnQuc2VuZFN5bmNTdGF0ZShuZXcgU3luY1N0YXRlKHtcclxuICAgICAgYW5zd2VyOiBwcmV2aW91c0Fuc3dlciA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xyXG4gICAgICAgIHNkcDogcHJldmlvdXNBbnN3ZXIuc2RwLFxyXG4gICAgICAgIHR5cGU6IHByZXZpb3VzQW5zd2VyLnR5cGVcclxuICAgICAgfSkgOiB1bmRlZmluZWQsXHJcbiAgICAgIG9mZmVyOiBwcmV2aW91c09mZmVyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XHJcbiAgICAgICAgc2RwOiBwcmV2aW91c09mZmVyLnNkcCxcclxuICAgICAgICB0eXBlOiBwcmV2aW91c09mZmVyLnR5cGVcclxuICAgICAgfSkgOiB1bmRlZmluZWQsXHJcbiAgICAgIHN1YnNjcmlwdGlvbjogbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XHJcbiAgICAgICAgdHJhY2tTaWRzLFxyXG4gICAgICAgIHN1YnNjcmliZTogIWF1dG9TdWJzY3JpYmUsXHJcbiAgICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtdXHJcbiAgICAgIH0pLFxyXG4gICAgICBwdWJsaXNoVHJhY2tzOiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyhsb2NhbFRyYWNrcyksXHJcbiAgICAgIGRhdGFDaGFubmVsczogdGhpcy5kYXRhQ2hhbm5lbHNJbmZvKCksXHJcbiAgICAgIHRyYWNrU2lkc0Rpc2FibGVkLFxyXG4gICAgICBkYXRhY2hhbm5lbFJlY2VpdmVTdGF0ZXM6IHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlLm1hcCgoc2VxLCBzaWQpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFubmVsUmVjZWl2ZVN0YXRlKHtcclxuICAgICAgICAgIHB1Ymxpc2hlclNpZDogc2lkLFxyXG4gICAgICAgICAgbGFzdFNlcTogc2VxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIGZhaWxOZXh0KCkge1xyXG4gICAgLy8gZGVidWdnaW5nIG1ldGhvZCB0byBmYWlsIHRoZSBuZXh0IHJlY29ubmVjdC9yZXN1bWUgYXR0ZW1wdFxyXG4gICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IHRydWU7XHJcbiAgfVxyXG4gIGRhdGFDaGFubmVsc0luZm8oKSB7XHJcbiAgICBjb25zdCBpbmZvcyA9IFtdO1xyXG4gICAgY29uc3QgZ2V0SW5mbyA9IChkYywgdGFyZ2V0KSA9PiB7XHJcbiAgICAgIGlmICgoZGMgPT09IG51bGwgfHwgZGMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRjLmlkKSAhPT0gdW5kZWZpbmVkICYmIGRjLmlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgaW5mb3MucHVzaChuZXcgRGF0YUNoYW5uZWxJbmZvKHtcclxuICAgICAgICAgIGxhYmVsOiBkYy5sYWJlbCxcclxuICAgICAgICAgIGlkOiBkYy5pZCxcclxuICAgICAgICAgIHRhcmdldFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XHJcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xyXG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWUpLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XHJcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcclxuICAgIHJldHVybiBpbmZvcztcclxuICB9XHJcbiAgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xyXG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xyXG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcclxuICAgIH1cclxuICB9XHJcbiAgY2xlYXJQZW5kaW5nUmVjb25uZWN0KCkge1xyXG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcclxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gIH1cclxuICByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xyXG4gICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpIHtcclxuICAgIGlmIChpc1dlYigpKSB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5jbGFzcyBTaWduYWxSZWNvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yIHt9XHJcbmZ1bmN0aW9uIHN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKHByb3RvY29sKSB7XHJcbiAgcmV0dXJuIHByb3RvY29sICE9PSB1bmRlZmluZWQgJiYgcHJvdG9jb2wgPiAxMztcclxufVxyXG5mdW5jdGlvbiBhcHBseVVzZXJEYXRhQ29tcGF0KG5ld09iaiwgb2xkT2JqKSB7XHJcbiAgY29uc3QgcGFydGljaXBhbnRJZGVudGl0eSA9IG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5ID8gbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgOiBvbGRPYmoucGFydGljaXBhbnRJZGVudGl0eTtcclxuICBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XHJcbiAgb2xkT2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xyXG4gIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG5ld09iai5kZXN0aW5hdGlvbklkZW50aXRpZXMubGVuZ3RoICE9PSAwID8gbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA6IG9sZE9iai5kZXN0aW5hdGlvbklkZW50aXRpZXM7XHJcbiAgbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IGRlc3RpbmF0aW9uSWRlbnRpdGllcztcclxuICBvbGRPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xyXG59XHJcblxyXG5jbGFzcyBSZWdpb25VcmxQcm92aWRlciB7XHJcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xyXG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSAwO1xyXG4gICAgdGhpcy5zZXR0aW5nc0NhY2hlVGltZSA9IDMwMDA7XHJcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcclxuICAgIHRoaXMuc2VydmVyVXJsID0gbmV3IFVSTCh1cmwpO1xyXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gIH1cclxuICB1cGRhdGVUb2tlbih0b2tlbikge1xyXG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xyXG4gIH1cclxuICBpc0Nsb3VkKCkge1xyXG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xyXG4gIH1cclxuICBnZXRTZXJ2ZXJVcmwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XHJcbiAgfVxyXG4gIGdldE5leHRCZXN0UmVnaW9uVXJsKGFib3J0U2lnbmFsKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNDbG91ZCgpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3JlZ2lvbiBhdmFpbGFiaWxpdHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIExpdmVLaXQgQ2xvdWQgZG9tYWlucycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5yZWdpb25TZXR0aW5ncyB8fCBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VXBkYXRlQXQgPiB0aGlzLnNldHRpbmdzQ2FjaGVUaW1lKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IHlpZWxkIHRoaXMuZmV0Y2hSZWdpb25TZXR0aW5ncyhhYm9ydFNpZ25hbCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVnaW9uc0xlZnQgPSB0aGlzLnJlZ2lvblNldHRpbmdzLnJlZ2lvbnMuZmlsdGVyKHJlZ2lvbiA9PiAhdGhpcy5hdHRlbXB0ZWRSZWdpb25zLmZpbmQoYXR0ZW1wdGVkID0+IGF0dGVtcHRlZC51cmwgPT09IHJlZ2lvbi51cmwpKTtcclxuICAgICAgaWYgKHJlZ2lvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zLnB1c2gobmV4dFJlZ2lvbik7XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcIm5leHQgcmVnaW9uOiBcIi5jb25jYXQobmV4dFJlZ2lvbi5yZWdpb24pKTtcclxuICAgICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXNldEF0dGVtcHRzKCkge1xyXG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIGZldGNoUmVnaW9uU2V0dGluZ3Moc2lnbmFsKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlID0geWllbGQgZmV0Y2goXCJcIi5jb25jYXQoZ2V0Q2xvdWRDb25maWdVcmwodGhpcy5zZXJ2ZXJVcmwpLCBcIi9yZWdpb25zXCIpLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgYXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KHRoaXMudG9rZW4pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWduYWxcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9uU2V0dGluZ3MgPSB5aWVsZCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lvblNldHRpbmdzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiBcIi5jb25jYXQocmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXNUZXh0KSwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMgPT09IDQwMSA/IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkIDogQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsIHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhyZWdpb25zKSB7XHJcbiAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0gcmVnaW9ucztcclxuICAgIHRoaXMubGFzdFVwZGF0ZUF0ID0gRGF0ZS5ub3coKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsKSB7XHJcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyksIFwiLy9cIikuY29uY2F0KHNlcnZlclVybC5ob3N0LCBcIi9zZXR0aW5nc1wiKTtcclxufVxyXG5cclxuY2xhc3MgQmFzZVN0cmVhbVJlYWRlciB7XHJcbiAgZ2V0IGluZm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW5mbztcclxuICB9XHJcbiAgY29uc3RydWN0b3IoaW5mbywgc3RyZWFtLCB0b3RhbEJ5dGVTaXplKSB7XHJcbiAgICB0aGlzLnJlYWRlciA9IHN0cmVhbTtcclxuICAgIHRoaXMudG90YWxCeXRlU2l6ZSA9IHRvdGFsQnl0ZVNpemU7XHJcbiAgICB0aGlzLl9pbmZvID0gaW5mbztcclxuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XHJcbiAgfVxyXG59XHJcbmNsYXNzIEJ5dGVTdHJlYW1SZWFkZXIgZXh0ZW5kcyBCYXNlU3RyZWFtUmVhZGVyIHtcclxuICBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gY2h1bmsuY29udGVudC5ieXRlTGVuZ3RoO1xyXG4gICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy50b3RhbEJ5dGVTaXplID8gdGhpcy5ieXRlc1JlY2VpdmVkIC8gdGhpcy50b3RhbEJ5dGVTaXplIDogdW5kZWZpbmVkO1xyXG4gICAgKF9hID0gdGhpcy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50UHJvZ3Jlc3MpO1xyXG4gIH1cclxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xyXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgZG9uZSxcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLmNvbnRlbnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgLy8gVE9ETyBoYW5kbGUgZXJyb3JzXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSksXHJcbiAgICAgIHJldHVybigpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICByZWFkQWxsKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcclxuICAgICAgbGV0IGNodW5rcyA9IG5ldyBTZXQoKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh0aGlzKSwgX2Y7IF9mID0geWllbGQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgX2QgPSBmYWxzZTtcclxuICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XHJcbiAgICAgICAgICBjaHVua3MuYWRkKGNodW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XHJcbiAgICAgICAgZV8xID0ge1xyXG4gICAgICAgICAgZXJyb3I6IGVfMV8xXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2h1bmtzKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQSBjbGFzcyB0byByZWFkIGNodW5rcyBmcm9tIGEgUmVhZGFibGVTdHJlYW0gYW5kIHByb3ZpZGUgdGhlbSBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LlxyXG4gKi9cclxuY2xhc3MgVGV4dFN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xyXG4gIC8qKlxyXG4gICAqIEEgVGV4dFN0cmVhbVJlYWRlciBpbnN0YW5jZSBjYW4gYmUgdXNlZCBhcyBhbiBBc3luY0l0ZXJhdG9yIHRoYXQgcmV0dXJucyB0aGUgZW50aXJlIHN0cmluZ1xyXG4gICAqIHRoYXQgaGFzIGJlZW4gcmVjZWl2ZWQgdXAgdG8gdGhlIGN1cnJlbnQgcG9pbnQgaW4gdGltZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihpbmZvLCBzdHJlYW0sIHRvdGFsQ2h1bmtDb3VudCkge1xyXG4gICAgc3VwZXIoaW5mbywgc3RyZWFtLCB0b3RhbENodW5rQ291bnQpO1xyXG4gICAgdGhpcy5yZWNlaXZlZENodW5rcyA9IG5ldyBNYXAoKTtcclxuICB9XHJcbiAgaGFuZGxlQ2h1bmtSZWNlaXZlZChjaHVuaykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgaW5kZXggPSBiaWdJbnRUb051bWJlcihjaHVuay5jaHVua0luZGV4KTtcclxuICAgIGNvbnN0IHByZXZpb3VzQ2h1bmtBdEluZGV4ID0gdGhpcy5yZWNlaXZlZENodW5rcy5nZXQoaW5kZXgpO1xyXG4gICAgaWYgKHByZXZpb3VzQ2h1bmtBdEluZGV4ICYmIHByZXZpb3VzQ2h1bmtBdEluZGV4LnZlcnNpb24gPiBjaHVuay52ZXJzaW9uKSB7XHJcbiAgICAgIC8vIHdlIGhhdmUgYSBuZXdlciB2ZXJzaW9uIGFscmVhZHksIGRyb3BwaW5nIHRoZSBvbGQgb25lXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMucmVjZWl2ZWRDaHVua3Muc2V0KGluZGV4LCBjaHVuayk7XHJcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gY2h1bmsuY29udGVudC5ieXRlTGVuZ3RoO1xyXG4gICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy50b3RhbEJ5dGVTaXplID8gdGhpcy5ieXRlc1JlY2VpdmVkIC8gdGhpcy50b3RhbEJ5dGVTaXplIDogdW5kZWZpbmVkO1xyXG4gICAgKF9hID0gdGhpcy5vblByb2dyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50UHJvZ3Jlc3MpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBc3luYyBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB1c2FnZSBvZiBgZm9yIGF3YWl0Li4ub2ZgIHN5bnRheC5cclxuICAgKiBZaWVsZHMgc3RydWN0dXJlZCBjaHVua3MgZnJvbSB0aGUgc3RyZWFtLlxyXG4gICAqXHJcbiAgICovXHJcbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcclxuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMucmVhZGVyLmdldFJlYWRlcigpO1xyXG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmV4dDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGRvbmUsXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNodW5rUmVjZWl2ZWQodmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVyLmRlY29kZSh2YWx1ZS5jb250ZW50KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvcnNcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSxcclxuICAgICAgcmV0dXJuKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIHJlYWRBbGwoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xyXG4gICAgICBsZXQgZmluYWxTdHJpbmcgPSAnJztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh0aGlzKSwgX2Y7IF9mID0geWllbGQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgX2QgPSBmYWxzZTtcclxuICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XHJcbiAgICAgICAgICBmaW5hbFN0cmluZyArPSBjaHVuaztcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XHJcbiAgICAgICAgZV8yID0ge1xyXG4gICAgICAgICAgZXJyb3I6IGVfMl8xXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZpbmFsU3RyaW5nO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBCYXNlU3RyZWFtV3JpdGVyIHtcclxuICBjb25zdHJ1Y3Rvcih3cml0YWJsZVN0cmVhbSwgaW5mbywgb25DbG9zZSkge1xyXG4gICAgdGhpcy53cml0YWJsZVN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xyXG4gICAgdGhpcy5kZWZhdWx0V3JpdGVyID0gd3JpdGFibGVTdHJlYW0uZ2V0V3JpdGVyKCk7XHJcbiAgICB0aGlzLm9uQ2xvc2UgPSBvbkNsb3NlO1xyXG4gICAgdGhpcy5pbmZvID0gaW5mbztcclxuICB9XHJcbiAgd3JpdGUoY2h1bmspIHtcclxuICAgIHJldHVybiB0aGlzLmRlZmF1bHRXcml0ZXIud3JpdGUoY2h1bmspO1xyXG4gIH1cclxuICBjbG9zZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgeWllbGQgdGhpcy5kZWZhdWx0V3JpdGVyLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMuZGVmYXVsdFdyaXRlci5yZWxlYXNlTG9jaygpO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uQ2xvc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFRleHRTdHJlYW1Xcml0ZXIgZXh0ZW5kcyBCYXNlU3RyZWFtV3JpdGVyIHt9XHJcbmNsYXNzIEJ5dGVTdHJlYW1Xcml0ZXIgZXh0ZW5kcyBCYXNlU3RyZWFtV3JpdGVyIHt9XHJcblxyXG5jbGFzcyBSZW1vdGVUcmFjayBleHRlbmRzIFRyYWNrIHtcclxuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIGtpbmQsIHJlY2VpdmVyLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIHRoaXMuc2lkID0gc2lkO1xyXG4gICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gIH1cclxuICBnZXQgaXNMb2NhbCgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldE11dGVkKG11dGVkKSB7XHJcbiAgICBpZiAodGhpcy5pc011dGVkICE9PSBtdXRlZCkge1xyXG4gICAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcclxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIW11dGVkO1xyXG4gICAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYWNrIGlzIGZpbmlzaGVkXHJcbiAgICB0aGlzLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgY29uc3Qgb25SZW1vdmVUcmFjayA9IGV2ZW50ID0+IHtcclxuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XHJcbiAgICAgICAgc3RyZWFtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgb25SZW1vdmVUcmFjayk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZXIgJiYgJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgb25SZW1vdmVUcmFjayk7XHJcbiAgfVxyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5zdGFydE1vbml0b3IoKTtcclxuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxyXG4gICAgc3VwZXIuZW5hYmxlKCk7XHJcbiAgfVxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XHJcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcclxuICAgIHN1cGVyLmRpc2FibGUoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBSZW1vdGVUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwUmVjZWl2ZXJcclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIGdldFJUQ1N0YXRzUmVwb3J0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoISgoX2EgPSB0aGlzLnJlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0YXRzUmVwb3J0ID0geWllbGQgdGhpcy5yZWNlaXZlci5nZXRTdGF0cygpO1xyXG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIHRvIHNldCBhIHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIGZvciB0aGlzIHRyYWNrLlxyXG4gICAqIEEgaGlnaGVyIHZhbHVlIGFsbG93cyBmb3IgbW9yZSBidWZmZXJpbmcgb2YgdGhlIHRyYWNrIGluIHRoZSBicm93c2VyXHJcbiAgICogYW5kIHdpbGwgcmVzdWx0IGluIGEgZGVsYXkgb2YgbWVkaWEgYmVpbmcgcGxheWVkIGJhY2sgb2YgYGRlbGF5SW5TZWNvbmRzYFxyXG4gICAqL1xyXG4gIHNldFBsYXlvdXREZWxheShkZWxheUluU2Vjb25kcykge1xyXG4gICAgaWYgKHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50ID0gZGVsYXlJblNlY29uZHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3Qgc2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5b3V0IGRlbGF5IChpbiBzZWNvbmRzKSBvZiB0aGlzIHRyYWNrLlxyXG4gICAqL1xyXG4gIGdldFBsYXlvdXREZWxheSgpIHtcclxuICAgIGlmICh0aGlzLnJlY2VpdmVyKSB7XHJcbiAgICAgIGlmICgncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3QgZ2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICBzdGFydE1vbml0b3IoKSB7XHJcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XHJcbiAgICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5tb25pdG9yUmVjZWl2ZXIoKSwgbW9uaXRvckZyZXF1ZW5jeSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzKCkpIHtcclxuICAgICAgdGhpcy5yZWdpc3RlclRpbWVTeW5jVXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKSB7XHJcbiAgICBjb25zdCBsb29wID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHRoaXMudGltZVN5bmNIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbG9vcCgpKTtcclxuICAgICAgY29uc3Qgc291cmNlcyA9IChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzKClbMF07XHJcbiAgICAgIGlmIChzb3VyY2VzKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgdGltZXN0YW1wLFxyXG4gICAgICAgICAgcnRwVGltZXN0YW1wXHJcbiAgICAgICAgfSA9IHNvdXJjZXM7XHJcbiAgICAgICAgaWYgKHJ0cFRpbWVzdGFtcCAmJiB0aGlzLnJ0cFRpbWVzdGFtcCAhPT0gcnRwVGltZXN0YW1wKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5UaW1lU3luY1VwZGF0ZSwge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIHJ0cFRpbWVzdGFtcFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB0aGlzLnJ0cFRpbWVzdGFtcCA9IHJ0cFRpbWVzdGFtcDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBsb29wKCk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBSZW1vdGVBdWRpb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xyXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGF1ZGlvQ29udGV4dCwgYXVkaW9PdXRwdXQsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5BdWRpbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcclxuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XHJcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBbXTtcclxuICAgIGlmIChhdWRpb091dHB1dCkge1xyXG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xyXG4gICAqL1xyXG4gIHNldFZvbHVtZSh2b2x1bWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5hdHRhY2hlZEVsZW1lbnRzKSB7XHJcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWwudm9sdW1lID0gdm9sdW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5fc2V0Vm9sdW1lKHZvbHVtZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvZiBhdHRhY2hlZCBhdWRpbyBlbGVtZW50cyAobG91ZGVzdClcclxuICAgKi9cclxuICBnZXRWb2x1bWUoKSB7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRWb2x1bWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XHJcbiAgICAgIC8vIFJOIHZvbHVtZSB2YWx1ZSBkZWZhdWx0cyB0byAxLjAgaWYgaGFzbid0IGJlZW4gY2hhbmdlZC5cclxuICAgICAgcmV0dXJuIDEuMDtcclxuICAgIH1cclxuICAgIGxldCBoaWdoZXN0Vm9sdW1lID0gMDtcclxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XHJcbiAgICAgICAgaGlnaGVzdFZvbHVtZSA9IGVsZW1lbnQudm9sdW1lO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBoaWdoZXN0Vm9sdW1lO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBjYWxscyBzZXRTaW5rSWQgb24gYWxsIGF0dGFjaGVkIGVsZW1lbnRzLCBpZiBzdXBwb3J0ZWRcclxuICAgKiBAcGFyYW0gZGV2aWNlSWQgYXVkaW8gb3V0cHV0IGRldmljZVxyXG4gICAqL1xyXG4gIHNldFNpbmtJZChkZXZpY2VJZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcclxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwodGhpcy5hdHRhY2hlZEVsZW1lbnRzLm1hcChlbG0gPT4ge1xyXG4gICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgcmV0dXJuIGVsbS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xyXG4gICAgICB9KSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXR0YWNoKGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMDtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcclxuICAgICAgZWxlbWVudC5zZXRTaW5rSWQodGhpcy5zaW5rSWQpLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdGYWlsZWQgdG8gc2V0IHNpbmsgaWQgb24gcmVtb3RlIGF1ZGlvIHRyYWNrJywgZSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24pIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGF1ZGlvIGNvbnRleHQgbWFwcGluZycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcclxuICAgICAgZWxlbWVudC52b2x1bWUgPSAwO1xyXG4gICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHZvbHVtZSBzZXR0aW5nIGlzIGJlaW5nIGFwcGxpZWQgdG8gdGhlIG5ld2x5IGF0dGFjaGVkIGVsZW1lbnRcclxuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5lbGVtZW50Vm9sdW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuICBkZXRhY2goZWxlbWVudCkge1xyXG4gICAgbGV0IGRldGFjaGVkO1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XHJcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcclxuICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIGFueSBhdHRhY2hlZCBlbGVtZW50cyBhZnRlciBkZXRhY2hpbmcsIGNvbm5lY3Qgd2ViYXVkaW8gdG8gdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCdzIGxlZnRcclxuICAgICAgLy8gZGlzY29ubmVjdCB3ZWJhdWRpbyBvdGhlcndpc2VcclxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkZXRhY2hlZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGV4cGVyaW1lbnRhbFxyXG4gICAqL1xyXG4gIHNldEF1ZGlvQ29udGV4dChhdWRpb0NvbnRleHQpIHtcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xyXG4gICAgaWYgKGF1ZGlvQ29udGV4dCAmJiB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XHJcbiAgICB9IGVsc2UgaWYgKCFhdWRpb0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGV4cGVyaW1lbnRhbFxyXG4gICAqIEBwYXJhbSB7QXVkaW9Ob2RlW119IG5vZGVzIC0gQW4gYXJyYXkgb2YgV2ViQXVkaW8gbm9kZXMuIFRoZXNlIG5vZGVzIHNob3VsZCBub3QgYmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgd2hlbiBwYXNzZWQsIGFzIHRoZSBzZGsgd2lsbCB0YWtlIGNhcmUgb2YgY29ubmVjdGluZyB0aGVtIGluIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkuXHJcbiAgICovXHJcbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzKSB7XHJcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBub2RlcztcclxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29ubmVjdFdlYkF1ZGlvKGNvbnRleHQsIGVsZW1lbnQpIHtcclxuICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XHJcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxyXG4gICAgdGhpcy5zb3VyY2VOb2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShlbGVtZW50LnNyY09iamVjdCk7XHJcbiAgICBsZXQgbGFzdE5vZGUgPSB0aGlzLnNvdXJjZU5vZGU7XHJcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgbGFzdE5vZGUuY29ubmVjdChub2RlKTtcclxuICAgICAgbGFzdE5vZGUgPSBub2RlO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICBsYXN0Tm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xyXG4gICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KGNvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xyXG4gICAgICB0aGlzLmdhaW5Ob2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHRoaXMuZWxlbWVudFZvbHVtZSwgMCwgMC4xKTtcclxuICAgIH1cclxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XHJcbiAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XHJcbiAgICAgIGNvbnRleHQucmVzdW1lKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xyXG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgbmV3IEVycm9yKFwiQXVkaW8gQ29udGV4dCBjb3VsZG4ndCBiZSBzdGFydGVkIGF1dG9tYXRpY2FsbHlcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgKF9hID0gdGhpcy5nYWluTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcclxuICAgIChfYiA9IHRoaXMuc291cmNlTm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcclxuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnNvdXJjZU5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XHJcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xyXG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcclxuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXHJcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxyXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxyXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXHJcbiAgICAgICAgICAgIGNvbmNlYWxlZFNhbXBsZXM6IHYuY29uY2VhbGVkU2FtcGxlcyxcclxuICAgICAgICAgICAgY29uY2VhbG1lbnRFdmVudHM6IHYuY29uY2VhbG1lbnRFdmVudHMsXHJcbiAgICAgICAgICAgIHNpbGVudENvbmNlYWxlZFNhbXBsZXM6IHYuc2lsZW50Q29uY2VhbGVkU2FtcGxlcyxcclxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM6IHYuc2lsZW50Q29uY2VhbG1lbnRFdmVudHMsXHJcbiAgICAgICAgICAgIHRvdGFsQXVkaW9FbmVyZ3k6IHYudG90YWxBdWRpb0VuZXJneSxcclxuICAgICAgICAgICAgdG90YWxTYW1wbGVzRHVyYXRpb246IHYudG90YWxTYW1wbGVzRHVyYXRpb25cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IFJFQUNUSU9OX0RFTEFZID0gMTAwO1xyXG5jbGFzcyBSZW1vdGVWaWRlb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xyXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIHNpZCwgVHJhY2suS2luZC5WaWRlbywgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcclxuICAgIHRoaXMubW9uaXRvclJlY2VpdmVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5nZXRSZWNlaXZlclN0YXRzKCk7XHJcbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHM7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplID0gcigoKSA9PiB7XHJcbiAgICAgIHRoaXMudXBkYXRlRGltZW5zaW9ucygpO1xyXG4gICAgfSwgUkVBQ1RJT05fREVMQVkpO1xyXG4gICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcclxuICB9XHJcbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIE5vdGU6IFdoZW4gdXNpbmcgYWRhcHRpdmVTdHJlYW0sIHlvdSBuZWVkIHRvIHVzZSByZW1vdGVWaWRlb1RyYWNrLmF0dGFjaCgpIHRvIGFkZCB0aGUgdHJhY2sgdG8gYSBIVE1MVmlkZW9FbGVtZW50LCBvdGhlcndpc2UgeW91ciB2aWRlbyB0cmFja3MgbWlnaHQgbmV2ZXIgc3RhcnRcclxuICAgKi9cclxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0TXV0ZWQobXV0ZWQpIHtcclxuICAgIHN1cGVyLnNldE11dGVkKG11dGVkKTtcclxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAvLyBkZXRhY2ggb3IgYXR0YWNoXHJcbiAgICAgIGlmIChtdXRlZCkge1xyXG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGF0dGFjaChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gSXQncyBwb3NzaWJsZSBhdHRhY2ggaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIGFuIGVsZW1lbnQuIFdoZW4gdGhhdCdzXHJcbiAgICAvLyB0aGUgY2FzZSwgd2UnZCB3YW50IHRvIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgZWxlbWVudEluZm9zXHJcbiAgICBpZiAodGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgZWxlbWVudEluZm8gPSBuZXcgSFRNTEVsZW1lbnRJbmZvKGVsZW1lbnQpO1xyXG4gICAgICB0aGlzLm9ic2VydmVFbGVtZW50SW5mbyhlbGVtZW50SW5mbyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cclxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBvYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pIHtcclxuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xyXG4gICAgICB9O1xyXG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XHJcbiAgICAgIGVsZW1lbnRJbmZvLm9ic2VydmUoKTtcclxuICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgcmVzaXplIHVwZGF0ZSBjeWNsZVxyXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcclxuICAgICAgLy8gdGhlIHRhYiBjb21lcyBpbnRvIGZvY3VzIGZvciB0aGUgZmlyc3QgdGltZS5cclxuICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcclxuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCd2aXNpYmlsaXR5IHJlc2l6ZSBvYnNlcnZlciBub3QgdHJpZ2dlcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3RvcCBvYnNlcnZpbmcgYW4gRWxlbWVudEluZm8gZm9yIGNoYW5nZXMuXHJcbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8gaWdub3JlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbyk7XHJcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xyXG4gICAgICBpbmZvLnN0b3BPYnNlcnZpbmcoKTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mbyAhPT0gZWxlbWVudEluZm8pO1xyXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xyXG4gIH1cclxuICBkZXRhY2goZWxlbWVudCkge1xyXG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHMgPSBbXTtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgIHJldHVybiBzdXBlci5kZXRhY2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBkZXRhY2hlZEVsZW1lbnRzID0gc3VwZXIuZGV0YWNoKCk7XHJcbiAgICBmb3IgKGNvbnN0IGUgb2YgZGV0YWNoZWRFbGVtZW50cykge1xyXG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBnZXREZWNvZGVySW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wcmV2U3RhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNvZGVySW1wbGVtZW50YXRpb247XHJcbiAgfVxyXG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIgfHwgIXRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XHJcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xyXG4gICAgICBsZXQgY29kZWNJRCA9ICcnO1xyXG4gICAgICBsZXQgY29kZWNzID0gbmV3IE1hcCgpO1xyXG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcclxuICAgICAgICAgIGNvZGVjSUQgPSB2LmNvZGVjSWQ7XHJcbiAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxyXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcclxuICAgICAgICAgICAgZnJhbWVzRGVjb2RlZDogdi5mcmFtZXNEZWNvZGVkLFxyXG4gICAgICAgICAgICBmcmFtZXNEcm9wcGVkOiB2LmZyYW1lc0Ryb3BwZWQsXHJcbiAgICAgICAgICAgIGZyYW1lc1JlY2VpdmVkOiB2LmZyYW1lc1JlY2VpdmVkLFxyXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IHYucGFja2V0c1JlY2VpdmVkLFxyXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcclxuICAgICAgICAgICAgZnJhbWVXaWR0aDogdi5mcmFtZVdpZHRoLFxyXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcclxuICAgICAgICAgICAgcGxpQ291bnQ6IHYucGxpQ291bnQsXHJcbiAgICAgICAgICAgIGZpckNvdW50OiB2LmZpckNvdW50LFxyXG4gICAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxyXG4gICAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxyXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXHJcbiAgICAgICAgICAgIGRlY29kZXJJbXBsZW1lbnRhdGlvbjogdi5kZWNvZGVySW1wbGVtZW50YXRpb25cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcclxuICAgICAgICAgIGNvZGVjcy5zZXQodi5pZCwgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHJlY2VpdmVyU3RhdHMgJiYgY29kZWNJRCAhPT0gJycgJiYgY29kZWNzLmdldChjb2RlY0lEKSkge1xyXG4gICAgICAgIHJlY2VpdmVyU3RhdHMubWltZVR5cGUgPSBjb2RlY3MuZ2V0KGNvZGVjSUQpLm1pbWVUeXBlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xyXG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcclxuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oaW5mbyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZFxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xyXG4gICAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xyXG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5lbGVtZW50SW5mb3MucmVkdWNlKChwcmV2LCBpbmZvKSA9PiBNYXRoLm1heChwcmV2LCBpbmZvLnZpc2liaWxpdHlDaGFuZ2VkQXQgfHwgMCksIDApO1xyXG4gICAgY29uc3QgYmFja2dyb3VuZFBhdXNlID0gKChfYiA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlVmlkZW9JbkJhY2tncm91bmQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlXHJcbiAgICApID8gdGhpcy5pc0luQmFja2dyb3VuZCA6IGZhbHNlO1xyXG4gICAgY29uc3QgaXNQaVBNb2RlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8ucGljdHVyZUluUGljdHVyZSk7XHJcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby52aXNpYmxlKSAmJiAhYmFja2dyb3VuZFBhdXNlIHx8IGlzUGlQTW9kZTtcclxuICAgIGlmICh0aGlzLmxhc3RWaXNpYmxlID09PSBpc1Zpc2libGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1Zpc2libGUgJiYgRGF0ZS5ub3coKSAtIGxhc3RWaXNpYmlsaXR5Q2hhbmdlIDwgUkVBQ1RJT05fREVMQVkpIHtcclxuICAgICAgLy8gZGVsYXkgaGlkZGVuIGV2ZW50c1xyXG4gICAgICBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgICAgfSwgUkVBQ1RJT05fREVMQVkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xyXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIGlzVmlzaWJsZSwgdGhpcyk7XHJcbiAgfVxyXG4gIHVwZGF0ZURpbWVuc2lvbnMoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgbGV0IG1heFdpZHRoID0gMDtcclxuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xyXG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gdGhpcy5nZXRQaXhlbERlbnNpdHkoKTtcclxuICAgIGZvciAoY29uc3QgaW5mbyBvZiB0aGlzLmVsZW1lbnRJbmZvcykge1xyXG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudFdpZHRoID0gaW5mby53aWR0aCgpICogcGl4ZWxEZW5zaXR5O1xyXG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEhlaWdodCA9IGluZm8uaGVpZ2h0KCkgKiBwaXhlbERlbnNpdHk7XHJcbiAgICAgIGlmIChjdXJyZW50RWxlbWVudFdpZHRoICsgY3VycmVudEVsZW1lbnRIZWlnaHQgPiBtYXhXaWR0aCArIG1heEhlaWdodCkge1xyXG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudEVsZW1lbnRXaWR0aDtcclxuICAgICAgICBtYXhIZWlnaHQgPSBjdXJyZW50RWxlbWVudEhlaWdodDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCgoX2EgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBtYXhXaWR0aCAmJiAoKF9iID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IG1heEhlaWdodCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxhc3REaW1lbnNpb25zID0ge1xyXG4gICAgICB3aWR0aDogbWF4V2lkdGgsXHJcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0XHJcbiAgICB9O1xyXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5sYXN0RGltZW5zaW9ucywgdGhpcyk7XHJcbiAgfVxyXG4gIGdldFBpeGVsRGVuc2l0eSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBpeGVsRGVuc2l0eTtcclxuICAgIGlmIChwaXhlbERlbnNpdHkgPT09ICdzY3JlZW4nKSB7XHJcbiAgICAgIHJldHVybiBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XHJcbiAgICB9IGVsc2UgaWYgKCFwaXhlbERlbnNpdHkpIHtcclxuICAgICAgLy8gd2hlbiB1bnNldCwgd2UnbGwgcGljayBhIHNhbmUgZGVmYXVsdCBoZXJlLlxyXG4gICAgICAvLyBmb3IgaGlnaGVyIHBpeGVsIGRlbnNpdHkgZGV2aWNlcyAobW9iaWxlIHBob25lcywgZXRjKSwgd2UnbGwgdXNlIDJcclxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGRlZmF1bHRzIHRvIDFcclxuICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGdldERldmljZVBpeGVsUmF0aW8oKTtcclxuICAgICAgaWYgKGRldmljZVBpeGVsUmF0aW8gPiAyKSB7XHJcbiAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwaXhlbERlbnNpdHk7XHJcbiAgfVxyXG59XHJcbmNsYXNzIEhUTUxFbGVtZW50SW5mbyB7XHJcbiAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1BpUCB8fCB0aGlzLmlzSW50ZXJzZWN0aW5nO1xyXG4gIH1cclxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmlzUGlQO1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB2aXNpYmxlKSB7XHJcbiAgICB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQgPSBlbnRyeSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICBpc0ludGVyc2VjdGluZ1xyXG4gICAgICB9ID0gZW50cnk7XHJcbiAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0ludGVyc2VjdGluZztcclxuICAgICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkVudGVyUGlQID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgKF9iID0gKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpbmRvdykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcclxuICAgICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgIChfYyA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25MZWF2ZVBpUCA9ICgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcclxuICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSB2aXNpYmxlICE9PSBudWxsICYmIHZpc2libGUgIT09IHZvaWQgMCA/IHZpc2libGUgOiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQpO1xyXG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgaXNFbGVtZW50SW5QaVAoZWxlbWVudCk7XHJcbiAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQXQgPSAwO1xyXG4gIH1cclxuICB3aWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgfVxyXG4gIGhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gIH1cclxuICBvYnNlcnZlKCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAvLyBtYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSBjdXJyZW50IHZpc2libGUgc3RhdGUgb25jZSB3ZSBzdGFydCB0byBvYnNlcnZlXHJcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNFbGVtZW50SW5WaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XHJcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMuaGFuZGxlUmVzaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XHJcbiAgICBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcclxuICAgIGdldFJlc2l6ZU9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XHJcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcclxuICAgIChfYSA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XHJcbiAgICAoX2MgPSAoX2IgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2luZG93KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xyXG4gIH1cclxuICBzdG9wT2JzZXJ2aW5nKCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgIChfYSA9IGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcclxuICAgIChfYiA9IGdldFJlc2l6ZU9ic2VydmVyKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51bm9ic2VydmUodGhpcy5lbGVtZW50KTtcclxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uRW50ZXJQaVApO1xyXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XHJcbiAgICAoX2MgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW50ZXInLCB0aGlzLm9uRW50ZXJQaVApO1xyXG4gICAgKF9lID0gKF9kID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpbmRvdykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNFbGVtZW50SW5QaVAoZWwpIHtcclxuICB2YXIgX2EsIF9iO1xyXG4gIC8vIFNpbXBsZSB2aWRlbyBQaVBcclxuICBpZiAoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsKSByZXR1cm4gdHJ1ZTtcclxuICAvLyBEb2N1bWVudCBQaVBcclxuICBpZiAoKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpbmRvdykgcmV0dXJuIGlzRWxlbWVudEluVmlld3BvcnQoZWwsIChfYiA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aW5kb3cpO1xyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBkb2VzIG5vdCBhY2NvdW50IGZvciBvY2NsdXNpb24gYnkgb3RoZXIgZWxlbWVudHMgb3Igb3BhY2l0eSBwcm9wZXJ0eVxyXG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCB3aW4pIHtcclxuICBjb25zdCB2aWV3cG9ydFdpbmRvdyA9IHdpbiB8fCB3aW5kb3c7XHJcbiAgbGV0IHRvcCA9IGVsLm9mZnNldFRvcDtcclxuICBsZXQgbGVmdCA9IGVsLm9mZnNldExlZnQ7XHJcbiAgY29uc3Qgd2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcclxuICBjb25zdCBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XHJcbiAgY29uc3Qge1xyXG4gICAgaGlkZGVuXHJcbiAgfSA9IGVsO1xyXG4gIGNvbnN0IHtcclxuICAgIGRpc3BsYXlcclxuICB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgd2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xyXG4gICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XHJcbiAgICB0b3AgKz0gZWwub2Zmc2V0VG9wO1xyXG4gICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xyXG4gIH1cclxuICByZXR1cm4gdG9wIDwgdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgKyB2aWV3cG9ydFdpbmRvdy5pbm5lckhlaWdodCAmJiBsZWZ0IDwgdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgKyB2aWV3cG9ydFdpbmRvdy5pbm5lcldpZHRoICYmIHRvcCArIGhlaWdodCA+IHZpZXdwb3J0V2luZG93LnBhZ2VZT2Zmc2V0ICYmIGxlZnQgKyB3aWR0aCA+IHZpZXdwb3J0V2luZG93LnBhZ2VYT2Zmc2V0ICYmICFoaWRkZW4gJiYgZGlzcGxheSAhPT0gJ25vbmUnO1xyXG59XHJcblxyXG5jbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKGtpbmQsIGlkLCBuYW1lLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmVuY3J5cHRpb24gPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcclxuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcclxuICAgIHRoaXMuaGFuZGxlTXV0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVVubXV0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMgPT09IG51bGwgfHwgbG9nZ2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XHJcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IHRoaXMubG9nZ2VyQ29udGV4dENiO1xyXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcclxuICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB0aGlzLnRyYWNrU2lkID0gaWQ7XHJcbiAgICB0aGlzLnRyYWNrTmFtZSA9IG5hbWU7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0VHJhY2sodHJhY2spIHtcclxuICAgIGlmICh0aGlzLnRyYWNrKSB7XHJcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xyXG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRyYWNrID0gdHJhY2s7XHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgLy8gZm9yd2FyZCBldmVudHNcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpKTtcclxuICB9XHJcbiAgZ2V0IGlzTXV0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YU11dGVkO1xyXG4gIH1cclxuICBnZXQgaXNFbmFibGVkKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFjayAhPT0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogYW4gW0F1ZGlvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYW4gYXVkaW8gdHJhY2tcclxuICAgKi9cclxuICBnZXQgYXVkaW9UcmFjaygpIHtcclxuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcclxuICAgKi9cclxuICBnZXQgdmlkZW9UcmFjaygpIHtcclxuICAgIGlmIChpc1ZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICB1cGRhdGVJbmZvKGluZm8pIHtcclxuICAgIHRoaXMudHJhY2tTaWQgPSBpbmZvLnNpZDtcclxuICAgIHRoaXMudHJhY2tOYW1lID0gaW5mby5uYW1lO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xyXG4gICAgdGhpcy5taW1lVHlwZSA9IGluZm8ubWltZVR5cGU7XHJcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIGluZm8ud2lkdGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcclxuICAgICAgICB3aWR0aDogaW5mby53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGluZm8uaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuc2ltdWxjYXN0ZWQgPSBpbmZvLnNpbXVsY2FzdDtcclxuICAgIH1cclxuICAgIHRoaXMuZW5jcnlwdGlvbiA9IGluZm8uZW5jcnlwdGlvbjtcclxuICAgIHRoaXMudHJhY2tJbmZvID0gaW5mbztcclxuICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGUgcHVibGljYXRpb24gaW5mbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICBpbmZvXHJcbiAgICB9KSk7XHJcbiAgfVxyXG59XHJcbihmdW5jdGlvbiAoVHJhY2tQdWJsaWNhdGlvbikge1xyXG4gIChmdW5jdGlvbiAoU3Vic2NyaXB0aW9uU3RhdHVzKSB7XHJcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJEZXNpcmVkXCJdID0gXCJkZXNpcmVkXCI7XHJcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XHJcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xyXG4gIH0pKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XHJcbiAgKGZ1bmN0aW9uIChQZXJtaXNzaW9uU3RhdHVzKSB7XHJcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiQWxsb3dlZFwiXSA9IFwiYWxsb3dlZFwiO1xyXG4gICAgUGVybWlzc2lvblN0YXR1c1tcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdF9hbGxvd2VkXCI7XHJcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgPSB7fSkpO1xyXG59KShUcmFja1B1YmxpY2F0aW9uIHx8IChUcmFja1B1YmxpY2F0aW9uID0ge30pKTtcclxuXHJcbmNsYXNzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xyXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkO1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgdHJhY2ssIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLnRyYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcclxuICAgIHRoaXMuc2V0VHJhY2sodHJhY2spO1xyXG4gIH1cclxuICBzZXRUcmFjayh0cmFjaykge1xyXG4gICAgaWYgKHRoaXMudHJhY2spIHtcclxuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcclxuICAgIH1cclxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgaXNNdXRlZCgpIHtcclxuICAgIGlmICh0aGlzLnRyYWNrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrLmlzTXV0ZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXIuaXNNdXRlZDtcclxuICB9XHJcbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XHJcbiAgICByZXR1cm4gc3VwZXIuYXVkaW9UcmFjaztcclxuICB9XHJcbiAgZ2V0IHZpZGVvVHJhY2soKSB7XHJcbiAgICByZXR1cm4gc3VwZXIudmlkZW9UcmFjaztcclxuICB9XHJcbiAgZ2V0IGlzTG9jYWwoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTXV0ZSB0aGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cclxuICAgKi9cclxuICBtdXRlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11dGUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBVbm11dGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cclxuICAgKi9cclxuICB1bm11dGUoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5tdXRlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gZnJvbSBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcclxuICAgKiBhbmQgc2lnbmFscyBcIm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzXHJcbiAgICogVXNlZnVsIGlmIHlvdSB3YW50IHRvIHBhdXNlIHRoZSBzdHJlYW0gd2l0aG91dCBwYXVzaW5nIHRoZSBsb2NhbCBtZWRpYSBzdHJlYW0gdHJhY2tcclxuICAgKi9cclxuICBwYXVzZVVwc3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VVcHN0cmVhbSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cclxuICAgKiBhbmQgc2lnbmFscyBcInVubXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHMgKHVubGVzcyB0aGUgdHJhY2sgaXMgZXhwbGljaXRseSBtdXRlZClcclxuICAgKi9cclxuICByZXN1bWVVcHN0cmVhbSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgeWllbGQgKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZVVwc3RyZWFtKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0VHJhY2tGZWF0dXJlcygpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcclxuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnRyYWNrLmdldFNvdXJjZVRyYWNrU2V0dGluZ3MoKTtcclxuICAgICAgY29uc3QgZmVhdHVyZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgIGlmIChzZXR0aW5ncy5hdXRvR2FpbkNvbnRyb2wpIHtcclxuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfQVVUT19HQUlOX0NPTlRST0wpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXR0aW5ncy5lY2hvQ2FuY2VsbGF0aW9uKSB7XHJcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VDSE9fQ0FOQ0VMTEFUSU9OKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGluZ3Mubm9pc2VTdXBwcmVzc2lvbikge1xyXG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT0lTRV9TVVBQUkVTU0lPTik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNldHRpbmdzLmNoYW5uZWxDb3VudCAmJiBzZXR0aW5ncy5jaGFubmVsQ291bnQgPiAxKSB7XHJcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1NURVJFTyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCEoKF9hID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHR4KSkge1xyXG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT19EVFgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnRyYWNrLmVuaGFuY2VkTm9pc2VDYW5jZWxsYXRpb24pIHtcclxuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShmZWF0dXJlcy52YWx1ZXMoKSk7XHJcbiAgICB9IGVsc2UgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBsb2NhbCB2aWRlbyBhbmQgYXVkaW8gdHJhY2sgYXQgdGhlIHNhbWUgdGltZS4gV2hlbiBhY3F1aXJpbmcgYm90aFxyXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXHJcbiAqIHRoZSB1c2VyIGluc3RlYWQgb2YgdHdvIHNlcGFyYXRlIG9uZXMuXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFRyYWNrcyhvcHRpb25zLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcclxuICAgIGxldCBhdHRlbXB0RXhhY3RNYXRjaCA9IGZhbHNlO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBhdWRpb1Byb2Nlc3NvcixcclxuICAgICAgdmlkZW9Qcm9jZXNzb3IsXHJcbiAgICAgIG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yOiBpbnRlcm5hbE9wdGlvbnNcclxuICAgIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgbGV0IHJldHJ5QXVkaW9PcHRpb25zID0gaW50ZXJuYWxPcHRpb25zLmF1ZGlvO1xyXG4gICAgbGV0IHJldHJ5VmlkZW9PcHRpb25zID0gaW50ZXJuYWxPcHRpb25zLnZpZGVvO1xyXG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpby5wcm9jZXNzb3IgPSBhdWRpb1Byb2Nlc3NvcjtcclxuICAgIH1cclxuICAgIGlmICh2aWRlb1Byb2Nlc3NvciAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8ucHJvY2Vzc29yID0gdmlkZW9Qcm9jZXNzb3I7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGUgdXNlciBwYXNzZXMgYSBkZXZpY2UgaWQgYXMgYSBzdHJpbmcsIHdlIGRlZmF1bHQgdG8gZXhhY3QgbWF0Y2hcclxuICAgIGlmIChvcHRpb25zLmF1ZGlvICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGNvbnN0IGRldmljZUlkID0gaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkO1xyXG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPSB7XHJcbiAgICAgICAgZXhhY3Q6IGRldmljZUlkXHJcbiAgICAgIH07XHJcbiAgICAgIGF0dGVtcHRFeGFjdE1hdGNoID0gdHJ1ZTtcclxuICAgICAgcmV0cnlBdWRpb09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsT3B0aW9ucy5hdWRpbyksIHtcclxuICAgICAgICBkZXZpY2VJZDoge1xyXG4gICAgICAgICAgaWRlYWw6IGRldmljZUlkXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8gJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgY29uc3QgZGV2aWNlSWQgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQ7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCA9IHtcclxuICAgICAgICBleGFjdDogZGV2aWNlSWRcclxuICAgICAgfTtcclxuICAgICAgYXR0ZW1wdEV4YWN0TWF0Y2ggPSB0cnVlO1xyXG4gICAgICByZXRyeVZpZGVvT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxPcHRpb25zLnZpZGVvKSwge1xyXG4gICAgICAgIGRldmljZUlkOiB7XHJcbiAgICAgICAgICBpZGVhbDogZGV2aWNlSWRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSB8fCB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiAhaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkKSB7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpbyA9IHtcclxuICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSB0cnVlKSB7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlbyA9IHtcclxuICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmICFpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQpIHtcclxuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID0gJ2RlZmF1bHQnO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMoaW50ZXJuYWxPcHRpb25zLCBhdWRpb0RlZmF1bHRzLCB2aWRlb0RlZmF1bHRzKTtcclxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xyXG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxyXG4gICAgLy8gd29ya3MgYXJvdW5kIGlPUyBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcclxuICAgIGNvbnN0IG1lZGlhUHJvbWlzZSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcclxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMuYXVkaW8pIHtcclxuICAgICAgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNldCgnYXVkaW9pbnB1dCcsIG1lZGlhUHJvbWlzZSk7XHJcbiAgICAgIG1lZGlhUHJvbWlzZS5jYXRjaCgoKSA9PiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuZGVsZXRlKCdhdWRpb2lucHV0JykpO1xyXG4gICAgfVxyXG4gICAgaWYgKGludGVybmFsT3B0aW9ucy52aWRlbykge1xyXG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCd2aWRlb2lucHV0JywgbWVkaWFQcm9taXNlKTtcclxuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ3ZpZGVvaW5wdXQnKSk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBtZWRpYVByb21pc2U7XHJcbiAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLmFsbChzdHJlYW0uZ2V0VHJhY2tzKCkubWFwKG1lZGlhU3RyZWFtVHJhY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGlzQXVkaW8gPSBtZWRpYVN0cmVhbVRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XHJcbiAgICAgICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRzLmF1ZGlvIDogb3B0cy52aWRlbztcclxuICAgICAgICBpZiAodHlwZW9mIHRyYWNrT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nIHx8ICF0cmFja09wdGlvbnMpIHtcclxuICAgICAgICAgIHRyYWNrT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdHJhY2tDb25zdHJhaW50cztcclxuICAgICAgICBjb25zdCBjb25PckJvb2wgPSBpc0F1ZGlvID8gY29uc3RyYWludHMuYXVkaW8gOiBjb25zdHJhaW50cy52aWRlbztcclxuICAgICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzID0gY29uT3JCb29sO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBlYWNoIHRyYWNrIHJlc3RhcnQgKGUuZy4gbXV0ZSAtIHVubXV0ZSkgd2lsbCB0cnkgdG8gaW5pdGlhbGl6ZSB0aGUgZGV2aWNlIGFnYWluIC0+IGNhdXNpbmcgYWRkaXRpb25hbCBwZXJtaXNzaW9uIHByb21wdHNcclxuICAgICAgICBjb25zdCBuZXdEZXZpY2VJZCA9IG1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcclxuICAgICAgICBpZiAoKHRyYWNrQ29uc3RyYWludHMgPT09IG51bGwgfHwgdHJhY2tDb25zdHJhaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgJiYgdW53cmFwQ29uc3RyYWludCh0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkKSAhPT0gbmV3RGV2aWNlSWQpIHtcclxuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMuZGV2aWNlSWQgPSBuZXdEZXZpY2VJZDtcclxuICAgICAgICB9IGVsc2UgaWYgKCF0cmFja0NvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzID0ge1xyXG4gICAgICAgICAgICBkZXZpY2VJZDogbmV3RGV2aWNlSWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYWNrID0gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCB0cmFja0NvbnN0cmFpbnRzLCBsb2dnZXJPcHRpb25zKTtcclxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcclxuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbSA9IHN0cmVhbTtcclxuICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSAmJiBhdWRpb1Byb2Nlc3Nvcikge1xyXG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKGF1ZGlvUHJvY2Vzc29yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykgJiYgdmlkZW9Qcm9jZXNzb3IpIHtcclxuICAgICAgICAgIHlpZWxkIHRyYWNrLnNldFByb2Nlc3Nvcih2aWRlb1Byb2Nlc3Nvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cmFjaztcclxuICAgICAgfSkpKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaWYgKCFhdHRlbXB0RXhhY3RNYXRjaCkge1xyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsVHJhY2tzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHtcclxuICAgICAgICBhdWRpbzogcmV0cnlBdWRpb09wdGlvbnMsXHJcbiAgICAgICAgdmlkZW86IHJldHJ5VmlkZW9PcHRpb25zXHJcbiAgICAgIH0pLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIFtbTG9jYWxWaWRlb1RyYWNrXV0gd2l0aCBnZXRVc2VyTWVkaWEoKVxyXG4gKiBAcGFyYW0gb3B0aW9uc1xyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xyXG4gICAgICBhdWRpbzogZmFsc2UsXHJcbiAgICAgIHZpZGVvOiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cmFja3NbMF07XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3Moe1xyXG4gICAgICBhdWRpbzogb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogdHJ1ZSxcclxuICAgICAgdmlkZW86IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cmFja3NbMF07XHJcbiAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cclxuICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyhvcHRpb25zKSB7XHJcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcclxuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gU2NyZWVuU2hhcmVQcmVzZXRzLmgxMDgwZnBzMzAucmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XHJcbiAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcclxuICAgIHNjcmVlblZpZGVvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcclxuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcclxuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSk7XHJcbiAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xyXG4gICAgICBsb2NhbFRyYWNrcy5wdXNoKHNjcmVlbkF1ZGlvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbFRyYWNrcztcclxuICB9KTtcclxufVxyXG5cclxudmFyIENvbm5lY3Rpb25RdWFsaXR5O1xyXG4oZnVuY3Rpb24gKENvbm5lY3Rpb25RdWFsaXR5KSB7XHJcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xyXG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiR29vZFwiXSA9IFwiZ29vZFwiO1xyXG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiUG9vclwiXSA9IFwicG9vclwiO1xyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IGEgcGFydGljaXBhbnQgaGFzIHRlbXBvcmFyaWx5IChvciBwZXJtYW5lbnRseSkgbG9zdCBjb25uZWN0aW9uIHRvIExpdmVLaXQuXHJcbiAgICogRm9yIHBlcm1hbmVudCBkaXNjb25uZWN0aW9uIGEgYFBhcnRpY2lwYW50RGlzY29ubmVjdGVkYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgYWZ0ZXIgYSB0aW1lb3V0XHJcbiAgICovXHJcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJMb3N0XCJdID0gXCJsb3N0XCI7XHJcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XHJcbn0pKENvbm5lY3Rpb25RdWFsaXR5IHx8IChDb25uZWN0aW9uUXVhbGl0eSA9IHt9KSk7XHJcbmZ1bmN0aW9uIHF1YWxpdHlGcm9tUHJvdG8ocSkge1xyXG4gIHN3aXRjaCAocSkge1xyXG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkVYQ0VMTEVOVDpcclxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LkV4Y2VsbGVudDtcclxuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5HT09EOlxyXG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuR29vZDtcclxuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5QT09SOlxyXG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuUG9vcjtcclxuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5MT1NUOlxyXG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuTG9zdDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xyXG4gIH1cclxufVxyXG5jbGFzcyBQYXJ0aWNpcGFudCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xyXG4gIH1cclxuICBnZXQgaXNFbmNyeXB0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zaXplID4gMCAmJiBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmV2ZXJ5KHRyID0+IHRyLmlzRW5jcnlwdGVkKTtcclxuICB9XHJcbiAgZ2V0IGlzQWdlbnQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZ2VudCkgfHwgdGhpcy5raW5kID09PSBQYXJ0aWNpcGFudEluZm9fS2luZC5BR0VOVDtcclxuICB9XHJcbiAgZ2V0IGlzQWN0aXZlKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLnBhcnRpY2lwYW50SW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSA9PT0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRTtcclxuICB9XHJcbiAgZ2V0IGtpbmQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fa2luZDtcclxuICB9XHJcbiAgLyoqIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMsIHNpbWlsYXIgdG8gbWV0YWRhdGEsIGJ1dCBhcyBhIGtleS92YWx1ZSBtYXAgKi9cclxuICBnZXQgYXR0cmlidXRlcygpIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2F0dHJpYnV0ZXMpKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXHJcbiAgICB0aGlzLmF1ZGlvTGV2ZWwgPSAwO1xyXG4gICAgLyoqIGlmIHBhcnRpY2lwYW50IGlzIGN1cnJlbnRseSBzcGVha2luZyAqL1xyXG4gICAgdGhpcy5pc1NwZWFraW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUGFydGljaXBhbnQpO1xyXG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcclxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XHJcbiAgICB0aGlzLnNpZCA9IHNpZDtcclxuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5fa2luZCA9IGtpbmQ7XHJcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzICE9PSB2b2lkIDAgPyBhdHRyaWJ1dGVzIDoge307XHJcbiAgfVxyXG4gIGdldFRyYWNrUHVibGljYXRpb25zKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHNvdXJjZSBmaWx0ZXIsIGZvciBleGFtcGxlLCBnZXR0aW5nXHJcbiAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxyXG4gICAqL1xyXG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlKSB7XHJcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xyXG4gICAgICBpZiAocHViLnNvdXJjZSA9PT0gc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1YjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSB0cmFjaydzIG5hbWUuXHJcbiAgICovXHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XHJcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xyXG4gICAgICBpZiAocHViLnRyYWNrTmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwdWI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2FpdHMgdW50aWwgdGhlIHBhcnRpY2lwYW50IGlzIGFjdGl2ZSBhbmQgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhIG1lc3NhZ2VzXHJcbiAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlXHJcbiAgICovXHJcbiAgd2FpdFVudGlsQWN0aXZlKCkge1xyXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYWN0aXZlRnV0dXJlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUZ1dHVyZS5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hY3RpdmVGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICB0aGlzLm9uY2UoUGFydGljaXBhbnRFdmVudC5BY3RpdmUsICgpID0+IHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgKF9iID0gKF9hID0gdGhpcy5hY3RpdmVGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgIHRoaXMuYWN0aXZlRnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGdXR1cmUucHJvbWlzZTtcclxuICB9XHJcbiAgZ2V0IGNvbm5lY3Rpb25RdWFsaXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xyXG4gIH1cclxuICBnZXQgaXNDYW1lcmFFbmFibGVkKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLkNhbWVyYSk7XHJcbiAgICByZXR1cm4gISgoX2EgPSB0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2suaXNNdXRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgfVxyXG4gIGdldCBpc01pY3JvcGhvbmVFbmFibGVkKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xyXG4gICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xyXG4gIH1cclxuICBnZXQgaXNTY3JlZW5TaGFyZUVuYWJsZWQoKSB7XHJcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpO1xyXG4gICAgcmV0dXJuICEhdHJhY2s7XHJcbiAgfVxyXG4gIGdldCBpc0xvY2FsKCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKiogd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb20gKi9cclxuICBnZXQgam9pbmVkQXQoKSB7XHJcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0aGlzLnBhcnRpY2lwYW50SW5mby5qb2luZWRBdC50b1N0cmluZygpKSAqIDEwMDApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICB1cGRhdGVJbmZvKGluZm8pIHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIHVwZGF0ZSBjb3VsZCBiZSBhcHBsaWVkIG91dCBvZiBvcmRlciBkdWUgdG8gYXdhaXRcclxuICAgIC8vIGR1cmluZyByZWNvbm5lY3Qgc2VxdWVuY2VzLiB3aGVuIHRoYXQgaGFwcGVucywgaXQncyBwb3NzaWJsZSBmb3Igc2VydmVyXHJcbiAgICAvLyB0byBoYXZlIHNlbnQgbW9yZSByZWNlbnQgdmVyc2lvbiBvZiBwYXJ0aWNpcGFudCBpbmZvIHdoaWxlIEpTIGlzIHdhaXRpbmdcclxuICAgIC8vIHRvIHByb2Nlc3MgdGhlIGV4aXN0aW5nIHBheWxvYWQuXHJcbiAgICAvLyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBzaWQgcmVtYWlucyB0aGUgc2FtZSwgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIGxhdGVyIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSBwYXlsb2FkLCB0aGV5IGNhbiBiZSBzYWZlbHkgc2tpcHBlZFxyXG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvICYmIHRoaXMucGFydGljaXBhbnRJbmZvLnNpZCA9PT0gaW5mby5zaWQgJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8udmVyc2lvbiA+IGluZm8udmVyc2lvbikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLmlkZW50aXR5ID0gaW5mby5pZGVudGl0eTtcclxuICAgIHRoaXMuc2lkID0gaW5mby5zaWQ7XHJcbiAgICB0aGlzLl9zZXROYW1lKGluZm8ubmFtZSk7XHJcbiAgICB0aGlzLl9zZXRNZXRhZGF0YShpbmZvLm1ldGFkYXRhKTtcclxuICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoaW5mby5hdHRyaWJ1dGVzKTtcclxuICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFICYmICgoX2EgPSB0aGlzLnBhcnRpY2lwYW50SW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSkge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BY3RpdmUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xyXG4gICAgICB0aGlzLnNldFBlcm1pc3Npb25zKGluZm8ucGVybWlzc2lvbik7XHJcbiAgICB9XHJcbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xyXG4gICAgdGhpcy5wYXJ0aWNpcGFudEluZm8gPSBpbmZvO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcclxuICAgKiovXHJcbiAgX3NldE1ldGFkYXRhKG1kKSB7XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5tZXRhZGF0YSAhPT0gbWQ7XHJcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xyXG4gICAgdGhpcy5tZXRhZGF0YSA9IG1kO1xyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHByZXZNZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9zZXROYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcclxuICAgKiovXHJcbiAgX3NldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xyXG4gICAgY29uc3QgZGlmZiA9IGRpZmZBdHRyaWJ1dGVzKHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XHJcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgIGlmIChPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBkaWZmKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gcGVybWlzc2lvbnMuY2FuUHVibGlzaCAhPT0gKChfYSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5QdWJsaXNoKSB8fCBwZXJtaXNzaW9ucy5jYW5TdWJzY3JpYmUgIT09ICgoX2IgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuU3Vic2NyaWJlKSB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoRGF0YSAhPT0gKChfYyA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYW5QdWJsaXNoRGF0YSkgfHwgcGVybWlzc2lvbnMuaGlkZGVuICE9PSAoKF9kID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmhpZGRlbikgfHwgcGVybWlzc2lvbnMucmVjb3JkZXIgIT09ICgoX2UgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVjb3JkZXIpIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCAhPT0gdGhpcy5wZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5sZW5ndGggfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMuc29tZSgodmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSk7XHJcbiAgICB9KSB8fCBwZXJtaXNzaW9ucy5jYW5TdWJzY3JpYmVNZXRyaWNzICE9PSAoKF9mID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhblN1YnNjcmliZU1ldHJpY3MpO1xyXG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldElzU3BlYWtpbmcoc3BlYWtpbmcpIHtcclxuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xyXG4gICAgaWYgKHNwZWFraW5nKSB7XHJcbiAgICAgIHRoaXMubGFzdFNwb2tlQXQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuSXNTcGVha2luZ0NoYW5nZWQsIHNwZWFraW5nKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHEpIHtcclxuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSA9IHF1YWxpdHlGcm9tUHJvdG8ocSk7XHJcbiAgICBpZiAocHJldlF1YWxpdHkgIT09IHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5KSB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBzZXREaXNjb25uZWN0ZWQoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgaWYgKHRoaXMuYWN0aXZlRnV0dXJlKSB7XHJcbiAgICAgIChfYiA9IChfYSA9IHRoaXMuYWN0aXZlRnV0dXJlKS5yZWplY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXcgRXJyb3IoJ1BhcnRpY2lwYW50IGRpc2Nvbm5lY3RlZCcpKTtcclxuICAgICAgdGhpcy5hY3RpdmVGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldEF1ZGlvQ29udGV4dChjdHgpIHtcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xyXG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHJhY2sgPT4gaXNBdWRpb1RyYWNrKHRyYWNrLnRyYWNrKSAmJiB0cmFjay50cmFjay5zZXRBdWRpb0NvbnRleHQoY3R4KSk7XHJcbiAgfVxyXG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcclxuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5NdXRlZCwgKCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWJsaWNhdGlvbik7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgKCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcHViID0gcHVibGljYXRpb247XHJcbiAgICBpZiAocHViLnRyYWNrKSB7XHJcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcclxuICAgIH1cclxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuc2V0KHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBwdWJsaWNhdGlvbik7XHJcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcclxuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxyXG4gICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxyXG4gICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocGVybXMpIHtcclxuICB2YXIgX2EsIF9iLCBfYztcclxuICBpZiAoIXBlcm1zLnBhcnRpY2lwYW50U2lkICYmICFwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhY2sgcGVybWlzc2lvbiwgbXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBvZiBwYXJ0aWNpcGFudElkZW50aXR5IGFuZCBwYXJ0aWNpcGFudFNpZCcpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IFRyYWNrUGVybWlzc2lvbih7XHJcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiAoX2EgPSBwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyxcclxuICAgIHBhcnRpY2lwYW50U2lkOiAoX2IgPSBwZXJtcy5wYXJ0aWNpcGFudFNpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXHJcbiAgICBhbGxUcmFja3M6IChfYyA9IHBlcm1zLmFsbG93QWxsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSxcclxuICAgIHRyYWNrU2lkczogcGVybXMuYWxsb3dlZFRyYWNrU2lkcyB8fCBbXVxyXG4gIH0pO1xyXG59XHJcblxyXG5jb25zdCBTVFJFQU1fQ0hVTktfU0laRSA9IDE1MDAwO1xyXG5jbGFzcyBMb2NhbFBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBlbmdpbmUsIG9wdGlvbnMsIHJvb21ScGNIYW5kbGVycykge1xyXG4gICAgc3VwZXIoc2lkLCBpZGVudGl0eSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xyXG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5lbmdpbmUubG9nQ29udGV4dFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nID0gbmV3IFNldCgpO1xyXG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBbXTtcclxuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gdHJ1ZTtcclxuICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcclxuICAgIHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcyA9IFtdO1xyXG4gICAgdGhpcy5wZW5kaW5nQWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMucmVjb25uZWN0RnV0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgaWYgKHRoaXMucmVjb25uZWN0RnV0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oZS5tZXNzYWdlLCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlamVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsICdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkge1xyXG4gICAgICAgIChfZCA9IChfYyA9IHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKS5yZWplY3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCAnR290IGRpc2Nvbm5lY3RlZCB3aXRob3V0IHNpZ25hbCBjb25uZWN0ZWQnKTtcclxuICAgICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICAoX2YgPSAoX2UgPSB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVqZWN0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgJ0dvdCBkaXNjb25uZWN0ZWQgd2l0aG91dCBhY3RpdmUgYWdlbnQgcHJlc2VudCcpO1xyXG4gICAgICB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTaWduYWxDb25uZWN0ZWQgPSBqb2luUmVzcG9uc2UgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBpZiAoam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvKGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkge1xyXG4gICAgICAgIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIChfYiA9IChfYSA9IHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIG1lc3NhZ2VcclxuICAgICAgfSA9IHJlc3BvbnNlO1xyXG4gICAgICBjb25zdCB0YXJnZXRSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XHJcbiAgICAgIGlmICh0YXJnZXRSZXF1ZXN0KSB7XHJcbiAgICAgICAgaWYgKHJlYXNvbiAhPT0gUmVxdWVzdFJlc3BvbnNlX1JlYXNvbi5PSykge1xyXG4gICAgICAgICAgdGFyZ2V0UmVxdWVzdC5yZWplY3QobmV3IFNpZ25hbFJlcXVlc3RFcnJvcihtZXNzYWdlLCByZWFzb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSBwYWNrZXQgPT4ge1xyXG4gICAgICBzd2l0Y2ggKHBhY2tldC52YWx1ZS5jYXNlKSB7XHJcbiAgICAgICAgY2FzZSAncnBjUmVzcG9uc2UnOlxyXG4gICAgICAgICAgbGV0IHJwY1Jlc3BvbnNlID0gcGFja2V0LnZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgbGV0IHBheWxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcclxuICAgICAgICAgIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAncGF5bG9hZCcpIHtcclxuICAgICAgICAgICAgcGF5bG9hZCA9IHJwY1Jlc3BvbnNlLnZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgICAgIGVycm9yID0gUnBjRXJyb3IuZnJvbVByb3RvKHJwY1Jlc3BvbnNlLnZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShycGNSZXNwb25zZS5yZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3JwY0Fjayc6XHJcbiAgICAgICAgICBsZXQgcnBjQWNrID0gcGFja2V0LnZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY0FjayhycGNBY2sucmVxdWVzdElkKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgdHJhY2sgc3Vic2NyaXB0aW9uIHBlcm1pc3Npb25zJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgYWxsUGFydGljaXBhbnRzQWxsb3dlZDogdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsXHJcbiAgICAgICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc1xyXG4gICAgICB9KSk7XHJcbiAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnModGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLm1hcChwID0+IHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocCkpKTtcclxuICAgIH07XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0aGlzLm9uVHJhY2tVbm11dGVkID0gdHJhY2sgPT4ge1xyXG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNVcHN0cmVhbVBhdXNlZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gd2hlbiB0aGUgbG9jYWwgdHJhY2sgY2hhbmdlcyBpbiBtdXRlIHN0YXR1cywgd2UnbGwgbm90aWZ5IHNlcnZlciBhcyBzdWNoXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0aGlzLm9uVHJhY2tNdXRlZCA9ICh0cmFjaywgbXV0ZWQpID0+IHtcclxuICAgICAgaWYgKG11dGVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtdXRlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0cmFjay5zaWQpIHtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IHVwZGF0ZSBtdXRlIHN0YXR1cyBmb3IgdW5wdWJsaXNoZWQgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZW5naW5lLnVwZGF0ZU11dGVTdGF0dXModHJhY2suc2lkLCBtdXRlZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQgPSB0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSBwYXVzZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQgPSB0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cHN0cmVhbSByZXN1bWVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNNdXRlZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSA9IHRyYWNrID0+IHtcclxuICAgICAgY29uc3QgcHViID0gdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmdldCh0cmFjay5zaWQpO1xyXG4gICAgICBpZiAoIXB1Yikge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3QgdXBkYXRlIGxvY2FsIGF1ZGlvIHRyYWNrIHNldHRpbmdzLCBtaXNzaW5nIHB1YmxpY2F0aW9uIGZvciB0cmFjayBcIi5jb25jYXQodHJhY2suc2lkKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrU2lkLCBwdWIuZ2V0VHJhY2tGZWF0dXJlcygpKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcclxuICAgICAgdmFyIF9kO1xyXG4gICAgICBpZiAoISgoX2QgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZHluYWNhc3QpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcclxuICAgICAgaWYgKCFwdWIpIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdyZWNlaXZlZCBzdWJzY3JpYmVkIHF1YWxpdHkgdXBkYXRlIGZvciB1bmtub3duIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IHlpZWxkIHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgbmV3Q29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKG5ld0NvZGVjcyksIG5ld0NvZGVjc18xXzE7IG5ld0NvZGVjc18xXzEgPSB5aWVsZCBuZXdDb2RlY3NfMS5uZXh0KCksIF9hID0gbmV3Q29kZWNzXzFfMS5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xyXG4gICAgICAgICAgX2MgPSBuZXdDb2RlY3NfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgX2UgPSBmYWxzZTtcclxuICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2M7XHJcbiAgICAgICAgICBpZiAoaXNCYWNrdXBDb2RlYyhjb2RlYykpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoIFwiLmNvbmNhdChjb2RlYywgXCIgZm9yIFwiKS5jb25jYXQocHViLnZpZGVvVHJhY2suc2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YikpKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2socHViLnZpZGVvVHJhY2ssIGNvZGVjLCBwdWIub3B0aW9ucyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xyXG4gICAgICAgIGVfMSA9IHtcclxuICAgICAgICAgIGVycm9yOiBlXzFfMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IG5ld0NvZGVjc18xLnJldHVybikpIHlpZWxkIF9iLmNhbGwobmV3Q29kZWNzXzEpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5wdWJsaXNoZWQgPT4ge1xyXG4gICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHVucHVibGlzaGVkLnRyYWNrU2lkKTtcclxuICAgICAgaWYgKCF0cmFjaykge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHVucHVibGlzaGVkIGV2ZW50IGZvciB1bmtub3duIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICB0cmFja1NpZDogdW5wdWJsaXNoZWQudHJhY2tTaWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2spO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pIHtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIGxvY2FsIHRyYWNrIGR1ZSB0byBUcmFja0VuZGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spO1xyXG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnMgPSB5aWVsZCBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBlcm1pc3Npb24gcXVlcnkgZm9yIGNhbWVyYSBhbmQgbWljcm9waG9uZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmkgYW5kIEZpcmVmb3hcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSA/ICdjYW1lcmEnIDogJ21pY3JvcGhvbmUnXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucyAmJiBjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgPT09ICdkZW5pZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwidXNlciBoYXMgcmV2b2tlZCBhY2Nlc3MgdG8gXCIuY29uY2F0KHRyYWNrLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBncmFudGVkIGNoYW5nZSBhZnRlciBwZXJtaXNzaW9ucyB3ZXJlIGRlbmllZCB0byB0cnkgYW5kIHJlc3VtZSB0aGVuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgIT09ICdkZW5pZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0cmFjay5yZXN0YXJ0VHJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcm1pc3Npb25zLm9uY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2V0VXNlck1lZGlhIFBlcm1pc3Npb24gZGVuaWVkJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMgcXVlcnkgZmFpbHMgZm9yIGZpcmVmb3gsIHdlIGNvbnRpbnVlIGFuZCB0cnkgdG8gcmVzdGFydCB0aGUgdHJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd0cmFjayBlbmRlZCwgYXR0ZW1wdGluZyB0byB1c2UgYSBkaWZmZXJlbnQgZGV2aWNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRlZmF1bHQgZGV2aWNlIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgIHlpZWxkIHRyYWNrLnJlc3RhcnRUcmFjayh7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlc3RhcnQgdHJhY2ssIG11dGluZyBpbnN0ZWFkXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgdGhpcy5yb29tT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLnNldHVwRW5naW5lKGVuZ2luZSk7XHJcbiAgICB0aGlzLmFjdGl2ZURldmljZU1hcCA9IG5ldyBNYXAoW1snYXVkaW9pbnB1dCcsICdkZWZhdWx0J10sIFsndmlkZW9pbnB1dCcsICdkZWZhdWx0J10sIFsnYXVkaW9vdXRwdXQnLCAnZGVmYXVsdCddXSk7XHJcbiAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMucnBjSGFuZGxlcnMgPSByb29tUnBjSGFuZGxlcnM7XHJcbiAgfVxyXG4gIGdldCBsYXN0Q2FtZXJhRXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFFcnJvcjtcclxuICB9XHJcbiAgZ2V0IGxhc3RNaWNyb3Bob25lRXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWNyb3Bob25lRXJyb3I7XHJcbiAgfVxyXG4gIGdldCBpc0UyRUVFbmFibGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FO1xyXG4gIH1cclxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSkge1xyXG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKTtcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldHVwRW5naW5lKGVuZ2luZSkge1xyXG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCAodHJhY2tTaWQsIG11dGVkKSA9PiB7XHJcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYWNrU2lkKTtcclxuICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAobXV0ZWQpIHtcclxuICAgICAgICBwdWIubXV0ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHB1Yi51bm11dGUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Db25uZWN0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgdGhpcy5oYW5kbGVTaWduYWxDb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UpLm9uKEVuZ2luZUV2ZW50LkRhdGFQYWNrZXRSZWNlaXZlZCwgdGhpcy5oYW5kbGVEYXRhUGFja2V0KTtcclxuICAgIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXHJcbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXHJcbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xyXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxyXG4gICAqL1xyXG4gIHNldE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7XHJcbiAgICAgICAgbWV0YWRhdGFcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbmFtZSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXHJcbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXHJcbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xyXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxyXG4gICAqL1xyXG4gIHNldE5hbWUobmFtZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xyXG4gICAgICAgIG5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0IG9yIHVwZGF0ZSBwYXJ0aWNpcGFudCBhdHRyaWJ1dGVzLiBJdCB3aWxsIG1ha2UgdXBkYXRlcyBvbmx5IHRvIGtleXMgdGhhdFxyXG4gICAqIGFyZSBwcmVzZW50IGluIGBhdHRyaWJ1dGVzYCwgYW5kIHdpbGwgbm90IG92ZXJyaWRlIG90aGVycy5cclxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cclxuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBhdHRyaWJ1dGVzIHRvIHVwZGF0ZVxyXG4gICAqL1xyXG4gIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xyXG4gICAgICAgIGF0dHJpYnV0ZXNcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVxdWVzdE1ldGFkYXRhVXBkYXRlKF9hKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZikge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIG1ldGFkYXRhLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgYXR0cmlidXRlc1xyXG4gICAgICB9ID0gX3JlZjtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGlzUmVqZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0geWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKChfYSA9IG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyBtZXRhZGF0YSA6IHRoaXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCAoX2IgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiB0aGlzLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHtcclxuICAgICAgICAgICAgICByZXNvbHZlLFxyXG4gICAgICAgICAgICAgIHJlamVjdDogZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2hpbGUgKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lIDwgNTAwMCAmJiAhaXNSZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgIGlmICgoIW5hbWUgfHwgdGhpcy5uYW1lID09PSBuYW1lKSAmJiAoIW1ldGFkYXRhIHx8IHRoaXMubWV0YWRhdGEgPT09IG1ldGFkYXRhKSAmJiAoIWF0dHJpYnV0ZXMgfHwgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZXZlcnkoX3JlZjIgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJycgJiYgIXRoaXMuYXR0cmlidXRlc1trZXldO1xyXG4gICAgICAgICAgICAgIH0pKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWplY3QobmV3IFNpZ25hbFJlcXVlc3RFcnJvcignUmVxdWVzdCB0byB1cGRhdGUgbG9jYWwgbWV0YWRhdGEgdGltZWQgb3V0JywgJ1RpbWVvdXRFcnJvcicpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBjYW1lcmEgdHJhY2suXHJcbiAgICpcclxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxyXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcclxuICAgKi9cclxuICBzZXRDYW1lcmFFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLkNhbWVyYSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHBhcnRpY2lwYW50J3MgbWljcm9waG9uZSB0cmFjay5cclxuICAgKlxyXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXHJcbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHNldE1pY3JvcGhvbmVFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3RhcnQgb3Igc3RvcCBzaGFyaW5nIGEgcGFydGljaXBhbnQncyBzY3JlZW5cclxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgc2V0U2NyZWVuU2hhcmVFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXRUcmFja0VuYWJsZWQoVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xyXG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcclxuICAgIGNvbnN0IGNoYW5nZWQgPSBzdXBlci5zZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucyk7XHJcbiAgICBpZiAoY2hhbmdlZCAmJiBwcmV2UGVybWlzc2lvbnMpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldEUyRUVFbmFibGVkKGVuYWJsZWQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBlbmFibGVkID8gRW5jcnlwdGlvbl9UeXBlLkdDTSA6IEVuY3J5cHRpb25fVHlwZS5OT05FO1xyXG4gICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXRUcmFja0VuYWJsZWQoc291cmNlLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldFRyYWNrRW5hYmxlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBlbmFibGVkXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKHRoaXMucmVwdWJsaXNoUHJvbWlzZSkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMucmVwdWJsaXNoUHJvbWlzZTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcclxuICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICBpZiAodHJhY2spIHtcclxuICAgICAgICAgIHlpZWxkIHRyYWNrLnVubXV0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsZXQgbG9jYWxUcmFja3M7XHJcbiAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhY2sgPSB5aWVsZCB0aGlzLndhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAoIXBlbmRpbmdUcmFjaykge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dhaXRpbmcgZm9yIHBlbmRpbmcgcHVibGljYXRpb24gcHJvbWlzZSB0aW1lZCBvdXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZVxyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBwZW5kaW5nVHJhY2sgPT09IG51bGwgfHwgcGVuZGluZ1RyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nVHJhY2sudW5tdXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nVHJhY2s7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChzb3VyY2UpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3dpdGNoIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XHJcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcclxuICAgICAgICAgICAgICAgICAgdmlkZW86IChfYSA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcclxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xyXG4gICAgICAgICAgICAgICAgICBhdWRpbzogKF9iID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTpcclxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVTY3JlZW5UcmFja3MoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihzb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcclxuICAgICAgICAgICAgICB0ci5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUsIHNvdXJjZVRvS2luZChzb3VyY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmIGlzQXVkaW9UcmFjayhsb2NhbFRyYWNrKSAmJiAocHVibGlzaE9wdGlvbnMgPT09IG51bGwgfHwgcHVibGlzaE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1Ymxpc2hPcHRpb25zLnByZUNvbm5lY3RCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnc3RhcnRpbmcgcHJlY29ubmVjdCBidWZmZXIgZm9yIG1pY3JvcGhvbmUnLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgICAgICAgICAgICBsb2NhbFRyYWNrLnN0YXJ0UHJlQ29ubmVjdEJ1ZmZlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbFRyYWNrIG9mIGxvY2FsVHJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygncHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhsb2NhbFRyYWNrKSkpO1xyXG4gICAgICAgICAgICAgIHB1Ymxpc2hQcm9taXNlcy5wdXNoKHRoaXMucHVibGlzaFRyYWNrKGxvY2FsVHJhY2ssIHB1Ymxpc2hPcHRpb25zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcHVibGlzaGVkVHJhY2tzID0geWllbGQgUHJvbWlzZS5hbGwocHVibGlzaFByb21pc2VzKTtcclxuICAgICAgICAgICAgLy8gZm9yIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbnMgaW5jbHVkaW5nIGF1ZGlvLCB0aGlzIHdpbGwgb25seSByZXR1cm4gdGhlIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbiwgbm90IHRoZSBzY3JlZW4gc2hhcmUgYXVkaW8gb25lXHJcbiAgICAgICAgICAgIC8vIHJldmlzaXQgaWYgd2Ugd2FudCB0byByZXR1cm4gYW4gYXJyYXkgb2YgdHJhY2tzIGluc3RlYWQgZm9yIHYyXHJcbiAgICAgICAgICAgIFt0cmFja10gPSBwdWJsaXNoZWRUcmFja3M7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcclxuICAgICAgICAgICAgICB0ci5zdG9wKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoc291cmNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCEodHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLnRyYWNrKSAmJiB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XHJcbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIHRyYWNrIGF2YWlsYWJsZSB5ZXQgZmlyc3Qgd2FpdCBmb3IgcGVuZGluZyBwdWJsaXNoaW5nIHByb21pc2VzIG9mIHRoYXQgc291cmNlIHRvIHNlZSBpZiBpdCBiZWNvbWVzIGF2YWlsYWJsZVxyXG4gICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLndhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgICAgaWYgKCF0cmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCd3YWl0aW5nIGZvciBwZW5kaW5nIHB1YmxpY2F0aW9uIHByb21pc2UgdGltZWQgb3V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgICAgc291cmNlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLnRyYWNrKSB7XHJcbiAgICAgICAgICAvLyBzY3JlZW5zaGFyZSBjYW5ub3QgYmUgbXV0ZWQsIHVucHVibGlzaCBpbnN0ZWFkXHJcbiAgICAgICAgICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpIHtcclxuICAgICAgICAgICAgdHJhY2sgPSB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW9UcmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyk7XHJcbiAgICAgICAgICAgIGlmIChzY3JlZW5BdWRpb1RyYWNrICYmIHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spIHtcclxuICAgICAgICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cmFjaztcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQdWJsaXNoIGJvdGggY2FtZXJhIGFuZCBtaWNyb3Bob25lIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXNlZnVsIGZvclxyXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cclxuICAgKi9cclxuICBlbmFibGVDYW1lcmFBbmRNaWNyb3Bob25lKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5DYW1lcmEpIHx8IHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSkge1xyXG4gICAgICAgIC8vIG5vLW9wIGl0J3MgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcclxuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcclxuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgdmlkZW86IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIGNyZWF0ZVRyYWNrcyhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiBvcHRpb25zID0ge307XHJcbiAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLCAoX2IgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHlpZWxkIGNyZWF0ZUxvY2FsVHJhY2tzKG1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycywge1xyXG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IHRyYWNrcy5tYXAodHJhY2sgPT4ge1xyXG4gICAgICAgICAgaWYgKGlzQXVkaW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XHJcbiAgICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgIGlmIChvcHRpb25zLmF1ZGlvKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gZXJyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMudmlkZW8pIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IGVycjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxyXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cclxuICAgKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXHJcbiAgICovXHJcbiAgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTcoKSkge1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxyXG4gICAgICAgIC8vIGR1ZSB0byBlbmNvZGluZyBhIGh1Z2UgdmlkZW8uIEVuY29kaW5nIHN1Y2ggbGFyZ2Ugc3VyZmFjZXMgaXMgcmVhbGx5IGV4cGVuc2l2ZVxyXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlbHkgU2FmYXJpIDE3IGhhcyBhIGJ1dCBhbmQgY2Fubm90IGJlIGNvbnN0cmFpbmVkIGJ5IGRlZmF1bHRcclxuICAgICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcclxuICAgICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSwge1xyXG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICB9KTtcclxuICAgICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xyXG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50SGludCkge1xyXG4gICAgICAgIHNjcmVlblZpZGVvLm1lZGlhU3RyZWFtVHJhY2suY29udGVudEhpbnQgPSBvcHRpb25zLmNvbnRlbnRIaW50O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcclxuICAgICAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcclxuICAgICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XHJcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xyXG4gICAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsb2NhbFRyYWNrcztcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQdWJsaXNoIGEgbmV3IHRyYWNrIHRvIHRoZSByb29tXHJcbiAgICogQHBhcmFtIHRyYWNrXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKi9cclxuICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrLCBvcHRpb25zKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBwdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFja18xLCBvcHRpb25zXzEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh0cmFjaywgb3B0aW9ucykge1xyXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgbGV0IGlzUmVwdWJsaXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dChfdGhpczIuYXVkaW9Db250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgKF9hID0gX3RoaXMyLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb21pc2U7XHJcbiAgICAgICAgaWYgKF90aGlzMi5yZXB1Ymxpc2hQcm9taXNlICYmICFpc1JlcHVibGlzaCkge1xyXG4gICAgICAgICAgeWllbGQgX3RoaXMyLnJlcHVibGlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spICYmIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmhhcyh0cmFjaykpIHtcclxuICAgICAgICAgIHlpZWxkIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkZWZhdWx0Q29uc3RyYWludHM7XHJcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xyXG4gICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suZ2V0Q29uc3RyYWludHMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gd2Ugd2FudCB0byBhY2Nlc3MgY29uc3RyYWludHMgZGlyZWN0bHkgYXMgYHRyYWNrLm1lZGlhU3RyZWFtVHJhY2tgXHJcbiAgICAgICAgICAvLyBtaWdodCBiZSBwb2ludGluZyB0byBhIG5vbi1kZXZpY2UgdHJhY2sgKGUuZy4gcHJvY2Vzc2VkIHRyYWNrKSBhbHJlYWR5XHJcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5jb25zdHJhaW50cztcclxuICAgICAgICAgIGxldCBkZXZpY2VLaW5kID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgc3dpdGNoICh0cmFjay5zb3VyY2UpIHtcclxuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcclxuICAgICAgICAgICAgICBkZXZpY2VLaW5kID0gJ2F1ZGlvaW5wdXQnO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XHJcbiAgICAgICAgICAgICAgZGV2aWNlS2luZCA9ICd2aWRlb2lucHV0JztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChkZXZpY2VLaW5kICYmIF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuaGFzKGRldmljZUtpbmQpKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbnN0cmFpbnRzKSwge1xyXG4gICAgICAgICAgICAgIGRldmljZUlkOiBfdGhpczIuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29udmVydCByYXcgbWVkaWEgdHJhY2sgaW50byBhdWRpbyBvciB2aWRlbyB0cmFja1xyXG4gICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcclxuICAgICAgICAgIHN3aXRjaCAodHJhY2sua2luZCkge1xyXG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XHJcbiAgICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIF90aGlzMi5hdWRpb0NvbnRleHQsIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XHJcbiAgICAgICAgICAgICAgdHJhY2sgPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrLCBkZWZhdWx0Q29uc3RyYWludHMsIHRydWUsIHtcclxuICAgICAgICAgICAgICAgIGxvZ2dlck5hbWU6IF90aGlzMi5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIE1lZGlhU3RyZWFtVHJhY2sga2luZCBcIi5jb25jYXQodHJhY2sua2luZCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cmFjay51cGRhdGVMb2dnZXJPcHRpb25zKHtcclxuICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpcyBpdCBhbHJlYWR5IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxyXG4gICAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xyXG4gICAgICAgIF90aGlzMi50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcclxuICAgICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xyXG4gICAgICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gcHVibGljYXRpb247XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nUHVibGljYXRpb24pIHtcclxuICAgICAgICAgIF90aGlzMi5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbikpKTtcclxuICAgICAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc1N0ZXJlb0lucHV0ID0gJ2NoYW5uZWxDb3VudCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY2hhbm5lbENvdW50YCBvbiBnZXRTZXR0aW5ncygpIGlzIGN1cnJlbnRseSBvbmx5IGF2YWlsYWJsZSBmb3IgU2FmYXJpLCBidXQgaXMgZ2VuZXJhbGx5IHRoZSBiZXN0IHdheSB0byBkZXRlcm1pbmUgYSBzdGVyZW8gdHJhY2sgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tTZXR0aW5ncy9jaGFubmVsQ291bnRcclxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyIHx8IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKS5jaGFubmVsQ291bnQgPT09IDI7XHJcbiAgICAgICAgY29uc3QgaXNTdGVyZW8gPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2VTdGVyZW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGlzU3RlcmVvSW5wdXQ7XHJcbiAgICAgICAgLy8gZGlzYWJsZSBkdHggZm9yIHN0ZXJlbyB0cmFjayBpZiBub3QgZW5hYmxlZCBleHBsaWNpdGx5XHJcbiAgICAgICAgaWYgKGlzU3RlcmVvKSB7XHJcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZHR4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiT3B1cyBEVFggd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5yZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJPcHVzIFJFRCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIChfYyA9IG9wdGlvbnMuZHR4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBvcHRpb25zLmR0eCA9IGZhbHNlO1xyXG4gICAgICAgICAgKF9kID0gb3B0aW9ucy5yZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG9wdGlvbnMucmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5yb29tT3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAoIWlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCgpICYmIF90aGlzMi5yb29tT3B0aW9ucy5lMmVlKSB7XHJcbiAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJFbmQtdG8tZW5kIGVuY3J5cHRpb24gaXMgc2V0IHVwLCBzaW11bGNhc3QgcHVibGlzaGluZyB3aWxsIGJlIGRpc2FibGVkIG9uIFNhZmFyaSB2ZXJzaW9ucyBhbmQgaU9TIGJyb3dzZXJzIHJ1bm5pbmcgaU9TIDwgdjE3LjJcIiwgT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLmxvZ0NvbnRleHQpKTtcclxuICAgICAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnNvdXJjZSkge1xyXG4gICAgICAgICAgdHJhY2suc291cmNlID0gb3B0cy5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzMiwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdkZWZlcnJpbmcgdHJhY2sgcHVibGljYXRpb24gdW50aWwgc2lnbmFsIGlzIGNvbm5lY3RlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgICAgdHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIG5vdCBjb25uZWN0ZWQgd2l0aGluIHRpbWVvdXQnLCA0MDgpKTtcclxuICAgICAgICAgICAgICB9LCAxNTAwMCk7XHJcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy53YWl0VW50aWxFbmdpbmVDb25uZWN0ZWQoKTtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcclxuICAgICAgICAgICAgICByZXNvbHZlKHB1YmxpY2F0aW9uKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5zZXQodHJhY2ssIHB1Ymxpc2hQcm9taXNlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcclxuICAgICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5kZWxldGUodHJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHdhaXRVbnRpbEVuZ2luZUNvbm5lY3RlZCgpIHtcclxuICAgIGlmICghdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpIHtcclxuICAgICAgdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUucHJvbWlzZTtcclxuICB9XHJcbiAgaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2godHJhY2spIHtcclxuICAgIGlmICghdGhpcy5wZXJtaXNzaW9ucykge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdubyBwZXJtaXNzaW9ucyBwcmVzZW50IGZvciBwdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGNhblB1Ymxpc2gsXHJcbiAgICAgIGNhblB1Ymxpc2hTb3VyY2VzXHJcbiAgICB9ID0gdGhpcy5wZXJtaXNzaW9ucztcclxuICAgIGlmIChjYW5QdWJsaXNoICYmIChjYW5QdWJsaXNoU291cmNlcy5sZW5ndGggPT09IDAgfHwgY2FuUHVibGlzaFNvdXJjZXMubWFwKHNvdXJjZSA9PiBnZXRUcmFja1NvdXJjZUZyb21Qcm90byhzb3VyY2UpKS5pbmNsdWRlcyh0cmFjay5zb3VyY2UpKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRoaXMubG9nLndhcm4oJ2luc3VmZmljaWVudCBwZXJtaXNzaW9ucyB0byBwdWJsaXNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBwdWJsaXNoKHRyYWNrLCBvcHRzLCBpc1N0ZXJlbykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xyXG4gICAgICBpZiAoIXRoaXMuaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2godHJhY2spKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFB1Ymxpc2hUcmFja0Vycm9yKCdmYWlsZWQgdG8gcHVibGlzaCB0cmFjaywgaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zJywgNDAzKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBleGlzdGluZ1RyYWNrT2ZTb3VyY2UgPSBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbmQocHVibGlzaGVkVHJhY2sgPT4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHRyYWNrLnNvdXJjZSk7XHJcbiAgICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xyXG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJwdWJsaXNoaW5nIGEgc2Vjb25kIHRyYWNrIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIGlzRmlyZUZveCgpKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBzaW11bGNhc3RlZCBzY3JlZW4gc2hhcmVcclxuICAgICAgICAvLyB3ZSBmcmVxdWVudGx5IGdldCBubyBkYXRhIG9uIGxheWVyIDAgd2hlbiBlbmFibGVkXHJcbiAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZXF1aXJlIGZ1bGwgQVYxL1ZQOSBTVkMgc3VwcG9ydCBwcmlvciB0byB1c2luZyBpdFxyXG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAnYXYxJyAmJiAhc3VwcG9ydHNBVjEoKSkge1xyXG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSAndnA5JyAmJiAhc3VwcG9ydHNWUDkoKSkge1xyXG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0cy52aWRlb0NvZGVjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSBkZWZhdWx0VmlkZW9Db2RlYztcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBmYWxsYmFjayB0byBhIHN1cHBvcnRlZCBjb2RlYyBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3Muc29tZShjID0+IG9wdHMudmlkZW9Db2RlYyA9PT0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcoYy5taW1lKSkpIHtcclxuICAgICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjc1swXS5taW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmlkZW9Db2RlYyA9IG9wdHMudmlkZW9Db2RlYztcclxuICAgICAgLy8gaGFuZGxlIHRyYWNrIGFjdGlvbnNcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlLCB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlKTtcclxuICAgICAgY29uc3QgYXVkaW9GZWF0dXJlcyA9IFtdO1xyXG4gICAgICBjb25zdCBkaXNhYmxlRHR4ID0gISgoX2EgPSBvcHRzLmR0eCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdHJhY2suZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpO1xyXG4gICAgICBpZiAoc2V0dGluZ3MuYXV0b0dhaW5Db250cm9sKSB7XHJcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0FVVE9fR0FJTl9DT05UUk9MKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGluZ3MuZWNob0NhbmNlbGxhdGlvbikge1xyXG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9FQ0hPX0NBTkNFTExBVElPTik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNldHRpbmdzLm5vaXNlU3VwcHJlc3Npb24pIHtcclxuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9JU0VfU1VQUFJFU1NJT04pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXR0aW5ncy5jaGFubmVsQ291bnQgJiYgc2V0dGluZ3MuY2hhbm5lbENvdW50ID4gMSkge1xyXG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9TVEVSRU8pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkaXNhYmxlRHR4KSB7XHJcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PX0RUWCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSAmJiB0cmFjay5oYXNQcmVDb25uZWN0QnVmZmVyKSB7XHJcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1BSRUNPTk5FQ1RfQlVGRkVSKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBjcmVhdGUgdHJhY2sgcHVibGljYXRpb24gZnJvbSB0cmFja1xyXG4gICAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcclxuICAgICAgICAvLyBnZXQgbG9jYWwgdHJhY2sgaWQgZm9yIHVzZSBkdXJpbmcgcHVibGlzaGluZ1xyXG4gICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcclxuICAgICAgICBuYW1lOiBvcHRzLm5hbWUsXHJcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXHJcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXHJcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXHJcbiAgICAgICAgZGlzYWJsZUR0eCxcclxuICAgICAgICBlbmNyeXB0aW9uOiB0aGlzLmVuY3J5cHRpb25UeXBlLFxyXG4gICAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXHJcbiAgICAgICAgZGlzYWJsZVJlZDogdGhpcy5pc0UyRUVFbmFibGVkIHx8ICEoKF9iID0gb3B0cy5yZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpLFxyXG4gICAgICAgIHN0cmVhbTogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnN0cmVhbSxcclxuICAgICAgICBiYWNrdXBDb2RlY1BvbGljeTogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmJhY2t1cENvZGVjUG9saWN5LFxyXG4gICAgICAgIGF1ZGlvRmVhdHVyZXNcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGNvbXB1dGUgZW5jb2RpbmdzIGFuZCBsYXllcnMgZm9yIHZpZGVvXHJcbiAgICAgIGxldCBlbmNvZGluZ3M7XHJcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgICAgbGV0IGRpbXMgPSB7XHJcbiAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRpbXMgPSB5aWVsZCB0cmFjay53YWl0Rm9yRGltZW5zaW9ucygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcclxuICAgICAgICAgIC8vIHNvIHVzaW5nIGRlZmF1bHQgZGltcyBhY2NvcmRpbmcgdG8gcHVibGlzaCBzZXR0aW5nc1xyXG4gICAgICAgICAgY29uc3QgZGVmYXVsdFJlcyA9IChfZCA9IChfYyA9IHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXNvbHV0aW9uKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBWaWRlb1ByZXNldHMuaDcyMC5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgZGltcyA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IGRlZmF1bHRSZXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogZGVmYXVsdFJlcy5oZWlnaHRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICAvLyBsb2cgZmFpbHVyZVxyXG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgdHJhY2sgZGltZW5zaW9ucywgdXNpbmcgZGVmYXVsdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpLCB7XHJcbiAgICAgICAgICAgIGRpbXNcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBzaG91bGQgYmUgZGVmaW5lZCBmb3IgdmlkZW9cclxuICAgICAgICByZXEud2lkdGggPSBkaW1zLndpZHRoO1xyXG4gICAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcclxuICAgICAgICAvLyBmb3Igc3ZjIGNvZGVjcywgZGlzYWJsZSBzaW11bGNhc3QgYW5kIHVzZSB2cDggZm9yIGJhY2t1cCBjb2RlY1xyXG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgIGlmIChpc1NWQ0NvZGVjKHZpZGVvQ29kZWMpKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xyXG4gICAgICAgICAgICAgIC8vIHZwOSBzdmMgd2l0aCBzY3JlZW5zaGFyZSBjYW5ub3QgZW5jb2RlIG11bHRpcGxlIHNwYXRpYWwgbGF5ZXJzXHJcbiAgICAgICAgICAgICAgLy8gZG9pbmcgc28gcmVkdWNlcyBwdWJsaXNoIHJlc29sdXRpb24gdG8gbWluaW1hbCByZXNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAnTDFUMyc7XHJcbiAgICAgICAgICAgICAgLy8gQ2hyb21lIGRvZXMgbm90IGFsbG93IG1vcmUgdGhhbiA1IGZwcyB3aXRoIEwxVDMsIGFuZCBpdCBoYXMgZW5jb2RpbmcgYnVncyB3aXRoIEwzVDNcclxuICAgICAgICAgICAgICAvLyBJdCBoYXMgYSBkaWZmZXJlbnQgcGF0aCBmb3Igc2NyZWVuc2hhcmUgaGFuZGxpbmcgYW5kIGl0IHNlZW1zIHRvIGJlIHVudGVzdGVkL2J1Z2d5XHJcbiAgICAgICAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kLCB3ZSBhcmUgc2V0dGluZyBjb250ZW50SGludCB0byBmb3JjZSBpdCB0byBnbyB0aHJvdWdoIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgLy8gcGF0aCBhcyByZWd1bGFyIGNhbWVyYSB2aWRlby4gV2hpbGUgdGhpcyBpcyBub3Qgb3B0aW1hbCwgaXQgZGVsaXZlcnMgdGhlIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICAgICAgLy8gdGhhdCB3ZSBuZWVkXHJcbiAgICAgICAgICAgICAgaWYgKCdjb250ZW50SGludCcgaW4gdHJhY2subWVkaWFTdHJlYW1UcmFjaykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9ICdtb3Rpb24nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnZm9yY2luZyBjb250ZW50SGludCB0byBtb3Rpb24gZm9yIHNjcmVlbnNoYXJlIHdpdGggU1ZDIGNvZGVjcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IHNjYWxhYmlsaXR5TW9kZSB0byAnTDNUM19LRVknIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgb3B0cy5zY2FsYWJpbGl0eU1vZGUgPSAoX2UgPSBvcHRzLnNjYWxhYmlsaXR5TW9kZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ0wzVDNfS0VZJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlcS5zaW11bGNhc3RDb2RlY3MgPSBbbmV3IFNpbXVsY2FzdENvZGVjKHtcclxuICAgICAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXHJcbiAgICAgICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxyXG4gICAgICAgICAgfSldO1xyXG4gICAgICAgICAgLy8gc2V0IHVwIGJhY2t1cFxyXG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgb3B0cy5iYWNrdXBDb2RlYyA9IHtcclxuICAgICAgICAgICAgICBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChvcHRzLmJhY2t1cENvZGVjICYmIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcclxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xyXG4gICAgICAgICAgcmVxLmVuY3J5cHRpb24gPT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XHJcbiAgICAgICAgICAgIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCByZXF1aXJlcyBkeW5hY2FzdFxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcclxuICAgICAgICAgICAgICB0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2gobmV3IFNpbXVsY2FzdENvZGVjKHtcclxuICAgICAgICAgICAgICBjb2RlYzogb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyxcclxuICAgICAgICAgICAgICBjaWQ6ICcnXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xyXG4gICAgICAgIHJlcS5sYXllcnMgPSB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3MocmVxLndpZHRoLCByZXEuaGVpZ2h0LCBlbmNvZGluZ3MsIGlzU1ZDQ29kZWMob3B0cy52aWRlb0NvZGVjKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xyXG4gICAgICAgIGVuY29kaW5ncyA9IFt7XHJcbiAgICAgICAgICBtYXhCaXRyYXRlOiAoX2YgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWF4Qml0cmF0ZSxcclxuICAgICAgICAgIHByaW9yaXR5OiAoX2ggPSAoX2cgPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucHJpb3JpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICdoaWdoJyxcclxuICAgICAgICAgIG5ldHdvcmtQcmlvcml0eTogKF9rID0gKF9qID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnByaW9yaXR5KSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAnaGlnaCdcclxuICAgICAgICB9XTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG5lZ290aWF0ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAoIXRoaXMuZW5naW5lLnBjTWFuYWdlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3BjTWFuYWdlciBpcyBub3QgcmVhZHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2suc2VuZGVyID0geWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2VuZGVyKHRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xyXG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgIChfYSA9IG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcHRzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA9IGdldERlZmF1bHREZWdyYWRhdGlvblByZWZlcmVuY2UodHJhY2spO1xyXG4gICAgICAgICAgdHJhY2suc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xyXG4gICAgICAgICAgaWYgKGlzRmlyZUZveCgpICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcclxuICAgICAgICAgICAgLyogUmVmZXIgdG8gUkZDIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU4NyNzZWN0aW9uLTYuMSxcclxuICAgICAgICAgICAgICAgbGl2ZWtpdC1zZXJ2ZXIgdXNlcyBtYXhhdmVyYWdlYml0cmF0ZT01MTAwMDAgaW4gdGhlIGFuc3dlciBzZHAgdG8gcGVybWl0IGNsaWVudCB0b1xyXG4gICAgICAgICAgICAgICBwdWJsaXNoIGhpZ2ggcXVhbGl0eSBhdWRpbyB0cmFjay4gQnV0IGZpcmVmb3ggYWx3YXlzIHVzZXMgdGhpcyB2YWx1ZSBhcyB0aGUgYWN0dWFsXHJcbiAgICAgICAgICAgICAgIGJpdHJhdGVzLCBjYXVzaW5nIHRoZSBhdWRpbyBiaXRyYXRlcyB0byByaXNlIHRvIDUxMEticHMgaW4gYW55IHN0ZXJlbyBjYXNlIHVuZXhwZWN0ZWRseS5cclxuICAgICAgICAgICAgICAgU28gdGhlIGNsaWVudCBuZWVkIHRvIG1vZGlmeSBtYXhhdmVycmFnZWJpdHJhdGVzIGluIGFuc3dlciBzZHAgdG8gdXNlciBwcm92aWRlZCB2YWx1ZSB0b1xyXG4gICAgICAgICAgICAgICBmaXggdGhlIGlzc3VlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbGV0IHRyYWNrVHJhbnNjZWl2ZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xyXG4gICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrLnNlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tUcmFuc2NlaXZlciA9IHRyYW5zY2VpdmVyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmFja1RyYW5zY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlcjogdHJhY2tUcmFuc2NlaXZlcixcclxuICAgICAgICAgICAgICAgIGNvZGVjOiAnb3B1cycsXHJcbiAgICAgICAgICAgICAgICBtYXhicjogKChfYiA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heEJpdHJhdGUpID8gZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwIDogMFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmICgoX2MgPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhCaXRyYXRlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcclxuICAgICAgICAgICAgICBjaWQ6IHJlcS5jaWQsXHJcbiAgICAgICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxyXG4gICAgICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgbGV0IHRpO1xyXG4gICAgICBjb25zdCBhZGRUcmFja1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aSA9IHlpZWxkIHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XHJcbiAgICAgICAgICByZXNvbHZlKHRpKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGlmICh0cmFjay5zZW5kZXIgJiYgKChfYSA9IHRoaXMuZW5naW5lLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1Ymxpc2hlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5yZW1vdmVUcmFjayh0cmFjay5zZW5kZXIpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKS5jYXRjaChuZWdvdGlhdGVFcnIgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdmYWlsZWQgdG8gbmVnb3RpYXRlIGFmdGVyIHJlbW92aW5nIHRyYWNrIGR1ZSB0byBmYWlsZWQgYWRkIHRyYWNrIHJlcXVlc3QnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpLCB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogbmVnb3RpYXRlRXJyXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCByZXRzID0geWllbGQgUHJvbWlzZS5hbGwoW2FkZFRyYWNrUHJvbWlzZSwgbmVnb3RpYXRlKCldKTtcclxuICAgICAgICB0aSA9IHJldHNbMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGkgPSB5aWVsZCBhZGRUcmFja1Byb21pc2U7XHJcbiAgICAgICAgLy8gc2VydmVyIG1pZ2h0IG5vdCBzdXBwb3J0IHRoZSBjb2RlYyB0aGUgY2xpZW50IGhhcyByZXF1ZXN0ZWQsIGluIHRoYXQgY2FzZSwgZmFsbGJhY2tcclxuICAgICAgICAvLyB0byBhIHN1cHBvcnRlZCBjb2RlY1xyXG4gICAgICAgIGxldCBwcmltYXJ5Q29kZWNNaW1lO1xyXG4gICAgICAgIHRpLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcclxuICAgICAgICAgIGlmIChwcmltYXJ5Q29kZWNNaW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJpbWFyeUNvZGVjTWltZSA9IGNvZGVjLm1pbWVUeXBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmltYXJ5Q29kZWNNaW1lICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcclxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xyXG4gICAgICAgICAgaWYgKHVwZGF0ZWRDb2RlYyAhPT0gdmlkZW9Db2RlYykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZmFsbGluZyBiYWNrIHRvIHNlcnZlciBzZWxlY3RlZCBjb2RlYycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcclxuICAgICAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdXBkYXRlZENvZGVjO1xyXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgZW5jb2RpbmdzIHNpbmNlIGJpdHJhdGVzL2V0YyBjb3VsZCBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCBuZWdvdGlhdGUoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2sua2luZCwgdGksIHRyYWNrLCB7XHJcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyBzYXZlIG9wdGlvbnMgZm9yIHdoZW4gaXQgbmVlZHMgdG8gYmUgcmVwdWJsaXNoZWQgYWdhaW5cclxuICAgICAgcHVibGljYXRpb24ub3B0aW9ucyA9IG9wdHM7XHJcbiAgICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoaW5nIFwiLmNvbmNhdCh0cmFjay5raW5kLCBcIiB3aXRoIGVuY29kaW5nc1wiKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgZW5jb2RpbmdzLFxyXG4gICAgICAgIHRyYWNrSW5mbzogdGlcclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKHRoaXMuZW5naW5lLmNsaWVudCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcclxuICAgICAgLy8gc2VuZCBldmVudCBmb3IgcHVibGljYXRpb25cclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xyXG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spICYmIHRpLmF1ZGlvRmVhdHVyZXMuaW5jbHVkZXMoQXVkaW9UcmFja0ZlYXR1cmUuVEZfUFJFQ09OTkVDVF9CVUZGRVIpKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gdHJhY2suZ2V0UHJlQ29ubmVjdEJ1ZmZlcigpO1xyXG4gICAgICAgIC8vIFRPRE86IHdlJ3JlIHJlZ2lzdGVyaW5nIHRoZSBsaXN0ZW5lciBhZnRlciBuZWdvdGlhdGlvbiwgc28gdGhlcmUgbWlnaHQgYmUgYSByYWNlXHJcbiAgICAgICAgdGhpcy5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCBwdWIgPT4ge1xyXG4gICAgICAgICAgaWYgKHB1Yi50cmFja1NpZCA9PT0gdGkuc2lkKSB7XHJcbiAgICAgICAgICAgIGlmICghdHJhY2suaGFzUHJlQ29ubmVjdEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3N1YnNjcmliZSBldmVudCBjYW1lIHRvIGxhdGUsIGJ1ZmZlciBhbHJlYWR5IGNsb3NlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdmaW5pc2hlZCByZWNvcmRpbmcgcHJlY29ubmVjdCBidWZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICAgIHRyYWNrLnN0b3BQcmVDb25uZWN0QnVmZmVyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHN0cmVhbSkge1xyXG4gICAgICAgICAgY29uc3QgYnVmZmVyU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcclxuICAgICAgICAgICAgdmFyIF9kLCBfZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnd2FpdGluZyBmb3IgYWdlbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgYWdlbnRBY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdhZ2VudCBub3QgYWN0aXZlIHdpdGhpbiAxMCBzZWNvbmRzJykpO1xyXG4gICAgICAgICAgICAgIH0sIDEwMDAwKTtcclxuICAgICAgICAgICAgICBjb25zdCBhZ2VudCA9IHlpZWxkIHRoaXMud2FpdFVudGlsQWN0aXZlQWdlbnRQcmVzZW50KCk7XHJcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFnZW50QWN0aXZlVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgcHJlY29ubmVjdCBidWZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5zdHJlYW1CeXRlcyh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAncHJlY29ubmVjdC1idWZmZXInLFxyXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6ICdhdWRpby9vcHVzJyxcclxuICAgICAgICAgICAgICAgIHRvcGljOiAnbGsuYWdlbnQucHJlLWNvbm5lY3QtYXVkaW8tYnVmZmVyJyxcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2FnZW50LmlkZW50aXR5XSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcclxuICAgICAgICAgICAgICAgICAgdHJhY2tJZDogcHVibGljYXRpb24udHJhY2tTaWQsXHJcbiAgICAgICAgICAgICAgICAgIHNhbXBsZVJhdGU6IFN0cmluZygoX2QgPSBzZXR0aW5ncy5zYW1wbGVSYXRlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnNDgwMDAnKSxcclxuICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IFN0cmluZygoX2UgPSBzZXR0aW5ncy5jaGFubmVsQ291bnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICcxJylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1fMSA9IF9fYXN5bmNWYWx1ZXMoc3RyZWFtKSwgc3RyZWFtXzFfMTsgc3RyZWFtXzFfMSA9IHlpZWxkIHN0cmVhbV8xLm5leHQoKSwgX2EgPSBzdHJlYW1fMV8xLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgIF9jID0gc3RyZWFtXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcclxuICAgICAgICAgICAgICAgICAgeWllbGQgd3JpdGVyLndyaXRlKGNodW5rKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGNhdGNoIChlXzJfMSkge1xyXG4gICAgICAgICAgICAgICAgZV8yID0ge1xyXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZV8yXzFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IHN0cmVhbV8xLnJldHVybikpIHlpZWxkIF9iLmNhbGwoc3RyZWFtXzEpO1xyXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIGJ1ZmZlclN0cmVhbVByb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwcmVjb25uZWN0IGJ1ZmZlciBzZW50IHN1Y2Nlc3NmdWxseScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igc2VuZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcclxuICAgICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldCBpc0xvY2FsKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWxcclxuICAgKiBwdWJsaXNoIGFkZGl0aW9uYWwgY29kZWMgdG8gZXhpc3RpbmcgdHJhY2tcclxuICAgKi9cclxuICBwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2sodHJhY2ssIHZpZGVvQ29kZWMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgLy8gVE9ETyByZW1vdmUgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIHRyYWNrc1xyXG4gICAgICBpZiAodGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gaXMgaXQgbm90IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxyXG4gICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcclxuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcclxuICAgICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcclxuICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBwdWJsaXNoZWQnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IGEgdmlkZW8gdHJhY2snKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyk7XHJcbiAgICAgIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cyk7XHJcbiAgICAgIGlmICghZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcImJhY2t1cCBjb2RlYyBoYXMgYmVlbiBkaXNhYmxlZCwgaWdub3JpbmcgcmVxdWVzdCB0byBhZGQgYWRkaXRpb25hbCBjb2RlYyBmb3IgdHJhY2tcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzaW11bGNhc3RUcmFjayA9IHRyYWNrLmFkZFNpbXVsY2FzdFRyYWNrKHZpZGVvQ29kZWMsIGVuY29kaW5ncyk7XHJcbiAgICAgIGlmICghc2ltdWxjYXN0VHJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XHJcbiAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxyXG4gICAgICAgIHR5cGU6IFRyYWNrLmtpbmRUb1Byb3RvKHRyYWNrLmtpbmQpLFxyXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxyXG4gICAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxyXG4gICAgICAgIHNpZDogdHJhY2suc2lkLFxyXG4gICAgICAgIHNpbXVsY2FzdENvZGVjczogW3tcclxuICAgICAgICAgIGNvZGVjOiBvcHRzLnZpZGVvQ29kZWMsXHJcbiAgICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWRcclxuICAgICAgICB9XVxyXG4gICAgICB9KTtcclxuICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncyk7XHJcbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmVnb3RpYXRlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNyZWF0ZVNpbXVsY2FzdFNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXRzID0geWllbGQgUHJvbWlzZS5hbGwoW3RoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSksIG5lZ290aWF0ZSgpXSk7XHJcbiAgICAgIGNvbnN0IHRpID0gcmV0c1swXTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoZWQgXCIuY29uY2F0KHZpZGVvQ29kZWMsIFwiIGZvciB0cmFjayBcIikuY29uY2F0KHRyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGVuY29kaW5ncyxcclxuICAgICAgICB0cmFja0luZm86IHRpXHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB1bnB1Ymxpc2hUcmFjayh0cmFjaywgc3RvcE9uVW5wdWJsaXNoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlID0gdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmdldCh0cmFjayk7XHJcbiAgICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdhd2FpdGluZyBwdWJsaXNoIHByb21pc2UgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdW5wdWJsaXNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgeWllbGQgcHVibGlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIGxvb2sgdGhyb3VnaCBhbGwgcHVibGlzaGVkIHRyYWNrcyB0byBmaW5kIHRoZSByaWdodCBvbmVzXHJcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKTtcclxuICAgICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcclxuICAgICAgaWYgKCFwdWJsaWNhdGlvbiB8fCAhcHVibGljYXRpb24udHJhY2spIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICB0cmFjayA9IHB1YmxpY2F0aW9uLnRyYWNrO1xyXG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5vblRyYWNrTXV0ZWQpO1xyXG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcclxuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XHJcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCk7XHJcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkKTtcclxuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xyXG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzdG9wT25VbnB1Ymxpc2ggPSAoX2IgPSAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RvcE9uVW5wdWJsaXNoKSB7XHJcbiAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRyYWNrLnN0b3BNb25pdG9yKCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG5lZ290aWF0aW9uTmVlZGVkID0gZmFsc2U7XHJcbiAgICAgIGNvbnN0IHRyYWNrU2VuZGVyID0gdHJhY2suc2VuZGVyO1xyXG4gICAgICB0cmFjay5zZW5kZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmICh0aGlzLmVuZ2luZS5wY01hbmFnZXIgJiYgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSA8IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEICYmIHRyYWNrU2VuZGVyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xyXG4gICAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXHJcbiAgICAgICAgICAgIC8vIHJlbW92ZVRyYWNrIHdvdWxkIGhhdmUgbm8gZWZmZWN0LlxyXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgd2UgZW5kIHVwIHN1Y2Nlc3NmdWxseSByZW1vdmluZyB0aGUgdHJhY2ssIG1hbnVhbGx5IHNldFxyXG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcclxuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2tTZW5kZXIpIHtcclxuICAgICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xyXG4gICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xyXG4gICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgdHJhY2tJbmZvXSBvZiB0cmFjay5zaW11bGNhc3RDb2RlY3MpIHtcclxuICAgICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrSW5mby5zZW5kZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyYWNrSW5mby5zZW5kZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrLnNpbXVsY2FzdENvZGVjcy5jbGVhcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byB1bnB1Ymxpc2ggdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcclxuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xyXG4gICAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcclxuICAgICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XHJcbiAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcclxuICAgICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XHJcbiAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XHJcbiAgICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcclxuICAgIH0pO1xyXG4gIH1cclxuICB1bnB1Ymxpc2hUcmFja3ModHJhY2tzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0cmFjayA9PiB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIodHJhY2sgPT4gISF0cmFjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVwdWJsaXNoQWxsVHJhY2tzKG9wdGlvbnNfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgIGxldCByZXN0YXJ0VHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAoX3RoaXMzLnJlcHVibGlzaFByb21pc2UpIHtcclxuICAgICAgICAgIHlpZWxkIF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpczMucmVwdWJsaXNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYWxQdWJzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChwdWIudHJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgIHB1Yi5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWIub3B0aW9ucyksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9jYWxQdWJzLnB1c2gocHViKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsb2NhbFB1YnMubWFwKHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBwdWIudHJhY2s7XHJcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgIGlmIChyZXN0YXJ0VHJhY2tzICYmICF0cmFjay5pc011dGVkICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8gJiYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpICYmICF0cmFjay5pc1VzZXJQcm92aWRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhbGx5IHdlIG5lZWQgdG8gcmVzdGFydCB0aGUgdHJhY2sgYmVmb3JlIHB1Ymxpc2hpbmcsIG9mdGVuIGEgZnVsbCByZWNvbm5lY3RcclxuICAgICAgICAgICAgICAgIC8vIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbXB1dGVyIGhhZCBnb25lIHRvIHNsZWVwLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgICAgICAgdHJhY2s6IHB1Yi50cmFja1NpZFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zLCB0cnVlKTtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwdWJsaXNoUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgeWllbGQgX3RoaXMzLnJlcHVibGlzaFByb21pc2U7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQdWJsaXNoIGEgbmV3IGRhdGEgcGF5bG9hZCB0byB0aGUgcm9vbS4gRGF0YSB3aWxsIGJlIGZvcndhcmRlZCB0byBlYWNoXHJcbiAgICogcGFydGljaXBhbnQgaW4gdGhlIHJvb20gaWYgdGhlIGRlc3RpbmF0aW9uIGZpZWxkIGluIHB1Ymxpc2hPcHRpb25zIGlzIGVtcHR5XHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSBVaW50OEFycmF5IG9mIHRoZSBwYXlsb2FkLiBUbyBzZW5kIHN0cmluZyBkYXRhLCB1c2UgVGV4dEVuY29kZXIuZW5jb2RlXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uYWxseSBzcGVjaWZ5IGEgYHJlbGlhYmxlYCwgYHRvcGljYCBhbmQgYGRlc3RpbmF0aW9uYFxyXG4gICAqL1xyXG4gIHB1Ymxpc2hEYXRhKGRhdGFfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XHJcbiAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qga2luZCA9IG9wdGlvbnMucmVsaWFibGUgPyBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUgOiBEYXRhUGFja2V0X0tpbmQuTE9TU1k7XHJcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XHJcbiAgICAgICAgY29uc3QgdG9waWMgPSBvcHRpb25zLnRvcGljO1xyXG4gICAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICAgIGtpbmQ6IGtpbmQsXHJcbiAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICBjYXNlOiAndXNlcicsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgVXNlclBhY2tldCh7XHJcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogX3RoaXM0LmlkZW50aXR5LFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXHJcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgICAgICAgIHRvcGljXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgeWllbGQgX3RoaXM0LmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUHVibGlzaCBTSVAgRFRNRiBtZXNzYWdlIHRvIHRoZSByb29tLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvZGUgRFRNRiBjb2RlXHJcbiAgICogQHBhcmFtIGRpZ2l0IERUTUYgZGlnaXRcclxuICAgKi9cclxuICBwdWJsaXNoRHRtZihjb2RlLCBkaWdpdCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ3NpcER0bWYnLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBTaXBEVE1GKHtcclxuICAgICAgICAgICAgY29kZTogY29kZSxcclxuICAgICAgICAgICAgZGlnaXQ6IGRpZ2l0XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kQ2hhdE1lc3NhZ2UodGV4dCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgbXNnID0ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIG1lc3NhZ2U6IHRleHQsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIGF0dGFjaGVkRmlsZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2htZW50c1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIGNhc2U6ICdjaGF0TWVzc2FnZScsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IENoYXRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwge1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLnRpbWVzdGFtcClcclxuICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XHJcbiAgICAgIHJldHVybiBtc2c7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWRpdENoYXRNZXNzYWdlKGVkaXRUZXh0LCBvcmlnaW5hbE1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IG1zZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxNZXNzYWdlKSwge1xyXG4gICAgICAgIG1lc3NhZ2U6IGVkaXRUZXh0LFxyXG4gICAgICAgIGVkaXRUaW1lc3RhbXA6IERhdGUubm93KClcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtc2cpLCB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKSxcclxuICAgICAgICAgICAgZWRpdFRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cuZWRpdFRpbWVzdGFtcClcclxuICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XHJcbiAgICAgIHJldHVybiBtc2c7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFRleHQodGV4dCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCBzdHJlYW1JZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgIGNvbnN0IHRleHRJbkJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xyXG4gICAgICBjb25zdCB0b3RhbFRleHRMZW5ndGggPSB0ZXh0SW5CeXRlcy5ieXRlTGVuZ3RoO1xyXG4gICAgICBjb25zdCBmaWxlSWRzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKCgpID0+IGNyeXB0by5yYW5kb21VVUlEKCkpO1xyXG4gICAgICBjb25zdCBwcm9ncmVzc2VzID0gbmV3IEFycmF5KGZpbGVJZHMgPyBmaWxlSWRzLmxlbmd0aCArIDEgOiAxKS5maWxsKDApO1xyXG4gICAgICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChwcm9ncmVzcywgaWR4KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHByb2dyZXNzZXNbaWR4XSA9IHByb2dyZXNzO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBwcm9ncmVzc2VzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XHJcbiAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHRvdGFsUHJvZ3Jlc3MpO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbVRleHQoe1xyXG4gICAgICAgIHN0cmVhbUlkLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogdG90YWxUZXh0TGVuZ3RoLFxyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICB0b3BpYzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljLFxyXG4gICAgICAgIGF0dGFjaGVkU3RyZWFtSWRzOiBmaWxlSWRzLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzXHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB3cml0ZXIud3JpdGUodGV4dCk7XHJcbiAgICAgIC8vIHNldCB0ZXh0IHBhcnQgb2YgcHJvZ3Jlc3MgdG8gMVxyXG4gICAgICBoYW5kbGVQcm9ncmVzcygxLCAwKTtcclxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XHJcbiAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzKSAmJiBmaWxlSWRzKSB7XHJcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwob3B0aW9ucy5hdHRhY2htZW50cy5tYXAoKGZpbGUsIGlkeCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRGaWxlKGZpbGVJZHNbaWR4XSwgZmlsZSwge1xyXG4gICAgICAgICAgICB0b3BpYzogb3B0aW9ucy50b3BpYyxcclxuICAgICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcclxuICAgICAgICAgICAgb25Qcm9ncmVzczogcHJvZ3Jlc3MgPT4ge1xyXG4gICAgICAgICAgICAgIGhhbmRsZVByb2dyZXNzKHByb2dyZXNzLCBpZHggKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gd3JpdGVyLmluZm87XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGV4cGVyaW1lbnRhbCBDQVVUSU9OLCBtaWdodCBnZXQgcmVtb3ZlZCBpbiBhIG1pbm9yIHJlbGVhc2VcclxuICAgKi9cclxuICBzdHJlYW1UZXh0KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGNvbnN0IHN0cmVhbUlkID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0cmVhbUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjcnlwdG8ucmFuZG9tVVVJRCgpO1xyXG4gICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgIGlkOiBzdHJlYW1JZCxcclxuICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICB0b3BpYzogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcclxuICAgICAgICBzaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhU3RyZWFtX0hlYWRlcih7XHJcbiAgICAgICAgc3RyZWFtSWQsXHJcbiAgICAgICAgbWltZVR5cGU6IGluZm8ubWltZVR5cGUsXHJcbiAgICAgICAgdG9waWM6IGluZm8udG9waWMsXHJcbiAgICAgICAgdGltZXN0YW1wOiBudW1iZXJUb0JpZ0ludChpbmZvLnRpbWVzdGFtcCksXHJcbiAgICAgICAgdG90YWxMZW5ndGg6IG51bWJlclRvQmlnSW50KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUpLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IGluZm8uYXR0cmlidXRlcyxcclxuICAgICAgICBjb250ZW50SGVhZGVyOiB7XHJcbiAgICAgICAgICBjYXNlOiAndGV4dEhlYWRlcicsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fVGV4dEhlYWRlcih7XHJcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZXJzaW9uLFxyXG4gICAgICAgICAgICBhdHRhY2hlZFN0cmVhbUlkczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaGVkU3RyZWFtSWRzLFxyXG4gICAgICAgICAgICByZXBseVRvU3RyZWFtSWQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBseVRvU3RyZWFtSWQsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgPT09ICd1cGRhdGUnID8gRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlLlVQREFURSA6IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5DUkVBVEVcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ3N0cmVhbUhlYWRlcicsXHJcbiAgICAgICAgICB2YWx1ZTogaGVhZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICBsZXQgY2h1bmtJZCA9IDA7XHJcbiAgICAgIGNvbnN0IGxvY2FsUCA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcclxuICAgICAgICAvLyBJbXBsZW1lbnQgdGhlIHNpbmtcclxuICAgICAgICB3cml0ZSh0ZXh0KSB7XHJcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRleHRCeXRlQ2h1bmsgb2Ygc3BsaXRVdGY4KHRleHQsIFNUUkVBTV9DSFVOS19TSVpFKSkge1xyXG4gICAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUud2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xyXG4gICAgICAgICAgICAgICAgY29udGVudDogdGV4dEJ5dGVDaHVuayxcclxuICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxyXG4gICAgICAgICAgICAgICAgY2h1bmtJbmRleDogbnVtYmVyVG9CaWdJbnQoY2h1bmtJZClcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVua1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUuc2VuZERhdGFQYWNrZXQoY2h1bmtQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgICAgICAgICAgY2h1bmtJZCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb3NlKCkge1xyXG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhaWxlciA9IG5ldyBEYXRhU3RyZWFtX1RyYWlsZXIoe1xyXG4gICAgICAgICAgICAgIHN0cmVhbUlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB5aWVsZCBsb2NhbFAuZW5naW5lLnNlbmREYXRhUGFja2V0KHRyYWlsZXJQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFib3J0KGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1NpbmsgZXJyb3I6JywgZXJyKTtcclxuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGFib3J0cyB0byBzaWduYWwgc29tZXRoaW5nIHRvIHJlY2VpdmVyIHNpZGVcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQgb25FbmdpbmVDbG9zZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGxvY2FsUC5lbmdpbmUub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkVuZ2luZUNsb3NlKTtcclxuICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFRleHRTdHJlYW1Xcml0ZXIod3JpdGFibGVTdHJlYW0sIGluZm8sICgpID0+IHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkVuZ2luZUNsb3NlKSk7XHJcbiAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZEZpbGUoZmlsZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xyXG4gICAgICB5aWVsZCB0aGlzLl9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHN0cmVhbUlkXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3NlbmRGaWxlKHN0cmVhbUlkLCBmaWxlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMuc3RyZWFtQnl0ZXMoe1xyXG4gICAgICAgIHN0cmVhbUlkLFxyXG4gICAgICAgIHRvdGFsU2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgIG5hbWU6IGZpbGUubmFtZSxcclxuICAgICAgICBtaW1lVHlwZTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlLnR5cGUsXHJcbiAgICAgICAgdG9waWM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYyxcclxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXNcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZpbGUuc3RyZWFtKCkuZ2V0UmVhZGVyKCk7XHJcbiAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgZG9uZSxcclxuICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfSA9IHlpZWxkIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xyXG4gICAgICByZXR1cm4gd3JpdGVyLmluZm87XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RyZWFtQnl0ZXMob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XHJcbiAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgaWQ6IHN0cmVhbUlkLFxyXG4gICAgICAgIG1pbWVUeXBlOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxyXG4gICAgICAgIHRvcGljOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlcyxcclxuICAgICAgICBzaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplLFxyXG4gICAgICAgIG5hbWU6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAndW5rbm93bidcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcclxuICAgICAgICB0b3RhbExlbmd0aDogbnVtYmVyVG9CaWdJbnQoKF9lID0gaW5mby5zaXplKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKSxcclxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcclxuICAgICAgICBzdHJlYW1JZCxcclxuICAgICAgICB0b3BpYzogaW5mby50b3BpYyxcclxuICAgICAgICB0aW1lc3RhbXA6IG51bWJlclRvQmlnSW50KERhdGUubm93KCkpLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IGluZm8uYXR0cmlidXRlcyxcclxuICAgICAgICBjb250ZW50SGVhZGVyOiB7XHJcbiAgICAgICAgICBjYXNlOiAnYnl0ZUhlYWRlcicsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQnl0ZUhlYWRlcih7XHJcbiAgICAgICAgICAgIG5hbWU6IGluZm8ubmFtZVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBjYXNlOiAnc3RyZWFtSGVhZGVyJyxcclxuICAgICAgICAgIHZhbHVlOiBoZWFkZXJcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgIGxldCBjaHVua0lkID0gMDtcclxuICAgICAgY29uc3Qgd3JpdGVNdXRleCA9IG5ldyBfKCk7XHJcbiAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuZW5naW5lO1xyXG4gICAgICBjb25zdCBsb2cgPSB0aGlzLmxvZztcclxuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xyXG4gICAgICAgIHdyaXRlKGNodW5rKSB7XHJcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB3cml0ZU11dGV4LmxvY2soKTtcclxuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHdoaWxlIChieXRlT2Zmc2V0IDwgY2h1bmsuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQ2h1bmsgPSBjaHVuay5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgU1RSRUFNX0NIVU5LX1NJWkUpO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgZW5naW5lLndhaXRGb3JCdWZmZXJTdGF0dXNMb3coRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbUNodW5rJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3ViQ2h1bmssXHJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1JZCxcclxuICAgICAgICAgICAgICAgICAgICAgIGNodW5rSW5kZXg6IG51bWJlclRvQmlnSW50KGNodW5rSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBlbmdpbmUuc2VuZERhdGFQYWNrZXQoY2h1bmtQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgICAgICAgICAgICBjaHVua0lkICs9IDE7XHJcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0ICs9IHN1YkNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgIHVubG9jaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb3NlKCkge1xyXG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhaWxlciA9IG5ldyBEYXRhU3RyZWFtX1RyYWlsZXIoe1xyXG4gICAgICAgICAgICAgIHN0cmVhbUlkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB5aWVsZCBlbmdpbmUuc2VuZERhdGFQYWNrZXQodHJhaWxlclBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWJvcnQoZXJyKSB7XHJcbiAgICAgICAgICBsb2cuZXJyb3IoJ1NpbmsgZXJyb3I6JywgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBieXRlV3JpdGVyID0gbmV3IEJ5dGVTdHJlYW1Xcml0ZXIod3JpdGFibGVTdHJlYW0sIGluZm8pO1xyXG4gICAgICByZXR1cm4gYnl0ZVdyaXRlcjtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBJbml0aWF0ZSBhbiBSUEMgY2FsbCB0byBhIHJlbW90ZSBwYXJ0aWNpcGFudFxyXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBpbml0aWF0aW5nIHRoZSBSUEMgY2FsbCwgc2VlIHtAbGluayBQZXJmb3JtUnBjUGFyYW1zfVxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHBheWxvYWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAqIEB0aHJvd3MgRXJyb3Igb24gZmFpbHVyZS4gRGV0YWlscyBpbiBgbWVzc2FnZWAuXHJcbiAgICovXHJcbiAgcGVyZm9ybVJwYyhfYSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKF9yZWYzKSB7XHJcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdHksXHJcbiAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIHBheWxvYWQsXHJcbiAgICAgICAgcmVzcG9uc2VUaW1lb3V0ID0gMTAwMDBcclxuICAgICAgfSA9IF9yZWYzO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBtYXhSb3VuZFRyaXBMYXRlbmN5ID0gMjAwMDtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzNSwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aChwYXlsb2FkKSA+IE1BWF9QQVlMT0FEX0JZVEVTKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFJykpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuZW5naW5lLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52ZXJzaW9uKSAmJiBjb21wYXJlVmVyc2lvbnMoKF9kID0gKF9jID0gdGhpcy5lbmdpbmUubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2VydmVySW5mbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnZlcnNpb24sICcxLjguMCcpIDwgMCkge1xyXG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfU0VSVkVSJykpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBpZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIGlkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCAtIG1heFJvdW5kVHJpcExhdGVuY3kpO1xyXG4gICAgICAgICAgY29uc3QgYWNrVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ0NPTk5FQ1RJT05fVElNRU9VVCcpKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICB9LCBtYXhSb3VuZFRyaXBMYXRlbmN5KTtcclxuICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3Muc2V0KGlkLCB7XHJcbiAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZGVzdGluYXRpb25JZGVudGl0eVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFU1BPTlNFX1RJTUVPVVQnKSk7XHJcbiAgICAgICAgICB9LCByZXNwb25zZVRpbWVvdXQpO1xyXG4gICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLnNldChpZCwge1xyXG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dElkKTtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQWNrcy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JQQyByZXNwb25zZSByZWNlaXZlZCBiZWZvcmUgYWNrJywgaWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QocmVzcG9uc2VFcnJvcik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2VQYXlsb2FkICE9PSBudWxsICYmIHJlc3BvbnNlUGF5bG9hZCAhPT0gdm9pZCAwID8gcmVzcG9uc2VQYXlsb2FkIDogJycpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogZGVzdGluYXRpb25JZGVudGl0eVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJScGNNZXRob2QobWV0aG9kLCBoYW5kbGVyKSB7XHJcbiAgICBpZiAodGhpcy5ycGNIYW5kbGVycy5oYXMobWV0aG9kKSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKFwieW91J3JlIG92ZXJyaWRpbmcgdGhlIFJQQyBoYW5kbGVyIGZvciBtZXRob2QgXCIuY29uY2F0KG1ldGhvZCwgXCIsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yXCIpKTtcclxuICAgIH1cclxuICAgIHRoaXMucnBjSGFuZGxlcnMuc2V0KG1ldGhvZCwgaGFuZGxlcik7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgcm9vbS51bnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXHJcbiAgICovXHJcbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcclxuICAgIHRoaXMucnBjSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENvbnRyb2wgd2hvIGNhbiBzdWJzY3JpYmUgdG8gTG9jYWxQYXJ0aWNpcGFudCdzIHB1Ymxpc2hlZCB0cmFja3MuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcclxuICAgKiB3aG8gaXMgYWJsZSB0byBzdWJzY3JpYmUgYXQgYSBwYXJ0aWNpcGFudCBhbmQgdHJhY2sgbGV2ZWwuXHJcbiAgICpcclxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcclxuICAgKiBbUGFydGljaXBhbnRUcmFja1Blcm1pc3Npb24uYWxsVHJhY2tzQWxsb3dlZF0gYXJlIGZhbHNlKSwgYW55IG5ld2VyIHB1Ymxpc2hlZCB0cmFja3NcclxuICAgKiB3aWxsIG5vdCBncmFudCBwZXJtaXNzaW9ucyB0byBhbnkgcGFydGljaXBhbnRzIGFuZCB3aWxsIHJlcXVpcmUgYSBzdWJzZXF1ZW50XHJcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIEFsbG93cyBhbGwgcGFydGljaXBhbnRzIHRvIHN1YnNjcmliZSBhbGwgdHJhY2tzLlxyXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cclxuICAgKiAgQnkgZGVmYXVsdCB0aGlzIGlzIHNldCB0byB0cnVlLlxyXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgRnVsbCBsaXN0IG9mIGluZGl2aWR1YWwgcGVybWlzc2lvbnMgcGVyXHJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXHJcbiAgICovXHJcbiAgc2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkKSB7XHJcbiAgICBsZXQgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcclxuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zO1xyXG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkO1xyXG4gICAgaWYgKCF0aGlzLmVuZ2luZS5jbGllbnQuaXNEaXNjb25uZWN0ZWQpIHtcclxuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZUluY29taW5nUnBjQWNrKHJlcXVlc3RJZCkge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ0Fja3MuZ2V0KHJlcXVlc3RJZCk7XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICBoYW5kbGVyLnJlc29sdmUoKTtcclxuICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUocmVxdWVzdElkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjayByZWNlaXZlZCBmb3IgdW5leHBlY3RlZCBSUEMgcmVxdWVzdCcsIHJlcXVlc3RJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZUluY29taW5nUnBjUmVzcG9uc2UocmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcikge1xyXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5nZXQocmVxdWVzdElkKTtcclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgIGhhbmRsZXIucmVzb2x2ZShwYXlsb2FkLCBlcnJvcik7XHJcbiAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUocmVxdWVzdElkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jlc3BvbnNlIHJlY2VpdmVkIGZvciB1bmV4cGVjdGVkIFJQQyByZXF1ZXN0JywgcmVxdWVzdElkKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgbWV0aG9kLCBwYXlsb2FkLCByZXNwb25zZVRpbWVvdXQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcclxuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIGNhc2U6ICdycGNSZXF1ZXN0JyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjUmVxdWVzdCh7XHJcbiAgICAgICAgICAgIGlkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lb3V0TXM6IHJlc3BvbnNlVGltZW91dCxcclxuICAgICAgICAgICAgdmVyc2lvbjogMVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgIGZvciAoY29uc3QgW2lkLCB7XHJcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlbmRpbmdJZGVudGl0eVxyXG4gICAgfV0gb2YgdGhpcy5wZW5kaW5nQWNrcykge1xyXG4gICAgICBpZiAocGVuZGluZ0lkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IFtpZCwge1xyXG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwZW5kaW5nSWRlbnRpdHksXHJcbiAgICAgIHJlc29sdmVcclxuICAgIH1dIG9mIHRoaXMucGVuZGluZ1Jlc3BvbnNlcykge1xyXG4gICAgICBpZiAocGVuZGluZ0lkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICAgICAgcmVzb2x2ZShudWxsLCBScGNFcnJvci5idWlsdEluKCdSRUNJUElFTlRfRElTQ09OTkVDVEVEJykpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRFbmFibGVkUHVibGlzaENvZGVjcyhjb2RlY3MpIHtcclxuICAgIHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcyA9IGNvZGVjcy5maWx0ZXIoYyA9PiBjLm1pbWUuc3BsaXQoJy8nKVswXS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHVwZGF0ZUluZm8oaW5mbykge1xyXG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBtdXRlIHN0YXR1cy5cclxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxyXG4gICAgLy8gdGhlIHNlcnZlcidzIGNvcHlcclxuICAgIGluZm8udHJhY2tzLmZvckVhY2godGkgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh0aS5zaWQpO1xyXG4gICAgICBpZiAocHViKSB7XHJcbiAgICAgICAgY29uc3QgbXV0ZWRPblNlcnZlciA9IHB1Yi5pc011dGVkIHx8ICgoX2IgPSAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XHJcbiAgICAgICAgaWYgKG11dGVkT25TZXJ2ZXIgIT09IHRpLm11dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgc2VydmVyIG11dGUgc3RhdGUgYWZ0ZXIgcmVjb25jaWxlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSksIHtcclxuICAgICAgICAgICAgbXV0ZWRPblNlcnZlclxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRNdXRlVHJhY2sodGkuc2lkLCBtdXRlZE9uU2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRBY3RpdmVBZ2VudChhZ2VudCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgdGhpcy5maXJzdEFjdGl2ZUFnZW50ID0gYWdlbnQ7XHJcbiAgICBpZiAoYWdlbnQgJiYgIXRoaXMuZmlyc3RBY3RpdmVBZ2VudCkge1xyXG4gICAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSBhZ2VudDtcclxuICAgIH1cclxuICAgIGlmIChhZ2VudCkge1xyXG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGFnZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIChfZCA9IChfYyA9IHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWplY3QpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCAnQWdlbnQgZGlzY29ubmVjdGVkJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICB3YWl0VW50aWxBY3RpdmVBZ2VudFByZXNlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5maXJzdEFjdGl2ZUFnZW50KSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5maXJzdEFjdGl2ZUFnZW50KTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkge1xyXG4gICAgICB0aGlzLmFjdGl2ZUFnZW50RnV0dXJlID0gbmV3IEZ1dHVyZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUucHJvbWlzZTtcclxuICB9XHJcbiAgZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjaykge1xyXG4gICAgbGV0IHB1YmxpY2F0aW9uO1xyXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XHJcbiAgICAgIGNvbnN0IGxvY2FsVHJhY2sgPSBwdWIudHJhY2s7XHJcbiAgICAgIGlmICghbG9jYWxUcmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyB0aGlzIGxvb2tzIG92ZXJseSBjb21wbGljYXRlZCBkdWUgdG8gdGhpcyBvYmplY3QgdHJlZVxyXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XHJcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKGxvY2FsVHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKGxvY2FsVHJhY2spKSB7XHJcbiAgICAgICAgICBpZiAobG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrID09PSB0cmFjaykge1xyXG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sgPT09IGxvY2FsVHJhY2spIHtcclxuICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcHVibGljYXRpb247XHJcbiAgfVxyXG4gIHdhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHdhaXRGb3JQZW5kaW5nVGltZW91dCA9IDEwMDAwO1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHN0YXJ0VGltZSArIHdhaXRGb3JQZW5kaW5nVGltZW91dCkge1xyXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlRW50cnkgPSBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5lbnRyaWVzKCkpLmZpbmQoX3JlZjQgPT4ge1xyXG4gICAgICAgICAgbGV0IFtwZW5kaW5nVHJhY2tdID0gX3JlZjQ7XHJcbiAgICAgICAgICByZXR1cm4gcGVuZGluZ1RyYWNrLnNvdXJjZSA9PT0gc291cmNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwdWJsaXNoUHJvbWlzZUVudHJ5KSB7XHJcbiAgICAgICAgICByZXR1cm4gcHVibGlzaFByb21pc2VFbnRyeVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgc2xlZXAoMjApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcclxuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgYXV0b1N1YnNjcmliZSwgbG9nZ2VyT3B0aW9ucykge1xyXG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XHJcbiAgICB0aGlzLmhhbmRsZUVuZGVkID0gdHJhY2sgPT4ge1xyXG4gICAgICB0aGlzLnNldFRyYWNrKHVuZGVmaW5lZCk7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0cmFjayk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gdmlzaWJsZSA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gdmlzaWJpbGl0eSBcIi5jb25jYXQodGhpcy50cmFja1NpZCwgXCIsIHZpc2libGU9XCIpLmNvbmNhdCh2aXNpYmxlKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5kaXNhYmxlZCA9ICF2aXNpYmxlO1xyXG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gZGltZW5zaW9ucyA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gZGltZW5zaW9ucyBcIi5jb25jYXQoZGltZW5zaW9ucy53aWR0aCwgXCJ4XCIpLmNvbmNhdChkaW1lbnNpb25zLmhlaWdodCksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcclxuICAgICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xyXG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHRvIHRoaXMgcmVtb3RlIHRyYWNrXHJcbiAgICogQHBhcmFtIHN1YnNjcmliZWQgdHJ1ZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgZmFsc2UgdG8gdW5zdWJzY3JpYmVcclxuICAgKi9cclxuICBzZXRTdWJzY3JpYmVkKHN1YnNjcmliZWQpIHtcclxuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcclxuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xyXG4gICAgdGhpcy5zdWJzY3JpYmVkID0gc3Vic2NyaWJlZDtcclxuICAgIC8vIHJlc2V0IGFsbG93ZWQgc3RhdHVzIHdoZW4gZGVzaXJlZCBzdWJzY3JpcHRpb24gc3RhdGUgY2hhbmdlc1xyXG4gICAgLy8gc2VydmVyIHdpbGwgbm90aWZ5IGNsaWVudCB2aWEgc2lnbmFsIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxsb3dlZFxyXG4gICAgaWYgKHN1YnNjcmliZWQpIHtcclxuICAgICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN1YiA9IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xyXG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcclxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXHJcbiAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbbmV3IFBhcnRpY2lwYW50VHJhY2tzKHtcclxuICAgICAgICAvLyBzZW5kaW5nIGFuIGVtcHR5IHBhcnRpY2lwYW50IGlkIHNpbmNlIFRyYWNrUHVibGljYXRpb24gZG9lc24ndCBrZWVwIGl0XHJcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXHJcbiAgICAgICAgcGFydGljaXBhbnRTaWQ6ICcnLFxyXG4gICAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdXHJcbiAgICAgIH0pXVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1Yik7XHJcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XHJcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcclxuICB9XHJcbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpIHtcclxuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5VbnN1YnNjcmliZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIXN1cGVyLmlzU3Vic2NyaWJlZCkge1xyXG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuRGVzaXJlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5TdWJzY3JpYmVkO1xyXG4gIH1cclxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpIHtcclxuICAgIHJldHVybiB0aGlzLmFsbG93ZWQgPyBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuQWxsb3dlZCA6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5Ob3RBbGxvd2VkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdHJhY2sgaXMgc3Vic2NyaWJlZCwgYW5kIHJlYWR5IGZvciBwbGF5YmFja1xyXG4gICAqL1xyXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XHJcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXIuaXNTdWJzY3JpYmVkO1xyXG4gIH1cclxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxyXG4gIGdldCBpc0Rlc2lyZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVkICE9PSBmYWxzZTtcclxuICB9XHJcbiAgZ2V0IGlzRW5hYmxlZCgpIHtcclxuICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZDtcclxuICB9XHJcbiAgZ2V0IGlzTG9jYWwoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGRpc2FibGUgc2VydmVyIGZyb20gc2VuZGluZyBkb3duIGRhdGEgZm9yIHRoaXMgdHJhY2suIHRoaXMgaXMgdXNlZnVsIHdoZW5cclxuICAgKiB0aGUgcGFydGljaXBhbnQgaXMgb2ZmIHNjcmVlbiwgeW91IG1heSBkaXNhYmxlIHN0cmVhbWluZyBkb3duIHRoZWlyIHZpZGVvXHJcbiAgICogdG8gcmVkdWNlIGJhbmR3aWR0aCByZXF1aXJlbWVudHNcclxuICAgKiBAcGFyYW0gZW5hYmxlZFxyXG4gICAqL1xyXG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xyXG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuZGlzYWJsZWQgPT09ICFlbmFibGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZGlzYWJsZWQgPSAhZW5hYmxlZDtcclxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGZvciB0cmFja3MgdGhhdCBzdXBwb3J0IHNpbXVsY2FzdGluZywgYWRqdXN0IHN1YnNjcmliZWQgcXVhbGl0eVxyXG4gICAqXHJcbiAgICogVGhpcyBpbmRpY2F0ZXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSB0aGUgY2xpZW50IGNhbiBhY2NlcHQuIGlmIG5ldHdvcmtcclxuICAgKiBiYW5kd2lkdGggZG9lcyBub3QgYWxsb3csIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgcmVkdWNlIHF1YWxpdHkgdG9cclxuICAgKiBvcHRpbWl6ZSBmb3IgdW5pbnRlcnJ1cHRlZCB2aWRlb1xyXG4gICAqL1xyXG4gIHNldFZpZGVvUXVhbGl0eShxdWFsaXR5KSB7XHJcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID09PSBxdWFsaXR5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHF1YWxpdHk7XHJcbiAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldFZpZGVvRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICgoKF9hID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IGRpbWVuc2lvbnMud2lkdGggJiYgKChfYiA9IHRoaXMudmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gZGltZW5zaW9ucy5oZWlnaHQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xyXG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xyXG4gIH1cclxuICBzZXRWaWRlb0ZQUyhmcHMpIHtcclxuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5mcHMgPT09IGZwcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmZwcyA9IGZwcztcclxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XHJcbiAgfVxyXG4gIGdldCB2aWRlb1F1YWxpdHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0VHJhY2sodHJhY2spIHtcclxuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcclxuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xyXG4gICAgY29uc3QgcHJldlRyYWNrID0gdGhpcy50cmFjaztcclxuICAgIGlmIChwcmV2VHJhY2sgPT09IHRyYWNrKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChwcmV2VHJhY2spIHtcclxuICAgICAgLy8gdW5yZWdpc3RlciBsaXN0ZW5lclxyXG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xyXG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlzaWJpbGl0eUNoYW5nZWQsIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XHJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XHJcbiAgICAgIHByZXZUcmFjay5kZXRhY2goKTtcclxuICAgICAgcHJldlRyYWNrLnN0b3BNb25pdG9yKCk7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVuc3Vic2NyaWJlZCwgcHJldlRyYWNrKTtcclxuICAgIH1cclxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICB0cmFjay5zaWQgPSB0aGlzLnRyYWNrU2lkO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvRGltZW5zaW9uc0NoYW5nZWQsIHRoaXMuaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlKTtcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmliZWQsIHRyYWNrKTtcclxuICAgIH1cclxuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xyXG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0QWxsb3dlZChhbGxvd2VkKSB7XHJcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XHJcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcclxuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XHJcbiAgICB0aGlzLmVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZQZXJtaXNzaW9uKTtcclxuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldFN1YnNjcmlwdGlvbkVycm9yKGVycm9yKSB7XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHVwZGF0ZUluZm8oaW5mbykge1xyXG4gICAgc3VwZXIudXBkYXRlSW5mbyhpbmZvKTtcclxuICAgIGNvbnN0IHByZXZNZXRhZGF0YU11dGVkID0gdGhpcy5tZXRhZGF0YU11dGVkO1xyXG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gaW5mby5tdXRlZDtcclxuICAgIGlmICh0aGlzLnRyYWNrKSB7XHJcbiAgICAgIHRoaXMudHJhY2suc2V0TXV0ZWQoaW5mby5tdXRlZCk7XHJcbiAgICB9IGVsc2UgaWYgKHByZXZNZXRhZGF0YU11dGVkICE9PSBpbmZvLm11dGVkKSB7XHJcbiAgICAgIHRoaXMuZW1pdChpbmZvLm11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNTdGF0dXMpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcclxuICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gY3VycmVudFN0YXR1cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBjdXJyZW50U3RhdHVzLCBwcmV2aW91c1N0YXR1cyk7XHJcbiAgfVxyXG4gIGVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xyXG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25TdGF0dXMgPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XHJcbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25TdGF0dXMgIT09IHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xyXG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgdGhpcy5wZXJtaXNzaW9uU3RhdHVzLCBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB7XHJcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvICYmIHRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB2aWRlbyB0cmFjayBzZXR0aW5ncycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5pc0Rlc2lyZWQpIHtcclxuICAgICAgdGhpcy5sb2cud2FybignY2Fubm90IHVwZGF0ZSB0cmFjayBzZXR0aW5ncyB3aGVuIG5vdCBzdWJzY3JpYmVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIGlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSAmJiB0aGlzLnRyYWNrLmlzQWRhcHRpdmVTdHJlYW07XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IFVwZGF0ZVRyYWNrU2V0dGluZ3Moe1xyXG4gICAgICB0cmFja1NpZHM6IFt0aGlzLnRyYWNrU2lkXSxcclxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXHJcbiAgICAgIGZwczogdGhpcy5mcHNcclxuICAgIH0pO1xyXG4gICAgaWYgKHRoaXMudmlkZW9EaW1lbnNpb25zKSB7XHJcbiAgICAgIHNldHRpbmdzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLndpZHRoKTtcclxuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHNldHRpbmdzLnF1YWxpdHkgPSB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBkZWZhdWx0cyB0byBoaWdoIHF1YWxpdHlcclxuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IFZpZGVvUXVhbGl0eS5ISUdIO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFJlbW90ZVBhcnRpY2lwYW50IGV4dGVuZHMgUGFydGljaXBhbnQge1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgZnJvbVBhcnRpY2lwYW50SW5mbyhzaWduYWxDbGllbnQsIHBpLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHNpZ25hbENsaWVudCwgcGkuc2lkLCBwaS5pZGVudGl0eSwgcGkubmFtZSwgcGkubWV0YWRhdGEsIHBpLmF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMsIHBpLmtpbmQpO1xyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1cGVyLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIHJwSUQ6IHRoaXMuc2lkLFxyXG4gICAgICByZW1vdGVQYXJ0aWNpcGFudDogdGhpcy5pZGVudGl0eVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBjb25zdHJ1Y3RvcihzaWduYWxDbGllbnQsIHNpZCwgaWRlbnRpdHksIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XHJcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5IHx8ICcnLCBuYW1lLCBtZXRhZGF0YSwgYXR0cmlidXRlcywgbG9nZ2VyT3B0aW9ucywga2luZCk7XHJcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcclxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnZvbHVtZU1hcCA9IG5ldyBNYXAoKTtcclxuICB9XHJcbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xyXG4gICAgc3VwZXIuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XHJcbiAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXHJcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVNldHRpbmdzLCBzZXR0aW5ncyA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kIHVwZGF0ZSBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcclxuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpO1xyXG4gICAgfSk7XHJcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViID0+IHtcclxuICAgICAgc3ViLnBhcnRpY2lwYW50VHJhY2tzLmZvckVhY2gocHQgPT4ge1xyXG4gICAgICAgIHB0LnBhcnRpY2lwYW50U2lkID0gdGhpcy5zaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yik7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHN0YXR1cyA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xyXG4gICAgfSk7XHJcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHN0YXR1cyA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2sgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcclxuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xyXG4gICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgIHJldHVybiB0cmFjaztcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XHJcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSk7XHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBzZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgYXVkaW8gdHJhY2tcclxuICAgKiBieSBkZWZhdWx0LCB0aGlzIGFmZmVjdHMgdGhlIG1pY3JvcGhvbmUgcHVibGljYXRpb25cclxuICAgKiBhIGRpZmZlcmVudCBzb3VyY2UgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHNlY29uZCBhcmd1bWVudFxyXG4gICAqIGlmIG5vIHRyYWNrIGV4aXN0cyB0aGUgdm9sdW1lIHdpbGwgYmUgYXBwbGllZCB3aGVuIHRoZSBtaWNyb3Bob25lIHRyYWNrIGlzIGFkZGVkXHJcbiAgICovXHJcbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xyXG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xyXG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xyXG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xyXG4gICAgICBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrLnNldFZvbHVtZSh2b2x1bWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgbWljcm9waG9uZSB0cmFja1xyXG4gICAqL1xyXG4gIGdldFZvbHVtZSgpIHtcclxuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xyXG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xyXG4gICAgaWYgKGF1ZGlvUHVibGljYXRpb24gJiYgYXVkaW9QdWJsaWNhdGlvbi50cmFjaykge1xyXG4gICAgICByZXR1cm4gYXVkaW9QdWJsaWNhdGlvbi50cmFjay5nZXRWb2x1bWUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnZvbHVtZU1hcC5nZXQoc291cmNlKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQpIHtcclxuICAgIC8vIGZpbmQgdGhlIHRyYWNrIHB1YmxpY2F0aW9uXHJcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgbWVkaWEgdHJhY2sgdG8gYXJyaXZlIGJlZm9yZSBwYXJ0aWNpcGFudCBpbmZvXHJcbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzaWQpO1xyXG4gICAgLy8gaXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgZGlkbid0IGhvbm9yIG91ciBvcmlnaW5hbCB0cmFjayBpZFxyXG4gICAgLy8gRmlyZUZveCB3b3VsZCB1c2UgaXRzIG93biBsb2NhbCB1dWlkIGluc3RlYWQgb2Ygc2VydmVyIHRyYWNrIGlkXHJcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XHJcbiAgICAgIGlmICghc2lkLnN0YXJ0c1dpdGgoJ1RSJykpIHtcclxuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdHlwZVxyXG4gICAgICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgIGlmICghcHVibGljYXRpb24gJiYgbWVkaWFUcmFjay5raW5kID09PSBwLmtpbmQudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHdoZW4gd2UgY291bGRuJ3QgbG9jYXRlIHRoZSB0cmFjaywgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBtZXRhZGF0YSBoYXNuJ3RcclxuICAgIC8vIHlldCBhcnJpdmVkLiBXYWl0IGEgYml0IGxvbmdlciBmb3IgaXQgdG8gYXJyaXZlLCBvciBmaXJlIGFuIGVycm9yXHJcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XHJcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IDApIHtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGZpbmQgcHVibGlzaGVkIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICB0cmFja1NpZDogc2lkXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQgLSAxKTtcclxuICAgICAgfSwgMTUwKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xyXG4gICAgICB0aGlzLmxvZy5lcnJvcigndW5hYmxlIHRvIHN1YnNjcmliZSBiZWNhdXNlIE1lZGlhU3RyZWFtVHJhY2sgaXMgZW5kZWQuIERvIG5vdCBjYWxsIE1lZGlhU3RyZWFtVHJhY2suc3RvcCgpJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXNWaWRlbyA9IG1lZGlhVHJhY2sua2luZCA9PT0gJ3ZpZGVvJztcclxuICAgIGxldCB0cmFjaztcclxuICAgIGlmIChpc1ZpZGVvKSB7XHJcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZVZpZGVvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cmFjayA9IG5ldyBSZW1vdGVBdWRpb1RyYWNrKG1lZGlhVHJhY2ssIHNpZCwgcmVjZWl2ZXIsIHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF1ZGlvT3V0cHV0KTtcclxuICAgIH1cclxuICAgIC8vIHNldCB0cmFjayBpbmZvXHJcbiAgICB0cmFjay5zb3VyY2UgPSBwdWJsaWNhdGlvbi5zb3VyY2U7XHJcbiAgICAvLyBrZWVwIHB1YmxpY2F0aW9uJ3MgbXV0ZWQgc3RhdHVzXHJcbiAgICB0cmFjay5pc011dGVkID0gcHVibGljYXRpb24uaXNNdXRlZDtcclxuICAgIHRyYWNrLnNldE1lZGlhU3RyZWFtKG1lZGlhU3RyZWFtKTtcclxuICAgIHRyYWNrLnN0YXJ0KCk7XHJcbiAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh0cmFjayk7XHJcbiAgICAvLyBzZXQgcGFydGljaXBhbnQgdm9sdW1lcyBvbiBuZXcgYXVkaW8gdHJhY2tzXHJcbiAgICBpZiAodGhpcy52b2x1bWVNYXAuaGFzKHB1YmxpY2F0aW9uLnNvdXJjZSkgJiYgaXNSZW1vdGVUcmFjayh0cmFjaykgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICB0cmFjay5zZXRWb2x1bWUodGhpcy52b2x1bWVNYXAuZ2V0KHB1YmxpY2F0aW9uLnNvdXJjZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZ2V0IGhhc01ldGFkYXRhKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5wYXJ0aWNpcGFudEluZm87XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIGdldFRyYWNrUHVibGljYXRpb25CeVNpZChzaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldChzaWQpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgdXBkYXRlSW5mbyhpbmZvKSB7XHJcbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxyXG4gICAgLy8gYW5kIHNlbmQgb3V0IGV2ZW50cyBmb3IgY2hhbmdlc1xyXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIHB1YmxpY2F0aW9ucywgcHVibGlzaCBldmVudHMgb25seSBpZiBtZXRhZGF0YSBpcyBhbHJlYWR5IHRoZXJlXHJcbiAgICAvLyBpLmUuIGNoYW5nZXMgc2luY2UgdGhlIGxvY2FsIHBhcnRpY2lwYW50IGhhcyBqb2luZWRcclxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHRpLnNpZCk7XHJcbiAgICAgIGlmICghcHVibGljYXRpb24pIHtcclxuICAgICAgICAvLyBuZXcgcHVibGljYXRpb25cclxuICAgICAgICBjb25zdCBraW5kID0gVHJhY2sua2luZEZyb21Qcm90byh0aS50eXBlKTtcclxuICAgICAgICBpZiAoIWtpbmQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljYXRpb24gPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbihraW5kLCB0aSwgKF9hID0gdGhpcy5zaWduYWxDbGllbnQuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvU3Vic2NyaWJlLCB7XHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcclxuICAgICAgICAgIGxvZ2dlck5hbWU6IChfYiA9IHRoaXMubG9nZ2VyT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxvZ2dlck5hbWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcclxuICAgICAgICBuZXdUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IChwdWJsaWNhdGlvbiA9PT0gbnVsbCB8fCBwdWJsaWNhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHVibGljYXRpb24uc291cmNlKSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiBwdWJsaWNhdGlvbi5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJlY2VpdmVkIGEgc2Vjb25kIHRyYWNrIHB1YmxpY2F0aW9uIGZvciBcIi5jb25jYXQodGhpcy5pZGVudGl0eSwgXCIgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiKS5jb25jYXQocHVibGljYXRpb24uc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgIG9sZFRyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSksXHJcbiAgICAgICAgICAgIG5ld1RyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhbGlkVHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgLy8gZGV0ZWN0IHJlbW92ZWQgdHJhY2tzXHJcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xyXG4gICAgICBpZiAoIXZhbGlkVHJhY2tzLmhhcyhwdWJsaWNhdGlvbi50cmFja1NpZCkpIHtcclxuICAgICAgICB0aGlzLmxvZy50cmFjZSgnZGV0ZWN0ZWQgcmVtb3ZlZCB0cmFjayBvbiByZW1vdGUgcGFydGljaXBhbnQsIHVucHVibGlzaGluZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcclxuICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBhbHdheXMgZW1pdCBldmVudHMgZm9yIG5ldyBwdWJsaWNhdGlvbnMsIFJvb20gd2lsbCBub3QgZm9yd2FyZCB0aGVtIHVubGVzcyBpdCdzIHJlYWR5XHJcbiAgICBuZXdUcmFja3MuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgdW5wdWJsaXNoVHJhY2soc2lkLCBzZW5kVW5wdWJsaXNoKSB7XHJcbiAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHNpZCk7XHJcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGFsc28gc2VuZCB1bnN1YnNjcmliZSwgaWYgdHJhY2sgaXMgYWN0aXZlbHkgc3Vic2NyaWJlZFxyXG4gICAgY29uc3Qge1xyXG4gICAgICB0cmFja1xyXG4gICAgfSA9IHB1YmxpY2F0aW9uO1xyXG4gICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSB0cmFjayBmcm9tIG1hcHMgb25seSBhZnRlciB1bnN1YnNjcmliZWQgaGFzIGJlZW4gZmlyZWRcclxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XHJcbiAgICAvLyByZW1vdmUgZnJvbSB0aGUgcmlnaHQgdHlwZSBtYXBcclxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xyXG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XHJcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XHJcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaWYgKHNlbmRVbnB1Ymxpc2gpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBzZXRBdWRpb091dHB1dChvdXRwdXQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuYXVkaW9PdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2socHViLnRyYWNrKSAmJiBpc1JlbW90ZVRyYWNrKHB1Yi50cmFjaykpIHtcclxuICAgICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZCgoX2EgPSBvdXRwdXQuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdkZWZhdWx0JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZW1pdChldmVudCkge1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICBldmVudCxcclxuICAgICAgYXJnc1xyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIENvbm5lY3Rpb25TdGF0ZTtcclxuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcclxuICBDb25uZWN0aW9uU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xyXG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcclxuICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xyXG4gIENvbm5lY3Rpb25TdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XHJcbiAgQ29ubmVjdGlvblN0YXRlW1wiU2lnbmFsUmVjb25uZWN0aW5nXCJdID0gXCJzaWduYWxSZWNvbm5lY3RpbmdcIjtcclxufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xyXG5jb25zdCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5ID0gNCAqIDEwMDA7XHJcbi8qKlxyXG4gKiBJbiBMaXZlS2l0LCBhIHJvb20gaXMgdGhlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGEgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXHJcbiAqIFBhcnRpY2lwYW50cyBpbiBhIHJvb20gY2FuIHB1Ymxpc2ggdHJhY2tzLCBhbmQgc3Vic2NyaWJlIHRvIG90aGVycycgdHJhY2tzLlxyXG4gKlxyXG4gKiBhIFJvb20gZmlyZXMgW1tSb29tRXZlbnQgfCBSb29tRXZlbnRzXV0uXHJcbiAqXHJcbiAqIEBub0luaGVyaXREb2NcclxuICovXHJcbmNsYXNzIFJvb20gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBSb29tLCB0aGUgcHJpbWFyeSBjb25zdHJ1Y3QgZm9yIGEgTGl2ZUtpdCBzZXNzaW9uLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgdmFyIF90aGlzO1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgX3RoaXMgPSB0aGlzO1xyXG4gICAgdGhpcy5zdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XHJcbiAgICAvKipcclxuICAgICAqIGxpc3Qgb2YgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFjdGl2ZWx5IHNwZWFraW5nLiB3aGVuIHRoaXMgY2hhbmdlc1xyXG4gICAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxyXG4gICAgICovXHJcbiAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XHJcbiAgICAvKiogcmVmbGVjdHMgdGhlIHNlbmRlciBlbmNyeXB0aW9uIHN0YXR1cyBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQgKi9cclxuICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5hdWRpb0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XHJcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5ycGNIYW5kbGVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuY29ubmVjdCA9ICh1cmwsIHRva2VuLCBvcHRzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKCFpc0Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yKFwiV2ViUlRDIGlzbid0IGRldGVjdGVkLCBoYXZlIHlvdSBjYWxsZWQgcmVnaXN0ZXJHbG9iYWxzP1wiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJMaXZlS2l0IGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLiBUcnkgdG8gdXBkYXRlIHlvdXIgYnJvd3NlciBhbmQgbWFrZSBzdXJlIG5vIGJyb3dzZXIgZXh0ZW5zaW9ucyBhcmUgZGlzYWJsaW5nIHdlYlJUQy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIEluIGNhc2UgYSBkaXNjb25uZWN0IGNhbGxlZCBoYXBwZW5lZCByaWdodCBiZWZvcmUgdGhlIGNvbm5lY3QgY2FsbCwgbWFrZSBzdXJlIHRoZSBkaXNjb25uZWN0IGlzIGNvbXBsZXRlZCBmaXJzdCBieSBhd2FpdGluZyBpdHMgbG9ja1xyXG4gICAgICBjb25zdCB1bmxvY2tEaXNjb25uZWN0ID0geWllbGQgdGhpcy5kaXNjb25uZWN0TG9jay5sb2NrKCk7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgaXMgcmVjb25uZWN0aW5nIG9yIGNvbm5lY3RlZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcImFscmVhZHkgY29ubmVjdGVkIHRvIHJvb20gXCIuY29uY2F0KHRoaXMubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jb25uZWN0RnV0dXJlKSB7XHJcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpO1xyXG4gICAgICBpZiAoKChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZXJ2ZXJVcmwoKS50b1N0cmluZygpKSAhPT0gdXJsKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih1cmwsIHRva2VuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IGZldGNoIHdpdGhvdXQgd2FpdGluZyBmb3IgYSByZXNwb25zZVxyXG4gICAgICAgIC8vIGlmIGluaXRpYWwgY29ubmVjdGlvbiBmYWlscywgdGhpcyB3aWxsIHNwZWVkIHVwIHBpY2tpbmcgcmVnaW9uYWwgdXJsXHJcbiAgICAgICAgLy8gb24gc3Vic2VxdWVudCBydW5zXHJcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5mZXRjaFJlZ2lvblNldHRpbmdzKCkudGhlbihzZXR0aW5ncyA9PiB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U2VydmVyUmVwb3J0ZWRSZWdpb25zKHNldHRpbmdzKTtcclxuICAgICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjb25uZWN0Rm4gPSAocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlcikge1xyXG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhwbGljaXQgY3JlYXRpb24gYXMgbG9jYWwgdmFyIG5lZWRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyIHdoZW4gcGFzc2luZyBpdCB0byBgYXR0ZW1wdENvbm5lY3Rpb25gIGZ1cnRoZXIgZG93blxyXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcclxuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBpbnRlbnRpb24gdG8gY29ubmVjdCBoYXMgYmVlbiBzaWduYWxsZWQgc28gd2UgY2FuIGFsbG93IGNhbmNlbGxpbmcgb2YgdGhlIGNvbm5lY3Rpb24gdmlhIGRpc2Nvbm5lY3QoKSBhZ2FpblxyXG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QgPT09IG51bGwgfHwgdW5sb2NrRGlzY29ubmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5sb2NrRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmF0dGVtcHRDb25uZWN0aW9uKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciAmJiBlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uICE9PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkICYmIGUucmVhc29uICE9PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xyXG4gICAgICAgICAgICBsZXQgbmV4dFVybCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgbmV4dFVybCA9IHlpZWxkIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKF9hID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWwpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0VXJsICYmICEoKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaWduYWwuYWJvcnRlZCkpIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKFwiSW5pdGlhbCBjb25uZWN0aW9uIGZhaWxlZCB3aXRoIENvbm5lY3Rpb25FcnJvcjogXCIuY29uY2F0KGUubWVzc2FnZSwgXCIuIFJldHJ5aW5nIHdpdGggYW5vdGhlciByZWdpb246IFwiKS5jb25jYXQobmV4dFVybCksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xyXG4gICAgICAgICAgICAgIHlpZWxkIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZSkpO1xyXG4gICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGRpc2Nvbm5lY3RSZWFzb24gPSBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xyXG4gICAgICAgICAgICAgIGRpc2Nvbm5lY3RSZWFzb24gPSBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIGRpc2Nvbm5lY3RSZWFzb24pO1xyXG4gICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVnaW9uVXJsID0gdGhpcy5yZWdpb25Vcmw7XHJcbiAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xyXG4gICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25GdXR1cmVzKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0RnV0dXJlLnByb21pc2U7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuY29ubmVjdFNpZ25hbCA9ICh1cmwsIHRva2VuLCBlbmdpbmUsIGNvbm5lY3RPcHRpb25zLCByb29tT3B0aW9ucywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCBlbmdpbmUuam9pbih1cmwsIHRva2VuLCB7XHJcbiAgICAgICAgYXV0b1N1YnNjcmliZTogY29ubmVjdE9wdGlvbnMuYXV0b1N1YnNjcmliZSxcclxuICAgICAgICBhZGFwdGl2ZVN0cmVhbTogdHlwZW9mIHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0JyA/IHRydWUgOiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSxcclxuICAgICAgICBtYXhSZXRyaWVzOiBjb25uZWN0T3B0aW9ucy5tYXhSZXRyaWVzLFxyXG4gICAgICAgIGUyZWVFbmFibGVkOiAhIXRoaXMuZTJlZU1hbmFnZXIsXHJcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogY29ubmVjdE9wdGlvbnMud2Vic29ja2V0VGltZW91dFxyXG4gICAgICB9LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgbGV0IHNlcnZlckluZm8gPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbztcclxuICAgICAgaWYgKCFzZXJ2ZXJJbmZvKSB7XHJcbiAgICAgICAgc2VydmVySW5mbyA9IHtcclxuICAgICAgICAgIHZlcnNpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uLFxyXG4gICAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNlcnZlckluZm8gPSBzZXJ2ZXJJbmZvO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcImNvbm5lY3RlZCB0byBMaXZla2l0IFNlcnZlciBcIi5jb25jYXQoT2JqZWN0LmVudHJpZXMoc2VydmVySW5mbykubWFwKF9yZWYgPT4ge1xyXG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiOiBcIikuY29uY2F0KHZhbHVlKTtcclxuICAgICAgfSkuam9pbignLCAnKSksIHtcclxuICAgICAgICByb29tOiAoX2EgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUsXHJcbiAgICAgICAgcm9vbVNpZDogKF9iID0gam9pblJlc3BvbnNlLnJvb20pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaWQsXHJcbiAgICAgICAgaWRlbnRpdHk6IChfYyA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlkZW50aXR5XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXNlcnZlckluZm8udmVyc2lvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFNlcnZlcigndW5rbm93biBzZXJ2ZXIgdmVyc2lvbicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXJ2ZXJJbmZvLnZlcnNpb24gPT09ICcwLjE1LjEnICYmIHRoaXMub3B0aW9ucy5keW5hY2FzdCkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdkaXNhYmxpbmcgZHluYWNhc3QgZHVlIHRvIHNlcnZlciB2ZXJzaW9uJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAvLyBkeW5hY2FzdCBoYXMgYSBidWcgaW4gMC4xNS4xLCBzbyB3ZSBjYW5ub3QgdXNlIGl0IHRoZW5cclxuICAgICAgICByb29tT3B0aW9ucy5keW5hY2FzdCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBqb2luUmVzcG9uc2U7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2UgPT4ge1xyXG4gICAgICBjb25zdCBwaSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudDtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCA9IHBpLnNpZDtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRFbmFibGVkUHVibGlzaENvZGVjcyhqb2luUmVzcG9uc2UuZW5hYmxlZFB1Ymxpc2hDb2RlY3MpO1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUgJiYgdGhpcy5lMmVlTWFuYWdlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFNpZlRyYWlsZXIoam9pblJlc3BvbnNlLnNpZlRyYWlsZXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdDb3VsZCBub3Qgc2V0IFNpZlRyYWlsZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gcG9wdWxhdGUgcmVtb3RlIHBhcnRpY2lwYW50cywgdGhlc2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIG5ldyBldmVudHNcclxuICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3BpLCAuLi5qb2luUmVzcG9uc2Uub3RoZXJQYXJ0aWNpcGFudHNdKTtcclxuICAgICAgaWYgKGpvaW5SZXNwb25zZS5yb29tKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKGpvaW5SZXNwb25zZS5yb29tKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24gPSAodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAoKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZW5kaW5nUmVjb25uZWN0KSkge1xyXG4gICAgICAgIHRoaXMubG9nLmluZm8oJ1JlY29ubmVjdGlvbiBhdHRlbXB0IHJlcGxhY2VkIGJ5IG5ldyBjb25uZWN0aW9uIGF0dGVtcHQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xyXG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXHJcbiAgICAgICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNDbG91ZCgpKSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUuc2V0UmVnaW9uVXJsUHJvdmlkZXIodGhpcy5yZWdpb25VcmxQcm92aWRlcik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCk7XHJcbiAgICAgIHRoaXMuY29ubk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMpLCBvcHRzKTtcclxuICAgICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucnRjQ29uZmlnID0gdGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0KSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XHJcbiAgICAgIH1cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBqb2luUmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNvbm5lY3RTaWduYWwodXJsLCB0b2tlbiwgdGhpcy5lbmdpbmUsIHRoaXMuY29ubk9wdGlvbnMsIHRoaXMub3B0aW9ucywgYWJvcnRDb250cm9sbGVyKTtcclxuICAgICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XHJcbiAgICAgICAgLy8gZm9yd2FyZCBtZXRhZGF0YSBjaGFuZ2VkIGZvciB0aGUgbG9jYWwgcGFydGljaXBhbnRcclxuICAgICAgICB0aGlzLnNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0aW5nRXJyb3IgPSBuZXcgQ29ubmVjdGlvbkVycm9yKFwiY291bGQgbm90IGVzdGFibGlzaCBzaWduYWwgY29ubmVjdGlvblwiLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpO1xyXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IubWVzc2FnZSA9IFwiXCIuY29uY2F0KHJlc3VsdGluZ0Vycm9yLm1lc3NhZ2UsIFwiOiBcIikuY29uY2F0KGVyci5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xyXG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcclxuICAgICAgICAgIHJlc3VsdGluZ0Vycm9yLnN0YXR1cyA9IGVyci5zdGF0dXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZXJyb3IgdHJ5aW5nIHRvIGVzdGFibGlzaCBzaWduYWwgY29ubmVjdGlvblwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhyb3cgcmVzdWx0aW5nRXJyb3I7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xyXG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZFwiLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhbHNvIGhvb2sgdW5sb2FkIGV2ZW50XHJcbiAgICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcclxuICAgICAgICAvLyBjYXB0dXJpbmcgYm90aCAncGFnZWhpZGUnIGFuZCAnYmVmb3JldW5sb2FkJyB0byBjYXB0dXJlIGJyb2FkZXN0IHNldCBvZiBicm93c2VyIGJlaGF2aW9yc1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzXzEgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgICAgYXJnc18xW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIFsuLi5hcmdzXzFdLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuICAgICAgICBsZXQgc3RvcFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMi5kaXNjb25uZWN0TG9jay5sb2NrKCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgX3RoaXMyLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCBfdGhpczIubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzMi5sb2cuaW5mbygnZGlzY29ubmVjdCBmcm9tIHJvb20nLCBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCkpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCBfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcgfHwgX3RoaXMyLmlzUmVzdW1pbmcpIHtcclxuICAgICAgICAgICAgICAvLyB0cnkgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9uIGF0dGVtcHRcclxuICAgICAgICAgICAgICBfdGhpczIubG9nLndhcm4oJ2Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIF90aGlzMi5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgICAoX2EgPSBfdGhpczIuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBhYm9ydCBjb250cm9sbGVyIGRpZG4ndCBtYW5hZ2UgdG8gY2FuY2VsIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQsIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlIGV4cGxpY2l0bHlcclxuICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpczIuY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcclxuICAgICAgICAgICAgICBfdGhpczIuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzZW5kIGxlYXZlXHJcbiAgICAgICAgICAgIGlmICghKChfZCA9IF90aGlzMi5lbmdpbmUpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jbGllbnQuaXNEaXNjb25uZWN0ZWQpKSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXMyLmVuZ2luZS5jbGllbnQuc2VuZExlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2xvc2UgZW5naW5lIChhbHNvIGNsb3NlcyBjbGllbnQpXHJcbiAgICAgICAgICAgIGlmIChfdGhpczIuZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXMyLmVuZ2luZS5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVEaXNjb25uZWN0KHN0b3BUcmFja3MsIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCk7XHJcbiAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICAgICAgX3RoaXMyLmVuZ2luZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIHVubG9jaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0oKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vblBhZ2VMZWF2ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5sb2cuaW5mbygnUGFnZSBsZWF2ZSBkZXRlY3RlZCwgZGlzY29ubmVjdGluZycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IHBvbGljaWVzIHJlZ2FyZGluZyBhdWRpbyBwbGF5YmFjay4gTW9zdCByZXF1aXJpbmdcclxuICAgICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cclxuICAgICAqIEluIHRob3NlIGNhc2VzLCBhdWRpbyB3aWxsIGJlIHNpbGVudCB1bnRpbCBhIGNsaWNrL3RhcCB0cmlnZ2VyaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nXHJcbiAgICAgKiAtIGBzdGFydEF1ZGlvYFxyXG4gICAgICogLSBgZ2V0VXNlck1lZGlhYFxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YXJ0QXVkaW8gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XHJcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgICAgIGlmIChicm93c2VyICYmIGJyb3dzZXIub3MgPT09ICdpT1MnKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaU9TIGJsb2NrcyBhdWRpbyBlbGVtZW50IHBsYXliYWNrIGlmXHJcbiAgICAgICAgICogLSB1c2VyIGlzIG5vdCBwdWJsaXNoaW5nIGF1ZGlvIHRoZW1zZWx2ZXMgYW5kXHJcbiAgICAgICAgICogLSBubyBvdGhlciBhdWRpbyBzb3VyY2UgaXMgcGxheWluZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXMgYSB3b3JrYXJvdW5kLCB3ZSBjcmVhdGUgYW4gYXVkaW8gZWxlbWVudCB3aXRoIGFuIGVtcHR5IHRyYWNrLCBzbyB0aGF0XHJcbiAgICAgICAgICogc2lsZW50IGF1ZGlvIGlzIGFsd2F5cyBwbGF5aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3QgYXVkaW9JZCA9ICdsaXZla2l0LWR1bW15LWF1ZGlvLWVsJztcclxuICAgICAgICBsZXQgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXVkaW9JZCk7XHJcbiAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcclxuICAgICAgICAgIGR1bW15QXVkaW9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XHJcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaWQgPSBhdWRpb0lkO1xyXG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmF1dG9wbGF5ID0gdHJ1ZTtcclxuICAgICAgICAgIGR1bW15QXVkaW9FbC5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcclxuICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFt0cmFja10pO1xyXG4gICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IHN0cmVhbTtcclxuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgc3JjT2JqZWN0IHRvIG51bGwgb24gcGFnZSBoaWRlIGluIG9yZGVyIHRvIHByZXZlbnQgbG9jayBzY3JlZW4gY29udHJvbHMgdG8gc2hvdyB1cCBmb3IgaXRcclxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsLnNyY09iamVjdCA9IGRvY3VtZW50LmhpZGRlbiA/IG51bGwgOiBzdHJlYW07XHJcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BhZ2UgdmlzaWJsZSBhZ2FpbiwgdHJpZ2dlcmluZyBzdGFydEF1ZGlvIHRvIHJlc3VtZSBwbGF5YmFjayBhbmQgdXBkYXRlIHBsYXliYWNrIHN0YXR1cycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5zdGFydEF1ZGlvKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcclxuICAgICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGR1bW15QXVkaW9FbCA9PT0gbnVsbCB8fCBkdW1teUF1ZGlvRWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGR1bW15QXVkaW9FbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID0gbnVsbDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50cy5wdXNoKGR1bW15QXVkaW9FbCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICBwLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0ID0+IHtcclxuICAgICAgICAgIGlmICh0LnRyYWNrKSB7XHJcbiAgICAgICAgICAgIHQudHJhY2suYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksIC4uLmVsZW1lbnRzLm1hcChlID0+IHtcclxuICAgICAgICAgIGUubXV0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgIHJldHVybiBlLnBsYXkoKTtcclxuICAgICAgICB9KV0pO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQoKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKGVycik7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc3RhcnRWaWRlbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgcC52aWRlb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHIgPT4ge1xyXG4gICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgKF9hID0gdHIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoZWwgPT4gZWwucGxheSgpKSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCgpO1xyXG4gICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1Jlc3VtaW5nIHZpZGVvIHBsYXliYWNrIGZhaWxlZCwgbWFrZSBzdXJlIHlvdSBjYWxsIGBzdGFydFZpZGVvYCBkaXJlY3RseSBpbiBhIHVzZXIgZ2VzdHVyZSBoYW5kbGVyJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmhhbmRsZVJlc3RhcnRpbmcgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICAgIC8vIGluIGNhc2Ugd2Ugd2VudCBmcm9tIHJlc3VtaW5nIHRvIGZ1bGwtcmVjb25uZWN0LCBtYWtlIHN1cmUgdG8gcmVmbGVjdCBpdCBvbiB0aGUgaXNSZXN1bWluZyBmbGFnXHJcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xyXG4gICAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXHJcbiAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocC5pZGVudGl0eSwgcCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzdGFydGVkID0gam9pblJlc3BvbnNlID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJzaWduYWwgcmVjb25uZWN0ZWQgdG8gc2VydmVyLCByZWdpb24gXCIuY29uY2F0KGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cclxuICAgICAgfSkpO1xyXG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XHJcbiAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyB1bnB1Ymxpc2ggJiByZXB1Ymxpc2ggdHJhY2tzXHJcbiAgICAgICAgeWllbGQgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB0cnlpbmcgdG8gcmUtcHVibGlzaCB0cmFja3MgYWZ0ZXIgcmVjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBlcnJvclxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLndhaXRGb3JSZXN0YXJ0ZWQoKTtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlclwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxyXG4gICAgICAgIH0pKTtcclxuICAgICAgfSBjYXRjaCAoX2EpIHtcclxuICAgICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xyXG4gICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyA9IHBhcnRpY2lwYW50SW5mb3MgPT4ge1xyXG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byBwYXJ0aWNpcGFudCBzdGF0ZSwgYW5kIHNlbmQgZXZlbnRzXHJcbiAgICAgIHBhcnRpY2lwYW50SW5mb3MuZm9yRWFjaChpbmZvID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGluZm8uaWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkge1xyXG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIExpdmVLaXQgc2VydmVyIGRvZXNuJ3Qgc2VuZCBpZGVudGl0eSBpbmZvIHByaW9yIHRvIHZlcnNpb24gMS41LjIgaW4gZGlzY29ubmVjdCB1cGRhdGVzXHJcbiAgICAgICAgLy8gc28gd2UgdHJ5IHRvIG1hcCBhbiBlbXB0eSBpZGVudGl0eSB0byBhbiBhbHJlYWR5IGtub3duIHNJRCBtYW51YWxseVxyXG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSAnJykge1xyXG4gICAgICAgICAgaW5mby5pZGVudGl0eSA9IChfYSA9IHRoaXMuc2lkVG9JZGVudGl0eS5nZXQoaW5mby5zaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGluZm8uaWRlbnRpdHkpO1xyXG4gICAgICAgIC8vIHdoZW4gaXQncyBkaXNjb25uZWN0ZWQsIHNlbmQgdXBkYXRlc1xyXG4gICAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGluZm8uaWRlbnRpdHksIHJlbW90ZVBhcnRpY2lwYW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgIHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gdXBkYXRlcyBhcmUgc2VudCBvbmx5IHdoZW4gdGhlcmUncyBhIGNoYW5nZSB0byBzcGVha2VyIG9yZGVyaW5nXHJcbiAgICB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlID0gc3BlYWtlcnMgPT4ge1xyXG4gICAgICBjb25zdCBhY3RpdmVTcGVha2VycyA9IFtdO1xyXG4gICAgICBjb25zdCBzZWVuU2lkcyA9IHt9O1xyXG4gICAgICBzcGVha2Vycy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xyXG4gICAgICAgIHNlZW5TaWRzW3NwZWFrZXIuc2lkXSA9IHRydWU7XHJcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyh0cnVlKTtcclxuICAgICAgICAgIGFjdGl2ZVNwZWFrZXJzLnB1c2godGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XHJcbiAgICAgICAgICBpZiAocCkge1xyXG4gICAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xyXG4gICAgICAgICAgICBwLnNldElzU3BlYWtpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGFjdGl2ZVNwZWFrZXJzLnB1c2gocCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb0xldmVsID0gMDtcclxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyhmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICBpZiAoIXNlZW5TaWRzW3Auc2lkXSkge1xyXG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gMDtcclxuICAgICAgICAgIHAuc2V0SXNTcGVha2luZyhmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQsIGFjdGl2ZVNwZWFrZXJzKTtcclxuICAgIH07XHJcbiAgICAvLyBwcm9jZXNzIGxpc3Qgb2YgY2hhbmdlZCBzcGVha2Vyc1xyXG4gICAgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQgPSBzcGVha2VyVXBkYXRlcyA9PiB7XHJcbiAgICAgIGNvbnN0IGxhc3RTcGVha2VycyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5hY3RpdmVTcGVha2Vycy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KHAuaWRlbnRpdHkpO1xyXG4gICAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudCAmJiByZW1vdGVQYXJ0aWNpcGFudC5zaWQgIT09IHAuc2lkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RTcGVha2Vycy5zZXQocC5zaWQsIHApO1xyXG4gICAgICB9KTtcclxuICAgICAgc3BlYWtlclVwZGF0ZXMuZm9yRWFjaChzcGVha2VyID0+IHtcclxuICAgICAgICBsZXQgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XHJcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XHJcbiAgICAgICAgICBwID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXApIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcclxuICAgICAgICBwLnNldElzU3BlYWtpbmcoc3BlYWtlci5hY3RpdmUpO1xyXG4gICAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgbGFzdFNwZWFrZXJzLnNldChzcGVha2VyLnNpZCwgcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xyXG4gICAgICBhY3RpdmVTcGVha2Vycy5zb3J0KChhLCBiKSA9PiBiLmF1ZGlvTGV2ZWwgLSBhLmF1ZGlvTGV2ZWwpO1xyXG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gYWN0aXZlU3BlYWtlcnM7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUgPSBzdHJlYW1TdGF0ZVVwZGF0ZSA9PiB7XHJcbiAgICAgIHN0cmVhbVN0YXRlVXBkYXRlLnN0cmVhbVN0YXRlcy5mb3JFYWNoKHN0cmVhbVN0YXRlID0+IHtcclxuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XHJcbiAgICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQoc3RyZWFtU3RhdGUudHJhY2tTaWQpO1xyXG4gICAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3U3RyZWFtU3RhdGUgPSBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byhzdHJlYW1TdGF0ZS5zdGF0ZSk7XHJcbiAgICAgICAgaWYgKG5ld1N0cmVhbVN0YXRlICE9PSBwdWIudHJhY2suc3RyZWFtU3RhdGUpIHtcclxuICAgICAgICAgIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSA9IG5ld1N0cmVhbVN0YXRlO1xyXG4gICAgICAgICAgcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSk7XHJcbiAgICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCwgcHViLCBwdWIudHJhY2suc3RyZWFtU3RhdGUsIHBhcnRpY2lwYW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IHVwZGF0ZSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHVwZGF0ZS5wYXJ0aWNpcGFudFNpZCk7XHJcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XHJcbiAgICAgIGlmICghcHViKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHB1Yi5zZXRBbGxvd2VkKHVwZGF0ZS5hbGxvd2VkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gdXBkYXRlID0+IHtcclxuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5maW5kKHAgPT4gcC50cmFja1B1YmxpY2F0aW9ucy5oYXModXBkYXRlLnRyYWNrU2lkKSk7XHJcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XHJcbiAgICAgIGlmICghcHViKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHB1Yi5zZXRTdWJzY3JpcHRpb25FcnJvcih1cGRhdGUuZXJyKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSBwYWNrZXQgPT4ge1xyXG4gICAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxyXG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSk7XHJcbiAgICAgIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3VzZXInKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVVc2VyUGFja2V0KHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5raW5kKTtcclxuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3RyYW5zY3JpcHRpb24nKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnc2lwRHRtZicpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVNpcER0bWYocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdjaGF0TWVzc2FnZScpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUNoYXRNZXNzYWdlKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnbWV0cmljcycpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZU1ldHJpY3MocGFja2V0LnZhbHVlLnZhbHVlLCBwYXJ0aWNpcGFudCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1IZWFkZXInKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW1IZWFkZXIocGFja2V0LnZhbHVlLnZhbHVlLCBwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1DaHVuaycpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUNodW5rKHBhY2tldC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1UcmFpbGVyJykge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtVHJhaWxlcihwYWNrZXQudmFsdWUudmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAncnBjUmVxdWVzdCcpIHtcclxuICAgICAgICBjb25zdCBycGMgPSBwYWNrZXQudmFsdWUudmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY1JlcXVlc3QocGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHksIHJwYy5pZCwgcnBjLm1ldGhvZCwgcnBjLnBheWxvYWQsIHJwYy5yZXNwb25zZVRpbWVvdXRNcywgcnBjLnZlcnNpb24pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVVc2VyUGFja2V0ID0gKHBhcnRpY2lwYW50LCB1c2VyUGFja2V0LCBraW5kKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIHBhcnRpY2lwYW50LCBraW5kLCB1c2VyUGFja2V0LnRvcGljKTtcclxuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxyXG4gICAgICBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBraW5kKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVNpcER0bWYgPSAocGFydGljaXBhbnQsIGR0bWYpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYsIHBhcnRpY2lwYW50KTtcclxuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxyXG4gICAgICBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlNpcERUTUZSZWNlaXZlZCwgZHRtZik7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5idWZmZXJlZFNlZ21lbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uID0gKF9yZW1vdGVQYXJ0aWNpcGFudCwgdHJhbnNjcmlwdGlvbikgPT4ge1xyXG4gICAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxyXG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRyYW5zY3JpcHRpb24udHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPyB0aGlzLmxvY2FsUGFydGljaXBhbnQgOiB0aGlzLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eSh0cmFuc2NyaXB0aW9uLnRyYW5zY3JpYmVkUGFydGljaXBhbnRJZGVudGl0eSk7XHJcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFuc2NyaXB0aW9uLnRyYWNrSWQpO1xyXG4gICAgICBjb25zdCBzZWdtZW50cyA9IGV4dHJhY3RUcmFuc2NyaXB0aW9uU2VnbWVudHModHJhbnNjcmlwdGlvbiwgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyk7XHJcbiAgICAgIHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5lbWl0KFRyYWNrRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cyk7XHJcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cywgcHVibGljYXRpb24pO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMsIHBhcnRpY2lwYW50LCBwdWJsaWNhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVDaGF0TWVzc2FnZSA9IChwYXJ0aWNpcGFudCwgY2hhdE1lc3NhZ2UpID0+IHtcclxuICAgICAgY29uc3QgbXNnID0gZXh0cmFjdENoYXRNZXNzYWdlKGNoYXRNZXNzYWdlKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5DaGF0TWVzc2FnZSwgbXNnLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVNZXRyaWNzID0gKG1ldHJpY3MsIHBhcnRpY2lwYW50KSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWV0cmljc1JlY2VpdmVkLCBtZXRyaWNzLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCA9IGUgPT4ge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcGxheWJhY2sgYXVkaW8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBlcnJvcjogZVxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmICghdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XHJcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XHJcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZURldmljZUNoYW5nZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9zKSAhPT0gJ2lPUycpIHtcclxuICAgICAgICAvLyBkZWZhdWx0IGRldmljZXMgYXJlIG5vbiBkZXRlcm1pbmlzdGljIG9uIGlPUywgc28gd2UgZG9uJ3QgYXR0ZW1wdCB0byBzZWxlY3QgdGhlbSBoZXJlXHJcbiAgICAgICAgeWllbGQgdGhpcy5zZWxlY3REZWZhdWx0RGV2aWNlcygpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzQ2hhbmdlZCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb20gPT4ge1xyXG4gICAgICBjb25zdCBvbGRSb29tID0gdGhpcy5yb29tSW5mbztcclxuICAgICAgdGhpcy5yb29tSW5mbyA9IHJvb207XHJcbiAgICAgIGlmIChvbGRSb29tICYmIG9sZFJvb20ubWV0YWRhdGEgIT09IHJvb20ubWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Sb29tTWV0YWRhdGFDaGFuZ2VkLCByb29tLm1ldGFkYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKG9sZFJvb20gPT09IG51bGwgfHwgb2xkUm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkUm9vbS5hY3RpdmVSZWNvcmRpbmcpICE9PSByb29tLmFjdGl2ZVJlY29yZGluZykge1xyXG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJlY29yZGluZ1N0YXR1c0NoYW5nZWQsIHJvb20uYWN0aXZlUmVjb3JkaW5nKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4ge1xyXG4gICAgICB1cGRhdGUudXBkYXRlcy5mb3JFYWNoKGluZm8gPT4ge1xyXG4gICAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0Q29ubmVjdGlvblF1YWxpdHkoaW5mby5xdWFsaXR5KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoaW5mby5wYXJ0aWNpcGFudFNpZCk7XHJcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XHJcbiAgICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgPSBtZXRhZGF0YSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQgPSBuYW1lID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkID0gY2hhbmdlZEF0dHJpYnV0ZXMgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQgPSBwdWIgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQgPSBwdWIgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5tdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSA9IHByb2Nlc3NvciA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gcHJvY2Vzc29yID09PSBudWxsIHx8IHByb2Nlc3NvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzc29yLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvY2Vzc29yLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbihUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xyXG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbihUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQpO1xyXG4gICAgICAoX2UgPSAoX2QgPSAoX2MgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9jZXNzb3IoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHB1Yi50cmFjaykpIHtcclxuICAgICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgcHViLnRyYWNrLmNoZWNrRm9yU2lsZW5jZSgpO1xyXG4gICAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQsIHB1Yik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgKF9mID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZ2V0RGV2aWNlSWQoZmFsc2UpO1xyXG4gICAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xyXG4gICAgICBpZiAoZGV2aWNlS2luZCAmJiBkZXZpY2VJZCAmJiBkZXZpY2VJZCAhPT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZCkpIHtcclxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHB1YiA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZihUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xyXG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vZmYoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMub25Mb2NhbFRyYWNrUmVzdGFydGVkKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCB0cmFjay5nZXREZXZpY2VJZChmYWxzZSk7XHJcbiAgICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQodHJhY2suc291cmNlKTtcclxuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJsb2NhbCB0cmFjayByZXN0YXJ0ZWQsIHNldHRpbmcgXCIuY29uY2F0KGRldmljZUtpbmQsIFwiIFwiKS5jb25jYXQoZGV2aWNlSWQsIFwiIGFjdGl2ZVwiKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gcXVhbGl0eSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25NZWRpYURldmljZXNFcnJvciA9IChlLCBraW5kKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUsIGtpbmQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gcHJldlBlcm1pc3Npb25zID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCA9IG1zZyA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgIH07XHJcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xyXG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnNpZFRvSWRlbnRpdHkgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21PcHRpb25EZWZhdWx0cyksIG9wdGlvbnMpO1xyXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlJvb20pO1xyXG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXVkaW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyk7XHJcbiAgICB0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xyXG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyk7XHJcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XHJcbiAgICB0aGlzLmRpc2Nvbm5lY3RMb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KCcnLCAnJywgdGhpcy5lbmdpbmUsIHRoaXMub3B0aW9ucywgdGhpcy5ycGNIYW5kbGVycyk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSB7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KCd2aWRlb2lucHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKChfYiA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSB7XHJcbiAgICAgIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKCdhdWRpb291dHB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkKSkuY2F0Y2goZSA9PiB0aGlzLmxvZy53YXJuKFwiQ291bGQgbm90IHNldCBhdWRpbyBvdXRwdXQ6IFwiLmNvbmNhdChlLm1lc3NhZ2UpLCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xyXG4gICAgICB0aGlzLnNldHVwRTJFRSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAvLyBpbiBvcmRlciB0byBjYXRjaCBkZXZpY2UgY2hhbmdlcyBwcmlvciB0byByb29tIGNvbm5lY3Rpb24gd2UgbmVlZCB0byByZWdpc3RlciB0aGUgZXZlbnQgaW4gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAgIChfYyA9IG5hdmlnYXRvci5tZWRpYURldmljZXMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCB0aGlzLmhhbmRsZURldmljZUNoYW5nZSwge1xyXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKFJvb20uY2xlYW51cFJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgUm9vbS5jbGVhbnVwUmVnaXN0cnkucmVnaXN0ZXIodGhpcywgKCkgPT4ge1xyXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRleHQgc3RyZWFtIGhhbmRsZXIgZm9yIHRvcGljIFxcXCJcIi5jb25jYXQodG9waWMsIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHNldC5cIikpO1xyXG4gICAgfVxyXG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XHJcbiAgfVxyXG4gIHVucmVnaXN0ZXJUZXh0U3RyZWFtSGFuZGxlcih0b3BpYykge1xyXG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcclxuICB9XHJcbiAgcmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYywgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIGJ5dGUgc3RyZWFtIGhhbmRsZXIgZm9yIHRvcGljIFxcXCJcIi5jb25jYXQodG9waWMsIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHNldC5cIikpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XHJcbiAgfVxyXG4gIHVucmVnaXN0ZXJCeXRlU3RyZWFtSGFuZGxlcih0b3BpYykge1xyXG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRXN0YWJsaXNoZXMgdGhlIHBhcnRpY2lwYW50IGFzIGEgcmVjZWl2ZXIgZm9yIGNhbGxzIG9mIHRoZSBzcGVjaWZpZWQgUlBDIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbmFtZSBvZiB0aGUgaW5kaWNhdGVkIFJQQyBtZXRob2RcclxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFdpbGwgYmUgaW52b2tlZCB3aGVuIGFuIFJQQyByZXF1ZXN0IGZvciB0aGlzIG1ldGhvZCBpcyByZWNlaXZlZFxyXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG1ldGhvZCBpcyBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZFxyXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIGhhbmRsZXIgZm9yIHRoaXMgbWV0aG9kIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCAobXVzdCBjYWxsIHVucmVnaXN0ZXJScGNNZXRob2QgZmlyc3QpXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiByb29tLmxvY2FsUGFydGljaXBhbnQ/LnJlZ2lzdGVyUnBjTWV0aG9kKFxyXG4gICAqICAgJ2dyZWV0JyxcclxuICAgKiAgIGFzeW5jIChkYXRhOiBScGNJbnZvY2F0aW9uRGF0YSkgPT4ge1xyXG4gICAqICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgZ3JlZXRpbmcgZnJvbSAke2RhdGEuY2FsbGVySWRlbnRpdHl9OiAke2RhdGEucGF5bG9hZH1gKTtcclxuICAgKiAgICAgcmV0dXJuIGBIZWxsbywgJHtkYXRhLmNhbGxlcklkZW50aXR5fSFgO1xyXG4gICAqICAgfVxyXG4gICAqICk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxyXG4gICAqIElmIHVuYWJsZSB0byByZXNwb25kIHdpdGhpbiBgcmVzcG9uc2VUaW1lb3V0YCwgdGhlIHJlcXVlc3Qgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3Igb24gdGhlIGNhbGxlcidzIHNpZGUuXHJcbiAgICpcclxuICAgKiBZb3UgbWF5IHRocm93IGVycm9ycyBvZiB0eXBlIGBScGNFcnJvcmAgd2l0aCBhIHN0cmluZyBgbWVzc2FnZWAgaW4gdGhlIGhhbmRsZXIsXHJcbiAgICogYW5kIHRoZXkgd2lsbCBiZSByZWNlaXZlZCBvbiB0aGUgY2FsbGVyJ3Mgc2lkZSB3aXRoIHRoZSBtZXNzYWdlIGludGFjdC5cclxuICAgKiBPdGhlciBlcnJvcnMgdGhyb3duIGluIHlvdXIgaGFuZGxlciB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCBhcy1pcywgYW5kIHdpbGwgaW5zdGVhZCBhcnJpdmUgdG8gdGhlIGNhbGxlciBhcyBgMTUwMGAgKFwiQXBwbGljYXRpb24gRXJyb3JcIikuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJScGNNZXRob2QobWV0aG9kLCBoYW5kbGVyKSB7XHJcbiAgICBpZiAodGhpcy5ycGNIYW5kbGVycy5oYXMobWV0aG9kKSkge1xyXG4gICAgICB0aHJvdyBFcnJvcihcIlJQQyBoYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kIFwiLmNvbmNhdChtZXRob2QsIFwiLCB1bnJlZ2lzdGVyUnBjTWV0aG9kIGJlZm9yZSB0cnlpbmcgdG8gcmVnaXN0ZXIgYWdhaW5cIikpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ycGNIYW5kbGVycy5zZXQobWV0aG9kLCBoYW5kbGVyKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVW5yZWdpc3RlcnMgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgUlBDIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbmFtZSBvZiB0aGUgUlBDIG1ldGhvZCB0byB1bnJlZ2lzdGVyXHJcbiAgICovXHJcbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcclxuICAgIHRoaXMucnBjSGFuZGxlcnMuZGVsZXRlKG1ldGhvZCk7XHJcbiAgfVxyXG4gIGhhbmRsZUluY29taW5nUnBjUmVxdWVzdChjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCwgdmVyc2lvbikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY0FjayhjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkKTtcclxuICAgICAgaWYgKHZlcnNpb24gIT09IDEpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgbnVsbCwgUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfVkVSU0lPTicpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucnBjSGFuZGxlcnMuZ2V0KG1ldGhvZCk7XHJcbiAgICAgIGlmICghaGFuZGxlcikge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBudWxsLCBScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9NRVRIT0QnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZXNwb25zZUVycm9yID0gbnVsbDtcclxuICAgICAgbGV0IHJlc3BvbnNlUGF5bG9hZCA9IG51bGw7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBoYW5kbGVyKHtcclxuICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgIGNhbGxlcklkZW50aXR5LFxyXG4gICAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICAgIHJlc3BvbnNlVGltZW91dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChieXRlTGVuZ3RoKHJlc3BvbnNlKSA+IE1BWF9QQVlMT0FEX0JZVEVTKSB7XHJcbiAgICAgICAgICByZXNwb25zZUVycm9yID0gUnBjRXJyb3IuYnVpbHRJbignUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UnKTtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcIlJQQyBSZXNwb25zZSBwYXlsb2FkIHRvbyBsYXJnZSBmb3IgXCIuY29uY2F0KG1ldGhvZCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXNwb25zZVBheWxvYWQgPSByZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUnBjRXJyb3IpIHtcclxuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgZXJyb3IgcmV0dXJuZWQgYnkgUlBDIGhhbmRsZXIgZm9yIFwiLmNvbmNhdChtZXRob2QsIFwiLiBSZXR1cm5pbmcgQVBQTElDQVRJT05fRVJST1IgaW5zdGVhZC5cIiksIGVycm9yKTtcclxuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBScGNFcnJvci5idWlsdEluKCdBUFBMSUNBVElPTl9FUlJPUicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjUmVzcG9uc2UoY2FsbGVySWRlbnRpdHksIHJlcXVlc3RJZCwgcmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICovXHJcbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEUyRUVFbmFibGVkKGVuYWJsZWQpXSk7XHJcbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcclxuICAgICAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkLCB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignZTJlZSBub3QgY29uZmlndXJlZCwgcGxlYXNlIHNldCBlMmVlIHNldHRpbmdzIHdpdGhpbiB0aGUgcm9vbSBvcHRpb25zJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXR1cEUyRUUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUpIHtcclxuICAgICAgaWYgKCdlMmVlTWFuYWdlcicgaW4gdGhpcy5vcHRpb25zLmUyZWUpIHtcclxuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gdGhpcy5vcHRpb25zLmUyZWUuZTJlZU1hbmFnZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlciA9IG5ldyBFMkVFTWFuYWdlcih0aGlzLm9wdGlvbnMuZTJlZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgKGVuYWJsZWQsIHBhcnRpY2lwYW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzTG9jYWxQYXJ0aWNpcGFudChwYXJ0aWNpcGFudCkpIHtcclxuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZW5hYmxlZCwgcGFydGljaXBhbnQpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvciA9PiB0aGlzLmVtaXQoUm9vbUV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IpKTtcclxuICAgICAgKF9hID0gdGhpcy5lMmVlTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldHVwKHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvb206IHRoaXMubmFtZSxcclxuICAgICAgcm9vbUlEOiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkLFxyXG4gICAgICBwYXJ0aWNpcGFudDogdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxyXG4gICAgICBwSUQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRcclxuICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGlmIHRoZSBjdXJyZW50IHJvb20gaGFzIGEgcGFydGljaXBhbnQgd2l0aCBgcmVjb3JkZXI6IHRydWVgIGluIGl0cyBKV1QgZ3JhbnRcclxuICAgKiovXHJcbiAgZ2V0IGlzUmVjb3JkaW5nKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlUmVjb3JkaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogc2VydmVyIGFzc2lnbmVkIHVuaXF1ZSByb29tIGlkLlxyXG4gICAqIHJldHVybnMgb25jZSBhIHNpZCBoYXMgYmVlbiBpc3N1ZWQgYnkgdGhlIHNlcnZlci5cclxuICAgKi9cclxuICBnZXRTaWQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5yb29tSW5mbyAmJiB0aGlzLnJvb21JbmZvLnNpZCAhPT0gJycpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb29tSW5mby5zaWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBoYW5kbGVSb29tVXBkYXRlID0gcm9vbUluZm8gPT4ge1xyXG4gICAgICAgICAgaWYgKHJvb21JbmZvLnNpZCAhPT0gJycpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xyXG4gICAgICAgICAgICByZXNvbHZlKHJvb21JbmZvLnNpZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcclxuICAgICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xyXG4gICAgICAgICAgcmVqZWN0KCdSb29tIGRpc2Nvbm5lY3RlZCBiZWZvcmUgcm9vbSBzZXJ2ZXIgaWQgd2FzIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiogdXNlciBhc3NpZ25lZCBuYW1lLCBkZXJpdmVkIGZyb20gSldUIHRva2VuICovXHJcbiAgZ2V0IG5hbWUoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcclxuICB9XHJcbiAgLyoqIHJvb20gbWV0YWRhdGEgKi9cclxuICBnZXQgbWV0YWRhdGEoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhO1xyXG4gIH1cclxuICBnZXQgbnVtUGFydGljaXBhbnRzKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gIH1cclxuICBnZXQgbnVtUHVibGlzaGVycygpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bVB1Ymxpc2hlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgfVxyXG4gIG1heWJlQ3JlYXRlRW5naW5lKCkge1xyXG4gICAgaWYgKHRoaXMuZW5naW5lICYmICF0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmVuZ2luZSA9IG5ldyBSVENFbmdpbmUodGhpcy5vcHRpb25zKTtcclxuICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcykub24oRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgdGhpcy5oYW5kbGVSb29tVXBkYXRlKS5vbihFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkKS5vbihFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHRoaXMuaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLCB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25FcnJvcikub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKS5vbihFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSA9PiB7XHJcbiAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xyXG4gICAgfSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24gPT4ge1xyXG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIHJlYXNvbik7XHJcbiAgICB9KS5vbihFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IHRydWU7XHJcbiAgICAgIHRoaXMubG9nLmluZm8oJ1Jlc3VtaW5nIHNpZ25hbCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuU2lnbmFsUmVjb25uZWN0aW5nKSkge1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsUmVjb25uZWN0aW5nKTtcclxuICAgICAgfVxyXG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdW1lZCwgKCkgPT4ge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xyXG4gICAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1lZCBzaWduYWwgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9ucygpO1xyXG4gICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xyXG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcclxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcpIHtcclxuICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZXN0YXJ0aW5nKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlU2lnbmFsUmVzdGFydGVkKS5vbihFbmdpbmVFdmVudC5PZmZsaW5lLCAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XHJcbiAgICAgIH1cclxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgKHN0YXR1cywga2luZCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRDQnVmZmVyU3RhdHVzQ2hhbmdlZCwgc3RhdHVzLCBraW5kKTtcclxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCBzdWJzY3JpYmVkU2lkID0+IHtcclxuICAgICAgY29uc3QgdHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpLmZpbmQoX3JlZjIgPT4ge1xyXG4gICAgICAgIGxldCB7XHJcbiAgICAgICAgICB0cmFja1NpZFxyXG4gICAgICAgIH0gPSBfcmVmMjtcclxuICAgICAgICByZXR1cm4gdHJhY2tTaWQgPT09IHN1YnNjcmliZWRTaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXRyYWNrUHVibGljYXRpb24pIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgZmluZCBsb2NhbCB0cmFjayBzdWJzY3JpcHRpb24gZm9yIHN1YnNjcmliZWQgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCB0cmFja1B1YmxpY2F0aW9uKTtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrUHVibGljYXRpb24sIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihFbmdpbmVFdmVudC5Sb29tTW92ZWQsIHJvb21Nb3ZlZCA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyb29tIG1vdmVkJywgcm9vbU1vdmVkKTtcclxuICAgICAgaWYgKHJvb21Nb3ZlZC5yb29tKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlKHJvb21Nb3ZlZC5yb29tKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCwgaWRlbnRpdHkpID0+IHtcclxuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1vdmVkLCByb29tTW92ZWQucm9vbS5uYW1lKTtcclxuICAgICAgaWYgKHJvb21Nb3ZlZC5wYXJ0aWNpcGFudCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKFtyb29tTW92ZWQucGFydGljaXBhbnQsIC4uLnJvb21Nb3ZlZC5vdGhlclBhcnRpY2lwYW50c10pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKHJvb21Nb3ZlZC5vdGhlclBhcnRpY2lwYW50cyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCkge1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcclxuICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGdldExvY2FsRGV2aWNlcyBhYnN0cmFjdHMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzLlxyXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IHJlcXVlc3RzIGRldmljZSBwZXJtaXNzaW9ucyBieSBkZWZhdWx0IGlmIG5lZWRlZFxyXG4gICAqIGFuZCBtYWtlcyBzdXJlIHRoZSByZXR1cm5lZCBkZXZpY2UgZG9lcyBub3QgY29uc2lzdCBvZiBkdW1teSBkZXZpY2VzXHJcbiAgICogQHBhcmFtIGtpbmRcclxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGxvY2FsIGRldmljZXNcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0TG9jYWxEZXZpY2VzKGtpbmQpIHtcclxuICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XHJcbiAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXMoa2luZCwgcmVxdWVzdFBlcm1pc3Npb25zKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogcHJlcGFyZUNvbm5lY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIGxvYWRlZCwgaW4gb3JkZXJcclxuICAgKiB0byBzcGVlZCB1cCB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBUaGlzIGZ1bmN0aW9uIHdpbGxcclxuICAgKiAtIHBlcmZvcm0gRE5TIHJlc29sdXRpb24gYW5kIHByZS13YXJtIHRoZSBETlMgY2FjaGVcclxuICAgKiAtIGVzdGFibGlzaCBUTFMgY29ubmVjdGlvbiBhbmQgY2FjaGUgVExTIGtleXNcclxuICAgKlxyXG4gICAqIFdpdGggTGl2ZUtpdCBDbG91ZCwgaXQgd2lsbCBhbHNvIGRldGVybWluZSB0aGUgYmVzdCBlZGdlIGRhdGEgY2VudGVyIGZvclxyXG4gICAqIHRoZSBjdXJyZW50IGNsaWVudCB0byBjb25uZWN0IHRvIGlmIGEgdG9rZW4gaXMgcHJvdmlkZWQuXHJcbiAgICovXHJcbiAgcHJlcGFyZUNvbm5lY3Rpb24odXJsLCB0b2tlbikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlQ29ubmVjdGlvbiB0byBcIi5jb25jYXQodXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpICYmIHRva2VuKSB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xyXG4gICAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xyXG4gICAgICAgICAgLy8gd2Ugd2lsbCBub3QgcmVwbGFjZSB0aGUgcmVnaW9uVXJsIGlmIGFuIGF0dGVtcHQgaGFkIGFscmVhZHkgc3RhcnRlZFxyXG4gICAgICAgICAgLy8gdG8gYXZvaWQgb3ZlcnJpZGluZyByZWdpb25VcmwgYWZ0ZXIgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGhhZCBzdGFydGVkXHJcbiAgICAgICAgICBpZiAocmVnaW9uVXJsICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb25VcmwgPSByZWdpb25Vcmw7XHJcbiAgICAgICAgICAgIHlpZWxkIGZldGNoKHRvSHR0cFVybChyZWdpb25VcmwpLCB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJlcGFyZWQgY29ubmVjdGlvbiB0byBcIi5jb25jYXQocmVnaW9uVXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHVybCksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwcmVwYXJlIGNvbm5lY3Rpb24nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogcmV0cmlldmVzIGEgcGFydGljaXBhbnQgYnkgaWRlbnRpdHlcclxuICAgKiBAcGFyYW0gaWRlbnRpdHlcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xyXG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gaWRlbnRpdHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xyXG4gIH1cclxuICBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xyXG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWwgZm9yIHRlc3RpbmdcclxuICAgKi9cclxuICBzaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvLCBhcmcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGxldCBwb3N0QWN0aW9uID0gKCkgPT4ge307XHJcbiAgICAgIGxldCByZXE7XHJcbiAgICAgIHN3aXRjaCAoc2NlbmFyaW8pIHtcclxuICAgICAgICBjYXNlICdzaWduYWwtcmVjb25uZWN0JzpcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxyXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGRpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NwZWFrZXInOlxyXG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xyXG4gICAgICAgICAgICBzY2VuYXJpbzoge1xyXG4gICAgICAgICAgICAgIGNhc2U6ICdzcGVha2VyVXBkYXRlJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogM1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ25vZGUtZmFpbHVyZSc6XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ25vZGVGYWlsdXJlJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NlcnZlci1sZWF2ZSc6XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ3NlcnZlckxlYXZlJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ21pZ3JhdGlvbic6XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ21pZ3JhdGlvbicsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyZXN1bWUtcmVjb25uZWN0JzpcclxuICAgICAgICAgIHRoaXMuZW5naW5lLmZhaWxOZXh0KCk7XHJcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcclxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGlzY29ubmVjdC1zaWduYWwtb24tcmVzdW1lJzpcclxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xyXG4gICAgICAgICAgICBzY2VuYXJpbzoge1xyXG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWUnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZGlzY29ubmVjdC1zaWduYWwtb24tcmVzdW1lLW5vLW1lc3NhZ2VzJzpcclxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xyXG4gICAgICAgICAgICBzY2VuYXJpbzoge1xyXG4gICAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWVOb01lc3NhZ2VzJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2Z1bGwtcmVjb25uZWN0JzpcclxuICAgICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xyXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZnVsbC1yZWNvbm5lY3QnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2ZvcmNlLXRjcCc6XHJcbiAgICAgICAgY2FzZSAnZm9yY2UtdGxzJzpcclxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcclxuICAgICAgICAgICAgc2NlbmFyaW86IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnc3dpdGNoQ2FuZGlkYXRlUHJvdG9jb2wnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHBvc3RBY3Rpb24gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uTGVhdmUgPSB0aGlzLmVuZ2luZS5jbGllbnQub25MZWF2ZTtcclxuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcclxuICAgICAgICAgICAgICBvbkxlYXZlKG5ldyBMZWF2ZVJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246IExlYXZlUmVxdWVzdF9BY3Rpb24uUkVDT05ORUNUXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZXItYmFuZHdpZHRoJzpcclxuICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgYXJnICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ3N1YnNjcmliZXJCYW5kd2lkdGgnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBudW1iZXJUb0JpZ0ludChhcmcpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbGVhdmUtZnVsbC1yZWNvbm5lY3QnOlxyXG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xyXG4gICAgICAgICAgICBzY2VuYXJpbzoge1xyXG4gICAgICAgICAgICAgIGNhc2U6ICdsZWF2ZVJlcXVlc3RGdWxsUmVjb25uZWN0JyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmVxKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRTaW11bGF0ZVNjZW5hcmlvKHJlcSk7XHJcbiAgICAgICAgeWllbGQgcG9zdEFjdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIGVuYWJsZWRcclxuICAgKi9cclxuICBnZXQgY2FuUGxheWJhY2tBdWRpbygpIHtcclxuICAgIHJldHVybiB0aGlzLmF1ZGlvRW5hYmxlZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcclxuICAgKi9cclxuICBnZXQgY2FuUGxheWJhY2tWaWRlbygpIHtcclxuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xyXG4gIH1cclxuICBnZXRBY3RpdmVEZXZpY2Uoa2luZCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTd2l0Y2hlcyBhbGwgYWN0aXZlIGRldmljZXMgdXNlZCBpbiB0aGlzIHJvb20gdG8gdGhlIGdpdmVuIGRldmljZS5cclxuICAgKlxyXG4gICAqIE5vdGU6IHNldHRpbmcgQXVkaW9PdXRwdXQgaXMgbm90IHN1cHBvcnRlZCBvbiBzb21lIGJyb3dzZXJzLiBTZWUgW3NldFNpbmtJZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvc2V0U2lua0lkI2Jyb3dzZXJfY29tcGF0aWJpbGl0eSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcclxuICAgKiAgYGF1ZGlvaW5wdXRgIGZvciBtaWNyb3Bob25lIHRyYWNrLFxyXG4gICAqICBgYXVkaW9vdXRwdXRgIHRvIHNldCBzcGVha2VyIGZvciBhbGwgaW5jb21pbmcgYXVkaW8gdHJhY2tzXHJcbiAgICogQHBhcmFtIGRldmljZUlkXHJcbiAgICovXHJcbiAgc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmRfMSwgZGV2aWNlSWRfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGtpbmQsIGRldmljZUlkKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xyXG4gICAgICBsZXQgZXhhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcclxuICAgICAgICB2YXIgX2g7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgIGxldCBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBkZXZpY2VDb25zdHJhaW50ID0gZXhhY3QgPyB7XHJcbiAgICAgICAgICBleGFjdDogZGV2aWNlSWRcclxuICAgICAgICB9IDogZGV2aWNlSWQ7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xyXG4gICAgICAgICAgbmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzID0gX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xyXG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9hID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XHJcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcclxuICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHQuYXVkaW9UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpO1xyXG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xyXG4gICAgICAgICAgbmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzID0gX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xyXG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9iID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XHJcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCA9IGRldmljZUNvbnN0cmFpbnQ7XHJcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3VjY2VzcyA9ICh5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHQgPT4ge1xyXG4gICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XHJcbiAgICAgICAgICAgIH0pKSkuZXZlcnkodmFsID0+IHZhbCA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xyXG4gICAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZCgpICYmICFfdGhpczMub3B0aW9ucy53ZWJBdWRpb01peCB8fCBfdGhpczMub3B0aW9ucy53ZWJBdWRpb01peCAmJiBfdGhpczMuYXVkaW9Db250ZXh0ICYmICEoJ3NldFNpbmtJZCcgaW4gX3RoaXMzLmF1ZGlvQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIGF1ZGlvIG91dHB1dCwgc2V0U2lua0lkIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy53ZWJBdWRpb01peCkge1xyXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBkZWZhdWx0YCBmb3Igd2ViIGF1ZGlvIG91dHB1dCBkb2Vzbid0IHdvcmssIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIHRoZSBpZCBiZWZvcmVcclxuICAgICAgICAgICAgZGV2aWNlSWQgPSAoX2MgPSB5aWVsZCBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkubm9ybWFsaXplRGV2aWNlSWQoJ2F1ZGlvb3V0cHV0JywgZGV2aWNlSWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIChfZCA9IChfaCA9IF90aGlzMy5vcHRpb25zKS5hdWRpb091dHB1dCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogX2guYXVkaW9PdXRwdXQgPSB7fTtcclxuICAgICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IChfZSA9IF90aGlzMy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkO1xyXG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBkZXZpY2VJZDtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy53ZWJBdWRpb01peCkge1xyXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2V0U2lua0lkIGlzIG5vdCB5ZXQgaW4gdGhlIHR5cGVzY3JpcHQgdHlwZSBvZiBBdWRpb0NvbnRleHRcclxuICAgICAgICAgICAgICAoX2YgPSBfdGhpczMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc2V0U2lua0lkKGRldmljZUlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIHNldCBhdWRpbyBvdXRwdXQgb24gYWxsIGF1ZGlvIGVsZW1lbnRzLCBldmVuIGlmIHdlYkF1ZGlvTWl4IGlzIGVuYWJsZWQgaW4gb3JkZXIgdG8gd29ya2Fyb3VuZCBlY2hvIGNhbmNlbGxhdGlvbiBub3Qgd29ya2luZyBvbiBjaHJvbWUgd2l0aCBub24tZGVmYXVsdCBvdXRwdXQgZGV2aWNlc1xyXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MDI1MjkxMSNjb21tZW50N1xyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChBcnJheS5mcm9tKF90aGlzMy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcChwID0+IHAuc2V0QXVkaW9PdXRwdXQoe1xyXG4gICAgICAgICAgICAgIGRldmljZUlkXHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkID0gcHJldkRldmljZUlkO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzIHx8IGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBub3QgYWN0aXZlIHRyYWNrcyB5ZXQgb3Igd2UncmUgc3dpdGNoaW5nIGF1ZGlvb3V0cHV0LCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGUgYWN0aXZlIGRldmljZSBtYXAgaGVyZSBhcyBjaGFuZ2luZyBhdWRpbyBvdXRwdXQgd29uJ3QgcmVzdWx0IGluIGEgdHJhY2sgcmVzdGFydFxyXG4gICAgICAgICAgX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldChraW5kLCBraW5kID09PSAnYXVkaW9vdXRwdXQnICYmICgoX2cgPSBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmRldmljZUlkKSB8fCBkZXZpY2VJZCk7XHJcbiAgICAgICAgICBfdGhpczMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwga2luZCwgZGV2aWNlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VjY2VzcztcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldHVwTG9jYWxQYXJ0aWNpcGFudEV2ZW50cygpIHtcclxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub24oUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XHJcbiAgfVxyXG4gIHJlY3JlYXRlRW5naW5lKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xyXG4gICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcclxuICAgIC8vIGNsZWFyIG91dCBleGlzdGluZyByZW1vdGUgcGFydGljaXBhbnRzLCBzaW5jZSB0aGV5IG1heSBoYXZlIGF0dGFjaGVkXHJcbiAgICAvLyB0aGUgb2xkIGVuZ2luZVxyXG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuY2xlYXIoKTtcclxuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5jbGVhcigpO1xyXG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xyXG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xyXG4gIH1cclxuICBvblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikge1xyXG4gICAgLy8gZG9uJ3QgZmlyZSBvblN1YnNjcmliZWQgd2hlbiBjb25uZWN0aW5nXHJcbiAgICAvLyBXZWJSVEMgZmlyZXMgb25UcmFjayBhcyBzb29uIGFzIHNldFJlbW90ZURlc2NyaXB0aW9uIGlzIGNhbGxlZCBvbiB0aGUgb2ZmZXJcclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxyXG4gICAgLy8gdGVjaG5pY2FsbHkgc3Vic2NyaWJlZC5cclxuICAgIC8vIFdlJ2xsIGRlZmVyIHRoZXNlIGV2ZW50cyB1bnRpbCB3aGVuIHRoZSByb29tIGlzIGNvbm5lY3RlZCBvciBldmVudHVhbGx5IGRpc2Nvbm5lY3RlZC5cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XHJcbiAgICAgIGNvbnN0IHJlY29ubmVjdGVkSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcclxuICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuUmVjb25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XHJcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xyXG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3NraXBwaW5nIGluY29taW5nIHRyYWNrIGFmdGVyIFJvb20gZGlzY29ubmVjdGVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xyXG4gICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhcyBpdCBhbHJlYWR5IGVuZGVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xyXG4gICAgY29uc3QgcGFydGljaXBhbnRTaWQgPSBwYXJ0c1swXTtcclxuICAgIGxldCBzdHJlYW1JZCA9IHBhcnRzWzFdO1xyXG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xyXG4gICAgLy8gZmlyZWZveCB3aWxsIGdldCBzdHJlYW1JZCAocElEfHRyYWNrSWQpIGluc3RlYWQgb2YgKHBJRHxzdHJlYW1JZCkgYXMgaXQgZG9lc24ndCBzdXBwb3J0IHN5bmMgdHJhY2tzIGJ5IHN0cmVhbVxyXG4gICAgLy8gYW5kIGdlbmVyYXRlcyBpdHMgb3duIHRyYWNrIGlkIGluc3RlYWQgb2YgaW5mZXIgZnJvbSBzZHAgdHJhY2sgaWQuXHJcbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xyXG4gICAgaWYgKHBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3RyaWVkIHRvIGNyZWF0ZSBSZW1vdGVQYXJ0aWNpcGFudCBmb3IgbG9jYWwgcGFydGljaXBhbnQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnNpZCA9PT0gcGFydGljaXBhbnRTaWQpO1xyXG4gICAgaWYgKCFwYXJ0aWNpcGFudCkge1xyXG4gICAgICB0aGlzLmxvZy5lcnJvcihcIlRyaWVkIHRvIGFkZCBhIHRyYWNrIGZvciBhIHBhcnRpY2lwYW50LCB0aGF0J3Mgbm90IHByZXNlbnQuIFNpZDogXCIuY29uY2F0KHBhcnRpY2lwYW50U2lkKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJ0aWNpcGFudC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhtZWRpYVRyYWNrLCB0cmFja0lkLCBzdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcclxuICB9XHJcbiAgaGFuZGxlRGlzY29ubmVjdCgpIHtcclxuICAgIGxldCBzaG91bGRTdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcclxuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xyXG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcy5jbGVhcigpO1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgIHAudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xyXG4gICAgICAgICAgcC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2tTaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAocHViLnRyYWNrKSB7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHViLnRyYWNrLCBzaG91bGRTdG9wVHJhY2tzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFN0b3BUcmFja3MpIHtcclxuICAgICAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldGFjaCgpO1xyXG4gICAgICAgICAgKF9iID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAoX2MgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdG9wTW9uaXRvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vZmYoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkLCB0aGlzLnN0YXJ0QXVkaW8pLm9mZihQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCB0aGlzLm9uTG9jYWxDaGF0TWVzc2FnZVNlbnQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xyXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xyXG4gICAgICB0aGlzLnNpZFRvSWRlbnRpdHkuY2xlYXIoKTtcclxuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xyXG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XHJcbiAgICAgICAgKF9hID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlKTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaWRlbnRpdHksIHBhcnRpY2lwYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyByZW1vdmUgYW5kIHNlbmQgZXZlbnRcclxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmRlbGV0ZShpZGVudGl0eSk7XHJcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xyXG4gICAgICBwYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWJsaWNhdGlvbi50cmFja1NpZCwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcclxuICAgIHBhcnRpY2lwYW50LnNldERpc2Nvbm5lY3RlZCgpO1xyXG4gICAgKF9hID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocGFydGljaXBhbnQuaWRlbnRpdHkpO1xyXG4gIH1cclxuICBoYW5kbGVTdHJlYW1IZWFkZXIoc3RyZWFtSGVhZGVyLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmIChzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci5jYXNlID09PSAnYnl0ZUhlYWRlcicpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sgPSB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5nZXQoc3RyZWFtSGVhZGVyLnRvcGljKTtcclxuICAgICAgICBpZiAoIXN0cmVhbUhhbmRsZXJDYWxsYmFjaykge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2lnbm9yaW5nIGluY29taW5nIGJ5dGUgc3RyZWFtIGR1ZSB0byBubyBoYW5kbGVyIGZvciB0b3BpYycsIHN0cmVhbUhlYWRlci50b3BpYyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICBpZDogc3RyZWFtSGVhZGVyLnN0cmVhbUlkLFxyXG4gICAgICAgICAgbmFtZTogKF9hID0gc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIudmFsdWUubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3Vua25vd24nLFxyXG4gICAgICAgICAgbWltZVR5cGU6IHN0cmVhbUhlYWRlci5taW1lVHlwZSxcclxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgdG9waWM6IHN0cmVhbUhlYWRlci50b3BpYyxcclxuICAgICAgICAgIHRpbWVzdGFtcDogYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcclxuICAgICAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcclxuICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcclxuICAgICAgICAgICAgICBpbmZvLFxyXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXHJcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhuZXcgQnl0ZVN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkpLCB7XHJcbiAgICAgICAgICBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLmNhc2UgPT09ICd0ZXh0SGVhZGVyJykge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUhhbmRsZXJDYWxsYmFjayA9IHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmdldChzdHJlYW1IZWFkZXIudG9waWMpO1xyXG4gICAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnaWdub3JpbmcgaW5jb21pbmcgdGV4dCBzdHJlYW0gZHVlIHRvIG5vIGhhbmRsZXIgZm9yIHRvcGljJywgc3RyZWFtSGVhZGVyLnRvcGljKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXI7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgIGlkOiBzdHJlYW1IZWFkZXIuc3RyZWFtSWQsXHJcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxyXG4gICAgICAgICAgc2l6ZTogc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoID8gTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB0b3BpYzogc3RyZWFtSGVhZGVyLnRvcGljLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXHJcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcclxuICAgICAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcclxuICAgICAgICAgICAgc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcclxuICAgICAgICAgICAgICBpbmZvLFxyXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXHJcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhuZXcgVGV4dFN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkpLCB7XHJcbiAgICAgICAgICBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaGFuZGxlU3RyZWFtQ2h1bmsoY2h1bmspIHtcclxuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5nZXQoY2h1bmsuc3RyZWFtSWQpO1xyXG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcclxuICAgICAgaWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZpbGVCdWZmZXIuY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgdGV4dEJ1ZmZlciA9IHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XHJcbiAgICBpZiAodGV4dEJ1ZmZlcikge1xyXG4gICAgICBpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZVN0cmVhbVRyYWlsZXIodHJhaWxlcikge1xyXG4gICAgY29uc3QgdGV4dEJ1ZmZlciA9IHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcclxuICAgIGlmICh0ZXh0QnVmZmVyKSB7XHJcbiAgICAgIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0ZXh0QnVmZmVyLmluZm8uYXR0cmlidXRlcyksIHRyYWlsZXIuYXR0cmlidXRlcyk7XHJcbiAgICAgIHRleHRCdWZmZXIuY29udHJvbGxlci5jbG9zZSgpO1xyXG4gICAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5kZWxldGUodHJhaWxlci5zdHJlYW1JZCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWxlQnVmZmVyID0gdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMuZ2V0KHRyYWlsZXIuc3RyZWFtSWQpO1xyXG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcclxuICAgICAge1xyXG4gICAgICAgIGZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWxlQnVmZmVyLmluZm8uYXR0cmlidXRlcyksIHRyYWlsZXIuYXR0cmlidXRlcyk7XHJcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMuZGVsZXRlKHRyYWlsZXIuc3RyZWFtSWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGF0dGVtcHQgdG8gc2VsZWN0IHRoZSBkZWZhdWx0IGRldmljZXMgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgZGV2aWNlcyBhcmUgbm8gbG9uZ2VyIGF2YWlsYWJsZSBhZnRlciBhIGRldmljZSBjaGFuZ2UgZXZlbnRcclxuICAgKi9cclxuICBzZWxlY3REZWZhdWx0RGV2aWNlcygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICBjb25zdCBwcmV2aW91c0RldmljZXMgPSBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkucHJldmlvdXNEZXZpY2VzO1xyXG4gICAgICAvLyBjaGVjayBmb3IgYXZhaWxhYmxlIGRldmljZXMsIGJ1dCBkb24ndCByZXF1ZXN0IHBlcm1pc3Npb25zIGluIG9yZGVyIHRvIGF2b2lkIHByb21wdHMgZm9yIGtpbmRzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgYmVmb3JlXHJcbiAgICAgIGNvbnN0IGF2YWlsYWJsZURldmljZXMgPSB5aWVsZCBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyh1bmRlZmluZWQsIGZhbHNlKTtcclxuICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGJyb3dzZXIub3MgIT09ICdpT1MnKSB7XHJcbiAgICAgICAgZm9yIChsZXQgYXZhaWxhYmxlRGV2aWNlIG9mIGF2YWlsYWJsZURldmljZXMpIHtcclxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzRGV2aWNlID0gcHJldmlvdXNEZXZpY2VzLmZpbmQoaW5mbyA9PiBpbmZvLmRldmljZUlkID09PSBhdmFpbGFibGVEZXZpY2UuZGV2aWNlSWQpO1xyXG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV2aWNlICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSAnJyAmJiBwcmV2aW91c0RldmljZS5raW5kID09PSBhdmFpbGFibGVEZXZpY2Uua2luZCAmJiBwcmV2aW91c0RldmljZS5sYWJlbCAhPT0gYXZhaWxhYmxlRGV2aWNlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIGxhYmVsIGhhcyBjaGFuZ2VkIG9uIGRldmljZSB0aGUgc2FtZSBkZXZpY2VJZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBkZWZhdWx0IGRldmljZSBoYXMgY2hhbmdlZCBvbiB0aGUgT1MgbGV2ZWxcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGF2YWlsYWJsZURldmljZS5raW5kKSA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgLy8gZW1pdCBhbiBhY3RpdmUgZGV2aWNlIGNoYW5nZSBldmVudCBvbmx5IGlmIHRoZSBzZWxlY3RlZCBvdXRwdXQgZGV2aWNlIGlzIGFjdHVhbGx5IG9uIGBkZWZhdWx0YFxyXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgYXZhaWxhYmxlRGV2aWNlLmtpbmQsIGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qga2luZHMgPSBbJ2F1ZGlvb3V0cHV0JywgJ2F1ZGlvaW5wdXQnLCAndmlkZW9pbnB1dCddO1xyXG4gICAgICBmb3IgKGxldCBraW5kIG9mIGtpbmRzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U291cmNlID0ga2luZFRvU291cmNlKGtpbmQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFB1YmxpY2F0aW9uID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb24odGFyZ2V0U291cmNlKTtcclxuICAgICAgICBpZiAodGFyZ2V0UHVibGljYXRpb24gJiYgKChfYSA9IHRhcmdldFB1YmxpY2F0aW9uLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVc2VyUHJvdmlkZWQpKSB7XHJcbiAgICAgICAgICAvLyBpZiB0aGUgdHJhY2sgaXMgdXNlciBwcm92aWRlZCwgd2UgZG9uJ3Qgd2FudCB0byBzd2l0Y2ggZGV2aWNlcyBvbiBiZWhhbGYgb2YgdGhlIHVzZXJcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZXZpY2VzT2ZLaW5kID0gYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09IGtpbmQpO1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZURldmljZSA9IHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpO1xyXG4gICAgICAgIGlmIChhY3RpdmVEZXZpY2UgPT09ICgoX2IgPSBwcmV2aW91c0RldmljZXMuZmlsdGVyKGluZm8gPT4gaW5mby5raW5kID09PSBraW5kKVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSkge1xyXG4gICAgICAgICAgLy8gaW4gIFNhZmFyaSB0aGUgZmlyc3QgZGV2aWNlIGlzIGFsd2F5cyB0aGUgZGVmYXVsdCwgc28gd2UgYXNzdW1lIGEgdXNlciBvbiB0aGUgZGVmYXVsdCBkZXZpY2Ugd291bGQgbGlrZSB0byBzd2l0Y2ggdG8gdGhlIGRlZmF1bHQgb25jZSBpdCBjaGFuZ2VzXHJcbiAgICAgICAgICAvLyBGRiBkb2Vzbid0IGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgZGVmYXVsdCBkZXZpY2UgY2hhbmdlcywgc28gd2UgcGVyZm9ybSB0aGUgc2FtZSBiZXN0IGVmZm9ydCBhbmQgc3dpdGNoIHRvIHRoZSBuZXcgZGV2aWNlIG9uY2UgY29ubmVjdGVkIGFuZCBpZiBpdCdzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgIGlmIChkZXZpY2VzT2ZLaW5kLmxlbmd0aCA+IDAgJiYgKChfYyA9IGRldmljZXNPZktpbmRbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZXZpY2VJZCkgIT09IGFjdGl2ZURldmljZSkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcgJiYgIWlzU2FmYXJpQmFzZWQoKSB8fCBraW5kID09PSAndmlkZW9pbnB1dCcpIHtcclxuICAgICAgICAgIC8vIGFpcnBvZHMgb24gU2FmYXJpIG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgYXVkaW9pbnB1dCBhcyB0aGUgdHJhY2sgZG9lc24ndCBlbmQgYXMgc29vbiBhcyB5b3UgdGFrZSB0aGVtIG91dFxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN3aXRjaCB0byBmaXJzdCBhdmFpbGFibGUgZGV2aWNlIGlmIHByZXZpb3VzbHkgYWN0aXZlIGRldmljZSBpcyBub3QgYXZhaWxhYmxlIGFueSBtb3JlXHJcbiAgICAgICAgaWYgKGRldmljZXNPZktpbmQubGVuZ3RoID4gMCAmJiAhZGV2aWNlc09mS2luZC5maW5kKGRldmljZUluZm8gPT4gZGV2aWNlSW5mby5kZXZpY2VJZCA9PT0gdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkpICYmIChcclxuICAgICAgICAvLyBhdm9pZCBzd2l0Y2hpbmcgYXVkaW8gb3V0cHV0IG9uIHNhZmFyaSB3aXRob3V0IGV4cGxpY2l0IHVzZXIgYWN0aW9uIGFzIGl0IGxlYWRzIHRvIHNsb3dlZCBkb3duIGF1ZGlvIHBsYXliYWNrXHJcbiAgICAgICAga2luZCAhPT0gJ2F1ZGlvb3V0cHV0JyB8fCAhaXNTYWZhcmlCYXNlZCgpKSkge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZCwgZGV2aWNlc09mS2luZFswXS5kZXZpY2VJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWNxdWlyZUF1ZGlvQ29udGV4dCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiYgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIGF1ZGlvIGNvbnRleHQgd2l0aCBjdXN0b20gYXVkaW8gY29udGV4dCBpZiBzdXBwbGllZCBieSB1c2VyXHJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXguYXVkaW9Db250ZXh0O1xyXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvQ29udGV4dCB8fCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAvLyBieSB1c2luZyBhbiBBdWRpb0NvbnRleHQsIGl0IHJlZHVjZXMgbGFnIG9uIGF1ZGlvIGVsZW1lbnRzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTgxMTQyOS9odG1sNS1hdWRpby10YWctb24tc2FmYXJpLWhhcy1hLWRlbGF5LzU0MTE5ODU0IzU0MTE5ODU0XHJcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSAoX2EgPSBnZXROZXdBdWRpb0NvbnRleHQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcclxuICAgICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHBhcnRpY2lwYW50ID0+IHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xyXG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdGhpcy5hdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XHJcbiAgICAgICAgLy8gZm9yIGlPUyBhIG5ld2x5IGNyZWF0ZWQgQXVkaW9Db250ZXh0IGlzIGFsd2F5cyBpbiBgc3VzcGVuZGVkYCBzdGF0ZS5cclxuICAgICAgICAvLyB3ZSB0cnkgb3VyIGJlc3QgdG8gcmVzdW1lIHRoZSBjb250ZXh0IGhlcmUsIGlmIHRoYXQgZG9lc24ndCB3b3JrLCB3ZSBqdXN0IGNvbnRpbnVlIHdpdGggcmVndWxhciBwcm9jZXNzaW5nXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbdGhpcy5hdWRpb0NvbnRleHQucmVzdW1lKCksIHNsZWVwKDIwMCldKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV3Q29udGV4dElzUnVubmluZyA9ICgoX2IgPSB0aGlzLmF1ZGlvQ29udGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlKSA9PT0gJ3J1bm5pbmcnO1xyXG4gICAgICBpZiAobmV3Q29udGV4dElzUnVubmluZyAhPT0gdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XHJcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBuZXdDb250ZXh0SXNSdW5uaW5nO1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIG5ld0NvbnRleHRJc1J1bm5pbmcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pIHtcclxuICAgIHZhciBfYTtcclxuICAgIGxldCBwYXJ0aWNpcGFudDtcclxuICAgIGlmIChpbmZvKSB7XHJcbiAgICAgIHBhcnRpY2lwYW50ID0gUmVtb3RlUGFydGljaXBhbnQuZnJvbVBhcnRpY2lwYW50SW5mbyh0aGlzLmVuZ2luZS5jbGllbnQsIGluZm8sIHtcclxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcclxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcnRpY2lwYW50ID0gbmV3IFJlbW90ZVBhcnRpY2lwYW50KHRoaXMuZW5naW5lLmNsaWVudCwgJycsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XHJcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXHJcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XHJcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKF9hID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlSWQpIHtcclxuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9PdXRwdXQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xyXG4gIH1cclxuICBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkZW50aXR5LCBpbmZvKSB7XHJcbiAgICBpZiAodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuaGFzKGlkZW50aXR5KSkge1xyXG4gICAgICBjb25zdCBleGlzdGluZ1BhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcclxuICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICBjb25zdCB3YXNVcGRhdGVkID0gZXhpc3RpbmdQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xyXG4gICAgICAgIGlmICh3YXNVcGRhdGVkKSB7XHJcbiAgICAgICAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGV4aXN0aW5nUGFydGljaXBhbnQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pO1xyXG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuc2V0KGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XHJcbiAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcclxuICAgIC8vIGlmIHdlIGhhdmUgdmFsaWQgaW5mbyBhbmQgdGhlIHBhcnRpY2lwYW50IHdhc24ndCBpbiB0aGUgbWFwIGJlZm9yZSwgd2UgY2FuIGFzc3VtZSB0aGUgcGFydGljaXBhbnQgaXMgbmV3XHJcbiAgICAvLyBmaXJpbmcgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBgUGFydGljaXBhbnRDb25uZWN0ZWRgIGZpcmVzIGJlZm9yZSB0aGUgaW5pdGlhbCB0cmFjayBldmVudHNcclxuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XHJcbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXHJcbiAgICAvLyB0cmFja1B1Ymxpc2hlZCBpcyBvbmx5IGZpcmVkIGZvciB0cmFja3MgYWRkZWQgYWZ0ZXIgYm90aCBsb2NhbCBwYXJ0aWNpcGFudFxyXG4gICAgLy8gYW5kIHJlbW90ZSBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb21cclxuICAgIHBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24gPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgdHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHVibGljYXRpb24pID0+IHtcclxuICAgICAgLy8gbW9uaXRvciBwbGF5YmFjayBzdGF0dXNcclxuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcclxuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKTtcclxuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKTtcclxuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tTdGFydGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHViID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHViID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBjaGFuZ2VkQXR0cmlidXRlcyA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCAodHJhY2tTaWQsIGVycm9yKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHRyYWNrU2lkLCBwYXJ0aWNpcGFudCwgZXJyb3IpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHViLCBzdGF0dXMsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQWN0aXZlLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50QWN0aXZlLCBwYXJ0aWNpcGFudCk7XHJcbiAgICAgIGlmIChwYXJ0aWNpcGFudC5raW5kID09PSBQYXJ0aWNpcGFudEluZm9fS2luZC5BR0VOVCkge1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBY3RpdmVBZ2VudChwYXJ0aWNpcGFudCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gdXBkYXRlIGluZm8gYXQgdGhlIGVuZCBhZnRlciBjYWxsYmFja3MgaGF2ZSBiZWVuIHNldCB1cFxyXG4gICAgaWYgKGluZm8pIHtcclxuICAgICAgcGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcclxuICB9XHJcbiAgc2VuZFN5bmNTdGF0ZSgpIHtcclxuICAgIGNvbnN0IHJlbW90ZVRyYWNrcyA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLnJlZHVjZSgoYWNjLCBwYXJ0aWNpcGFudCkgPT4ge1xyXG4gICAgICBhY2MucHVzaCguLi5wYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIFJlbW90ZVRyYWNrUHVibGljYXRpb25zIGRpcmVjdGx5IGluc3RlYWQgb2YgdGhlIHR5cGUgY2FzdFxyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIExvY2FsVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XHJcbiAgICB0aGlzLmVuZ2luZS5zZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBZnRlciByZXN1bWluZywgd2UnbGwgbmVlZCB0byBub3RpZnkgdGhlIHNlcnZlciBvZiB0aGUgY3VycmVudFxyXG4gICAqIHN1YnNjcmlwdGlvbiBzZXR0aW5ncy5cclxuICAgKi9cclxuICB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xyXG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgcHViIG9mIHAudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmIChwdWIuaXNTdWJzY3JpYmVkICYmIGlzUmVtb3RlUHViKHB1YikpIHtcclxuICAgICAgICAgIHB1Yi5lbWl0VHJhY2tVcGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzaWQpIHtcclxuICAgIGNvbnN0IGlkZW50aXR5ID0gdGhpcy5zaWRUb0lkZW50aXR5LmdldChzaWQpO1xyXG4gICAgaWYgKGlkZW50aXR5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XHJcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xyXG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xyXG4gICAgdGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGlmIChcclxuICAgICAgLy8gZW5zdXJlIHdlIGRpZG4ndCB0ZWFyIGl0IGRvd25cclxuICAgICAgIXRoaXMuZW5naW5lIHx8XHJcbiAgICAgIC8vIGVuZ2luZSBkZXRlY3RlZCBjbG9zZSwgYnV0IFJvb20gbWlzc2VkIGl0XHJcbiAgICAgIHRoaXMuZW5naW5lLmlzQ2xvc2VkIHx8XHJcbiAgICAgIC8vIHRyYW5zcG9ydHMgZmFpbGVkIHdpdGhvdXQgbm90aWZ5aW5nIGVuZ2luZVxyXG4gICAgICAhdGhpcy5lbmdpbmUudmVyaWZ5VHJhbnNwb3J0KCkpIHtcclxuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzKys7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignZGV0ZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZSBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgbnVtRmFpbHVyZXM6IGNvbnNlY3V0aXZlRmFpbHVyZXMsXHJcbiAgICAgICAgICBlbmdpbmU6IHRoaXMuZW5naW5lID8ge1xyXG4gICAgICAgICAgICBjbG9zZWQ6IHRoaXMuZW5naW5lLmlzQ2xvc2VkLFxyXG4gICAgICAgICAgICB0cmFuc3BvcnRzQ29ubmVjdGVkOiB0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKVxyXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoY29uc2VjdXRpdmVGYWlsdXJlcyA+PSAzKSB7XHJcbiAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcclxuICAgICAgfVxyXG4gICAgfSwgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSk7XHJcbiAgfVxyXG4gIGNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcclxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCkge1xyXG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xyXG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XHJcbiAgICAgIC8vIHVuY2hhbmdlZFxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHRoaXMuc3RhdGUpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGVtaXRCdWZmZXJlZEV2ZW50cygpIHtcclxuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMuZm9yRWFjaChfcmVmMyA9PiB7XHJcbiAgICAgIGxldCBbZXYsIGFyZ3NdID0gX3JlZjM7XHJcbiAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcclxuICB9XHJcbiAgZW1pdFdoZW5Db25uZWN0ZWQoZXZlbnQpIHtcclxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcgfHwgIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLnBlbmRpbmdSZWNvbm5lY3QpIHtcclxuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxyXG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLnB1c2goW2V2ZW50LCBhcmdzXSk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFsbG93cyB0byBwb3B1bGF0ZSBhIHJvb20gd2l0aCBzaW11bGF0ZWQgcGFydGljaXBhbnRzLlxyXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xyXG4gICAqIEBleHBlcmltZW50YWxcclxuICAgKi9cclxuICBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgIHZpZGVvOiB0cnVlLFxyXG4gICAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlXHJcbiAgICAgIH0sIG9wdGlvbnMucHVibGlzaCk7XHJcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGNvdW50OiA5LFxyXG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcclxuICAgICAgICB2aWRlbzogdHJ1ZSxcclxuICAgICAgICBhc3BlY3RSYXRpb3M6IFsxLjY2LCAxLjcsIDEuM11cclxuICAgICAgfSwgb3B0aW9ucy5wYXJ0aWNpcGFudHMpO1xyXG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcclxuICAgICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tJDEoe1xyXG4gICAgICAgIHNpZDogJ1JNX1NJTVVMQVRFRCcsXHJcbiAgICAgICAgbmFtZTogJ3NpbXVsYXRlZC1yb29tJyxcclxuICAgICAgICBlbXB0eVRpbWVvdXQ6IDAsXHJcbiAgICAgICAgbWF4UGFydGljaXBhbnRzOiAwLFxyXG4gICAgICAgIGNyZWF0aW9uVGltZTogcHJvdG9JbnQ2NC5wYXJzZShuZXcgRGF0ZSgpLmdldFRpbWUoKSksXHJcbiAgICAgICAgbWV0YWRhdGE6ICcnLFxyXG4gICAgICAgIG51bVBhcnRpY2lwYW50czogMSxcclxuICAgICAgICBudW1QdWJsaXNoZXJzOiAxLFxyXG4gICAgICAgIHR1cm5QYXNzd29yZDogJycsXHJcbiAgICAgICAgZW5hYmxlZENvZGVjczogW10sXHJcbiAgICAgICAgYWN0aXZlUmVjb3JkaW5nOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVwZGF0ZUluZm8obmV3IFBhcnRpY2lwYW50SW5mbyh7XHJcbiAgICAgICAgaWRlbnRpdHk6ICdzaW11bGF0ZWQtbG9jYWwnLFxyXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJ1xyXG4gICAgICB9KSk7XHJcbiAgICAgIHRoaXMuc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCk7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XHJcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oVHJhY2suS2luZC5WaWRlbywgbmV3IFRyYWNrSW5mbyh7XHJcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLkNBTUVSQSxcclxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXHJcbiAgICAgICAgICBuYW1lOiAndmlkZW8tZHVtbXknXHJcbiAgICAgICAgfSksIG5ldyBMb2NhbFZpZGVvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xyXG4gICAgICAgICAgdmlkZW86IHRydWVcclxuICAgICAgICB9KSkuZ2V0VmlkZW9UcmFja3MoKVswXSA6IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9hID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSksIDE2MCwgdHJ1ZSwgdHJ1ZSksIHVuZGVmaW5lZCwgZmFsc2UsIHtcclxuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcclxuICAgICAgICB9KSwge1xyXG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihjYW1QdWIpO1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgY2FtUHViKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHVibGlzaE9wdGlvbnMuYXVkaW8pIHtcclxuICAgICAgICBjb25zdCBhdWRpb1B1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oVHJhY2suS2luZC5BdWRpbywgbmV3IFRyYWNrSW5mbyh7XHJcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXHJcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXHJcbiAgICAgICAgfSksIG5ldyBMb2NhbEF1ZGlvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbiAgICAgICAgICBhdWRpbzogdHJ1ZVxyXG4gICAgICAgIH0pKS5nZXRBdWRpb1RyYWNrcygpWzBdIDogZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCksIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XHJcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICAgICAgfSksIHtcclxuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgYXVkaW9QdWIpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljaXBhbnRPcHRpb25zLmNvdW50IC0gMTsgaSArPSAxKSB7XHJcbiAgICAgICAgbGV0IGluZm8gPSBuZXcgUGFydGljaXBhbnRJbmZvKHtcclxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICBpZGVudGl0eTogXCJzaW11bGF0ZWQtXCIuY29uY2F0KGkpLFxyXG4gICAgICAgICAgc3RhdGU6IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkUsXHJcbiAgICAgICAgICB0cmFja3M6IFtdLFxyXG4gICAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xyXG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMudmlkZW8pIHtcclxuICAgICAgICAgIGNvbnN0IGR1bW15VmlkZW8gPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soMTYwICogKChfYiA9IHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSksIDE2MCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xyXG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLkNBTUVSQSxcclxuICAgICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soZHVtbXlWaWRlbywgdmlkZW9UcmFjay5zaWQsIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlWaWRlb10pLCBuZXcgUlRDUnRwUmVjZWl2ZXIoKSk7XHJcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgdmlkZW9UcmFja107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJ0aWNpcGFudE9wdGlvbnMuYXVkaW8pIHtcclxuICAgICAgICAgIGNvbnN0IGR1bW15VHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcclxuICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcclxuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5NSUNST1BIT05FLFxyXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVRyYWNrLCBhdWRpb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVRyYWNrXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcclxuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCBhdWRpb1RyYWNrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcC51cGRhdGVJbmZvKGluZm8pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLy8gLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGVtaXQoZXZlbnQpIHtcclxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XHJcbiAgICB9XHJcbiAgICAvLyBhY3RpdmUgc3BlYWtlciB1cGRhdGVzIGFyZSB0b28gc3BhbW15XHJcbiAgICBpZiAoZXZlbnQgIT09IFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQgJiYgZXZlbnQgIT09IFJvb21FdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQpIHtcclxuICAgICAgLy8gb25seSBleHRyYWN0IGxvZ0NvbnRleHQgZnJvbSBhcmd1bWVudHMgaW4gb3JkZXIgdG8gYXZvaWQgbG9nZ2luZyB0aGUgd2hvbGUgb2JqZWN0IHRyZWVcclxuICAgICAgY29uc3QgbWluaW1pemVkQXJncyA9IG1hcEFyZ3MoYXJncykuZmlsdGVyKGFyZyA9PiBhcmcgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicm9vbSBldmVudCBcIi5jb25jYXQoZXZlbnQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBldmVudCxcclxuICAgICAgICBhcmdzOiBtaW5pbWl6ZWRBcmdzXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICB9XHJcbn1cclxuUm9vbS5jbGVhbnVwUmVnaXN0cnkgPSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShjbGVhbnVwID0+IHtcclxuICBjbGVhbnVwKCk7XHJcbn0pO1xyXG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3MpIHtcclxuICByZXR1cm4gYXJncy5tYXAoYXJnID0+IHtcclxuICAgIGlmICghYXJnKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyA/IGFyZy5sb2dDb250ZXh0IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZztcclxuICB9KTtcclxufVxyXG5cclxuLy8gVGhpcyBmaWxlIHdhcyBnZW5lcmF0ZWQgZnJvbSBKU09OIFNjaGVtYSB1c2luZyBxdWlja3R5cGUsIGRvIG5vdCBtb2RpZnkgaXQgZGlyZWN0bHkuXHJcbi8vIFRoZSBjb2RlIGdlbmVyYXRpb24gbGl2ZXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvYXR0cmlidXRlLWRlZmluaXRpb25zXHJcbi8vXHJcbi8vIFRvIHBhcnNlIHRoaXMgZGF0YTpcclxuLy9cclxuLy8gICBpbXBvcnQgeyBDb252ZXJ0LCBBZ2VudEF0dHJpYnV0ZXMsIFRyYW5zY3JpcHRpb25BdHRyaWJ1dGVzIH0gZnJvbSBcIi4vZmlsZVwiO1xyXG4vL1xyXG4vLyAgIGNvbnN0IGFnZW50QXR0cmlidXRlcyA9IENvbnZlcnQudG9BZ2VudEF0dHJpYnV0ZXMoanNvbik7XHJcbi8vICAgY29uc3QgdHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMgPSBDb252ZXJ0LnRvVHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMoanNvbik7XHJcbi8vIENvbnZlcnRzIEpTT04gc3RyaW5ncyB0by9mcm9tIHlvdXIgdHlwZXNcclxuY2xhc3MgQ29udmVydCB7XHJcbiAgc3RhdGljIHRvQWdlbnRBdHRyaWJ1dGVzKGpzb24pIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xyXG4gIH1cclxuICBzdGF0aWMgYWdlbnRBdHRyaWJ1dGVzVG9Kc29uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gIH1cclxuICBzdGF0aWMgdG9UcmFuc2NyaXB0aW9uQXR0cmlidXRlcyhqc29uKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcclxuICB9XHJcbiAgc3RhdGljIHRyYW5zY3JpcHRpb25BdHRyaWJ1dGVzVG9Kc29uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxudmFyIGF0dHJpYnV0ZVR5cGluZ3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbiAgX19wcm90b19fOiBudWxsLFxyXG4gIENvbnZlcnQ6IENvbnZlcnRcclxufSk7XHJcblxyXG52YXIgQ2hlY2tTdGF0dXM7XHJcbihmdW5jdGlvbiAoQ2hlY2tTdGF0dXMpIHtcclxuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xyXG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiUlVOTklOR1wiXSA9IDFdID0gXCJSVU5OSU5HXCI7XHJcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJTS0lQUEVEXCJdID0gMl0gPSBcIlNLSVBQRURcIjtcclxuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNVQ0NFU1NcIl0gPSAzXSA9IFwiU1VDQ0VTU1wiO1xyXG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiRkFJTEVEXCJdID0gNF0gPSBcIkZBSUxFRFwiO1xyXG59KShDaGVja1N0YXR1cyB8fCAoQ2hlY2tTdGF0dXMgPSB7fSkpO1xyXG5jbGFzcyBDaGVja2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcclxuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLnN0YXR1cyA9IENoZWNrU3RhdHVzLklETEU7XHJcbiAgICB0aGlzLmxvZ3MgPSBbXTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICB0aGlzLnJvb20gPSBuZXcgUm9vbShvcHRpb25zLnJvb21PcHRpb25zKTtcclxuICAgIHRoaXMuY29ubmVjdE9wdGlvbnMgPSBvcHRpb25zLmNvbm5lY3RPcHRpb25zO1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICB9XHJcbiAgcnVuKG9uQ29tcGxldGUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuSURMRSkge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdjaGVjayBpcyBydW5uaW5nIGFscmVhZHknKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5SVU5OSU5HKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm0oKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVycm9yc0FzV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgLy8gc2xlZXAgZm9yIGEgYml0IHRvIGVuc3VyZSBkaXNjb25uZWN0XHJcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IENoZWNrU3RhdHVzLlNLSVBQRUQpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcclxuICAgICAgICBvbkNvbXBsZXRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5mbygpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlzU3VjY2VzcygpIHtcclxuICAgIHJldHVybiAhdGhpcy5sb2dzLnNvbWUobCA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcclxuICB9XHJcbiAgY29ubmVjdCh1cmwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnJvb20uc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb29tO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgdXJsID0gdGhpcy51cmw7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodXJsLCB0aGlzLnRva2VuLCB0aGlzLmNvbm5lY3RPcHRpb25zKTtcclxuICAgICAgcmV0dXJuIHRoaXMucm9vbTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBkaXNjb25uZWN0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMucm9vbSAmJiB0aGlzLnJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLnJvb20uZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIC8vIHdhaXQgZm9yIGl0IHRvIGdvIHRocm91Z2hcclxuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBza2lwKCkge1xyXG4gICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuU0tJUFBFRCk7XHJcbiAgfVxyXG4gIHN3aXRjaFByb3RvY29sKHByb3RvY29sKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBsZXQgaGFzUmVjb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgIGxldCBoYXNSZWNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgKCkgPT4ge1xyXG4gICAgICAgIGhhc1JlY29ubmVjdGluZyA9IHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnJvb20ub25jZShSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcclxuICAgICAgICBoYXNSZWNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnJvb20uc2ltdWxhdGVTY2VuYXJpbyhcImZvcmNlLVwiLmNvbmNhdChwcm90b2NvbCkpO1xyXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG4gICAgICBpZiAoIWhhc1JlY29ubmVjdGluZykge1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gd2FpdCBmb3IgcmVjb25uZWN0aW9uXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHdhaXQgZm9yIDEwIHNlY29uZHMgZm9yIHJlY29ubmVjdGlvblxyXG4gICAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArIDEwMDAwO1xyXG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHRpbWVvdXQpIHtcclxuICAgICAgICBpZiAoaGFzUmVjb25uZWN0ZWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgc2xlZXAoMTAwKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVjb25uZWN0IHVzaW5nIFwiLmNvbmNhdChwcm90b2NvbCwgXCIgcHJvdG9jb2wgYWZ0ZXIgMTAgc2Vjb25kc1wiKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICB0aGlzLmxvZ3MucHVzaCh7XHJcbiAgICAgIGxldmVsOiAnaW5mbycsXHJcbiAgICAgIG1lc3NhZ2VcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XHJcbiAgfVxyXG4gIGFwcGVuZFdhcm5pbmcobWVzc2FnZSkge1xyXG4gICAgdGhpcy5sb2dzLnB1c2goe1xyXG4gICAgICBsZXZlbDogJ3dhcm5pbmcnLFxyXG4gICAgICBtZXNzYWdlXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xyXG4gIH1cclxuICBhcHBlbmRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICB0aGlzLmxvZ3MucHVzaCh7XHJcbiAgICAgIGxldmVsOiAnZXJyb3InLFxyXG4gICAgICBtZXNzYWdlXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xyXG4gIH1cclxuICBzZXRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xyXG4gIH1cclxuICBnZXQgZW5naW5lKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZ2luZTtcclxuICB9XHJcbiAgZ2V0SW5mbygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxvZ3M6IHRoaXMubG9ncyxcclxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvblxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgZm9yIGNvbm5lY3Rpb25zIHF1YWxpdHkgdG8gY2xvc2VzdHMgQ2xvdWQgcmVnaW9ucyBhbmQgZGV0ZXJtaW5pbmcgdGhlIGJlc3QgcXVhbGl0eVxyXG4gKi9cclxuY2xhc3MgQ2xvdWRSZWdpb25DaGVjayBleHRlbmRzIENoZWNrZXIge1xyXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnQ2xvdWQgcmVnaW9ucyc7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCByZWdpb25Qcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih0aGlzLnVybCwgdGhpcy50b2tlbik7XHJcbiAgICAgIGlmICghcmVnaW9uUHJvdmlkZXIuaXNDbG91ZCgpKSB7XHJcbiAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJlZ2lvblN0YXRzID0gW107XHJcbiAgICAgIGNvbnN0IHNlZW5VcmxzID0gbmV3IFNldCgpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IHlpZWxkIHJlZ2lvblByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XHJcbiAgICAgICAgaWYgKCFyZWdpb25VcmwpIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VlblVybHMuaGFzKHJlZ2lvblVybCkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuVXJscy5hZGQocmVnaW9uVXJsKTtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuY2hlY2tDbG91ZFJlZ2lvbihyZWdpb25VcmwpO1xyXG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIlwiLmNvbmNhdChzdGF0cy5yZWdpb24sIFwiIFJUVDogXCIpLmNvbmNhdChzdGF0cy5ydHQsIFwibXMsIGR1cmF0aW9uOiBcIikuY29uY2F0KHN0YXRzLmR1cmF0aW9uLCBcIm1zXCIpKTtcclxuICAgICAgICByZWdpb25TdGF0cy5wdXNoKHN0YXRzKTtcclxuICAgICAgfVxyXG4gICAgICByZWdpb25TdGF0cy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChhLmR1cmF0aW9uIC0gYi5kdXJhdGlvbikgKiAwLjUgKyAoYS5ydHQgLSBiLnJ0dCkgKiAwLjU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBiZXN0UmVnaW9uID0gcmVnaW9uU3RhdHNbMF07XHJcbiAgICAgIHRoaXMuYmVzdFN0YXRzID0gYmVzdFJlZ2lvbjtcclxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiYmVzdCBDbG91ZCByZWdpb246IFwiLmNvbmNhdChiZXN0UmVnaW9uLnJlZ2lvbikpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldEluZm8oKSB7XHJcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0SW5mbygpO1xyXG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9XHJcbiAgY2hlY2tDbG91ZFJlZ2lvbih1cmwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCh1cmwpO1xyXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sID09PSAndGNwJykge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoUHJvdG9jb2woJ3RjcCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IChfYSA9IHRoaXMucm9vbS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVnaW9uO1xyXG4gICAgICBpZiAoIXJlZ2lvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaW9uIG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LnN0cmVhbVRleHQoe1xyXG4gICAgICAgIHRvcGljOiAndGVzdCdcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEwMDA7IC8vIGVhY2ggY2h1bmsgaXMgYWJvdXQgMTAwMCBieXRlc1xyXG4gICAgICBjb25zdCB0b3RhbFNpemUgPSAxMDAwMDAwOyAvLyBhcHByb3hpbWF0ZWx5IDFNQiBvZiBkYXRhXHJcbiAgICAgIGNvbnN0IG51bUNodW5rcyA9IHRvdGFsU2l6ZSAvIGNodW5rU2l6ZTsgLy8gd2lsbCB5aWVsZCAxMDAwIGNodW5rc1xyXG4gICAgICBjb25zdCBjaHVua0RhdGEgPSAnQScucmVwZWF0KGNodW5rU2l6ZSk7IC8vIGNyZWF0ZSBhIHN0cmluZyBvZiAxMDAwICdBJyBjaGFyYWN0ZXJzXHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2h1bmtzOyBpKyspIHtcclxuICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUoY2h1bmtEYXRhKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcclxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgKF9iID0gdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdWJsaXNoZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgY29uc3QgcmVnaW9uU3RhdHMgPSB7XHJcbiAgICAgICAgcmVnaW9uOiByZWdpb24sXHJcbiAgICAgICAgcnR0OiAxMDAwMCxcclxuICAgICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZVxyXG4gICAgICB9O1xyXG4gICAgICBzdGF0cyA9PT0gbnVsbCB8fCBzdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcclxuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInICYmIHN0YXQubm9taW5hdGVkKSB7XHJcbiAgICAgICAgICByZWdpb25TdGF0cy5ydHQgPSBzdGF0LmN1cnJlbnRSb3VuZFRyaXBUaW1lICogMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgcmV0dXJuIHJlZ2lvblN0YXRzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBURVNUX0RVUkFUSU9OID0gMTAwMDA7XHJcbmNsYXNzIENvbm5lY3Rpb25Qcm90b2NvbENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdDb25uZWN0aW9uIHZpYSBVRFAgdnMgVENQJztcclxuICB9XHJcbiAgcGVyZm9ybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHVkcFN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndWRwJyk7XHJcbiAgICAgIGNvbnN0IHRjcFN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndGNwJyk7XHJcbiAgICAgIHRoaXMuYmVzdFN0YXRzID0gdWRwU3RhdHM7XHJcbiAgICAgIC8vIHVkcCBzaG91bGQgaXMgdGhlIGJldHRlciBwcm90b2NvbCB0eXBpY2FsbHkuIGhvd2V2ZXIsIHdlJ2QgcHJlZmVyIFRDUCB3aGVuIGVpdGhlciBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSB0cnVlOlxyXG4gICAgICAvLyAxLiB0aGUgYmFuZHdpZHRoIGxpbWl0YXRpb24gaXMgd29yc2Ugb24gVURQIGJ5IDUwMG1zXHJcbiAgICAgIC8vIDIuIHRoZSBwYWNrZXQgbG9zcyBpcyBoaWdoZXIgb24gVURQIGJ5IDElXHJcbiAgICAgIGlmICh1ZHBTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggLSB0Y3BTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggPiAwLjUgfHwgKHVkcFN0YXRzLnBhY2tldHNMb3N0IC0gdGNwU3RhdHMucGFja2V0c0xvc3QpIC8gdWRwU3RhdHMucGFja2V0c1NlbnQgPiAwLjAxKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdiZXN0IGNvbm5lY3Rpb24gcXVhbGl0eSB2aWEgdGNwJyk7XHJcbiAgICAgICAgdGhpcy5iZXN0U3RhdHMgPSB0Y3BTdGF0cztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB1ZHAnKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0cyA9IHRoaXMuYmVzdFN0YXRzO1xyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJ1cHN0cmVhbSBiaXRyYXRlOiBcIi5jb25jYXQoKHN0YXRzLmJpdHJhdGVUb3RhbCAvIHN0YXRzLmNvdW50IC8gMTAwMCAvIDEwMDApLnRvRml4ZWQoMiksIFwiIG1icHNcIikpO1xyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJSVFQ6IFwiLmNvbmNhdCgoc3RhdHMucnR0VG90YWwgLyBzdGF0cy5jb3VudCAqIDEwMDApLnRvRml4ZWQoMiksIFwiIG1zXCIpKTtcclxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiaml0dGVyOiBcIi5jb25jYXQoKHN0YXRzLmppdHRlclRvdGFsIC8gc3RhdHMuY291bnQgKiAxMDAwKS50b0ZpeGVkKDIpLCBcIiBtc1wiKSk7XHJcbiAgICAgIGlmIChzdGF0cy5wYWNrZXRzTG9zdCA+IDApIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJwYWNrZXRzIGxvc3Q6IFwiLmNvbmNhdCgoc3RhdHMucGFja2V0c0xvc3QgLyBzdGF0cy5wYWNrZXRzU2VudCAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoID4gMSkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImJhbmR3aWR0aCBsaW1pdGVkIFwiLmNvbmNhdCgoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoIC8gKFRFU1RfRFVSQVRJT04gLyAxMDAwKSAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuY3B1ID4gMCkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImNwdSBsaW1pdGVkIFwiLmNvbmNhdCgoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuY3B1IC8gKFRFU1RfRFVSQVRJT04gLyAxMDAwKSAqIDEwMCkudG9GaXhlZCgyKSwgXCIlXCIpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGdldEluZm8oKSB7XHJcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0SW5mbygpO1xyXG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XHJcbiAgICByZXR1cm4gaW5mbztcclxuICB9XHJcbiAgY2hlY2tDb25uZWN0aW9uUHJvdG9jb2wocHJvdG9jb2wpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgICBpZiAocHJvdG9jb2wgPT09ICd0Y3AnKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndWRwJyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gY3JlYXRlIGEgY2FudmFzIHdpdGggYW5pbWF0ZWQgY29udGVudFxyXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgY2FudmFzLndpZHRoID0gMTI4MDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IDcyMDtcclxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGh1ZSA9IDA7XHJcbiAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaHVlID0gKGh1ZSArIDEpICUgMzYwO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcImhzbChcIi5jb25jYXQoaHVlLCBcIiwgMTAwJSwgNTAlKVwiKTtcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGFuaW1hdGUoKTtcclxuICAgICAgLy8gY3JlYXRlIHZpZGVvIHRyYWNrIGZyb20gY2FudmFzXHJcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKDMwKTsgLy8gMzBmcHNcclxuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xyXG4gICAgICAvLyBwdWJsaXNoIHRvIHJvb21cclxuICAgICAgY29uc3QgcHViID0geWllbGQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHZpZGVvVHJhY2ssIHtcclxuICAgICAgICBzaW11bGNhc3Q6IGZhbHNlLFxyXG4gICAgICAgIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZTogJ21haW50YWluLXJlc29sdXRpb24nLFxyXG4gICAgICAgIHZpZGVvRW5jb2Rpbmc6IHtcclxuICAgICAgICAgIG1heEJpdHJhdGU6IDIwMDAwMDBcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcclxuICAgICAgY29uc3QgcHJvdG9jb2xTdGF0cyA9IHtcclxuICAgICAgICBwcm90b2NvbCxcclxuICAgICAgICBwYWNrZXRzTG9zdDogMCxcclxuICAgICAgICBwYWNrZXRzU2VudDogMCxcclxuICAgICAgICBxdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9uczoge30sXHJcbiAgICAgICAgcnR0VG90YWw6IDAsXHJcbiAgICAgICAgaml0dGVyVG90YWw6IDAsXHJcbiAgICAgICAgYml0cmF0ZVRvdGFsOiAwLFxyXG4gICAgICAgIGNvdW50OiAwXHJcbiAgICAgIH07XHJcbiAgICAgIC8vIGdhdGhlciBzdGF0cyBvbmNlIGEgc2Vjb25kXHJcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdHJhY2suZ2V0UlRDU3RhdHNSZXBvcnQoKTtcclxuICAgICAgICBzdGF0cyA9PT0gbnVsbCB8fCBzdGF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcclxuICAgICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XHJcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucGFja2V0c1NlbnQgPSBzdGF0LnBhY2tldHNTZW50O1xyXG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zID0gc3RhdC5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucztcclxuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5iaXRyYXRlVG90YWwgKz0gc3RhdC50YXJnZXRCaXRyYXRlO1xyXG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmNvdW50Kys7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQudHlwZSA9PT0gJ3JlbW90ZS1pbmJvdW5kLXJ0cCcpIHtcclxuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5wYWNrZXRzTG9zdCA9IHN0YXQucGFja2V0c0xvc3Q7XHJcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucnR0VG90YWwgKz0gc3RhdC5yb3VuZFRyaXBUaW1lO1xyXG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmppdHRlclRvdGFsICs9IHN0YXQuaml0dGVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSwgMTAwMCk7XHJcbiAgICAgIC8vIHdhaXQgYSBiaXQgdG8gZ2F0aGVyIHN0YXRzXHJcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBURVNUX0RVUkFUSU9OKSk7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICB2aWRlb1RyYWNrLnN0b3AoKTtcclxuICAgICAgY2FudmFzLnJlbW92ZSgpO1xyXG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgcmV0dXJuIHByb3RvY29sU3RhdHM7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFB1Ymxpc2hBdWRpb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCBhdWRpbyc7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcclxuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2soKTtcclxuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodHJhY2ssIDEwMDApO1xyXG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVjdCBhdWRpbyBmcm9tIG1pY3JvcGhvbmUnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2RldGVjdGVkIGF1ZGlvIGZyb20gbWljcm9waG9uZScpO1xyXG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcclxuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXHJcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XHJcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xyXG4gICAgICBpZiAoIXN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xyXG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIChzdGF0LmtpbmQgPT09ICdhdWRpbycgfHwgIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ2F1ZGlvJykpIHtcclxuICAgICAgICAgIG51bVBhY2tldHMgPSBzdGF0LnBhY2tldHNTZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChudW1QYWNrZXRzID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJwdWJsaXNoZWQgXCIuY29uY2F0KG51bVBhY2tldHMsIFwiIGF1ZGlvIHBhY2tldHNcIikpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBQdWJsaXNoVmlkZW9DaGVjayBleHRlbmRzIENoZWNrZXIge1xyXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggdmlkZW8nO1xyXG4gIH1cclxuICBwZXJmb3JtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgY3JlYXRlTG9jYWxWaWRlb1RyYWNrKCk7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgdmlkZW8gZnJvbSBjYW1lcmFcclxuICAgICAgeWllbGQgdGhpcy5jaGVja0ZvclZpZGVvKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xyXG4gICAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcclxuICAgICAgLy8gd2FpdCBmb3IgYSBmZXcgc2Vjb25kcyB0byBwdWJsaXNoXHJcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XHJcbiAgICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2EgPSB0cmFjay5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cygpO1xyXG4gICAgICBpZiAoIXN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xyXG4gICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnICYmIChzdGF0LmtpbmQgPT09ICd2aWRlbycgfHwgIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ3ZpZGVvJykpIHtcclxuICAgICAgICAgIG51bVBhY2tldHMgKz0gc3RhdC5wYWNrZXRzU2VudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiB2aWRlbyBwYWNrZXRzXCIpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja0ZvclZpZGVvKHRyYWNrKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrLmNsb25lKCkpO1xyXG4gICAgICAvLyBDcmVhdGUgdmlkZW8gZWxlbWVudCB0byBjaGVjayBmcmFtZXNcclxuICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XHJcbiAgICAgIHZpZGVvLm11dGVkID0gdHJ1ZTtcclxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgdmlkZW8ub25wbGF5ID0gKCkgPT4ge1xyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAoX2IgPSAoX2EgPSBzZXR0aW5ncy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlkZW8udmlkZW9XaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTI4MDtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKF9kID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB2aWRlby52aWRlb0hlaWdodCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogNzIwO1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgdmlkZW8gZnJhbWUgdG8gY2FudmFzXHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xyXG4gICAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBhbmQgY2hlY2sgaWYgYWxsIHBpeGVscyBhcmUgYmxhY2tcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBpc0FsbEJsYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gIT09IDAgfHwgZGF0YVtpICsgMV0gIT09IDAgfHwgZGF0YVtpICsgMl0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlzQWxsQmxhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNBbGxCbGFjaykge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoJ2NhbWVyYSBhcHBlYXJzIHRvIGJlIHByb2R1Y2luZyBvbmx5IGJsYWNrIGZyYW1lcycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgncmVjZWl2ZWQgdmlkZW8gZnJhbWVzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2aWRlby5wbGF5KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2aWRlby5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUmVjb25uZWN0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcclxuICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcclxuICB9XHJcbiAgcGVyZm9ybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgICBsZXQgcmVjb25uZWN0aW5nVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgIGxldCByZWNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICBsZXQgcmVjb25uZWN0UmVzb2x2ZXI7XHJcbiAgICAgIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApO1xyXG4gICAgICAgIHJlY29ubmVjdFJlc29sdmVyID0gcmVzb2x2ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGhhbmRsZVJlY29ubmVjdGluZyA9ICgpID0+IHtcclxuICAgICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICB9O1xyXG4gICAgICByb29tLm9uKFJvb21FdmVudC5TaWduYWxSZWNvbm5lY3RpbmcsIGhhbmRsZVJlY29ubmVjdGluZykub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgaGFuZGxlUmVjb25uZWN0aW5nKS5vbihSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcclxuICAgICAgICByZWNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAoX2EgPSByb29tLmVuZ2luZS5jbGllbnQud3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xyXG4gICAgICBjb25zdCBvbkNsb3NlID0gcm9vbS5lbmdpbmUuY2xpZW50Lm9uQ2xvc2U7XHJcbiAgICAgIGlmIChvbkNsb3NlKSB7XHJcbiAgICAgICAgb25DbG9zZSgnJyk7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgcmVjb25uZWN0VGltZW91dDtcclxuICAgICAgaWYgKCFyZWNvbm5lY3RpbmdUcmlnZ2VyZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcclxuICAgICAgfSBlbHNlIGlmICghcmVjb25uZWN0ZWQgfHwgcm9vbS5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncmVjb25uZWN0aW9uIGlzIG9ubHkgcG9zc2libGUgaW4gUmVkaXMtYmFzZWQgY29uZmlndXJhdGlvbnMnKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xyXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnQ2FuIGNvbm5lY3QgdmlhIFRVUk4nO1xyXG4gIH1cclxuICBwZXJmb3JtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgY29uc3Qgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xyXG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcclxuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDAsXHJcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQgaGFzVExTID0gZmFsc2U7XHJcbiAgICAgIGxldCBoYXNUVVJOID0gZmFsc2U7XHJcbiAgICAgIGxldCBoYXNTVFVOID0gZmFsc2U7XHJcbiAgICAgIGZvciAobGV0IGljZVNlcnZlciBvZiBqb2luUmVzLmljZVNlcnZlcnMpIHtcclxuICAgICAgICBmb3IgKGxldCB1cmwgb2YgaWNlU2VydmVyLnVybHMpIHtcclxuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybjonKSkge1xyXG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcclxuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuczonKSkge1xyXG4gICAgICAgICAgICBoYXNUVVJOID0gdHJ1ZTtcclxuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XHJcbiAgICAgICAgICAgIGhhc1RMUyA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3N0dW46JykpIHtcclxuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghaGFzU1RVTikge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gU1RVTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQgb24gc2VydmVyIHNpZGUuJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaGFzVFVSTiAmJiAhaGFzVExTKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdUVVJOIGlzIGNvbmZpZ3VyZWQgc2VydmVyIHNpZGUsIGJ1dCBUVVJOL1RMUyBpcyB1bmF2YWlsYWJsZS4nKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcclxuICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmNvbm5lY3RPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnRjQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWNlU2VydmVycykgfHwgaGFzVFVSTikge1xyXG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XHJcbiAgICAgICAgICBydGNDb25maWc6IHtcclxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAncmVsYXknXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBUVVJOIHNlcnZlcnMgY29uZmlndXJlZC4nKTtcclxuICAgICAgICB0aGlzLnNraXAoKTtcclxuICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFdlYlJUQ0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdFc3RhYmxpc2hpbmcgV2ViUlRDIGNvbm5lY3Rpb24nO1xyXG4gIH1cclxuICBwZXJmb3JtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgbGV0IGhhc1RjcCA9IGZhbHNlO1xyXG4gICAgICBsZXQgaGFzSXB2NFVkcCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByZXZUcmlja2xlID0gdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlO1xyXG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICBpZiAoc2QuY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IG5ldyBSVENJY2VDYW5kaWRhdGUoc2QpO1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIi5jb25jYXQoY2FuZGlkYXRlLnByb3RvY29sLCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS5hZGRyZXNzLCBcIjpcIikuY29uY2F0KGNhbmRpZGF0ZS5wb3J0LCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS50eXBlKTtcclxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5hZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgKHByaXZhdGUpJztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xyXG4gICAgICAgICAgICAgICAgICBoYXNUY3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBzdHIgKz0gJyAocGFzc2l2ZSknO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XHJcbiAgICAgICAgICAgICAgICAgIGhhc0lwdjRVZHAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2Uoc3RyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwcmV2VHJpY2tsZSkge1xyXG4gICAgICAgICAgICBwcmV2VHJpY2tsZShzZCwgdGFyZ2V0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlcikge1xyXG4gICAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZUVycm9yID0gZXYgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQpIHtcclxuICAgICAgICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJlcnJvciB3aXRoIElDRSBjYW5kaWRhdGU6IFwiLmNvbmNhdChldi5lcnJvckNvZGUsIFwiIFwiKS5jb25jYXQoZXYuZXJyb3JUZXh0LCBcIiBcIikuY29uY2F0KGV2LnVybCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdub3cgdGhlIHJvb20gaXMgY29ubmVjdGVkJyk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncG9ydHMgbmVlZCB0byBiZSBvcGVuIG9uIGZpcmV3YWxsIGluIG9yZGVyIHRvIGNvbm5lY3QuJyk7XHJcbiAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaGFzVGNwKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIElDRS9UQ1AnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWhhc0lwdjRVZHApIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzSVBQcml2YXRlKGFkZHJlc3MpIHtcclxuICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKTtcclxuICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7XHJcbiAgICBpZiAocGFydHNbMF0gPT09ICcxMCcpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTkyJyAmJiBwYXJ0c1sxXSA9PT0gJzE2OCcpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTcyJykge1xyXG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xyXG4gICAgICBpZiAoc2Vjb25kID49IDE2ICYmIHNlY29uZCA8PSAzMSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuY2xhc3MgV2ViU29ja2V0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcclxuICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ0Nvbm5lY3RpbmcgdG8gc2lnbmFsIGNvbm5lY3Rpb24gdmlhIFdlYlNvY2tldCc7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ3dzOicpIHx8IHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykpIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBpbnNlY3VyZSwgY2xpZW50cyBtYXkgYmxvY2sgY29ubmVjdGlvbnMgdG8gaXQnKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xyXG4gICAgICBjb25zdCBqb2luUmVzID0geWllbGQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcclxuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxyXG4gICAgICAgIG1heFJldHJpZXM6IDAsXHJcbiAgICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJDb25uZWN0ZWQgdG8gc2VydmVyLCB2ZXJzaW9uIFwiLmNvbmNhdChqb2luUmVzLnNlcnZlclZlcnNpb24sIFwiLlwiKSk7XHJcbiAgICAgIGlmICgoKF9hID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWRpdGlvbikgPT09IFNlcnZlckluZm9fRWRpdGlvbi5DbG91ZCAmJiAoKF9iID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaW9uKSkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkxpdmVLaXQgQ2xvdWQ6IFwiLmNvbmNhdCgoX2MgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZWdpb24pKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQ29ubmVjdGlvbkNoZWNrIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcclxuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgIHRoaXMuY2hlY2tSZXN1bHRzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuICBnZXROZXh0Q2hlY2tJZCgpIHtcclxuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XHJcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQobmV4dElkLCB7XHJcbiAgICAgIGxvZ3M6IFtdLFxyXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXHJcbiAgICAgIG5hbWU6ICcnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJydcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5leHRJZDtcclxuICB9XHJcbiAgdXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbykge1xyXG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KGNoZWNrSWQsIGluZm8pO1xyXG4gICAgdGhpcy5lbWl0KCdjaGVja1VwZGF0ZScsIGNoZWNrSWQsIGluZm8pO1xyXG4gIH1cclxuICBpc1N1Y2Nlc3MoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoZWNrUmVzdWx0cy52YWx1ZXMoKSkuZXZlcnkociA9PiByLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuRkFJTEVEKTtcclxuICB9XHJcbiAgZ2V0UmVzdWx0cygpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKTtcclxuICB9XHJcbiAgY3JlYXRlQW5kUnVuQ2hlY2soY2hlY2spIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XHJcbiAgICAgIGNvbnN0IHRlc3QgPSBuZXcgY2hlY2sodGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IGluZm8gPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2soY2hlY2tJZCwgaW5mbyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRlc3QucnVuKCk7XHJcbiAgICAgIHRlc3Qub2ZmKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrV2Vic29ja2V0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViU29ja2V0Q2hlY2spO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrV2ViUlRDKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soV2ViUlRDQ2hlY2spO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrVFVSTigpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tSZWNvbm5lY3QoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhSZWNvbm5lY3RDaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tQdWJsaXNoQXVkaW8oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoQXVkaW9DaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tQdWJsaXNoVmlkZW8oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tDb25uZWN0aW9uUHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDb25uZWN0aW9uUHJvdG9jb2xDaGVjayk7XHJcbiAgICAgIGlmIChpbmZvLmRhdGEgJiYgJ3Byb3RvY29sJyBpbiBpbmZvLmRhdGEpIHtcclxuICAgICAgICBjb25zdCBzdGF0cyA9IGluZm8uZGF0YTtcclxuICAgICAgICB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPSBzdGF0cy5wcm90b2NvbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaW5mbztcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja0Nsb3VkUmVnaW9uKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soQ2xvdWRSZWdpb25DaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXHJcbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlIHRoZSBgZmFjaW5nTW9kZWAgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsIGJ1dCB3aWxsIGZhbGwgYmFjayBvbiBhIHN0cmluZy1iYXNlZCBhbmFseXNpcyBvZiB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXHJcbiAqIElmIGJvdGggbWV0aG9kcyBmYWlsLCB0aGUgZGVmYXVsdCBmYWNpbmcgbW9kZSB3aWxsIGJlIHVzZWQuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMvZmFjaW5nTW9kZSB8IE1ETiBkb2NzIG9uIGZhY2luZ01vZGV9XHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjayhsb2NhbFRyYWNrKSB7XHJcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gIHZhciBfYTtcclxuICBjb25zdCB0cmFjayA9IGlzTG9jYWxUcmFjayhsb2NhbFRyYWNrKSA/IGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA6IGxvY2FsVHJhY2s7XHJcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XHJcbiAgbGV0IHJlc3VsdCA9IHtcclxuICAgIGZhY2luZ01vZGU6IChfYSA9IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1c2VyJyxcclxuICAgIGNvbmZpZGVuY2U6ICdsb3cnXHJcbiAgfTtcclxuICAvLyAxLiBUcnkgdG8gZ2V0IGZhY2luZ01vZGUgZnJvbSB0cmFjayBzZXR0aW5ncy5cclxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IHJhd0ZhY2luZ01vZGUgPSB0cmFja1NldHRpbmdzLmZhY2luZ01vZGU7XHJcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKCdyYXdGYWNpbmdNb2RlJywge1xyXG4gICAgICByYXdGYWNpbmdNb2RlXHJcbiAgICB9KTtcclxuICAgIGlmIChyYXdGYWNpbmdNb2RlICYmIHR5cGVvZiByYXdGYWNpbmdNb2RlID09PSAnc3RyaW5nJyAmJiBpc0ZhY2luZ01vZGVWYWx1ZShyYXdGYWNpbmdNb2RlKSkge1xyXG4gICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgZmFjaW5nTW9kZTogcmF3RmFjaW5nTW9kZSxcclxuICAgICAgICBjb25maWRlbmNlOiAnaGlnaCdcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXHJcbiAgaWYgKFsnbG93JywgJ21lZGl1bSddLmluY2x1ZGVzKHJlc3VsdC5jb25maWRlbmNlKSkge1xyXG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZShcIlRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6IChcIi5jb25jYXQodHJhY2subGFiZWwsIFwiKVwiKSk7XHJcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XHJcbiAgICBpZiAobGFiZWxBbmFseXNpc1Jlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJlc3VsdCA9IGxhYmVsQW5hbHlzaXNSZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3Qga25vd25EZXZpY2VMYWJlbHMgPSBuZXcgTWFwKFtbJ29icyB2aXJ0dWFsIGNhbWVyYScsIHtcclxuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxyXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXHJcbn1dXSk7XHJcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXAoW1snaXBob25lJywge1xyXG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXHJcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcclxufV0sIFsnaXBhZCcsIHtcclxuICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLFxyXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXHJcbn1dXSk7XHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIGFuYWx5emUgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxyXG4gKlxyXG4gKiBAZXhwZXJpbWVudGFsXHJcbiAqL1xyXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKGRldmljZUxhYmVsKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IGxhYmVsID0gZGV2aWNlTGFiZWwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgLy8gRW1wdHkgc3RyaW5nIGlzIGEgdmFsaWQgZGV2aWNlIGxhYmVsIGJ1dCB3ZSBjYW4ndCBpbmZlciBhbnl0aGluZyBmcm9tIGl0LlxyXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8vIENhbiB3ZSBtYXRjaCBhZ2FpbnN0IHdpZGVseSBrbm93biBkZXZpY2UgbGFiZWxzLlxyXG4gIGlmIChrbm93bkRldmljZUxhYmVscy5oYXMobGFiZWwpKSB7XHJcbiAgICByZXR1cm4ga25vd25EZXZpY2VMYWJlbHMuZ2V0KGxhYmVsKTtcclxuICB9XHJcbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgc2VjdGlvbnMgb2YgdGhlIGRldmljZSBsYWJlbC5cclxuICByZXR1cm4gKF9hID0gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKF9yZWYgPT4ge1xyXG4gICAgbGV0IFtzZWN0aW9uXSA9IF9yZWY7XHJcbiAgICByZXR1cm4gbGFiZWwuaW5jbHVkZXMoc2VjdGlvbik7XHJcbiAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcclxufVxyXG5mdW5jdGlvbiBpc0ZhY2luZ01vZGVWYWx1ZShpdGVtKSB7XHJcbiAgY29uc3QgYWxsb3dlZFZhbHVlcyA9IFsndXNlcicsICdlbnZpcm9ubWVudCcsICdsZWZ0JywgJ3JpZ2h0J107XHJcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0pO1xyXG59XHJcblxyXG5leHBvcnQgeyBBdWRpb1ByZXNldHMsIEJhY2t1cENvZGVjUG9saWN5LCBCYXNlS2V5UHJvdmlkZXIsIENoZWNrU3RhdHVzLCBDaGVja2VyLCBDb25uZWN0aW9uQ2hlY2ssIENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdGlvbkVycm9yUmVhc29uLCBDb25uZWN0aW9uUXVhbGl0eSwgQ29ubmVjdGlvblN0YXRlLCBDcml0aWNhbFRpbWVycywgQ3J5cHRvckVycm9yLCBDcnlwdG9yRXJyb3JSZWFzb24sIENyeXB0b3JFdmVudCwgRGF0YVBhY2tldF9LaW5kLCBEZWZhdWx0UmVjb25uZWN0UG9saWN5LCBEZXZpY2VVbnN1cHBvcnRlZEVycm9yLCBEaXNjb25uZWN0UmVhc29uLCBFbmNyeXB0aW9uRXZlbnQsIEVuZ2luZUV2ZW50LCBFeHRlcm5hbEUyRUVLZXlQcm92aWRlciwgS2V5SGFuZGxlckV2ZW50LCBLZXlQcm92aWRlckV2ZW50LCBMaXZla2l0RXJyb3IsIExvY2FsQXVkaW9UcmFjaywgTG9jYWxQYXJ0aWNpcGFudCwgTG9jYWxUcmFjaywgTG9jYWxUcmFja1B1YmxpY2F0aW9uLCBMb2NhbFRyYWNrUmVjb3JkZXIsIExvY2FsVmlkZW9UcmFjaywgTG9nTGV2ZWwsIExvZ2dlck5hbWVzLCBNZWRpYURldmljZUZhaWx1cmUsIF8gYXMgTXV0ZXgsIE5lZ290aWF0aW9uRXJyb3IsIFBhcnRpY2lwYW50LCBQYXJ0aWNpcGFudEV2ZW50LCBQYXJ0aWNpcGFudEluZm9fS2luZCBhcyBQYXJ0aWNpcGFudEtpbmQsIFB1Ymxpc2hEYXRhRXJyb3IsIFB1Ymxpc2hUcmFja0Vycm9yLCBSZW1vdGVBdWRpb1RyYWNrLCBSZW1vdGVQYXJ0aWNpcGFudCwgUmVtb3RlVHJhY2ssIFJlbW90ZVRyYWNrUHVibGljYXRpb24sIFJlbW90ZVZpZGVvVHJhY2ssIFJvb20sIFJvb21FdmVudCwgUnBjRXJyb3IsIFNjcmVlblNoYXJlUHJlc2V0cywgU2lnbmFsUmVxdWVzdEVycm9yLCBTdWJzY3JpcHRpb25FcnJvciwgVHJhY2ssIFRyYWNrRXZlbnQsIFRyYWNrSW52YWxpZEVycm9yLCBUcmFja1B1YmxpY2F0aW9uLCBUcmFja1R5cGUsIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUsIFVuc3VwcG9ydGVkU2VydmVyLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MywgVmlkZW9RdWFsaXR5LCBhdHRhY2hUb0VsZW1lbnQsIGF0dHJpYnV0ZVR5cGluZ3MgYXMgYXR0cmlidXRlcywgY29tcGFyZVZlcnNpb25zLCBjcmVhdGVBdWRpb0FuYWx5c2VyLCBjcmVhdGVFMkVFS2V5LCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZywgY3JlYXRlTG9jYWxBdWRpb1RyYWNrLCBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcywgY3JlYXRlTG9jYWxUcmFja3MsIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaywgZGVyaXZlS2V5cywgZGV0YWNoVHJhY2ssIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwsIGZhY2luZ01vZGVGcm9tTG9jYWxUcmFjaywgZ2V0QnJvd3NlciwgZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrLCBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2ssIGdldExvZ2dlciwgaW1wb3J0S2V5LCBpc0F1ZGlvVHJhY2ssIGlzQmFja3VwQ29kZWMsIGlzQnJvd3NlclN1cHBvcnRlZCwgaXNFMkVFU3VwcG9ydGVkLCBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQsIGlzTG9jYWxQYXJ0aWNpcGFudCwgaXNMb2NhbFRyYWNrLCBpc1JlbW90ZVBhcnRpY2lwYW50LCBpc1JlbW90ZVRyYWNrLCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCwgaXNWaWRlb0ZyYW1lLCBpc1ZpZGVvVHJhY2ssIG5lZWRzUmJzcFVuZXNjYXBpbmcsIHBhcnNlUmJzcCwgcHJvdG9jb2xWZXJzaW9uLCByYXRjaGV0LCBzZXRMb2dFeHRlbnNpb24sIHNldExvZ0xldmVsLCBzdXBwb3J0c0FWMSwgc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSwgc3VwcG9ydHNEeW5hY2FzdCwgc3VwcG9ydHNWUDksIHZlcnNpb24sIHZpZGVvQ29kZWNzLCB3cml0ZVJic3AgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl2ZWtpdC1jbGllbnQuZXNtLm1qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\r\n\r\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEO0FBQ2hEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcYXBpXFxuYXZpZ2F0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24nO1xyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CPython%5C%5Ctravel-detail-demo%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Csupport%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CPython%5C%5Ctravel-detail-demo%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Csupport%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/support/page.tsx */ \"(app-pages-browser)/./src/app/support/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q1B5dGhvbiU1QyU1Q3RyYXZlbC1kZXRhaWwtZGVtbyU1QyU1Q2Zyb250ZW5kJTVDJTVDc3JjJTVDJTVDYXBwJTVDJTVDc3VwcG9ydCU1QyU1Q3BhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOEtBQTBHIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxQeXRob25cXFxcdHJhdmVsLWRldGFpbC1kZW1vXFxcXGZyb250ZW5kXFxcXHNyY1xcXFxhcHBcXFxcc3VwcG9ydFxcXFxwYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CPython%5C%5Ctravel-detail-demo%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Csupport%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={529:(e,r,t)=>{var n=t(191);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},191:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(529);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXFB5dGhvblxcdHJhdmVsLWRldGFpbC1kZW1vXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxcbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cXGhtclxcaG90TW9kdWxlUmVwbGFjZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezUyOTooZSxyLHQpPT57dmFyIG49dCgxOTEpO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIGE9dHlwZW9mIGRvY3VtZW50PT09XCJ1bmRlZmluZWRcIjt2YXIgbz1BcnJheS5wcm90b3R5cGUuZm9yRWFjaDtmdW5jdGlvbiBkZWJvdW5jZShlLHIpe3ZhciB0PTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpczt2YXIgaT1hcmd1bWVudHM7dmFyIGE9ZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCl7cmV0dXJuIGUuYXBwbHkobixpKX07Y2xlYXJUaW1lb3V0KHQpO3Q9c2V0VGltZW91dChhLHIpfX1mdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwoZSl7dmFyIHI9aVtlXTtpZighcil7aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7cj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31lbHNle3ZhciB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO3ZhciBhPXRbdC5sZW5ndGgtMV07aWYoYSl7cj1hLnNyY319aVtlXT1yfXJldHVybiBmdW5jdGlvbihlKXtpZighcil7cmV0dXJuIG51bGx9dmFyIHQ9ci5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTt2YXIgaT10JiZ0WzFdO2lmKCFpKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1pZighZSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19cmV0dXJuIGUuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cChcIlwiLmNvbmNhdChpLFwiXFxcXC5qcyRcIiksXCJnXCIpO3JldHVybiBuKHIucmVwbGFjZSh0LFwiXCIuY29uY2F0KGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLGkpLFwiLmNzc1wiKSkpfSkpfX1mdW5jdGlvbiB1cGRhdGVDc3MoZSxyKXtpZighcil7aWYoIWUuaHJlZil7cmV0dXJufXI9ZS5ocmVmLnNwbGl0KFwiP1wiKVswXX1pZighaXNVcmxSZXF1ZXN0KHIpKXtyZXR1cm59aWYoZS5pc0xvYWRlZD09PWZhbHNlKXtyZXR1cm59aWYoIXJ8fCEoci5pbmRleE9mKFwiLmNzc1wiKT4tMSkpe3JldHVybn1lLnZpc2l0ZWQ9dHJ1ZTt2YXIgdD1lLmNsb25lTm9kZSgpO3QuaXNMb2FkZWQ9ZmFsc2U7dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5ocmVmPVwiXCIuY29uY2F0KHIsXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtpZihlLm5leHRTaWJsaW5nKXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9ZWxzZXtlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodCl9fWZ1bmN0aW9uIGdldFJlbG9hZFVybChlLHIpe3ZhciB0O2U9bihlLHtzdHJpcFdXVzpmYWxzZX0pO3Iuc29tZSgoZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKHIpPi0xKXt0PW59fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZFN0eWxlKGUpe2lmKCFlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7dmFyIHQ9ZmFsc2U7by5jYWxsKHIsKGZ1bmN0aW9uKHIpe2lmKCFyLmhyZWYpe3JldHVybn12YXIgbj1nZXRSZWxvYWRVcmwoci5ocmVmLGUpO2lmKCFpc1VybFJlcXVlc3Qobikpe3JldHVybn1pZihyLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59aWYobil7dXBkYXRlQ3NzKHIsbik7dD10cnVlfX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRBbGwoKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTtvLmNhbGwoZSwoZnVuY3Rpb24oZSl7aWYoZS52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufXVwZGF0ZUNzcyhlKX0pKX1mdW5jdGlvbiBpc1VybFJlcXVlc3QoZSl7aWYoIS9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLnRlc3QoZSkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZihhKXtjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtyZXR1cm4gbm9vcH12YXIgdD1nZXRDdXJyZW50U2NyaXB0VXJsKGUpO2Z1bmN0aW9uIHVwZGF0ZSgpe3ZhciBlPXQoci5maWxlbmFtZSk7dmFyIG49cmVsb2FkU3R5bGUoZSk7aWYoci5sb2NhbHMpe2NvbnNvbGUubG9nKFwiW0hNUl0gRGV0ZWN0ZWQgbG9jYWwgY3NzIG1vZHVsZXMuIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpO3JldHVybn1pZihuKXtjb25zb2xlLmxvZyhcIltITVJdIGNzcyByZWxvYWQgJXNcIixlLmpvaW4oXCIgXCIpKX1lbHNle2NvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCl9fXJldHVybiBkZWJvdW5jZSh1cGRhdGUsNTApfX0sMTkxOmU9PntmdW5jdGlvbiBub3JtYWxpemVVcmwoZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHIpe3N3aXRjaChyKXtjYXNlXCIuLlwiOmUucG9wKCk7YnJlYWs7Y2FzZVwiLlwiOmJyZWFrO2RlZmF1bHQ6ZS5wdXNoKHIpfXJldHVybiBlfSksW10pLmpvaW4oXCIvXCIpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtlPWUudHJpbSgpO2lmKC9eZGF0YTovaS50ZXN0KGUpKXtyZXR1cm4gZX12YXIgcj1lLmluZGV4T2YoXCIvL1wiKSE9PS0xP2Uuc3BsaXQoXCIvL1wiKVswXStcIi8vXCI6XCJcIjt2YXIgdD1lLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiaVwiKSxcIlwiKS5zcGxpdChcIi9cIik7dmFyIG49dFswXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLFwiXCIpO3RbMF09XCJcIjt2YXIgaT1ub3JtYWxpemVVcmwodCk7cmV0dXJuIHIrbitpfX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49clt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg1MjkpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\r\n * @license React\r\n * react-jsx-dev-runtime.development.js\r\n *\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\r\n true &&\r\n  (function () {\r\n    function getComponentNameFromType(type) {\r\n      if (null == type) return null;\r\n      if (\"function\" === typeof type)\r\n        return type.$$typeof === REACT_CLIENT_REFERENCE\r\n          ? null\r\n          : type.displayName || type.name || null;\r\n      if (\"string\" === typeof type) return type;\r\n      switch (type) {\r\n        case REACT_FRAGMENT_TYPE:\r\n          return \"Fragment\";\r\n        case REACT_PROFILER_TYPE:\r\n          return \"Profiler\";\r\n        case REACT_STRICT_MODE_TYPE:\r\n          return \"StrictMode\";\r\n        case REACT_SUSPENSE_TYPE:\r\n          return \"Suspense\";\r\n        case REACT_SUSPENSE_LIST_TYPE:\r\n          return \"SuspenseList\";\r\n        case REACT_ACTIVITY_TYPE:\r\n          return \"Activity\";\r\n      }\r\n      if (\"object\" === typeof type)\r\n        switch (\r\n          (\"number\" === typeof type.tag &&\r\n            console.error(\r\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\r\n            ),\r\n          type.$$typeof)\r\n        ) {\r\n          case REACT_PORTAL_TYPE:\r\n            return \"Portal\";\r\n          case REACT_CONTEXT_TYPE:\r\n            return (type.displayName || \"Context\") + \".Provider\";\r\n          case REACT_CONSUMER_TYPE:\r\n            return (type._context.displayName || \"Context\") + \".Consumer\";\r\n          case REACT_FORWARD_REF_TYPE:\r\n            var innerType = type.render;\r\n            type = type.displayName;\r\n            type ||\r\n              ((type = innerType.displayName || innerType.name || \"\"),\r\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\r\n            return type;\r\n          case REACT_MEMO_TYPE:\r\n            return (\r\n              (innerType = type.displayName || null),\r\n              null !== innerType\r\n                ? innerType\r\n                : getComponentNameFromType(type.type) || \"Memo\"\r\n            );\r\n          case REACT_LAZY_TYPE:\r\n            innerType = type._payload;\r\n            type = type._init;\r\n            try {\r\n              return getComponentNameFromType(type(innerType));\r\n            } catch (x) {}\r\n        }\r\n      return null;\r\n    }\r\n    function testStringCoercion(value) {\r\n      return \"\" + value;\r\n    }\r\n    function checkKeyStringCoercion(value) {\r\n      try {\r\n        testStringCoercion(value);\r\n        var JSCompiler_inline_result = !1;\r\n      } catch (e) {\r\n        JSCompiler_inline_result = !0;\r\n      }\r\n      if (JSCompiler_inline_result) {\r\n        JSCompiler_inline_result = console;\r\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\r\n        var JSCompiler_inline_result$jscomp$0 =\r\n          (\"function\" === typeof Symbol &&\r\n            Symbol.toStringTag &&\r\n            value[Symbol.toStringTag]) ||\r\n          value.constructor.name ||\r\n          \"Object\";\r\n        JSCompiler_temp_const.call(\r\n          JSCompiler_inline_result,\r\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\r\n          JSCompiler_inline_result$jscomp$0\r\n        );\r\n        return testStringCoercion(value);\r\n      }\r\n    }\r\n    function getTaskName(type) {\r\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\r\n      if (\r\n        \"object\" === typeof type &&\r\n        null !== type &&\r\n        type.$$typeof === REACT_LAZY_TYPE\r\n      )\r\n        return \"<...>\";\r\n      try {\r\n        var name = getComponentNameFromType(type);\r\n        return name ? \"<\" + name + \">\" : \"<...>\";\r\n      } catch (x) {\r\n        return \"<...>\";\r\n      }\r\n    }\r\n    function getOwner() {\r\n      var dispatcher = ReactSharedInternals.A;\r\n      return null === dispatcher ? null : dispatcher.getOwner();\r\n    }\r\n    function UnknownOwner() {\r\n      return Error(\"react-stack-top-frame\");\r\n    }\r\n    function hasValidKey(config) {\r\n      if (hasOwnProperty.call(config, \"key\")) {\r\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\r\n        if (getter && getter.isReactWarning) return !1;\r\n      }\r\n      return void 0 !== config.key;\r\n    }\r\n    function defineKeyPropWarningGetter(props, displayName) {\r\n      function warnAboutAccessingKey() {\r\n        specialPropKeyWarningShown ||\r\n          ((specialPropKeyWarningShown = !0),\r\n          console.error(\r\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\r\n            displayName\r\n          ));\r\n      }\r\n      warnAboutAccessingKey.isReactWarning = !0;\r\n      Object.defineProperty(props, \"key\", {\r\n        get: warnAboutAccessingKey,\r\n        configurable: !0\r\n      });\r\n    }\r\n    function elementRefGetterWithDeprecationWarning() {\r\n      var componentName = getComponentNameFromType(this.type);\r\n      didWarnAboutElementRef[componentName] ||\r\n        ((didWarnAboutElementRef[componentName] = !0),\r\n        console.error(\r\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\r\n        ));\r\n      componentName = this.props.ref;\r\n      return void 0 !== componentName ? componentName : null;\r\n    }\r\n    function ReactElement(\r\n      type,\r\n      key,\r\n      self,\r\n      source,\r\n      owner,\r\n      props,\r\n      debugStack,\r\n      debugTask\r\n    ) {\r\n      self = props.ref;\r\n      type = {\r\n        $$typeof: REACT_ELEMENT_TYPE,\r\n        type: type,\r\n        key: key,\r\n        props: props,\r\n        _owner: owner\r\n      };\r\n      null !== (void 0 !== self ? self : null)\r\n        ? Object.defineProperty(type, \"ref\", {\r\n            enumerable: !1,\r\n            get: elementRefGetterWithDeprecationWarning\r\n          })\r\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\r\n      type._store = {};\r\n      Object.defineProperty(type._store, \"validated\", {\r\n        configurable: !1,\r\n        enumerable: !1,\r\n        writable: !0,\r\n        value: 0\r\n      });\r\n      Object.defineProperty(type, \"_debugInfo\", {\r\n        configurable: !1,\r\n        enumerable: !1,\r\n        writable: !0,\r\n        value: null\r\n      });\r\n      Object.defineProperty(type, \"_debugStack\", {\r\n        configurable: !1,\r\n        enumerable: !1,\r\n        writable: !0,\r\n        value: debugStack\r\n      });\r\n      Object.defineProperty(type, \"_debugTask\", {\r\n        configurable: !1,\r\n        enumerable: !1,\r\n        writable: !0,\r\n        value: debugTask\r\n      });\r\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\r\n      return type;\r\n    }\r\n    function jsxDEVImpl(\r\n      type,\r\n      config,\r\n      maybeKey,\r\n      isStaticChildren,\r\n      source,\r\n      self,\r\n      debugStack,\r\n      debugTask\r\n    ) {\r\n      var children = config.children;\r\n      if (void 0 !== children)\r\n        if (isStaticChildren)\r\n          if (isArrayImpl(children)) {\r\n            for (\r\n              isStaticChildren = 0;\r\n              isStaticChildren < children.length;\r\n              isStaticChildren++\r\n            )\r\n              validateChildKeys(children[isStaticChildren]);\r\n            Object.freeze && Object.freeze(children);\r\n          } else\r\n            console.error(\r\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\r\n            );\r\n        else validateChildKeys(children);\r\n      if (hasOwnProperty.call(config, \"key\")) {\r\n        children = getComponentNameFromType(type);\r\n        var keys = Object.keys(config).filter(function (k) {\r\n          return \"key\" !== k;\r\n        });\r\n        isStaticChildren =\r\n          0 < keys.length\r\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\r\n            : \"{key: someKey}\";\r\n        didWarnAboutKeySpread[children + isStaticChildren] ||\r\n          ((keys =\r\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\r\n          console.error(\r\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\r\n            isStaticChildren,\r\n            children,\r\n            keys,\r\n            children\r\n          ),\r\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\r\n      }\r\n      children = null;\r\n      void 0 !== maybeKey &&\r\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\r\n      hasValidKey(config) &&\r\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\r\n      if (\"key\" in config) {\r\n        maybeKey = {};\r\n        for (var propName in config)\r\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\r\n      } else maybeKey = config;\r\n      children &&\r\n        defineKeyPropWarningGetter(\r\n          maybeKey,\r\n          \"function\" === typeof type\r\n            ? type.displayName || type.name || \"Unknown\"\r\n            : type\r\n        );\r\n      return ReactElement(\r\n        type,\r\n        children,\r\n        self,\r\n        source,\r\n        getOwner(),\r\n        maybeKey,\r\n        debugStack,\r\n        debugTask\r\n      );\r\n    }\r\n    function validateChildKeys(node) {\r\n      \"object\" === typeof node &&\r\n        null !== node &&\r\n        node.$$typeof === REACT_ELEMENT_TYPE &&\r\n        node._store &&\r\n        (node._store.validated = 1);\r\n    }\r\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\r\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\r\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\r\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\r\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\r\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\r\n    Symbol.for(\"react.provider\");\r\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\r\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\r\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\r\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\r\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\r\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\r\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\r\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\r\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\r\n      ReactSharedInternals =\r\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\r\n      hasOwnProperty = Object.prototype.hasOwnProperty,\r\n      isArrayImpl = Array.isArray,\r\n      createTask = console.createTask\r\n        ? console.createTask\r\n        : function () {\r\n            return null;\r\n          };\r\n    React = {\r\n      \"react-stack-bottom-frame\": function (callStackForError) {\r\n        return callStackForError();\r\n      }\r\n    };\r\n    var specialPropKeyWarningShown;\r\n    var didWarnAboutElementRef = {};\r\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\r\n      React,\r\n      UnknownOwner\r\n    )();\r\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\r\n    var didWarnAboutKeySpread = {};\r\n    exports.Fragment = REACT_FRAGMENT_TYPE;\r\n    exports.jsxDEV = function (\r\n      type,\r\n      config,\r\n      maybeKey,\r\n      isStaticChildren,\r\n      source,\r\n      self\r\n    ) {\r\n      var trackActualOwner =\r\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\r\n      return jsxDEVImpl(\r\n        type,\r\n        config,\r\n        maybeKey,\r\n        isStaticChildren,\r\n        source,\r\n        self,\r\n        trackActualOwner\r\n          ? Error(\"react-stack-top-frame\")\r\n          : unknownOwnerDebugStack,\r\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\r\n      );\r\n    };\r\n  })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0Q7QUFDaEUsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLGdDQUFnQyxrQ0FBa0MsT0FBTztBQUN6RTtBQUNBLGdHQUFnRyxTQUFTLFVBQVUsc0ZBQXNGLGFBQWEsVUFBVSxVQUFVO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiRDpcXFB5dGhvblxcdHJhdmVsLWRldGFpbC1kZW1vXFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGNqc1xccmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZSBSZWFjdFxyXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcclxuICpcclxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cclxuICovXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XHJcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xyXG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcclxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxyXG4gICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XHJcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XHJcbiAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcclxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XHJcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxyXG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcclxuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XHJcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XHJcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxyXG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcclxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xyXG4gICAgICAgIGNhc2UgUkVBQ1RfQUNUSVZJVFlfVFlQRTpcclxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxyXG4gICAgICAgIHN3aXRjaCAoXHJcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcclxuICAgICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcclxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XHJcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xyXG4gICAgICAgICAgICB0eXBlIHx8XHJcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxyXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXHJcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXHJcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxyXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XHJcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cclxuICAgICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcclxuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XHJcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcclxuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xyXG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxyXG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxyXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcclxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcclxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcclxuICAgICAgICAgIFwiT2JqZWN0XCI7XHJcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXHJcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXHJcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXHJcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcclxuICAgICAgICBudWxsICE9PSB0eXBlICYmXHJcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXHJcbiAgICAgIClcclxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xyXG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcclxuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xyXG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XHJcbiAgICAgIHJldHVybiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xyXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XHJcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XHJcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XHJcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcclxuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxyXG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXHJcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXHJcbiAgICAgICAgICApKTtcclxuICAgICAgfVxyXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XHJcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xyXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xyXG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XHJcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxyXG4gICAgICAgICkpO1xyXG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XHJcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcclxuICAgICAgdHlwZSxcclxuICAgICAga2V5LFxyXG4gICAgICBzZWxmLFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG93bmVyLFxyXG4gICAgICBwcm9wcyxcclxuICAgICAgZGVidWdTdGFjayxcclxuICAgICAgZGVidWdUYXNrXHJcbiAgICApIHtcclxuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcclxuICAgICAgdHlwZSA9IHtcclxuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgcHJvcHM6IHByb3BzLFxyXG4gICAgICAgIF9vd25lcjogb3duZXJcclxuICAgICAgfTtcclxuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxyXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXHJcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XHJcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXHJcbiAgICAgICAgZW51bWVyYWJsZTogITEsXHJcbiAgICAgICAgd3JpdGFibGU6ICEwLFxyXG4gICAgICAgIHZhbHVlOiAwXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6ICExLFxyXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxyXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcclxuICAgICAgICB2YWx1ZTogbnVsbFxyXG4gICAgICB9KTtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXHJcbiAgICAgICAgZW51bWVyYWJsZTogITEsXHJcbiAgICAgICAgd3JpdGFibGU6ICEwLFxyXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6ICExLFxyXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxyXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcclxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXHJcbiAgICAgIH0pO1xyXG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcclxuICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxyXG4gICAgICB0eXBlLFxyXG4gICAgICBjb25maWcsXHJcbiAgICAgIG1heWJlS2V5LFxyXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHNlbGYsXHJcbiAgICAgIGRlYnVnU3RhY2ssXHJcbiAgICAgIGRlYnVnVGFza1xyXG4gICAgKSB7XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcclxuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXHJcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXHJcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGZvciAoXHJcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XHJcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcclxuICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cclxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxyXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxyXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcclxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxyXG4gICAgICAgICAgKChrZXlzID1cclxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxyXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxyXG4gICAgICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICAgICAga2V5cyxcclxuICAgICAgICAgICAgY2hpbGRyZW5cclxuICAgICAgICAgICksXHJcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxyXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XHJcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcclxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcclxuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXHJcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XHJcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcclxuICAgICAgY2hpbGRyZW4gJiZcclxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcclxuICAgICAgICAgIG1heWJlS2V5LFxyXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxyXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXHJcbiAgICAgICAgICAgIDogdHlwZVxyXG4gICAgICAgICk7XHJcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBzZWxmLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBnZXRPd25lcigpLFxyXG4gICAgICAgIG1heWJlS2V5LFxyXG4gICAgICAgIGRlYnVnU3RhY2ssXHJcbiAgICAgICAgZGVidWdUYXNrXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XHJcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXHJcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxyXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxyXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXHJcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xyXG4gICAgfVxyXG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcclxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxyXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXHJcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXHJcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXHJcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XHJcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XHJcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcclxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXHJcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXHJcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXHJcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxyXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcclxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXHJcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXHJcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcclxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxyXG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcclxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXHJcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcclxuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xyXG4gICAgICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH07XHJcbiAgICBSZWFjdCA9IHtcclxuICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XHJcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xyXG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKFxyXG4gICAgICBSZWFjdCxcclxuICAgICAgVW5rbm93bk93bmVyXHJcbiAgICApKCk7XHJcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdUYXNrID0gY3JlYXRlVGFzayhnZXRUYXNrTmFtZShVbmtub3duT3duZXIpKTtcclxuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcclxuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xyXG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIGNvbmZpZyxcclxuICAgICAgbWF5YmVLZXksXHJcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgc2VsZlxyXG4gICAgKSB7XHJcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cclxuICAgICAgICAxZTQgPiBSZWFjdFNoYXJlZEludGVybmFscy5yZWNlbnRseUNyZWF0ZWRPd25lclN0YWNrcysrO1xyXG4gICAgICByZXR1cm4ganN4REVWSW1wbChcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIGNvbmZpZyxcclxuICAgICAgICBtYXliZUtleSxcclxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBzZWxmLFxyXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcclxuICAgICAgICAgID8gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIilcclxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcclxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcclxuICAgICAgKTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOExBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXGNvbXBpbGVkXFxyZWFjdFxcanN4LWRldi1ydW50aW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5qcycpO1xyXG59IGVsc2Uge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/styles/SupportPage.module.css":
/*!***********************************************!*\
  !*** ./src/app/styles/SupportPage.module.css ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"SupportPage_main__VvHbu\",\"controlSection\":\"SupportPage_controlSection__ujsy7\"};\n    if(true) {\n      // 1750490353262\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"d40ed7beb367\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3R5bGVzL1N1cHBvcnRQYWdlLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTJILGNBQWMsc0RBQXNEO0FBQzdOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXHNyY1xcYXBwXFxzdHlsZXNcXFN1cHBvcnRQYWdlLm1vZHVsZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcIm1haW5cIjpcIlN1cHBvcnRQYWdlX21haW5fX1Z2SGJ1XCIsXCJjb250cm9sU2VjdGlvblwiOlwiU3VwcG9ydFBhZ2VfY29udHJvbFNlY3Rpb25fX3Vqc3k3XCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NTA0OTAzNTMyNjJcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiRDovUHl0aG9uL3RyYXZlbC1kZXRhaWwtZGVtby9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCJkNDBlZDdiZWIzNjdcIlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/styles/SupportPage.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/support/page.tsx":
/*!**********************************!*\
  !*** ./src/app/support/page.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Page)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/room-889cObLb.mjs\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _styles_SupportPage_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/SupportPage.module.css */ \"(app-pages-browser)/./src/app/styles/SupportPage.module.css\");\n/* harmony import */ var _styles_SupportPage_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_SupportPage_module_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_livekit_SimpleVoiceAssistant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/livekit/SimpleVoiceAssistant */ \"(app-pages-browser)/./src/components/livekit/SimpleVoiceAssistant.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Page() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const serverUrl = \"wss://travelop-08yu97jy.livekit.cloud\";\n    const token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTQ2NDM4NDUsImlzcyI6IkFQSUNtaGtDanZuRlFUVCIsIm5iZiI6MTc1MDg0Mzg0NSwic3ViIjoieWFzYXMiLCJ2aWRlbyI6eyJjYW5QdWJsaXNoIjp0cnVlLCJjYW5QdWJsaXNoRGF0YSI6dHJ1ZSwiY2FuU3Vic2NyaWJlIjp0cnVlLCJyb29tIjoieWFzYXMiLCJyb29tSm9pbiI6dHJ1ZX19.K3zdq6GLWLgiAedgDbt1hLMTx7mqQbmzraGqW7mQslE\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_SupportPage_module_css__WEBPACK_IMPORTED_MODULE_2___default().main),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_styles_SupportPage_module_css__WEBPACK_IMPORTED_MODULE_2___default().controlSection),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.L, {\n                serverUrl: serverUrl,\n                token: token,\n                connect: true,\n                video: false,\n                audio: false,\n                onDisconnected: ()=>router.push('/'),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_5__.R, {}, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\app\\\\support\\\\page.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_livekit_SimpleVoiceAssistant__WEBPACK_IMPORTED_MODULE_3__.SimpleVoiceAssistant, {}, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\app\\\\support\\\\page.tsx\",\n                        lineNumber: 29,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\app\\\\support\\\\page.tsx\",\n                lineNumber: 20,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\app\\\\support\\\\page.tsx\",\n            lineNumber: 19,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\app\\\\support\\\\page.tsx\",\n        lineNumber: 18,\n        columnNumber: 5\n    }, this);\n}\n_s(Page, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter\n    ];\n});\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc3VwcG9ydC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBS21DO0FBQ1M7QUFDVTtBQUN5QjtBQUVoRSxTQUFTSzs7SUFDdEIsTUFBTUMsU0FBU0osMERBQVNBO0lBRXhCLE1BQU1LLFlBQVlDLHVDQUEwQztJQUM1RCxNQUFNRyxRQUFRSCwyVEFBcUM7SUFFbkQscUJBQ0UsOERBQUNLO1FBQUlDLFdBQVdYLDRFQUFXO2tCQUN6Qiw0RUFBQ1U7WUFBSUMsV0FBV1gsc0ZBQXFCO3NCQUNuQyw0RUFBQ0gsd0RBQVdBO2dCQUNWTyxXQUFXQTtnQkFDWEksT0FBT0E7Z0JBQ1BNLFNBQVM7Z0JBQ1RDLE9BQU87Z0JBQ1BDLE9BQU87Z0JBQ1BDLGdCQUFnQixJQUFNZCxPQUFPZSxJQUFJLENBQUM7O2tDQUVsQyw4REFBQ3BCLHdEQUFpQkE7Ozs7O2tDQUNsQiw4REFBQ0csMEZBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSy9CO0dBdkJ3QkM7O1FBQ1BILHNEQUFTQTs7O0tBREZHIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxzcmNcXGFwcFxcc3VwcG9ydFxccGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHtcclxuICBMaXZlS2l0Um9vbSxcclxuICBSb29tQXVkaW9SZW5kZXJlclxyXG59IGZyb20gXCJAbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuLi9zdHlsZXMvU3VwcG9ydFBhZ2UubW9kdWxlLmNzcyc7XHJcbmltcG9ydCB7U2ltcGxlVm9pY2VBc3Npc3RhbnR9IGZyb20gXCJAL2NvbXBvbmVudHMvbGl2ZWtpdC9TaW1wbGVWb2ljZUFzc2lzdGFudFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGFnZSgpIHtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgY29uc3Qgc2VydmVyVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTElWRUtJVF9TRVJWRVJfVVJMO1xyXG4gIGNvbnN0IHRva2VuID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTElWRUtJVF9UT0tFTjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubWFpbn0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udHJvbFNlY3Rpb259PlxyXG4gICAgICAgIDxMaXZlS2l0Um9vbVxyXG4gICAgICAgICAgc2VydmVyVXJsPXtzZXJ2ZXJVcmx9XHJcbiAgICAgICAgICB0b2tlbj17dG9rZW59XHJcbiAgICAgICAgICBjb25uZWN0PXt0cnVlfVxyXG4gICAgICAgICAgdmlkZW89e2ZhbHNlfVxyXG4gICAgICAgICAgYXVkaW89e2ZhbHNlfVxyXG4gICAgICAgICAgb25EaXNjb25uZWN0ZWQ9eygpID0+IHJvdXRlci5wdXNoKCcvJyl9XHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgPFJvb21BdWRpb1JlbmRlcmVyIC8+XHJcbiAgICAgICAgICA8U2ltcGxlVm9pY2VBc3Npc3RhbnQgLz5cclxuICAgICAgICA8L0xpdmVLaXRSb29tPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn0iXSwibmFtZXMiOlsiTGl2ZUtpdFJvb20iLCJSb29tQXVkaW9SZW5kZXJlciIsInVzZVJvdXRlciIsInN0eWxlcyIsIlNpbXBsZVZvaWNlQXNzaXN0YW50IiwiUGFnZSIsInJvdXRlciIsInNlcnZlclVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19MSVZFS0lUX1NFUlZFUl9VUkwiLCJ0b2tlbiIsIk5FWFRfUFVCTElDX0xJVkVLSVRfVE9LRU4iLCJkaXYiLCJjbGFzc05hbWUiLCJtYWluIiwiY29udHJvbFNlY3Rpb24iLCJjb25uZWN0IiwidmlkZW8iLCJhdWRpbyIsIm9uRGlzY29ubmVjdGVkIiwicHVzaCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/support/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/ChatVisualizer.tsx":
/*!***************************************************!*\
  !*** ./src/components/livekit/ChatVisualizer.tsx ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatVisualizer: () => (/* binding */ ChatVisualizer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/hooks-OJtwh4jO.mjs\");\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs\");\n/* harmony import */ var _styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/ChatVisualizer.module.css */ \"(app-pages-browser)/./src/components/livekit/styles/ChatVisualizer.module.css\");\n/* harmony import */ var _styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction ChatVisualizer() {\n    _s();\n    const { state, audioTrack, agentTranscriptions } = (0,_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.V)();\n    const localParticipant = (0,_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.C)();\n    const { segments: userSegments } = (0,_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.U)({\n        publication: localParticipant.microphoneTrack,\n        source: livekit_client__WEBPACK_IMPORTED_MODULE_3__.Track.Source.Microphone,\n        participant: localParticipant.localParticipant\n    });\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ChatVisualizer.useEffect\": ()=>{\n            const msgs = [];\n            userSegments === null || userSegments === void 0 ? void 0 : userSegments.forEach({\n                \"ChatVisualizer.useEffect\": (seg)=>{\n                    var _seg_firstReceivedTime;\n                    msgs.push({\n                        message: seg.text,\n                        from: {\n                            name: \"You\",\n                            identity: \"user\",\n                            isLocal: true\n                        },\n                        timestamp: (_seg_firstReceivedTime = seg.firstReceivedTime) !== null && _seg_firstReceivedTime !== void 0 ? _seg_firstReceivedTime : Date.now()\n                    });\n                }\n            }[\"ChatVisualizer.useEffect\"]);\n            agentTranscriptions === null || agentTranscriptions === void 0 ? void 0 : agentTranscriptions.forEach({\n                \"ChatVisualizer.useEffect\": (seg)=>{\n                    var _seg_firstReceivedTime;\n                    msgs.push({\n                        message: seg.text,\n                        from: {\n                            name: \"Agent\",\n                            identity: \"agent\",\n                            isLocal: false\n                        },\n                        timestamp: (_seg_firstReceivedTime = seg.firstReceivedTime) !== null && _seg_firstReceivedTime !== void 0 ? _seg_firstReceivedTime : Date.now()\n                    });\n                }\n            }[\"ChatVisualizer.useEffect\"]);\n            msgs.sort({\n                \"ChatVisualizer.useEffect\": (a, b)=>a.timestamp - b.timestamp\n            }[\"ChatVisualizer.useEffect\"]);\n            setMessages(msgs);\n        }\n    }[\"ChatVisualizer.useEffect\"], [\n        userSegments,\n        agentTranscriptions\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().mainContainer),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().section), \" \").concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().messageSection)),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-[24px] mt-1 mb-8\",\n                        children: \"Chat\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().msgSection),\n                        children: messages.map((msg, index)=>{\n                            const isAgent = msg.from.identity === \"agent\";\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().chatContainer), \" \").concat(isAgent ? (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().userContainer) : (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().agentContainer)),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().chatBubble), \" \").concat(isAgent ? (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().agentBubble) : (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().userBubble)),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().chatHeader), \" \").concat(isAgent ? (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().agentHeader) : (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().userHeader)),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().name),\n                                                    children: msg.from.name\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                                    lineNumber: 73,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().time),\n                                                    children: new Date(msg.timestamp).toLocaleTimeString([], {\n                                                        hour: \"2-digit\",\n                                                        minute: \"2-digit\"\n                                                    })\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                                    lineNumber: 74,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                            lineNumber: 72,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().chatMessage), \" \").concat(isAgent ? (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().agentMsg) : (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().userMsg)),\n                                            children: msg.message\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                            lineNumber: 81,\n                                            columnNumber: 19\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                    lineNumber: 68,\n                                    columnNumber: 17\n                                }, this)\n                            }, index, false, {\n                                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                                lineNumber: 62,\n                                columnNumber: 15\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                lineNumber: 56,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().section), \" \").concat((_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().visualizerSection)),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-[24px] mt-1\",\n                        children: \"Visualizer\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_5__.B, {\n                        state: state,\n                        trackRef: audioTrack,\n                        className: (_styles_ChatVisualizer_module_css__WEBPACK_IMPORTED_MODULE_1___default().visualizer),\n                        barCount: 5\n                    }, void 0, false, {\n                        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                        lineNumber: 91,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n                lineNumber: 89,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\ChatVisualizer.tsx\",\n        lineNumber: 55,\n        columnNumber: 5\n    }, this);\n}\n_s(ChatVisualizer, \"mNxA9I4sSxVMvs+Kf5OKfDDoYgg=\", false, function() {\n    return [\n        _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.V,\n        _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.C,\n        _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.U\n    ];\n});\n_c = ChatVisualizer;\nvar _c;\n$RefreshReg$(_c, \"ChatVisualizer\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvQ2hhdFZpc3VhbGl6ZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBS21DO0FBQ3FCO0FBQ1o7QUFDTDtBQUVoQyxTQUFTUTs7SUFDZCxNQUFNLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxtQkFBbUIsRUFBRSxHQUFHUiw0REFBaUJBO0lBQ3BFLE1BQU1TLG1CQUFtQlgsNERBQW1CQTtJQUU1QyxNQUFNLEVBQUVZLFVBQVVDLFlBQVksRUFBRSxHQUFHWiw0REFBcUJBLENBQUM7UUFDdkRhLGFBQWFILGlCQUFpQkksZUFBZTtRQUM3Q0MsUUFBUVYsaURBQUtBLENBQUNXLE1BQU0sQ0FBQ0MsVUFBVTtRQUMvQkMsYUFBYVIsaUJBQWlCQSxnQkFBZ0I7SUFDaEQ7SUFFQSxNQUFNLENBQUNTLFVBQVVDLFlBQVksR0FBR2hCLCtDQUFRQSxDQUFDLEVBQUU7SUFFM0NELGdEQUFTQTtvQ0FBQztZQUNSLE1BQU1rQixPQUFPLEVBQUU7WUFFZlQseUJBQUFBLG1DQUFBQSxhQUFjVSxPQUFPOzRDQUFDLENBQUNDO3dCQVFSQTtvQkFQYkYsS0FBS0csSUFBSSxDQUFDO3dCQUNSQyxTQUFTRixJQUFJRyxJQUFJO3dCQUNqQkMsTUFBTTs0QkFDSkMsTUFBTTs0QkFDTkMsVUFBVTs0QkFDVkMsU0FBUzt3QkFDWDt3QkFDQUMsV0FBV1IsQ0FBQUEseUJBQUFBLElBQUlTLGlCQUFpQixjQUFyQlQsb0NBQUFBLHlCQUF5QlUsS0FBS0MsR0FBRztvQkFDOUM7Z0JBQ0Y7O1lBRUF6QixnQ0FBQUEsMENBQUFBLG9CQUFxQmEsT0FBTzs0Q0FBQyxDQUFDQzt3QkFRZkE7b0JBUGJGLEtBQUtHLElBQUksQ0FBQzt3QkFDUkMsU0FBU0YsSUFBSUcsSUFBSTt3QkFDakJDLE1BQU07NEJBQ0pDLE1BQU07NEJBQ05DLFVBQVU7NEJBQ1ZDLFNBQVM7d0JBQ1g7d0JBQ0FDLFdBQVdSLENBQUFBLHlCQUFBQSxJQUFJUyxpQkFBaUIsY0FBckJULG9DQUFBQSx5QkFBeUJVLEtBQUtDLEdBQUc7b0JBQzlDO2dCQUNGOztZQUVBYixLQUFLYyxJQUFJOzRDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVMLFNBQVMsR0FBR00sRUFBRU4sU0FBUzs7WUFDN0NYLFlBQVlDO1FBQ2Q7bUNBQUc7UUFBQ1Q7UUFBY0g7S0FBb0I7SUFFdEMscUJBQ0UsOERBQUM2QjtRQUFJQyxXQUFXckMsd0ZBQW9COzswQkFDbEMsOERBQUNvQztnQkFBSUMsV0FBVyxHQUFxQnJDLE9BQWxCQSxrRkFBYyxFQUFDLEtBQXlCLE9BQXRCQSx5RkFBcUI7O2tDQUN4RCw4REFBQ3lDO3dCQUFHSixXQUFVO2tDQUF3Qjs7Ozs7O2tDQUN0Qyw4REFBQ0Q7d0JBQUlDLFdBQVdyQyxxRkFBaUI7a0NBQzlCaUIsU0FBUzBCLEdBQUcsQ0FBQyxDQUFDQyxLQUFLQzs0QkFDbEIsTUFBTUMsVUFBVUYsSUFBSW5CLElBQUksQ0FBQ0UsUUFBUSxLQUFLOzRCQUN0QyxxQkFDRSw4REFBQ1M7Z0NBRUVDLFdBQVcsR0FDVlMsT0FEYTlDLHdGQUFvQixFQUFDLEtBRWxDLE9BREE4QyxVQUFVOUMsd0ZBQW9CLEdBQUdBLHlGQUFxQjswQ0FHeEQsNEVBQUNvQztvQ0FDQ0MsV0FBVyxHQUNUUyxPQURZOUMscUZBQWlCLEVBQUMsS0FFL0IsT0FEQzhDLFVBQVU5QyxzRkFBa0IsR0FBR0EscUZBQWlCOztzREFFbEQsOERBQUNvQzs0Q0FBSUMsV0FBVyxHQUF3QlMsT0FBckI5QyxxRkFBaUIsRUFBQyxLQUFvRCxPQUFqRDhDLFVBQVU5QyxzRkFBa0IsR0FBR0EscUZBQWlCOzs4REFDdEYsOERBQUN3RDtvREFBS25CLFdBQVdyQywrRUFBVzs4REFBRzRDLElBQUluQixJQUFJLENBQUNDLElBQUk7Ozs7Ozs4REFDNUMsOERBQUM4QjtvREFBS25CLFdBQVdyQywrRUFBVzs4REFDekIsSUFBSStCLEtBQUthLElBQUlmLFNBQVMsRUFBRTZCLGtCQUFrQixDQUFDLEVBQUUsRUFBRTt3REFDOUNDLE1BQU07d0RBQ05DLFFBQVE7b0RBQ1Y7Ozs7Ozs7Ozs7OztzREFHSiw4REFBQ0M7NENBQUV4QixXQUFXLEdBQXlCUyxPQUF0QjlDLHNGQUFrQixFQUFDLEtBQThDLE9BQTNDOEMsVUFBVTlDLG1GQUFlLEdBQUdBLGtGQUFjO3NEQUFLNEMsSUFBSXJCLE9BQU87Ozs7Ozs7Ozs7OzsrQkFsQjlGc0I7Ozs7O3dCQXNCWDs7Ozs7Ozs7Ozs7OzBCQUlKLDhEQUFDVDtnQkFBSUMsV0FBVyxHQUFxQnJDLE9BQWxCQSxrRkFBYyxFQUFDLEtBQTRCLE9BQXpCQSw0RkFBd0I7O2tDQUMzRCw4REFBQ3lDO3dCQUFHSixXQUFVO2tDQUFtQjs7Ozs7O2tDQUNqQyw4REFBQ3pDLHdEQUFhQTt3QkFDWlMsT0FBT0E7d0JBQ1A2RCxVQUFVNUQ7d0JBQ1YrQixXQUFXckMscUZBQWlCO3dCQUM1Qm9FLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtwQjtHQXpGZ0JoRTs7UUFDcUNMLHdEQUFpQkE7UUFDM0NGLHdEQUFtQkE7UUFFVEMsd0RBQXFCQTs7O0tBSjFDTSIsInNvdXJjZXMiOlsiRDpcXFB5dGhvblxcdHJhdmVsLWRldGFpbC1kZW1vXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxsaXZla2l0XFxDaGF0VmlzdWFsaXplci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBCYXJWaXN1YWxpemVyLFxyXG4gIHVzZUxvY2FsUGFydGljaXBhbnQsXHJcbiAgdXNlVHJhY2tUcmFuc2NyaXB0aW9uLFxyXG4gIHVzZVZvaWNlQXNzaXN0YW50LFxyXG59IGZyb20gXCJAbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSBcIi4vc3R5bGVzL0NoYXRWaXN1YWxpemVyLm1vZHVsZS5jc3NcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBUcmFjayB9IGZyb20gXCJsaXZla2l0LWNsaWVudFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENoYXRWaXN1YWxpemVyKCkge1xyXG4gIGNvbnN0IHsgc3RhdGUsIGF1ZGlvVHJhY2ssIGFnZW50VHJhbnNjcmlwdGlvbnMgfSA9IHVzZVZvaWNlQXNzaXN0YW50KCk7XHJcbiAgY29uc3QgbG9jYWxQYXJ0aWNpcGFudCA9IHVzZUxvY2FsUGFydGljaXBhbnQoKTtcclxuXHJcbiAgY29uc3QgeyBzZWdtZW50czogdXNlclNlZ21lbnRzIH0gPSB1c2VUcmFja1RyYW5zY3JpcHRpb24oe1xyXG4gICAgcHVibGljYXRpb246IGxvY2FsUGFydGljaXBhbnQubWljcm9waG9uZVRyYWNrLFxyXG4gICAgc291cmNlOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSxcclxuICAgIHBhcnRpY2lwYW50OiBsb2NhbFBhcnRpY2lwYW50LmxvY2FsUGFydGljaXBhbnQsXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGUoW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgbXNncyA9IFtdO1xyXG5cclxuICAgIHVzZXJTZWdtZW50cz8uZm9yRWFjaCgoc2VnKSA9PiB7XHJcbiAgICAgIG1zZ3MucHVzaCh7XHJcbiAgICAgICAgbWVzc2FnZTogc2VnLnRleHQsXHJcbiAgICAgICAgZnJvbToge1xyXG4gICAgICAgICAgbmFtZTogXCJZb3VcIixcclxuICAgICAgICAgIGlkZW50aXR5OiBcInVzZXJcIixcclxuICAgICAgICAgIGlzTG9jYWw6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0aW1lc3RhbXA6IHNlZy5maXJzdFJlY2VpdmVkVGltZSA/PyBEYXRlLm5vdygpLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFnZW50VHJhbnNjcmlwdGlvbnM/LmZvckVhY2goKHNlZykgPT4ge1xyXG4gICAgICBtc2dzLnB1c2goe1xyXG4gICAgICAgIG1lc3NhZ2U6IHNlZy50ZXh0LFxyXG4gICAgICAgIGZyb206IHtcclxuICAgICAgICAgIG5hbWU6IFwiQWdlbnRcIixcclxuICAgICAgICAgIGlkZW50aXR5OiBcImFnZW50XCIsXHJcbiAgICAgICAgICBpc0xvY2FsOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRpbWVzdGFtcDogc2VnLmZpcnN0UmVjZWl2ZWRUaW1lID8/IERhdGUubm93KCksXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbXNncy5zb3J0KChhLCBiKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcclxuICAgIHNldE1lc3NhZ2VzKG1zZ3MpO1xyXG4gIH0sIFt1c2VyU2VnbWVudHMsIGFnZW50VHJhbnNjcmlwdGlvbnNdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubWFpbkNvbnRhaW5lcn0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtzdHlsZXMuc2VjdGlvbn0gJHtzdHlsZXMubWVzc2FnZVNlY3Rpb259YH0+XHJcbiAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtWzI0cHhdIG10LTEgbWItOFwiPkNoYXQ8L2gxPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubXNnU2VjdGlvbn0+XHJcbiAgICAgICAgICB7bWVzc2FnZXMubWFwKChtc2csIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzQWdlbnQgPSBtc2cuZnJvbS5pZGVudGl0eSA9PT0gXCJhZ2VudFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMuY2hhdENvbnRhaW5lcn0gJHtcclxuICAgICAgICAgICAgICAgICAgaXNBZ2VudCA/IHN0eWxlcy51c2VyQ29udGFpbmVyIDogc3R5bGVzLmFnZW50Q29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgfWB9XHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5jaGF0QnViYmxlfSAke1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWdlbnQgPyBzdHlsZXMuYWdlbnRCdWJibGUgOiBzdHlsZXMudXNlckJ1YmJsZVxyXG4gICAgICAgICAgICAgICAgICB9YH0+XHJcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtzdHlsZXMuY2hhdEhlYWRlcn0gJHtpc0FnZW50ID8gc3R5bGVzLmFnZW50SGVhZGVyIDogc3R5bGVzLnVzZXJIZWFkZXJ9YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMubmFtZX0+e21zZy5mcm9tLm5hbWV9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnRpbWV9PlxyXG4gICAgICAgICAgICAgICAgICAgICAge25ldyBEYXRlKG1zZy50aW1lc3RhbXApLnRvTG9jYWxlVGltZVN0cmluZyhbXSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBcIjItZGlnaXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17YCR7c3R5bGVzLmNoYXRNZXNzYWdlfSAke2lzQWdlbnQgPyBzdHlsZXMuYWdlbnRNc2cgOiBzdHlsZXMudXNlck1zZ31gfT57bXNnLm1lc3NhZ2V9PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9KX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7c3R5bGVzLnNlY3Rpb259ICR7c3R5bGVzLnZpc3VhbGl6ZXJTZWN0aW9ufWB9PlxyXG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LVsyNHB4XSBtdC0xXCI+VmlzdWFsaXplcjwvaDE+XHJcbiAgICAgICAgPEJhclZpc3VhbGl6ZXJcclxuICAgICAgICAgIHN0YXRlPXtzdGF0ZX1cclxuICAgICAgICAgIHRyYWNrUmVmPXthdWRpb1RyYWNrfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudmlzdWFsaXplcn1cclxuICAgICAgICAgIGJhckNvdW50PXs1fVxyXG4gICAgICAgIC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiQmFyVmlzdWFsaXplciIsInVzZUxvY2FsUGFydGljaXBhbnQiLCJ1c2VUcmFja1RyYW5zY3JpcHRpb24iLCJ1c2VWb2ljZUFzc2lzdGFudCIsInN0eWxlcyIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiVHJhY2siLCJDaGF0VmlzdWFsaXplciIsInN0YXRlIiwiYXVkaW9UcmFjayIsImFnZW50VHJhbnNjcmlwdGlvbnMiLCJsb2NhbFBhcnRpY2lwYW50Iiwic2VnbWVudHMiLCJ1c2VyU2VnbWVudHMiLCJwdWJsaWNhdGlvbiIsIm1pY3JvcGhvbmVUcmFjayIsInNvdXJjZSIsIlNvdXJjZSIsIk1pY3JvcGhvbmUiLCJwYXJ0aWNpcGFudCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJtc2dzIiwiZm9yRWFjaCIsInNlZyIsInB1c2giLCJtZXNzYWdlIiwidGV4dCIsImZyb20iLCJuYW1lIiwiaWRlbnRpdHkiLCJpc0xvY2FsIiwidGltZXN0YW1wIiwiZmlyc3RSZWNlaXZlZFRpbWUiLCJEYXRlIiwibm93Iiwic29ydCIsImEiLCJiIiwiZGl2IiwiY2xhc3NOYW1lIiwibWFpbkNvbnRhaW5lciIsInNlY3Rpb24iLCJtZXNzYWdlU2VjdGlvbiIsImgxIiwibXNnU2VjdGlvbiIsIm1hcCIsIm1zZyIsImluZGV4IiwiaXNBZ2VudCIsImNoYXRDb250YWluZXIiLCJ1c2VyQ29udGFpbmVyIiwiYWdlbnRDb250YWluZXIiLCJjaGF0QnViYmxlIiwiYWdlbnRCdWJibGUiLCJ1c2VyQnViYmxlIiwiY2hhdEhlYWRlciIsImFnZW50SGVhZGVyIiwidXNlckhlYWRlciIsInNwYW4iLCJ0aW1lIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsInAiLCJjaGF0TWVzc2FnZSIsImFnZW50TXNnIiwidXNlck1zZyIsInZpc3VhbGl6ZXJTZWN0aW9uIiwidHJhY2tSZWYiLCJ2aXN1YWxpemVyIiwiYmFyQ291bnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/ChatVisualizer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/Controls.tsx":
/*!*********************************************!*\
  !*** ./src/components/livekit/Controls.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controls: () => (/* binding */ Controls)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _styles_Controls_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/Controls.module.css */ \"(app-pages-browser)/./src/components/livekit/styles/Controls.module.css\");\n/* harmony import */ var _styles_Controls_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_Controls_module_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _livekit_components_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @livekit/components-react */ \"(app-pages-browser)/./node_modules/@livekit/components-react/dist/components-BeK2vIib.mjs\");\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! livekit-client */ \"(app-pages-browser)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ Controls auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction Controls() {\n    _s();\n    const [micActive, setMicActive] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [cameraActive, setCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Controls_module_css__WEBPACK_IMPORTED_MODULE_1___default().bar),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.T, {\n                source: livekit_client__WEBPACK_IMPORTED_MODULE_2__.Track.Source.Camera,\n                onClick: ()=>setCameraActive(!cameraActive)\n            }, void 0, false, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\Controls.tsx\",\n                lineNumber: 13,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.T, {\n                source: livekit_client__WEBPACK_IMPORTED_MODULE_2__.Track.Source.Microphone,\n                onClick: ()=>setMicActive(!micActive)\n            }, void 0, false, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\Controls.tsx\",\n                lineNumber: 17,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_livekit_components_react__WEBPACK_IMPORTED_MODULE_4__.D, {\n                children: \"Disconnect\"\n            }, void 0, false, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\Controls.tsx\",\n                lineNumber: 21,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\Controls.tsx\",\n        lineNumber: 12,\n        columnNumber: 7\n    }, this);\n}\n_s(Controls, \"OdnAkR+w+oNFZfAFCBspOZJUi/4=\");\n_c = Controls;\nvar _c;\n$RefreshReg$(_c, \"Controls\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvQ29udHJvbHMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFDa0Q7QUFDc0I7QUFDakM7QUFDUjtBQUV4QixTQUFTSzs7SUFDZCxNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR0gsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDSSxjQUFjQyxnQkFBZ0IsR0FBR0wsK0NBQVFBLENBQUM7SUFFakQscUJBQ0ksOERBQUNNO1FBQUlDLFdBQVdYLHdFQUFVOzswQkFDcEIsOERBQUNDLHdEQUFXQTtnQkFDVlksUUFBUVYsaURBQUtBLENBQUNXLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDM0JDLFNBQVMsSUFBTVAsZ0JBQWdCLENBQUNEOzs7Ozs7MEJBRWxDLDhEQUFDUCx3REFBV0E7Z0JBQ1ZZLFFBQVFWLGlEQUFLQSxDQUFDVyxNQUFNLENBQUNHLFVBQVU7Z0JBQy9CRCxTQUFTLElBQU1ULGFBQWEsQ0FBQ0Q7Ozs7OzswQkFFL0IsOERBQUNKLHdEQUFnQkE7MEJBQUM7Ozs7Ozs7Ozs7OztBQUs5QjtHQW5CZ0JHO0tBQUFBIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGxpdmVraXRcXENvbnRyb2xzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMvQ29udHJvbHMubW9kdWxlLmNzcyc7XHJcbmltcG9ydCB7VHJhY2tUb2dnbGUsIERpc2Nvbm5lY3RCdXR0b259IGZyb20gXCJAbGl2ZWtpdC9jb21wb25lbnRzLXJlYWN0XCI7XHJcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSBcImxpdmVraXQtY2xpZW50XCI7XHJcbmltcG9ydCB7dXNlU3RhdGV9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvbnRyb2xzKCkge1xyXG4gIGNvbnN0IFttaWNBY3RpdmUsIHNldE1pY0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2NhbWVyYUFjdGl2ZSwgc2V0Q2FtZXJhQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5iYXJ9PlxyXG4gICAgICAgICAgICA8VHJhY2tUb2dnbGVcclxuICAgICAgICAgICAgICBzb3VyY2U9e1RyYWNrLlNvdXJjZS5DYW1lcmF9XHJcbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Q2FtZXJhQWN0aXZlKCFjYW1lcmFBY3RpdmUpfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8VHJhY2tUb2dnbGVcclxuICAgICAgICAgICAgICBzb3VyY2U9e1RyYWNrLlNvdXJjZS5NaWNyb3Bob25lfVxyXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldE1pY0FjdGl2ZSghbWljQWN0aXZlKX1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPERpc2Nvbm5lY3RCdXR0b24+XHJcbiAgICAgICAgICAgICAgRGlzY29ubmVjdFxyXG4gICAgICAgICAgICA8L0Rpc2Nvbm5lY3RCdXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gIClcclxufSJdLCJuYW1lcyI6WyJzdHlsZXMiLCJUcmFja1RvZ2dsZSIsIkRpc2Nvbm5lY3RCdXR0b24iLCJUcmFjayIsInVzZVN0YXRlIiwiQ29udHJvbHMiLCJtaWNBY3RpdmUiLCJzZXRNaWNBY3RpdmUiLCJjYW1lcmFBY3RpdmUiLCJzZXRDYW1lcmFBY3RpdmUiLCJkaXYiLCJjbGFzc05hbWUiLCJiYXIiLCJzb3VyY2UiLCJTb3VyY2UiLCJDYW1lcmEiLCJvbkNsaWNrIiwiTWljcm9waG9uZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/Controls.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/SimpleVoiceAssistant.tsx":
/*!*********************************************************!*\
  !*** ./src/components/livekit/SimpleVoiceAssistant.tsx ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimpleVoiceAssistant: () => (/* binding */ SimpleVoiceAssistant)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _styles_SimpleVoiceAssistant_module_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/SimpleVoiceAssistant.module.css */ \"(app-pages-browser)/./src/components/livekit/styles/SimpleVoiceAssistant.module.css\");\n/* harmony import */ var _styles_SimpleVoiceAssistant_module_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_SimpleVoiceAssistant_module_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_livekit_Controls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/livekit/Controls */ \"(app-pages-browser)/./src/components/livekit/Controls.tsx\");\n/* harmony import */ var _components_livekit_ChatVisualizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/livekit/ChatVisualizer */ \"(app-pages-browser)/./src/components/livekit/ChatVisualizer.tsx\");\n/* __next_internal_client_entry_do_not_use__ SimpleVoiceAssistant auto */ \n\n\n\nfunction SimpleVoiceAssistant() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_SimpleVoiceAssistant_module_css__WEBPACK_IMPORTED_MODULE_1___default().mainContainer),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_livekit_ChatVisualizer__WEBPACK_IMPORTED_MODULE_3__.ChatVisualizer, {}, void 0, false, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\SimpleVoiceAssistant.tsx\",\n                lineNumber: 9,\n                columnNumber: 11\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_livekit_Controls__WEBPACK_IMPORTED_MODULE_2__.Controls, {}, void 0, false, {\n                fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\SimpleVoiceAssistant.tsx\",\n                lineNumber: 10,\n                columnNumber: 11\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\Python\\\\travel-detail-demo\\\\frontend\\\\src\\\\components\\\\livekit\\\\SimpleVoiceAssistant.tsx\",\n        lineNumber: 8,\n        columnNumber: 7\n    }, this);\n}\n_c = SimpleVoiceAssistant;\nvar _c;\n$RefreshReg$(_c, \"SimpleVoiceAssistant\");\n\n\n;\r\n    // Wrapped in an IIFE to avoid polluting the global scope\r\n    ;\r\n    (function () {\r\n        var _a, _b;\r\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\r\n        // to extract CSS. For backwards compatibility, we need to check we're in a\r\n        // browser context before continuing.\r\n        if (typeof self !== 'undefined' &&\r\n            // AMP / No-JS mode does not inject these helpers:\r\n            '$RefreshHelpers$' in self) {\r\n            // @ts-ignore __webpack_module__ is global\r\n            var currentExports = module.exports;\r\n            // @ts-ignore __webpack_module__ is global\r\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\r\n            // This cannot happen in MainTemplate because the exports mismatch between\r\n            // templating and execution.\r\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\r\n            // A module can be accepted automatically based on its exports, e.g. when\r\n            // it is a Refresh Boundary.\r\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\r\n                // Save the previous exports signature on update so we can compare the boundary\r\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\r\n                module.hot.dispose(function (data) {\r\n                    data.prevSignature =\r\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\r\n                });\r\n                // Unconditionally accept an update to this module, we'll check if it's\r\n                // still a Refresh Boundary later.\r\n                // @ts-ignore importMeta is replaced in the loader\r\n                module.hot.accept();\r\n                // This field is set when the previous version of this module was a\r\n                // Refresh Boundary, letting us know we need to check for invalidation or\r\n                // enqueue an update.\r\n                if (prevSignature !== null) {\r\n                    // A boundary can become ineligible if its exports are incompatible\r\n                    // with the previous exports.\r\n                    //\r\n                    // For example, if you add/remove/change exports, we'll want to\r\n                    // re-execute the importing modules, and force those components to\r\n                    // re-render. Similarly, if you convert a class component to a\r\n                    // function, we want to invalidate the boundary.\r\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\r\n                        module.hot.invalidate();\r\n                    }\r\n                    else {\r\n                        self.$RefreshHelpers$.scheduleUpdate();\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Since we just executed the code for the module, it's possible that the\r\n                // new exports made it ineligible for being a boundary.\r\n                // We only care about the case when we were _previously_ a boundary,\r\n                // because we already accepted this update (accidental side effect).\r\n                var isNoLongerABoundary = prevSignature !== null;\r\n                if (isNoLongerABoundary) {\r\n                    module.hot.invalidate();\r\n                }\r\n            }\r\n        }\r\n    })();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvU2ltcGxlVm9pY2VBc3Npc3RhbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDOEQ7QUFDUDtBQUNZO0FBRTVELFNBQVNHO0lBQ2QscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVdMLDhGQUFvQjs7MEJBQ2hDLDhEQUFDRSw4RUFBY0E7Ozs7OzBCQUNmLDhEQUFDRCxrRUFBUUE7Ozs7Ozs7Ozs7O0FBR25CO0tBUGdCRSIsInNvdXJjZXMiOlsiRDpcXFB5dGhvblxcdHJhdmVsLWRldGFpbC1kZW1vXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxsaXZla2l0XFxTaW1wbGVWb2ljZUFzc2lzdGFudC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzL1NpbXBsZVZvaWNlQXNzaXN0YW50Lm1vZHVsZS5jc3MnO1xyXG5pbXBvcnQge0NvbnRyb2xzfSBmcm9tIFwiQC9jb21wb25lbnRzL2xpdmVraXQvQ29udHJvbHNcIjtcclxuaW1wb3J0IHtDaGF0VmlzdWFsaXplcn0gZnJvbSBcIkAvY29tcG9uZW50cy9saXZla2l0L0NoYXRWaXN1YWxpemVyXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlVm9pY2VBc3Npc3RhbnQoKSB7XHJcbiAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5tYWluQ29udGFpbmVyfT5cclxuICAgICAgICAgIDxDaGF0VmlzdWFsaXplciAvPlxyXG4gICAgICAgICAgPENvbnRyb2xzIC8+XHJcbiAgICAgIDwvZGl2PlxyXG4gIClcclxufSJdLCJuYW1lcyI6WyJzdHlsZXMiLCJDb250cm9scyIsIkNoYXRWaXN1YWxpemVyIiwiU2ltcGxlVm9pY2VBc3Npc3RhbnQiLCJkaXYiLCJjbGFzc05hbWUiLCJtYWluQ29udGFpbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/SimpleVoiceAssistant.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/styles/ChatVisualizer.module.css":
/*!*****************************************************************!*\
  !*** ./src/components/livekit/styles/ChatVisualizer.module.css ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"mainContainer\":\"ChatVisualizer_mainContainer__XQLE_\",\"section\":\"ChatVisualizer_section___XvNS\",\"messageSection\":\"ChatVisualizer_messageSection__qTo_G\",\"visualizerSection\":\"ChatVisualizer_visualizerSection__aF0n9\",\"msgSection\":\"ChatVisualizer_msgSection__30yST\",\"chatContainer\":\"ChatVisualizer_chatContainer__Nk0Ur\",\"chatBubble\":\"ChatVisualizer_chatBubble__5y1gM\",\"chatHeader\":\"ChatVisualizer_chatHeader__WeJS0\",\"name\":\"ChatVisualizer_name__9GmPy\",\"time\":\"ChatVisualizer_time__OTMgv\",\"chatMessage\":\"ChatVisualizer_chatMessage__N0Uj_\",\"agentContainer\":\"ChatVisualizer_agentContainer__1Ev5B\",\"userContainer\":\"ChatVisualizer_userContainer__Q0H5T\",\"agentBubble\":\"ChatVisualizer_agentBubble__7xlTw\",\"userBubble\":\"ChatVisualizer_userBubble__BXLC_\",\"agentMsg\":\"ChatVisualizer_agentMsg__V4VXc\",\"userMsg\":\"ChatVisualizer_userMsg__riC9N\",\"agentHeader\":\"ChatVisualizer_agentHeader__mDIVB\",\"userHeader\":\"ChatVisualizer_userHeader__DBNIz\"};\n    if(true) {\n      // 1750526795858\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"3c6b8bec8001\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvc3R5bGVzL0NoYXRWaXN1YWxpemVyLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTJILGNBQWMsc0RBQXNEO0FBQzdOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcbGl2ZWtpdFxcc3R5bGVzXFxDaGF0VmlzdWFsaXplci5tb2R1bGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJtYWluQ29udGFpbmVyXCI6XCJDaGF0VmlzdWFsaXplcl9tYWluQ29udGFpbmVyX19YUUxFX1wiLFwic2VjdGlvblwiOlwiQ2hhdFZpc3VhbGl6ZXJfc2VjdGlvbl9fX1h2TlNcIixcIm1lc3NhZ2VTZWN0aW9uXCI6XCJDaGF0VmlzdWFsaXplcl9tZXNzYWdlU2VjdGlvbl9fcVRvX0dcIixcInZpc3VhbGl6ZXJTZWN0aW9uXCI6XCJDaGF0VmlzdWFsaXplcl92aXN1YWxpemVyU2VjdGlvbl9fYUYwbjlcIixcIm1zZ1NlY3Rpb25cIjpcIkNoYXRWaXN1YWxpemVyX21zZ1NlY3Rpb25fXzMweVNUXCIsXCJjaGF0Q29udGFpbmVyXCI6XCJDaGF0VmlzdWFsaXplcl9jaGF0Q29udGFpbmVyX19OazBVclwiLFwiY2hhdEJ1YmJsZVwiOlwiQ2hhdFZpc3VhbGl6ZXJfY2hhdEJ1YmJsZV9fNXkxZ01cIixcImNoYXRIZWFkZXJcIjpcIkNoYXRWaXN1YWxpemVyX2NoYXRIZWFkZXJfX1dlSlMwXCIsXCJuYW1lXCI6XCJDaGF0VmlzdWFsaXplcl9uYW1lX185R21QeVwiLFwidGltZVwiOlwiQ2hhdFZpc3VhbGl6ZXJfdGltZV9fT1RNZ3ZcIixcImNoYXRNZXNzYWdlXCI6XCJDaGF0VmlzdWFsaXplcl9jaGF0TWVzc2FnZV9fTjBVal9cIixcImFnZW50Q29udGFpbmVyXCI6XCJDaGF0VmlzdWFsaXplcl9hZ2VudENvbnRhaW5lcl9fMUV2NUJcIixcInVzZXJDb250YWluZXJcIjpcIkNoYXRWaXN1YWxpemVyX3VzZXJDb250YWluZXJfX1EwSDVUXCIsXCJhZ2VudEJ1YmJsZVwiOlwiQ2hhdFZpc3VhbGl6ZXJfYWdlbnRCdWJibGVfXzd4bFR3XCIsXCJ1c2VyQnViYmxlXCI6XCJDaGF0VmlzdWFsaXplcl91c2VyQnViYmxlX19CWExDX1wiLFwiYWdlbnRNc2dcIjpcIkNoYXRWaXN1YWxpemVyX2FnZW50TXNnX19WNFZYY1wiLFwidXNlck1zZ1wiOlwiQ2hhdFZpc3VhbGl6ZXJfdXNlck1zZ19fcmlDOU5cIixcImFnZW50SGVhZGVyXCI6XCJDaGF0VmlzdWFsaXplcl9hZ2VudEhlYWRlcl9fbURJVkJcIixcInVzZXJIZWFkZXJcIjpcIkNoYXRWaXN1YWxpemVyX3VzZXJIZWFkZXJfX0RCTkl6XCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NTA1MjY3OTU4NThcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiRDovUHl0aG9uL3RyYXZlbC1kZXRhaWwtZGVtby9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCIzYzZiOGJlYzgwMDFcIlxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/styles/ChatVisualizer.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/styles/Controls.module.css":
/*!***********************************************************!*\
  !*** ./src/components/livekit/styles/Controls.module.css ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"bar\":\"Controls_bar__X4yHE\"};\n    if(true) {\n      // 1750502534621\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"a92df09736a1\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvc3R5bGVzL0NvbnRyb2xzLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTJILGNBQWMsc0RBQXNEO0FBQzdOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcbGl2ZWtpdFxcc3R5bGVzXFxDb250cm9scy5tb2R1bGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJiYXJcIjpcIkNvbnRyb2xzX2Jhcl9fWDR5SEVcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTc1MDUwMjUzNDYyMVxuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJEOi9QeXRob24vdHJhdmVsLWRldGFpbC1kZW1vL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzXCIpKG1vZHVsZS5pZCwge1wicHVibGljUGF0aFwiOlwiL19uZXh0L1wiLFwiZXNNb2R1bGVcIjpmYWxzZSxcImxvY2Fsc1wiOnRydWV9KTtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShjc3NSZWxvYWQpO1xuICAgICAgXG4gICAgfVxuICBcbm1vZHVsZS5leHBvcnRzLl9fY2hlY2tzdW0gPSBcImE5MmRmMDk3MzZhMVwiXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/styles/Controls.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/livekit/styles/SimpleVoiceAssistant.module.css":
/*!***********************************************************************!*\
  !*** ./src/components/livekit/styles/SimpleVoiceAssistant.module.css ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"mainContainer\":\"SimpleVoiceAssistant_mainContainer__8de6i\"};\n    if(true) {\n      // 1750490354499\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"8ebc939550e0\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xpdmVraXQvc3R5bGVzL1NpbXBsZVZvaWNlQXNzaXN0YW50Lm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQTJILGNBQWMsc0RBQXNEO0FBQzdOLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXHNyY1xcY29tcG9uZW50c1xcbGl2ZWtpdFxcc3R5bGVzXFxTaW1wbGVWb2ljZUFzc2lzdGFudC5tb2R1bGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJtYWluQ29udGFpbmVyXCI6XCJTaW1wbGVWb2ljZUFzc2lzdGFudF9tYWluQ29udGFpbmVyX184ZGU2aVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzUwNDkwMzU0NDk5XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIkQ6L1B5dGhvbi90cmF2ZWwtZGV0YWlsLWRlbW8vZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gIFxubW9kdWxlLmV4cG9ydHMuX19jaGVja3N1bSA9IFwiOGViYzkzOTU1MGUwXCJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/livekit/styles/SimpleVoiceAssistant.module.css\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5CPython%5C%5Ctravel-detail-demo%5C%5Cfrontend%5C%5Csrc%5C%5Capp%5C%5Csupport%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);