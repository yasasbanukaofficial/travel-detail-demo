"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gsap";
exports.ids = ["vendor-chunks/gsap"];
exports.modules = {

/***/ "(ssr)/./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: () => (/* binding */ CSSPlugin),\n/* harmony export */   _createElement: () => (/* binding */ _createElement),\n/* harmony export */   _getBBox: () => (/* binding */ _getBBox),\n/* harmony export */   checkPrefix: () => (/* binding */ _checkPropPrefix),\n/* harmony export */   \"default\": () => (/* binding */ CSSPlugin)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(ssr)/./node_modules/gsap/gsap-core.js\");\n/*!\r\n * CSSPlugin 3.13.0\r\n * https://gsap.com\r\n *\r\n * Copyright 2008-2025, GreenSock. All rights reserved.\r\n * Subject to the terms at https://gsap.com/standard-license\r\n * @author: Jack Doyle, jack@greensock.com\r\n*/\r\n\r\n/* eslint-disable */\r\n\r\n\r\nvar _win,\r\n    _doc,\r\n    _docElement,\r\n    _pluginInitted,\r\n    _tempDiv,\r\n    _tempDivStyler,\r\n    _recentSetterPlugin,\r\n    _reverting,\r\n    _windowExists = function _windowExists() {\r\n  return typeof window !== \"undefined\";\r\n},\r\n    _transformProps = {},\r\n    _RAD2DEG = 180 / Math.PI,\r\n    _DEG2RAD = Math.PI / 180,\r\n    _atan2 = Math.atan2,\r\n    _bigNum = 1e8,\r\n    _capsExp = /([A-Z])/g,\r\n    _horizontalExp = /(left|right|width|margin|padding|x)/i,\r\n    _complexExp = /[\\s,\\(]\\S/,\r\n    _propertyAliases = {\r\n  autoAlpha: \"opacity,visibility\",\r\n  scale: \"scaleX,scaleY\",\r\n  alpha: \"opacity\"\r\n},\r\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\r\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\r\n},\r\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\r\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\r\n},\r\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\r\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\r\n},\r\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\r\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\r\n  var value = data.s + data.c * ratio;\r\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\r\n},\r\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\r\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\r\n},\r\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\r\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\r\n},\r\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\r\n  return target.style[property] = value;\r\n},\r\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\r\n  return target.style.setProperty(property, value);\r\n},\r\n    _setterTransform = function _setterTransform(target, property, value) {\r\n  return target._gsap[property] = value;\r\n},\r\n    _setterScale = function _setterScale(target, property, value) {\r\n  return target._gsap.scaleX = target._gsap.scaleY = value;\r\n},\r\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\r\n  var cache = target._gsap;\r\n  cache.scaleX = cache.scaleY = value;\r\n  cache.renderTransform(ratio, cache);\r\n},\r\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\r\n  var cache = target._gsap;\r\n  cache[property] = value;\r\n  cache.renderTransform(ratio, cache);\r\n},\r\n    _transformProp = \"transform\",\r\n    _transformOriginProp = _transformProp + \"Origin\",\r\n    _saveStyle = function _saveStyle(property, isNotCSS) {\r\n  var _this = this;\r\n\r\n  var target = this.target,\r\n      style = target.style,\r\n      cache = target._gsap;\r\n\r\n  if (property in _transformProps && style) {\r\n    this.tfm = this.tfm || {};\r\n\r\n    if (property !== \"transform\") {\r\n      property = _propertyAliases[property] || property;\r\n      ~property.indexOf(\",\") ? property.split(\",\").forEach(function (a) {\r\n        return _this.tfm[a] = _get(target, a);\r\n      }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\r\n\r\n      property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\r\n    } else {\r\n      return _propertyAliases.transform.split(\",\").forEach(function (p) {\r\n        return _saveStyle.call(_this, p, isNotCSS);\r\n      });\r\n    }\r\n\r\n    if (this.props.indexOf(_transformProp) >= 0) {\r\n      return;\r\n    }\r\n\r\n    if (cache.svg) {\r\n      this.svgo = target.getAttribute(\"data-svg-origin\");\r\n      this.props.push(_transformOriginProp, isNotCSS, \"\");\r\n    }\r\n\r\n    property = _transformProp;\r\n  }\r\n\r\n  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\r\n},\r\n    _removeIndependentTransforms = function _removeIndependentTransforms(style) {\r\n  if (style.translate) {\r\n    style.removeProperty(\"translate\");\r\n    style.removeProperty(\"scale\");\r\n    style.removeProperty(\"rotate\");\r\n  }\r\n},\r\n    _revertStyle = function _revertStyle() {\r\n  var props = this.props,\r\n      target = this.target,\r\n      style = target.style,\r\n      cache = target._gsap,\r\n      i,\r\n      p;\r\n\r\n  for (i = 0; i < props.length; i += 3) {\r\n    // stored like this: property, isNotCSS, value\r\n    if (!props[i + 1]) {\r\n      props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\r\n    } else if (props[i + 1] === 2) {\r\n      // non-CSS value (function-based)\r\n      target[props[i]](props[i + 2]);\r\n    } else {\r\n      // non-CSS value (not function-based)\r\n      target[props[i]] = props[i + 2];\r\n    }\r\n  }\r\n\r\n  if (this.tfm) {\r\n    for (p in this.tfm) {\r\n      cache[p] = this.tfm[p];\r\n    }\r\n\r\n    if (cache.svg) {\r\n      cache.renderTransform();\r\n      target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\r\n    }\r\n\r\n    i = _reverting();\r\n\r\n    if ((!i || !i.isStart) && !style[_transformProp]) {\r\n      _removeIndependentTransforms(style);\r\n\r\n      if (cache.zOrigin && style[_transformOriginProp]) {\r\n        style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\"; // since we're uncaching, we must put the zOrigin back into the transformOrigin so that we can pull it out accurately when we parse again. Otherwise, we'd lose the z portion of the origin since we extract it to protect from Safari bugs.\r\n\r\n        cache.zOrigin = 0;\r\n        cache.renderTransform();\r\n      }\r\n\r\n      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\r\n    }\r\n  }\r\n},\r\n    _getStyleSaver = function _getStyleSaver(target, properties) {\r\n  var saver = {\r\n    target: target,\r\n    props: [],\r\n    revert: _revertStyle,\r\n    save: _saveStyle\r\n  };\r\n  target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\r\n\r\n  properties && target.style && target.nodeType && properties.split(\",\").forEach(function (p) {\r\n    return saver.save(p);\r\n  }); // make sure it's a DOM node too.\r\n\r\n  return saver;\r\n},\r\n    _supports3D,\r\n    _createElement = function _createElement(type, ns) {\r\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\r\n\r\n  return e && e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://gsap.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\r\n},\r\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\r\n  var cs = getComputedStyle(target);\r\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\r\n},\r\n    _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"),\r\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\r\n  var e = element || _tempDiv,\r\n      s = e.style,\r\n      i = 5;\r\n\r\n  if (property in s && !preferPrefix) {\r\n    return property;\r\n  }\r\n\r\n  property = property.charAt(0).toUpperCase() + property.substr(1);\r\n\r\n  while (i-- && !(_prefixes[i] + property in s)) {}\r\n\r\n  return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\r\n},\r\n    _initCore = function _initCore() {\r\n  if (_windowExists() && window.document) {\r\n    _win = window;\r\n    _doc = _win.document;\r\n    _docElement = _doc.documentElement;\r\n    _tempDiv = _createElement(\"div\") || {\r\n      style: {}\r\n    };\r\n    _tempDivStyler = _createElement(\"div\");\r\n    _transformProp = _checkPropPrefix(_transformProp);\r\n    _transformOriginProp = _transformProp + \"Origin\";\r\n    _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\r\n\r\n    _supports3D = !!_checkPropPrefix(\"perspective\");\r\n    _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;\r\n    _pluginInitted = 1;\r\n  }\r\n},\r\n    _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {\r\n  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\r\n  var owner = target.ownerSVGElement,\r\n      svg = _createElement(\"svg\", owner && owner.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"),\r\n      clone = target.cloneNode(true),\r\n      bbox;\r\n\r\n  clone.style.display = \"block\";\r\n  svg.appendChild(clone);\r\n\r\n  _docElement.appendChild(svg);\r\n\r\n  try {\r\n    bbox = clone.getBBox();\r\n  } catch (e) {}\r\n\r\n  svg.removeChild(clone);\r\n\r\n  _docElement.removeChild(svg);\r\n\r\n  return bbox;\r\n},\r\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\r\n  var i = attributesArray.length;\r\n\r\n  while (i--) {\r\n    if (target.hasAttribute(attributesArray[i])) {\r\n      return target.getAttribute(attributesArray[i]);\r\n    }\r\n  }\r\n},\r\n    _getBBox = function _getBBox(target) {\r\n  var bounds, cloned;\r\n\r\n  try {\r\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\r\n  } catch (error) {\r\n    bounds = _getReparentedCloneBBox(target);\r\n    cloned = 1;\r\n  }\r\n\r\n  bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\r\n\r\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\r\n    x: +_getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\r\n    y: +_getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\r\n    width: 0,\r\n    height: 0\r\n  } : bounds;\r\n},\r\n    _isSVG = function _isSVG(e) {\r\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\r\n},\r\n    //reports if the element is an SVG on which getBBox() actually works\r\n_removeProperty = function _removeProperty(target, property) {\r\n  if (property) {\r\n    var style = target.style,\r\n        first2Chars;\r\n\r\n    if (property in _transformProps && property !== _transformOriginProp) {\r\n      property = _transformProp;\r\n    }\r\n\r\n    if (style.removeProperty) {\r\n      first2Chars = property.substr(0, 2);\r\n\r\n      if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\r\n        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\r\n        property = \"-\" + property;\r\n      }\r\n\r\n      style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\r\n    } else {\r\n      //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\r\n      style.removeAttribute(property);\r\n    }\r\n  }\r\n},\r\n    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\r\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\r\n  plugin._pt = pt;\r\n  pt.b = beginning;\r\n  pt.e = end;\r\n\r\n  plugin._props.push(property);\r\n\r\n  return pt;\r\n},\r\n    _nonConvertibleUnits = {\r\n  deg: 1,\r\n  rad: 1,\r\n  turn: 1\r\n},\r\n    _nonStandardLayouts = {\r\n  grid: 1,\r\n  flex: 1\r\n},\r\n    //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\r\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\r\n  var curValue = parseFloat(value) || 0,\r\n      curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\",\r\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\r\n  style = _tempDiv.style,\r\n      horizontal = _horizontalExp.test(property),\r\n      isRootSVG = target.tagName.toLowerCase() === \"svg\",\r\n      measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"),\r\n      amount = 100,\r\n      toPixels = unit === \"px\",\r\n      toPercent = unit === \"%\",\r\n      px,\r\n      parent,\r\n      cache,\r\n      isSVG;\r\n\r\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\r\n    return curValue;\r\n  }\r\n\r\n  curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\r\n  isSVG = target.getCTM && _isSVG(target);\r\n\r\n  if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\r\n    px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\r\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\r\n  }\r\n\r\n  style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\r\n  parent = unit !== \"rem\" && ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\r\n\r\n  if (isSVG) {\r\n    parent = (target.ownerSVGElement || {}).parentNode;\r\n  }\r\n\r\n  if (!parent || parent === _doc || !parent.appendChild) {\r\n    parent = _doc.body;\r\n  }\r\n\r\n  cache = parent._gsap;\r\n\r\n  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {\r\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\r\n  } else {\r\n    if (toPercent && (property === \"height\" || property === \"width\")) {\r\n      // if we're dealing with width/height that's inside a container with padding and/or it's a flexbox/grid container, we must apply it to the target itself rather than the _tempDiv in order to ensure complete accuracy, factoring in the parent's padding.\r\n      var v = target.style[property];\r\n      target.style[property] = amount + unit;\r\n      px = target[measureProperty];\r\n      v ? target.style[property] = v : _removeProperty(target, property);\r\n    } else {\r\n      (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\r\n      parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\r\n\r\n      parent.appendChild(_tempDiv);\r\n      px = _tempDiv[measureProperty];\r\n      parent.removeChild(_tempDiv);\r\n      style.position = \"absolute\";\r\n    }\r\n\r\n    if (horizontal && toPercent) {\r\n      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\r\n      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\r\n      cache.width = parent[measureProperty];\r\n    }\r\n  }\r\n\r\n  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\r\n},\r\n    _get = function _get(target, property, unit, uncache) {\r\n  var value;\r\n  _pluginInitted || _initCore();\r\n\r\n  if (property in _propertyAliases && property !== \"transform\") {\r\n    property = _propertyAliases[property];\r\n\r\n    if (~property.indexOf(\",\")) {\r\n      property = property.split(\",\")[0];\r\n    }\r\n  }\r\n\r\n  if (_transformProps[property] && property !== \"transform\") {\r\n    value = _parseTransform(target, uncache);\r\n    value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\r\n  } else {\r\n    value = target.style[property];\r\n\r\n    if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\r\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\r\n    }\r\n  }\r\n\r\n  return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\r\n},\r\n    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\r\n  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\r\n  if (!start || start === \"none\") {\r\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://gsap.com/forums/topic/18310-clippath-doesnt-work-on-ios/\r\n    var p = _checkPropPrefix(prop, target, 1),\r\n        s = p && _getComputedProperty(target, p, 1);\r\n\r\n    if (s && s !== start) {\r\n      prop = p;\r\n      start = s;\r\n    } else if (prop === \"borderColor\") {\r\n      start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://gsap.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\r\n    }\r\n  }\r\n\r\n  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),\r\n      index = 0,\r\n      matchIndex = 0,\r\n      a,\r\n      result,\r\n      startValues,\r\n      startNum,\r\n      color,\r\n      startValue,\r\n      endValue,\r\n      endNum,\r\n      chunk,\r\n      endUnit,\r\n      startUnit,\r\n      endValues;\r\n  pt.b = start;\r\n  pt.e = end;\r\n  start += \"\"; // ensure values are strings\r\n\r\n  end += \"\";\r\n\r\n  if (end.substring(0, 6) === \"var(--\") {\r\n    end = _getComputedProperty(target, end.substring(4, end.indexOf(\")\")));\r\n  }\r\n\r\n  if (end === \"auto\") {\r\n    startValue = target.style[prop];\r\n    target.style[prop] = end;\r\n    end = _getComputedProperty(target, prop) || end;\r\n    startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\r\n  }\r\n\r\n  a = [start, end];\r\n\r\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\r\n\r\n\r\n  start = a[0];\r\n  end = a[1];\r\n  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\r\n  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\r\n\r\n  if (endValues.length) {\r\n    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {\r\n      endValue = result[0];\r\n      chunk = end.substring(index, result.index);\r\n\r\n      if (color) {\r\n        color = (color + 1) % 5;\r\n      } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\r\n        color = 1;\r\n      }\r\n\r\n      if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\r\n        startNum = parseFloat(startValue) || 0;\r\n        startUnit = startValue.substr((startNum + \"\").length);\r\n        endValue.charAt(1) === \"=\" && (endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);\r\n        endNum = parseFloat(endValue);\r\n        endUnit = endValue.substr((endNum + \"\").length);\r\n        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\r\n\r\n        if (!endUnit) {\r\n          //if something like \"perspective:300\" is passed in and we must add a unit to the end\r\n          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\r\n\r\n          if (index === end.length) {\r\n            end += endUnit;\r\n            pt.e += endUnit;\r\n          }\r\n        }\r\n\r\n        if (startUnit !== endUnit) {\r\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\r\n        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\r\n\r\n\r\n        pt._pt = {\r\n          _next: pt._pt,\r\n          p: chunk || matchIndex === 1 ? chunk : \",\",\r\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\r\n          s: startNum,\r\n          c: endNum - startNum,\r\n          m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\r\n        };\r\n      }\r\n    }\r\n\r\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\r\n  } else {\r\n    pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\r\n  }\r\n\r\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\r\n\r\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\r\n\r\n  return pt;\r\n},\r\n    _keywordToPercent = {\r\n  top: \"0%\",\r\n  bottom: \"100%\",\r\n  left: \"0%\",\r\n  right: \"100%\",\r\n  center: \"50%\"\r\n},\r\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\r\n  var split = value.split(\" \"),\r\n      x = split[0],\r\n      y = split[1] || \"50%\";\r\n\r\n  if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\r\n    //the user provided them in the wrong order, so flip them\r\n    value = x;\r\n    x = y;\r\n    y = value;\r\n  }\r\n\r\n  split[0] = _keywordToPercent[x] || x;\r\n  split[1] = _keywordToPercent[y] || y;\r\n  return split.join(\" \");\r\n},\r\n    _renderClearProps = function _renderClearProps(ratio, data) {\r\n  if (data.tween && data.tween._time === data.tween._dur) {\r\n    var target = data.t,\r\n        style = target.style,\r\n        props = data.u,\r\n        cache = target._gsap,\r\n        prop,\r\n        clearTransforms,\r\n        i;\r\n\r\n    if (props === \"all\" || props === true) {\r\n      style.cssText = \"\";\r\n      clearTransforms = 1;\r\n    } else {\r\n      props = props.split(\",\");\r\n      i = props.length;\r\n\r\n      while (--i > -1) {\r\n        prop = props[i];\r\n\r\n        if (_transformProps[prop]) {\r\n          clearTransforms = 1;\r\n          prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\r\n        }\r\n\r\n        _removeProperty(target, prop);\r\n      }\r\n    }\r\n\r\n    if (clearTransforms) {\r\n      _removeProperty(target, _transformProp);\r\n\r\n      if (cache) {\r\n        cache.svg && target.removeAttribute(\"transform\");\r\n        style.scale = style.rotate = style.translate = \"none\";\r\n\r\n        _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\r\n\r\n\r\n        cache.uncache = 1;\r\n\r\n        _removeIndependentTransforms(style);\r\n      }\r\n    }\r\n  }\r\n},\r\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\r\n_specialProps = {\r\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\r\n    if (tween.data !== \"isFromStart\") {\r\n      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\r\n      pt.u = endValue;\r\n      pt.pr = -10;\r\n      pt.tween = tween;\r\n\r\n      plugin._props.push(property);\r\n\r\n      return 1;\r\n    }\r\n  }\r\n  /* className feature (about 0.4kb gzipped).\r\n  , className(plugin, target, property, endValue, tween) {\r\n  \tlet _renderClassName = (ratio, data) => {\r\n  \t\t\tdata.css.render(ratio, data.css);\r\n  \t\t\tif (!ratio || ratio === 1) {\r\n  \t\t\t\tlet inline = data.rmv,\r\n  \t\t\t\t\ttarget = data.t,\r\n  \t\t\t\t\tp;\r\n  \t\t\t\ttarget.setAttribute(\"class\", ratio ? data.e : data.b);\r\n  \t\t\t\tfor (p in inline) {\r\n  \t\t\t\t\t_removeProperty(target, p);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t},\r\n  \t\t_getAllStyles = (target) => {\r\n  \t\t\tlet styles = {},\r\n  \t\t\t\tcomputed = getComputedStyle(target),\r\n  \t\t\t\tp;\r\n  \t\t\tfor (p in computed) {\r\n  \t\t\t\tif (isNaN(p) && p !== \"cssText\" && p !== \"length\") {\r\n  \t\t\t\t\tstyles[p] = computed[p];\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\r\n  \t\t\treturn styles;\r\n  \t\t},\r\n  \t\tstartClassList = target.getAttribute(\"class\"),\r\n  \t\tstyle = target.style,\r\n  \t\tcssText = style.cssText,\r\n  \t\tcache = target._gsap,\r\n  \t\tclassPT = cache.classPT,\r\n  \t\tinlineToRemoveAtEnd = {},\r\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== \"=\") ? endValue : startClassList.replace(new RegExp(\"(?:\\\\s|^)\" + endValue.substr(2) + \"(?![\\\\w-])\"), \"\") + ((endValue.charAt(0) === \"+\") ? \" \" + endValue.substr(2) : \"\")},\r\n  \t\tchangingVars = {},\r\n  \t\tstartVars = _getAllStyles(target),\r\n  \t\ttransformRelated = /(transform|perspective)/i,\r\n  \t\tendVars, p;\r\n  \tif (classPT) {\r\n  \t\tclassPT.r(1, classPT.d);\r\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, \"_pt\");\r\n  \t}\r\n  \ttarget.setAttribute(\"class\", data.e);\r\n  \tendVars = _getAllStyles(target, true);\r\n  \ttarget.setAttribute(\"class\", startClassList);\r\n  \tfor (p in endVars) {\r\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\r\n  \t\t\tchangingVars[p] = endVars[p];\r\n  \t\t\tif (!style[p] && style[p] !== \"0\") {\r\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, \"className\", 0, 0, _renderClassName, data, 0, -11);\r\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\r\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).\r\n  \t}\r\n  \t_parseTransform(target, true); //to clear the caching of transforms\r\n  \tdata.css = new gsap.plugins.css();\r\n  \tdata.css.init(target, changingVars, tween);\r\n  \tplugin._props.push(...data.css._props);\r\n  \treturn 1;\r\n  }\r\n  */\r\n\r\n},\r\n\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * TRANSFORMS\r\n * --------------------------------------------------------------------------------------\r\n */\r\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\r\n    _rotationalProperties = {},\r\n    _isNullTransform = function _isNullTransform(value) {\r\n  return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\r\n},\r\n    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\r\n  var matrixString = _getComputedProperty(target, _transformProp);\r\n\r\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\r\n},\r\n    _getMatrix = function _getMatrix(target, force2D) {\r\n  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),\r\n      style = target.style,\r\n      matrix = _getComputedTransformMatrixAsArray(target),\r\n      parent,\r\n      nextSibling,\r\n      temp,\r\n      addedToDOM;\r\n\r\n  if (cache.svg && target.getAttribute(\"transform\")) {\r\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\r\n\r\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\r\n    return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\r\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\r\n    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\r\n    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\r\n    temp = style.display;\r\n    style.display = \"block\";\r\n    parent = target.parentNode;\r\n\r\n    if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {\r\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375. Note: position: fixed elements report a null offsetParent but they could also be invisible because they're in an ancestor with display: none, so we check getBoundingClientRect(). We only want to alter the DOM if we absolutely have to because it can cause iframe content to reload, like a Vimeo video.\r\n      addedToDOM = 1; //flag\r\n\r\n      nextSibling = target.nextElementSibling;\r\n\r\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\r\n\r\n    }\r\n\r\n    matrix = _getComputedTransformMatrixAsArray(target);\r\n    temp ? style.display = temp : _removeProperty(target, \"display\");\r\n\r\n    if (addedToDOM) {\r\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\r\n    }\r\n  }\r\n\r\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\r\n},\r\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\r\n  var cache = target._gsap,\r\n      matrix = matrixArray || _getMatrix(target, true),\r\n      xOriginOld = cache.xOrigin || 0,\r\n      yOriginOld = cache.yOrigin || 0,\r\n      xOffsetOld = cache.xOffset || 0,\r\n      yOffsetOld = cache.yOffset || 0,\r\n      a = matrix[0],\r\n      b = matrix[1],\r\n      c = matrix[2],\r\n      d = matrix[3],\r\n      tx = matrix[4],\r\n      ty = matrix[5],\r\n      originSplit = origin.split(\" \"),\r\n      xOrigin = parseFloat(originSplit[0]) || 0,\r\n      yOrigin = parseFloat(originSplit[1]) || 0,\r\n      bounds,\r\n      determinant,\r\n      x,\r\n      y;\r\n\r\n  if (!originIsAbsolute) {\r\n    bounds = _getBBox(target);\r\n    xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\r\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin); // if (!(\"xOrigin\" in cache) && (xOrigin || yOrigin)) { // added in 3.12.3, reverted in 3.12.4; requires more exploration\r\n    // \txOrigin -= bounds.x;\r\n    // \tyOrigin -= bounds.y;\r\n    // }\r\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\r\n    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\r\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\r\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\r\n    xOrigin = x;\r\n    yOrigin = y; // theory: we only had to do this for smoothing and it assumes that the previous one was not originIsAbsolute.\r\n  }\r\n\r\n  if (smooth || smooth !== false && cache.smooth) {\r\n    tx = xOrigin - xOriginOld;\r\n    ty = yOrigin - yOriginOld;\r\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\r\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\r\n  } else {\r\n    cache.xOffset = cache.yOffset = 0;\r\n  }\r\n\r\n  cache.xOrigin = xOrigin;\r\n  cache.yOrigin = yOrigin;\r\n  cache.smooth = !!smooth;\r\n  cache.origin = origin;\r\n  cache.originIsAbsolute = !!originIsAbsolute;\r\n  target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\r\n\r\n  if (pluginToAddPropTweensTo) {\r\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\r\n\r\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\r\n\r\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\r\n\r\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\r\n  }\r\n\r\n  target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\r\n},\r\n    _parseTransform = function _parseTransform(target, uncache) {\r\n  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\r\n\r\n  if (\"x\" in cache && !uncache && !cache.uncache) {\r\n    return cache;\r\n  }\r\n\r\n  var style = target.style,\r\n      invertedScaleX = cache.scaleX < 0,\r\n      px = \"px\",\r\n      deg = \"deg\",\r\n      cs = getComputedStyle(target),\r\n      origin = _getComputedProperty(target, _transformOriginProp) || \"0\",\r\n      x,\r\n      y,\r\n      z,\r\n      scaleX,\r\n      scaleY,\r\n      rotation,\r\n      rotationX,\r\n      rotationY,\r\n      skewX,\r\n      skewY,\r\n      perspective,\r\n      xOrigin,\r\n      yOrigin,\r\n      matrix,\r\n      angle,\r\n      cos,\r\n      sin,\r\n      a,\r\n      b,\r\n      c,\r\n      d,\r\n      a12,\r\n      a22,\r\n      t1,\r\n      t2,\r\n      t3,\r\n      a13,\r\n      a23,\r\n      a33,\r\n      a42,\r\n      a43,\r\n      a32;\r\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\r\n  scaleX = scaleY = 1;\r\n  cache.svg = !!(target.getCTM && _isSVG(target));\r\n\r\n  if (cs.translate) {\r\n    // accommodate independent transforms by combining them into normal ones.\r\n    if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\r\n      style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\r\n    }\r\n\r\n    style.scale = style.rotate = style.translate = \"none\";\r\n  }\r\n\r\n  matrix = _getMatrix(target, cache.svg);\r\n\r\n  if (cache.svg) {\r\n    if (cache.uncache) {\r\n      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\r\n      t2 = target.getBBox();\r\n      origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\r\n      t1 = \"\";\r\n    } else {\r\n      t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\r\n    }\r\n\r\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\r\n  }\r\n\r\n  xOrigin = cache.xOrigin || 0;\r\n  yOrigin = cache.yOrigin || 0;\r\n\r\n  if (matrix !== _identity2DMatrix) {\r\n    a = matrix[0]; //a11\r\n\r\n    b = matrix[1]; //a21\r\n\r\n    c = matrix[2]; //a31\r\n\r\n    d = matrix[3]; //a41\r\n\r\n    x = a12 = matrix[4];\r\n    y = a22 = matrix[5]; //2D matrix\r\n\r\n    if (matrix.length === 6) {\r\n      scaleX = Math.sqrt(a * a + b * b);\r\n      scaleY = Math.sqrt(d * d + c * c);\r\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\r\n\r\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\r\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\r\n\r\n      if (cache.svg) {\r\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\r\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\r\n      } //3D matrix\r\n\r\n    } else {\r\n      a32 = matrix[6];\r\n      a42 = matrix[7];\r\n      a13 = matrix[8];\r\n      a23 = matrix[9];\r\n      a33 = matrix[10];\r\n      a43 = matrix[11];\r\n      x = matrix[12];\r\n      y = matrix[13];\r\n      z = matrix[14];\r\n      angle = _atan2(a32, a33);\r\n      rotationX = angle * _RAD2DEG; //rotationX\r\n\r\n      if (angle) {\r\n        cos = Math.cos(-angle);\r\n        sin = Math.sin(-angle);\r\n        t1 = a12 * cos + a13 * sin;\r\n        t2 = a22 * cos + a23 * sin;\r\n        t3 = a32 * cos + a33 * sin;\r\n        a13 = a12 * -sin + a13 * cos;\r\n        a23 = a22 * -sin + a23 * cos;\r\n        a33 = a32 * -sin + a33 * cos;\r\n        a43 = a42 * -sin + a43 * cos;\r\n        a12 = t1;\r\n        a22 = t2;\r\n        a32 = t3;\r\n      } //rotationY\r\n\r\n\r\n      angle = _atan2(-c, a33);\r\n      rotationY = angle * _RAD2DEG;\r\n\r\n      if (angle) {\r\n        cos = Math.cos(-angle);\r\n        sin = Math.sin(-angle);\r\n        t1 = a * cos - a13 * sin;\r\n        t2 = b * cos - a23 * sin;\r\n        t3 = c * cos - a33 * sin;\r\n        a43 = d * sin + a43 * cos;\r\n        a = t1;\r\n        b = t2;\r\n        c = t3;\r\n      } //rotationZ\r\n\r\n\r\n      angle = _atan2(b, a);\r\n      rotation = angle * _RAD2DEG;\r\n\r\n      if (angle) {\r\n        cos = Math.cos(angle);\r\n        sin = Math.sin(angle);\r\n        t1 = a * cos + b * sin;\r\n        t2 = a12 * cos + a22 * sin;\r\n        b = b * cos - a * sin;\r\n        a22 = a22 * cos - a12 * sin;\r\n        a = t1;\r\n        a12 = t2;\r\n      }\r\n\r\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\r\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\r\n        rotationX = rotation = 0;\r\n        rotationY = 180 - rotationY;\r\n      }\r\n\r\n      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\r\n      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\r\n      angle = _atan2(a12, a22);\r\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\r\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\r\n    }\r\n\r\n    if (cache.svg) {\r\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\r\n      t1 = target.getAttribute(\"transform\");\r\n      cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\r\n      t1 && target.setAttribute(\"transform\", t1);\r\n    }\r\n  }\r\n\r\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\r\n    if (invertedScaleX) {\r\n      scaleX *= -1;\r\n      skewX += rotation <= 0 ? 180 : -180;\r\n      rotation += rotation <= 0 ? 180 : -180;\r\n    } else {\r\n      scaleY *= -1;\r\n      skewX += skewX <= 0 ? 180 : -180;\r\n    }\r\n  }\r\n\r\n  uncache = uncache || cache.uncache;\r\n  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\r\n  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\r\n  cache.z = z + px;\r\n  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\r\n  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\r\n  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\r\n  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\r\n  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\r\n  cache.skewX = skewX + deg;\r\n  cache.skewY = skewY + deg;\r\n  cache.transformPerspective = perspective + px;\r\n\r\n  if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\r\n    style[_transformOriginProp] = _firstTwoOnly(origin);\r\n  }\r\n\r\n  cache.xOffset = cache.yOffset = 0;\r\n  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\r\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\r\n  cache.uncache = 0;\r\n  return cache;\r\n},\r\n    _firstTwoOnly = function _firstTwoOnly(value) {\r\n  return (value = value.split(\" \"))[0] + \" \" + value[1];\r\n},\r\n    //for handling transformOrigin values, stripping out the 3rd dimension\r\n_addPxTranslate = function _addPxTranslate(target, start, value) {\r\n  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\r\n  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\r\n},\r\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\r\n  cache.z = \"0px\";\r\n  cache.rotationY = cache.rotationX = \"0deg\";\r\n  cache.force3D = 0;\r\n\r\n  _renderCSSTransforms(ratio, cache);\r\n},\r\n    _zeroDeg = \"0deg\",\r\n    _zeroPx = \"0px\",\r\n    _endParenthesis = \") \",\r\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\r\n  var _ref = cache || this,\r\n      xPercent = _ref.xPercent,\r\n      yPercent = _ref.yPercent,\r\n      x = _ref.x,\r\n      y = _ref.y,\r\n      z = _ref.z,\r\n      rotation = _ref.rotation,\r\n      rotationY = _ref.rotationY,\r\n      rotationX = _ref.rotationX,\r\n      skewX = _ref.skewX,\r\n      skewY = _ref.skewY,\r\n      scaleX = _ref.scaleX,\r\n      scaleY = _ref.scaleY,\r\n      transformPerspective = _ref.transformPerspective,\r\n      force3D = _ref.force3D,\r\n      target = _ref.target,\r\n      zOrigin = _ref.zOrigin,\r\n      transforms = \"\",\r\n      use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\r\n\r\n\r\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\r\n    var angle = parseFloat(rotationY) * _DEG2RAD,\r\n        a13 = Math.sin(angle),\r\n        a33 = Math.cos(angle),\r\n        cos;\r\n\r\n    angle = parseFloat(rotationX) * _DEG2RAD;\r\n    cos = Math.cos(angle);\r\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\r\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\r\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\r\n  }\r\n\r\n  if (transformPerspective !== _zeroPx) {\r\n    transforms += \"perspective(\" + transformPerspective + _endParenthesis;\r\n  }\r\n\r\n  if (xPercent || yPercent) {\r\n    transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\r\n  }\r\n\r\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\r\n    transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\r\n  }\r\n\r\n  if (rotation !== _zeroDeg) {\r\n    transforms += \"rotate(\" + rotation + _endParenthesis;\r\n  }\r\n\r\n  if (rotationY !== _zeroDeg) {\r\n    transforms += \"rotateY(\" + rotationY + _endParenthesis;\r\n  }\r\n\r\n  if (rotationX !== _zeroDeg) {\r\n    transforms += \"rotateX(\" + rotationX + _endParenthesis;\r\n  }\r\n\r\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\r\n    transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\r\n  }\r\n\r\n  if (scaleX !== 1 || scaleY !== 1) {\r\n    transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\r\n  }\r\n\r\n  target.style[_transformProp] = transforms || \"translate(0, 0)\";\r\n},\r\n    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\r\n  var _ref2 = cache || this,\r\n      xPercent = _ref2.xPercent,\r\n      yPercent = _ref2.yPercent,\r\n      x = _ref2.x,\r\n      y = _ref2.y,\r\n      rotation = _ref2.rotation,\r\n      skewX = _ref2.skewX,\r\n      skewY = _ref2.skewY,\r\n      scaleX = _ref2.scaleX,\r\n      scaleY = _ref2.scaleY,\r\n      target = _ref2.target,\r\n      xOrigin = _ref2.xOrigin,\r\n      yOrigin = _ref2.yOrigin,\r\n      xOffset = _ref2.xOffset,\r\n      yOffset = _ref2.yOffset,\r\n      forceCSS = _ref2.forceCSS,\r\n      tx = parseFloat(x),\r\n      ty = parseFloat(y),\r\n      a11,\r\n      a21,\r\n      a12,\r\n      a22,\r\n      temp;\r\n\r\n  rotation = parseFloat(rotation);\r\n  skewX = parseFloat(skewX);\r\n  skewY = parseFloat(skewY);\r\n\r\n  if (skewY) {\r\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\r\n    skewY = parseFloat(skewY);\r\n    skewX += skewY;\r\n    rotation += skewY;\r\n  }\r\n\r\n  if (rotation || skewX) {\r\n    rotation *= _DEG2RAD;\r\n    skewX *= _DEG2RAD;\r\n    a11 = Math.cos(rotation) * scaleX;\r\n    a21 = Math.sin(rotation) * scaleX;\r\n    a12 = Math.sin(rotation - skewX) * -scaleY;\r\n    a22 = Math.cos(rotation - skewX) * scaleY;\r\n\r\n    if (skewX) {\r\n      skewY *= _DEG2RAD;\r\n      temp = Math.tan(skewX - skewY);\r\n      temp = Math.sqrt(1 + temp * temp);\r\n      a12 *= temp;\r\n      a22 *= temp;\r\n\r\n      if (skewY) {\r\n        temp = Math.tan(skewY);\r\n        temp = Math.sqrt(1 + temp * temp);\r\n        a11 *= temp;\r\n        a21 *= temp;\r\n      }\r\n    }\r\n\r\n    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\r\n    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\r\n    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\r\n    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\r\n  } else {\r\n    a11 = scaleX;\r\n    a22 = scaleY;\r\n    a21 = a12 = 0;\r\n  }\r\n\r\n  if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\r\n    tx = _convertToUnit(target, \"x\", x, \"px\");\r\n    ty = _convertToUnit(target, \"y\", y, \"px\");\r\n  }\r\n\r\n  if (xOrigin || yOrigin || xOffset || yOffset) {\r\n    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\r\n    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\r\n  }\r\n\r\n  if (xPercent || yPercent) {\r\n    //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\r\n    temp = target.getBBox();\r\n    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\r\n    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\r\n  }\r\n\r\n  temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\r\n  target.setAttribute(\"transform\", temp);\r\n  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\r\n},\r\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\r\n  var cap = 360,\r\n      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),\r\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1),\r\n      change = endNum - startNum,\r\n      finalValue = startNum + change + \"deg\",\r\n      direction,\r\n      pt;\r\n\r\n  if (isString) {\r\n    direction = endValue.split(\"_\")[1];\r\n\r\n    if (direction === \"short\") {\r\n      change %= cap;\r\n\r\n      if (change !== change % (cap / 2)) {\r\n        change += change < 0 ? cap : -cap;\r\n      }\r\n    }\r\n\r\n    if (direction === \"cw\" && change < 0) {\r\n      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\r\n    } else if (direction === \"ccw\" && change > 0) {\r\n      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\r\n    }\r\n  }\r\n\r\n  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\r\n  pt.e = finalValue;\r\n  pt.u = \"deg\";\r\n\r\n  plugin._props.push(property);\r\n\r\n  return pt;\r\n},\r\n    _assign = function _assign(target, source) {\r\n  // Internet Explorer doesn't have Object.assign(), so we recreate it here.\r\n  for (var p in source) {\r\n    target[p] = source[p];\r\n  }\r\n\r\n  return target;\r\n},\r\n    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\r\n  //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\r\n  var startCache = _assign({}, target._gsap),\r\n      exclude = \"perspective,force3D,transformOrigin,svgOrigin\",\r\n      style = target.style,\r\n      endCache,\r\n      p,\r\n      startValue,\r\n      endValue,\r\n      startNum,\r\n      endNum,\r\n      startUnit,\r\n      endUnit;\r\n\r\n  if (startCache.svg) {\r\n    startValue = target.getAttribute(\"transform\");\r\n    target.setAttribute(\"transform\", \"\");\r\n    style[_transformProp] = transforms;\r\n    endCache = _parseTransform(target, 1);\r\n\r\n    _removeProperty(target, _transformProp);\r\n\r\n    target.setAttribute(\"transform\", startValue);\r\n  } else {\r\n    startValue = getComputedStyle(target)[_transformProp];\r\n    style[_transformProp] = transforms;\r\n    endCache = _parseTransform(target, 1);\r\n    style[_transformProp] = startValue;\r\n  }\r\n\r\n  for (p in _transformProps) {\r\n    startValue = startCache[p];\r\n    endValue = endCache[p];\r\n\r\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\r\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\r\n      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\r\n      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\r\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\r\n      endNum = parseFloat(endValue);\r\n      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\r\n      plugin._pt.u = endUnit || 0;\r\n\r\n      plugin._props.push(p);\r\n    }\r\n  }\r\n\r\n  _assign(endCache, startCache);\r\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\r\n\r\n\r\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"padding,margin,Width,Radius\", function (name, index) {\r\n  var t = \"Top\",\r\n      r = \"Right\",\r\n      b = \"Bottom\",\r\n      l = \"Left\",\r\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\r\n    return index < 2 ? name + side : \"border\" + side + name;\r\n  });\r\n\r\n  _specialProps[index > 1 ? \"border\" + name : name] = function (plugin, target, property, endValue, tween) {\r\n    var a, vars;\r\n\r\n    if (arguments.length < 4) {\r\n      // getter, passed target, property, and unit (from _get())\r\n      a = props.map(function (prop) {\r\n        return _get(plugin, prop, property);\r\n      });\r\n      vars = a.join(\" \");\r\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\r\n    }\r\n\r\n    a = (endValue + \"\").split(\" \");\r\n    vars = {};\r\n    props.forEach(function (prop, i) {\r\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\r\n    });\r\n    plugin.init(target, vars, tween);\r\n  };\r\n});\r\n\r\nvar CSSPlugin = {\r\n  name: \"css\",\r\n  register: _initCore,\r\n  targetTest: function targetTest(target) {\r\n    return target.style && target.nodeType;\r\n  },\r\n  init: function init(target, vars, tween, index, targets) {\r\n    var props = this._props,\r\n        style = target.style,\r\n        startAt = tween.vars.startAt,\r\n        startValue,\r\n        endValue,\r\n        endNum,\r\n        startNum,\r\n        type,\r\n        specialProp,\r\n        p,\r\n        startUnit,\r\n        endUnit,\r\n        relative,\r\n        isTransformRelated,\r\n        transformPropTween,\r\n        cache,\r\n        smooth,\r\n        hasPriority,\r\n        inlineProps;\r\n    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\r\n\r\n    this.styles = this.styles || _getStyleSaver(target);\r\n    inlineProps = this.styles.props;\r\n    this.tween = tween;\r\n\r\n    for (p in vars) {\r\n      if (p === \"autoRound\") {\r\n        continue;\r\n      }\r\n\r\n      endValue = vars[p];\r\n\r\n      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\r\n        // plugins\r\n        continue;\r\n      }\r\n\r\n      type = typeof endValue;\r\n      specialProp = _specialProps[p];\r\n\r\n      if (type === \"function\") {\r\n        endValue = endValue.call(tween, index, target, targets);\r\n        type = typeof endValue;\r\n      }\r\n\r\n      if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\r\n        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\r\n      }\r\n\r\n      if (specialProp) {\r\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\r\n      } else if (p.substr(0, 2) === \"--\") {\r\n        //CSS variable\r\n        startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\r\n        endValue += \"\";\r\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\r\n\r\n        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\r\n          // colors don't have units\r\n          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\r\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\r\n        }\r\n\r\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\r\n        this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\r\n        props.push(p);\r\n        inlineProps.push(p, 0, style[p]);\r\n      } else if (type !== \"undefined\") {\r\n        if (startAt && p in startAt) {\r\n          // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\r\n          startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\r\n          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf(\"random(\") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));\r\n          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + \"\") || startValue === \"auto\" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\r\n\r\n          (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\r\n        } else {\r\n          startValue = _get(target, p);\r\n        }\r\n\r\n        startNum = parseFloat(startValue);\r\n        relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\r\n        relative && (endValue = endValue.substr(2));\r\n        endNum = parseFloat(endValue);\r\n\r\n        if (p in _propertyAliases) {\r\n          if (p === \"autoAlpha\") {\r\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\r\n            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\r\n              //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\r\n              startNum = 0;\r\n            }\r\n\r\n            inlineProps.push(\"visibility\", 0, style.visibility);\r\n\r\n            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\r\n          }\r\n\r\n          if (p !== \"scale\" && p !== \"transform\") {\r\n            p = _propertyAliases[p];\r\n            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\r\n          }\r\n        }\r\n\r\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\r\n\r\n        if (isTransformRelated) {\r\n          this.styles.save(p);\r\n\r\n          if (type === \"string\" && endValue.substring(0, 6) === \"var(--\") {\r\n            endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(\")\")));\r\n            endNum = parseFloat(endValue);\r\n          }\r\n\r\n          if (!transformPropTween) {\r\n            cache = target._gsap;\r\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\r\n\r\n            smooth = vars.smoothOrigin !== false && cache.smooth;\r\n            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\r\n\r\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\r\n          }\r\n\r\n          if (p === \"scale\") {\r\n            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\r\n            this._pt.u = 0;\r\n            props.push(\"scaleY\", p);\r\n            p += \"X\";\r\n          } else if (p === \"transformOrigin\") {\r\n            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\r\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\r\n\r\n            if (cache.svg) {\r\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\r\n            } else {\r\n              endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\r\n\r\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\r\n\r\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\r\n            }\r\n\r\n            continue;\r\n          } else if (p === \"svgOrigin\") {\r\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\r\n\r\n            continue;\r\n          } else if (p in _rotationalProperties) {\r\n            _addRotationalPropTween(this, cache, p, startNum, relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);\r\n\r\n            continue;\r\n          } else if (p === \"smoothOrigin\") {\r\n            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\r\n\r\n            continue;\r\n          } else if (p === \"force3D\") {\r\n            cache[p] = endValue;\r\n            continue;\r\n          } else if (p === \"transform\") {\r\n            _addRawTransformPTs(this, endValue, target);\r\n\r\n            continue;\r\n          }\r\n        } else if (!(p in style)) {\r\n          p = _checkPropPrefix(p) || p;\r\n        }\r\n\r\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\r\n          startUnit = (startValue + \"\").substr((startNum + \"\").length);\r\n          endNum || (endNum = 0); // protect against NaN\r\n\r\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\r\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\r\n          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\r\n          this._pt.u = endUnit || 0;\r\n\r\n          if (startUnit !== endUnit && endUnit !== \"%\") {\r\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\r\n            this._pt.b = startValue;\r\n            this._pt.r = _renderCSSPropWithBeginning;\r\n          }\r\n        } else if (!(p in style)) {\r\n          if (p in target) {\r\n            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\r\n            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\r\n          } else if (p !== \"parseTransform\") {\r\n            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\r\n\r\n            continue;\r\n          }\r\n        } else {\r\n          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\r\n        }\r\n\r\n        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === \"function\" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));\r\n        props.push(p);\r\n      }\r\n    }\r\n\r\n    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\r\n  },\r\n  render: function render(ratio, data) {\r\n    if (data.tween._time || !_reverting()) {\r\n      var pt = data._pt;\r\n\r\n      while (pt) {\r\n        pt.r(ratio, pt.d);\r\n        pt = pt._next;\r\n      }\r\n    } else {\r\n      data.styles.revert();\r\n    }\r\n  },\r\n  get: _get,\r\n  aliases: _propertyAliases,\r\n  getSetter: function getSetter(target, property, plugin) {\r\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\r\n    var p = _propertyAliases[property];\r\n    p && p.indexOf(\",\") < 0 && (property = p);\r\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\r\n  },\r\n  core: {\r\n    _removeProperty: _removeProperty,\r\n    _getMatrix: _getMatrix\r\n  }\r\n};\r\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\r\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;\r\n\r\n(function (positionAndScale, rotation, others, aliases) {\r\n  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + \",\" + rotation + \",\" + others, function (name) {\r\n    _transformProps[name] = 1;\r\n  });\r\n\r\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {\r\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"deg\";\r\n    _rotationalProperties[name] = 1;\r\n  });\r\n\r\n  _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\r\n\r\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {\r\n    var split = name.split(\":\");\r\n    _propertyAliases[split[1]] = all[split[0]];\r\n  });\r\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\r\n\r\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function (name) {\r\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = \"px\";\r\n});\r\n\r\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkVBQTZFO0FBQ3BGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0RBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGFBQWEsc0RBQU87QUFDcEIsU0FBUyxxREFBTTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFNO0FBQ2hCLFVBQVUscURBQU07QUFDaEIsVUFBVSxxREFBTTtBQUNoQixV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QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLDJEQUFZO0FBQ2QsSUFBSSxrREFBTztBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkRBQVk7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLDJEQUFZO0FBQ1osRUFBRSxrREFBTztBQUNULENBQUM7QUFDRDtBQUNBLCtDQUFJIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGdzYXBcXENTU1BsdWdpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogQ1NTUGx1Z2luIDMuMTMuMFxyXG4gKiBodHRwczovL2dzYXAuY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4LTIwMjUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlXHJcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxyXG4qL1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuaW1wb3J0IHsgZ3NhcCwgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIGdldFVuaXQsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9jaGVja1BsdWdpbiwgX3JlcGxhY2VSYW5kb20sIF9wbHVnaW5zLCBHU0NhY2hlLCBQcm9wVHdlZW4sIF9jb25maWcsIF90aWNrZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX2NvbG9yRXhwLCBfcGFyc2VSZWxhdGl2ZSwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXHJcbn0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XHJcblxyXG52YXIgX3dpbixcclxuICAgIF9kb2MsXHJcbiAgICBfZG9jRWxlbWVudCxcclxuICAgIF9wbHVnaW5Jbml0dGVkLFxyXG4gICAgX3RlbXBEaXYsXHJcbiAgICBfdGVtcERpdlN0eWxlcixcclxuICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXHJcbiAgICBfcmV2ZXJ0aW5nLFxyXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XHJcbn0sXHJcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcclxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcclxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcclxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXHJcbiAgICBfYmlnTnVtID0gMWU4LFxyXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxyXG4gICAgX2hvcml6b250YWxFeHAgPSAvKGxlZnR8cmlnaHR8d2lkdGh8bWFyZ2lufHBhZGRpbmd8eCkvaSxcclxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXHJcbiAgICBfcHJvcGVydHlBbGlhc2VzID0ge1xyXG4gIGF1dG9BbHBoYTogXCJvcGFjaXR5LHZpc2liaWxpdHlcIixcclxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXHJcbiAgYWxwaGE6IFwib3BhY2l0eVwiXHJcbn0sXHJcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XHJcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSwgZGF0YSk7XHJcbn0sXHJcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcclxuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHJhdGlvID09PSAxID8gZGF0YS5lIDogTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xyXG59LFxyXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XHJcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51IDogZGF0YS5iLCBkYXRhKTtcclxufSxcclxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcclxuX3JlbmRlclJvdW5kZWRDU1NQcm9wID0gZnVuY3Rpb24gX3JlbmRlclJvdW5kZWRDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XHJcbiAgdmFyIHZhbHVlID0gZGF0YS5zICsgZGF0YS5jICogcmF0aW87XHJcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xyXG59LFxyXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZShyYXRpbywgZGF0YSkge1xyXG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xyXG59LFxyXG4gICAgX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgPSBmdW5jdGlvbiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZChyYXRpbywgZGF0YSkge1xyXG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xyXG59LFxyXG4gICAgX3NldHRlckNTU1N0eWxlID0gZnVuY3Rpb24gX3NldHRlckNTU1N0eWxlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxufSxcclxuICAgIF9zZXR0ZXJDU1NQcm9wID0gZnVuY3Rpb24gX3NldHRlckNTU1Byb3AodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XHJcbn0sXHJcbiAgICBfc2V0dGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XHJcbn0sXHJcbiAgICBfc2V0dGVyU2NhbGUgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcclxufSxcclxuICAgIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xyXG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcclxuICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSB2YWx1ZTtcclxuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcclxufSxcclxuICAgIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyID0gZnVuY3Rpb24gX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XHJcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xyXG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xyXG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xyXG59LFxyXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxyXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXHJcbiAgICBfc2F2ZVN0eWxlID0gZnVuY3Rpb24gX3NhdmVTdHlsZShwcm9wZXJ0eSwgaXNOb3RDU1MpIHtcclxuICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXHJcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxyXG4gICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcclxuXHJcbiAgaWYgKHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBzdHlsZSkge1xyXG4gICAgdGhpcy50Zm0gPSB0aGlzLnRmbSB8fCB7fTtcclxuXHJcbiAgICBpZiAocHJvcGVydHkgIT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eTtcclxuICAgICAgfnByb3BlcnR5LmluZGV4T2YoXCIsXCIpID8gcHJvcGVydHkuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMudGZtW2FdID0gX2dldCh0YXJnZXQsIGEpO1xyXG4gICAgICB9KSA6IHRoaXMudGZtW3Byb3BlcnR5XSA9IGNhY2hlLnggPyBjYWNoZVtwcm9wZXJ0eV0gOiBfZ2V0KHRhcmdldCwgcHJvcGVydHkpOyAvLyBub3RlOiBzY2FsZSB3b3VsZCBtYXAgdG8gXCJzY2FsZVgsc2NhbGVZXCIsIHRodXMgd2UgbG9vcCBhbmQgYXBwbHkgdGhlbSBib3RoLlxyXG5cclxuICAgICAgcHJvcGVydHkgPT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0aGlzLnRmbS56T3JpZ2luID0gY2FjaGUuek9yaWdpbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gX3Byb3BlcnR5QWxpYXNlcy50cmFuc2Zvcm0uc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gX3NhdmVTdHlsZS5jYWxsKF90aGlzLCBwLCBpc05vdENTUyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnByb3BzLmluZGV4T2YoX3RyYW5zZm9ybVByb3ApID49IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWNoZS5zdmcpIHtcclxuICAgICAgdGhpcy5zdmdvID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcclxuICAgICAgdGhpcy5wcm9wcy5wdXNoKF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBpc05vdENTUywgXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcclxuICB9XHJcblxyXG4gIChzdHlsZSB8fCBpc05vdENTUykgJiYgdGhpcy5wcm9wcy5wdXNoKHByb3BlcnR5LCBpc05vdENTUywgc3R5bGVbcHJvcGVydHldKTtcclxufSxcclxuICAgIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zKHN0eWxlKSB7XHJcbiAgaWYgKHN0eWxlLnRyYW5zbGF0ZSkge1xyXG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0cmFuc2xhdGVcIik7XHJcbiAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInNjYWxlXCIpO1xyXG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJyb3RhdGVcIik7XHJcbiAgfVxyXG59LFxyXG4gICAgX3JldmVydFN0eWxlID0gZnVuY3Rpb24gX3JldmVydFN0eWxlKCkge1xyXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcHMsXHJcbiAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxyXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcclxuICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXHJcbiAgICAgIGksXHJcbiAgICAgIHA7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgLy8gc3RvcmVkIGxpa2UgdGhpczogcHJvcGVydHksIGlzTm90Q1NTLCB2YWx1ZVxyXG4gICAgaWYgKCFwcm9wc1tpICsgMV0pIHtcclxuICAgICAgcHJvcHNbaSArIDJdID8gc3R5bGVbcHJvcHNbaV1dID0gcHJvcHNbaSArIDJdIDogc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcHNbaV0uc3Vic3RyKDAsIDIpID09PSBcIi0tXCIgPyBwcm9wc1tpXSA6IHByb3BzW2ldLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfSBlbHNlIGlmIChwcm9wc1tpICsgMV0gPT09IDIpIHtcclxuICAgICAgLy8gbm9uLUNTUyB2YWx1ZSAoZnVuY3Rpb24tYmFzZWQpXHJcbiAgICAgIHRhcmdldFtwcm9wc1tpXV0ocHJvcHNbaSArIDJdKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIG5vbi1DU1MgdmFsdWUgKG5vdCBmdW5jdGlvbi1iYXNlZClcclxuICAgICAgdGFyZ2V0W3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0aGlzLnRmbSkge1xyXG4gICAgZm9yIChwIGluIHRoaXMudGZtKSB7XHJcbiAgICAgIGNhY2hlW3BdID0gdGhpcy50Zm1bcF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhY2hlLnN2Zykge1xyXG4gICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB0aGlzLnN2Z28gfHwgXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaSA9IF9yZXZlcnRpbmcoKTtcclxuXHJcbiAgICBpZiAoKCFpIHx8ICFpLmlzU3RhcnQpICYmICFzdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcclxuICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSk7XHJcblxyXG4gICAgICBpZiAoY2FjaGUuek9yaWdpbiAmJiBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0pIHtcclxuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gKz0gXCIgXCIgKyBjYWNoZS56T3JpZ2luICsgXCJweFwiOyAvLyBzaW5jZSB3ZSdyZSB1bmNhY2hpbmcsIHdlIG11c3QgcHV0IHRoZSB6T3JpZ2luIGJhY2sgaW50byB0aGUgdHJhbnNmb3JtT3JpZ2luIHNvIHRoYXQgd2UgY2FuIHB1bGwgaXQgb3V0IGFjY3VyYXRlbHkgd2hlbiB3ZSBwYXJzZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSdkIGxvc2UgdGhlIHogcG9ydGlvbiBvZiB0aGUgb3JpZ2luIHNpbmNlIHdlIGV4dHJhY3QgaXQgdG8gcHJvdGVjdCBmcm9tIFNhZmFyaSBidWdzLlxyXG5cclxuICAgICAgICBjYWNoZS56T3JpZ2luID0gMDtcclxuICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2FjaGUudW5jYWNoZSA9IDE7IC8vIGlmIGl0J3MgYSBzdGFydEF0IHRoYXQncyBiZWluZyByZXZlcnRlZCBpbiB0aGUgX2luaXRUd2VlbigpIG9mIHRoZSBjb3JlLCB3ZSBkb24ndCBuZWVkIHRvIHVuY2FjaGUgdHJhbnNmb3Jtcy4gVGhpcyBpcyBwdXJlbHkgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG4gICAgX2dldFN0eWxlU2F2ZXIgPSBmdW5jdGlvbiBfZ2V0U3R5bGVTYXZlcih0YXJnZXQsIHByb3BlcnRpZXMpIHtcclxuICB2YXIgc2F2ZXIgPSB7XHJcbiAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgIHByb3BzOiBbXSxcclxuICAgIHJldmVydDogX3JldmVydFN0eWxlLFxyXG4gICAgc2F2ZTogX3NhdmVTdHlsZVxyXG4gIH07XHJcbiAgdGFyZ2V0Ll9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpOyAvLyBqdXN0IG1ha2Ugc3VyZSB0aGVyZSdzIGEgX2dzYXAgY2FjaGUgZGVmaW5lZCBiZWNhdXNlIHdlIHJlYWQgZnJvbSBpdCBpbiBfc2F2ZVN0eWxlKCkgYW5kIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8ganVzdCBjaGVjayBpdCBoZXJlIG9uY2UuXHJcblxyXG4gIHByb3BlcnRpZXMgJiYgdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5ub2RlVHlwZSAmJiBwcm9wZXJ0aWVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gc2F2ZXIuc2F2ZShwKTtcclxuICB9KTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBET00gbm9kZSB0b28uXHJcblxyXG4gIHJldHVybiBzYXZlcjtcclxufSxcclxuICAgIF9zdXBwb3J0czNELFxyXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xyXG4gIHZhciBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBzZXJ2ZXJzIHN3YXAgaW4gaHR0cHMgZm9yIGh0dHAgaW4gdGhlIG5hbWVzcGFjZSB3aGljaCBjYW4gYnJlYWsgdGhpbmdzLCBtYWtpbmcgXCJzdHlsZVwiIGluYWNjZXNzaWJsZS5cclxuXHJcbiAgcmV0dXJuIGUgJiYgZS5zdHlsZSA/IGUgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vc29tZSBlbnZpcm9ubWVudHMgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgd2hlbiBjcmVhdGVkIHdpdGggYSBuYW1lc3BhY2UgaW4gd2hpY2ggY2FzZSB3ZSBkZWZhdWx0IHRvIHRoZSBzdGFuZGFyZCBjcmVhdGVFbGVtZW50KCkgdG8gd29yayBhcm91bmQgdGhlIGlzc3VlLiBBbHNvIG5vdGUgdGhhdCB3aGVuIEdTQVAgaXMgZW1iZWRkZWQgZGlyZWN0bHkgaW5zaWRlIGFuIFNWRyBmaWxlLCBjcmVhdGVFbGVtZW50KCkgd29uJ3QgYWxsb3cgYWNjZXNzIHRvIHRoZSBzdHlsZSBvYmplY3QgaW4gRmlyZWZveCAoc2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cclxufSxcclxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XHJcbiAgdmFyIGNzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gIHJldHVybiBjc1twcm9wZXJ0eV0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KSB8fCAhc2tpcFByZWZpeEZhbGxiYWNrICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX2NoZWNrUHJvcFByZWZpeChwcm9wZXJ0eSkgfHwgcHJvcGVydHksIDEpIHx8IFwiXCI7IC8vY3NzIHZhcmlhYmxlcyBtYXkgbm90IG5lZWQgY2FwcyBzd2FwcGVkIG91dCBmb3IgZGFzaGVzIGFuZCBsb3dlcmNhc2UuXHJcbn0sXHJcbiAgICBfcHJlZml4ZXMgPSBcIk8sTW96LG1zLE1zLFdlYmtpdFwiLnNwbGl0KFwiLFwiKSxcclxuICAgIF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbiBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5LCBlbGVtZW50LCBwcmVmZXJQcmVmaXgpIHtcclxuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXHJcbiAgICAgIHMgPSBlLnN0eWxlLFxyXG4gICAgICBpID0gNTtcclxuXHJcbiAgaWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xyXG4gICAgcmV0dXJuIHByb3BlcnR5O1xyXG4gIH1cclxuXHJcbiAgcHJvcGVydHkgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcclxuXHJcbiAgd2hpbGUgKGktLSAmJiAhKF9wcmVmaXhlc1tpXSArIHByb3BlcnR5IGluIHMpKSB7fVxyXG5cclxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xyXG59LFxyXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xyXG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XHJcbiAgICBfd2luID0gd2luZG93O1xyXG4gICAgX2RvYyA9IF93aW4uZG9jdW1lbnQ7XHJcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgX3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSB8fCB7XHJcbiAgICAgIHN0eWxlOiB7fVxyXG4gICAgfTtcclxuICAgIF90ZW1wRGl2U3R5bGVyID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1Byb3BQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xyXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XHJcbiAgICBfdGVtcERpdi5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXItd2lkdGg6MDtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmc6MFwiOyAvL21ha2Ugc3VyZSB0byBvdmVycmlkZSBjZXJ0YWluIHByb3BlcnRpZXMgdGhhdCBtYXkgY29udGFtaW5hdGUgbWVhc3VyZW1lbnRzLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBvdmVycmVhY2hpbmcgc3R5bGUgc2hlZXRzLlxyXG5cclxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XHJcbiAgICBfcmV2ZXJ0aW5nID0gZ3NhcC5jb3JlLnJldmVydGluZztcclxuICAgIF9wbHVnaW5Jbml0dGVkID0gMTtcclxuICB9XHJcbn0sXHJcbiAgICBfZ2V0UmVwYXJlbnRlZENsb25lQkJveCA9IGZ1bmN0aW9uIF9nZXRSZXBhcmVudGVkQ2xvbmVCQm94KHRhcmdldCkge1xyXG4gIC8vd29ya3MgYXJvdW5kIGlzc3VlcyBpbiBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHRoYXQgZG9uJ3QgY29ycmVjdGx5IHJlcG9ydCBnZXRCQm94KCkgb24gU1ZHIGVsZW1lbnRzIGluc2lkZSBhIDxkZWZzPiBlbGVtZW50IGFuZC9vciA8bWFzaz4uIFdlIHRyeSBjcmVhdGluZyBhbiBTVkcsIGFkZGluZyBpdCB0byB0aGUgZG9jdW1lbnRFbGVtZW50IGFuZCB0b3NzIHRoZSBlbGVtZW50IGluIHRoZXJlIHNvIHRoYXQgaXQncyBkZWZpbml0ZWx5IHBhcnQgb2YgdGhlIHJlbmRlcmluZyB0cmVlLCB0aGVuIGdyYWIgdGhlIGJib3ggYW5kIGlmIGl0IHdvcmtzLCB3ZSBhY3R1YWxseSBzd2FwIG91dCB0aGUgb3JpZ2luYWwgZ2V0QkJveCgpIG1ldGhvZCBmb3Igb3VyIG93biB0aGF0IGRvZXMgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbmV2ZXIgZ2V0QkJveCBpcyBuZWVkZWQuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgcGVyZm9ybWFuY2UgaXMgb3B0aW1hbCAob25seSBkbyBhbGwgdGhlc2UgZXh0cmEgc3RlcHMgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4uLm1vc3QgZWxlbWVudHMgZG9uJ3QgbmVlZCBpdCkuXHJcbiAgdmFyIG93bmVyID0gdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCxcclxuICAgICAgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgb3duZXIgJiYgb3duZXIuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcclxuICAgICAgY2xvbmUgPSB0YXJnZXQuY2xvbmVOb2RlKHRydWUpLFxyXG4gICAgICBiYm94O1xyXG5cclxuICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gIHN2Zy5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblxyXG4gIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBiYm94ID0gY2xvbmUuZ2V0QkJveCgpO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIHN2Zy5yZW1vdmVDaGlsZChjbG9uZSk7XHJcblxyXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XHJcblxyXG4gIHJldHVybiBiYm94O1xyXG59LFxyXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcclxuICB2YXIgaSA9IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSkpIHtcclxuICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc0FycmF5W2ldKTtcclxuICAgIH1cclxuICB9XHJcbn0sXHJcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xyXG4gIHZhciBib3VuZHMsIGNsb25lZDtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGJvdW5kcyA9IHRhcmdldC5nZXRCQm94KCk7IC8vRmlyZWZveCB0aHJvd3MgZXJyb3JzIGlmIHlvdSB0cnkgY2FsbGluZyBnZXRCQm94KCkgb24gYW4gU1ZHIGVsZW1lbnQgdGhhdCdzIG5vdCByZW5kZXJlZCAobGlrZSBpbiBhIDxzeW1ib2w+IG9yIDxkZWZzPikuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYxMjExOFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBib3VuZHMgPSBfZ2V0UmVwYXJlbnRlZENsb25lQkJveCh0YXJnZXQpO1xyXG4gICAgY2xvbmVkID0gMTtcclxuICB9XHJcblxyXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IGNsb25lZCB8fCAoYm91bmRzID0gX2dldFJlcGFyZW50ZWRDbG9uZUJCb3godGFyZ2V0KSk7IC8vc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSBtaXNyZXBvcnQgdGhlIGJvdW5kcyBpZiB0aGUgZWxlbWVudCBoYXMgemVybyB3aWR0aCBhbmQgaGVpZ2h0IChpdCBqdXN0IGFzc3VtZXMgaXQncyBhdCB4OjAsIHk6MCksIHRodXMgd2UgbmVlZCB0byBtYW51YWxseSBncmFiIHRoZSBwb3NpdGlvbiBpbiB0aGF0IGNhc2UuXHJcblxyXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xyXG4gICAgeDogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ4XCIsIFwiY3hcIiwgXCJ4MVwiXSkgfHwgMCxcclxuICAgIHk6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieVwiLCBcImN5XCIsIFwieTFcIl0pIHx8IDAsXHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMFxyXG4gIH0gOiBib3VuZHM7XHJcbn0sXHJcbiAgICBfaXNTVkcgPSBmdW5jdGlvbiBfaXNTVkcoZSkge1xyXG4gIHJldHVybiAhIShlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xyXG59LFxyXG4gICAgLy9yZXBvcnRzIGlmIHRoZSBlbGVtZW50IGlzIGFuIFNWRyBvbiB3aGljaCBnZXRCQm94KCkgYWN0dWFsbHkgd29ya3NcclxuX3JlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHtcclxuICBpZiAocHJvcGVydHkpIHtcclxuICAgIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcclxuICAgICAgICBmaXJzdDJDaGFycztcclxuXHJcbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xyXG4gICAgICBwcm9wZXJ0eSA9IF90cmFuc2Zvcm1Qcm9wO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xyXG4gICAgICBmaXJzdDJDaGFycyA9IHByb3BlcnR5LnN1YnN0cigwLCAyKTtcclxuXHJcbiAgICAgIGlmIChmaXJzdDJDaGFycyA9PT0gXCJtc1wiIHx8IHByb3BlcnR5LnN1YnN0cigwLCA2KSA9PT0gXCJ3ZWJraXRcIikge1xyXG4gICAgICAgIC8vTWljcm9zb2Z0IGFuZCBzb21lIFdlYmtpdCBicm93c2VycyBkb24ndCBjb25mb3JtIHRvIHRoZSBzdGFuZGFyZCBvZiBjYXBpdGFsaXppbmcgdGhlIGZpcnN0IHByZWZpeCBjaGFyYWN0ZXIsIHNvIHdlIGFkanVzdCBzbyB0aGF0IHdoZW4gd2UgcHJlZml4IHRoZSBjYXBzIHdpdGggYSBkYXNoLCBpdCdzIGNvcnJlY3QgKG90aGVyd2lzZSBpdCdkIGJlIFwibXMtdHJhbnNmb3JtXCIgaW5zdGVhZCBvZiBcIi1tcy10cmFuc2Zvcm1cIiBmb3IgSUU5LCBmb3IgZXhhbXBsZSlcclxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KGZpcnN0MkNoYXJzID09PSBcIi0tXCIgPyBwcm9wZXJ0eSA6IHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXHJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcclxuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xyXG4gIHBsdWdpbi5fcHQgPSBwdDtcclxuICBwdC5iID0gYmVnaW5uaW5nO1xyXG4gIHB0LmUgPSBlbmQ7XHJcblxyXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XHJcblxyXG4gIHJldHVybiBwdDtcclxufSxcclxuICAgIF9ub25Db252ZXJ0aWJsZVVuaXRzID0ge1xyXG4gIGRlZzogMSxcclxuICByYWQ6IDEsXHJcbiAgdHVybjogMVxyXG59LFxyXG4gICAgX25vblN0YW5kYXJkTGF5b3V0cyA9IHtcclxuICBncmlkOiAxLFxyXG4gIGZsZXg6IDFcclxufSxcclxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cclxuX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xyXG4gIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXHJcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxyXG4gICAgICAvLyBzb21lIGJyb3dzZXJzIGxlYXZlIGV4dHJhIHdoaXRlc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBDU1MgdmFyaWFibGVzLCBoZW5jZSB0aGUgbmVlZCB0byB0cmltKClcclxuICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxyXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXHJcbiAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXHJcbiAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxyXG4gICAgICBhbW91bnQgPSAxMDAsXHJcbiAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxyXG4gICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcclxuICAgICAgcHgsXHJcbiAgICAgIHBhcmVudCxcclxuICAgICAgY2FjaGUsXHJcbiAgICAgIGlzU1ZHO1xyXG5cclxuICBpZiAodW5pdCA9PT0gY3VyVW5pdCB8fCAhY3VyVmFsdWUgfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbdW5pdF0gfHwgX25vbkNvbnZlcnRpYmxlVW5pdHNbY3VyVW5pdF0pIHtcclxuICAgIHJldHVybiBjdXJWYWx1ZTtcclxuICB9XHJcblxyXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xyXG4gIGlzU1ZHID0gdGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KTtcclxuXHJcbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XHJcbiAgICBweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcclxuICAgIHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xyXG4gIH1cclxuXHJcbiAgc3R5bGVbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdID0gYW1vdW50ICsgKHRvUGl4ZWxzID8gY3VyVW5pdCA6IHVuaXQpO1xyXG4gIHBhcmVudCA9IHVuaXQgIT09IFwicmVtXCIgJiYgfnByb3BlcnR5LmluZGV4T2YoXCJhZGl1c1wiKSB8fCB1bml0ID09PSBcImVtXCIgJiYgdGFyZ2V0LmFwcGVuZENoaWxkICYmICFpc1Jvb3RTVkcgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZTtcclxuXHJcbiAgaWYgKGlzU1ZHKSB7XHJcbiAgICBwYXJlbnQgPSAodGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCB8fCB7fSkucGFyZW50Tm9kZTtcclxuICB9XHJcblxyXG4gIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gX2RvYyB8fCAhcGFyZW50LmFwcGVuZENoaWxkKSB7XHJcbiAgICBwYXJlbnQgPSBfZG9jLmJvZHk7XHJcbiAgfVxyXG5cclxuICBjYWNoZSA9IHBhcmVudC5fZ3NhcDtcclxuXHJcbiAgaWYgKGNhY2hlICYmIHRvUGVyY2VudCAmJiBjYWNoZS53aWR0aCAmJiBob3Jpem9udGFsICYmIGNhY2hlLnRpbWUgPT09IF90aWNrZXIudGltZSAmJiAhY2FjaGUudW5jYWNoZSkge1xyXG4gICAgcmV0dXJuIF9yb3VuZChjdXJWYWx1ZSAvIGNhY2hlLndpZHRoICogYW1vdW50KTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKHRvUGVyY2VudCAmJiAocHJvcGVydHkgPT09IFwiaGVpZ2h0XCIgfHwgcHJvcGVydHkgPT09IFwid2lkdGhcIikpIHtcclxuICAgICAgLy8gaWYgd2UncmUgZGVhbGluZyB3aXRoIHdpZHRoL2hlaWdodCB0aGF0J3MgaW5zaWRlIGEgY29udGFpbmVyIHdpdGggcGFkZGluZyBhbmQvb3IgaXQncyBhIGZsZXhib3gvZ3JpZCBjb250YWluZXIsIHdlIG11c3QgYXBwbHkgaXQgdG8gdGhlIHRhcmdldCBpdHNlbGYgcmF0aGVyIHRoYW4gdGhlIF90ZW1wRGl2IGluIG9yZGVyIHRvIGVuc3VyZSBjb21wbGV0ZSBhY2N1cmFjeSwgZmFjdG9yaW5nIGluIHRoZSBwYXJlbnQncyBwYWRkaW5nLlxyXG4gICAgICB2YXIgdiA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XHJcbiAgICAgIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSBhbW91bnQgKyB1bml0O1xyXG4gICAgICBweCA9IHRhcmdldFttZWFzdXJlUHJvcGVydHldO1xyXG4gICAgICB2ID8gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHYgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAodG9QZXJjZW50IHx8IGN1clVuaXQgPT09IFwiJVwiKSAmJiAhX25vblN0YW5kYXJkTGF5b3V0c1tfZ2V0Q29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQsIFwiZGlzcGxheVwiKV0gJiYgKHN0eWxlLnBvc2l0aW9uID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBcInBvc2l0aW9uXCIpKTtcclxuICAgICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXHJcblxyXG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xyXG4gICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XHJcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfdGVtcERpdik7XHJcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChob3Jpem9udGFsICYmIHRvUGVyY2VudCkge1xyXG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xyXG4gICAgICBjYWNoZS50aW1lID0gX3RpY2tlci50aW1lO1xyXG4gICAgICBjYWNoZS53aWR0aCA9IHBhcmVudFttZWFzdXJlUHJvcGVydHldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcclxufSxcclxuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcclxuICB2YXIgdmFsdWU7XHJcbiAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XHJcblxyXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XHJcbiAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xyXG5cclxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcclxuICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdChcIixcIilbMF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BlcnR5XSAmJiBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xyXG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcclxuICAgIHZhbHVlID0gcHJvcGVydHkgIT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyB2YWx1ZVtwcm9wZXJ0eV0gOiB2YWx1ZS5zdmcgPyB2YWx1ZS5vcmlnaW4gOiBfZmlyc3RUd29Pbmx5KF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApKSArIFwiIFwiICsgdmFsdWUuek9yaWdpbiArIFwicHhcIjtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xyXG5cclxuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09IFwiYXV0b1wiIHx8IHVuY2FjaGUgfHwgfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCJjYWxjKFwiKSkge1xyXG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB1bml0ICYmICF+KHZhbHVlICsgXCJcIikudHJpbSgpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xyXG59LFxyXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XHJcbiAgLy8gbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cclxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0ID09PSBcIm5vbmVcIikge1xyXG4gICAgLy8gc29tZSBicm93c2VycyBsaWtlIFNhZmFyaSBhY3R1YWxseSBQUkVGRVIgdGhlIHByZWZpeGVkIHByb3BlcnR5IGFuZCBtaXMtcmVwb3J0IHRoZSB1bnByZWZpeGVkIHZhbHVlIGxpa2UgY2xpcFBhdGggKEJVRykuIEluIG90aGVyIHdvcmRzLCBldmVuIHRob3VnaCBjbGlwUGF0aCBleGlzdHMgaW4gdGhlIHN0eWxlIChcImNsaXBQYXRoXCIgaW4gdGFyZ2V0LnN0eWxlKSBhbmQgaXQncyBzZXQgaW4gdGhlIENTUyBwcm9wZXJseSAoYWxvbmcgd2l0aCAtd2Via2l0LWNsaXAtcGF0aCksIFNhZmFyaSByZXBvcnRzIGNsaXBQYXRoIGFzIFwibm9uZVwiIHdoZXJlYXMgV2Via2l0Q2xpcFBhdGggcmVwb3J0cyBhY2N1cmF0ZWx5IGxpa2UgXCJlbGxpcHNlKDEwMCUgMCUgYXQgNTAlIDAlKVwiLCBzbyBpbiB0aGlzIGNhc2Ugd2UgbXVzdCBTV0lUQ0ggdG8gdXNpbmcgdGhlIHByZWZpeGVkIHByb3BlcnR5IGluc3RlYWQuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8xODMxMC1jbGlwcGF0aC1kb2VzbnQtd29yay1vbi1pb3MvXHJcbiAgICB2YXIgcCA9IF9jaGVja1Byb3BQcmVmaXgocHJvcCwgdGFyZ2V0LCAxKSxcclxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xyXG5cclxuICAgIGlmIChzICYmIHMgIT09IHN0YXJ0KSB7XHJcbiAgICAgIHByb3AgPSBwO1xyXG4gICAgICBzdGFydCA9IHM7XHJcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiYm9yZGVyQ29sb3JcIikge1xyXG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3NhcC5jb20vZm9ydW1zL3RvcGljLzI0NTgzLWhvdy10by1yZXR1cm4tY29sb3JzLXRoYXQtaS1oYWQtYWZ0ZXItcmV2ZXJzZS9cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxyXG4gICAgICBpbmRleCA9IDAsXHJcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxyXG4gICAgICBhLFxyXG4gICAgICByZXN1bHQsXHJcbiAgICAgIHN0YXJ0VmFsdWVzLFxyXG4gICAgICBzdGFydE51bSxcclxuICAgICAgY29sb3IsXHJcbiAgICAgIHN0YXJ0VmFsdWUsXHJcbiAgICAgIGVuZFZhbHVlLFxyXG4gICAgICBlbmROdW0sXHJcbiAgICAgIGNodW5rLFxyXG4gICAgICBlbmRVbml0LFxyXG4gICAgICBzdGFydFVuaXQsXHJcbiAgICAgIGVuZFZhbHVlcztcclxuICBwdC5iID0gc3RhcnQ7XHJcbiAgcHQuZSA9IGVuZDtcclxuICBzdGFydCArPSBcIlwiOyAvLyBlbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXHJcblxyXG4gIGVuZCArPSBcIlwiO1xyXG5cclxuICBpZiAoZW5kLnN1YnN0cmluZygwLCA2KSA9PT0gXCJ2YXIoLS1cIikge1xyXG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBlbmQuc3Vic3RyaW5nKDQsIGVuZC5pbmRleE9mKFwiKVwiKSkpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcclxuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcF07XHJcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XHJcbiAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcclxuICAgIHN0YXJ0VmFsdWUgPyB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydFZhbHVlIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XHJcbiAgfVxyXG5cclxuICBhID0gW3N0YXJ0LCBlbmRdO1xyXG5cclxuICBfY29sb3JTdHJpbmdGaWx0ZXIoYSk7IC8vIHBhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuIElmIGNvbG9ycyBhcmUgZm91bmQsIGl0IHJldHVybnMgdHJ1ZSBhbmQgdGhlbiB3ZSBtdXN0IG1hdGNoIHdoZXJlIHRoZSBjb2xvciBzaG93cyB1cCBvcmRlci13aXNlIGJlY2F1c2UgZm9yIHRoaW5ncyBsaWtlIGJveFNoYWRvdywgc29tZXRpbWVzIHRoZSBicm93c2VyIHByb3ZpZGVzIHRoZSBjb21wdXRlZCB2YWx1ZXMgd2l0aCB0aGUgY29sb3IgRklSU1QsIGJ1dCB0aGUgdXNlciBwcm92aWRlcyBpdCB3aXRoIHRoZSBjb2xvciBMQVNULCBzbyBmbGlwIHRoZW0gaWYgbmVjZXNzYXJ5LiBTYW1lIGZvciBkcm9wLXNoYWRvdygpLlxyXG5cclxuXHJcbiAgc3RhcnQgPSBhWzBdO1xyXG4gIGVuZCA9IGFbMV07XHJcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xyXG4gIGVuZFZhbHVlcyA9IGVuZC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xyXG5cclxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xyXG4gICAgd2hpbGUgKHJlc3VsdCA9IF9udW1XaXRoVW5pdEV4cC5leGVjKGVuZCkpIHtcclxuICAgICAgZW5kVmFsdWUgPSByZXN1bHRbMF07XHJcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcclxuXHJcbiAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xyXG4gICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcclxuICAgICAgICBjb2xvciA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlbmRWYWx1ZSAhPT0gKHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlc1ttYXRjaEluZGV4KytdIHx8IFwiXCIpKSB7XHJcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XHJcbiAgICAgICAgc3RhcnRVbml0ID0gc3RhcnRWYWx1ZS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcclxuICAgICAgICBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChlbmRWYWx1ZSA9IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCBlbmRWYWx1ZSkgKyBzdGFydFVuaXQpO1xyXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xyXG4gICAgICAgIGVuZFVuaXQgPSBlbmRWYWx1ZS5zdWJzdHIoKGVuZE51bSArIFwiXCIpLmxlbmd0aCk7XHJcbiAgICAgICAgaW5kZXggPSBfbnVtV2l0aFVuaXRFeHAubGFzdEluZGV4IC0gZW5kVW5pdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmICghZW5kVW5pdCkge1xyXG4gICAgICAgICAgLy9pZiBzb21ldGhpbmcgbGlrZSBcInBlcnNwZWN0aXZlOjMwMFwiIGlzIHBhc3NlZCBpbiBhbmQgd2UgbXVzdCBhZGQgYSB1bml0IHRvIHRoZSBlbmRcclxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xyXG5cclxuICAgICAgICAgIGlmIChpbmRleCA9PT0gZW5kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcclxuICAgICAgICAgICAgcHQuZSArPSBlbmRVbml0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xyXG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XHJcbiAgICAgICAgfSAvLyB0aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxyXG5cclxuXHJcbiAgICAgICAgcHQuX3B0ID0ge1xyXG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcclxuICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxyXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXHJcbiAgICAgICAgICBzOiBzdGFydE51bSxcclxuICAgICAgICAgIGM6IGVuZE51bSAtIHN0YXJ0TnVtLFxyXG4gICAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0IHx8IHByb3AgPT09IFwiekluZGV4XCIgPyBNYXRoLnJvdW5kIDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXHJcbiAgfSBlbHNlIHtcclxuICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcclxuICB9XHJcblxyXG4gIF9yZWxFeHAudGVzdChlbmQpICYmIChwdC5lID0gMCk7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cclxuXHJcbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbChwbHVnaW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGFub3RoZXIgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxyXG5cclxuICByZXR1cm4gcHQ7XHJcbn0sXHJcbiAgICBfa2V5d29yZFRvUGVyY2VudCA9IHtcclxuICB0b3A6IFwiMCVcIixcclxuICBib3R0b206IFwiMTAwJVwiLFxyXG4gIGxlZnQ6IFwiMCVcIixcclxuICByaWdodDogXCIxMDAlXCIsXHJcbiAgY2VudGVyOiBcIjUwJVwiXHJcbn0sXHJcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XHJcbiAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxyXG4gICAgICB4ID0gc3BsaXRbMF0sXHJcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xyXG5cclxuICBpZiAoeCA9PT0gXCJ0b3BcIiB8fCB4ID09PSBcImJvdHRvbVwiIHx8IHkgPT09IFwibGVmdFwiIHx8IHkgPT09IFwicmlnaHRcIikge1xyXG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXHJcbiAgICB2YWx1ZSA9IHg7XHJcbiAgICB4ID0geTtcclxuICAgIHkgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcclxuICBzcGxpdFsxXSA9IF9rZXl3b3JkVG9QZXJjZW50W3ldIHx8IHk7XHJcbiAgcmV0dXJuIHNwbGl0LmpvaW4oXCIgXCIpO1xyXG59LFxyXG4gICAgX3JlbmRlckNsZWFyUHJvcHMgPSBmdW5jdGlvbiBfcmVuZGVyQ2xlYXJQcm9wcyhyYXRpbywgZGF0YSkge1xyXG4gIGlmIChkYXRhLnR3ZWVuICYmIGRhdGEudHdlZW4uX3RpbWUgPT09IGRhdGEudHdlZW4uX2R1cikge1xyXG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcclxuICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcclxuICAgICAgICBwcm9wcyA9IGRhdGEudSxcclxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcclxuICAgICAgICBwcm9wLFxyXG4gICAgICAgIGNsZWFyVHJhbnNmb3JtcyxcclxuICAgICAgICBpO1xyXG5cclxuICAgIGlmIChwcm9wcyA9PT0gXCJhbGxcIiB8fCBwcm9wcyA9PT0gdHJ1ZSkge1xyXG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcclxuICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xyXG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XHJcbiAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xyXG5cclxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XHJcbiAgICAgICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xyXG4gICAgICAgICAgcHJvcCA9IHByb3AgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF90cmFuc2Zvcm1Qcm9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XHJcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcclxuXHJcbiAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIGNhY2hlLnN2ZyAmJiB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xyXG4gICAgICAgIHN0eWxlLnNjYWxlID0gc3R5bGUucm90YXRlID0gc3R5bGUudHJhbnNsYXRlID0gXCJub25lXCI7XHJcblxyXG4gICAgICAgIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpOyAvLyBmb3JjZSBhbGwgdGhlIGNhY2hlZCB2YWx1ZXMgYmFjayB0byBcIm5vcm1hbFwiL2lkZW50aXR5LCBvdGhlcndpc2UgaWYgdGhlcmUncyBhbm90aGVyIHR3ZWVuIHRoYXQncyBhbHJlYWR5IHNldCB0byByZW5kZXIgdHJhbnNmb3JtcyBvbiB0aGlzIGVsZW1lbnQsIGl0IGNvdWxkIGRpc3BsYXkgdGhlIHdyb25nIHZhbHVlcy5cclxuXHJcblxyXG4gICAgICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xyXG5cclxuICAgICAgICBfcmVtb3ZlSW5kZXBlbmRlbnRUcmFuc2Zvcm1zKHN0eWxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSxcclxuICAgIC8vIG5vdGU6IHNwZWNpYWxQcm9wcyBzaG91bGQgcmV0dXJuIDEgaWYgKGFuZCBvbmx5IGlmKSB0aGV5IGhhdmUgYSBub24temVybyBwcmlvcml0eS4gSXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gc29ydCB0aGUgbGlua2VkIGxpc3QuXHJcbl9zcGVjaWFsUHJvcHMgPSB7XHJcbiAgY2xlYXJQcm9wczogZnVuY3Rpb24gY2xlYXJQcm9wcyhwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xyXG4gICAgaWYgKHR3ZWVuLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikge1xyXG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XHJcbiAgICAgIHB0LnUgPSBlbmRWYWx1ZTtcclxuICAgICAgcHQucHIgPSAtMTA7XHJcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XHJcblxyXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xyXG5cclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qIGNsYXNzTmFtZSBmZWF0dXJlIChhYm91dCAwLjRrYiBnemlwcGVkKS5cclxuICAsIGNsYXNzTmFtZShwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xyXG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcclxuICBcdFx0XHRkYXRhLmNzcy5yZW5kZXIocmF0aW8sIGRhdGEuY3NzKTtcclxuICBcdFx0XHRpZiAoIXJhdGlvIHx8IHJhdGlvID09PSAxKSB7XHJcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXHJcbiAgXHRcdFx0XHRcdHRhcmdldCA9IGRhdGEudCxcclxuICBcdFx0XHRcdFx0cDtcclxuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XHJcbiAgXHRcdFx0XHRmb3IgKHAgaW4gaW5saW5lKSB7XHJcbiAgXHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHApO1xyXG4gIFx0XHRcdFx0fVxyXG4gIFx0XHRcdH1cclxuICBcdFx0fSxcclxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcclxuICBcdFx0XHRsZXQgc3R5bGVzID0ge30sXHJcbiAgXHRcdFx0XHRjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcclxuICBcdFx0XHRcdHA7XHJcbiAgXHRcdFx0Zm9yIChwIGluIGNvbXB1dGVkKSB7XHJcbiAgXHRcdFx0XHRpZiAoaXNOYU4ocCkgJiYgcCAhPT0gXCJjc3NUZXh0XCIgJiYgcCAhPT0gXCJsZW5ndGhcIikge1xyXG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcclxuICBcdFx0XHRcdH1cclxuICBcdFx0XHR9XHJcbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xyXG4gIFx0XHRcdHJldHVybiBzdHlsZXM7XHJcbiAgXHRcdH0sXHJcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxyXG4gIFx0XHRzdHlsZSA9IHRhcmdldC5zdHlsZSxcclxuICBcdFx0Y3NzVGV4dCA9IHN0eWxlLmNzc1RleHQsXHJcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxyXG4gIFx0XHRjbGFzc1BUID0gY2FjaGUuY2xhc3NQVCxcclxuICBcdFx0aW5saW5lVG9SZW1vdmVBdEVuZCA9IHt9LFxyXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXHJcbiAgXHRcdGNoYW5naW5nVmFycyA9IHt9LFxyXG4gIFx0XHRzdGFydFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCksXHJcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcclxuICBcdFx0ZW5kVmFycywgcDtcclxuICBcdGlmIChjbGFzc1BUKSB7XHJcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xyXG4gIFx0XHRfcmVtb3ZlTGlua2VkTGlzdEl0ZW0oY2xhc3NQVC5kLnBsdWdpbiwgY2xhc3NQVCwgXCJfcHRcIik7XHJcbiAgXHR9XHJcbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcclxuICBcdGVuZFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCwgdHJ1ZSk7XHJcbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgc3RhcnRDbGFzc0xpc3QpO1xyXG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcclxuICBcdFx0aWYgKGVuZFZhcnNbcF0gIT09IHN0YXJ0VmFyc1twXSAmJiAhdHJhbnNmb3JtUmVsYXRlZC50ZXN0KHApKSB7XHJcbiAgXHRcdFx0Y2hhbmdpbmdWYXJzW3BdID0gZW5kVmFyc1twXTtcclxuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xyXG4gIFx0XHRcdFx0aW5saW5lVG9SZW1vdmVBdEVuZFtwXSA9IDE7XHJcbiAgXHRcdFx0fVxyXG4gIFx0XHR9XHJcbiAgXHR9XHJcbiAgXHRjYWNoZS5jbGFzc1BUID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBcImNsYXNzTmFtZVwiLCAwLCAwLCBfcmVuZGVyQ2xhc3NOYW1lLCBkYXRhLCAwLCAtMTEpO1xyXG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjAzNjgtcG9zc2libGUtZ3NhcC1idWctc3dpdGNoaW5nLWNsYXNzbmFtZXMtaW4tY2hyb21lLy5cclxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXHJcbiAgXHR9XHJcbiAgXHRfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB0cnVlKTsgLy90byBjbGVhciB0aGUgY2FjaGluZyBvZiB0cmFuc2Zvcm1zXHJcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XHJcbiAgXHRkYXRhLmNzcy5pbml0KHRhcmdldCwgY2hhbmdpbmdWYXJzLCB0d2Vlbik7XHJcbiAgXHRwbHVnaW4uX3Byb3BzLnB1c2goLi4uZGF0YS5jc3MuX3Byb3BzKTtcclxuICBcdHJldHVybiAxO1xyXG4gIH1cclxuICAqL1xyXG5cclxufSxcclxuXHJcbi8qXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIFRSQU5TRk9STVNcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICovXHJcbl9pZGVudGl0eTJETWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdLFxyXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXHJcbiAgICBfaXNOdWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2lzTnVsbFRyYW5zZm9ybSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCIgfHwgIXZhbHVlO1xyXG59LFxyXG4gICAgX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSB7XHJcbiAgdmFyIG1hdHJpeFN0cmluZyA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xyXG5cclxuICByZXR1cm4gX2lzTnVsbFRyYW5zZm9ybShtYXRyaXhTdHJpbmcpID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXhTdHJpbmcuc3Vic3RyKDcpLm1hdGNoKF9udW1FeHApLm1hcChfcm91bmQpO1xyXG59LFxyXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XHJcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IF9nZXRDYWNoZSh0YXJnZXQpLFxyXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcclxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxyXG4gICAgICBwYXJlbnQsXHJcbiAgICAgIG5leHRTaWJsaW5nLFxyXG4gICAgICB0ZW1wLFxyXG4gICAgICBhZGRlZFRvRE9NO1xyXG5cclxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcclxuICAgIHRlbXAgPSB0YXJnZXQudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKS5tYXRyaXg7IC8vZW5zdXJlcyB0aGF0IGV2ZW4gY29tcGxleCB2YWx1ZXMgbGlrZSBcInRyYW5zbGF0ZSg1MCw2MCkgcm90YXRlKDEzNSwwLDApXCIgYXJlIHBhcnNlZCBiZWNhdXNlIGl0IG1hc2hlcyBpdCBpbnRvIGEgbWF0cml4LlxyXG5cclxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcclxuICAgIHJldHVybiBtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIiA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4O1xyXG4gIH0gZWxzZSBpZiAobWF0cml4ID09PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAhdGFyZ2V0Lm9mZnNldFBhcmVudCAmJiB0YXJnZXQgIT09IF9kb2NFbGVtZW50ICYmICFjYWNoZS5zdmcpIHtcclxuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XHJcbiAgICAvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi4gRmlyZWZveCBhbmQgTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBwYXJ0aWFsIGJ1ZyB3aGVyZSB0aGV5J2xsIHJlcG9ydCB0cmFuc2Zvcm1zIGV2ZW4gaWYgZGlzcGxheTpub25lIEJVVCBub3QgYW55IHBlcmNlbnRhZ2UtYmFzZWQgdmFsdWVzIGxpa2UgdHJhbnNsYXRlKC01MCUsIDhweCkgd2lsbCBiZSByZXBvcnRlZCBhcyBpZiBpdCdzIHRyYW5zbGF0ZSgwLCA4cHgpLlxyXG4gICAgdGVtcCA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcblxyXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQgJiYgIXRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkge1xyXG4gICAgICAvLyBub3RlOiBpbiAzLjMuMCB3ZSBzd2l0Y2hlZCB0YXJnZXQub2Zmc2V0UGFyZW50IHRvIF9kb2MuYm9keS5jb250YWlucyh0YXJnZXQpIHRvIGF2b2lkIFtzb21ldGltZXMgdW5uZWNlc3NhcnldIE11dGF0aW9uT2JzZXJ2ZXIgY2FsbHMgYnV0IHRoYXQgd2Fzbid0IGFkZXF1YXRlIGJlY2F1c2UgdGhlcmUgYXJlIGVkZ2UgY2FzZXMgd2hlcmUgbmVzdGVkIHBvc2l0aW9uOiBmaXhlZCBlbGVtZW50cyBuZWVkIHRvIGdldCByZXBhcmVudGVkIHRvIGFjY3VyYXRlbHkgc2Vuc2UgdHJhbnNmb3Jtcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzg4IGFuZCBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM3NS4gTm90ZTogcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIHJlcG9ydCBhIG51bGwgb2Zmc2V0UGFyZW50IGJ1dCB0aGV5IGNvdWxkIGFsc28gYmUgaW52aXNpYmxlIGJlY2F1c2UgdGhleSdyZSBpbiBhbiBhbmNlc3RvciB3aXRoIGRpc3BsYXk6IG5vbmUsIHNvIHdlIGNoZWNrIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLiBXZSBvbmx5IHdhbnQgdG8gYWx0ZXIgdGhlIERPTSBpZiB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8gYmVjYXVzZSBpdCBjYW4gY2F1c2UgaWZyYW1lIGNvbnRlbnQgdG8gcmVsb2FkLCBsaWtlIGEgVmltZW8gdmlkZW8uXHJcbiAgICAgIGFkZGVkVG9ET00gPSAxOyAvL2ZsYWdcclxuXHJcbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZztcclxuXHJcbiAgICAgIF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHRhcmdldCk7IC8vd2UgbXVzdCBhZGQgaXQgdG8gdGhlIERPTSBpbiBvcmRlciB0byBnZXQgdmFsdWVzIHByb3Blcmx5XHJcblxyXG4gICAgfVxyXG5cclxuICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KTtcclxuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcclxuXHJcbiAgICBpZiAoYWRkZWRUb0RPTSkge1xyXG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZm9yY2UyRCAmJiBtYXRyaXgubGVuZ3RoID4gNiA/IFttYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0sIG1hdHJpeFsxMl0sIG1hdHJpeFsxM11dIDogbWF0cml4O1xyXG59LFxyXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xyXG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcclxuICAgICAgbWF0cml4ID0gbWF0cml4QXJyYXkgfHwgX2dldE1hdHJpeCh0YXJnZXQsIHRydWUpLFxyXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxyXG4gICAgICB5T3JpZ2luT2xkID0gY2FjaGUueU9yaWdpbiB8fCAwLFxyXG4gICAgICB4T2Zmc2V0T2xkID0gY2FjaGUueE9mZnNldCB8fCAwLFxyXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxyXG4gICAgICBhID0gbWF0cml4WzBdLFxyXG4gICAgICBiID0gbWF0cml4WzFdLFxyXG4gICAgICBjID0gbWF0cml4WzJdLFxyXG4gICAgICBkID0gbWF0cml4WzNdLFxyXG4gICAgICB0eCA9IG1hdHJpeFs0XSxcclxuICAgICAgdHkgPSBtYXRyaXhbNV0sXHJcbiAgICAgIG9yaWdpblNwbGl0ID0gb3JpZ2luLnNwbGl0KFwiIFwiKSxcclxuICAgICAgeE9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMF0pIHx8IDAsXHJcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxyXG4gICAgICBib3VuZHMsXHJcbiAgICAgIGRldGVybWluYW50LFxyXG4gICAgICB4LFxyXG4gICAgICB5O1xyXG5cclxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcclxuICAgIGJvdW5kcyA9IF9nZXRCQm94KHRhcmdldCk7XHJcbiAgICB4T3JpZ2luID0gYm91bmRzLnggKyAofm9yaWdpblNwbGl0WzBdLmluZGV4T2YoXCIlXCIpID8geE9yaWdpbiAvIDEwMCAqIGJvdW5kcy53aWR0aCA6IHhPcmlnaW4pO1xyXG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTsgLy8gaWYgKCEoXCJ4T3JpZ2luXCIgaW4gY2FjaGUpICYmICh4T3JpZ2luIHx8IHlPcmlnaW4pKSB7IC8vIGFkZGVkIGluIDMuMTIuMywgcmV2ZXJ0ZWQgaW4gMy4xMi40OyByZXF1aXJlcyBtb3JlIGV4cGxvcmF0aW9uXHJcbiAgICAvLyBcdHhPcmlnaW4gLT0gYm91bmRzLng7XHJcbiAgICAvLyBcdHlPcmlnaW4gLT0gYm91bmRzLnk7XHJcbiAgICAvLyB9XHJcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XHJcbiAgICAvL2lmIGl0J3MgemVybyAobGlrZSBpZiBzY2FsZVggYW5kIHNjYWxlWSBhcmUgemVybyksIHNraXAgaXQgdG8gYXZvaWQgZXJyb3JzIHdpdGggZGl2aWRpbmcgYnkgemVyby5cclxuICAgIHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudDtcclxuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcclxuICAgIHhPcmlnaW4gPSB4O1xyXG4gICAgeU9yaWdpbiA9IHk7IC8vIHRoZW9yeTogd2Ugb25seSBoYWQgdG8gZG8gdGhpcyBmb3Igc21vb3RoaW5nIGFuZCBpdCBhc3N1bWVzIHRoYXQgdGhlIHByZXZpb3VzIG9uZSB3YXMgbm90IG9yaWdpbklzQWJzb2x1dGUuXHJcbiAgfVxyXG5cclxuICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XHJcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xyXG4gICAgdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcclxuICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcclxuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xyXG4gIH1cclxuXHJcbiAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XHJcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XHJcbiAgY2FjaGUuc21vb3RoID0gISFzbW9vdGg7XHJcbiAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xyXG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XHJcbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiMHB4IDBweFwiOyAvL290aGVyd2lzZSwgaWYgc29tZW9uZSBzZXRzICBhbiBvcmlnaW4gdmlhIENTUywgaXQgd2lsbCBsaWtlbHkgaW50ZXJmZXJlIHdpdGggdGhlIFNWRyB0cmFuc2Zvcm0gYXR0cmlidXRlIG9uZXMgKGJlY2F1c2UgcmVtZW1iZXIsIHdlJ3JlIGJha2luZyB0aGUgb3JpZ2luIGludG8gdGhlIG1hdHJpeCgpIHZhbHVlKS5cclxuXHJcbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XHJcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9yaWdpblwiLCB4T3JpZ2luT2xkLCB4T3JpZ2luKTtcclxuXHJcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcclxuXHJcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcclxuXHJcbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9mZnNldFwiLCB5T2Zmc2V0T2xkLCBjYWNoZS55T2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgeE9yaWdpbiArIFwiIFwiICsgeU9yaWdpbik7XHJcbn0sXHJcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XHJcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwIHx8IG5ldyBHU0NhY2hlKHRhcmdldCk7XHJcblxyXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xyXG4gICAgcmV0dXJuIGNhY2hlO1xyXG4gIH1cclxuXHJcbiAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxyXG4gICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXHJcbiAgICAgIHB4ID0gXCJweFwiLFxyXG4gICAgICBkZWcgPSBcImRlZ1wiLFxyXG4gICAgICBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcclxuICAgICAgb3JpZ2luID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCkgfHwgXCIwXCIsXHJcbiAgICAgIHgsXHJcbiAgICAgIHksXHJcbiAgICAgIHosXHJcbiAgICAgIHNjYWxlWCxcclxuICAgICAgc2NhbGVZLFxyXG4gICAgICByb3RhdGlvbixcclxuICAgICAgcm90YXRpb25YLFxyXG4gICAgICByb3RhdGlvblksXHJcbiAgICAgIHNrZXdYLFxyXG4gICAgICBza2V3WSxcclxuICAgICAgcGVyc3BlY3RpdmUsXHJcbiAgICAgIHhPcmlnaW4sXHJcbiAgICAgIHlPcmlnaW4sXHJcbiAgICAgIG1hdHJpeCxcclxuICAgICAgYW5nbGUsXHJcbiAgICAgIGNvcyxcclxuICAgICAgc2luLFxyXG4gICAgICBhLFxyXG4gICAgICBiLFxyXG4gICAgICBjLFxyXG4gICAgICBkLFxyXG4gICAgICBhMTIsXHJcbiAgICAgIGEyMixcclxuICAgICAgdDEsXHJcbiAgICAgIHQyLFxyXG4gICAgICB0MyxcclxuICAgICAgYTEzLFxyXG4gICAgICBhMjMsXHJcbiAgICAgIGEzMyxcclxuICAgICAgYTQyLFxyXG4gICAgICBhNDMsXHJcbiAgICAgIGEzMjtcclxuICB4ID0geSA9IHogPSByb3RhdGlvbiA9IHJvdGF0aW9uWCA9IHJvdGF0aW9uWSA9IHNrZXdYID0gc2tld1kgPSBwZXJzcGVjdGl2ZSA9IDA7XHJcbiAgc2NhbGVYID0gc2NhbGVZID0gMTtcclxuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcclxuXHJcbiAgaWYgKGNzLnRyYW5zbGF0ZSkge1xyXG4gICAgLy8gYWNjb21tb2RhdGUgaW5kZXBlbmRlbnQgdHJhbnNmb3JtcyBieSBjb21iaW5pbmcgdGhlbSBpbnRvIG5vcm1hbCBvbmVzLlxyXG4gICAgaWYgKGNzLnRyYW5zbGF0ZSAhPT0gXCJub25lXCIgfHwgY3Muc2NhbGUgIT09IFwibm9uZVwiIHx8IGNzLnJvdGF0ZSAhPT0gXCJub25lXCIpIHtcclxuICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKGNzLnRyYW5zbGF0ZSAhPT0gXCJub25lXCIgPyBcInRyYW5zbGF0ZTNkKFwiICsgKGNzLnRyYW5zbGF0ZSArIFwiIDAgMFwiKS5zcGxpdChcIiBcIikuc2xpY2UoMCwgMykuam9pbihcIiwgXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3Mucm90YXRlICE9PSBcIm5vbmVcIiA/IFwicm90YXRlKFwiICsgY3Mucm90YXRlICsgXCIpIFwiIDogXCJcIikgKyAoY3Muc2NhbGUgIT09IFwibm9uZVwiID8gXCJzY2FsZShcIiArIGNzLnNjYWxlLnNwbGl0KFwiIFwiKS5qb2luKFwiLFwiKSArIFwiKSBcIiA6IFwiXCIpICsgKGNzW190cmFuc2Zvcm1Qcm9wXSAhPT0gXCJub25lXCIgPyBjc1tfdHJhbnNmb3JtUHJvcF0gOiBcIlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBzdHlsZS5zY2FsZSA9IHN0eWxlLnJvdGF0ZSA9IHN0eWxlLnRyYW5zbGF0ZSA9IFwibm9uZVwiO1xyXG4gIH1cclxuXHJcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XHJcblxyXG4gIGlmIChjYWNoZS5zdmcpIHtcclxuICAgIGlmIChjYWNoZS51bmNhY2hlKSB7XHJcbiAgICAgIC8vIGlmIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSAoYW5kIG1heWJlIGlmIG9yaWdpbiBpcyAwLDApLCB3ZSBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFByZXZpb3VzbHkgd2UgbGV0IHRoZSBkYXRhLXN2Zy1vcmlnaW4gc3RheSBpbnN0ZWFkLCBidXQgd2hlbiBpbnRyb2R1Y2luZyByZXZlcnQoKSwgaXQgY29tcGxpY2F0ZWQgdGhpbmdzLlxyXG4gICAgICB0MiA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICAgIG9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gLSB0Mi54ICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gdDIueSkgKyBcInB4XCI7XHJcbiAgICAgIHQxID0gXCJcIjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHQxID0gIXVuY2FjaGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTsgLy8gIFJlbWVtYmVyLCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGluY29uc2lzdGVuY2llcyB3ZSBhbHdheXMgZm9yY2UgU1ZHIGVsZW1lbnRzJyB0cmFuc2Zvcm1PcmlnaW4gdG8gMCwwIGFuZCBvZmZzZXQgdGhlIHRyYW5zbGF0aW9uIGFjY29yZGluZ2x5LlxyXG4gICAgfVxyXG5cclxuICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xyXG4gIH1cclxuXHJcbiAgeE9yaWdpbiA9IGNhY2hlLnhPcmlnaW4gfHwgMDtcclxuICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xyXG5cclxuICBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xyXG4gICAgYSA9IG1hdHJpeFswXTsgLy9hMTFcclxuXHJcbiAgICBiID0gbWF0cml4WzFdOyAvL2EyMVxyXG5cclxuICAgIGMgPSBtYXRyaXhbMl07IC8vYTMxXHJcblxyXG4gICAgZCA9IG1hdHJpeFszXTsgLy9hNDFcclxuXHJcbiAgICB4ID0gYTEyID0gbWF0cml4WzRdO1xyXG4gICAgeSA9IGEyMiA9IG1hdHJpeFs1XTsgLy8yRCBtYXRyaXhcclxuXHJcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA9PT0gNikge1xyXG4gICAgICBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XHJcbiAgICAgIHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcclxuICAgICAgcm90YXRpb24gPSBhIHx8IGIgPyBfYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXHJcblxyXG4gICAgICBza2V3WCA9IGMgfHwgZCA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xyXG4gICAgICBza2V3WCAmJiAoc2NhbGVZICo9IE1hdGguYWJzKE1hdGguY29zKHNrZXdYICogX0RFRzJSQUQpKSk7XHJcblxyXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XHJcbiAgICAgICAgeCAtPSB4T3JpZ2luIC0gKHhPcmlnaW4gKiBhICsgeU9yaWdpbiAqIGMpO1xyXG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcclxuICAgICAgfSAvLzNEIG1hdHJpeFxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGEzMiA9IG1hdHJpeFs2XTtcclxuICAgICAgYTQyID0gbWF0cml4WzddO1xyXG4gICAgICBhMTMgPSBtYXRyaXhbOF07XHJcbiAgICAgIGEyMyA9IG1hdHJpeFs5XTtcclxuICAgICAgYTMzID0gbWF0cml4WzEwXTtcclxuICAgICAgYTQzID0gbWF0cml4WzExXTtcclxuICAgICAgeCA9IG1hdHJpeFsxMl07XHJcbiAgICAgIHkgPSBtYXRyaXhbMTNdO1xyXG4gICAgICB6ID0gbWF0cml4WzE0XTtcclxuICAgICAgYW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xyXG4gICAgICByb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHOyAvL3JvdGF0aW9uWFxyXG5cclxuICAgICAgaWYgKGFuZ2xlKSB7XHJcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcclxuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xyXG4gICAgICAgIHQxID0gYTEyICogY29zICsgYTEzICogc2luO1xyXG4gICAgICAgIHQyID0gYTIyICogY29zICsgYTIzICogc2luO1xyXG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xyXG4gICAgICAgIGExMyA9IGExMiAqIC1zaW4gKyBhMTMgKiBjb3M7XHJcbiAgICAgICAgYTIzID0gYTIyICogLXNpbiArIGEyMyAqIGNvcztcclxuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xyXG4gICAgICAgIGE0MyA9IGE0MiAqIC1zaW4gKyBhNDMgKiBjb3M7XHJcbiAgICAgICAgYTEyID0gdDE7XHJcbiAgICAgICAgYTIyID0gdDI7XHJcbiAgICAgICAgYTMyID0gdDM7XHJcbiAgICAgIH0gLy9yb3RhdGlvbllcclxuXHJcblxyXG4gICAgICBhbmdsZSA9IF9hdGFuMigtYywgYTMzKTtcclxuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcclxuXHJcbiAgICAgIGlmIChhbmdsZSkge1xyXG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XHJcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcclxuICAgICAgICB0MSA9IGEgKiBjb3MgLSBhMTMgKiBzaW47XHJcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xyXG4gICAgICAgIHQzID0gYyAqIGNvcyAtIGEzMyAqIHNpbjtcclxuICAgICAgICBhNDMgPSBkICogc2luICsgYTQzICogY29zO1xyXG4gICAgICAgIGEgPSB0MTtcclxuICAgICAgICBiID0gdDI7XHJcbiAgICAgICAgYyA9IHQzO1xyXG4gICAgICB9IC8vcm90YXRpb25aXHJcblxyXG5cclxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XHJcbiAgICAgIHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcclxuXHJcbiAgICAgIGlmIChhbmdsZSkge1xyXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcclxuICAgICAgICB0MiA9IGExMiAqIGNvcyArIGEyMiAqIHNpbjtcclxuICAgICAgICBiID0gYiAqIGNvcyAtIGEgKiBzaW47XHJcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xyXG4gICAgICAgIGEgPSB0MTtcclxuICAgICAgICBhMTIgPSB0MjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJvdGF0aW9uWCAmJiBNYXRoLmFicyhyb3RhdGlvblgpICsgTWF0aC5hYnMocm90YXRpb24pID4gMzU5LjkpIHtcclxuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cclxuICAgICAgICByb3RhdGlvblggPSByb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgcm90YXRpb25ZID0gMTgwIC0gcm90YXRpb25ZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xyXG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xyXG4gICAgICBhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XHJcbiAgICAgIHNrZXdYID0gTWF0aC5hYnMoYW5nbGUpID4gMC4wMDAyID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XHJcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYWNoZS5zdmcpIHtcclxuICAgICAgLy9zZW5zZSBpZiB0aGVyZSBhcmUgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvbiBhbiBTVkcgZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gd2hlbiByZW5kZXJpbmcuIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzIG1vcmUgcmVsaWFibGUgY3Jvc3MtYnJvd3NlciwgYnV0IHdlIGNhbid0IGp1c3QgcmVtb3ZlIHRoZSBDU1Mgb25lcyBiZWNhdXNlIHRoZXkgbWF5IGJlIGFwcGxpZWQgaW4gYSBDU1MgcnVsZSBzb21ld2hlcmUgKG5vdCBqdXN0IGlubGluZSkuXHJcbiAgICAgIHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcclxuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcclxuICAgICAgdDEgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0MSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoTWF0aC5hYnMoc2tld1gpID4gOTAgJiYgTWF0aC5hYnMoc2tld1gpIDwgMjcwKSB7XHJcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcclxuICAgICAgc2NhbGVYICo9IC0xO1xyXG4gICAgICBza2V3WCArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcclxuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY2FsZVkgKj0gLTE7XHJcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdW5jYWNoZSA9IHVuY2FjaGUgfHwgY2FjaGUudW5jYWNoZTtcclxuICBjYWNoZS54ID0geCAtICgoY2FjaGUueFBlcmNlbnQgPSB4ICYmICghdW5jYWNoZSAmJiBjYWNoZS54UGVyY2VudCB8fCAoTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSA9PT0gTWF0aC5yb3VuZCgteCkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldFdpZHRoICogY2FjaGUueFBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xyXG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKCF1bmNhY2hlICYmIGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcclxuICBjYWNoZS56ID0geiArIHB4O1xyXG4gIGNhY2hlLnNjYWxlWCA9IF9yb3VuZChzY2FsZVgpO1xyXG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xyXG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcclxuICBjYWNoZS5yb3RhdGlvblggPSBfcm91bmQocm90YXRpb25YKSArIGRlZztcclxuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcclxuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xyXG4gIGNhY2hlLnNrZXdZID0gc2tld1kgKyBkZWc7XHJcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xyXG5cclxuICBpZiAoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgIXVuY2FjaGUgJiYgY2FjaGUuek9yaWdpbiB8fCAwKSB7XHJcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XHJcbiAgfVxyXG5cclxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XHJcbiAgY2FjaGUuZm9yY2UzRCA9IF9jb25maWcuZm9yY2UzRDtcclxuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gPSBjYWNoZS5zdmcgPyBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA6IF9zdXBwb3J0czNEID8gX3JlbmRlckNTU1RyYW5zZm9ybXMgOiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zO1xyXG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xyXG4gIHJldHVybiBjYWNoZTtcclxufSxcclxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XHJcbiAgcmV0dXJuICh2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiIFwiKSlbMF0gKyBcIiBcIiArIHZhbHVlWzFdO1xyXG59LFxyXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxyXG5fYWRkUHhUcmFuc2xhdGUgPSBmdW5jdGlvbiBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCBzdGFydCwgdmFsdWUpIHtcclxuICB2YXIgdW5pdCA9IGdldFVuaXQoc3RhcnQpO1xyXG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcclxufSxcclxuICAgIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xyXG4gIGNhY2hlLnogPSBcIjBweFwiO1xyXG4gIGNhY2hlLnJvdGF0aW9uWSA9IGNhY2hlLnJvdGF0aW9uWCA9IFwiMGRlZ1wiO1xyXG4gIGNhY2hlLmZvcmNlM0QgPSAwO1xyXG5cclxuICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xyXG59LFxyXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcclxuICAgIF96ZXJvUHggPSBcIjBweFwiLFxyXG4gICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxyXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcclxuICB2YXIgX3JlZiA9IGNhY2hlIHx8IHRoaXMsXHJcbiAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcclxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxyXG4gICAgICB4ID0gX3JlZi54LFxyXG4gICAgICB5ID0gX3JlZi55LFxyXG4gICAgICB6ID0gX3JlZi56LFxyXG4gICAgICByb3RhdGlvbiA9IF9yZWYucm90YXRpb24sXHJcbiAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxyXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcclxuICAgICAgc2tld1ggPSBfcmVmLnNrZXdYLFxyXG4gICAgICBza2V3WSA9IF9yZWYuc2tld1ksXHJcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxyXG4gICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcclxuICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxyXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxyXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcclxuICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcclxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXHJcbiAgICAgIHVzZTNEID0gZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEgfHwgZm9yY2UzRCA9PT0gdHJ1ZTsgLy8gU2FmYXJpIGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCBub3QgdG8gcmVuZGVyIDNEIHRyYW5zZm9ybS1vcmlnaW4gdmFsdWVzIHByb3Blcmx5LCBzbyB3ZSBmb3JjZSB0aGUgeiBvcmlnaW4gdG8gMCwgcmVjb3JkIGl0IGluIHRoZSBjYWNoZSwgYW5kIHRoZW4gZG8gdGhlIG1hdGggaGVyZSB0byBvZmZzZXQgdGhlIHRyYW5zbGF0ZSB2YWx1ZXMgYWNjb3JkaW5nbHkgKGJhc2ljYWxseSBkbyB0aGUgM0QgdHJhbnNmb3JtLW9yaWdpbiBwYXJ0IG1hbnVhbGx5KVxyXG5cclxuXHJcbiAgaWYgKHpPcmlnaW4gJiYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcgfHwgcm90YXRpb25ZICE9PSBfemVyb0RlZykpIHtcclxuICAgIHZhciBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25ZKSAqIF9ERUcyUkFELFxyXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcclxuICAgICAgICBhMzMgPSBNYXRoLmNvcyhhbmdsZSksXHJcbiAgICAgICAgY29zO1xyXG5cclxuICAgIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblgpICogX0RFRzJSQUQ7XHJcbiAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xyXG4gICAgeSA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHksIC1NYXRoLnNpbihhbmdsZSkgKiAtek9yaWdpbik7XHJcbiAgICB6ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeiwgYTMzICogY29zICogLXpPcmlnaW4gKyB6T3JpZ2luKTtcclxuICB9XHJcblxyXG4gIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xyXG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XHJcbiAgfVxyXG5cclxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcclxuICAgIHRyYW5zZm9ybXMgKz0gXCJ0cmFuc2xhdGUoXCIgKyB4UGVyY2VudCArIFwiJSwgXCIgKyB5UGVyY2VudCArIFwiJSkgXCI7XHJcbiAgfVxyXG5cclxuICBpZiAodXNlM0QgfHwgeCAhPT0gX3plcm9QeCB8fCB5ICE9PSBfemVyb1B4IHx8IHogIT09IF96ZXJvUHgpIHtcclxuICAgIHRyYW5zZm9ybXMgKz0geiAhPT0gX3plcm9QeCB8fCB1c2UzRCA/IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiLCBcIiArIHogKyBcIikgXCIgOiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgX2VuZFBhcmVudGhlc2lzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xyXG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcclxuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVZKFwiICsgcm90YXRpb25ZICsgX2VuZFBhcmVudGhlc2lzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJvdGF0aW9uWCAhPT0gX3plcm9EZWcpIHtcclxuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRpb25YICsgX2VuZFBhcmVudGhlc2lzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcclxuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcclxuICB9XHJcblxyXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XHJcbiAgICB0cmFuc2Zvcm1zICs9IFwic2NhbGUoXCIgKyBzY2FsZVggKyBcIiwgXCIgKyBzY2FsZVkgKyBfZW5kUGFyZW50aGVzaXM7XHJcbiAgfVxyXG5cclxuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcyB8fCBcInRyYW5zbGF0ZSgwLCAwKVwiO1xyXG59LFxyXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcclxuICB2YXIgX3JlZjIgPSBjYWNoZSB8fCB0aGlzLFxyXG4gICAgICB4UGVyY2VudCA9IF9yZWYyLnhQZXJjZW50LFxyXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxyXG4gICAgICB4ID0gX3JlZjIueCxcclxuICAgICAgeSA9IF9yZWYyLnksXHJcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXHJcbiAgICAgIHNrZXdYID0gX3JlZjIuc2tld1gsXHJcbiAgICAgIHNrZXdZID0gX3JlZjIuc2tld1ksXHJcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcclxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxyXG4gICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXHJcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxyXG4gICAgICB5T3JpZ2luID0gX3JlZjIueU9yaWdpbixcclxuICAgICAgeE9mZnNldCA9IF9yZWYyLnhPZmZzZXQsXHJcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxyXG4gICAgICBmb3JjZUNTUyA9IF9yZWYyLmZvcmNlQ1NTLFxyXG4gICAgICB0eCA9IHBhcnNlRmxvYXQoeCksXHJcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcclxuICAgICAgYTExLFxyXG4gICAgICBhMjEsXHJcbiAgICAgIGExMixcclxuICAgICAgYTIyLFxyXG4gICAgICB0ZW1wO1xyXG5cclxuICByb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xyXG4gIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XHJcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcclxuXHJcbiAgaWYgKHNrZXdZKSB7XHJcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxyXG4gICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcclxuICAgIHNrZXdYICs9IHNrZXdZO1xyXG4gICAgcm90YXRpb24gKz0gc2tld1k7XHJcbiAgfVxyXG5cclxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcclxuICAgIHJvdGF0aW9uICo9IF9ERUcyUkFEO1xyXG4gICAgc2tld1ggKj0gX0RFRzJSQUQ7XHJcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XHJcbiAgICBhMjEgPSBNYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVg7XHJcbiAgICBhMTIgPSBNYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIC1zY2FsZVk7XHJcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcclxuXHJcbiAgICBpZiAoc2tld1gpIHtcclxuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XHJcbiAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WCAtIHNrZXdZKTtcclxuICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xyXG4gICAgICBhMTIgKj0gdGVtcDtcclxuICAgICAgYTIyICo9IHRlbXA7XHJcblxyXG4gICAgICBpZiAoc2tld1kpIHtcclxuICAgICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xyXG4gICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcclxuICAgICAgICBhMTEgKj0gdGVtcDtcclxuICAgICAgICBhMjEgKj0gdGVtcDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGExMSA9IF9yb3VuZChhMTEpO1xyXG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XHJcbiAgICBhMTIgPSBfcm91bmQoYTEyKTtcclxuICAgIGEyMiA9IF9yb3VuZChhMjIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhMTEgPSBzY2FsZVg7XHJcbiAgICBhMjIgPSBzY2FsZVk7XHJcbiAgICBhMjEgPSBhMTIgPSAwO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xyXG4gICAgdHggPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB4LCBcInB4XCIpO1xyXG4gICAgdHkgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieVwiLCB5LCBcInB4XCIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcclxuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcclxuICAgIHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIGlmICh4UGVyY2VudCB8fCB5UGVyY2VudCkge1xyXG4gICAgLy9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSB0cmFuc2xhdGlvbiB0byBzaW11bGF0ZSBpdC5cclxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgdHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xyXG4gICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIHRlbXAgPSBcIm1hdHJpeChcIiArIGExMSArIFwiLFwiICsgYTIxICsgXCIsXCIgKyBhMTIgKyBcIixcIiArIGEyMiArIFwiLFwiICsgdHggKyBcIixcIiArIHR5ICsgXCIpXCI7XHJcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcclxuICBmb3JjZUNTUyAmJiAodGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRlbXApOyAvL3NvbWUgYnJvd3NlcnMgcHJpb3JpdGl6ZSBDU1MgdHJhbnNmb3JtcyBvdmVyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLiBXaGVuIHdlIHNlbnNlIHRoYXQgdGhlIHVzZXIgaGFzIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQsIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gdGhpcyB3YXkgKG90aGVyd2lzZSBzb21lIGJyb3dzZXIgc2ltcGx5IHdvbid0IHJlbmRlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBjaGFuZ2VzISlcclxufSxcclxuICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcclxuICB2YXIgY2FwID0gMzYwLFxyXG4gICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXHJcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcclxuICAgICAgY2hhbmdlID0gZW5kTnVtIC0gc3RhcnROdW0sXHJcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXHJcbiAgICAgIGRpcmVjdGlvbixcclxuICAgICAgcHQ7XHJcblxyXG4gIGlmIChpc1N0cmluZykge1xyXG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xyXG5cclxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xyXG4gICAgICBjaGFuZ2UgJT0gY2FwO1xyXG5cclxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XHJcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJjd1wiICYmIGNoYW5nZSA8IDApIHtcclxuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcclxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcclxuICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcclxuICBwdC5lID0gZmluYWxWYWx1ZTtcclxuICBwdC51ID0gXCJkZWdcIjtcclxuXHJcbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcclxuXHJcbiAgcmV0dXJuIHB0O1xyXG59LFxyXG4gICAgX2Fzc2lnbiA9IGZ1bmN0aW9uIF9hc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcclxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxyXG4gIGZvciAodmFyIHAgaW4gc291cmNlKSB7XHJcbiAgICB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59LFxyXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcclxuICAvL2ZvciBoYW5kbGluZyBjYXNlcyB3aGVyZSBzb21lb25lIHBhc3NlcyBpbiBhIHdob2xlIHRyYW5zZm9ybSBzdHJpbmcsIGxpa2UgdHJhbnNmb3JtOiBcInNjYWxlKDIsIDMpIHJvdGF0ZSgyMGRlZykgdHJhbnNsYXRlWSgzMGVtKVwiXHJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxyXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcclxuICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXHJcbiAgICAgIGVuZENhY2hlLFxyXG4gICAgICBwLFxyXG4gICAgICBzdGFydFZhbHVlLFxyXG4gICAgICBlbmRWYWx1ZSxcclxuICAgICAgc3RhcnROdW0sXHJcbiAgICAgIGVuZE51bSxcclxuICAgICAgc3RhcnRVbml0LFxyXG4gICAgICBlbmRVbml0O1xyXG5cclxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcclxuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xyXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcIlwiKTtcclxuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XHJcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xyXG5cclxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcclxuXHJcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcclxuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XHJcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xyXG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcclxuICB9XHJcblxyXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcclxuICAgIHN0YXJ0VmFsdWUgPSBzdGFydENhY2hlW3BdO1xyXG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcclxuXHJcbiAgICBpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgZXhjbHVkZS5pbmRleE9mKHApIDwgMCkge1xyXG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXHJcbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XHJcbiAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcclxuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcclxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XHJcbiAgICAgIHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcclxuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xyXG5cclxuICAgICAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XHJcbn07IC8vIGhhbmRsZSBzcGxpdHRpbmcgYXBhcnQgcGFkZGluZywgbWFyZ2luLCBib3JkZXJXaWR0aCwgYW5kIGJvcmRlclJhZGl1cyBpbnRvIHRoZWlyIDQgY29tcG9uZW50cy4gRmlyZWZveCwgZm9yIGV4YW1wbGUsIHdvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5IC0gaXQgd2lsbCBvbmx5IGRvIGJvcmRlclRvcExlZnRSYWRpdXMgYW5kIHRoZSBvdGhlciBjb3JuZXJzLiBXZSBhbHNvIHdhbnQgdG8gaGFuZGxlIHBhZGRpbmdUb3AsIG1hcmdpbkxlZnQsIGJvcmRlclJpZ2h0V2lkdGgsIGV0Yy5cclxuXHJcblxyXG5fZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XHJcbiAgdmFyIHQgPSBcIlRvcFwiLFxyXG4gICAgICByID0gXCJSaWdodFwiLFxyXG4gICAgICBiID0gXCJCb3R0b21cIixcclxuICAgICAgbCA9IFwiTGVmdFwiLFxyXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcclxuICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcclxuICB9KTtcclxuXHJcbiAgX3NwZWNpYWxQcm9wc1tpbmRleCA+IDEgPyBcImJvcmRlclwiICsgbmFtZSA6IG5hbWVdID0gZnVuY3Rpb24gKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XHJcbiAgICB2YXIgYSwgdmFycztcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcclxuICAgICAgLy8gZ2V0dGVyLCBwYXNzZWQgdGFyZ2V0LCBwcm9wZXJ0eSwgYW5kIHVuaXQgKGZyb20gX2dldCgpKVxyXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcclxuICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XHJcbiAgICB9XHJcblxyXG4gICAgYSA9IChlbmRWYWx1ZSArIFwiXCIpLnNwbGl0KFwiIFwiKTtcclxuICAgIHZhcnMgPSB7fTtcclxuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcclxuICAgICAgcmV0dXJuIHZhcnNbcHJvcF0gPSBhW2ldID0gYVtpXSB8fCBhWyhpIC0gMSkgLyAyIHwgMF07XHJcbiAgICB9KTtcclxuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuZXhwb3J0IHZhciBDU1NQbHVnaW4gPSB7XHJcbiAgbmFtZTogXCJjc3NcIixcclxuICByZWdpc3RlcjogX2luaXRDb3JlLFxyXG4gIHRhcmdldFRlc3Q6IGZ1bmN0aW9uIHRhcmdldFRlc3QodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0LnN0eWxlICYmIHRhcmdldC5ub2RlVHlwZTtcclxuICB9LFxyXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcclxuICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzLFxyXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxyXG4gICAgICAgIHN0YXJ0QXQgPSB0d2Vlbi52YXJzLnN0YXJ0QXQsXHJcbiAgICAgICAgc3RhcnRWYWx1ZSxcclxuICAgICAgICBlbmRWYWx1ZSxcclxuICAgICAgICBlbmROdW0sXHJcbiAgICAgICAgc3RhcnROdW0sXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBzcGVjaWFsUHJvcCxcclxuICAgICAgICBwLFxyXG4gICAgICAgIHN0YXJ0VW5pdCxcclxuICAgICAgICBlbmRVbml0LFxyXG4gICAgICAgIHJlbGF0aXZlLFxyXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcclxuICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4sXHJcbiAgICAgICAgY2FjaGUsXHJcbiAgICAgICAgc21vb3RoLFxyXG4gICAgICAgIGhhc1ByaW9yaXR5LFxyXG4gICAgICAgIGlubGluZVByb3BzO1xyXG4gICAgX3BsdWdpbkluaXR0ZWQgfHwgX2luaXRDb3JlKCk7IC8vIHdlIG1heSBjYWxsIGluaXQoKSBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwbHVnaW4gaW5zdGFuY2UsIGxpa2Ugd2hlbiBhZGRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzLCBzbyBtYWtlIHN1cmUgd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSByZXZlcnQgZGF0YSBvciBpbmxpbmVQcm9wc1xyXG5cclxuICAgIHRoaXMuc3R5bGVzID0gdGhpcy5zdHlsZXMgfHwgX2dldFN0eWxlU2F2ZXIodGFyZ2V0KTtcclxuICAgIGlubGluZVByb3BzID0gdGhpcy5zdHlsZXMucHJvcHM7XHJcbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XHJcblxyXG4gICAgZm9yIChwIGluIHZhcnMpIHtcclxuICAgICAgaWYgKHAgPT09IFwiYXV0b1JvdW5kXCIpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xyXG5cclxuICAgICAgaWYgKF9wbHVnaW5zW3BdICYmIF9jaGVja1BsdWdpbihwLCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpIHtcclxuICAgICAgICAvLyBwbHVnaW5zXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XHJcbiAgICAgIHNwZWNpYWxQcm9wID0gX3NwZWNpYWxQcm9wc1twXTtcclxuXHJcbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xyXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xyXG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcclxuICAgICAgICBzcGVjaWFsUHJvcCh0aGlzLCB0YXJnZXQsIHAsIGVuZFZhbHVlLCB0d2VlbikgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocC5zdWJzdHIoMCwgMikgPT09IFwiLS1cIikge1xyXG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXHJcbiAgICAgICAgc3RhcnRWYWx1ZSA9IChnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwKSArIFwiXCIpLnRyaW0oKTtcclxuICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xyXG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xyXG5cclxuICAgICAgICBpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7XHJcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xyXG4gICAgICAgICAgc3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcclxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XHJcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcclxuICAgICAgICBwcm9wcy5wdXNoKHApO1xyXG4gICAgICAgIGlubGluZVByb3BzLnB1c2gocCwgMCwgc3R5bGVbcF0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcclxuICAgICAgICAgIC8vIGluIGNhc2Ugc29tZW9uZSBoYXJkLWNvZGVzIGEgY29tcGxleCB2YWx1ZSBhcyB0aGUgc3RhcnQsIGxpa2UgdG9wOiBcImNhbGMoMnZoIC8gMilcIi4gV2l0aG91dCB0aGlzLCBpdCdkIHVzZSB0aGUgY29tcHV0ZWQgdmFsdWUgKGFsd2F5cyBpbiBweClcclxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XHJcbiAgICAgICAgICBfaXNTdHJpbmcoc3RhcnRWYWx1ZSkgJiYgfnN0YXJ0VmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgJiYgKHN0YXJ0VmFsdWUgPSBfcmVwbGFjZVJhbmRvbShzdGFydFZhbHVlKSk7XHJcbiAgICAgICAgICBnZXRVbml0KHN0YXJ0VmFsdWUgKyBcIlwiKSB8fCBzdGFydFZhbHVlID09PSBcImF1dG9cIiB8fCAoc3RhcnRWYWx1ZSArPSBfY29uZmlnLnVuaXRzW3BdIHx8IGdldFVuaXQoX2dldCh0YXJnZXQsIHApKSB8fCBcIlwiKTsgLy8gZm9yIGNhc2VzIHdoZW4gc29tZW9uZSBwYXNzZXMgaW4gYSB1bml0bGVzcyB2YWx1ZSBsaWtlIHt4OiAxMDB9OyBpZiB3ZSB0cnkgc2V0dGluZyB0cmFuc2xhdGUoMTAwLCAwcHgpIGl0IHdvbid0IHdvcmsuXHJcblxyXG4gICAgICAgICAgKHN0YXJ0VmFsdWUgKyBcIlwiKS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApKTsgLy8gY2FuJ3Qgd29yayB3aXRoIHJlbGF0aXZlIHZhbHVlc1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xyXG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIGVuZFZhbHVlLnN1YnN0cigwLCAyKTtcclxuICAgICAgICByZWxhdGl2ZSAmJiAoZW5kVmFsdWUgPSBlbmRWYWx1ZS5zdWJzdHIoMikpO1xyXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAocCBpbiBfcHJvcGVydHlBbGlhc2VzKSB7XHJcbiAgICAgICAgICBpZiAocCA9PT0gXCJhdXRvQWxwaGFcIikge1xyXG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cclxuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtID09PSAxICYmIF9nZXQodGFyZ2V0LCBcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCIgJiYgZW5kTnVtKSB7XHJcbiAgICAgICAgICAgICAgLy9pZiB2aXNpYmlsaXR5IGlzIGluaXRpYWxseSBzZXQgdG8gXCJoaWRkZW5cIiwgd2Ugc2hvdWxkIGludGVycHJldCB0aGF0IGFzIGludGVudCB0byBtYWtlIG9wYWNpdHkgMCAoYSBjb252ZW5pZW5jZSlcclxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlubGluZVByb3BzLnB1c2goXCJ2aXNpYmlsaXR5XCIsIDAsIHN0eWxlLnZpc2liaWxpdHkpO1xyXG5cclxuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgc3R5bGUsIFwidmlzaWJpbGl0eVwiLCBzdGFydE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgZW5kTnVtID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLCAhZW5kTnVtKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocCAhPT0gXCJzY2FsZVwiICYmIHAgIT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgICAgICAgcCA9IF9wcm9wZXJ0eUFsaWFzZXNbcF07XHJcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7IC8vLS0tIFRSQU5TRk9STS1SRUxBVEVEIC0tLVxyXG5cclxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XHJcbiAgICAgICAgICB0aGlzLnN0eWxlcy5zYXZlKHApO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIGVuZFZhbHVlLnN1YnN0cmluZygwLCA2KSA9PT0gXCJ2YXIoLS1cIikge1xyXG4gICAgICAgICAgICBlbmRWYWx1ZSA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgZW5kVmFsdWUuc3Vic3RyaW5nKDQsIGVuZFZhbHVlLmluZGV4T2YoXCIpXCIpKSk7XHJcbiAgICAgICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghdHJhbnNmb3JtUHJvcFR3ZWVuKSB7XHJcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xyXG4gICAgICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gJiYgIXZhcnMucGFyc2VUcmFuc2Zvcm0gfHwgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdmFycy5wYXJzZVRyYW5zZm9ybSk7IC8vIGlmLCBmb3IgZXhhbXBsZSwgZ3NhcC5zZXQoLi4uIHt0cmFuc2Zvcm06XCJ0cmFuc2xhdGVYKDUwdncpXCJ9KSwgdGhlIF9nZXQoKSBjYWxsIGRvZXNuJ3QgcGFyc2UgdGhlIHRyYW5zZm9ybSwgdGh1cyBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gd29uJ3QgYmUgc2V0IHlldCBzbyBmb3JjZSB0aGUgcGFyc2luZyBvZiB0aGUgdHJhbnNmb3JtIGhlcmUuXHJcblxyXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4gPSB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHN0eWxlLCBfdHJhbnNmb3JtUHJvcCwgMCwgMSwgY2FjaGUucmVuZGVyVHJhbnNmb3JtLCBjYWNoZSwgMCwgLTEpOyAvL3RoZSBmaXJzdCB0aW1lIHRocm91Z2gsIGNyZWF0ZSB0aGUgcmVuZGVyaW5nIFByb3BUd2VlbiBzbyB0aGF0IGl0IHJ1bnMgTEFTVCAoaW4gdGhlIGxpbmtlZCBsaXN0LCB3ZSBrZWVwIGFkZGluZyB0byB0aGUgYmVnaW5uaW5nKVxyXG5cclxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgY2FjaGUsIFwic2NhbGVZXCIsIGNhY2hlLnNjYWxlWSwgKHJlbGF0aXZlID8gX3BhcnNlUmVsYXRpdmUoY2FjaGUuc2NhbGVZLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gY2FjaGUuc2NhbGVZIHx8IDAsIF9yZW5kZXJDU1NQcm9wKTtcclxuICAgICAgICAgICAgdGhpcy5fcHQudSA9IDA7XHJcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XHJcbiAgICAgICAgICAgIHAgKz0gXCJYXCI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpIHtcclxuICAgICAgICAgICAgaW5saW5lUHJvcHMucHVzaChfdHJhbnNmb3JtT3JpZ2luUHJvcCwgMCwgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdKTtcclxuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXHJcblxyXG4gICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XHJcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwOyAvL2hhbmRsZSB0aGUgek9yaWdpbiBzZXBhcmF0ZWx5IVxyXG5cclxuICAgICAgICAgICAgICBlbmRVbml0ICE9PSBjYWNoZS56T3JpZ2luICYmIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIGNhY2hlLCBcInpPcmlnaW5cIiwgY2FjaGUuek9yaWdpbiwgZW5kVW5pdCk7XHJcblxyXG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInN2Z09yaWdpblwiKSB7XHJcbiAgICAgICAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIGVuZFZhbHVlLCAxLCBzbW9vdGgsIDAsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgaW4gX3JvdGF0aW9uYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIGNhY2hlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgcmVsYXRpdmUgKyBlbmRWYWx1ZSkgOiBlbmRWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzbW9vdGhPcmlnaW5cIikge1xyXG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcclxuICAgICAgICAgICAgY2FjaGVbcF0gPSBlbmRWYWx1ZTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcclxuICAgICAgICAgICAgX2FkZFJhd1RyYW5zZm9ybVBUcyh0aGlzLCBlbmRWYWx1ZSwgdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xyXG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcclxuICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XHJcbiAgICAgICAgICBlbmROdW0gfHwgKGVuZE51bSA9IDApOyAvLyBwcm90ZWN0IGFnYWluc3QgTmFOXHJcblxyXG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpIHx8IChwIGluIF9jb25maWcudW5pdHMgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcclxuICAgICAgICAgIHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpKTtcclxuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XHJcbiAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xyXG5cclxuICAgICAgICAgIGlmIChzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgZW5kVW5pdCAhPT0gXCIlXCIpIHtcclxuICAgICAgICAgICAgLy93aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXZlcnQgaXQgdG8gdGhlIE9MRC9PUklHSU5BTCB2YWx1ZSAod2l0aCB0aG9zZSB1bml0cykuIFdlIHJlY29yZCB0aGF0IGFzIGEgXCJiXCIgKGJlZ2lubmluZykgcHJvcGVydHkgYW5kIHBvaW50IHRvIGEgcmVuZGVyIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhhdC4gKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcclxuICAgICAgICAgICAgdGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3B0LnIgPSBfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XHJcbiAgICAgICAgICBpZiAocCBpbiB0YXJnZXQpIHtcclxuICAgICAgICAgICAgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cclxuICAgICAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAocCAhPT0gXCJwYXJzZVRyYW5zZm9ybVwiKSB7XHJcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBzdGFydFZhbHVlLCByZWxhdGl2ZSA/IHJlbGF0aXZlICsgZW5kVmFsdWUgOiBlbmRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKHAgaW4gc3R5bGUgPyBpbmxpbmVQcm9wcy5wdXNoKHAsIDAsIHN0eWxlW3BdKSA6IHR5cGVvZiB0YXJnZXRbcF0gPT09IFwiZnVuY3Rpb25cIiA/IGlubGluZVByb3BzLnB1c2gocCwgMiwgdGFyZ2V0W3BdKCkpIDogaW5saW5lUHJvcHMucHVzaChwLCAxLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSkpO1xyXG4gICAgICAgIHByb3BzLnB1c2gocCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHRoaXMpO1xyXG4gIH0sXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcclxuICAgIGlmIChkYXRhLnR3ZWVuLl90aW1lIHx8ICFfcmV2ZXJ0aW5nKCkpIHtcclxuICAgICAgdmFyIHB0ID0gZGF0YS5fcHQ7XHJcblxyXG4gICAgICB3aGlsZSAocHQpIHtcclxuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcclxuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhLnN0eWxlcy5yZXZlcnQoKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGdldDogX2dldCxcclxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxyXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xyXG4gICAgLy9yZXR1cm5zIGEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSBhbmQgYXBwbGllcyBpdCBhY2NvcmRpbmdseS4gUmVtZW1iZXIsIHByb3BlcnRpZXMgbGlrZSBcInhcIiBhcmVuJ3QgYXMgc2ltcGxlIGFzIHRhcmdldC5zdHlsZS5wcm9wZXJ0eSA9IHZhbHVlIGJlY2F1c2UgdGhleSd2ZSBnb3QgdG8gYmUgYXBwbGllZCB0byBhIHByb3h5IG9iamVjdCBhbmQgdGhlbiBtZXJnZWQgaW50byBhIHRyYW5zZm9ybSBzdHJpbmcgaW4gYSByZW5kZXJlci5cclxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XHJcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xyXG4gICAgcmV0dXJuIHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRhcmdldC5fZ3NhcC54IHx8IF9nZXQodGFyZ2V0LCBcInhcIikpID8gcGx1Z2luICYmIF9yZWNlbnRTZXR0ZXJQbHVnaW4gPT09IHBsdWdpbiA/IHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGUgOiBfc2V0dGVyVHJhbnNmb3JtIDogKF9yZWNlbnRTZXR0ZXJQbHVnaW4gPSBwbHVnaW4gfHwge30pICYmIChwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlV2l0aFJlbmRlciA6IF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKSA6IHRhcmdldC5zdHlsZSAmJiAhX2lzVW5kZWZpbmVkKHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0pID8gX3NldHRlckNTU1N0eWxlIDogfnByb3BlcnR5LmluZGV4T2YoXCItXCIpID8gX3NldHRlckNTU1Byb3AgOiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpO1xyXG4gIH0sXHJcbiAgY29yZToge1xyXG4gICAgX3JlbW92ZVByb3BlcnR5OiBfcmVtb3ZlUHJvcGVydHksXHJcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XHJcbiAgfVxyXG59O1xyXG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcclxuZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXIgPSBfZ2V0U3R5bGVTYXZlcjtcclxuXHJcbihmdW5jdGlvbiAocG9zaXRpb25BbmRTY2FsZSwgcm90YXRpb24sIG90aGVycywgYWxpYXNlcykge1xyXG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XHJcbiAgfSk7XHJcblxyXG4gIF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIF9jb25maWcudW5pdHNbbmFtZV0gPSBcImRlZ1wiO1xyXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcclxuICB9KTtcclxuXHJcbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xyXG5cclxuICBfZm9yRWFjaE5hbWUoYWxpYXNlcywgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xyXG4gICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xyXG4gIH0pO1xyXG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XHJcblxyXG5fZm9yRWFjaE5hbWUoXCJ4LHkseix0b3AscmlnaHQsYm90dG9tLGxlZnQsd2lkdGgsaGVpZ2h0LGZvbnRTaXplLHBhZGRpbmcsbWFyZ2luLHBlcnNwZWN0aXZlXCIsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcclxufSk7XHJcblxyXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XHJcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/CSSPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gsap/Observer.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/Observer.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observer: () => (/* binding */ Observer),\n/* harmony export */   _getProxyProp: () => (/* binding */ _getProxyProp),\n/* harmony export */   _getScrollFunc: () => (/* binding */ _getScrollFunc),\n/* harmony export */   _getTarget: () => (/* binding */ _getTarget),\n/* harmony export */   _getVelocityProp: () => (/* binding */ _getVelocityProp),\n/* harmony export */   _horizontal: () => (/* binding */ _horizontal),\n/* harmony export */   _isViewport: () => (/* binding */ _isViewport),\n/* harmony export */   _proxies: () => (/* binding */ _proxies),\n/* harmony export */   _scrollers: () => (/* binding */ _scrollers),\n/* harmony export */   _vertical: () => (/* binding */ _vertical),\n/* harmony export */   \"default\": () => (/* binding */ Observer)\n/* harmony export */ });\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\r\n\r\n/*!\r\n * Observer 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\r\n * Subject to the terms at https://gsap.com/standard-license\r\n * @author: Jack Doyle, jack@greensock.com\r\n*/\r\n\r\n/* eslint-disable */\r\nvar gsap,\r\n    _coreInitted,\r\n    _clamp,\r\n    _win,\r\n    _doc,\r\n    _docEl,\r\n    _body,\r\n    _isTouch,\r\n    _pointerType,\r\n    ScrollTrigger,\r\n    _root,\r\n    _normalizer,\r\n    _eventTypes,\r\n    _context,\r\n    _getGSAP = function _getGSAP() {\r\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n},\r\n    _startup = 1,\r\n    _observers = [],\r\n    _scrollers = [],\r\n    _proxies = [],\r\n    _getTime = Date.now,\r\n    _bridge = function _bridge(name, value) {\r\n  return value;\r\n},\r\n    _integrate = function _integrate() {\r\n  var core = ScrollTrigger.core,\r\n      data = core.bridge || {},\r\n      scrollers = core._scrollers,\r\n      proxies = core._proxies;\r\n  scrollers.push.apply(scrollers, _scrollers);\r\n  proxies.push.apply(proxies, _proxies);\r\n  _scrollers = scrollers;\r\n  _proxies = proxies;\r\n\r\n  _bridge = function _bridge(name, value) {\r\n    return data[name](value);\r\n  };\r\n},\r\n    _getProxyProp = function _getProxyProp(element, property) {\r\n  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];\r\n},\r\n    _isViewport = function _isViewport(el) {\r\n  return !!~_root.indexOf(el);\r\n},\r\n    _addListener = function _addListener(element, type, func, passive, capture) {\r\n  return element.addEventListener(type, func, {\r\n    passive: passive !== false,\r\n    capture: !!capture\r\n  });\r\n},\r\n    _removeListener = function _removeListener(element, type, func, capture) {\r\n  return element.removeEventListener(type, func, !!capture);\r\n},\r\n    _scrollLeft = \"scrollLeft\",\r\n    _scrollTop = \"scrollTop\",\r\n    _onScroll = function _onScroll() {\r\n  return _normalizer && _normalizer.isPressed || _scrollers.cache++;\r\n},\r\n    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {\r\n  var cachingFunc = function cachingFunc(value) {\r\n    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\r\n    if (value || value === 0) {\r\n      _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\r\n\r\n      var isNormalizing = _normalizer && _normalizer.isPressed;\r\n      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\r\n\r\n      f(value);\r\n      cachingFunc.cacheID = _scrollers.cache;\r\n      isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\r\n    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\r\n      cachingFunc.cacheID = _scrollers.cache;\r\n      cachingFunc.v = f();\r\n    }\r\n\r\n    return cachingFunc.v + cachingFunc.offset;\r\n  };\r\n\r\n  cachingFunc.offset = 0;\r\n  return f && cachingFunc;\r\n},\r\n    _horizontal = {\r\n  s: _scrollLeft,\r\n  p: \"left\",\r\n  p2: \"Left\",\r\n  os: \"right\",\r\n  os2: \"Right\",\r\n  d: \"width\",\r\n  d2: \"Width\",\r\n  a: \"x\",\r\n  sc: _scrollCacheFunc(function (value) {\r\n    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\r\n  })\r\n},\r\n    _vertical = {\r\n  s: _scrollTop,\r\n  p: \"top\",\r\n  p2: \"Top\",\r\n  os: \"bottom\",\r\n  os2: \"Bottom\",\r\n  d: \"height\",\r\n  d2: \"Height\",\r\n  a: \"y\",\r\n  op: _horizontal,\r\n  sc: _scrollCacheFunc(function (value) {\r\n    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\r\n  })\r\n},\r\n    _getTarget = function _getTarget(t, self) {\r\n  return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null);\r\n},\r\n    _isWithin = function _isWithin(element, list) {\r\n  // check if the element is in the list or is a descendant of an element in the list.\r\n  var i = list.length;\r\n\r\n  while (i--) {\r\n    if (list[i] === element || list[i].contains(element)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n},\r\n    _getScrollFunc = function _getScrollFunc(element, _ref) {\r\n  var s = _ref.s,\r\n      sc = _ref.sc;\r\n  // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\r\n  _isViewport(element) && (element = _doc.scrollingElement || _docEl);\r\n\r\n  var i = _scrollers.indexOf(element),\r\n      offset = sc === _vertical.sc ? 1 : 2;\r\n\r\n  !~i && (i = _scrollers.push(element) - 1);\r\n  _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\r\n\r\n  var prev = _scrollers[i + offset],\r\n      func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {\r\n    return arguments.length ? element[s] = value : element[s];\r\n  })));\r\n  func.target = element;\r\n  prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\r\n\r\n  return func;\r\n},\r\n    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {\r\n  var v1 = value,\r\n      v2 = value,\r\n      t1 = _getTime(),\r\n      t2 = t1,\r\n      min = minTimeRefresh || 50,\r\n      dropToZeroTime = Math.max(500, min * 3),\r\n      update = function update(value, force) {\r\n    var t = _getTime();\r\n\r\n    if (force || t - t1 > min) {\r\n      v2 = v1;\r\n      v1 = value;\r\n      t2 = t1;\r\n      t1 = t;\r\n    } else if (useDelta) {\r\n      v1 += value;\r\n    } else {\r\n      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\r\n      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\r\n    }\r\n  },\r\n      reset = function reset() {\r\n    v2 = v1 = useDelta ? 0 : v1;\r\n    t2 = t1 = 0;\r\n  },\r\n      getVelocity = function getVelocity(latestValue) {\r\n    var tOld = t2,\r\n        vOld = v2,\r\n        t = _getTime();\r\n\r\n    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\r\n    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\r\n  };\r\n\r\n  return {\r\n    update: update,\r\n    reset: reset,\r\n    getVelocity: getVelocity\r\n  };\r\n},\r\n    _getEvent = function _getEvent(e, preventDefault) {\r\n  preventDefault && !e._gsapAllow && e.preventDefault();\r\n  return e.changedTouches ? e.changedTouches[0] : e;\r\n},\r\n    _getAbsoluteMax = function _getAbsoluteMax(a) {\r\n  var max = Math.max.apply(Math, a),\r\n      min = Math.min.apply(Math, a);\r\n  return Math.abs(max) >= Math.abs(min) ? max : min;\r\n},\r\n    _setScrollTrigger = function _setScrollTrigger() {\r\n  ScrollTrigger = gsap.core.globals().ScrollTrigger;\r\n  ScrollTrigger && ScrollTrigger.core && _integrate();\r\n},\r\n    _initCore = function _initCore(core) {\r\n  gsap = core || _getGSAP();\r\n\r\n  if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\r\n    _win = window;\r\n    _doc = document;\r\n    _docEl = _doc.documentElement;\r\n    _body = _doc.body;\r\n    _root = [_win, _doc, _docEl, _body];\r\n    _clamp = gsap.utils.clamp;\r\n\r\n    _context = gsap.core.context || function () {};\r\n\r\n    _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\r\n\r\n    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\r\n    _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\r\n    setTimeout(function () {\r\n      return _startup = 0;\r\n    }, 500);\r\n\r\n    _setScrollTrigger();\r\n\r\n    _coreInitted = 1;\r\n  }\r\n\r\n  return _coreInitted;\r\n};\r\n\r\n_horizontal.op = _vertical;\r\n_scrollers.cache = 0;\r\nvar Observer = /*#__PURE__*/function () {\r\n  function Observer(vars) {\r\n    this.init(vars);\r\n  }\r\n\r\n  var _proto = Observer.prototype;\r\n\r\n  _proto.init = function init(vars) {\r\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\r\n    ScrollTrigger || _setScrollTrigger();\r\n    var tolerance = vars.tolerance,\r\n        dragMinimum = vars.dragMinimum,\r\n        type = vars.type,\r\n        target = vars.target,\r\n        lineHeight = vars.lineHeight,\r\n        debounce = vars.debounce,\r\n        preventDefault = vars.preventDefault,\r\n        onStop = vars.onStop,\r\n        onStopDelay = vars.onStopDelay,\r\n        ignore = vars.ignore,\r\n        wheelSpeed = vars.wheelSpeed,\r\n        event = vars.event,\r\n        onDragStart = vars.onDragStart,\r\n        onDragEnd = vars.onDragEnd,\r\n        onDrag = vars.onDrag,\r\n        onPress = vars.onPress,\r\n        onRelease = vars.onRelease,\r\n        onRight = vars.onRight,\r\n        onLeft = vars.onLeft,\r\n        onUp = vars.onUp,\r\n        onDown = vars.onDown,\r\n        onChangeX = vars.onChangeX,\r\n        onChangeY = vars.onChangeY,\r\n        onChange = vars.onChange,\r\n        onToggleX = vars.onToggleX,\r\n        onToggleY = vars.onToggleY,\r\n        onHover = vars.onHover,\r\n        onHoverEnd = vars.onHoverEnd,\r\n        onMove = vars.onMove,\r\n        ignoreCheck = vars.ignoreCheck,\r\n        isNormalizer = vars.isNormalizer,\r\n        onGestureStart = vars.onGestureStart,\r\n        onGestureEnd = vars.onGestureEnd,\r\n        onWheel = vars.onWheel,\r\n        onEnable = vars.onEnable,\r\n        onDisable = vars.onDisable,\r\n        onClick = vars.onClick,\r\n        scrollSpeed = vars.scrollSpeed,\r\n        capture = vars.capture,\r\n        allowClicks = vars.allowClicks,\r\n        lockAxis = vars.lockAxis,\r\n        onLockAxis = vars.onLockAxis;\r\n    this.target = target = _getTarget(target) || _docEl;\r\n    this.vars = vars;\r\n    ignore && (ignore = gsap.utils.toArray(ignore));\r\n    tolerance = tolerance || 1e-9;\r\n    dragMinimum = dragMinimum || 0;\r\n    wheelSpeed = wheelSpeed || 1;\r\n    scrollSpeed = scrollSpeed || 1;\r\n    type = type || \"wheel,touch,pointer\";\r\n    debounce = debounce !== false;\r\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\r\n\r\n    var id,\r\n        onStopDelayedCall,\r\n        dragged,\r\n        moved,\r\n        wheeled,\r\n        locked,\r\n        axis,\r\n        self = this,\r\n        prevDeltaX = 0,\r\n        prevDeltaY = 0,\r\n        passive = vars.passive || !preventDefault && vars.passive !== false,\r\n        scrollFuncX = _getScrollFunc(target, _horizontal),\r\n        scrollFuncY = _getScrollFunc(target, _vertical),\r\n        scrollX = scrollFuncX(),\r\n        scrollY = scrollFuncY(),\r\n        limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\",\r\n        // for devices that accommodate mouse events and touch events, we need to distinguish.\r\n    isViewport = _isViewport(target),\r\n        ownerDoc = target.ownerDocument || _doc,\r\n        deltaX = [0, 0, 0],\r\n        // wheel, scroll, pointer/touch\r\n    deltaY = [0, 0, 0],\r\n        onClickTime = 0,\r\n        clickCapture = function clickCapture() {\r\n      return onClickTime = _getTime();\r\n    },\r\n        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {\r\n      return (self.event = e) && ignore && _isWithin(e.target, ignore) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);\r\n    },\r\n        onStopFunc = function onStopFunc() {\r\n      self._vx.reset();\r\n\r\n      self._vy.reset();\r\n\r\n      onStopDelayedCall.pause();\r\n      onStop && onStop(self);\r\n    },\r\n        update = function update() {\r\n      var dx = self.deltaX = _getAbsoluteMax(deltaX),\r\n          dy = self.deltaY = _getAbsoluteMax(deltaY),\r\n          changedX = Math.abs(dx) >= tolerance,\r\n          changedY = Math.abs(dy) >= tolerance;\r\n\r\n      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\r\n\r\n      if (changedX) {\r\n        onRight && self.deltaX > 0 && onRight(self);\r\n        onLeft && self.deltaX < 0 && onLeft(self);\r\n        onChangeX && onChangeX(self);\r\n        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\r\n        prevDeltaX = self.deltaX;\r\n        deltaX[0] = deltaX[1] = deltaX[2] = 0;\r\n      }\r\n\r\n      if (changedY) {\r\n        onDown && self.deltaY > 0 && onDown(self);\r\n        onUp && self.deltaY < 0 && onUp(self);\r\n        onChangeY && onChangeY(self);\r\n        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\r\n        prevDeltaY = self.deltaY;\r\n        deltaY[0] = deltaY[1] = deltaY[2] = 0;\r\n      }\r\n\r\n      if (moved || dragged) {\r\n        onMove && onMove(self);\r\n\r\n        if (dragged) {\r\n          onDragStart && dragged === 1 && onDragStart(self);\r\n          onDrag && onDrag(self);\r\n          dragged = 0;\r\n        }\r\n\r\n        moved = false;\r\n      }\r\n\r\n      locked && !(locked = false) && onLockAxis && onLockAxis(self);\r\n\r\n      if (wheeled) {\r\n        onWheel(self);\r\n        wheeled = false;\r\n      }\r\n\r\n      id = 0;\r\n    },\r\n        onDelta = function onDelta(x, y, index) {\r\n      deltaX[index] += x;\r\n      deltaY[index] += y;\r\n\r\n      self._vx.update(x);\r\n\r\n      self._vy.update(y);\r\n\r\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\r\n    },\r\n        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {\r\n      if (lockAxis && !axis) {\r\n        self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\r\n        locked = true;\r\n      }\r\n\r\n      if (axis !== \"y\") {\r\n        deltaX[2] += x;\r\n\r\n        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\r\n\r\n      }\r\n\r\n      if (axis !== \"x\") {\r\n        deltaY[2] += y;\r\n\r\n        self._vy.update(y, true);\r\n      }\r\n\r\n      debounce ? id || (id = requestAnimationFrame(update)) : update();\r\n    },\r\n        _onDrag = function _onDrag(e) {\r\n      if (_ignoreCheck(e, 1)) {\r\n        return;\r\n      }\r\n\r\n      e = _getEvent(e, preventDefault);\r\n      var x = e.clientX,\r\n          y = e.clientY,\r\n          dx = x - self.x,\r\n          dy = y - self.y,\r\n          isDragging = self.isDragging;\r\n      self.x = x;\r\n      self.y = y;\r\n\r\n      if (isDragging || (dx || dy) && (Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum)) {\r\n        dragged = isDragging ? 2 : 1; // dragged: 0 = not dragging, 1 = first drag, 2 = normal drag\r\n\r\n        isDragging || (self.isDragging = true);\r\n        onTouchOrPointerDelta(dx, dy);\r\n      }\r\n    },\r\n        _onPress = self.onPress = function (e) {\r\n      if (_ignoreCheck(e, 1) || e && e.button) {\r\n        return;\r\n      }\r\n\r\n      self.axis = axis = null;\r\n      onStopDelayedCall.pause();\r\n      self.isPressed = true;\r\n      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\r\n\r\n      prevDeltaX = prevDeltaY = 0;\r\n      self.startX = self.x = e.clientX;\r\n      self.startY = self.y = e.clientY;\r\n\r\n      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\r\n\r\n\r\n      self._vy.reset();\r\n\r\n      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\r\n\r\n      self.deltaX = self.deltaY = 0;\r\n      onPress && onPress(self);\r\n    },\r\n        _onRelease = self.onRelease = function (e) {\r\n      if (_ignoreCheck(e, 1)) {\r\n        return;\r\n      }\r\n\r\n      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\r\n\r\n      var isTrackingDrag = !isNaN(self.y - self.startY),\r\n          wasDragging = self.isDragging,\r\n          isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),\r\n          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\r\n      eventData = _getEvent(e);\r\n\r\n      if (!isDragNotClick && isTrackingDrag) {\r\n        self._vx.reset();\r\n\r\n        self._vy.reset(); //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\r\n\r\n\r\n        if (preventDefault && allowClicks) {\r\n          gsap.delayedCall(0.08, function () {\r\n            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\r\n            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\r\n              if (e.target.click) {\r\n                //some browsers (like mobile Safari) don't properly trigger the click event\r\n                e.target.click();\r\n              } else if (ownerDoc.createEvent) {\r\n                var syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\r\n                syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\r\n                e.target.dispatchEvent(syntheticEvent);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      self.isDragging = self.isGesturing = self.isPressed = false;\r\n      onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\r\n      dragged && update(); // in case debouncing, we don't want onDrag to fire AFTER onDragEnd().\r\n\r\n      onDragEnd && wasDragging && onDragEnd(self);\r\n      onRelease && onRelease(self, isDragNotClick);\r\n    },\r\n        _onGestureStart = function _onGestureStart(e) {\r\n      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);\r\n    },\r\n        _onGestureEnd = function _onGestureEnd() {\r\n      return (self.isGesturing = false) || onGestureEnd(self);\r\n    },\r\n        onScroll = function onScroll(e) {\r\n      if (_ignoreCheck(e)) {\r\n        return;\r\n      }\r\n\r\n      var x = scrollFuncX(),\r\n          y = scrollFuncY();\r\n      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\r\n      scrollX = x;\r\n      scrollY = y;\r\n      onStop && onStopDelayedCall.restart(true);\r\n    },\r\n        _onWheel = function _onWheel(e) {\r\n      if (_ignoreCheck(e)) {\r\n        return;\r\n      }\r\n\r\n      e = _getEvent(e, preventDefault);\r\n      onWheel && (wheeled = true);\r\n      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\r\n      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\r\n      onStop && !isNormalizer && onStopDelayedCall.restart(true);\r\n    },\r\n        _onMove = function _onMove(e) {\r\n      if (_ignoreCheck(e)) {\r\n        return;\r\n      }\r\n\r\n      var x = e.clientX,\r\n          y = e.clientY,\r\n          dx = x - self.x,\r\n          dy = y - self.y;\r\n      self.x = x;\r\n      self.y = y;\r\n      moved = true;\r\n      onStop && onStopDelayedCall.restart(true);\r\n      (dx || dy) && onTouchOrPointerDelta(dx, dy);\r\n    },\r\n        _onHover = function _onHover(e) {\r\n      self.event = e;\r\n      onHover(self);\r\n    },\r\n        _onHoverEnd = function _onHoverEnd(e) {\r\n      self.event = e;\r\n      onHoverEnd(self);\r\n    },\r\n        _onClick = function _onClick(e) {\r\n      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\r\n    };\r\n\r\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\r\n    self.deltaX = self.deltaY = 0;\r\n    self._vx = _getVelocityProp(0, 50, true);\r\n    self._vy = _getVelocityProp(0, 50, true);\r\n    self.scrollX = scrollFuncX;\r\n    self.scrollY = scrollFuncY;\r\n    self.isDragging = self.isGesturing = self.isPressed = false;\r\n\r\n    _context(this);\r\n\r\n    self.enable = function (e) {\r\n      if (!self.isEnabled) {\r\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\r\n\r\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\r\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\r\n\r\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\r\n          _addListener(target, _eventTypes[0], _onPress, passive, capture);\r\n\r\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\r\n\r\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\r\n\r\n          allowClicks && _addListener(target, \"click\", clickCapture, true, true);\r\n          onClick && _addListener(target, \"click\", _onClick);\r\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\r\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\r\n          onHover && _addListener(target, _pointerType + \"enter\", _onHover);\r\n          onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\r\n          onMove && _addListener(target, _pointerType + \"move\", _onMove);\r\n        }\r\n\r\n        self.isEnabled = true;\r\n        self.isDragging = self.isGesturing = self.isPressed = moved = dragged = false;\r\n\r\n        self._vx.reset();\r\n\r\n        self._vy.reset();\r\n\r\n        scrollX = scrollFuncX();\r\n        scrollY = scrollFuncY();\r\n        e && e.type && _onPress(e);\r\n        onEnable && onEnable(self);\r\n      }\r\n\r\n      return self;\r\n    };\r\n\r\n    self.disable = function () {\r\n      if (self.isEnabled) {\r\n        // only remove the _onScroll listener if there aren't any others that rely on the functionality.\r\n        _observers.filter(function (o) {\r\n          return o !== self && _isViewport(o.target);\r\n        }).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\r\n\r\n        if (self.isPressed) {\r\n          self._vx.reset();\r\n\r\n          self._vy.reset();\r\n\r\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\r\n        }\r\n\r\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\r\n\r\n        _removeListener(target, \"wheel\", _onWheel, capture);\r\n\r\n        _removeListener(target, _eventTypes[0], _onPress, capture);\r\n\r\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\r\n\r\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\r\n\r\n        _removeListener(target, \"click\", clickCapture, true);\r\n\r\n        _removeListener(target, \"click\", _onClick);\r\n\r\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\r\n\r\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\r\n\r\n        _removeListener(target, _pointerType + \"enter\", _onHover);\r\n\r\n        _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\r\n\r\n        _removeListener(target, _pointerType + \"move\", _onMove);\r\n\r\n        self.isEnabled = self.isPressed = self.isDragging = false;\r\n        onDisable && onDisable(self);\r\n      }\r\n    };\r\n\r\n    self.kill = self.revert = function () {\r\n      self.disable();\r\n\r\n      var i = _observers.indexOf(self);\r\n\r\n      i >= 0 && _observers.splice(i, 1);\r\n      _normalizer === self && (_normalizer = 0);\r\n    };\r\n\r\n    _observers.push(self);\r\n\r\n    isNormalizer && _isViewport(target) && (_normalizer = self);\r\n    self.enable(event);\r\n  };\r\n\r\n  _createClass(Observer, [{\r\n    key: \"velocityX\",\r\n    get: function get() {\r\n      return this._vx.getVelocity();\r\n    }\r\n  }, {\r\n    key: \"velocityY\",\r\n    get: function get() {\r\n      return this._vy.getVelocity();\r\n    }\r\n  }]);\r\n\r\n  return Observer;\r\n}();\r\nObserver.version = \"3.13.0\";\r\n\r\nObserver.create = function (vars) {\r\n  return new Observer(vars);\r\n};\r\n\r\nObserver.register = _initCore;\r\n\r\nObserver.getAll = function () {\r\n  return _observers.slice();\r\n};\r\n\r\nObserver.getById = function (id) {\r\n  return _observers.filter(function (o) {\r\n    return o.vars.id === id;\r\n  })[0];\r\n};\r\n\r\n_getGSAP() && gsap.registerPlugin(Observer);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3NhcC9PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEO0FBQy9QO0FBQ0EsOERBQThELHNFQUFzRSw4REFBOEQ7QUFDbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseURBQXlEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3NhcFxcT2JzZXJ2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuXHJcbi8qIVxyXG4gKiBPYnNlcnZlciAzLjEzLjBcclxuICogaHR0cHM6Ly9nc2FwLmNvbVxyXG4gKlxyXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZVxyXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cclxuKi9cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlICovXHJcbnZhciBnc2FwLFxyXG4gICAgX2NvcmVJbml0dGVkLFxyXG4gICAgX2NsYW1wLFxyXG4gICAgX3dpbixcclxuICAgIF9kb2MsXHJcbiAgICBfZG9jRWwsXHJcbiAgICBfYm9keSxcclxuICAgIF9pc1RvdWNoLFxyXG4gICAgX3BvaW50ZXJUeXBlLFxyXG4gICAgU2Nyb2xsVHJpZ2dlcixcclxuICAgIF9yb290LFxyXG4gICAgX25vcm1hbGl6ZXIsXHJcbiAgICBfZXZlbnRUeXBlcyxcclxuICAgIF9jb250ZXh0LFxyXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcclxuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcclxufSxcclxuICAgIF9zdGFydHVwID0gMSxcclxuICAgIF9vYnNlcnZlcnMgPSBbXSxcclxuICAgIF9zY3JvbGxlcnMgPSBbXSxcclxuICAgIF9wcm94aWVzID0gW10sXHJcbiAgICBfZ2V0VGltZSA9IERhdGUubm93LFxyXG4gICAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWU7XHJcbn0sXHJcbiAgICBfaW50ZWdyYXRlID0gZnVuY3Rpb24gX2ludGVncmF0ZSgpIHtcclxuICB2YXIgY29yZSA9IFNjcm9sbFRyaWdnZXIuY29yZSxcclxuICAgICAgZGF0YSA9IGNvcmUuYnJpZGdlIHx8IHt9LFxyXG4gICAgICBzY3JvbGxlcnMgPSBjb3JlLl9zY3JvbGxlcnMsXHJcbiAgICAgIHByb3hpZXMgPSBjb3JlLl9wcm94aWVzO1xyXG4gIHNjcm9sbGVycy5wdXNoLmFwcGx5KHNjcm9sbGVycywgX3Njcm9sbGVycyk7XHJcbiAgcHJveGllcy5wdXNoLmFwcGx5KHByb3hpZXMsIF9wcm94aWVzKTtcclxuICBfc2Nyb2xsZXJzID0gc2Nyb2xsZXJzO1xyXG4gIF9wcm94aWVzID0gcHJveGllcztcclxuXHJcbiAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcclxuICAgIHJldHVybiBkYXRhW25hbWVdKHZhbHVlKTtcclxuICB9O1xyXG59LFxyXG4gICAgX2dldFByb3h5UHJvcCA9IGZ1bmN0aW9uIF9nZXRQcm94eVByb3AoZWxlbWVudCwgcHJvcGVydHkpIHtcclxuICByZXR1cm4gfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgJiYgX3Byb3hpZXNbX3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSArIDFdW3Byb3BlcnR5XTtcclxufSxcclxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZWwpIHtcclxuICByZXR1cm4gISF+X3Jvb3QuaW5kZXhPZihlbCk7XHJcbn0sXHJcbiAgICBfYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgcGFzc2l2ZSwgY2FwdHVyZSkge1xyXG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xyXG4gICAgcGFzc2l2ZTogcGFzc2l2ZSAhPT0gZmFsc2UsXHJcbiAgICBjYXB0dXJlOiAhIWNhcHR1cmVcclxuICB9KTtcclxufSxcclxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XHJcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xyXG59LFxyXG4gICAgX3Njcm9sbExlZnQgPSBcInNjcm9sbExlZnRcIixcclxuICAgIF9zY3JvbGxUb3AgPSBcInNjcm9sbFRvcFwiLFxyXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xyXG4gIHJldHVybiBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pc1ByZXNzZWQgfHwgX3Njcm9sbGVycy5jYWNoZSsrO1xyXG59LFxyXG4gICAgX3Njcm9sbENhY2hlRnVuYyA9IGZ1bmN0aW9uIF9zY3JvbGxDYWNoZUZ1bmMoZiwgZG9Ob3RDYWNoZSkge1xyXG4gIHZhciBjYWNoaW5nRnVuYyA9IGZ1bmN0aW9uIGNhY2hpbmdGdW5jKHZhbHVlKSB7XHJcbiAgICAvLyBzaW5jZSByZWFkaW5nIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdC9wYWdlT2Zmc2V0WS9wYWdlT2Zmc2V0WCBjYW4gdHJpZ2dlciBhIGxheW91dCwgdGhpcyBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gY2FjaGUgdGhlIHZhbHVlIHNvIGl0IG9ubHkgZ2V0cyByZWFkIGZyZXNoIGFmdGVyIGEgXCJzY3JvbGxcIiBldmVudCBmaXJlcyAob3Igd2hpbGUgd2UncmUgcmVmcmVzaGluZyBiZWNhdXNlIHRoYXQgY2FuIGxlbmd0aGVuIHRoZSBwYWdlIGFuZCBhbHRlciB0aGUgc2Nyb2xsIHBvc2l0aW9uKS4gd2hlbiBcInNvZnRcIiBpcyB0cnVlLCB0aGF0IG1lYW5zIGRvbid0IGFjdHVhbGx5IHNldCB0aGUgc2Nyb2xsLCBidXQgY2FjaGUgdGhlIG5ldyB2YWx1ZSBpbnN0ZWFkICh1c2VmdWwgaW4gU2Nyb2xsU21vb3RoZXIpXHJcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcclxuICAgICAgX3N0YXJ0dXAgJiYgKF93aW4uaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCIpOyAvLyBvdGhlcndpc2UgdGhlIG5ldyBwb3NpdGlvbiB3aWxsIGdldCBvdmVyd3JpdHRlbiBieSB0aGUgYnJvd3NlciBvbmxvYWQuXHJcblxyXG4gICAgICB2YXIgaXNOb3JtYWxpemluZyA9IF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZDtcclxuICAgICAgdmFsdWUgPSBjYWNoaW5nRnVuYy52ID0gTWF0aC5yb3VuZCh2YWx1ZSkgfHwgKF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlPUyA/IDEgOiAwKTsgLy9UT0RPOiBpT1MgQnVnOiBpZiB5b3UgYWxsb3cgaXQgdG8gZ28gdG8gMCwgU2FmYXJpIGNhbiBzdGFydCB0byByZXBvcnQgc3VwZXIgc3RyYW5nZSAod2lsZGx5IGluYWNjdXJhdGUpIHRvdWNoIHBvc2l0aW9ucyFcclxuXHJcbiAgICAgIGYodmFsdWUpO1xyXG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcclxuICAgICAgaXNOb3JtYWxpemluZyAmJiBfYnJpZGdlKFwic3NcIiwgdmFsdWUpOyAvLyBzZXQgc2Nyb2xsIChub3RpZnkgU2Nyb2xsVHJpZ2dlciBzbyBpdCBjYW4gZGlzcGF0Y2ggYSBcInNjcm9sbFN0YXJ0XCIgZXZlbnQgaWYgbmVjZXNzYXJ5XHJcbiAgICB9IGVsc2UgaWYgKGRvTm90Q2FjaGUgfHwgX3Njcm9sbGVycy5jYWNoZSAhPT0gY2FjaGluZ0Z1bmMuY2FjaGVJRCB8fCBfYnJpZGdlKFwicmVmXCIpKSB7XHJcbiAgICAgIGNhY2hpbmdGdW5jLmNhY2hlSUQgPSBfc2Nyb2xsZXJzLmNhY2hlO1xyXG4gICAgICBjYWNoaW5nRnVuYy52ID0gZigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYWNoaW5nRnVuYy52ICsgY2FjaGluZ0Z1bmMub2Zmc2V0O1xyXG4gIH07XHJcblxyXG4gIGNhY2hpbmdGdW5jLm9mZnNldCA9IDA7XHJcbiAgcmV0dXJuIGYgJiYgY2FjaGluZ0Z1bmM7XHJcbn0sXHJcbiAgICBfaG9yaXpvbnRhbCA9IHtcclxuICBzOiBfc2Nyb2xsTGVmdCxcclxuICBwOiBcImxlZnRcIixcclxuICBwMjogXCJMZWZ0XCIsXHJcbiAgb3M6IFwicmlnaHRcIixcclxuICBvczI6IFwiUmlnaHRcIixcclxuICBkOiBcIndpZHRoXCIsXHJcbiAgZDI6IFwiV2lkdGhcIixcclxuICBhOiBcInhcIixcclxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyh2YWx1ZSwgX3ZlcnRpY2FsLnNjKCkpIDogX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jW19zY3JvbGxMZWZ0XSB8fCBfZG9jRWxbX3Njcm9sbExlZnRdIHx8IF9ib2R5W19zY3JvbGxMZWZ0XSB8fCAwO1xyXG4gIH0pXHJcbn0sXHJcbiAgICBfdmVydGljYWwgPSB7XHJcbiAgczogX3Njcm9sbFRvcCxcclxuICBwOiBcInRvcFwiLFxyXG4gIHAyOiBcIlRvcFwiLFxyXG4gIG9zOiBcImJvdHRvbVwiLFxyXG4gIG9zMjogXCJCb3R0b21cIixcclxuICBkOiBcImhlaWdodFwiLFxyXG4gIGQyOiBcIkhlaWdodFwiLFxyXG4gIGE6IFwieVwiLFxyXG4gIG9wOiBfaG9yaXpvbnRhbCxcclxuICBzYzogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyhfaG9yaXpvbnRhbC5zYygpLCB2YWx1ZSkgOiBfd2luLnBhZ2VZT2Zmc2V0IHx8IF9kb2NbX3Njcm9sbFRvcF0gfHwgX2RvY0VsW19zY3JvbGxUb3BdIHx8IF9ib2R5W19zY3JvbGxUb3BdIHx8IDA7XHJcbiAgfSlcclxufSxcclxuICAgIF9nZXRUYXJnZXQgPSBmdW5jdGlvbiBfZ2V0VGFyZ2V0KHQsIHNlbGYpIHtcclxuICByZXR1cm4gKHNlbGYgJiYgc2VsZi5fY3R4ICYmIHNlbGYuX2N0eC5zZWxlY3RvciB8fCBnc2FwLnV0aWxzLnRvQXJyYXkpKHQpWzBdIHx8ICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIiAmJiBnc2FwLmNvbmZpZygpLm51bGxUYXJnZXRXYXJuICE9PSBmYWxzZSA/IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0KSA6IG51bGwpO1xyXG59LFxyXG4gICAgX2lzV2l0aGluID0gZnVuY3Rpb24gX2lzV2l0aGluKGVsZW1lbnQsIGxpc3QpIHtcclxuICAvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgbGlzdCBvciBpcyBhIGRlc2NlbmRhbnQgb2YgYW4gZWxlbWVudCBpbiB0aGUgbGlzdC5cclxuICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xyXG5cclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBpZiAobGlzdFtpXSA9PT0gZWxlbWVudCB8fCBsaXN0W2ldLmNvbnRhaW5zKGVsZW1lbnQpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59LFxyXG4gICAgX2dldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsRnVuYyhlbGVtZW50LCBfcmVmKSB7XHJcbiAgdmFyIHMgPSBfcmVmLnMsXHJcbiAgICAgIHNjID0gX3JlZi5zYztcclxuICAvLyB3ZSBzdG9yZSB0aGUgc2Nyb2xsZXIgZnVuY3Rpb25zIGluIGFuIGFsdGVybmF0aW5nIHNlcXVlbmNlZCBBcnJheSBsaWtlIFtlbGVtZW50LCB2ZXJ0aWNhbFNjcm9sbEZ1bmMsIGhvcml6b250YWxTY3JvbGxGdW5jLCAuLi5dIHNvIHRoYXQgd2UgY2FuIG1pbmltaXplIG1lbW9yeSwgbWF4aW1pemUgcGVyZm9ybWFuY2UsIGFuZCB3ZSBhbHNvIHJlY29yZCB0aGUgbGFzdCBwb3NpdGlvbiBhcyBhIFwiLnJlY1wiIHByb3BlcnR5IGluIG9yZGVyIHRvIHJldmVydCB0byB0aGF0IGFmdGVyIHJlZnJlc2hpbmcgdG8gZW5zdXJlIHRoaW5ncyBkb24ndCBzaGlmdCBhcm91bmQuXHJcbiAgX2lzVmlld3BvcnQoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZG9jLnNjcm9sbGluZ0VsZW1lbnQgfHwgX2RvY0VsKTtcclxuXHJcbiAgdmFyIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YoZWxlbWVudCksXHJcbiAgICAgIG9mZnNldCA9IHNjID09PSBfdmVydGljYWwuc2MgPyAxIDogMjtcclxuXHJcbiAgIX5pICYmIChpID0gX3Njcm9sbGVycy5wdXNoKGVsZW1lbnQpIC0gMSk7XHJcbiAgX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSB8fCBfYWRkTGlzdGVuZXIoZWxlbWVudCwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gY2xlYXIgdGhlIGNhY2hlIHdoZW4gYSBzY3JvbGwgb2NjdXJzXHJcblxyXG4gIHZhciBwcmV2ID0gX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSxcclxuICAgICAgZnVuYyA9IHByZXYgfHwgKF9zY3JvbGxlcnNbaSArIG9mZnNldF0gPSBfc2Nyb2xsQ2FjaGVGdW5jKF9nZXRQcm94eVByb3AoZWxlbWVudCwgcyksIHRydWUpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IHNjIDogX3Njcm9sbENhY2hlRnVuYyhmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZWxlbWVudFtzXSA9IHZhbHVlIDogZWxlbWVudFtzXTtcclxuICB9KSkpO1xyXG4gIGZ1bmMudGFyZ2V0ID0gZWxlbWVudDtcclxuICBwcmV2IHx8IChmdW5jLnNtb290aCA9IGdzYXAuZ2V0UHJvcGVydHkoZWxlbWVudCwgXCJzY3JvbGxCZWhhdmlvclwiKSA9PT0gXCJzbW9vdGhcIik7IC8vIG9ubHkgc2V0IGl0IHRoZSBmaXJzdCB0aW1lIChkb24ndCByZXNldCBldmVyeSB0aW1lIGEgc2Nyb2xsRnVuYyBpcyByZXF1ZXN0ZWQgYmVjYXVzZSBwZXJoYXBzIGl0IGhhcHBlbnMgZHVyaW5nIGEgcmVmcmVzaCgpIHdoZW4gaXQncyBkaXNhYmxlZCBpbiBTY3JvbGxUcmlnZ2VyLlxyXG5cclxuICByZXR1cm4gZnVuYztcclxufSxcclxuICAgIF9nZXRWZWxvY2l0eVByb3AgPSBmdW5jdGlvbiBfZ2V0VmVsb2NpdHlQcm9wKHZhbHVlLCBtaW5UaW1lUmVmcmVzaCwgdXNlRGVsdGEpIHtcclxuICB2YXIgdjEgPSB2YWx1ZSxcclxuICAgICAgdjIgPSB2YWx1ZSxcclxuICAgICAgdDEgPSBfZ2V0VGltZSgpLFxyXG4gICAgICB0MiA9IHQxLFxyXG4gICAgICBtaW4gPSBtaW5UaW1lUmVmcmVzaCB8fCA1MCxcclxuICAgICAgZHJvcFRvWmVyb1RpbWUgPSBNYXRoLm1heCg1MDAsIG1pbiAqIDMpLFxyXG4gICAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodmFsdWUsIGZvcmNlKSB7XHJcbiAgICB2YXIgdCA9IF9nZXRUaW1lKCk7XHJcblxyXG4gICAgaWYgKGZvcmNlIHx8IHQgLSB0MSA+IG1pbikge1xyXG4gICAgICB2MiA9IHYxO1xyXG4gICAgICB2MSA9IHZhbHVlO1xyXG4gICAgICB0MiA9IHQxO1xyXG4gICAgICB0MSA9IHQ7XHJcbiAgICB9IGVsc2UgaWYgKHVzZURlbHRhKSB7XHJcbiAgICAgIHYxICs9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gbm90IHRvdGFsbHkgbmVjZXNzYXJ5LCBidXQgbWFrZXMgaXQgYSBiaXQgbW9yZSBhY2N1cmF0ZSBieSBhZGp1c3RpbmcgdGhlIHYxIHZhbHVlIGFjY29yZGluZyB0byB0aGUgbmV3IHNsb3BlLiBUaGlzIHdheSB3ZSdyZSBub3QganVzdCBpZ25vcmluZyB0aGUgaW5jb21pbmcgZGF0YS4gUmVtb3ZpbmcgZm9yIG5vdyBiZWNhdXNlIGl0IGRvZXNuJ3Qgc2VlbSB0byBtYWtlIG11Y2ggcHJhY3RpY2FsIGRpZmZlcmVuY2UgYW5kIGl0J3MgcHJvYmFibHkgbm90IHdvcnRoIHRoZSBrYi5cclxuICAgICAgdjEgPSB2MiArICh2YWx1ZSAtIHYyKSAvICh0IC0gdDIpICogKHQxIC0gdDIpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICB2MiA9IHYxID0gdXNlRGVsdGEgPyAwIDogdjE7XHJcbiAgICB0MiA9IHQxID0gMDtcclxuICB9LFxyXG4gICAgICBnZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGxhdGVzdFZhbHVlKSB7XHJcbiAgICB2YXIgdE9sZCA9IHQyLFxyXG4gICAgICAgIHZPbGQgPSB2MixcclxuICAgICAgICB0ID0gX2dldFRpbWUoKTtcclxuXHJcbiAgICAobGF0ZXN0VmFsdWUgfHwgbGF0ZXN0VmFsdWUgPT09IDApICYmIGxhdGVzdFZhbHVlICE9PSB2MSAmJiB1cGRhdGUobGF0ZXN0VmFsdWUpO1xyXG4gICAgcmV0dXJuIHQxID09PSB0MiB8fCB0IC0gdDIgPiBkcm9wVG9aZXJvVGltZSA/IDAgOiAodjEgKyAodXNlRGVsdGEgPyB2T2xkIDogLXZPbGQpKSAvICgodXNlRGVsdGEgPyB0IDogdDEpIC0gdE9sZCkgKiAxMDAwO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB1cGRhdGU6IHVwZGF0ZSxcclxuICAgIHJlc2V0OiByZXNldCxcclxuICAgIGdldFZlbG9jaXR5OiBnZXRWZWxvY2l0eVxyXG4gIH07XHJcbn0sXHJcbiAgICBfZ2V0RXZlbnQgPSBmdW5jdGlvbiBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpIHtcclxuICBwcmV2ZW50RGVmYXVsdCAmJiAhZS5fZ3NhcEFsbG93ICYmIGUucHJldmVudERlZmF1bHQoKTtcclxuICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlO1xyXG59LFxyXG4gICAgX2dldEFic29sdXRlTWF4ID0gZnVuY3Rpb24gX2dldEFic29sdXRlTWF4KGEpIHtcclxuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYSksXHJcbiAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGEpO1xyXG4gIHJldHVybiBNYXRoLmFicyhtYXgpID49IE1hdGguYWJzKG1pbikgPyBtYXggOiBtaW47XHJcbn0sXHJcbiAgICBfc2V0U2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zZXRTY3JvbGxUcmlnZ2VyKCkge1xyXG4gIFNjcm9sbFRyaWdnZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFRyaWdnZXI7XHJcbiAgU2Nyb2xsVHJpZ2dlciAmJiBTY3JvbGxUcmlnZ2VyLmNvcmUgJiYgX2ludGVncmF0ZSgpO1xyXG59LFxyXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcclxuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xyXG5cclxuICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICBfd2luID0gd2luZG93O1xyXG4gICAgX2RvYyA9IGRvY3VtZW50O1xyXG4gICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcclxuICAgIF9yb290ID0gW193aW4sIF9kb2MsIF9kb2NFbCwgX2JvZHldO1xyXG4gICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcclxuXHJcbiAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIF9wb2ludGVyVHlwZSA9IFwib25wb2ludGVyZW50ZXJcIiBpbiBfYm9keSA/IFwicG9pbnRlclwiIDogXCJtb3VzZVwiOyAvLyBpc1RvdWNoIGlzIDAgaWYgbm8gdG91Y2gsIDEgaWYgT05MWSB0b3VjaCwgYW5kIDIgaWYgaXQgY2FuIGFjY29tbW9kYXRlIHRvdWNoIGJ1dCBhbHNvIG90aGVyIHR5cGVzIGxpa2UgbW91c2UvcG9pbnRlci5cclxuXHJcbiAgICBfaXNUb3VjaCA9IE9ic2VydmVyLmlzVG91Y2ggPSBfd2luLm1hdGNoTWVkaWEgJiYgX3dpbi5tYXRjaE1lZGlhKFwiKGhvdmVyOiBub25lKSwgKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlcyA/IDEgOiBcIm9udG91Y2hzdGFydFwiIGluIF93aW4gfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDAgPyAyIDogMDtcclxuICAgIF9ldmVudFR5cGVzID0gT2JzZXJ2ZXIuZXZlbnRUeXBlcyA9IChcIm9udG91Y2hzdGFydFwiIGluIF9kb2NFbCA/IFwidG91Y2hzdGFydCx0b3VjaG1vdmUsdG91Y2hjYW5jZWwsdG91Y2hlbmRcIiA6ICEoXCJvbnBvaW50ZXJkb3duXCIgaW4gX2RvY0VsKSA/IFwibW91c2Vkb3duLG1vdXNlbW92ZSxtb3VzZXVwLG1vdXNldXBcIiA6IFwicG9pbnRlcmRvd24scG9pbnRlcm1vdmUscG9pbnRlcmNhbmNlbCxwb2ludGVydXBcIikuc3BsaXQoXCIsXCIpO1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XHJcbiAgICB9LCA1MDApO1xyXG5cclxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyKCk7XHJcblxyXG4gICAgX2NvcmVJbml0dGVkID0gMTtcclxuICB9XHJcblxyXG4gIHJldHVybiBfY29yZUluaXR0ZWQ7XHJcbn07XHJcblxyXG5faG9yaXpvbnRhbC5vcCA9IF92ZXJ0aWNhbDtcclxuX3Njcm9sbGVycy5jYWNoZSA9IDA7XHJcbmV4cG9ydCB2YXIgT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhcnMpIHtcclxuICAgIHRoaXMuaW5pdCh2YXJzKTtcclxuICB9XHJcblxyXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZlci5wcm90b3R5cGU7XHJcblxyXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzKSB7XHJcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKVwiKTtcclxuICAgIFNjcm9sbFRyaWdnZXIgfHwgX3NldFNjcm9sbFRyaWdnZXIoKTtcclxuICAgIHZhciB0b2xlcmFuY2UgPSB2YXJzLnRvbGVyYW5jZSxcclxuICAgICAgICBkcmFnTWluaW11bSA9IHZhcnMuZHJhZ01pbmltdW0sXHJcbiAgICAgICAgdHlwZSA9IHZhcnMudHlwZSxcclxuICAgICAgICB0YXJnZXQgPSB2YXJzLnRhcmdldCxcclxuICAgICAgICBsaW5lSGVpZ2h0ID0gdmFycy5saW5lSGVpZ2h0LFxyXG4gICAgICAgIGRlYm91bmNlID0gdmFycy5kZWJvdW5jZSxcclxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHZhcnMucHJldmVudERlZmF1bHQsXHJcbiAgICAgICAgb25TdG9wID0gdmFycy5vblN0b3AsXHJcbiAgICAgICAgb25TdG9wRGVsYXkgPSB2YXJzLm9uU3RvcERlbGF5LFxyXG4gICAgICAgIGlnbm9yZSA9IHZhcnMuaWdub3JlLFxyXG4gICAgICAgIHdoZWVsU3BlZWQgPSB2YXJzLndoZWVsU3BlZWQsXHJcbiAgICAgICAgZXZlbnQgPSB2YXJzLmV2ZW50LFxyXG4gICAgICAgIG9uRHJhZ1N0YXJ0ID0gdmFycy5vbkRyYWdTdGFydCxcclxuICAgICAgICBvbkRyYWdFbmQgPSB2YXJzLm9uRHJhZ0VuZCxcclxuICAgICAgICBvbkRyYWcgPSB2YXJzLm9uRHJhZyxcclxuICAgICAgICBvblByZXNzID0gdmFycy5vblByZXNzLFxyXG4gICAgICAgIG9uUmVsZWFzZSA9IHZhcnMub25SZWxlYXNlLFxyXG4gICAgICAgIG9uUmlnaHQgPSB2YXJzLm9uUmlnaHQsXHJcbiAgICAgICAgb25MZWZ0ID0gdmFycy5vbkxlZnQsXHJcbiAgICAgICAgb25VcCA9IHZhcnMub25VcCxcclxuICAgICAgICBvbkRvd24gPSB2YXJzLm9uRG93bixcclxuICAgICAgICBvbkNoYW5nZVggPSB2YXJzLm9uQ2hhbmdlWCxcclxuICAgICAgICBvbkNoYW5nZVkgPSB2YXJzLm9uQ2hhbmdlWSxcclxuICAgICAgICBvbkNoYW5nZSA9IHZhcnMub25DaGFuZ2UsXHJcbiAgICAgICAgb25Ub2dnbGVYID0gdmFycy5vblRvZ2dsZVgsXHJcbiAgICAgICAgb25Ub2dnbGVZID0gdmFycy5vblRvZ2dsZVksXHJcbiAgICAgICAgb25Ib3ZlciA9IHZhcnMub25Ib3ZlcixcclxuICAgICAgICBvbkhvdmVyRW5kID0gdmFycy5vbkhvdmVyRW5kLFxyXG4gICAgICAgIG9uTW92ZSA9IHZhcnMub25Nb3ZlLFxyXG4gICAgICAgIGlnbm9yZUNoZWNrID0gdmFycy5pZ25vcmVDaGVjayxcclxuICAgICAgICBpc05vcm1hbGl6ZXIgPSB2YXJzLmlzTm9ybWFsaXplcixcclxuICAgICAgICBvbkdlc3R1cmVTdGFydCA9IHZhcnMub25HZXN0dXJlU3RhcnQsXHJcbiAgICAgICAgb25HZXN0dXJlRW5kID0gdmFycy5vbkdlc3R1cmVFbmQsXHJcbiAgICAgICAgb25XaGVlbCA9IHZhcnMub25XaGVlbCxcclxuICAgICAgICBvbkVuYWJsZSA9IHZhcnMub25FbmFibGUsXHJcbiAgICAgICAgb25EaXNhYmxlID0gdmFycy5vbkRpc2FibGUsXHJcbiAgICAgICAgb25DbGljayA9IHZhcnMub25DbGljayxcclxuICAgICAgICBzY3JvbGxTcGVlZCA9IHZhcnMuc2Nyb2xsU3BlZWQsXHJcbiAgICAgICAgY2FwdHVyZSA9IHZhcnMuY2FwdHVyZSxcclxuICAgICAgICBhbGxvd0NsaWNrcyA9IHZhcnMuYWxsb3dDbGlja3MsXHJcbiAgICAgICAgbG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzLFxyXG4gICAgICAgIG9uTG9ja0F4aXMgPSB2YXJzLm9uTG9ja0F4aXM7XHJcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldCA9IF9nZXRUYXJnZXQodGFyZ2V0KSB8fCBfZG9jRWw7XHJcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xyXG4gICAgaWdub3JlICYmIChpZ25vcmUgPSBnc2FwLnV0aWxzLnRvQXJyYXkoaWdub3JlKSk7XHJcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMWUtOTtcclxuICAgIGRyYWdNaW5pbXVtID0gZHJhZ01pbmltdW0gfHwgMDtcclxuICAgIHdoZWVsU3BlZWQgPSB3aGVlbFNwZWVkIHx8IDE7XHJcbiAgICBzY3JvbGxTcGVlZCA9IHNjcm9sbFNwZWVkIHx8IDE7XHJcbiAgICB0eXBlID0gdHlwZSB8fCBcIndoZWVsLHRvdWNoLHBvaW50ZXJcIjtcclxuICAgIGRlYm91bmNlID0gZGVib3VuY2UgIT09IGZhbHNlO1xyXG4gICAgbGluZUhlaWdodCB8fCAobGluZUhlaWdodCA9IHBhcnNlRmxvYXQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKF9ib2R5KS5saW5lSGVpZ2h0KSB8fCAyMik7IC8vIG5vdGU6IGJyb3dzZXIgbWF5IHJlcG9ydCBcIm5vcm1hbFwiLCBzbyBkZWZhdWx0IHRvIDIyLlxyXG5cclxuICAgIHZhciBpZCxcclxuICAgICAgICBvblN0b3BEZWxheWVkQ2FsbCxcclxuICAgICAgICBkcmFnZ2VkLFxyXG4gICAgICAgIG1vdmVkLFxyXG4gICAgICAgIHdoZWVsZWQsXHJcbiAgICAgICAgbG9ja2VkLFxyXG4gICAgICAgIGF4aXMsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgcHJldkRlbHRhWCA9IDAsXHJcbiAgICAgICAgcHJldkRlbHRhWSA9IDAsXHJcbiAgICAgICAgcGFzc2l2ZSA9IHZhcnMucGFzc2l2ZSB8fCAhcHJldmVudERlZmF1bHQgJiYgdmFycy5wYXNzaXZlICE9PSBmYWxzZSxcclxuICAgICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxyXG4gICAgICAgIHNjcm9sbEZ1bmNZID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfdmVydGljYWwpLFxyXG4gICAgICAgIHNjcm9sbFggPSBzY3JvbGxGdW5jWCgpLFxyXG4gICAgICAgIHNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpLFxyXG4gICAgICAgIGxpbWl0VG9Ub3VjaCA9IH50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSAmJiAhfnR5cGUuaW5kZXhPZihcInBvaW50ZXJcIikgJiYgX2V2ZW50VHlwZXNbMF0gPT09IFwicG9pbnRlcmRvd25cIixcclxuICAgICAgICAvLyBmb3IgZGV2aWNlcyB0aGF0IGFjY29tbW9kYXRlIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoLlxyXG4gICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHRhcmdldCksXHJcbiAgICAgICAgb3duZXJEb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxyXG4gICAgICAgIGRlbHRhWCA9IFswLCAwLCAwXSxcclxuICAgICAgICAvLyB3aGVlbCwgc2Nyb2xsLCBwb2ludGVyL3RvdWNoXHJcbiAgICBkZWx0YVkgPSBbMCwgMCwgMF0sXHJcbiAgICAgICAgb25DbGlja1RpbWUgPSAwLFxyXG4gICAgICAgIGNsaWNrQ2FwdHVyZSA9IGZ1bmN0aW9uIGNsaWNrQ2FwdHVyZSgpIHtcclxuICAgICAgcmV0dXJuIG9uQ2xpY2tUaW1lID0gX2dldFRpbWUoKTtcclxuICAgIH0sXHJcbiAgICAgICAgX2lnbm9yZUNoZWNrID0gZnVuY3Rpb24gX2lnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpIHtcclxuICAgICAgcmV0dXJuIChzZWxmLmV2ZW50ID0gZSkgJiYgaWdub3JlICYmIF9pc1dpdGhpbihlLnRhcmdldCwgaWdub3JlKSB8fCBpc1BvaW50ZXJPclRvdWNoICYmIGxpbWl0VG9Ub3VjaCAmJiBlLnBvaW50ZXJUeXBlICE9PSBcInRvdWNoXCIgfHwgaWdub3JlQ2hlY2sgJiYgaWdub3JlQ2hlY2soZSwgaXNQb2ludGVyT3JUb3VjaCk7XHJcbiAgICB9LFxyXG4gICAgICAgIG9uU3RvcEZ1bmMgPSBmdW5jdGlvbiBvblN0b3BGdW5jKCkge1xyXG4gICAgICBzZWxmLl92eC5yZXNldCgpO1xyXG5cclxuICAgICAgc2VsZi5fdnkucmVzZXQoKTtcclxuXHJcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnBhdXNlKCk7XHJcbiAgICAgIG9uU3RvcCAmJiBvblN0b3Aoc2VsZik7XHJcbiAgICB9LFxyXG4gICAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgdmFyIGR4ID0gc2VsZi5kZWx0YVggPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFYKSxcclxuICAgICAgICAgIGR5ID0gc2VsZi5kZWx0YVkgPSBfZ2V0QWJzb2x1dGVNYXgoZGVsdGFZKSxcclxuICAgICAgICAgIGNoYW5nZWRYID0gTWF0aC5hYnMoZHgpID49IHRvbGVyYW5jZSxcclxuICAgICAgICAgIGNoYW5nZWRZID0gTWF0aC5hYnMoZHkpID49IHRvbGVyYW5jZTtcclxuXHJcbiAgICAgIG9uQ2hhbmdlICYmIChjaGFuZ2VkWCB8fCBjaGFuZ2VkWSkgJiYgb25DaGFuZ2Uoc2VsZiwgZHgsIGR5LCBkZWx0YVgsIGRlbHRhWSk7IC8vIGluIFNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsKCksIHdlIG5lZWQgdG8ga25vdyBpZiBpdCB3YXMgdG91Y2gvcG9pbnRlciBzbyB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgZGVsdGFYL2RlbHRhWSBBcnJheXMgYmVmb3JlIHdlIGNsZWFyIHRoZW0gb3V0LlxyXG5cclxuICAgICAgaWYgKGNoYW5nZWRYKSB7XHJcbiAgICAgICAgb25SaWdodCAmJiBzZWxmLmRlbHRhWCA+IDAgJiYgb25SaWdodChzZWxmKTtcclxuICAgICAgICBvbkxlZnQgJiYgc2VsZi5kZWx0YVggPCAwICYmIG9uTGVmdChzZWxmKTtcclxuICAgICAgICBvbkNoYW5nZVggJiYgb25DaGFuZ2VYKHNlbGYpO1xyXG4gICAgICAgIG9uVG9nZ2xlWCAmJiBzZWxmLmRlbHRhWCA8IDAgIT09IHByZXZEZWx0YVggPCAwICYmIG9uVG9nZ2xlWChzZWxmKTtcclxuICAgICAgICBwcmV2RGVsdGFYID0gc2VsZi5kZWx0YVg7XHJcbiAgICAgICAgZGVsdGFYWzBdID0gZGVsdGFYWzFdID0gZGVsdGFYWzJdID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNoYW5nZWRZKSB7XHJcbiAgICAgICAgb25Eb3duICYmIHNlbGYuZGVsdGFZID4gMCAmJiBvbkRvd24oc2VsZik7XHJcbiAgICAgICAgb25VcCAmJiBzZWxmLmRlbHRhWSA8IDAgJiYgb25VcChzZWxmKTtcclxuICAgICAgICBvbkNoYW5nZVkgJiYgb25DaGFuZ2VZKHNlbGYpO1xyXG4gICAgICAgIG9uVG9nZ2xlWSAmJiBzZWxmLmRlbHRhWSA8IDAgIT09IHByZXZEZWx0YVkgPCAwICYmIG9uVG9nZ2xlWShzZWxmKTtcclxuICAgICAgICBwcmV2RGVsdGFZID0gc2VsZi5kZWx0YVk7XHJcbiAgICAgICAgZGVsdGFZWzBdID0gZGVsdGFZWzFdID0gZGVsdGFZWzJdID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1vdmVkIHx8IGRyYWdnZWQpIHtcclxuICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKHNlbGYpO1xyXG5cclxuICAgICAgICBpZiAoZHJhZ2dlZCkge1xyXG4gICAgICAgICAgb25EcmFnU3RhcnQgJiYgZHJhZ2dlZCA9PT0gMSAmJiBvbkRyYWdTdGFydChzZWxmKTtcclxuICAgICAgICAgIG9uRHJhZyAmJiBvbkRyYWcoc2VsZik7XHJcbiAgICAgICAgICBkcmFnZ2VkID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1vdmVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxvY2tlZCAmJiAhKGxvY2tlZCA9IGZhbHNlKSAmJiBvbkxvY2tBeGlzICYmIG9uTG9ja0F4aXMoc2VsZik7XHJcblxyXG4gICAgICBpZiAod2hlZWxlZCkge1xyXG4gICAgICAgIG9uV2hlZWwoc2VsZik7XHJcbiAgICAgICAgd2hlZWxlZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZCA9IDA7XHJcbiAgICB9LFxyXG4gICAgICAgIG9uRGVsdGEgPSBmdW5jdGlvbiBvbkRlbHRhKHgsIHksIGluZGV4KSB7XHJcbiAgICAgIGRlbHRhWFtpbmRleF0gKz0geDtcclxuICAgICAgZGVsdGFZW2luZGV4XSArPSB5O1xyXG5cclxuICAgICAgc2VsZi5fdngudXBkYXRlKHgpO1xyXG5cclxuICAgICAgc2VsZi5fdnkudXBkYXRlKHkpO1xyXG5cclxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcclxuICAgIH0sXHJcbiAgICAgICAgb25Ub3VjaE9yUG9pbnRlckRlbHRhID0gZnVuY3Rpb24gb25Ub3VjaE9yUG9pbnRlckRlbHRhKHgsIHkpIHtcclxuICAgICAgaWYgKGxvY2tBeGlzICYmICFheGlzKSB7XHJcbiAgICAgICAgc2VsZi5heGlzID0gYXhpcyA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyBcInhcIiA6IFwieVwiO1xyXG4gICAgICAgIGxvY2tlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChheGlzICE9PSBcInlcIikge1xyXG4gICAgICAgIGRlbHRhWFsyXSArPSB4O1xyXG5cclxuICAgICAgICBzZWxmLl92eC51cGRhdGUoeCwgdHJ1ZSk7IC8vIHVwZGF0ZSB0aGUgdmVsb2NpdHkgYXMgZnJlcXVlbnRseSBhcyBwb3NzaWJsZSBpbnN0ZWFkIG9mIGluIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gc28gdGhhdCB2ZXJ5IHF1aWNrIHRvdWNoLXNjcm9sbHMgKGZsaWNrcykgZmVlbCBuYXR1cmFsLiBJZiBpdCdzIHRoZSBtb3VzZS90b3VjaC9wb2ludGVyLCBmb3JjZSBpdCBzbyB0aGF0IHdlIGdldCBzbmFwcHkvYWNjdXJhdGUgbW9tZW50dW0gc2Nyb2xsLlxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGF4aXMgIT09IFwieFwiKSB7XHJcbiAgICAgICAgZGVsdGFZWzJdICs9IHk7XHJcblxyXG4gICAgICAgIHNlbGYuX3Z5LnVwZGF0ZSh5LCB0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGVib3VuY2UgPyBpZCB8fCAoaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKSkgOiB1cGRhdGUoKTtcclxuICAgIH0sXHJcbiAgICAgICAgX29uRHJhZyA9IGZ1bmN0aW9uIF9vbkRyYWcoZSkge1xyXG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcclxuICAgICAgdmFyIHggPSBlLmNsaWVudFgsXHJcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxyXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxyXG4gICAgICAgICAgZHkgPSB5IC0gc2VsZi55LFxyXG4gICAgICAgICAgaXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZztcclxuICAgICAgc2VsZi54ID0geDtcclxuICAgICAgc2VsZi55ID0geTtcclxuXHJcbiAgICAgIGlmIChpc0RyYWdnaW5nIHx8IChkeCB8fCBkeSkgJiYgKE1hdGguYWJzKHNlbGYuc3RhcnRYIC0geCkgPj0gZHJhZ01pbmltdW0gfHwgTWF0aC5hYnMoc2VsZi5zdGFydFkgLSB5KSA+PSBkcmFnTWluaW11bSkpIHtcclxuICAgICAgICBkcmFnZ2VkID0gaXNEcmFnZ2luZyA/IDIgOiAxOyAvLyBkcmFnZ2VkOiAwID0gbm90IGRyYWdnaW5nLCAxID0gZmlyc3QgZHJhZywgMiA9IG5vcm1hbCBkcmFnXHJcblxyXG4gICAgICAgIGlzRHJhZ2dpbmcgfHwgKHNlbGYuaXNEcmFnZ2luZyA9IHRydWUpO1xyXG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgICAgIF9vblByZXNzID0gc2VsZi5vblByZXNzID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlLCAxKSB8fCBlICYmIGUuYnV0dG9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZWxmLmF4aXMgPSBheGlzID0gbnVsbDtcclxuICAgICAgb25TdG9wRGVsYXllZENhbGwucGF1c2UoKTtcclxuICAgICAgc2VsZi5pc1ByZXNzZWQgPSB0cnVlO1xyXG4gICAgICBlID0gX2dldEV2ZW50KGUpOyAvLyBub3RlOiBtYXkgbmVlZCB0byBwcmV2ZW50RGVmYXVsdCg/KSBXb24ndCBzaWRlLXNjcm9sbCBvbiBpT1MgU2FmYXJpIGlmIHdlIGRvLCB0aG91Z2guXHJcblxyXG4gICAgICBwcmV2RGVsdGFYID0gcHJldkRlbHRhWSA9IDA7XHJcbiAgICAgIHNlbGYuc3RhcnRYID0gc2VsZi54ID0gZS5jbGllbnRYO1xyXG4gICAgICBzZWxmLnN0YXJ0WSA9IHNlbGYueSA9IGUuY2xpZW50WTtcclxuXHJcbiAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7IC8vIG90aGVyd2lzZSB0aGUgdDIgbWF5IGJlIHN0YWxlIGlmIHRoZSB1c2VyIHRvdWNoZXMgYW5kIGZsaWNrcyBzdXBlciBmYXN0IGFuZCByZWxlYXNlcyBpbiBsZXNzIHRoYW4gMiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGlja3MsIGNhdXNpbmcgdmVsb2NpdHkgdG8gYmUgMC5cclxuXHJcblxyXG4gICAgICBzZWxmLl92eS5yZXNldCgpO1xyXG5cclxuICAgICAgX2FkZExpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgcGFzc2l2ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcclxuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xyXG4gICAgfSxcclxuICAgICAgICBfb25SZWxlYXNlID0gc2VsZi5vblJlbGVhc2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUsIDEpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcclxuXHJcbiAgICAgIHZhciBpc1RyYWNraW5nRHJhZyA9ICFpc05hTihzZWxmLnkgLSBzZWxmLnN0YXJ0WSksXHJcbiAgICAgICAgICB3YXNEcmFnZ2luZyA9IHNlbGYuaXNEcmFnZ2luZyxcclxuICAgICAgICAgIGlzRHJhZ05vdENsaWNrID0gd2FzRHJhZ2dpbmcgJiYgKE1hdGguYWJzKHNlbGYueCAtIHNlbGYuc3RhcnRYKSA+IDMgfHwgTWF0aC5hYnMoc2VsZi55IC0gc2VsZi5zdGFydFkpID4gMyksXHJcbiAgICAgICAgICAvLyBzb21lIHRvdWNoIGRldmljZXMgbmVlZCBzb21lIHdpZ2dsZSByb29tIGluIHRlcm1zIG9mIHNlbnNpbmcgY2xpY2tzIC0gdGhlIGZpbmdlciBtYXkgbW92ZSBhIGZldyBwaXhlbHMuXHJcbiAgICAgIGV2ZW50RGF0YSA9IF9nZXRFdmVudChlKTtcclxuXHJcbiAgICAgIGlmICghaXNEcmFnTm90Q2xpY2sgJiYgaXNUcmFja2luZ0RyYWcpIHtcclxuICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xyXG5cclxuICAgICAgICBzZWxmLl92eS5yZXNldCgpOyAvL2lmIChwcmV2ZW50RGVmYXVsdCAmJiBhbGxvd0NsaWNrcyAmJiBzZWxmLmlzUHJlc3NlZCkgeyAvLyBjaGVjayBpc1ByZXNzZWQgYmVjYXVzZSBpbiBhIHJhcmUgZWRnZSBjYXNlLCB0aGUgaW5wdXRPYnNlcnZlciBpbiBTY3JvbGxUcmlnZ2VyIG1heSBzdG9wUHJvcGFnYXRpb24oKSBvbiB0aGUgcHJlc3MvZHJhZywgc28gdGhlIG9uUmVsZWFzZSBtYXkgZ2V0IGZpcmVkIHdpdGhvdXQgdGhlIG9uUHJlc3Mvb25EcmFnIGV2ZXIgZ2V0dGluZyBjYWxsZWQsIHRodXMgaXQgY291bGQgdHJpZ2dlciBhIGNsaWNrIHRvIG9jY3VyIG9uIGEgbGluayBhZnRlciBzY3JvbGwtZHJhZ2dpbmcgaXQuXHJcblxyXG5cclxuICAgICAgICBpZiAocHJldmVudERlZmF1bHQgJiYgYWxsb3dDbGlja3MpIHtcclxuICAgICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC4wOCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxyXG4gICAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIG9uQ2xpY2tUaW1lID4gMzAwICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgICBpZiAoZS50YXJnZXQuY2xpY2spIHtcclxuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuY2xpY2soKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG93bmVyRG9jLmNyZWF0ZUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCBfd2luLCAxLCBldmVudERhdGEuc2NyZWVuWCwgZXZlbnREYXRhLnNjcmVlblksIGV2ZW50RGF0YS5jbGllbnRYLCBldmVudERhdGEuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzeW50aGV0aWNFdmVudCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICBvblN0b3AgJiYgd2FzRHJhZ2dpbmcgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xyXG4gICAgICBkcmFnZ2VkICYmIHVwZGF0ZSgpOyAvLyBpbiBjYXNlIGRlYm91bmNpbmcsIHdlIGRvbid0IHdhbnQgb25EcmFnIHRvIGZpcmUgQUZURVIgb25EcmFnRW5kKCkuXHJcblxyXG4gICAgICBvbkRyYWdFbmQgJiYgd2FzRHJhZ2dpbmcgJiYgb25EcmFnRW5kKHNlbGYpO1xyXG4gICAgICBvblJlbGVhc2UgJiYgb25SZWxlYXNlKHNlbGYsIGlzRHJhZ05vdENsaWNrKTtcclxuICAgIH0sXHJcbiAgICAgICAgX29uR2VzdHVyZVN0YXJ0ID0gZnVuY3Rpb24gX29uR2VzdHVyZVN0YXJ0KGUpIHtcclxuICAgICAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSAmJiAoc2VsZi5pc0dlc3R1cmluZyA9IHRydWUpICYmIG9uR2VzdHVyZVN0YXJ0KGUsIHNlbGYuaXNEcmFnZ2luZyk7XHJcbiAgICB9LFxyXG4gICAgICAgIF9vbkdlc3R1cmVFbmQgPSBmdW5jdGlvbiBfb25HZXN0dXJlRW5kKCkge1xyXG4gICAgICByZXR1cm4gKHNlbGYuaXNHZXN0dXJpbmcgPSBmYWxzZSkgfHwgb25HZXN0dXJlRW5kKHNlbGYpO1xyXG4gICAgfSxcclxuICAgICAgICBvblNjcm9sbCA9IGZ1bmN0aW9uIG9uU2Nyb2xsKGUpIHtcclxuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHggPSBzY3JvbGxGdW5jWCgpLFxyXG4gICAgICAgICAgeSA9IHNjcm9sbEZ1bmNZKCk7XHJcbiAgICAgIG9uRGVsdGEoKHggLSBzY3JvbGxYKSAqIHNjcm9sbFNwZWVkLCAoeSAtIHNjcm9sbFkpICogc2Nyb2xsU3BlZWQsIDEpO1xyXG4gICAgICBzY3JvbGxYID0geDtcclxuICAgICAgc2Nyb2xsWSA9IHk7XHJcbiAgICAgIG9uU3RvcCAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xyXG4gICAgfSxcclxuICAgICAgICBfb25XaGVlbCA9IGZ1bmN0aW9uIF9vbldoZWVsKGUpIHtcclxuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCk7XHJcbiAgICAgIG9uV2hlZWwgJiYgKHdoZWVsZWQgPSB0cnVlKTtcclxuICAgICAgdmFyIG11bHRpcGxpZXIgPSAoZS5kZWx0YU1vZGUgPT09IDEgPyBsaW5lSGVpZ2h0IDogZS5kZWx0YU1vZGUgPT09IDIgPyBfd2luLmlubmVySGVpZ2h0IDogMSkgKiB3aGVlbFNwZWVkO1xyXG4gICAgICBvbkRlbHRhKGUuZGVsdGFYICogbXVsdGlwbGllciwgZS5kZWx0YVkgKiBtdWx0aXBsaWVyLCAwKTtcclxuICAgICAgb25TdG9wICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcclxuICAgIH0sXHJcbiAgICAgICAgX29uTW92ZSA9IGZ1bmN0aW9uIF9vbk1vdmUoZSkge1xyXG4gICAgICBpZiAoX2lnbm9yZUNoZWNrKGUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcclxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXHJcbiAgICAgICAgICBkeCA9IHggLSBzZWxmLngsXHJcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnk7XHJcbiAgICAgIHNlbGYueCA9IHg7XHJcbiAgICAgIHNlbGYueSA9IHk7XHJcbiAgICAgIG1vdmVkID0gdHJ1ZTtcclxuICAgICAgb25TdG9wICYmIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XHJcbiAgICAgIChkeCB8fCBkeSkgJiYgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XHJcbiAgICB9LFxyXG4gICAgICAgIF9vbkhvdmVyID0gZnVuY3Rpb24gX29uSG92ZXIoZSkge1xyXG4gICAgICBzZWxmLmV2ZW50ID0gZTtcclxuICAgICAgb25Ib3ZlcihzZWxmKTtcclxuICAgIH0sXHJcbiAgICAgICAgX29uSG92ZXJFbmQgPSBmdW5jdGlvbiBfb25Ib3ZlckVuZChlKSB7XHJcbiAgICAgIHNlbGYuZXZlbnQgPSBlO1xyXG4gICAgICBvbkhvdmVyRW5kKHNlbGYpO1xyXG4gICAgfSxcclxuICAgICAgICBfb25DbGljayA9IGZ1bmN0aW9uIF9vbkNsaWNrKGUpIHtcclxuICAgICAgcmV0dXJuIF9pZ25vcmVDaGVjayhlKSB8fCBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpICYmIG9uQ2xpY2soc2VsZik7XHJcbiAgICB9O1xyXG5cclxuICAgIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGMgPSBnc2FwLmRlbGF5ZWRDYWxsKG9uU3RvcERlbGF5IHx8IDAuMjUsIG9uU3RvcEZ1bmMpLnBhdXNlKCk7XHJcbiAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcclxuICAgIHNlbGYuX3Z4ID0gX2dldFZlbG9jaXR5UHJvcCgwLCA1MCwgdHJ1ZSk7XHJcbiAgICBzZWxmLl92eSA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xyXG4gICAgc2VsZi5zY3JvbGxYID0gc2Nyb2xsRnVuY1g7XHJcbiAgICBzZWxmLnNjcm9sbFkgPSBzY3JvbGxGdW5jWTtcclxuICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuICAgIF9jb250ZXh0KHRoaXMpO1xyXG5cclxuICAgIHNlbGYuZW5hYmxlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKCFzZWxmLmlzRW5hYmxlZCkge1xyXG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XHJcblxyXG4gICAgICAgIHR5cGUuaW5kZXhPZihcInNjcm9sbFwiKSA+PSAwICYmIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIG9uU2Nyb2xsLCBwYXNzaXZlLCBjYXB0dXJlKTtcclxuICAgICAgICB0eXBlLmluZGV4T2YoXCJ3aGVlbFwiKSA+PSAwICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwid2hlZWxcIiwgX29uV2hlZWwsIHBhc3NpdmUsIGNhcHR1cmUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZS5pbmRleE9mKFwidG91Y2hcIikgPj0gMCAmJiBfaXNUb3VjaCB8fCB0eXBlLmluZGV4T2YoXCJwb2ludGVyXCIpID49IDApIHtcclxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9ldmVudFR5cGVzWzBdLCBfb25QcmVzcywgcGFzc2l2ZSwgY2FwdHVyZSk7XHJcblxyXG4gICAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1syXSwgX29uUmVsZWFzZSk7XHJcblxyXG4gICAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1szXSwgX29uUmVsZWFzZSk7XHJcblxyXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgb25DbGljayAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIF9vbkNsaWNrKTtcclxuICAgICAgICAgIG9uR2VzdHVyZVN0YXJ0ICYmIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlc3RhcnRcIiwgX29uR2VzdHVyZVN0YXJ0KTtcclxuICAgICAgICAgIG9uR2VzdHVyZUVuZCAmJiBfYWRkTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZWVuZFwiLCBfb25HZXN0dXJlRW5kKTtcclxuICAgICAgICAgIG9uSG92ZXIgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJlbnRlclwiLCBfb25Ib3Zlcik7XHJcbiAgICAgICAgICBvbkhvdmVyRW5kICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibGVhdmVcIiwgX29uSG92ZXJFbmQpO1xyXG4gICAgICAgICAgb25Nb3ZlICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuaXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBzZWxmLmlzR2VzdHVyaW5nID0gc2VsZi5pc1ByZXNzZWQgPSBtb3ZlZCA9IGRyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcclxuXHJcbiAgICAgICAgc2VsZi5fdnkucmVzZXQoKTtcclxuXHJcbiAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCk7XHJcbiAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCk7XHJcbiAgICAgICAgZSAmJiBlLnR5cGUgJiYgX29uUHJlc3MoZSk7XHJcbiAgICAgICAgb25FbmFibGUgJiYgb25FbmFibGUoc2VsZik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChzZWxmLmlzRW5hYmxlZCkge1xyXG4gICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBfb25TY3JvbGwgbGlzdGVuZXIgaWYgdGhlcmUgYXJlbid0IGFueSBvdGhlcnMgdGhhdCByZWx5IG9uIHRoZSBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICAgIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICByZXR1cm4gbyAhPT0gc2VsZiAmJiBfaXNWaWV3cG9ydChvLnRhcmdldCk7XHJcbiAgICAgICAgfSkubGVuZ3RoIHx8IF9yZW1vdmVMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmlzUHJlc3NlZCkge1xyXG4gICAgICAgICAgc2VsZi5fdngucmVzZXQoKTtcclxuXHJcbiAgICAgICAgICBzZWxmLl92eS5yZXNldCgpO1xyXG5cclxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihpc05vcm1hbGl6ZXIgPyB0YXJnZXQgOiBvd25lckRvYywgX2V2ZW50VHlwZXNbMV0sIF9vbkRyYWcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIGNhcHR1cmUpO1xyXG5cclxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBjYXB0dXJlKTtcclxuXHJcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBjYXB0dXJlKTtcclxuXHJcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBfZXZlbnRUeXBlc1syXSwgX29uUmVsZWFzZSk7XHJcblxyXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xyXG5cclxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIGNsaWNrQ2FwdHVyZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgX29uQ2xpY2spO1xyXG5cclxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwiZ2VzdHVyZXN0YXJ0XCIsIF9vbkdlc3R1cmVTdGFydCk7XHJcblxyXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlZW5kXCIsIF9vbkdlc3R1cmVFbmQpO1xyXG5cclxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImVudGVyXCIsIF9vbkhvdmVyKTtcclxuXHJcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX3BvaW50ZXJUeXBlICsgXCJsZWF2ZVwiLCBfb25Ib3ZlckVuZCk7XHJcblxyXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcclxuXHJcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBzZWxmLmlzUHJlc3NlZCA9IHNlbGYuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIG9uRGlzYWJsZSAmJiBvbkRpc2FibGUoc2VsZik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5raWxsID0gc2VsZi5yZXZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xyXG5cclxuICAgICAgdmFyIGkgPSBfb2JzZXJ2ZXJzLmluZGV4T2Yoc2VsZik7XHJcblxyXG4gICAgICBpID49IDAgJiYgX29ic2VydmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIF9ub3JtYWxpemVyID09PSBzZWxmICYmIChfbm9ybWFsaXplciA9IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBfb2JzZXJ2ZXJzLnB1c2goc2VsZik7XHJcblxyXG4gICAgaXNOb3JtYWxpemVyICYmIF9pc1ZpZXdwb3J0KHRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gc2VsZik7XHJcbiAgICBzZWxmLmVuYWJsZShldmVudCk7XHJcbiAgfTtcclxuXHJcbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmVyLCBbe1xyXG4gICAga2V5OiBcInZlbG9jaXR5WFwiLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl92eC5nZXRWZWxvY2l0eSgpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJ2ZWxvY2l0eVlcIixcclxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdnkuZ2V0VmVsb2NpdHkoKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBPYnNlcnZlcjtcclxufSgpO1xyXG5PYnNlcnZlci52ZXJzaW9uID0gXCIzLjEzLjBcIjtcclxuXHJcbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XHJcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcih2YXJzKTtcclxufTtcclxuXHJcbk9ic2VydmVyLnJlZ2lzdGVyID0gX2luaXRDb3JlO1xyXG5cclxuT2JzZXJ2ZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBfb2JzZXJ2ZXJzLnNsaWNlKCk7XHJcbn07XHJcblxyXG5PYnNlcnZlci5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgcmV0dXJuIF9vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XHJcbiAgICByZXR1cm4gby52YXJzLmlkID09PSBpZDtcclxuICB9KVswXTtcclxufTtcclxuXHJcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihPYnNlcnZlcik7XHJcbmV4cG9ydCB7IE9ic2VydmVyIGFzIGRlZmF1bHQsIF9pc1ZpZXdwb3J0LCBfc2Nyb2xsZXJzLCBfZ2V0U2Nyb2xsRnVuYywgX2dldFByb3h5UHJvcCwgX3Byb3hpZXMsIF9nZXRWZWxvY2l0eVByb3AsIF92ZXJ0aWNhbCwgX2hvcml6b250YWwsIF9nZXRUYXJnZXQgfTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/Observer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gsap/ScrollTrigger.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/ScrollTrigger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: () => (/* binding */ ScrollTrigger),\n/* harmony export */   \"default\": () => (/* binding */ ScrollTrigger)\n/* harmony export */ });\n/* harmony import */ var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Observer.js */ \"(ssr)/./node_modules/gsap/Observer.js\");\n/*!\r\n * ScrollTrigger 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\r\n * Subject to the terms at https://gsap.com/standard-license\r\n * @author: Jack Doyle, jack@greensock.com\r\n*/\r\n\r\n/* eslint-disable */\r\n\r\n\r\nvar gsap,\r\n    _coreInitted,\r\n    _win,\r\n    _doc,\r\n    _docEl,\r\n    _body,\r\n    _root,\r\n    _resizeDelay,\r\n    _toArray,\r\n    _clamp,\r\n    _time2,\r\n    _syncInterval,\r\n    _refreshing,\r\n    _pointerIsDown,\r\n    _transformProp,\r\n    _i,\r\n    _prevWidth,\r\n    _prevHeight,\r\n    _autoRefresh,\r\n    _sort,\r\n    _suppressOverwrites,\r\n    _ignoreResize,\r\n    _normalizer,\r\n    _ignoreMobileResize,\r\n    _baseScreenHeight,\r\n    _baseScreenWidth,\r\n    _fixIOSBug,\r\n    _context,\r\n    _scrollRestoration,\r\n    _div100vh,\r\n    _100vh,\r\n    _isReverted,\r\n    _clampingMax,\r\n    _limitCallbacks,\r\n    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\r\n_startup = 1,\r\n    _getTime = Date.now,\r\n    _time1 = _getTime(),\r\n    _lastScrollTime = 0,\r\n    _enabled = 0,\r\n    _parseClamp = function _parseClamp(value, type, self) {\r\n  var clamp = _isString(value) && (value.substr(0, 6) === \"clamp(\" || value.indexOf(\"max\") > -1);\r\n  self[\"_\" + type + \"Clamp\"] = clamp;\r\n  return clamp ? value.substr(6, value.length - 7) : value;\r\n},\r\n    _keepClamp = function _keepClamp(value, clamp) {\r\n  return clamp && (!_isString(value) || value.substr(0, 6) !== \"clamp(\") ? \"clamp(\" + value + \")\" : value;\r\n},\r\n    _rafBugFix = function _rafBugFix() {\r\n  return _enabled && requestAnimationFrame(_rafBugFix);\r\n},\r\n    // in some browsers (like Firefox), screen repaints weren't consistent unless we had SOMETHING queued up in requestAnimationFrame()! So this just creates a super simple loop to keep it alive and smooth out repaints.\r\n_pointerDownHandler = function _pointerDownHandler() {\r\n  return _pointerIsDown = 1;\r\n},\r\n    _pointerUpHandler = function _pointerUpHandler() {\r\n  return _pointerIsDown = 0;\r\n},\r\n    _passThrough = function _passThrough(v) {\r\n  return v;\r\n},\r\n    _round = function _round(value) {\r\n  return Math.round(value * 100000) / 100000 || 0;\r\n},\r\n    _windowExists = function _windowExists() {\r\n  return typeof window !== \"undefined\";\r\n},\r\n    _getGSAP = function _getGSAP() {\r\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n},\r\n    _isViewport = function _isViewport(e) {\r\n  return !!~_root.indexOf(e);\r\n},\r\n    _getViewportDimension = function _getViewportDimension(dimensionProperty) {\r\n  return (dimensionProperty === \"Height\" ? _100vh : _win[\"inner\" + dimensionProperty]) || _docEl[\"client\" + dimensionProperty] || _body[\"client\" + dimensionProperty];\r\n},\r\n    _getBoundsFunc = function _getBoundsFunc(element) {\r\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, \"getBoundingClientRect\") || (_isViewport(element) ? function () {\r\n    _winOffsets.width = _win.innerWidth;\r\n    _winOffsets.height = _100vh;\r\n    return _winOffsets;\r\n  } : function () {\r\n    return _getBounds(element);\r\n  });\r\n},\r\n    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {\r\n  var d = _ref.d,\r\n      d2 = _ref.d2,\r\n      a = _ref.a;\r\n  return (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"getBoundingClientRect\")) ? function () {\r\n    return a()[d];\r\n  } : function () {\r\n    return (isViewport ? _getViewportDimension(d2) : scroller[\"client\" + d2]) || 0;\r\n  };\r\n},\r\n    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {\r\n  return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function () {\r\n    return _winOffsets;\r\n  };\r\n},\r\n    _maxScroll = function _maxScroll(element, _ref2) {\r\n  var s = _ref2.s,\r\n      d2 = _ref2.d2,\r\n      d = _ref2.d,\r\n      a = _ref2.a;\r\n  return Math.max(0, (s = \"scroll\" + d2) && (a = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element[\"offset\" + d2]);\r\n},\r\n    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {\r\n  for (var i = 0; i < _autoRefresh.length; i += 3) {\r\n    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\r\n  }\r\n},\r\n    _isString = function _isString(value) {\r\n  return typeof value === \"string\";\r\n},\r\n    _isFunction = function _isFunction(value) {\r\n  return typeof value === \"function\";\r\n},\r\n    _isNumber = function _isNumber(value) {\r\n  return typeof value === \"number\";\r\n},\r\n    _isObject = function _isObject(value) {\r\n  return typeof value === \"object\";\r\n},\r\n    _endAnimation = function _endAnimation(animation, reversed, pause) {\r\n  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();\r\n},\r\n    _callback = function _callback(self, func) {\r\n  if (self.enabled) {\r\n    var result = self._ctx ? self._ctx.add(function () {\r\n      return func(self);\r\n    }) : func(self);\r\n    result && result.totalTime && (self.callbackAnimation = result);\r\n  }\r\n},\r\n    _abs = Math.abs,\r\n    _left = \"left\",\r\n    _top = \"top\",\r\n    _right = \"right\",\r\n    _bottom = \"bottom\",\r\n    _width = \"width\",\r\n    _height = \"height\",\r\n    _Right = \"Right\",\r\n    _Left = \"Left\",\r\n    _Top = \"Top\",\r\n    _Bottom = \"Bottom\",\r\n    _padding = \"padding\",\r\n    _margin = \"margin\",\r\n    _Width = \"Width\",\r\n    _Height = \"Height\",\r\n    _px = \"px\",\r\n    _getComputedStyle = function _getComputedStyle(element) {\r\n  return _win.getComputedStyle(element);\r\n},\r\n    _makePositionable = function _makePositionable(element) {\r\n  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative\r\n  var position = _getComputedStyle(element).position;\r\n\r\n  element.style.position = position === \"absolute\" || position === \"fixed\" ? position : \"relative\";\r\n},\r\n    _setDefaults = function _setDefaults(obj, defaults) {\r\n  for (var p in defaults) {\r\n    p in obj || (obj[p] = defaults[p]);\r\n  }\r\n\r\n  return obj;\r\n},\r\n    _getBounds = function _getBounds(element, withoutTransforms) {\r\n  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== \"matrix(1, 0, 0, 1, 0, 0)\" && gsap.to(element, {\r\n    x: 0,\r\n    y: 0,\r\n    xPercent: 0,\r\n    yPercent: 0,\r\n    rotation: 0,\r\n    rotationX: 0,\r\n    rotationY: 0,\r\n    scale: 1,\r\n    skewX: 0,\r\n    skewY: 0\r\n  }).progress(1),\r\n      bounds = element.getBoundingClientRect();\r\n  tween && tween.progress(0).kill();\r\n  return bounds;\r\n},\r\n    _getSize = function _getSize(element, _ref3) {\r\n  var d2 = _ref3.d2;\r\n  return element[\"offset\" + d2] || element[\"client\" + d2] || 0;\r\n},\r\n    _getLabelRatioArray = function _getLabelRatioArray(timeline) {\r\n  var a = [],\r\n      labels = timeline.labels,\r\n      duration = timeline.duration(),\r\n      p;\r\n\r\n  for (p in labels) {\r\n    a.push(labels[p] / duration);\r\n  }\r\n\r\n  return a;\r\n},\r\n    _getClosestLabel = function _getClosestLabel(animation) {\r\n  return function (value) {\r\n    return gsap.utils.snap(_getLabelRatioArray(animation), value);\r\n  };\r\n},\r\n    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {\r\n  var snap = gsap.utils.snap(snapIncrementOrArray),\r\n      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {\r\n    return a - b;\r\n  });\r\n  return a ? function (value, direction, threshold) {\r\n    if (threshold === void 0) {\r\n      threshold = 1e-3;\r\n    }\r\n\r\n    var i;\r\n\r\n    if (!direction) {\r\n      return snap(value);\r\n    }\r\n\r\n    if (direction > 0) {\r\n      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.\r\n\r\n      for (i = 0; i < a.length; i++) {\r\n        if (a[i] >= value) {\r\n          return a[i];\r\n        }\r\n      }\r\n\r\n      return a[i - 1];\r\n    } else {\r\n      i = a.length;\r\n      value += threshold;\r\n\r\n      while (i--) {\r\n        if (a[i] <= value) {\r\n          return a[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    return a[0];\r\n  } : function (value, direction, threshold) {\r\n    if (threshold === void 0) {\r\n      threshold = 1e-3;\r\n    }\r\n\r\n    var snapped = snap(value);\r\n    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);\r\n  };\r\n},\r\n    _getLabelAtDirection = function _getLabelAtDirection(timeline) {\r\n  return function (value, st) {\r\n    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);\r\n  };\r\n},\r\n    _multiListener = function _multiListener(func, element, types, callback) {\r\n  return types.split(\",\").forEach(function (type) {\r\n    return func(element, type, callback);\r\n  });\r\n},\r\n    _addListener = function _addListener(element, type, func, nonPassive, capture) {\r\n  return element.addEventListener(type, func, {\r\n    passive: !nonPassive,\r\n    capture: !!capture\r\n  });\r\n},\r\n    _removeListener = function _removeListener(element, type, func, capture) {\r\n  return element.removeEventListener(type, func, !!capture);\r\n},\r\n    _wheelListener = function _wheelListener(func, el, scrollFunc) {\r\n  scrollFunc = scrollFunc && scrollFunc.wheelHandler;\r\n\r\n  if (scrollFunc) {\r\n    func(el, \"wheel\", scrollFunc);\r\n    func(el, \"touchmove\", scrollFunc);\r\n  }\r\n},\r\n    _markerDefaults = {\r\n  startColor: \"green\",\r\n  endColor: \"red\",\r\n  indent: 0,\r\n  fontSize: \"16px\",\r\n  fontWeight: \"normal\"\r\n},\r\n    _defaults = {\r\n  toggleActions: \"play\",\r\n  anticipatePin: 0\r\n},\r\n    _keywords = {\r\n  top: 0,\r\n  left: 0,\r\n  center: 0.5,\r\n  bottom: 1,\r\n  right: 1\r\n},\r\n    _offsetToPx = function _offsetToPx(value, size) {\r\n  if (_isString(value)) {\r\n    var eqIndex = value.indexOf(\"=\"),\r\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\r\n\r\n    if (~eqIndex) {\r\n      value.indexOf(\"%\") > eqIndex && (relative *= size / 100);\r\n      value = value.substr(0, eqIndex - 1);\r\n    }\r\n\r\n    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf(\"%\") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\r\n  }\r\n\r\n  return value;\r\n},\r\n    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {\r\n  var startColor = _ref4.startColor,\r\n      endColor = _ref4.endColor,\r\n      fontSize = _ref4.fontSize,\r\n      indent = _ref4.indent,\r\n      fontWeight = _ref4.fontWeight;\r\n\r\n  var e = _doc.createElement(\"div\"),\r\n      useFixedPosition = _isViewport(container) || (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, \"pinType\") === \"fixed\",\r\n      isScroller = type.indexOf(\"scroller\") !== -1,\r\n      parent = useFixedPosition ? _body : container,\r\n      isStart = type.indexOf(\"start\") !== -1,\r\n      color = isStart ? startColor : endColor,\r\n      css = \"border-color:\" + color + \";font-size:\" + fontSize + \";color:\" + color + \";font-weight:\" + fontWeight + \";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;\";\r\n\r\n  css += \"position:\" + ((isScroller || containerAnimation) && useFixedPosition ? \"fixed;\" : \"absolute;\");\r\n  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + \":\" + (offset + parseFloat(indent)) + \"px;\");\r\n  matchWidthEl && (css += \"box-sizing:border-box;text-align:left;width:\" + matchWidthEl.offsetWidth + \"px;\");\r\n  e._isStart = isStart;\r\n  e.setAttribute(\"class\", \"gsap-marker-\" + type + (name ? \" marker-\" + name : \"\"));\r\n  e.style.cssText = css;\r\n  e.innerText = name || name === 0 ? type + \"-\" + name : type;\r\n  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\r\n  e._offset = e[\"offset\" + direction.op.d2];\r\n\r\n  _positionMarker(e, 0, direction, isStart);\r\n\r\n  return e;\r\n},\r\n    _positionMarker = function _positionMarker(marker, start, direction, flipped) {\r\n  var vars = {\r\n    display: \"block\"\r\n  },\r\n      side = direction[flipped ? \"os2\" : \"p2\"],\r\n      oppositeSide = direction[flipped ? \"p2\" : \"os2\"];\r\n  marker._isFlipped = flipped;\r\n  vars[direction.a + \"Percent\"] = flipped ? -100 : 0;\r\n  vars[direction.a] = flipped ? \"1px\" : 0;\r\n  vars[\"border\" + side + _Width] = 1;\r\n  vars[\"border\" + oppositeSide + _Width] = 0;\r\n  vars[direction.p] = start + \"px\";\r\n  gsap.set(marker, vars);\r\n},\r\n    _triggers = [],\r\n    _ids = {},\r\n    _rafID,\r\n    _sync = function _sync() {\r\n  return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)));\r\n},\r\n    _onScroll = function _onScroll() {\r\n  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010\r\n  if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {\r\n    // if the user is dragging the scrollbar, allow it.\r\n    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\r\n\r\n    if (_normalizer) {\r\n      _rafID || (_rafID = requestAnimationFrame(_updateAll));\r\n    } else {\r\n      _updateAll(); // Safari in particular (on desktop) NEEDS the immediate update rather than waiting for a requestAnimationFrame() whereas iOS seems to benefit from waiting for the requestAnimationFrame() tick, at least when normalizing. See https://codepen.io/GreenSock/pen/qBYozqO?editors=0110\r\n\r\n    }\r\n\r\n    _lastScrollTime || _dispatch(\"scrollStart\");\r\n    _lastScrollTime = _getTime();\r\n  }\r\n},\r\n    _setBaseDimensions = function _setBaseDimensions() {\r\n  _baseScreenWidth = _win.innerWidth;\r\n  _baseScreenHeight = _win.innerHeight;\r\n},\r\n    _onResize = function _onResize(force) {\r\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\r\n  (force === true || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25)) && _resizeDelay.restart(true);\r\n},\r\n    // ignore resizes triggered by refresh()\r\n_listeners = {},\r\n    _emptyArray = [],\r\n    _softRefresh = function _softRefresh() {\r\n  return _removeListener(ScrollTrigger, \"scrollEnd\", _softRefresh) || _refreshAll(true);\r\n},\r\n    _dispatch = function _dispatch(type) {\r\n  return _listeners[type] && _listeners[type].map(function (f) {\r\n    return f();\r\n  }) || _emptyArray;\r\n},\r\n    _savedStyles = [],\r\n    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\r\n_revertRecorded = function _revertRecorded(media) {\r\n  for (var i = 0; i < _savedStyles.length; i += 5) {\r\n    if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {\r\n      _savedStyles[i].style.cssText = _savedStyles[i + 1];\r\n      _savedStyles[i].getBBox && _savedStyles[i].setAttribute(\"transform\", _savedStyles[i + 2] || \"\");\r\n      _savedStyles[i + 3].uncache = 1;\r\n    }\r\n  }\r\n},\r\n    _revertAll = function _revertAll(kill, media) {\r\n  var trigger;\r\n\r\n  for (_i = 0; _i < _triggers.length; _i++) {\r\n    trigger = _triggers[_i];\r\n\r\n    if (trigger && (!media || trigger._ctx === media)) {\r\n      if (kill) {\r\n        trigger.kill(1);\r\n      } else {\r\n        trigger.revert(true, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  _isReverted = true;\r\n  media && _revertRecorded(media);\r\n  media || _dispatch(\"revert\");\r\n},\r\n    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {\r\n  // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.\r\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\r\n  (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\r\n    return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0);\r\n  });\r\n  _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration);\r\n},\r\n    _refreshingAll,\r\n    _refreshID = 0,\r\n    _queueRefreshID,\r\n    _queueRefreshAll = function _queueRefreshAll() {\r\n  // we don't want to call _refreshAll() every time we create a new ScrollTrigger (for performance reasons) - it's better to batch them. Some frameworks dynamically load content and we can't rely on the window's \"load\" or \"DOMContentLoaded\" events to trigger it.\r\n  if (_queueRefreshID !== _refreshID) {\r\n    var id = _queueRefreshID = _refreshID;\r\n    requestAnimationFrame(function () {\r\n      return id === _refreshID && _refreshAll(true);\r\n    });\r\n  }\r\n},\r\n    _refresh100vh = function _refresh100vh() {\r\n  _body.appendChild(_div100vh);\r\n\r\n  _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;\r\n\r\n  _body.removeChild(_div100vh);\r\n},\r\n    _hideAllMarkers = function _hideAllMarkers(hide) {\r\n  return _toArray(\".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end\").forEach(function (el) {\r\n    return el.style.display = hide ? \"none\" : \"block\";\r\n  });\r\n},\r\n    _refreshAll = function _refreshAll(force, skipRevert) {\r\n  _docEl = _doc.documentElement; // some frameworks like Astro may cache the <body> and replace it during routing, so we'll just re-record the _docEl and _body for safety (otherwise, the markers may not get added properly).\r\n\r\n  _body = _doc.body;\r\n  _root = [_win, _doc, _docEl, _body];\r\n\r\n  if (_lastScrollTime && !force && !_isReverted) {\r\n    _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\r\n\r\n    return;\r\n  }\r\n\r\n  _refresh100vh();\r\n\r\n  _refreshingAll = ScrollTrigger.isRefreshing = true;\r\n\r\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\r\n    return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj());\r\n  }); // force the clearing of the cache because some browsers take a little while to dispatch the \"scroll\" event and the user may have changed the scroll position and then called ScrollTrigger.refresh() right away\r\n\r\n\r\n  var refreshInits = _dispatch(\"refreshInit\");\r\n\r\n  _sort && ScrollTrigger.sort();\r\n  skipRevert || _revertAll();\r\n\r\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\r\n    if (_isFunction(obj)) {\r\n      obj.smooth && (obj.target.style.scrollBehavior = \"auto\"); // smooth scrolling interferes\r\n\r\n      obj(0);\r\n    }\r\n  });\r\n\r\n  _triggers.slice(0).forEach(function (t) {\r\n    return t.refresh();\r\n  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.\r\n\r\n\r\n  _isReverted = false;\r\n\r\n  _triggers.forEach(function (t) {\r\n    // nested pins (pinnedContainer) with pinSpacing may expand the container, so we must accommodate that here.\r\n    if (t._subPinOffset && t.pin) {\r\n      var prop = t.vars.horizontal ? \"offsetWidth\" : \"offsetHeight\",\r\n          original = t.pin[prop];\r\n      t.revert(true, 1);\r\n      t.adjustPinSpacing(t.pin[prop] - original);\r\n      t.refresh();\r\n    }\r\n  });\r\n\r\n  _clampingMax = 1; // pinSpacing might be propping a page open, thus when we .setPositions() to clamp a ScrollTrigger's end we should leave the pinSpacing alone. That's what this flag is for.\r\n\r\n  _hideAllMarkers(true);\r\n\r\n  _triggers.forEach(function (t) {\r\n    // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: \"max\". Same for anything with a clamped end\r\n    var max = _maxScroll(t.scroller, t._dir),\r\n        endClamp = t.vars.end === \"max\" || t._endClamp && t.end > max,\r\n        startClamp = t._startClamp && t.start >= max;\r\n\r\n    (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, true);\r\n  });\r\n\r\n  _hideAllMarkers(false);\r\n\r\n  _clampingMax = 0;\r\n  refreshInits.forEach(function (result) {\r\n    return result && result.render && result.render(-1);\r\n  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\r\n\r\n  _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (obj) {\r\n    if (_isFunction(obj)) {\r\n      obj.smooth && requestAnimationFrame(function () {\r\n        return obj.target.style.scrollBehavior = \"smooth\";\r\n      });\r\n      obj.rec && obj(obj.rec);\r\n    }\r\n  });\r\n\r\n  _clearScrollMemory(_scrollRestoration, 1);\r\n\r\n  _resizeDelay.pause();\r\n\r\n  _refreshID++;\r\n  _refreshingAll = 2;\r\n\r\n  _updateAll(2);\r\n\r\n  _triggers.forEach(function (t) {\r\n    return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t);\r\n  });\r\n\r\n  _refreshingAll = ScrollTrigger.isRefreshing = false;\r\n\r\n  _dispatch(\"refresh\");\r\n},\r\n    _lastScroll = 0,\r\n    _direction = 1,\r\n    _primary,\r\n    _updateAll = function _updateAll(force) {\r\n  if (force === 2 || !_refreshingAll && !_isReverted) {\r\n    // _isReverted could be true if, for example, a matchMedia() is in the process of executing. We don't want to update during the time everything is reverted.\r\n    ScrollTrigger.isUpdating = true;\r\n    _primary && _primary.update(0); // ScrollSmoother uses refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.\r\n\r\n    var l = _triggers.length,\r\n        time = _getTime(),\r\n        recordVelocity = time - _time1 >= 50,\r\n        scroll = l && _triggers[0].scroll();\r\n\r\n    _direction = _lastScroll > scroll ? -1 : 1;\r\n    _refreshingAll || (_lastScroll = scroll);\r\n\r\n    if (recordVelocity) {\r\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\r\n        _lastScrollTime = 0;\r\n\r\n        _dispatch(\"scrollEnd\");\r\n      }\r\n\r\n      _time2 = _time1;\r\n      _time1 = time;\r\n    }\r\n\r\n    if (_direction < 0) {\r\n      _i = l;\r\n\r\n      while (_i-- > 0) {\r\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\r\n      }\r\n\r\n      _direction = 1;\r\n    } else {\r\n      for (_i = 0; _i < l; _i++) {\r\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\r\n      }\r\n    }\r\n\r\n    ScrollTrigger.isUpdating = false;\r\n  }\r\n\r\n  _rafID = 0;\r\n},\r\n    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, \"display\", \"flexShrink\", \"float\", \"zIndex\", \"gridColumnStart\", \"gridColumnEnd\", \"gridRowStart\", \"gridRowEnd\", \"gridArea\", \"justifySelf\", \"alignSelf\", \"placeSelf\", \"order\"],\r\n    _stateProps = _propNamesToCopy.concat([_width, _height, \"boxSizing\", \"max\" + _Width, \"max\" + _Height, \"position\", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\r\n    _swapPinOut = function _swapPinOut(pin, spacer, state) {\r\n  _setState(state);\r\n\r\n  var cache = pin._gsap;\r\n\r\n  if (cache.spacerIsNative) {\r\n    _setState(cache.spacerState);\r\n  } else if (pin._gsap.swappedIn) {\r\n    var parent = spacer.parentNode;\r\n\r\n    if (parent) {\r\n      parent.insertBefore(pin, spacer);\r\n      parent.removeChild(spacer);\r\n    }\r\n  }\r\n\r\n  pin._gsap.swappedIn = false;\r\n},\r\n    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {\r\n  if (!pin._gsap.swappedIn) {\r\n    var i = _propNamesToCopy.length,\r\n        spacerStyle = spacer.style,\r\n        pinStyle = pin.style,\r\n        p;\r\n\r\n    while (i--) {\r\n      p = _propNamesToCopy[i];\r\n      spacerStyle[p] = cs[p];\r\n    }\r\n\r\n    spacerStyle.position = cs.position === \"absolute\" ? \"absolute\" : \"relative\";\r\n    cs.display === \"inline\" && (spacerStyle.display = \"inline-block\");\r\n    pinStyle[_bottom] = pinStyle[_right] = \"auto\";\r\n    spacerStyle.flexBasis = cs.flexBasis || \"auto\";\r\n    spacerStyle.overflow = \"visible\";\r\n    spacerStyle.boxSizing = \"border-box\";\r\n    spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;\r\n    spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;\r\n    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = \"0\";\r\n\r\n    _setState(spacerState);\r\n\r\n    pinStyle[_width] = pinStyle[\"max\" + _Width] = cs[_width];\r\n    pinStyle[_height] = pinStyle[\"max\" + _Height] = cs[_height];\r\n    pinStyle[_padding] = cs[_padding];\r\n\r\n    if (pin.parentNode !== spacer) {\r\n      pin.parentNode.insertBefore(spacer, pin);\r\n      spacer.appendChild(pin);\r\n    }\r\n\r\n    pin._gsap.swappedIn = true;\r\n  }\r\n},\r\n    _capsExp = /([A-Z])/g,\r\n    _setState = function _setState(state) {\r\n  if (state) {\r\n    var style = state.t.style,\r\n        l = state.length,\r\n        i = 0,\r\n        p,\r\n        value;\r\n    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\r\n\r\n    for (; i < l; i += 2) {\r\n      value = state[i + 1];\r\n      p = state[i];\r\n\r\n      if (value) {\r\n        style[p] = value;\r\n      } else if (style[p]) {\r\n        style.removeProperty(p.replace(_capsExp, \"-$1\").toLowerCase());\r\n      }\r\n    }\r\n  }\r\n},\r\n    _getState = function _getState(element) {\r\n  // returns an Array with alternating values like [property, value, property, value] and a \"t\" property pointing to the target (element). Makes it fast and cheap.\r\n  var l = _stateProps.length,\r\n      style = element.style,\r\n      state = [],\r\n      i = 0;\r\n\r\n  for (; i < l; i++) {\r\n    state.push(_stateProps[i], style[_stateProps[i]]);\r\n  }\r\n\r\n  state.t = element;\r\n  return state;\r\n},\r\n    _copyState = function _copyState(state, override, omitOffsets) {\r\n  var result = [],\r\n      l = state.length,\r\n      i = omitOffsets ? 8 : 0,\r\n      // skip top, left, right, bottom if omitOffsets is true\r\n  p;\r\n\r\n  for (; i < l; i += 2) {\r\n    p = state[i];\r\n    result.push(p, p in override ? override[p] : state[i + 1]);\r\n  }\r\n\r\n  result.t = state.t;\r\n  return result;\r\n},\r\n    _winOffsets = {\r\n  left: 0,\r\n  top: 0\r\n},\r\n    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition(\"#id\", \"top bottom\")\r\n// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {\r\n// \tscroller = _getTarget(scroller || _win);\r\n// \tlet direction = horizontal ? _horizontal : _vertical,\r\n// \t\tisViewport = _isViewport(scroller);\r\n// \t_getSizeFunc(scroller, isViewport, direction);\r\n// \treturn _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);\r\n// },\r\n_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {\r\n  _isFunction(value) && (value = value(self));\r\n\r\n  if (_isString(value) && value.substr(0, 3) === \"max\") {\r\n    value = scrollerMax + (value.charAt(4) === \"=\" ? _offsetToPx(\"0\" + value.substr(3), scrollerSize) : 0);\r\n  }\r\n\r\n  var time = containerAnimation ? containerAnimation.time() : 0,\r\n      p1,\r\n      p2,\r\n      element;\r\n  containerAnimation && containerAnimation.seek(0);\r\n  isNaN(value) || (value = +value); // convert a string number like \"45\" to an actual number\r\n\r\n  if (!_isNumber(value)) {\r\n    _isFunction(trigger) && (trigger = trigger(self));\r\n    var offsets = (value || \"0\").split(\" \"),\r\n        bounds,\r\n        localOffset,\r\n        globalOffset,\r\n        display;\r\n    element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;\r\n    bounds = _getBounds(element) || {};\r\n\r\n    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === \"none\") {\r\n      // if display is \"none\", it won't report getBoundingClientRect() properly\r\n      display = element.style.display;\r\n      element.style.display = \"block\";\r\n      bounds = _getBounds(element);\r\n      display ? element.style.display = display : element.style.removeProperty(\"display\");\r\n    }\r\n\r\n    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\r\n    globalOffset = _offsetToPx(offsets[1] || \"0\", scrollerSize);\r\n    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\r\n    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\r\n    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\r\n  } else {\r\n    containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));\r\n    markerScroller && _positionMarker(markerScroller, scrollerSize, direction, true);\r\n  }\r\n\r\n  if (clampZeroProp) {\r\n    self[clampZeroProp] = value || -0.001;\r\n    value < 0 && (value = 0);\r\n  }\r\n\r\n  if (marker) {\r\n    var position = value + scrollerSize,\r\n        isStart = marker._isStart;\r\n    p1 = \"scroll\" + direction.d2;\r\n\r\n    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);\r\n\r\n    if (useFixedPosition) {\r\n      scrollerBounds = _getBounds(markerScroller);\r\n      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\r\n    }\r\n  }\r\n\r\n  if (containerAnimation && element) {\r\n    p1 = _getBounds(element);\r\n    containerAnimation.seek(scrollerMax);\r\n    p2 = _getBounds(element);\r\n    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];\r\n    value = value / containerAnimation._caScrollDist * scrollerMax;\r\n  }\r\n\r\n  containerAnimation && containerAnimation.seek(time);\r\n  return containerAnimation ? value : Math.round(value);\r\n},\r\n    _prefixExp = /(webkit|moz|length|cssText|inset)/i,\r\n    _reparent = function _reparent(element, parent, top, left) {\r\n  if (element.parentNode !== parent) {\r\n    var style = element.style,\r\n        p,\r\n        cs;\r\n\r\n    if (parent === _body) {\r\n      element._stOrig = style.cssText; // record original inline styles so we can revert them later\r\n\r\n      cs = _getComputedStyle(element);\r\n\r\n      for (p in cs) {\r\n        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\r\n        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === \"string\" && p !== \"0\") {\r\n          style[p] = cs[p];\r\n        }\r\n      }\r\n\r\n      style.top = top;\r\n      style.left = left;\r\n    } else {\r\n      style.cssText = element._stOrig;\r\n    }\r\n\r\n    gsap.core.getCache(element).uncache = 1;\r\n    parent.appendChild(element);\r\n  }\r\n},\r\n    _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {\r\n  var last1 = initialValue,\r\n      last2 = last1;\r\n  return function (value) {\r\n    var current = Math.round(getValueFunc()); // round because in some [very uncommon] Windows environments, scroll can get reported with decimals even though it was set without.\r\n\r\n    if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {\r\n      // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.\r\n      value = current;\r\n      onInterrupt && onInterrupt();\r\n    }\r\n\r\n    last2 = last1;\r\n    last1 = Math.round(value);\r\n    return last1;\r\n  };\r\n},\r\n    _shiftMarker = function _shiftMarker(marker, direction, value) {\r\n  var vars = {};\r\n  vars[direction.p] = \"+=\" + value;\r\n  gsap.set(marker, vars);\r\n},\r\n    // _mergeAnimations = animations => {\r\n// \tlet tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));\r\n// \tanimations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });\r\n// \ttl.smoothChildTiming = false;\r\n// \treturn tl;\r\n// },\r\n// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)\r\n_getTweenCreator = function _getTweenCreator(scroller, direction) {\r\n  var getScroll = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\r\n      prop = \"_scroll\" + direction.p2,\r\n      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.\r\n  getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {\r\n    var tween = getTween.tween,\r\n        onComplete = vars.onComplete,\r\n        modifiers = {};\r\n    initialValue = initialValue || getScroll();\r\n\r\n    var checkForInterruption = _interruptionTracker(getScroll, initialValue, function () {\r\n      tween.kill();\r\n      getTween.tween = 0;\r\n    });\r\n\r\n    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.\r\n\r\n    change1 = change1 || scrollTo - initialValue;\r\n    tween && tween.kill();\r\n    vars[prop] = scrollTo;\r\n    vars.inherit = false;\r\n    vars.modifiers = modifiers;\r\n\r\n    modifiers[prop] = function () {\r\n      return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio);\r\n    };\r\n\r\n    vars.onUpdate = function () {\r\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;\r\n      getTween.tween && _updateAll(); // if it was interrupted/killed, like in a context.revert(), don't force an updateAll()\r\n    };\r\n\r\n    vars.onComplete = function () {\r\n      getTween.tween = 0;\r\n      onComplete && onComplete.call(tween);\r\n    };\r\n\r\n    tween = getTween.tween = gsap.to(scroller, vars);\r\n    return tween;\r\n  };\r\n\r\n  scroller[prop] = getScroll;\r\n\r\n  getScroll.wheelHandler = function () {\r\n    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);\r\n  };\r\n\r\n  _addListener(scroller, \"wheel\", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like \"3 lines per scroll\") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.\r\n\r\n\r\n  ScrollTrigger.isTouch && _addListener(scroller, \"touchmove\", getScroll.wheelHandler);\r\n  return getTween;\r\n};\r\n\r\nvar ScrollTrigger = /*#__PURE__*/function () {\r\n  function ScrollTrigger(vars, animation) {\r\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollTrigger)\");\r\n\r\n    _context(this);\r\n\r\n    this.init(vars, animation);\r\n  }\r\n\r\n  var _proto = ScrollTrigger.prototype;\r\n\r\n  _proto.init = function init(vars, animation) {\r\n    this.progress = this.start = 0;\r\n    this.vars && this.kill(true, true); // in case it's being initted again\r\n\r\n    if (!_enabled) {\r\n      this.update = this.refresh = this.kill = _passThrough;\r\n      return;\r\n    }\r\n\r\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\r\n      trigger: vars\r\n    } : vars, _defaults);\r\n\r\n    var _vars = vars,\r\n        onUpdate = _vars.onUpdate,\r\n        toggleClass = _vars.toggleClass,\r\n        id = _vars.id,\r\n        onToggle = _vars.onToggle,\r\n        onRefresh = _vars.onRefresh,\r\n        scrub = _vars.scrub,\r\n        trigger = _vars.trigger,\r\n        pin = _vars.pin,\r\n        pinSpacing = _vars.pinSpacing,\r\n        invalidateOnRefresh = _vars.invalidateOnRefresh,\r\n        anticipatePin = _vars.anticipatePin,\r\n        onScrubComplete = _vars.onScrubComplete,\r\n        onSnapComplete = _vars.onSnapComplete,\r\n        once = _vars.once,\r\n        snap = _vars.snap,\r\n        pinReparent = _vars.pinReparent,\r\n        pinSpacer = _vars.pinSpacer,\r\n        containerAnimation = _vars.containerAnimation,\r\n        fastScrollEnd = _vars.fastScrollEnd,\r\n        preventOverlaps = _vars.preventOverlaps,\r\n        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical,\r\n        isToggle = !scrub && scrub !== 0,\r\n        scroller = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win),\r\n        scrollerCache = gsap.core.getCache(scroller),\r\n        isViewport = _isViewport(scroller),\r\n        useFixedPosition = (\"pinType\" in vars ? vars.pinType : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"pinType\") || isViewport && \"fixed\") === \"fixed\",\r\n        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\r\n        toggleActions = isToggle && vars.toggleActions.split(\" \"),\r\n        markers = \"markers\" in vars ? vars.markers : _defaults.markers,\r\n        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)[\"border\" + direction.p2 + _Width]) || 0,\r\n        self = this,\r\n        onRefreshInit = vars.onRefreshInit && function () {\r\n      return vars.onRefreshInit(self);\r\n    },\r\n        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\r\n        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\r\n        lastSnap = 0,\r\n        lastRefresh = 0,\r\n        prevProgress = 0,\r\n        scrollFunc = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),\r\n        tweenTo,\r\n        pinCache,\r\n        snapFunc,\r\n        scroll1,\r\n        scroll2,\r\n        start,\r\n        end,\r\n        markerStart,\r\n        markerEnd,\r\n        markerStartTrigger,\r\n        markerEndTrigger,\r\n        markerVars,\r\n        executingOnRefresh,\r\n        change,\r\n        pinOriginalState,\r\n        pinActiveState,\r\n        pinState,\r\n        spacer,\r\n        offset,\r\n        pinGetter,\r\n        pinSetter,\r\n        pinStart,\r\n        pinChange,\r\n        spacingStart,\r\n        spacerState,\r\n        markerStartSetter,\r\n        pinMoves,\r\n        markerEndSetter,\r\n        cs,\r\n        snap1,\r\n        snap2,\r\n        scrubTween,\r\n        scrubSmooth,\r\n        snapDurClamp,\r\n        snapDelayedCall,\r\n        prevScroll,\r\n        prevAnimProgress,\r\n        caMarkerSetter,\r\n        customRevertReturn; // for the sake of efficiency, _startClamp/_endClamp serve like a truthy value indicating that clamping was enabled on the start/end, and ALSO store the actual pre-clamped numeric value. We tap into that in ScrollSmoother for speed effects. So for example, if start=\"clamp(top bottom)\" results in a start of -100 naturally, it would get clamped to 0 but -100 would be stored in _startClamp.\r\n\r\n\r\n    self._startClamp = self._endClamp = false;\r\n    self._dir = direction;\r\n    anticipatePin *= 45;\r\n    self.scroller = scroller;\r\n    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;\r\n    scroll1 = scrollFunc();\r\n    self.vars = vars;\r\n    animation = animation || vars.animation;\r\n\r\n    if (\"refreshPriority\" in vars) {\r\n      _sort = 1;\r\n      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother\r\n    }\r\n\r\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\r\n      top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\r\n      left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)\r\n    };\r\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\r\n\r\n    self.scrubDuration = function (value) {\r\n      scrubSmooth = _isNumber(value) && value;\r\n\r\n      if (!scrubSmooth) {\r\n        scrubTween && scrubTween.progress(1).kill();\r\n        scrubTween = 0;\r\n      } else {\r\n        scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {\r\n          ease: \"expo\",\r\n          totalProgress: \"+=0\",\r\n          inherit: false,\r\n          duration: scrubSmooth,\r\n          paused: true,\r\n          onComplete: function onComplete() {\r\n            return onScrubComplete && onScrubComplete(self);\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    if (animation) {\r\n      animation.vars.lazy = false;\r\n      animation._initted && !self.isReverted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.duration() && animation.render(0, true, true); // special case: if this ScrollTrigger gets re-initted, a from() tween with a stagger could get initted initially and then reverted on the re-init which means it'll need to get rendered again here to properly display things. Otherwise, See https://gsap.com/forums/topic/36777-scrollsmoother-splittext-nextjs/ and https://codepen.io/GreenSock/pen/eYPyPpd?editors=0010\r\n\r\n      self.animation = animation.pause();\r\n      animation.scrollTrigger = self;\r\n      self.scrubDuration(scrub);\r\n      snap1 = 0;\r\n      id || (id = animation.vars.id);\r\n    }\r\n\r\n    if (snap) {\r\n      // TODO: potential idea: use legitimate CSS scroll snapping by pushing invisible elements into the DOM that serve as snap positions, and toggle the document.scrollingElement.style.scrollSnapType onToggle. See https://codepen.io/GreenSock/pen/JjLrgWM for a quick proof of concept.\r\n      if (!_isObject(snap) || snap.push) {\r\n        snap = {\r\n          snapTo: snap\r\n        };\r\n      }\r\n\r\n      \"scrollBehavior\" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\r\n        scrollBehavior: \"auto\"\r\n      }); // smooth scrolling doesn't work with snap.\r\n\r\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function (o) {\r\n        return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = false);\r\n      }); // note: set smooth to false on both the vertical and horizontal scroll getters/setters\r\n\r\n\r\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === \"labels\" ? _getClosestLabel(animation) : snap.snapTo === \"labelsDirectional\" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {\r\n        return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction);\r\n      } : gsap.utils.snap(snap.snapTo);\r\n      snapDurClamp = snap.duration || {\r\n        min: 0.1,\r\n        max: 2\r\n      };\r\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\r\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {\r\n        var scroll = scrollFunc(),\r\n            refreshedRecently = _getTime() - lastRefresh < 500,\r\n            tween = tweenTo.tween;\r\n\r\n        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {\r\n          var progress = (scroll - start) / change,\r\n              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,\r\n              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\r\n              change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),\r\n              naturalEnd = progress + (snap.inertia === false ? 0 : change1),\r\n              endValue,\r\n              endScroll,\r\n              _snap = snap,\r\n              onStart = _snap.onStart,\r\n              _onInterrupt = _snap.onInterrupt,\r\n              _onComplete = _snap.onComplete;\r\n          endValue = snapFunc(naturalEnd, self);\r\n          _isNumber(endValue) || (endValue = naturalEnd); // in case the function didn't return a number, fall back to using the naturalEnd\r\n\r\n          endScroll = Math.max(0, Math.round(start + endValue * change));\r\n\r\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\r\n            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {\r\n              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.\r\n              return;\r\n            }\r\n\r\n            if (snap.inertia === false) {\r\n              change1 = endValue - progress;\r\n            }\r\n\r\n            tweenTo(endScroll, {\r\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\r\n              ease: snap.ease || \"power3\",\r\n              data: _abs(endScroll - scroll),\r\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\r\n              onInterrupt: function onInterrupt() {\r\n                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);\r\n              },\r\n              onComplete: function onComplete() {\r\n                self.update();\r\n                lastSnap = scrollFunc();\r\n\r\n                if (animation && !isToggle) {\r\n                  // the resolution of the scrollbar is limited, so we should correct the scrubbed animation's playhead at the end to match EXACTLY where it was supposed to snap\r\n                  scrubTween ? scrubTween.resetTo(\"totalProgress\", endValue, animation._tTime / animation._tDur) : animation.progress(endValue);\r\n                }\r\n\r\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\r\n                onSnapComplete && onSnapComplete(self);\r\n                _onComplete && _onComplete(self);\r\n              }\r\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\r\n            onStart && onStart(self, tweenTo.tween);\r\n          }\r\n        } else if (self.isActive && lastSnap !== scroll) {\r\n          snapDelayedCall.restart(true);\r\n        }\r\n      }).pause();\r\n    }\r\n\r\n    id && (_ids[id] = self);\r\n    trigger = self.trigger = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== true && pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the \"y\" or \"x\" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.\r\n\r\n    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;\r\n    customRevertReturn && (customRevertReturn = customRevertReturn(self));\r\n    pin = pin === true ? trigger : (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);\r\n    _isString(toggleClass) && (toggleClass = {\r\n      targets: trigger,\r\n      className: toggleClass\r\n    });\r\n\r\n    if (pin) {\r\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === \"flex\" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default. We should check that pin.parentNode is an element (not shadow dom window)\r\n\r\n      self.pin = pin;\r\n      pinCache = gsap.core.getCache(pin);\r\n\r\n      if (!pinCache.spacer) {\r\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the \"original\" pin state after it has already been affected by another ScrollTrigger.\r\n        if (pinSpacer) {\r\n          pinSpacer = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);\r\n          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular\r\n\r\n          pinCache.spacerIsNative = !!pinSpacer;\r\n          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));\r\n        }\r\n\r\n        pinCache.spacer = spacer = pinSpacer || _doc.createElement(\"div\");\r\n        spacer.classList.add(\"pin-spacer\");\r\n        id && spacer.classList.add(\"pin-spacer-\" + id);\r\n        pinCache.pinState = pinOriginalState = _getState(pin);\r\n      } else {\r\n        pinOriginalState = pinCache.pinState;\r\n      }\r\n\r\n      vars.force3D !== false && gsap.set(pin, {\r\n        force3D: true\r\n      });\r\n      self.spacer = spacer = pinCache.spacer;\r\n      cs = _getComputedStyle(pin);\r\n      spacingStart = cs[pinSpacing + direction.os2];\r\n      pinGetter = gsap.getProperty(pin);\r\n      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = \"hidden\"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\r\n\r\n      _swapPinIn(pin, spacer, cs);\r\n\r\n      pinState = _getState(pin);\r\n    }\r\n\r\n    if (markers) {\r\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\r\n      markerStartTrigger = _createMarker(\"scroller-start\", id, scroller, direction, markerVars, 0);\r\n      markerEndTrigger = _createMarker(\"scroller-end\", id, scroller, direction, markerVars, 0, markerStartTrigger);\r\n      offset = markerStartTrigger[\"offset\" + direction.op.d2];\r\n\r\n      var content = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"content\") || scroller);\r\n\r\n      markerStart = this.markerStart = _createMarker(\"start\", id, content, direction, markerVars, offset, 0, containerAnimation);\r\n      markerEnd = this.markerEnd = _createMarker(\"end\", id, content, direction, markerVars, offset, 0, containerAnimation);\r\n      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));\r\n\r\n      if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, \"fixedMarkers\") === true)) {\r\n        _makePositionable(isViewport ? _body : scroller);\r\n\r\n        gsap.set([markerStartTrigger, markerEndTrigger], {\r\n          force3D: true\r\n        });\r\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\r\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\r\n      }\r\n    }\r\n\r\n    if (containerAnimation) {\r\n      var oldOnUpdate = containerAnimation.vars.onUpdate,\r\n          oldParams = containerAnimation.vars.onUpdateParams;\r\n      containerAnimation.eventCallback(\"onUpdate\", function () {\r\n        self.update(0, 0, 1);\r\n        oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || []);\r\n      });\r\n    }\r\n\r\n    self.previous = function () {\r\n      return _triggers[_triggers.indexOf(self) - 1];\r\n    };\r\n\r\n    self.next = function () {\r\n      return _triggers[_triggers.indexOf(self) + 1];\r\n    };\r\n\r\n    self.revert = function (revert, temp) {\r\n      if (!temp) {\r\n        return self.kill(true);\r\n      } // for compatibility with gsap.context() and gsap.matchMedia() which call revert()\r\n\r\n\r\n      var r = revert !== false || !self.enabled,\r\n          prevRefreshing = _refreshing;\r\n\r\n      if (r !== self.isReverted) {\r\n        if (r) {\r\n          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\r\n\r\n          prevProgress = self.progress;\r\n          prevAnimProgress = animation && animation.progress();\r\n        }\r\n\r\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\r\n          return m.style.display = r ? \"none\" : \"block\";\r\n        });\r\n\r\n        if (r) {\r\n          _refreshing = self;\r\n          self.update(r); // make sure the pin is back in its original position so that all the measurements are correct. do this BEFORE swapping the pin out\r\n        }\r\n\r\n        if (pin && (!pinReparent || !self.isActive)) {\r\n          if (r) {\r\n            _swapPinOut(pin, spacer, pinOriginalState);\r\n          } else {\r\n            _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState);\r\n          }\r\n        }\r\n\r\n        r || self.update(r); // when we're restoring, the update should run AFTER swapping the pin into its pin-spacer.\r\n\r\n        _refreshing = prevRefreshing; // restore. We set it to true during the update() so that things fire properly in there.\r\n\r\n        self.isReverted = r;\r\n      }\r\n    };\r\n\r\n    self.refresh = function (soft, force, position, pinOffset) {\r\n      // position is typically only defined if it's coming from setPositions() - it's a way to skip the normal parsing. pinOffset is also only from setPositions() and is mostly related to fancy stuff we need to do in ScrollSmoother with effects\r\n      if ((_refreshing || !self.enabled) && !force) {\r\n        return;\r\n      }\r\n\r\n      if (pin && soft && _lastScrollTime) {\r\n        _addListener(ScrollTrigger, \"scrollEnd\", _softRefresh);\r\n\r\n        return;\r\n      }\r\n\r\n      !_refreshingAll && onRefreshInit && onRefreshInit(self);\r\n      _refreshing = self;\r\n\r\n      if (tweenTo.tween && !position) {\r\n        // we skip this if a position is passed in because typically that's from .setPositions() and it's best to allow in-progress snapping to continue.\r\n        tweenTo.tween.kill();\r\n        tweenTo.tween = 0;\r\n      }\r\n\r\n      scrubTween && scrubTween.pause();\r\n\r\n      if (invalidateOnRefresh && animation) {\r\n        animation.revert({\r\n          kill: false\r\n        }).invalidate();\r\n        animation.getChildren && animation.getChildren(true, true, false).forEach(function (t) {\r\n          return t.vars.immediateRender && t.render(0, true, true);\r\n        }); // any from() or fromTo() tweens inside a timeline should render immediately (well, unless they have immediateRender: false)\r\n      }\r\n\r\n      self.isReverted || self.revert(true, true);\r\n      self._subPinOffset = false; // we'll set this to true in the sub-pins if we find any\r\n\r\n      var size = getScrollerSize(),\r\n          scrollerBounds = getScrollerOffsets(),\r\n          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),\r\n          isFirstRefresh = change <= 0.01 || !change,\r\n          offset = 0,\r\n          otherPinOffset = pinOffset || 0,\r\n          parsedEnd = _isObject(position) ? position.end : vars.end,\r\n          parsedEndTrigger = vars.endTrigger || trigger,\r\n          parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? \"0 0\" : \"0 100%\"),\r\n          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self),\r\n          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\r\n          i = triggerIndex,\r\n          cs,\r\n          bounds,\r\n          scroll,\r\n          isVertical,\r\n          override,\r\n          curTrigger,\r\n          curPin,\r\n          oppositeScroll,\r\n          initted,\r\n          revertedPins,\r\n          forcedOverflow,\r\n          markerStartOffset,\r\n          markerEndOffset;\r\n\r\n      if (markers && _isObject(position)) {\r\n        // if we alter the start/end positions with .setPositions(), it generally feeds in absolute NUMBERS which don't convey information about where to line up the markers, so to keep it intuitive, we record how far the trigger positions shift after applying the new numbers and then offset by that much in the opposite direction. We do the same to the associated trigger markers too of course.\r\n        markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);\r\n        markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p);\r\n      }\r\n\r\n      while (i-- > 0) {\r\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things \"rewind\" properly.\r\n        curTrigger = _triggers[i];\r\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.\r\n\r\n        curPin = curTrigger.pin;\r\n\r\n        if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {\r\n          revertedPins || (revertedPins = []);\r\n          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly\r\n\r\n          curTrigger.revert(true, true);\r\n        }\r\n\r\n        if (curTrigger !== _triggers[i]) {\r\n          // in case it got removed.\r\n          triggerIndex--;\r\n          i--;\r\n        }\r\n      }\r\n\r\n      _isFunction(parsedStart) && (parsedStart = parsedStart(self));\r\n      parsedStart = _parseClamp(parsedStart, \"start\", self);\r\n      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && \"_startClamp\") || (pin ? -0.001 : 0);\r\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\r\n\r\n      if (_isString(parsedEnd) && !parsedEnd.indexOf(\"+=\")) {\r\n        if (~parsedEnd.indexOf(\" \")) {\r\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(\" \")[0] : \"\") + parsedEnd;\r\n        } else {\r\n          offset = _offsetToPx(parsedEnd.substr(2), size);\r\n          parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.\r\n\r\n          parsedEndTrigger = trigger;\r\n        }\r\n      }\r\n\r\n      parsedEnd = _parseClamp(parsedEnd, \"end\", self);\r\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? \"100% 0\" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && \"_endClamp\")) || -0.001;\r\n      offset = 0;\r\n      i = triggerIndex;\r\n\r\n      while (i--) {\r\n        curTrigger = _triggers[i];\r\n        curPin = curTrigger.pin;\r\n\r\n        if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {\r\n          cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);\r\n\r\n          if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {\r\n            // numeric start values shouldn't be offset at all - treat them as absolute\r\n            offset += cs * (1 - curTrigger.progress);\r\n          }\r\n\r\n          curPin === pin && (otherPinOffset += cs);\r\n        }\r\n      }\r\n\r\n      start += offset;\r\n      end += offset;\r\n      self._startClamp && (self._startClamp += offset);\r\n\r\n      if (self._endClamp && !_refreshingAll) {\r\n        self._endClamp = end || -0.001;\r\n        end = Math.min(end, _maxScroll(scroller, direction));\r\n      }\r\n\r\n      change = end - start || (start -= 0.01) && 0.001;\r\n\r\n      if (isFirstRefresh) {\r\n        // on the very first refresh(), the prevProgress couldn't have been accurate yet because the start/end were never calculated, so we set it here. Before 3.11.5, it could lead to an inaccurate scroll position restoration with snapping.\r\n        prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll));\r\n      }\r\n\r\n      self._pinPush = otherPinOffset;\r\n\r\n      if (markerStart && offset) {\r\n        // offset the markers if necessary\r\n        cs = {};\r\n        cs[direction.a] = \"+=\" + offset;\r\n        pinnedContainer && (cs[direction.p] = \"-=\" + scrollFunc());\r\n        gsap.set([markerStart, markerEnd], cs);\r\n      }\r\n\r\n      if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {\r\n        cs = _getComputedStyle(pin);\r\n        isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;\r\n        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll\r\n\r\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\r\n\r\n        if (!max && end > 1) {\r\n          // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://gsap.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\r\n          forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;\r\n          forcedOverflow = {\r\n            style: forcedOverflow,\r\n            value: forcedOverflow[\"overflow\" + direction.a.toUpperCase()]\r\n          };\r\n\r\n          if (isViewport && _getComputedStyle(_body)[\"overflow\" + direction.a.toUpperCase()] !== \"scroll\") {\r\n            // avoid an extra scrollbar if BOTH <html> and <body> have overflow set to \"scroll\"\r\n            forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = \"scroll\";\r\n          }\r\n        }\r\n\r\n        _swapPinIn(pin, spacer, cs);\r\n\r\n        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\r\n\r\n        bounds = _getBounds(pin, true);\r\n        oppositeScroll = useFixedPosition && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();\r\n\r\n        if (pinSpacing) {\r\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\r\n          spacerState.t = spacer;\r\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\r\n\r\n          if (i) {\r\n            spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\r\n\r\n            spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\r\n          }\r\n\r\n          _setState(spacerState);\r\n\r\n          if (pinnedContainer) {\r\n            // in ScrollTrigger.refresh(), we need to re-evaluate the pinContainer's size because this pinSpacing may stretch it out, but we can't just add the exact distance because depending on layout, it may not push things down or it may only do so partially.\r\n            _triggers.forEach(function (t) {\r\n              if (t.pin === pinnedContainer && t.vars.pinSpacing !== false) {\r\n                t._subPinOffset = true;\r\n              }\r\n            });\r\n          }\r\n\r\n          useFixedPosition && scrollFunc(prevScroll);\r\n        } else {\r\n          i = _getSize(pin, direction);\r\n          i && spacer.style.flexBasis !== \"auto\" && (spacer.style.flexBasis = i + _px);\r\n        }\r\n\r\n        if (useFixedPosition) {\r\n          override = {\r\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\r\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\r\n            boxSizing: \"border-box\",\r\n            position: \"fixed\"\r\n          };\r\n          override[_width] = override[\"max\" + _Width] = Math.ceil(bounds.width) + _px;\r\n          override[_height] = override[\"max\" + _Height] = Math.ceil(bounds.height) + _px;\r\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = \"0\";\r\n          override[_padding] = cs[_padding];\r\n          override[_padding + _Top] = cs[_padding + _Top];\r\n          override[_padding + _Right] = cs[_padding + _Right];\r\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\r\n          override[_padding + _Left] = cs[_padding + _Left];\r\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\r\n          _refreshingAll && scrollFunc(0);\r\n        }\r\n\r\n        if (animation) {\r\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.\r\n          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\r\n\r\n          _suppressOverwrites(1);\r\n\r\n          animation.render(animation.duration(), true, true);\r\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\r\n          pinMoves = Math.abs(change - pinChange) > 1;\r\n          useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\r\n\r\n          animation.render(0, true, true);\r\n          initted || animation.invalidate(true);\r\n          animation.parent || animation.totalTime(animation.totalTime()); // if, for example, a toggleAction called play() and then refresh() happens and when we render(1) above, it would cause the animation to complete and get removed from its parent, so this makes sure it gets put back in.\r\n\r\n          _suppressOverwrites(0);\r\n        } else {\r\n          pinChange = change;\r\n        }\r\n\r\n        forcedOverflow && (forcedOverflow.value ? forcedOverflow.style[\"overflow\" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty(\"overflow-\" + direction.a));\r\n      } else if (trigger && scrollFunc() && !containerAnimation) {\r\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()\r\n        bounds = trigger.parentNode;\r\n\r\n        while (bounds && bounds !== _body) {\r\n          if (bounds._pinOffset) {\r\n            start -= bounds._pinOffset;\r\n            end -= bounds._pinOffset;\r\n          }\r\n\r\n          bounds = bounds.parentNode;\r\n        }\r\n      }\r\n\r\n      revertedPins && revertedPins.forEach(function (t) {\r\n        return t.revert(false, true);\r\n      });\r\n      self.start = start;\r\n      self.end = end;\r\n      scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc(); // reset velocity\r\n\r\n      if (!containerAnimation && !_refreshingAll) {\r\n        scroll1 < prevScroll && scrollFunc(prevScroll);\r\n        self.scroll.rec = 0;\r\n      }\r\n\r\n      self.revert(false, true);\r\n      lastRefresh = _getTime();\r\n\r\n      if (snapDelayedCall) {\r\n        lastSnap = -1; // just so snapping gets re-enabled, clear out any recorded last value\r\n        // self.isActive && scrollFunc(start + change * prevProgress); // previously this line was here to ensure that when snapping kicks in, it's from the previous progress but in some cases that's not desirable, like an all-page ScrollTrigger when new content gets added to the page, that'd totally change the progress.\r\n\r\n        snapDelayedCall.restart(true);\r\n      }\r\n\r\n      _refreshing = 0;\r\n      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\r\n\r\n      if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh || animation && !animation._initted) {\r\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\r\n        animation && !isToggle && (animation._initted || prevProgress || animation.vars.immediateRender !== false) && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.\r\n\r\n        self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress;\r\n      }\r\n\r\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\r\n      scrubTween && scrubTween.invalidate();\r\n\r\n      if (!isNaN(markerStartOffset)) {\r\n        // numbers were passed in for the position which are absolute, so instead of just putting the markers at the very bottom of the viewport, we figure out how far they shifted down (it's safe to assume they were originally positioned in closer relation to the trigger element with values like \"top\", \"center\", a percentage or whatever, so we offset that much in the opposite direction to basically revert them to the relative position thy were at previously.\r\n        markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);\r\n        markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);\r\n\r\n        _shiftMarker(markerStartTrigger, direction, markerStartOffset);\r\n\r\n        _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));\r\n\r\n        _shiftMarker(markerEndTrigger, direction, markerEndOffset);\r\n\r\n        _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0));\r\n      }\r\n\r\n      isFirstRefresh && !_refreshingAll && self.update(); // edge case - when you reload a page when it's already scrolled down, some browsers fire a \"scroll\" event before DOMContentLoaded, triggering an updateAll(). If we don't update the self.progress as part of refresh(), then when it happens next, it may record prevProgress as 0 when it really shouldn't, potentially causing a callback in an animation to fire again.\r\n\r\n      if (onRefresh && !_refreshingAll && !executingOnRefresh) {\r\n        // when refreshing all, we do extra work to correct pinnedContainer sizes and ensure things don't exceed the maxScroll, so we should do all the refreshes at the end after all that work so that the start/end values are corrected.\r\n        executingOnRefresh = true;\r\n        onRefresh(self);\r\n        executingOnRefresh = false;\r\n      }\r\n    };\r\n\r\n    self.getVelocity = function () {\r\n      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;\r\n    };\r\n\r\n    self.endAnimation = function () {\r\n      _endAnimation(self.callbackAnimation);\r\n\r\n      if (animation) {\r\n        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);\r\n      }\r\n    };\r\n\r\n    self.labelToScroll = function (label) {\r\n      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;\r\n    };\r\n\r\n    self.getTrailing = function (name) {\r\n      var i = _triggers.indexOf(self),\r\n          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);\r\n\r\n      return (_isString(name) ? a.filter(function (t) {\r\n        return t.vars.preventOverlaps === name;\r\n      }) : a).filter(function (t) {\r\n        return self.direction > 0 ? t.end <= start : t.start >= end;\r\n      });\r\n    };\r\n\r\n    self.update = function (reset, recordVelocity, forceFake) {\r\n      if (containerAnimation && !forceFake && !reset) {\r\n        return;\r\n      }\r\n\r\n      var scroll = _refreshingAll === true ? prevScroll : self.scroll(),\r\n          p = reset ? 0 : (scroll - start) / change,\r\n          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\r\n          prevProgress = self.progress,\r\n          isActive,\r\n          wasActive,\r\n          toggleState,\r\n          action,\r\n          stateChanged,\r\n          toggled,\r\n          isAtMax,\r\n          isTakingAction;\r\n\r\n      if (recordVelocity) {\r\n        scroll2 = scroll1;\r\n        scroll1 = containerAnimation ? scrollFunc() : scroll;\r\n\r\n        if (snap) {\r\n          snap2 = snap1;\r\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\r\n        }\r\n      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\r\n\r\n\r\n      if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {\r\n        if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\r\n          clipped = 0.0001;\r\n        } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {\r\n          clipped = 0.9999;\r\n        }\r\n      }\r\n\r\n      if (clipped !== prevProgress && self.enabled) {\r\n        isActive = self.isActive = !!clipped && clipped < 1;\r\n        wasActive = !!prevProgress && prevProgress < 1;\r\n        toggled = isActive !== wasActive;\r\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)\r\n\r\n        self.direction = clipped > prevProgress ? 1 : -1;\r\n        self.progress = clipped;\r\n\r\n        if (stateChanged && !_refreshing) {\r\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.\r\n\r\n          if (isToggle) {\r\n            action = !toggled && toggleActions[toggleState + 1] !== \"none\" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the \"enter\" action, we should switch to the \"leave\" in this case (but only if one is defined)\r\n\r\n            isTakingAction = animation && (action === \"complete\" || action === \"reset\" || action in animation);\r\n          }\r\n        }\r\n\r\n        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {\r\n          return t.endAnimation();\r\n        }));\r\n\r\n        if (!isToggle) {\r\n          if (scrubTween && !_refreshing && !_startup) {\r\n            scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.\r\n\r\n            if (scrubTween.resetTo) {\r\n              scrubTween.resetTo(\"totalProgress\", clipped, animation._tTime / animation._tDur);\r\n            } else {\r\n              // legacy support (courtesy), before 3.10.0\r\n              scrubTween.vars.totalProgress = clipped;\r\n              scrubTween.invalidate().restart();\r\n            }\r\n          } else if (animation) {\r\n            animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)));\r\n          }\r\n        }\r\n\r\n        if (pin) {\r\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\r\n\r\n          if (!useFixedPosition) {\r\n            pinSetter(_round(pinStart + pinChange * clipped));\r\n          } else if (stateChanged) {\r\n            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\r\n\r\n            if (pinReparent) {\r\n              if (!reset && (isActive || isAtMax)) {\r\n                var bounds = _getBounds(pin, true),\r\n                    _offset = scroll - start;\r\n\r\n                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px);\r\n              } else {\r\n                _reparent(pin, spacer);\r\n              }\r\n            }\r\n\r\n            _setState(isActive || isAtMax ? pinActiveState : pinState);\r\n\r\n            pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));\r\n          }\r\n        }\r\n\r\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\r\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {\r\n          return el.classList[isActive || once ? \"add\" : \"remove\"](toggleClass.className);\r\n        }); // classes could affect positioning, so do it even if reset or refreshing is true.\r\n\r\n        onUpdate && !isToggle && !reset && onUpdate(self);\r\n\r\n        if (stateChanged && !_refreshing) {\r\n          if (isToggle) {\r\n            if (isTakingAction) {\r\n              if (action === \"complete\") {\r\n                animation.pause().totalProgress(1);\r\n              } else if (action === \"reset\") {\r\n                animation.restart(true).pause();\r\n              } else if (action === \"restart\") {\r\n                animation.restart(true);\r\n              } else {\r\n                animation[action]();\r\n              }\r\n            }\r\n\r\n            onUpdate && onUpdate(self);\r\n          }\r\n\r\n          if (toggled || !_limitCallbacks) {\r\n            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.\r\n            onToggle && toggled && _callback(self, onToggle);\r\n            callbacks[toggleState] && _callback(self, callbacks[toggleState]);\r\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.\r\n\r\n            if (!toggled) {\r\n              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\r\n              toggleState = clipped === 1 ? 1 : 3;\r\n              callbacks[toggleState] && _callback(self, callbacks[toggleState]);\r\n            }\r\n          }\r\n\r\n          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {\r\n            _endAnimation(self.callbackAnimation);\r\n\r\n            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === \"reverse\" ? 1 : !clipped, 1);\r\n          }\r\n        } else if (isToggle && onUpdate && !_refreshing) {\r\n          onUpdate(self);\r\n        }\r\n      } // update absolutely-positioned markers (only if the scroller isn't the viewport)\r\n\r\n\r\n      if (markerEndSetter) {\r\n        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;\r\n        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));\r\n        markerEndSetter(n);\r\n      }\r\n\r\n      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));\r\n    };\r\n\r\n    self.enable = function (reset, refresh) {\r\n      if (!self.enabled) {\r\n        self.enabled = true;\r\n\r\n        _addListener(scroller, \"resize\", _onResize);\r\n\r\n        isViewport || _addListener(scroller, \"scroll\", _onScroll);\r\n        onRefreshInit && _addListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\r\n\r\n        if (reset !== false) {\r\n          self.progress = prevProgress = 0;\r\n          scroll1 = scroll2 = lastSnap = scrollFunc();\r\n        }\r\n\r\n        refresh !== false && self.refresh();\r\n      }\r\n    };\r\n\r\n    self.getTween = function (snap) {\r\n      return snap && tweenTo ? tweenTo.tween : scrubTween;\r\n    };\r\n\r\n    self.setPositions = function (newStart, newEnd, keepClamp, pinOffset) {\r\n      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()\r\n      if (containerAnimation) {\r\n        // convert ratios into scroll positions. Remember, start/end values on ScrollTriggers that have a containerAnimation refer to the time (in seconds), NOT scroll positions.\r\n        var st = containerAnimation.scrollTrigger,\r\n            duration = containerAnimation.duration(),\r\n            _change = st.end - st.start;\r\n\r\n        newStart = st.start + _change * newStart / duration;\r\n        newEnd = st.start + _change * newEnd / duration;\r\n      }\r\n\r\n      self.refresh(false, false, {\r\n        start: _keepClamp(newStart, keepClamp && !!self._startClamp),\r\n        end: _keepClamp(newEnd, keepClamp && !!self._endClamp)\r\n      }, pinOffset);\r\n      self.update();\r\n    };\r\n\r\n    self.adjustPinSpacing = function (amount) {\r\n      if (spacerState && amount) {\r\n        var i = spacerState.indexOf(direction.d) + 1;\r\n        spacerState[i] = parseFloat(spacerState[i]) + amount + _px;\r\n        spacerState[1] = parseFloat(spacerState[1]) + amount + _px;\r\n\r\n        _setState(spacerState);\r\n      }\r\n    };\r\n\r\n    self.disable = function (reset, allowAnimation) {\r\n      if (self.enabled) {\r\n        reset !== false && self.revert(true, true);\r\n        self.enabled = self.isActive = false;\r\n        allowAnimation || scrubTween && scrubTween.pause();\r\n        prevScroll = 0;\r\n        pinCache && (pinCache.uncache = 1);\r\n        onRefreshInit && _removeListener(ScrollTrigger, \"refreshInit\", onRefreshInit);\r\n\r\n        if (snapDelayedCall) {\r\n          snapDelayedCall.pause();\r\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\r\n        }\r\n\r\n        if (!isViewport) {\r\n          var i = _triggers.length;\r\n\r\n          while (i--) {\r\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\r\n              return; //don't remove the listeners if there are still other triggers referencing it.\r\n            }\r\n          }\r\n\r\n          _removeListener(scroller, \"resize\", _onResize);\r\n\r\n          isViewport || _removeListener(scroller, \"scroll\", _onScroll);\r\n        }\r\n      }\r\n    };\r\n\r\n    self.kill = function (revert, allowAnimation) {\r\n      self.disable(revert, allowAnimation);\r\n      scrubTween && !allowAnimation && scrubTween.kill();\r\n      id && delete _ids[id];\r\n\r\n      var i = _triggers.indexOf(self);\r\n\r\n      i >= 0 && _triggers.splice(i, 1);\r\n      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\r\n      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.\r\n\r\n      i = 0;\r\n\r\n      _triggers.forEach(function (t) {\r\n        return t.scroller === self.scroller && (i = 1);\r\n      });\r\n\r\n      i || _refreshingAll || (self.scroll.rec = 0);\r\n\r\n      if (animation) {\r\n        animation.scrollTrigger = null;\r\n        revert && animation.revert({\r\n          kill: false\r\n        });\r\n        allowAnimation || animation.kill();\r\n      }\r\n\r\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {\r\n        return m.parentNode && m.parentNode.removeChild(m);\r\n      });\r\n      _primary === self && (_primary = 0);\r\n\r\n      if (pin) {\r\n        pinCache && (pinCache.uncache = 1);\r\n        i = 0;\r\n\r\n        _triggers.forEach(function (t) {\r\n          return t.pin === pin && i++;\r\n        });\r\n\r\n        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\r\n      }\r\n\r\n      vars.onKill && vars.onKill(self);\r\n    };\r\n\r\n    _triggers.push(self);\r\n\r\n    self.enable(false, false);\r\n    customRevertReturn && customRevertReturn(self);\r\n\r\n    if (animation && animation.add && !change) {\r\n      // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If \"change\" is defined, we know it must be re-enabling, thus we can refresh() right away.\r\n      var updateFunc = self.update; // some browsers may fire a scroll event BEFORE a tick elapses and/or the DOMContentLoaded fires. So there's a chance update() will be called BEFORE a refresh() has happened on a Timeline-attached ScrollTrigger which means the start/end won't be calculated yet. We don't want to add conditional logic inside the update() method (like check to see if end is defined and if not, force a refresh()) because that's a function that gets hit a LOT (performance). So we swap out the real update() method for this one that'll re-attach it the first time it gets called and of course forces a refresh().\r\n\r\n      self.update = function () {\r\n        self.update = updateFunc;\r\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // otherwise a cached scroll position may get used in the refresh() in a very rare scenario, like if ScrollTriggers are created inside a DOMContentLoaded event and the queued requestAnimationFrame() fires beforehand. See https://gsap.com/community/forums/topic/41267-scrolltrigger-breaks-on-refresh-when-using-domcontentloaded/\r\n\r\n        start || end || self.refresh();\r\n      };\r\n\r\n      gsap.delayedCall(0.01, self.update);\r\n      change = 0.01;\r\n      start = end = 0;\r\n    } else {\r\n      self.refresh();\r\n    }\r\n\r\n    pin && _queueRefreshAll(); // pinning could affect the positions of other things, so make sure we queue a full refresh()\r\n  };\r\n\r\n  ScrollTrigger.register = function register(core) {\r\n    if (!_coreInitted) {\r\n      gsap = core || _getGSAP();\r\n      _windowExists() && window.document && ScrollTrigger.enable();\r\n      _coreInitted = _enabled;\r\n    }\r\n\r\n    return _coreInitted;\r\n  };\r\n\r\n  ScrollTrigger.defaults = function defaults(config) {\r\n    if (config) {\r\n      for (var p in config) {\r\n        _defaults[p] = config[p];\r\n      }\r\n    }\r\n\r\n    return _defaults;\r\n  };\r\n\r\n  ScrollTrigger.disable = function disable(reset, kill) {\r\n    _enabled = 0;\r\n\r\n    _triggers.forEach(function (trigger) {\r\n      return trigger[kill ? \"kill\" : \"disable\"](reset);\r\n    });\r\n\r\n    _removeListener(_win, \"wheel\", _onScroll);\r\n\r\n    _removeListener(_doc, \"scroll\", _onScroll);\r\n\r\n    clearInterval(_syncInterval);\r\n\r\n    _removeListener(_doc, \"touchcancel\", _passThrough);\r\n\r\n    _removeListener(_body, \"touchstart\", _passThrough);\r\n\r\n    _multiListener(_removeListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\r\n\r\n    _multiListener(_removeListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\r\n\r\n    _resizeDelay.kill();\r\n\r\n    _iterateAutoRefresh(_removeListener);\r\n\r\n    for (var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {\r\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\r\n\r\n      _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\r\n    }\r\n  };\r\n\r\n  ScrollTrigger.enable = function enable() {\r\n    _win = window;\r\n    _doc = document;\r\n    _docEl = _doc.documentElement;\r\n    _body = _doc.body;\r\n\r\n    if (gsap) {\r\n      _toArray = gsap.utils.toArray;\r\n      _clamp = gsap.utils.clamp;\r\n      _context = gsap.core.context || _passThrough;\r\n      _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\r\n      _scrollRestoration = _win.history.scrollRestoration || \"auto\";\r\n      _lastScroll = _win.pageYOffset || 0;\r\n      gsap.core.globals(\"ScrollTrigger\", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\r\n\r\n      if (_body) {\r\n        _enabled = 1;\r\n        _div100vh = document.createElement(\"div\"); // to solve mobile browser address bar show/hide resizing, we shouldn't rely on window.innerHeight. Instead, use a <div> with its height set to 100vh and measure that since that's what the scrolling is based on anyway and it's not affected by address bar showing/hiding.\r\n\r\n        _div100vh.style.height = \"100vh\";\r\n        _div100vh.style.position = \"absolute\";\r\n\r\n        _refresh100vh();\r\n\r\n        _rafBugFix();\r\n\r\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\r\n\r\n        ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;\r\n        _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503\r\n\r\n        _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;\r\n\r\n        _addListener(_win, \"wheel\", _onScroll); // mostly for 3rd party smooth scrolling libraries.\r\n\r\n\r\n        _root = [_win, _doc, _docEl, _body];\r\n\r\n        if (gsap.matchMedia) {\r\n          ScrollTrigger.matchMedia = function (vars) {\r\n            var mm = gsap.matchMedia(),\r\n                p;\r\n\r\n            for (p in vars) {\r\n              mm.add(p, vars[p]);\r\n            }\r\n\r\n            return mm;\r\n          };\r\n\r\n          gsap.addEventListener(\"matchMediaInit\", function () {\r\n            return _revertAll();\r\n          });\r\n          gsap.addEventListener(\"matchMediaRevert\", function () {\r\n            return _revertRecorded();\r\n          });\r\n          gsap.addEventListener(\"matchMedia\", function () {\r\n            _refreshAll(0, 1);\r\n\r\n            _dispatch(\"matchMedia\");\r\n          });\r\n          gsap.matchMedia().add(\"(orientation: portrait)\", function () {\r\n            // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.\r\n            _setBaseDimensions();\r\n\r\n            return _setBaseDimensions;\r\n          });\r\n        } else {\r\n          console.warn(\"Requires GSAP 3.11.0 or later\");\r\n        }\r\n\r\n        _setBaseDimensions();\r\n\r\n        _addListener(_doc, \"scroll\", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!\r\n\r\n\r\n        var bodyHasStyle = _body.hasAttribute(\"style\"),\r\n            bodyStyle = _body.style,\r\n            border = bodyStyle.borderTopStyle,\r\n            AnimationProto = gsap.core.Animation.prototype,\r\n            bounds,\r\n            i;\r\n\r\n        AnimationProto.revert || Object.defineProperty(AnimationProto, \"revert\", {\r\n          value: function value() {\r\n            return this.time(-0.01, true);\r\n          }\r\n        }); // only for backwards compatibility (Animation.revert() was added after 3.10.4)\r\n\r\n        bodyStyle.borderTopStyle = \"solid\"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.\r\n\r\n        bounds = _getBounds(_body);\r\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\r\n\r\n        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;\r\n        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty(\"border-top-style\");\r\n\r\n        if (!bodyHasStyle) {\r\n          // SSR frameworks like Next.js complain if this attribute gets added.\r\n          _body.setAttribute(\"style\", \"\"); // it's not enough to just removeAttribute() - we must first set it to empty, otherwise Next.js complains.\r\n\r\n\r\n          _body.removeAttribute(\"style\");\r\n        } // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.\r\n\r\n\r\n        _syncInterval = setInterval(_sync, 250);\r\n        gsap.delayedCall(0.5, function () {\r\n          return _startup = 0;\r\n        });\r\n\r\n        _addListener(_doc, \"touchcancel\", _passThrough); // some older Android devices intermittently stop dispatching \"touchmove\" events if we don't listen for \"touchcancel\" on the document.\r\n\r\n\r\n        _addListener(_body, \"touchstart\", _passThrough); //works around Safari bug: https://gsap.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\r\n\r\n\r\n        _multiListener(_addListener, _doc, \"pointerdown,touchstart,mousedown\", _pointerDownHandler);\r\n\r\n        _multiListener(_addListener, _doc, \"pointerup,touchend,mouseup\", _pointerUpHandler);\r\n\r\n        _transformProp = gsap.utils.checkPrefix(\"transform\");\r\n\r\n        _stateProps.push(_transformProp);\r\n\r\n        _coreInitted = _getTime();\r\n        _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\r\n        _autoRefresh = [_doc, \"visibilitychange\", function () {\r\n          var w = _win.innerWidth,\r\n              h = _win.innerHeight;\r\n\r\n          if (_doc.hidden) {\r\n            _prevWidth = w;\r\n            _prevHeight = h;\r\n          } else if (_prevWidth !== w || _prevHeight !== h) {\r\n            _onResize();\r\n          }\r\n        }, _doc, \"DOMContentLoaded\", _refreshAll, _win, \"load\", _refreshAll, _win, \"resize\", _onResize];\r\n\r\n        _iterateAutoRefresh(_addListener);\r\n\r\n        _triggers.forEach(function (trigger) {\r\n          return trigger.enable(0, 1);\r\n        });\r\n\r\n        for (i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {\r\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);\r\n\r\n          _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  ScrollTrigger.config = function config(vars) {\r\n    \"limitCallbacks\" in vars && (_limitCallbacks = !!vars.limitCallbacks);\r\n    var ms = vars.syncInterval;\r\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\r\n    \"ignoreMobileResize\" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);\r\n\r\n    if (\"autoRefreshEvents\" in vars) {\r\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || \"none\");\r\n      _ignoreResize = (vars.autoRefreshEvents + \"\").indexOf(\"resize\") === -1;\r\n    }\r\n  };\r\n\r\n  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {\r\n    var t = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target),\r\n        i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t),\r\n        isViewport = _isViewport(t);\r\n\r\n    if (~i) {\r\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2);\r\n    }\r\n\r\n    if (vars) {\r\n      isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars);\r\n    }\r\n  };\r\n\r\n  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {\r\n    _triggers.forEach(function (t) {\r\n      return t._ctx && t._ctx.query === query && t._ctx.kill(true, true);\r\n    });\r\n  };\r\n\r\n  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {\r\n    var bounds = (_isString(element) ? (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(),\r\n        offset = bounds[horizontal ? _width : _height] * ratio || 0;\r\n    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;\r\n  };\r\n\r\n  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {\r\n    _isString(element) && (element = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));\r\n    var bounds = element.getBoundingClientRect(),\r\n        size = bounds[horizontal ? _width : _height],\r\n        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf(\"%\") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;\r\n    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;\r\n  };\r\n\r\n  ScrollTrigger.killAll = function killAll(allowListeners) {\r\n    _triggers.slice(0).forEach(function (t) {\r\n      return t.vars.id !== \"ScrollSmoother\" && t.kill();\r\n    });\r\n\r\n    if (allowListeners !== true) {\r\n      var listeners = _listeners.killAll || [];\r\n      _listeners = {};\r\n      listeners.forEach(function (f) {\r\n        return f();\r\n      });\r\n    }\r\n  };\r\n\r\n  return ScrollTrigger;\r\n}();\r\nScrollTrigger.version = \"3.13.0\";\r\n\r\nScrollTrigger.saveStyles = function (targets) {\r\n  return targets ? _toArray(targets).forEach(function (target) {\r\n    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]\r\n    if (target && target.style) {\r\n      var i = _savedStyles.indexOf(target);\r\n\r\n      i >= 0 && _savedStyles.splice(i, 5);\r\n\r\n      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute(\"transform\"), gsap.core.getCache(target), _context());\r\n    }\r\n  }) : _savedStyles;\r\n};\r\n\r\nScrollTrigger.revert = function (soft, media) {\r\n  return _revertAll(!soft, media);\r\n};\r\n\r\nScrollTrigger.create = function (vars, animation) {\r\n  return new ScrollTrigger(vars, animation);\r\n};\r\n\r\nScrollTrigger.refresh = function (safe) {\r\n  return safe ? _onResize(true) : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);\r\n};\r\n\r\nScrollTrigger.update = function (force) {\r\n  return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === true ? 2 : 0);\r\n};\r\n\r\nScrollTrigger.clearScrollMemory = _clearScrollMemory;\r\n\r\nScrollTrigger.maxScroll = function (element, horizontal) {\r\n  return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\r\n};\r\n\r\nScrollTrigger.getScrollFunc = function (element, horizontal) {\r\n  return (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\r\n};\r\n\r\nScrollTrigger.getById = function (id) {\r\n  return _ids[id];\r\n};\r\n\r\nScrollTrigger.getAll = function () {\r\n  return _triggers.filter(function (t) {\r\n    return t.vars.id !== \"ScrollSmoother\";\r\n  });\r\n}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.\r\n\r\n\r\nScrollTrigger.isScrolling = function () {\r\n  return !!_lastScrollTime;\r\n};\r\n\r\nScrollTrigger.snapDirectional = _snapDirectional;\r\n\r\nScrollTrigger.addEventListener = function (type, callback) {\r\n  var a = _listeners[type] || (_listeners[type] = []);\r\n  ~a.indexOf(callback) || a.push(callback);\r\n};\r\n\r\nScrollTrigger.removeEventListener = function (type, callback) {\r\n  var a = _listeners[type],\r\n      i = a && a.indexOf(callback);\r\n  i >= 0 && a.splice(i, 1);\r\n};\r\n\r\nScrollTrigger.batch = function (targets, vars) {\r\n  var result = [],\r\n      varsCopy = {},\r\n      interval = vars.interval || 0.016,\r\n      batchMax = vars.batchMax || 1e9,\r\n      proxyCallback = function proxyCallback(type, callback) {\r\n    var elements = [],\r\n        triggers = [],\r\n        delay = gsap.delayedCall(interval, function () {\r\n      callback(elements, triggers);\r\n      elements = [];\r\n      triggers = [];\r\n    }).pause();\r\n    return function (self) {\r\n      elements.length || delay.restart(true);\r\n      elements.push(self.trigger);\r\n      triggers.push(self);\r\n      batchMax <= elements.length && delay.progress(1);\r\n    };\r\n  },\r\n      p;\r\n\r\n  for (p in vars) {\r\n    varsCopy[p] = p.substr(0, 2) === \"on\" && _isFunction(vars[p]) && p !== \"onRefreshInit\" ? proxyCallback(p, vars[p]) : vars[p];\r\n  }\r\n\r\n  if (_isFunction(batchMax)) {\r\n    batchMax = batchMax();\r\n\r\n    _addListener(ScrollTrigger, \"refresh\", function () {\r\n      return batchMax = vars.batchMax();\r\n    });\r\n  }\r\n\r\n  _toArray(targets).forEach(function (target) {\r\n    var config = {};\r\n\r\n    for (p in varsCopy) {\r\n      config[p] = varsCopy[p];\r\n    }\r\n\r\n    config.trigger = target;\r\n    result.push(ScrollTrigger.create(config));\r\n  });\r\n\r\n  return result;\r\n}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).\r\n\r\n\r\nvar _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {\r\n  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);\r\n  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;\r\n},\r\n    _allowNativePanning = function _allowNativePanning(target, direction) {\r\n  if (direction === true) {\r\n    target.style.removeProperty(\"touch-action\");\r\n  } else {\r\n    target.style.touchAction = direction === true ? \"auto\" : direction ? \"pan-\" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? \" pinch-zoom\" : \"\") : \"none\"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.\r\n  }\r\n\r\n  target === _docEl && _allowNativePanning(_body, direction);\r\n},\r\n    _overflow = {\r\n  auto: 1,\r\n  scroll: 1\r\n},\r\n    _nestedScroll = function _nestedScroll(_ref5) {\r\n  var event = _ref5.event,\r\n      target = _ref5.target,\r\n      axis = _ref5.axis;\r\n\r\n  var node = (event.changedTouches ? event.changedTouches[0] : event).target,\r\n      cache = node._gsap || gsap.core.getCache(node),\r\n      time = _getTime(),\r\n      cs;\r\n\r\n  if (!cache._isScrollT || time - cache._isScrollT > 2000) {\r\n    // cache for 2 seconds to improve performance.\r\n    while (node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {\r\n      node = node.parentNode;\r\n    }\r\n\r\n    cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);\r\n    cache._isScrollT = time;\r\n  }\r\n\r\n  if (cache._isScroll || axis === \"x\") {\r\n    event.stopPropagation();\r\n    event._gsapAllow = true;\r\n  }\r\n},\r\n    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor\r\n_inputObserver = function _inputObserver(target, type, inputs, nested) {\r\n  return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({\r\n    target: target,\r\n    capture: true,\r\n    debounce: false,\r\n    lockAxis: true,\r\n    type: type,\r\n    onWheel: nested = nested && _nestedScroll,\r\n    onPress: nested,\r\n    onDrag: nested,\r\n    onScroll: nested,\r\n    onEnable: function onEnable() {\r\n      return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, false, true);\r\n    },\r\n    onDisable: function onDisable() {\r\n      return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, true);\r\n    }\r\n  });\r\n},\r\n    _inputExp = /(input|label|select|textarea)/i,\r\n    _inputIsFocused,\r\n    _captureInputs = function _captureInputs(e) {\r\n  var isInput = _inputExp.test(e.target.tagName);\r\n\r\n  if (isInput || _inputIsFocused) {\r\n    e._gsapAllow = true;\r\n    _inputIsFocused = isInput;\r\n  }\r\n},\r\n    _getScrollNormalizer = function _getScrollNormalizer(vars) {\r\n  _isObject(vars) || (vars = {});\r\n  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;\r\n  vars.type || (vars.type = \"wheel,touch\");\r\n  vars.debounce = !!vars.debounce;\r\n  vars.id = vars.id || \"normalizer\";\r\n\r\n  var _vars2 = vars,\r\n      normalizeScrollX = _vars2.normalizeScrollX,\r\n      momentum = _vars2.momentum,\r\n      allowNestedScroll = _vars2.allowNestedScroll,\r\n      onRelease = _vars2.onRelease,\r\n      self,\r\n      maxY,\r\n      target = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl,\r\n      smoother = gsap.core.globals().ScrollSmoother,\r\n      smootherInstance = smoother && smoother.get(),\r\n      content = _fixIOSBug && (vars.content && (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== false && !smootherInstance.smooth() && smootherInstance.content()),\r\n      scrollFuncY = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),\r\n      scrollFuncX = (0,_Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal),\r\n      scale = 1,\r\n      initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,\r\n      wheelRefresh = 0,\r\n      resolveMomentumDuration = _isFunction(momentum) ? function () {\r\n    return momentum(self);\r\n  } : function () {\r\n    return momentum || 2.8;\r\n  },\r\n      lastRefreshID,\r\n      skipTouchMove,\r\n      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),\r\n      resumeTouchMove = function resumeTouchMove() {\r\n    return skipTouchMove = false;\r\n  },\r\n      scrollClampX = _passThrough,\r\n      scrollClampY = _passThrough,\r\n      updateClamps = function updateClamps() {\r\n    maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);\r\n    scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);\r\n    normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));\r\n    lastRefreshID = _refreshID;\r\n  },\r\n      removeContentOffset = function removeContentOffset() {\r\n    content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + \"px\";\r\n    content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + parseFloat(content._gsap.y) + \", 0, 1)\";\r\n    scrollFuncY.offset = scrollFuncY.cacheID = 0;\r\n  },\r\n      ignoreDrag = function ignoreDrag() {\r\n    if (skipTouchMove) {\r\n      requestAnimationFrame(resumeTouchMove);\r\n\r\n      var offset = _round(self.deltaY / 2),\r\n          scroll = scrollClampY(scrollFuncY.v - offset);\r\n\r\n      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {\r\n        scrollFuncY.offset = scroll - scrollFuncY.v;\r\n\r\n        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);\r\n\r\n        content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\r\n        content._gsap.y = y + \"px\";\r\n        scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;\r\n\r\n        _updateAll();\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    scrollFuncY.offset && removeContentOffset();\r\n    skipTouchMove = true;\r\n  },\r\n      tween,\r\n      startScrollX,\r\n      startScrollY,\r\n      onStopDelayedCall,\r\n      onResize = function onResize() {\r\n    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.\r\n    updateClamps();\r\n\r\n    if (tween.isActive() && tween.vars.scrollY > maxY) {\r\n      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo(\"scrollY\", maxY);\r\n    }\r\n  };\r\n\r\n  content && gsap.set(content, {\r\n    y: \"+=0\"\r\n  }); // to ensure there's a cache (element._gsap)\r\n\r\n  vars.ignoreCheck = function (e) {\r\n    return _fixIOSBug && e.type === \"touchmove\" && ignoreDrag(e) || scale > 1.05 && e.type !== \"touchstart\" || self.isGesturing || e.touches && e.touches.length > 1;\r\n  };\r\n\r\n  vars.onPress = function () {\r\n    skipTouchMove = false;\r\n    var prevScale = scale;\r\n    scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);\r\n    tween.pause();\r\n    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : \"x\");\r\n    startScrollX = scrollFuncX();\r\n    startScrollY = scrollFuncY();\r\n    updateClamps();\r\n    lastRefreshID = _refreshID;\r\n  };\r\n\r\n  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {\r\n    scrollFuncY.offset && removeContentOffset();\r\n\r\n    if (!wasDragging) {\r\n      onStopDelayedCall.restart(true);\r\n    } else {\r\n      _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++; // make sure we're pulling the non-cached value\r\n      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),\tdur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)\r\n\r\n      var dur = resolveMomentumDuration(),\r\n          currentScroll,\r\n          endScroll;\r\n\r\n      if (normalizeScrollX) {\r\n        currentScroll = scrollFuncX();\r\n        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.\r\n\r\n        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));\r\n        tween.vars.scrollX = scrollClampX(endScroll);\r\n      }\r\n\r\n      currentScroll = scrollFuncY();\r\n      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)\r\n\r\n      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));\r\n      tween.vars.scrollY = scrollClampY(endScroll);\r\n      tween.invalidate().duration(dur).play(0.01);\r\n\r\n      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {\r\n        // iOS bug: it'll show the address bar but NOT fire the window \"resize\" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.\r\n        gsap.to({}, {\r\n          onUpdate: onResize,\r\n          duration: dur\r\n        });\r\n      }\r\n    }\r\n\r\n    onRelease && onRelease(self);\r\n  };\r\n\r\n  vars.onWheel = function () {\r\n    tween._ts && tween.pause();\r\n\r\n    if (_getTime() - wheelRefresh > 1000) {\r\n      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.\r\n      lastRefreshID = 0;\r\n      wheelRefresh = _getTime();\r\n    }\r\n  };\r\n\r\n  vars.onChange = function (self, dx, dy, xArray, yArray) {\r\n    _refreshID !== lastRefreshID && updateClamps();\r\n    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.\r\n\r\n    if (dy) {\r\n      scrollFuncY.offset && removeContentOffset();\r\n      var isTouch = yArray[2] === dy,\r\n          y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],\r\n          yClamped = scrollClampY(y);\r\n      isTouch && y !== yClamped && (startScrollY += yClamped - y);\r\n      scrollFuncY(yClamped);\r\n    }\r\n\r\n    (dy || dx) && _updateAll();\r\n  };\r\n\r\n  vars.onEnable = function () {\r\n    _allowNativePanning(target, normalizeScrollX ? false : \"x\");\r\n\r\n    ScrollTrigger.addEventListener(\"refresh\", onResize);\r\n\r\n    _addListener(_win, \"resize\", onResize);\r\n\r\n    if (scrollFuncY.smooth) {\r\n      scrollFuncY.target.style.scrollBehavior = \"auto\";\r\n      scrollFuncY.smooth = scrollFuncX.smooth = false;\r\n    }\r\n\r\n    inputObserver.enable();\r\n  };\r\n\r\n  vars.onDisable = function () {\r\n    _allowNativePanning(target, true);\r\n\r\n    _removeListener(_win, \"resize\", onResize);\r\n\r\n    ScrollTrigger.removeEventListener(\"refresh\", onResize);\r\n    inputObserver.kill();\r\n  };\r\n\r\n  vars.lockAxis = vars.lockAxis !== false;\r\n  self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\r\n  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.\r\n\r\n  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.\r\n\r\n  _fixIOSBug && gsap.ticker.add(_passThrough); // prevent the ticker from sleeping\r\n\r\n  onStopDelayedCall = self._dc;\r\n  tween = gsap.to(self, {\r\n    ease: \"power4\",\r\n    paused: true,\r\n    inherit: false,\r\n    scrollX: normalizeScrollX ? \"+=0.1\" : \"+=0\",\r\n    scrollY: \"+=0.1\",\r\n    modifiers: {\r\n      scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function () {\r\n        return tween.pause();\r\n      })\r\n    },\r\n    onUpdate: _updateAll,\r\n    onComplete: onStopDelayedCall.vars.onComplete\r\n  }); // we need the modifier to sense if the scroll position is altered outside of the momentum tween (like with a scrollTo tween) so we can pause() it to prevent conflicts.\r\n\r\n  return self;\r\n};\r\n\r\nScrollTrigger.sort = function (func) {\r\n  if (_isFunction(func)) {\r\n    return _triggers.sort(func);\r\n  }\r\n\r\n  var scroll = _win.pageYOffset || 0;\r\n  ScrollTrigger.getAll().forEach(function (t) {\r\n    return t._sortY = t.trigger ? scroll + t.trigger.getBoundingClientRect().top : t.start + _win.innerHeight;\r\n  });\r\n  return _triggers.sort(func || function (a, b) {\r\n    return (a.vars.refreshPriority || 0) * -1e6 + (a.vars.containerAnimation ? 1e6 : a._sortY) - ((b.vars.containerAnimation ? 1e6 : b._sortY) + (b.vars.refreshPriority || 0) * -1e6);\r\n  }); // anything with a containerAnimation should refresh last.\r\n};\r\n\r\nScrollTrigger.observe = function (vars) {\r\n  return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);\r\n};\r\n\r\nScrollTrigger.normalizeScroll = function (vars) {\r\n  if (typeof vars === \"undefined\") {\r\n    return _normalizer;\r\n  }\r\n\r\n  if (vars === true && _normalizer) {\r\n    return _normalizer.enable();\r\n  }\r\n\r\n  if (vars === false) {\r\n    _normalizer && _normalizer.kill();\r\n    _normalizer = vars;\r\n    return;\r\n  }\r\n\r\n  var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);\r\n  _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();\r\n  _isViewport(normalizer.target) && (_normalizer = normalizer);\r\n  return normalizer;\r\n};\r\n\r\nScrollTrigger.core = {\r\n  // smaller file size way to leverage in ScrollSmoother and Observer\r\n  _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,\r\n  _inputObserver: _inputObserver,\r\n  _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,\r\n  _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,\r\n  bridge: {\r\n    // when normalizeScroll sets the scroll position (ss = setScroll)\r\n    ss: function ss() {\r\n      _lastScrollTime || _dispatch(\"scrollStart\");\r\n      _lastScrollTime = _getTime();\r\n    },\r\n    // a way to get the _refreshing value in Observer\r\n    ref: function ref() {\r\n      return _refreshing;\r\n    }\r\n  }\r\n};\r\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29KO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxTQUFTLDJEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUFhO0FBQzNCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5QkFBeUIsa0RBQVE7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJEQUFhO0FBQzlELENBQUM7QUFDRDtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1EQUFTO0FBQy9DLHVDQUF1QyxxREFBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUw7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQSxNQUFNLG9EQUFVO0FBQ2hCO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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eUI7QUFDekI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0EsYUFBYSxrREFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFnQjtBQUNwQztBQUNBLGNBQWMsb0RBQVU7QUFDeEIsWUFBWSxrREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGdzYXBcXFNjcm9sbFRyaWdnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqIFNjcm9sbFRyaWdnZXIgMy4xMy4wXHJcbiAqIGh0dHBzOi8vZ3NhcC5jb21cclxuICpcclxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dzYXAuY29tL3N0YW5kYXJkLWxpY2Vuc2VcclxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXHJcbiovXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG5pbXBvcnQgeyBPYnNlcnZlciwgX2dldFRhcmdldCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX3Njcm9sbGVycywgX3Byb3hpZXMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfZ2V0VmVsb2NpdHlQcm9wIH0gZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcclxuXHJcbnZhciBnc2FwLFxyXG4gICAgX2NvcmVJbml0dGVkLFxyXG4gICAgX3dpbixcclxuICAgIF9kb2MsXHJcbiAgICBfZG9jRWwsXHJcbiAgICBfYm9keSxcclxuICAgIF9yb290LFxyXG4gICAgX3Jlc2l6ZURlbGF5LFxyXG4gICAgX3RvQXJyYXksXHJcbiAgICBfY2xhbXAsXHJcbiAgICBfdGltZTIsXHJcbiAgICBfc3luY0ludGVydmFsLFxyXG4gICAgX3JlZnJlc2hpbmcsXHJcbiAgICBfcG9pbnRlcklzRG93bixcclxuICAgIF90cmFuc2Zvcm1Qcm9wLFxyXG4gICAgX2ksXHJcbiAgICBfcHJldldpZHRoLFxyXG4gICAgX3ByZXZIZWlnaHQsXHJcbiAgICBfYXV0b1JlZnJlc2gsXHJcbiAgICBfc29ydCxcclxuICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMsXHJcbiAgICBfaWdub3JlUmVzaXplLFxyXG4gICAgX25vcm1hbGl6ZXIsXHJcbiAgICBfaWdub3JlTW9iaWxlUmVzaXplLFxyXG4gICAgX2Jhc2VTY3JlZW5IZWlnaHQsXHJcbiAgICBfYmFzZVNjcmVlbldpZHRoLFxyXG4gICAgX2ZpeElPU0J1ZyxcclxuICAgIF9jb250ZXh0LFxyXG4gICAgX3Njcm9sbFJlc3RvcmF0aW9uLFxyXG4gICAgX2RpdjEwMHZoLFxyXG4gICAgXzEwMHZoLFxyXG4gICAgX2lzUmV2ZXJ0ZWQsXHJcbiAgICBfY2xhbXBpbmdNYXgsXHJcbiAgICBfbGltaXRDYWxsYmFja3MsXHJcbiAgICAvLyBpZiB0cnVlLCB3ZSdsbCBvbmx5IHRyaWdnZXIgY2FsbGJhY2tzIGlmIHRoZSBhY3RpdmUgc3RhdGUgdG9nZ2xlcywgc28gaWYgeW91IHNjcm9sbCBpbW1lZGlhdGVseSBwYXN0IGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIGEgU2Nyb2xsVHJpZ2dlciAodGh1cyBpbmFjdGl2ZSB0byBpbmFjdGl2ZSksIG5laXRoZXIgaXRzIG9uRW50ZXIgbm9yIG9uTGVhdmUgd2lsbCBiZSBjYWxsZWQuIFRoaXMgaXMgdXNlZnVsIGR1cmluZyBzdGFydHVwLlxyXG5fc3RhcnR1cCA9IDEsXHJcbiAgICBfZ2V0VGltZSA9IERhdGUubm93LFxyXG4gICAgX3RpbWUxID0gX2dldFRpbWUoKSxcclxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXHJcbiAgICBfZW5hYmxlZCA9IDAsXHJcbiAgICBfcGFyc2VDbGFtcCA9IGZ1bmN0aW9uIF9wYXJzZUNsYW1wKHZhbHVlLCB0eXBlLCBzZWxmKSB7XHJcbiAgdmFyIGNsYW1wID0gX2lzU3RyaW5nKHZhbHVlKSAmJiAodmFsdWUuc3Vic3RyKDAsIDYpID09PSBcImNsYW1wKFwiIHx8IHZhbHVlLmluZGV4T2YoXCJtYXhcIikgPiAtMSk7XHJcbiAgc2VsZltcIl9cIiArIHR5cGUgKyBcIkNsYW1wXCJdID0gY2xhbXA7XHJcbiAgcmV0dXJuIGNsYW1wID8gdmFsdWUuc3Vic3RyKDYsIHZhbHVlLmxlbmd0aCAtIDcpIDogdmFsdWU7XHJcbn0sXHJcbiAgICBfa2VlcENsYW1wID0gZnVuY3Rpb24gX2tlZXBDbGFtcCh2YWx1ZSwgY2xhbXApIHtcclxuICByZXR1cm4gY2xhbXAgJiYgKCFfaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlLnN1YnN0cigwLCA2KSAhPT0gXCJjbGFtcChcIikgPyBcImNsYW1wKFwiICsgdmFsdWUgKyBcIilcIiA6IHZhbHVlO1xyXG59LFxyXG4gICAgX3JhZkJ1Z0ZpeCA9IGZ1bmN0aW9uIF9yYWZCdWdGaXgoKSB7XHJcbiAgcmV0dXJuIF9lbmFibGVkICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZShfcmFmQnVnRml4KTtcclxufSxcclxuICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCksIHNjcmVlbiByZXBhaW50cyB3ZXJlbid0IGNvbnNpc3RlbnQgdW5sZXNzIHdlIGhhZCBTT01FVEhJTkcgcXVldWVkIHVwIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpISBTbyB0aGlzIGp1c3QgY3JlYXRlcyBhIHN1cGVyIHNpbXBsZSBsb29wIHRvIGtlZXAgaXQgYWxpdmUgYW5kIHNtb290aCBvdXQgcmVwYWludHMuXHJcbl9wb2ludGVyRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlckRvd25IYW5kbGVyKCkge1xyXG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDE7XHJcbn0sXHJcbiAgICBfcG9pbnRlclVwSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyVXBIYW5kbGVyKCkge1xyXG4gIHJldHVybiBfcG9pbnRlcklzRG93biA9IDA7XHJcbn0sXHJcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xyXG4gIHJldHVybiB2O1xyXG59LFxyXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XHJcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XHJcbn0sXHJcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcclxuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcclxufSxcclxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XHJcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcclxufSxcclxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xyXG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGUpO1xyXG59LFxyXG4gICAgX2dldFZpZXdwb3J0RGltZW5zaW9uID0gZnVuY3Rpb24gX2dldFZpZXdwb3J0RGltZW5zaW9uKGRpbWVuc2lvblByb3BlcnR5KSB7XHJcbiAgcmV0dXJuIChkaW1lbnNpb25Qcm9wZXJ0eSA9PT0gXCJIZWlnaHRcIiA/IF8xMDB2aCA6IF93aW5bXCJpbm5lclwiICsgZGltZW5zaW9uUHJvcGVydHldKSB8fCBfZG9jRWxbXCJjbGllbnRcIiArIGRpbWVuc2lvblByb3BlcnR5XSB8fCBfYm9keVtcImNsaWVudFwiICsgZGltZW5zaW9uUHJvcGVydHldO1xyXG59LFxyXG4gICAgX2dldEJvdW5kc0Z1bmMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSB7XHJcbiAgcmV0dXJuIF9nZXRQcm94eVByb3AoZWxlbWVudCwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gZnVuY3Rpb24gKCkge1xyXG4gICAgX3dpbk9mZnNldHMud2lkdGggPSBfd2luLmlubmVyV2lkdGg7XHJcbiAgICBfd2luT2Zmc2V0cy5oZWlnaHQgPSBfMTAwdmg7XHJcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XHJcbiAgfSA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xyXG4gIH0pO1xyXG59LFxyXG4gICAgX2dldFNpemVGdW5jID0gZnVuY3Rpb24gX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBfcmVmKSB7XHJcbiAgdmFyIGQgPSBfcmVmLmQsXHJcbiAgICAgIGQyID0gX3JlZi5kMixcclxuICAgICAgYSA9IF9yZWYuYTtcclxuICByZXR1cm4gKGEgPSBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKSkgPyBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gYSgpW2RdO1xyXG4gIH0gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKGlzVmlld3BvcnQgPyBfZ2V0Vmlld3BvcnREaW1lbnNpb24oZDIpIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcclxuICB9O1xyXG59LFxyXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcclxuICByZXR1cm4gIWlzVmlld3BvcnQgfHwgfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgPyBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfd2luT2Zmc2V0cztcclxuICB9O1xyXG59LFxyXG4gICAgX21heFNjcm9sbCA9IGZ1bmN0aW9uIF9tYXhTY3JvbGwoZWxlbWVudCwgX3JlZjIpIHtcclxuICB2YXIgcyA9IF9yZWYyLnMsXHJcbiAgICAgIGQyID0gX3JlZjIuZDIsXHJcbiAgICAgIGQgPSBfcmVmMi5kLFxyXG4gICAgICBhID0gX3JlZjIuYTtcclxuICByZXR1cm4gTWF0aC5tYXgoMCwgKHMgPSBcInNjcm9sbFwiICsgZDIpICYmIChhID0gX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSkgPyBhKCkgLSBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSgpW2RdIDogX2lzVmlld3BvcnQoZWxlbWVudCkgPyAoX2RvY0VsW3NdIHx8IF9ib2R5W3NdKSAtIF9nZXRWaWV3cG9ydERpbWVuc2lvbihkMikgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdKTtcclxufSxcclxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2ggPSBmdW5jdGlvbiBfaXRlcmF0ZUF1dG9SZWZyZXNoKGZ1bmMsIGV2ZW50cykge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX2F1dG9SZWZyZXNoLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcclxuICB9XHJcbn0sXHJcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG59LFxyXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcclxufSxcclxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbn0sXHJcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xyXG59LFxyXG4gICAgX2VuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCByZXZlcnNlZCwgcGF1c2UpIHtcclxuICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhyZXZlcnNlZCA/IDAgOiAxKSAmJiBwYXVzZSAmJiBhbmltYXRpb24ucGF1c2UoKTtcclxufSxcclxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhzZWxmLCBmdW5jKSB7XHJcbiAgaWYgKHNlbGYuZW5hYmxlZCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHNlbGYuX2N0eCA/IHNlbGYuX2N0eC5hZGQoZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gZnVuYyhzZWxmKTtcclxuICAgIH0pIDogZnVuYyhzZWxmKTtcclxuICAgIHJlc3VsdCAmJiByZXN1bHQudG90YWxUaW1lICYmIChzZWxmLmNhbGxiYWNrQW5pbWF0aW9uID0gcmVzdWx0KTtcclxuICB9XHJcbn0sXHJcbiAgICBfYWJzID0gTWF0aC5hYnMsXHJcbiAgICBfbGVmdCA9IFwibGVmdFwiLFxyXG4gICAgX3RvcCA9IFwidG9wXCIsXHJcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXHJcbiAgICBfYm90dG9tID0gXCJib3R0b21cIixcclxuICAgIF93aWR0aCA9IFwid2lkdGhcIixcclxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxyXG4gICAgX1JpZ2h0ID0gXCJSaWdodFwiLFxyXG4gICAgX0xlZnQgPSBcIkxlZnRcIixcclxuICAgIF9Ub3AgPSBcIlRvcFwiLFxyXG4gICAgX0JvdHRvbSA9IFwiQm90dG9tXCIsXHJcbiAgICBfcGFkZGluZyA9IFwicGFkZGluZ1wiLFxyXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXHJcbiAgICBfV2lkdGggPSBcIldpZHRoXCIsXHJcbiAgICBfSGVpZ2h0ID0gXCJIZWlnaHRcIixcclxuICAgIF9weCA9IFwicHhcIixcclxuICAgIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xyXG4gIHJldHVybiBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbn0sXHJcbiAgICBfbWFrZVBvc2l0aW9uYWJsZSA9IGZ1bmN0aW9uIF9tYWtlUG9zaXRpb25hYmxlKGVsZW1lbnQpIHtcclxuICAvLyBpZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBwb3NpdGlvbjogYWJzb2x1dGUgb3IgZml4ZWQsIGxlYXZlIHRoYXQsIG90aGVyd2lzZSBtYWtlIGl0IHBvc2l0aW9uOiByZWxhdGl2ZVxyXG4gIHZhciBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xyXG5cclxuICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gcG9zaXRpb24gOiBcInJlbGF0aXZlXCI7XHJcbn0sXHJcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xyXG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcclxuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59LFxyXG4gICAgX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHMoZWxlbWVudCwgd2l0aG91dFRyYW5zZm9ybXMpIHtcclxuICB2YXIgdHdlZW4gPSB3aXRob3V0VHJhbnNmb3JtcyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gIT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgJiYgZ3NhcC50byhlbGVtZW50LCB7XHJcbiAgICB4OiAwLFxyXG4gICAgeTogMCxcclxuICAgIHhQZXJjZW50OiAwLFxyXG4gICAgeVBlcmNlbnQ6IDAsXHJcbiAgICByb3RhdGlvbjogMCxcclxuICAgIHJvdGF0aW9uWDogMCxcclxuICAgIHJvdGF0aW9uWTogMCxcclxuICAgIHNjYWxlOiAxLFxyXG4gICAgc2tld1g6IDAsXHJcbiAgICBza2V3WTogMFxyXG4gIH0pLnByb2dyZXNzKDEpLFxyXG4gICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHR3ZWVuICYmIHR3ZWVuLnByb2dyZXNzKDApLmtpbGwoKTtcclxuICByZXR1cm4gYm91bmRzO1xyXG59LFxyXG4gICAgX2dldFNpemUgPSBmdW5jdGlvbiBfZ2V0U2l6ZShlbGVtZW50LCBfcmVmMykge1xyXG4gIHZhciBkMiA9IF9yZWYzLmQyO1xyXG4gIHJldHVybiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDA7XHJcbn0sXHJcbiAgICBfZ2V0TGFiZWxSYXRpb0FycmF5ID0gZnVuY3Rpb24gX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkge1xyXG4gIHZhciBhID0gW10sXHJcbiAgICAgIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcclxuICAgICAgZHVyYXRpb24gPSB0aW1lbGluZS5kdXJhdGlvbigpLFxyXG4gICAgICBwO1xyXG5cclxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XHJcbiAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGE7XHJcbn0sXHJcbiAgICBfZ2V0Q2xvc2VzdExhYmVsID0gZnVuY3Rpb24gX2dldENsb3Nlc3RMYWJlbChhbmltYXRpb24pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZ3NhcC51dGlscy5zbmFwKF9nZXRMYWJlbFJhdGlvQXJyYXkoYW5pbWF0aW9uKSwgdmFsdWUpO1xyXG4gIH07XHJcbn0sXHJcbiAgICBfc25hcERpcmVjdGlvbmFsID0gZnVuY3Rpb24gX3NuYXBEaXJlY3Rpb25hbChzbmFwSW5jcmVtZW50T3JBcnJheSkge1xyXG4gIHZhciBzbmFwID0gZ3NhcC51dGlscy5zbmFwKHNuYXBJbmNyZW1lbnRPckFycmF5KSxcclxuICAgICAgYSA9IEFycmF5LmlzQXJyYXkoc25hcEluY3JlbWVudE9yQXJyYXkpICYmIHNuYXBJbmNyZW1lbnRPckFycmF5LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxuICB9KTtcclxuICByZXR1cm4gYSA/IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcclxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xyXG4gICAgICB0aHJlc2hvbGQgPSAxZS0zO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpO1xyXG5cclxuICAgIGlmICghZGlyZWN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBzbmFwKHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xyXG4gICAgICB2YWx1ZSAtPSB0aHJlc2hvbGQ7IC8vIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy4gSWYgd2UncmUgdG9vIHN0cmljdCwgaXQgbWlnaHQgc25hcCBmb3J3YXJkLCB0aGVuIGltbWVkaWF0ZWx5IGFnYWluLCBhbmQgYWdhaW4uXHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhW2ldID49IHZhbHVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gYVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhW2kgLSAxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgPSBhLmxlbmd0aDtcclxuICAgICAgdmFsdWUgKz0gdGhyZXNob2xkO1xyXG5cclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChhW2ldIDw9IHZhbHVlKSB7XHJcbiAgICAgICAgICByZXR1cm4gYVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYVswXTtcclxuICB9IDogZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xyXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNuYXBwZWQgPSBzbmFwKHZhbHVlKTtcclxuICAgIHJldHVybiAhZGlyZWN0aW9uIHx8IE1hdGguYWJzKHNuYXBwZWQgLSB2YWx1ZSkgPCB0aHJlc2hvbGQgfHwgc25hcHBlZCAtIHZhbHVlIDwgMCA9PT0gZGlyZWN0aW9uIDwgMCA/IHNuYXBwZWQgOiBzbmFwKGRpcmVjdGlvbiA8IDAgPyB2YWx1ZSAtIHNuYXBJbmNyZW1lbnRPckFycmF5IDogdmFsdWUgKyBzbmFwSW5jcmVtZW50T3JBcnJheSk7XHJcbiAgfTtcclxufSxcclxuICAgIF9nZXRMYWJlbEF0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsQXREaXJlY3Rpb24odGltZWxpbmUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xyXG4gICAgcmV0dXJuIF9zbmFwRGlyZWN0aW9uYWwoX2dldExhYmVsUmF0aW9BcnJheSh0aW1lbGluZSkpKHZhbHVlLCBzdC5kaXJlY3Rpb24pO1xyXG4gIH07XHJcbn0sXHJcbiAgICBfbXVsdGlMaXN0ZW5lciA9IGZ1bmN0aW9uIF9tdWx0aUxpc3RlbmVyKGZ1bmMsIGVsZW1lbnQsIHR5cGVzLCBjYWxsYmFjaykge1xyXG4gIHJldHVybiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgcmV0dXJuIGZ1bmMoZWxlbWVudCwgdHlwZSwgY2FsbGJhY2spO1xyXG4gIH0pO1xyXG59LFxyXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIG5vblBhc3NpdmUsIGNhcHR1cmUpIHtcclxuICByZXR1cm4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIHtcclxuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxyXG4gICAgY2FwdHVyZTogISFjYXB0dXJlXHJcbiAgfSk7XHJcbn0sXHJcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xyXG4gIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgISFjYXB0dXJlKTtcclxufSxcclxuICAgIF93aGVlbExpc3RlbmVyID0gZnVuY3Rpb24gX3doZWVsTGlzdGVuZXIoZnVuYywgZWwsIHNjcm9sbEZ1bmMpIHtcclxuICBzY3JvbGxGdW5jID0gc2Nyb2xsRnVuYyAmJiBzY3JvbGxGdW5jLndoZWVsSGFuZGxlcjtcclxuXHJcbiAgaWYgKHNjcm9sbEZ1bmMpIHtcclxuICAgIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XHJcbiAgICBmdW5jKGVsLCBcInRvdWNobW92ZVwiLCBzY3JvbGxGdW5jKTtcclxuICB9XHJcbn0sXHJcbiAgICBfbWFya2VyRGVmYXVsdHMgPSB7XHJcbiAgc3RhcnRDb2xvcjogXCJncmVlblwiLFxyXG4gIGVuZENvbG9yOiBcInJlZFwiLFxyXG4gIGluZGVudDogMCxcclxuICBmb250U2l6ZTogXCIxNnB4XCIsXHJcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIlxyXG59LFxyXG4gICAgX2RlZmF1bHRzID0ge1xyXG4gIHRvZ2dsZUFjdGlvbnM6IFwicGxheVwiLFxyXG4gIGFudGljaXBhdGVQaW46IDBcclxufSxcclxuICAgIF9rZXl3b3JkcyA9IHtcclxuICB0b3A6IDAsXHJcbiAgbGVmdDogMCxcclxuICBjZW50ZXI6IDAuNSxcclxuICBib3R0b206IDEsXHJcbiAgcmlnaHQ6IDFcclxufSxcclxuICAgIF9vZmZzZXRUb1B4ID0gZnVuY3Rpb24gX29mZnNldFRvUHgodmFsdWUsIHNpemUpIHtcclxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgdmFyIGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcclxuICAgICAgICByZWxhdGl2ZSA9IH5lcUluZGV4ID8gKyh2YWx1ZS5jaGFyQXQoZXFJbmRleCAtIDEpICsgMSkgKiBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cihlcUluZGV4ICsgMSkpIDogMDtcclxuXHJcbiAgICBpZiAofmVxSW5kZXgpIHtcclxuICAgICAgdmFsdWUuaW5kZXhPZihcIiVcIikgPiBlcUluZGV4ICYmIChyZWxhdGl2ZSAqPSBzaXplIC8gMTAwKTtcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleCAtIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlID0gcmVsYXRpdmUgKyAodmFsdWUgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3ZhbHVlXSAqIHNpemUgOiB+dmFsdWUuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWx1ZTtcclxufSxcclxuICAgIF9jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiBfY3JlYXRlTWFya2VyKHR5cGUsIG5hbWUsIGNvbnRhaW5lciwgZGlyZWN0aW9uLCBfcmVmNCwgb2Zmc2V0LCBtYXRjaFdpZHRoRWwsIGNvbnRhaW5lckFuaW1hdGlvbikge1xyXG4gIHZhciBzdGFydENvbG9yID0gX3JlZjQuc3RhcnRDb2xvcixcclxuICAgICAgZW5kQ29sb3IgPSBfcmVmNC5lbmRDb2xvcixcclxuICAgICAgZm9udFNpemUgPSBfcmVmNC5mb250U2l6ZSxcclxuICAgICAgaW5kZW50ID0gX3JlZjQuaW5kZW50LFxyXG4gICAgICBmb250V2VpZ2h0ID0gX3JlZjQuZm9udFdlaWdodDtcclxuXHJcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXHJcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBfaXNWaWV3cG9ydChjb250YWluZXIpIHx8IF9nZXRQcm94eVByb3AoY29udGFpbmVyLCBcInBpblR5cGVcIikgPT09IFwiZml4ZWRcIixcclxuICAgICAgaXNTY3JvbGxlciA9IHR5cGUuaW5kZXhPZihcInNjcm9sbGVyXCIpICE9PSAtMSxcclxuICAgICAgcGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxyXG4gICAgICBpc1N0YXJ0ID0gdHlwZS5pbmRleE9mKFwic3RhcnRcIikgIT09IC0xLFxyXG4gICAgICBjb2xvciA9IGlzU3RhcnQgPyBzdGFydENvbG9yIDogZW5kQ29sb3IsXHJcbiAgICAgIGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xyXG5cclxuICBjc3MgKz0gXCJwb3NpdGlvbjpcIiArICgoaXNTY3JvbGxlciB8fCBjb250YWluZXJBbmltYXRpb24pICYmIHVzZUZpeGVkUG9zaXRpb24gPyBcImZpeGVkO1wiIDogXCJhYnNvbHV0ZTtcIik7XHJcbiAgKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8ICF1c2VGaXhlZFBvc2l0aW9uKSAmJiAoY3NzICs9IChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9yaWdodCA6IF9ib3R0b20pICsgXCI6XCIgKyAob2Zmc2V0ICsgcGFyc2VGbG9hdChpbmRlbnQpKSArIFwicHg7XCIpO1xyXG4gIG1hdGNoV2lkdGhFbCAmJiAoY3NzICs9IFwiYm94LXNpemluZzpib3JkZXItYm94O3RleHQtYWxpZ246bGVmdDt3aWR0aDpcIiArIG1hdGNoV2lkdGhFbC5vZmZzZXRXaWR0aCArIFwicHg7XCIpO1xyXG4gIGUuX2lzU3RhcnQgPSBpc1N0YXJ0O1xyXG4gIGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJnc2FwLW1hcmtlci1cIiArIHR5cGUgKyAobmFtZSA/IFwiIG1hcmtlci1cIiArIG5hbWUgOiBcIlwiKSk7XHJcbiAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzO1xyXG4gIGUuaW5uZXJUZXh0ID0gbmFtZSB8fCBuYW1lID09PSAwID8gdHlwZSArIFwiLVwiICsgbmFtZSA6IHR5cGU7XHJcbiAgcGFyZW50LmNoaWxkcmVuWzBdID8gcGFyZW50Lmluc2VydEJlZm9yZShlLCBwYXJlbnQuY2hpbGRyZW5bMF0pIDogcGFyZW50LmFwcGVuZENoaWxkKGUpO1xyXG4gIGUuX29mZnNldCA9IGVbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XHJcblxyXG4gIF9wb3NpdGlvbk1hcmtlcihlLCAwLCBkaXJlY3Rpb24sIGlzU3RhcnQpO1xyXG5cclxuICByZXR1cm4gZTtcclxufSxcclxuICAgIF9wb3NpdGlvbk1hcmtlciA9IGZ1bmN0aW9uIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHN0YXJ0LCBkaXJlY3Rpb24sIGZsaXBwZWQpIHtcclxuICB2YXIgdmFycyA9IHtcclxuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxyXG4gIH0sXHJcbiAgICAgIHNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwib3MyXCIgOiBcInAyXCJdLFxyXG4gICAgICBvcHBvc2l0ZVNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwicDJcIiA6IFwib3MyXCJdO1xyXG4gIG1hcmtlci5faXNGbGlwcGVkID0gZmxpcHBlZDtcclxuICB2YXJzW2RpcmVjdGlvbi5hICsgXCJQZXJjZW50XCJdID0gZmxpcHBlZCA/IC0xMDAgOiAwO1xyXG4gIHZhcnNbZGlyZWN0aW9uLmFdID0gZmxpcHBlZCA/IFwiMXB4XCIgOiAwO1xyXG4gIHZhcnNbXCJib3JkZXJcIiArIHNpZGUgKyBfV2lkdGhdID0gMTtcclxuICB2YXJzW1wiYm9yZGVyXCIgKyBvcHBvc2l0ZVNpZGUgKyBfV2lkdGhdID0gMDtcclxuICB2YXJzW2RpcmVjdGlvbi5wXSA9IHN0YXJ0ICsgXCJweFwiO1xyXG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XHJcbn0sXHJcbiAgICBfdHJpZ2dlcnMgPSBbXSxcclxuICAgIF9pZHMgPSB7fSxcclxuICAgIF9yYWZJRCxcclxuICAgIF9zeW5jID0gZnVuY3Rpb24gX3N5bmMoKSB7XHJcbiAgcmV0dXJuIF9nZXRUaW1lKCkgLSBfbGFzdFNjcm9sbFRpbWUgPiAzNCAmJiAoX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpKTtcclxufSxcclxuICAgIF9vblNjcm9sbCA9IGZ1bmN0aW9uIF9vblNjcm9sbCgpIHtcclxuICAvLyBwcmV2aW91c2x5LCB3ZSB0cmllZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZy9kZWZlcnJpbmcgdG8gdGhlIG5leHQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCksIGJ1dCBkaXNjb3ZlcmVkIHRoYXQgU2FmYXJpIGhhcyBhIGZldyBidWdzIHRoYXQgbWFrZSB0aGlzIHVud29ya2FibGUgKGVzcGVjaWFsbHkgb24gaU9TKS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzE2YzQzNWIxMmVmMDljMzgxMjUyMDQ4MThlN2I0NWZjP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vSmpPeFlwUS8zZGQ2NWNjZWM1YTYwZjFkODYyYzM1NWQ4NGQxNDU2Mj9lZGl0b3JzPTAwMTAgYW5kIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuL0V4YnJQTmEvMDg3Y2VmMTk3ZGMzNTQ0NWEwOTUxZTg5MzVjNDE1MDM/ZWRpdG9ycz0wMDEwXHJcbiAgaWYgKCFfbm9ybWFsaXplciB8fCAhX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9ub3JtYWxpemVyLnN0YXJ0WCA+IF9ib2R5LmNsaWVudFdpZHRoKSB7XHJcbiAgICAvLyBpZiB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgc2Nyb2xsYmFyLCBhbGxvdyBpdC5cclxuICAgIF9zY3JvbGxlcnMuY2FjaGUrKztcclxuXHJcbiAgICBpZiAoX25vcm1hbGl6ZXIpIHtcclxuICAgICAgX3JhZklEIHx8IChfcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3VwZGF0ZUFsbCkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3VwZGF0ZUFsbCgpOyAvLyBTYWZhcmkgaW4gcGFydGljdWxhciAob24gZGVza3RvcCkgTkVFRFMgdGhlIGltbWVkaWF0ZSB1cGRhdGUgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB3aGVyZWFzIGlPUyBzZWVtcyB0byBiZW5lZml0IGZyb20gd2FpdGluZyBmb3IgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHRpY2ssIGF0IGxlYXN0IHdoZW4gbm9ybWFsaXppbmcuIFNlZSBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9xQllvenFPP2VkaXRvcnM9MDExMFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XHJcbiAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xyXG4gIH1cclxufSxcclxuICAgIF9zZXRCYXNlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIF9zZXRCYXNlRGltZW5zaW9ucygpIHtcclxuICBfYmFzZVNjcmVlbldpZHRoID0gX3dpbi5pbm5lcldpZHRoO1xyXG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcclxufSxcclxuICAgIF9vblJlc2l6ZSA9IGZ1bmN0aW9uIF9vblJlc2l6ZShmb3JjZSkge1xyXG4gIF9zY3JvbGxlcnMuY2FjaGUrKztcclxuICAoZm9yY2UgPT09IHRydWUgfHwgIV9yZWZyZXNoaW5nICYmICFfaWdub3JlUmVzaXplICYmICFfZG9jLmZ1bGxzY3JlZW5FbGVtZW50ICYmICFfZG9jLndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ICYmICghX2lnbm9yZU1vYmlsZVJlc2l6ZSB8fCBfYmFzZVNjcmVlbldpZHRoICE9PSBfd2luLmlubmVyV2lkdGggfHwgTWF0aC5hYnMoX3dpbi5pbm5lckhlaWdodCAtIF9iYXNlU2NyZWVuSGVpZ2h0KSA+IF93aW4uaW5uZXJIZWlnaHQgKiAwLjI1KSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XHJcbn0sXHJcbiAgICAvLyBpZ25vcmUgcmVzaXplcyB0cmlnZ2VyZWQgYnkgcmVmcmVzaCgpXHJcbl9saXN0ZW5lcnMgPSB7fSxcclxuICAgIF9lbXB0eUFycmF5ID0gW10sXHJcbiAgICBfc29mdFJlZnJlc2ggPSBmdW5jdGlvbiBfc29mdFJlZnJlc2goKSB7XHJcbiAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpIHx8IF9yZWZyZXNoQWxsKHRydWUpO1xyXG59LFxyXG4gICAgX2Rpc3BhdGNoID0gZnVuY3Rpb24gX2Rpc3BhdGNoKHR5cGUpIHtcclxuICByZXR1cm4gX2xpc3RlbmVyc1t0eXBlXSAmJiBfbGlzdGVuZXJzW3R5cGVdLm1hcChmdW5jdGlvbiAoZikge1xyXG4gICAgcmV0dXJuIGYoKTtcclxuICB9KSB8fCBfZW1wdHlBcnJheTtcclxufSxcclxuICAgIF9zYXZlZFN0eWxlcyA9IFtdLFxyXG4gICAgLy8gd2hlbiBTY3JvbGxUcmlnZ2VyLnNhdmVTdHlsZXMoKSBpcyBjYWxsZWQsIHRoZSBpbmxpbmUgc3R5bGVzIGFyZSByZWNvcmRlZCBpbiB0aGlzIEFycmF5IGluIGEgc2VxdWVudGlhbCBmb3JtYXQgbGlrZSBbZWxlbWVudCwgY3NzVGV4dCwgZ3NDYWNoZSwgbWVkaWFdLiBUaGlzIGtlZXBzIGl0IHZlcnkgbWVtb3J5LWVmZmljaWVudCBhbmQgZmFzdCB0byBpdGVyYXRlIHRocm91Z2guXHJcbl9yZXZlcnRSZWNvcmRlZCA9IGZ1bmN0aW9uIF9yZXZlcnRSZWNvcmRlZChtZWRpYSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSArPSA1KSB7XHJcbiAgICBpZiAoIW1lZGlhIHx8IF9zYXZlZFN0eWxlc1tpICsgNF0gJiYgX3NhdmVkU3R5bGVzW2kgKyA0XS5xdWVyeSA9PT0gbWVkaWEpIHtcclxuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xyXG4gICAgICBfc2F2ZWRTdHlsZXNbaV0uZ2V0QkJveCAmJiBfc2F2ZWRTdHlsZXNbaV0uc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIF9zYXZlZFN0eWxlc1tpICsgMl0gfHwgXCJcIik7XHJcbiAgICAgIF9zYXZlZFN0eWxlc1tpICsgM10udW5jYWNoZSA9IDE7XHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcclxuICB2YXIgdHJpZ2dlcjtcclxuXHJcbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xyXG4gICAgdHJpZ2dlciA9IF90cmlnZ2Vyc1tfaV07XHJcblxyXG4gICAgaWYgKHRyaWdnZXIgJiYgKCFtZWRpYSB8fCB0cmlnZ2VyLl9jdHggPT09IG1lZGlhKSkge1xyXG4gICAgICBpZiAoa2lsbCkge1xyXG4gICAgICAgIHRyaWdnZXIua2lsbCgxKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0cmlnZ2VyLnJldmVydCh0cnVlLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2lzUmV2ZXJ0ZWQgPSB0cnVlO1xyXG4gIG1lZGlhICYmIF9yZXZlcnRSZWNvcmRlZChtZWRpYSk7XHJcbiAgbWVkaWEgfHwgX2Rpc3BhdGNoKFwicmV2ZXJ0XCIpO1xyXG59LFxyXG4gICAgX2NsZWFyU2Nyb2xsTWVtb3J5ID0gZnVuY3Rpb24gX2NsZWFyU2Nyb2xsTWVtb3J5KHNjcm9sbFJlc3RvcmF0aW9uLCBmb3JjZSkge1xyXG4gIC8vIHplcm8tb3V0IGFsbCB0aGUgcmVjb3JkZWQgc2Nyb2xsIHBvc2l0aW9ucy4gRG9uJ3QgdXNlIF90cmlnZ2VycyBiZWNhdXNlIGlmLCBmb3IgZXhhbXBsZSwgLm1hdGNoTWVkaWEoKSBpcyB1c2VkIHRvIGNyZWF0ZSBzb21lIFNjcm9sbFRyaWdnZXJzIGFuZCB0aGVuIHRoZSB1c2VyIHJlc2l6ZXMgYW5kIGl0IHJlbW92ZXMgQUxMIFNjcm9sbFRyaWdnZXJzLCBhbmQgdGhlbiBnbyBiYWNrIHRvIGEgc2l6ZSB3aGVyZSB0aGVyZSBhcmUgU2Nyb2xsVHJpZ2dlcnMsIGl0IHdvdWxkIGhhdmUga2VwdCB0aGUgcG9zaXRpb24ocykgc2F2ZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICBfc2Nyb2xsZXJzLmNhY2hlKys7XHJcbiAgKGZvcmNlIHx8ICFfcmVmcmVzaGluZ0FsbCkgJiYgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBfaXNGdW5jdGlvbihvYmopICYmIG9iai5jYWNoZUlEKysgJiYgKG9iai5yZWMgPSAwKTtcclxuICB9KTtcclxuICBfaXNTdHJpbmcoc2Nyb2xsUmVzdG9yYXRpb24pICYmIChfd2luLmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBfc2Nyb2xsUmVzdG9yYXRpb24gPSBzY3JvbGxSZXN0b3JhdGlvbik7XHJcbn0sXHJcbiAgICBfcmVmcmVzaGluZ0FsbCxcclxuICAgIF9yZWZyZXNoSUQgPSAwLFxyXG4gICAgX3F1ZXVlUmVmcmVzaElELFxyXG4gICAgX3F1ZXVlUmVmcmVzaEFsbCA9IGZ1bmN0aW9uIF9xdWV1ZVJlZnJlc2hBbGwoKSB7XHJcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWxsIF9yZWZyZXNoQWxsKCkgZXZlcnkgdGltZSB3ZSBjcmVhdGUgYSBuZXcgU2Nyb2xsVHJpZ2dlciAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpIC0gaXQncyBiZXR0ZXIgdG8gYmF0Y2ggdGhlbS4gU29tZSBmcmFtZXdvcmtzIGR5bmFtaWNhbGx5IGxvYWQgY29udGVudCBhbmQgd2UgY2FuJ3QgcmVseSBvbiB0aGUgd2luZG93J3MgXCJsb2FkXCIgb3IgXCJET01Db250ZW50TG9hZGVkXCIgZXZlbnRzIHRvIHRyaWdnZXIgaXQuXHJcbiAgaWYgKF9xdWV1ZVJlZnJlc2hJRCAhPT0gX3JlZnJlc2hJRCkge1xyXG4gICAgdmFyIGlkID0gX3F1ZXVlUmVmcmVzaElEID0gX3JlZnJlc2hJRDtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBpZCA9PT0gX3JlZnJlc2hJRCAmJiBfcmVmcmVzaEFsbCh0cnVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxufSxcclxuICAgIF9yZWZyZXNoMTAwdmggPSBmdW5jdGlvbiBfcmVmcmVzaDEwMHZoKCkge1xyXG4gIF9ib2R5LmFwcGVuZENoaWxkKF9kaXYxMDB2aCk7XHJcblxyXG4gIF8xMDB2aCA9ICFfbm9ybWFsaXplciAmJiBfZGl2MTAwdmgub2Zmc2V0SGVpZ2h0IHx8IF93aW4uaW5uZXJIZWlnaHQ7XHJcblxyXG4gIF9ib2R5LnJlbW92ZUNoaWxkKF9kaXYxMDB2aCk7XHJcbn0sXHJcbiAgICBfaGlkZUFsbE1hcmtlcnMgPSBmdW5jdGlvbiBfaGlkZUFsbE1hcmtlcnMoaGlkZSkge1xyXG4gIHJldHVybiBfdG9BcnJheShcIi5nc2FwLW1hcmtlci1zdGFydCwgLmdzYXAtbWFya2VyLWVuZCwgLmdzYXAtbWFya2VyLXNjcm9sbGVyLXN0YXJ0LCAuZ3NhcC1tYXJrZXItc2Nyb2xsZXItZW5kXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICByZXR1cm4gZWwuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcclxuICB9KTtcclxufSxcclxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcclxuICBfZG9jRWwgPSBfZG9jLmRvY3VtZW50RWxlbWVudDsgLy8gc29tZSBmcmFtZXdvcmtzIGxpa2UgQXN0cm8gbWF5IGNhY2hlIHRoZSA8Ym9keT4gYW5kIHJlcGxhY2UgaXQgZHVyaW5nIHJvdXRpbmcsIHNvIHdlJ2xsIGp1c3QgcmUtcmVjb3JkIHRoZSBfZG9jRWwgYW5kIF9ib2R5IGZvciBzYWZldHkgKG90aGVyd2lzZSwgdGhlIG1hcmtlcnMgbWF5IG5vdCBnZXQgYWRkZWQgcHJvcGVybHkpLlxyXG5cclxuICBfYm9keSA9IF9kb2MuYm9keTtcclxuICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcclxuXHJcbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UgJiYgIV9pc1JldmVydGVkKSB7XHJcbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBfcmVmcmVzaDEwMHZoKCk7XHJcblxyXG4gIF9yZWZyZXNoaW5nQWxsID0gU2Nyb2xsVHJpZ2dlci5pc1JlZnJlc2hpbmcgPSB0cnVlO1xyXG5cclxuICBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKG9iaikgJiYgKytvYmouY2FjaGVJRCAmJiAob2JqLnJlYyA9IG9iaigpKTtcclxuICB9KTsgLy8gZm9yY2UgdGhlIGNsZWFyaW5nIG9mIHRoZSBjYWNoZSBiZWNhdXNlIHNvbWUgYnJvd3NlcnMgdGFrZSBhIGxpdHRsZSB3aGlsZSB0byBkaXNwYXRjaCB0aGUgXCJzY3JvbGxcIiBldmVudCBhbmQgdGhlIHVzZXIgbWF5IGhhdmUgY2hhbmdlZCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFuZCB0aGVuIGNhbGxlZCBTY3JvbGxUcmlnZ2VyLnJlZnJlc2goKSByaWdodCBhd2F5XHJcblxyXG5cclxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XHJcblxyXG4gIF9zb3J0ICYmIFNjcm9sbFRyaWdnZXIuc29ydCgpO1xyXG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xyXG5cclxuICBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgaWYgKF9pc0Z1bmN0aW9uKG9iaikpIHtcclxuICAgICAgb2JqLnNtb290aCAmJiAob2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiKTsgLy8gc21vb3RoIHNjcm9sbGluZyBpbnRlcmZlcmVzXHJcblxyXG4gICAgICBvYmooMCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4gdC5yZWZyZXNoKCk7XHJcbiAgfSk7IC8vIGRvbid0IGxvb3Agd2l0aCBfaSBiZWNhdXNlIGR1cmluZyBhIHJlZnJlc2goKSBzb21lb25lIGNvdWxkIGNhbGwgU2Nyb2xsVHJpZ2dlci51cGRhdGUoKSB3aGljaCB3b3VsZCBpdGVyYXRlIHRocm91Z2ggX2kgcmVzdWx0aW5nIGluIGEgc2tpcC5cclxuXHJcblxyXG4gIF9pc1JldmVydGVkID0gZmFsc2U7XHJcblxyXG4gIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAvLyBuZXN0ZWQgcGlucyAocGlubmVkQ29udGFpbmVyKSB3aXRoIHBpblNwYWNpbmcgbWF5IGV4cGFuZCB0aGUgY29udGFpbmVyLCBzbyB3ZSBtdXN0IGFjY29tbW9kYXRlIHRoYXQgaGVyZS5cclxuICAgIGlmICh0Ll9zdWJQaW5PZmZzZXQgJiYgdC5waW4pIHtcclxuICAgICAgdmFyIHByb3AgPSB0LnZhcnMuaG9yaXpvbnRhbCA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIsXHJcbiAgICAgICAgICBvcmlnaW5hbCA9IHQucGluW3Byb3BdO1xyXG4gICAgICB0LnJldmVydCh0cnVlLCAxKTtcclxuICAgICAgdC5hZGp1c3RQaW5TcGFjaW5nKHQucGluW3Byb3BdIC0gb3JpZ2luYWwpO1xyXG4gICAgICB0LnJlZnJlc2goKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgX2NsYW1waW5nTWF4ID0gMTsgLy8gcGluU3BhY2luZyBtaWdodCBiZSBwcm9wcGluZyBhIHBhZ2Ugb3BlbiwgdGh1cyB3aGVuIHdlIC5zZXRQb3NpdGlvbnMoKSB0byBjbGFtcCBhIFNjcm9sbFRyaWdnZXIncyBlbmQgd2Ugc2hvdWxkIGxlYXZlIHRoZSBwaW5TcGFjaW5nIGFsb25lLiBUaGF0J3Mgd2hhdCB0aGlzIGZsYWcgaXMgZm9yLlxyXG5cclxuICBfaGlkZUFsbE1hcmtlcnModHJ1ZSk7XHJcblxyXG4gIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAvLyB0aGUgc2Nyb2xsZXIncyBtYXggc2Nyb2xsIHBvc2l0aW9uIG1heSBjaGFuZ2UgYWZ0ZXIgYWxsIHRoZSBTY3JvbGxUcmlnZ2VycyByZWZyZXNoZWQgKGxpa2UgcGlubmluZyBjb3VsZCBwdXNoIGl0IGRvd24pLCBzbyB3ZSBuZWVkIHRvIGxvb3AgYmFjayBhbmQgY29ycmVjdCBhbnkgd2l0aCBlbmQ6IFwibWF4XCIuIFNhbWUgZm9yIGFueXRoaW5nIHdpdGggYSBjbGFtcGVkIGVuZFxyXG4gICAgdmFyIG1heCA9IF9tYXhTY3JvbGwodC5zY3JvbGxlciwgdC5fZGlyKSxcclxuICAgICAgICBlbmRDbGFtcCA9IHQudmFycy5lbmQgPT09IFwibWF4XCIgfHwgdC5fZW5kQ2xhbXAgJiYgdC5lbmQgPiBtYXgsXHJcbiAgICAgICAgc3RhcnRDbGFtcCA9IHQuX3N0YXJ0Q2xhbXAgJiYgdC5zdGFydCA+PSBtYXg7XHJcblxyXG4gICAgKGVuZENsYW1wIHx8IHN0YXJ0Q2xhbXApICYmIHQuc2V0UG9zaXRpb25zKHN0YXJ0Q2xhbXAgPyBtYXggLSAxIDogdC5zdGFydCwgZW5kQ2xhbXAgPyBNYXRoLm1heChzdGFydENsYW1wID8gbWF4IDogdC5zdGFydCArIDEsIG1heCkgOiB0LmVuZCwgdHJ1ZSk7XHJcbiAgfSk7XHJcblxyXG4gIF9oaWRlQWxsTWFya2VycyhmYWxzZSk7XHJcblxyXG4gIF9jbGFtcGluZ01heCA9IDA7XHJcbiAgcmVmcmVzaEluaXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQucmVuZGVyICYmIHJlc3VsdC5yZW5kZXIoLTEpO1xyXG4gIH0pOyAvLyBpZiB0aGUgb25SZWZyZXNoSW5pdCgpIHJldHVybnMgYW4gYW5pbWF0aW9uICh0eXBpY2FsbHkgYSBnc2FwLnNldCgpKSwgcmV2ZXJ0IGl0LiBUaGlzIG1ha2VzIGl0IGVhc3kgdG8gcHV0IHRoaW5ncyBpbiBhIGNlcnRhaW4gc3BvdCBiZWZvcmUgcmVmcmVzaGluZyBmb3IgbWVhc3VyZW1lbnQgcHVycG9zZXMsIGFuZCB0aGVuIHB1dCB0aGluZ3MgYmFjay5cclxuXHJcbiAgX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgIGlmIChfaXNGdW5jdGlvbihvYmopKSB7XHJcbiAgICAgIG9iai5zbW9vdGggJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gb2JqLnRhcmdldC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwic21vb3RoXCI7XHJcbiAgICAgIH0pO1xyXG4gICAgICBvYmoucmVjICYmIG9iaihvYmoucmVjKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgX2NsZWFyU2Nyb2xsTWVtb3J5KF9zY3JvbGxSZXN0b3JhdGlvbiwgMSk7XHJcblxyXG4gIF9yZXNpemVEZWxheS5wYXVzZSgpO1xyXG5cclxuICBfcmVmcmVzaElEKys7XHJcbiAgX3JlZnJlc2hpbmdBbGwgPSAyO1xyXG5cclxuICBfdXBkYXRlQWxsKDIpO1xyXG5cclxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKHQudmFycy5vblJlZnJlc2gpICYmIHQudmFycy5vblJlZnJlc2godCk7XHJcbiAgfSk7XHJcblxyXG4gIF9yZWZyZXNoaW5nQWxsID0gU2Nyb2xsVHJpZ2dlci5pc1JlZnJlc2hpbmcgPSBmYWxzZTtcclxuXHJcbiAgX2Rpc3BhdGNoKFwicmVmcmVzaFwiKTtcclxufSxcclxuICAgIF9sYXN0U2Nyb2xsID0gMCxcclxuICAgIF9kaXJlY3Rpb24gPSAxLFxyXG4gICAgX3ByaW1hcnksXHJcbiAgICBfdXBkYXRlQWxsID0gZnVuY3Rpb24gX3VwZGF0ZUFsbChmb3JjZSkge1xyXG4gIGlmIChmb3JjZSA9PT0gMiB8fCAhX3JlZnJlc2hpbmdBbGwgJiYgIV9pc1JldmVydGVkKSB7XHJcbiAgICAvLyBfaXNSZXZlcnRlZCBjb3VsZCBiZSB0cnVlIGlmLCBmb3IgZXhhbXBsZSwgYSBtYXRjaE1lZGlhKCkgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgZXhlY3V0aW5nLiBXZSBkb24ndCB3YW50IHRvIHVwZGF0ZSBkdXJpbmcgdGhlIHRpbWUgZXZlcnl0aGluZyBpcyByZXZlcnRlZC5cclxuICAgIFNjcm9sbFRyaWdnZXIuaXNVcGRhdGluZyA9IHRydWU7XHJcbiAgICBfcHJpbWFyeSAmJiBfcHJpbWFyeS51cGRhdGUoMCk7IC8vIFNjcm9sbFNtb290aGVyIHVzZXMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cclxuXHJcbiAgICB2YXIgbCA9IF90cmlnZ2Vycy5sZW5ndGgsXHJcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXHJcbiAgICAgICAgcmVjb3JkVmVsb2NpdHkgPSB0aW1lIC0gX3RpbWUxID49IDUwLFxyXG4gICAgICAgIHNjcm9sbCA9IGwgJiYgX3RyaWdnZXJzWzBdLnNjcm9sbCgpO1xyXG5cclxuICAgIF9kaXJlY3Rpb24gPSBfbGFzdFNjcm9sbCA+IHNjcm9sbCA/IC0xIDogMTtcclxuICAgIF9yZWZyZXNoaW5nQWxsIHx8IChfbGFzdFNjcm9sbCA9IHNjcm9sbCk7XHJcblxyXG4gICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XHJcbiAgICAgIGlmIChfbGFzdFNjcm9sbFRpbWUgJiYgIV9wb2ludGVySXNEb3duICYmIHRpbWUgLSBfbGFzdFNjcm9sbFRpbWUgPiAyMDApIHtcclxuICAgICAgICBfbGFzdFNjcm9sbFRpbWUgPSAwO1xyXG5cclxuICAgICAgICBfZGlzcGF0Y2goXCJzY3JvbGxFbmRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90aW1lMiA9IF90aW1lMTtcclxuICAgICAgX3RpbWUxID0gdGltZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX2RpcmVjdGlvbiA8IDApIHtcclxuICAgICAgX2kgPSBsO1xyXG5cclxuICAgICAgd2hpbGUgKF9pLS0gPiAwKSB7XHJcbiAgICAgICAgX3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9kaXJlY3Rpb24gPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgbDsgX2krKykge1xyXG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBfcmFmSUQgPSAwO1xyXG59LFxyXG4gICAgX3Byb3BOYW1lc1RvQ29weSA9IFtfbGVmdCwgX3RvcCwgX2JvdHRvbSwgX3JpZ2h0LCBfbWFyZ2luICsgX0JvdHRvbSwgX21hcmdpbiArIF9SaWdodCwgX21hcmdpbiArIF9Ub3AsIF9tYXJnaW4gKyBfTGVmdCwgXCJkaXNwbGF5XCIsIFwiZmxleFNocmlua1wiLCBcImZsb2F0XCIsIFwiekluZGV4XCIsIFwiZ3JpZENvbHVtblN0YXJ0XCIsIFwiZ3JpZENvbHVtbkVuZFwiLCBcImdyaWRSb3dTdGFydFwiLCBcImdyaWRSb3dFbmRcIiwgXCJncmlkQXJlYVwiLCBcImp1c3RpZnlTZWxmXCIsIFwiYWxpZ25TZWxmXCIsIFwicGxhY2VTZWxmXCIsIFwib3JkZXJcIl0sXHJcbiAgICBfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcclxuICAgIF9zd2FwUGluT3V0ID0gZnVuY3Rpb24gX3N3YXBQaW5PdXQocGluLCBzcGFjZXIsIHN0YXRlKSB7XHJcbiAgX3NldFN0YXRlKHN0YXRlKTtcclxuXHJcbiAgdmFyIGNhY2hlID0gcGluLl9nc2FwO1xyXG5cclxuICBpZiAoY2FjaGUuc3BhY2VySXNOYXRpdmUpIHtcclxuICAgIF9zZXRTdGF0ZShjYWNoZS5zcGFjZXJTdGF0ZSk7XHJcbiAgfSBlbHNlIGlmIChwaW4uX2dzYXAuc3dhcHBlZEluKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gc3BhY2VyLnBhcmVudE5vZGU7XHJcblxyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcclxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHNwYWNlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwaW4uX2dzYXAuc3dhcHBlZEluID0gZmFsc2U7XHJcbn0sXHJcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XHJcbiAgaWYgKCFwaW4uX2dzYXAuc3dhcHBlZEluKSB7XHJcbiAgICB2YXIgaSA9IF9wcm9wTmFtZXNUb0NvcHkubGVuZ3RoLFxyXG4gICAgICAgIHNwYWNlclN0eWxlID0gc3BhY2VyLnN0eWxlLFxyXG4gICAgICAgIHBpblN0eWxlID0gcGluLnN0eWxlLFxyXG4gICAgICAgIHA7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBwID0gX3Byb3BOYW1lc1RvQ29weVtpXTtcclxuICAgICAgc3BhY2VyU3R5bGVbcF0gPSBjc1twXTtcclxuICAgIH1cclxuXHJcbiAgICBzcGFjZXJTdHlsZS5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIgPyBcImFic29sdXRlXCIgOiBcInJlbGF0aXZlXCI7XHJcbiAgICBjcy5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChzcGFjZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIik7XHJcbiAgICBwaW5TdHlsZVtfYm90dG9tXSA9IHBpblN0eWxlW19yaWdodF0gPSBcImF1dG9cIjtcclxuICAgIHNwYWNlclN0eWxlLmZsZXhCYXNpcyA9IGNzLmZsZXhCYXNpcyB8fCBcImF1dG9cIjtcclxuICAgIHNwYWNlclN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCI7XHJcbiAgICBzcGFjZXJTdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcclxuICAgIHNwYWNlclN0eWxlW193aWR0aF0gPSBfZ2V0U2l6ZShwaW4sIF9ob3Jpem9udGFsKSArIF9weDtcclxuICAgIHNwYWNlclN0eWxlW19oZWlnaHRdID0gX2dldFNpemUocGluLCBfdmVydGljYWwpICsgX3B4O1xyXG4gICAgc3BhY2VyU3R5bGVbX3BhZGRpbmddID0gcGluU3R5bGVbX21hcmdpbl0gPSBwaW5TdHlsZVtfdG9wXSA9IHBpblN0eWxlW19sZWZ0XSA9IFwiMFwiO1xyXG5cclxuICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XHJcblxyXG4gICAgcGluU3R5bGVbX3dpZHRoXSA9IHBpblN0eWxlW1wibWF4XCIgKyBfV2lkdGhdID0gY3NbX3dpZHRoXTtcclxuICAgIHBpblN0eWxlW19oZWlnaHRdID0gcGluU3R5bGVbXCJtYXhcIiArIF9IZWlnaHRdID0gY3NbX2hlaWdodF07XHJcbiAgICBwaW5TdHlsZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XHJcblxyXG4gICAgaWYgKHBpbi5wYXJlbnROb2RlICE9PSBzcGFjZXIpIHtcclxuICAgICAgcGluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwYWNlciwgcGluKTtcclxuICAgICAgc3BhY2VyLmFwcGVuZENoaWxkKHBpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcGluLl9nc2FwLnN3YXBwZWRJbiA9IHRydWU7XHJcbiAgfVxyXG59LFxyXG4gICAgX2NhcHNFeHAgPSAvKFtBLVpdKS9nLFxyXG4gICAgX3NldFN0YXRlID0gZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlKSB7XHJcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50LnN0eWxlLFxyXG4gICAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgcCxcclxuICAgICAgICB2YWx1ZTtcclxuICAgIChzdGF0ZS50Ll9nc2FwIHx8IGdzYXAuY29yZS5nZXRDYWNoZShzdGF0ZS50KSkudW5jYWNoZSA9IDE7IC8vIG90aGVyd2lzZSB0cmFuc2Zvcm1zIG1heSBiZSBvZmZcclxuXHJcbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xyXG4gICAgICB2YWx1ZSA9IHN0YXRlW2kgKyAxXTtcclxuICAgICAgcCA9IHN0YXRlW2ldO1xyXG5cclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgc3R5bGVbcF0gPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmIChzdHlsZVtwXSkge1xyXG4gICAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0sXHJcbiAgICBfZ2V0U3RhdGUgPSBmdW5jdGlvbiBfZ2V0U3RhdGUoZWxlbWVudCkge1xyXG4gIC8vIHJldHVybnMgYW4gQXJyYXkgd2l0aCBhbHRlcm5hdGluZyB2YWx1ZXMgbGlrZSBbcHJvcGVydHksIHZhbHVlLCBwcm9wZXJ0eSwgdmFsdWVdIGFuZCBhIFwidFwiIHByb3BlcnR5IHBvaW50aW5nIHRvIHRoZSB0YXJnZXQgKGVsZW1lbnQpLiBNYWtlcyBpdCBmYXN0IGFuZCBjaGVhcC5cclxuICB2YXIgbCA9IF9zdGF0ZVByb3BzLmxlbmd0aCxcclxuICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxyXG4gICAgICBzdGF0ZSA9IFtdLFxyXG4gICAgICBpID0gMDtcclxuXHJcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgIHN0YXRlLnB1c2goX3N0YXRlUHJvcHNbaV0sIHN0eWxlW19zdGF0ZVByb3BzW2ldXSk7XHJcbiAgfVxyXG5cclxuICBzdGF0ZS50ID0gZWxlbWVudDtcclxuICByZXR1cm4gc3RhdGU7XHJcbn0sXHJcbiAgICBfY29weVN0YXRlID0gZnVuY3Rpb24gX2NvcHlTdGF0ZShzdGF0ZSwgb3ZlcnJpZGUsIG9taXRPZmZzZXRzKSB7XHJcbiAgdmFyIHJlc3VsdCA9IFtdLFxyXG4gICAgICBsID0gc3RhdGUubGVuZ3RoLFxyXG4gICAgICBpID0gb21pdE9mZnNldHMgPyA4IDogMCxcclxuICAgICAgLy8gc2tpcCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gaWYgb21pdE9mZnNldHMgaXMgdHJ1ZVxyXG4gIHA7XHJcblxyXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICBwID0gc3RhdGVbaV07XHJcbiAgICByZXN1bHQucHVzaChwLCBwIGluIG92ZXJyaWRlID8gb3ZlcnJpZGVbcF0gOiBzdGF0ZVtpICsgMV0pO1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0LnQgPSBzdGF0ZS50O1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn0sXHJcbiAgICBfd2luT2Zmc2V0cyA9IHtcclxuICBsZWZ0OiAwLFxyXG4gIHRvcDogMFxyXG59LFxyXG4gICAgLy8gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlICg/KSBBbGxvdyB1c2VycyB0byBjYWxjdWxhdGUgd2hlcmUgYSB0cmlnZ2VyIGhpdHMgKHNjcm9sbCBwb3NpdGlvbikgbGlrZSBnZXRTY3JvbGxQb3NpdGlvbihcIiNpZFwiLCBcInRvcCBib3R0b21cIilcclxuLy8gX2dldFNjcm9sbFBvc2l0aW9uID0gKHRyaWdnZXIsIHBvc2l0aW9uLCB7c2Nyb2xsZXIsIGNvbnRhaW5lckFuaW1hdGlvbiwgaG9yaXpvbnRhbH0pID0+IHtcclxuLy8gXHRzY3JvbGxlciA9IF9nZXRUYXJnZXQoc2Nyb2xsZXIgfHwgX3dpbik7XHJcbi8vIFx0bGV0IGRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcclxuLy8gXHRcdGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydChzY3JvbGxlcik7XHJcbi8vIFx0X2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pO1xyXG4vLyBcdHJldHVybiBfcGFyc2VQb3NpdGlvbihwb3NpdGlvbiwgX2dldFRhcmdldCh0cmlnZ2VyKSwgX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pKCksIGRpcmVjdGlvbiwgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbikoKSwgMCwgMCwgMCwgX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSgpLCBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLCAwLCBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIpLCBjb250YWluZXJBbmltYXRpb24pO1xyXG4vLyB9LFxyXG5fcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKHZhbHVlLCB0cmlnZ2VyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgc2Nyb2xsLCBtYXJrZXIsIG1hcmtlclNjcm9sbGVyLCBzZWxmLCBzY3JvbGxlckJvdW5kcywgYm9yZGVyV2lkdGgsIHVzZUZpeGVkUG9zaXRpb24sIHNjcm9sbGVyTWF4LCBjb250YWluZXJBbmltYXRpb24sIGNsYW1wWmVyb1Byb3ApIHtcclxuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoc2VsZikpO1xyXG5cclxuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdWJzdHIoMCwgMykgPT09IFwibWF4XCIpIHtcclxuICAgIHZhbHVlID0gc2Nyb2xsZXJNYXggKyAodmFsdWUuY2hhckF0KDQpID09PSBcIj1cIiA/IF9vZmZzZXRUb1B4KFwiMFwiICsgdmFsdWUuc3Vic3RyKDMpLCBzY3JvbGxlclNpemUpIDogMCk7XHJcbiAgfVxyXG5cclxuICB2YXIgdGltZSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lKCkgOiAwLFxyXG4gICAgICBwMSxcclxuICAgICAgcDIsXHJcbiAgICAgIGVsZW1lbnQ7XHJcbiAgY29udGFpbmVyQW5pbWF0aW9uICYmIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKDApO1xyXG4gIGlzTmFOKHZhbHVlKSB8fCAodmFsdWUgPSArdmFsdWUpOyAvLyBjb252ZXJ0IGEgc3RyaW5nIG51bWJlciBsaWtlIFwiNDVcIiB0byBhbiBhY3R1YWwgbnVtYmVyXHJcblxyXG4gIGlmICghX2lzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgX2lzRnVuY3Rpb24odHJpZ2dlcikgJiYgKHRyaWdnZXIgPSB0cmlnZ2VyKHNlbGYpKTtcclxuICAgIHZhciBvZmZzZXRzID0gKHZhbHVlIHx8IFwiMFwiKS5zcGxpdChcIiBcIiksXHJcbiAgICAgICAgYm91bmRzLFxyXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxyXG4gICAgICAgIGdsb2JhbE9mZnNldCxcclxuICAgICAgICBkaXNwbGF5O1xyXG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlciwgc2VsZikgfHwgX2JvZHk7XHJcbiAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpIHx8IHt9O1xyXG5cclxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XHJcbiAgICAgIC8vIGlmIGRpc3BsYXkgaXMgXCJub25lXCIsIGl0IHdvbid0IHJlcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBwcm9wZXJseVxyXG4gICAgICBkaXNwbGF5ID0gZWxlbWVudC5zdHlsZS5kaXNwbGF5O1xyXG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XHJcbiAgICAgIGRpc3BsYXkgPyBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IDogZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9jYWxPZmZzZXQgPSBfb2Zmc2V0VG9QeChvZmZzZXRzWzBdLCBib3VuZHNbZGlyZWN0aW9uLmRdKTtcclxuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XHJcbiAgICB2YWx1ZSA9IGJvdW5kc1tkaXJlY3Rpb24ucF0gLSBzY3JvbGxlckJvdW5kc1tkaXJlY3Rpb24ucF0gLSBib3JkZXJXaWR0aCArIGxvY2FsT2Zmc2V0ICsgc2Nyb2xsIC0gZ2xvYmFsT2Zmc2V0O1xyXG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBnbG9iYWxPZmZzZXQsIGRpcmVjdGlvbiwgc2Nyb2xsZXJTaXplIC0gZ2xvYmFsT2Zmc2V0IDwgMjAgfHwgbWFya2VyU2Nyb2xsZXIuX2lzU3RhcnQgJiYgZ2xvYmFsT2Zmc2V0ID4gMjApO1xyXG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnRhaW5lckFuaW1hdGlvbiAmJiAodmFsdWUgPSBnc2FwLnV0aWxzLm1hcFJhbmdlKGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLnN0YXJ0LCBjb250YWluZXJBbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5lbmQsIDAsIHNjcm9sbGVyTWF4LCB2YWx1ZSkpO1xyXG4gICAgbWFya2VyU2Nyb2xsZXIgJiYgX3Bvc2l0aW9uTWFya2VyKG1hcmtlclNjcm9sbGVyLCBzY3JvbGxlclNpemUsIGRpcmVjdGlvbiwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBpZiAoY2xhbXBaZXJvUHJvcCkge1xyXG4gICAgc2VsZltjbGFtcFplcm9Qcm9wXSA9IHZhbHVlIHx8IC0wLjAwMTtcclxuICAgIHZhbHVlIDwgMCAmJiAodmFsdWUgPSAwKTtcclxuICB9XHJcblxyXG4gIGlmIChtYXJrZXIpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IHZhbHVlICsgc2Nyb2xsZXJTaXplLFxyXG4gICAgICAgIGlzU3RhcnQgPSBtYXJrZXIuX2lzU3RhcnQ7XHJcbiAgICBwMSA9IFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24uZDI7XHJcblxyXG4gICAgX3Bvc2l0aW9uTWFya2VyKG1hcmtlciwgcG9zaXRpb24sIGRpcmVjdGlvbiwgaXNTdGFydCAmJiBwb3NpdGlvbiA+IDIwIHx8ICFpc1N0YXJ0ICYmICh1c2VGaXhlZFBvc2l0aW9uID8gTWF0aC5tYXgoX2JvZHlbcDFdLCBfZG9jRWxbcDFdKSA6IG1hcmtlci5wYXJlbnROb2RlW3AxXSkgPD0gcG9zaXRpb24gKyAxKTtcclxuXHJcbiAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xyXG4gICAgICBzY3JvbGxlckJvdW5kcyA9IF9nZXRCb3VuZHMobWFya2VyU2Nyb2xsZXIpO1xyXG4gICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIChtYXJrZXIuc3R5bGVbZGlyZWN0aW9uLm9wLnBdID0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLm9wLnBdIC0gZGlyZWN0aW9uLm9wLm0gLSBtYXJrZXIuX29mZnNldCArIF9weCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoY29udGFpbmVyQW5pbWF0aW9uICYmIGVsZW1lbnQpIHtcclxuICAgIHAxID0gX2dldEJvdW5kcyhlbGVtZW50KTtcclxuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHNjcm9sbGVyTWF4KTtcclxuICAgIHAyID0gX2dldEJvdW5kcyhlbGVtZW50KTtcclxuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ID0gcDFbZGlyZWN0aW9uLnBdIC0gcDJbZGlyZWN0aW9uLnBdO1xyXG4gICAgdmFsdWUgPSB2YWx1ZSAvIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ICogc2Nyb2xsZXJNYXg7XHJcbiAgfVxyXG5cclxuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsodGltZSk7XHJcbiAgcmV0dXJuIGNvbnRhaW5lckFuaW1hdGlvbiA/IHZhbHVlIDogTWF0aC5yb3VuZCh2YWx1ZSk7XHJcbn0sXHJcbiAgICBfcHJlZml4RXhwID0gLyh3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxyXG4gICAgX3JlcGFyZW50ID0gZnVuY3Rpb24gX3JlcGFyZW50KGVsZW1lbnQsIHBhcmVudCwgdG9wLCBsZWZ0KSB7XHJcbiAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAhPT0gcGFyZW50KSB7XHJcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxyXG4gICAgICAgIHAsXHJcbiAgICAgICAgY3M7XHJcblxyXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcclxuICAgICAgZWxlbWVudC5fc3RPcmlnID0gc3R5bGUuY3NzVGV4dDsgLy8gcmVjb3JkIG9yaWdpbmFsIGlubGluZSBzdHlsZXMgc28gd2UgY2FuIHJldmVydCB0aGVtIGxhdGVyXHJcblxyXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG5cclxuICAgICAgZm9yIChwIGluIGNzKSB7XHJcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXHJcbiAgICAgICAgaWYgKCErcCAmJiAhX3ByZWZpeEV4cC50ZXN0KHApICYmIGNzW3BdICYmIHR5cGVvZiBzdHlsZVtwXSA9PT0gXCJzdHJpbmdcIiAmJiBwICE9PSBcIjBcIikge1xyXG4gICAgICAgICAgc3R5bGVbcF0gPSBjc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0eWxlLnRvcCA9IHRvcDtcclxuICAgICAgc3R5bGUubGVmdCA9IGxlZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5fc3RPcmlnO1xyXG4gICAgfVxyXG5cclxuICAgIGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcclxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICB9XHJcbn0sXHJcbiAgICBfaW50ZXJydXB0aW9uVHJhY2tlciA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHRpb25UcmFja2VyKGdldFZhbHVlRnVuYywgaW5pdGlhbFZhbHVlLCBvbkludGVycnVwdCkge1xyXG4gIHZhciBsYXN0MSA9IGluaXRpYWxWYWx1ZSxcclxuICAgICAgbGFzdDIgPSBsYXN0MTtcclxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgY3VycmVudCA9IE1hdGgucm91bmQoZ2V0VmFsdWVGdW5jKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBzY3JvbGwgY2FuIGdldCByZXBvcnRlZCB3aXRoIGRlY2ltYWxzIGV2ZW4gdGhvdWdoIGl0IHdhcyBzZXQgd2l0aG91dC5cclxuXHJcbiAgICBpZiAoY3VycmVudCAhPT0gbGFzdDEgJiYgY3VycmVudCAhPT0gbGFzdDIgJiYgTWF0aC5hYnMoY3VycmVudCAtIGxhc3QxKSA+IDMgJiYgTWF0aC5hYnMoY3VycmVudCAtIGxhc3QyKSA+IDMpIHtcclxuICAgICAgLy8gaWYgdGhlIHVzZXIgc2Nyb2xscywga2lsbCB0aGUgdHdlZW4uIGlPUyBTYWZhcmkgaW50ZXJtaXR0ZW50bHkgbWlzcmVwb3J0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBpdCBtYXkgYmUgdGhlIG1vc3QgcmVjZW50bHktc2V0IG9uZSBvciB0aGUgb25lIGJlZm9yZSB0aGF0ISBXaGVuIFNhZmFyaSBpcyB6b29tZWQgKENNRC0rKSwgaXQgb2Z0ZW4gbWlzcmVwb3J0cyBhcyAxIHBpeGVsIG9mZiB0b28hIFNvIGlmIHdlIHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIDEyNSwgZm9yIGV4YW1wbGUsIGl0J2xsIGFjdHVhbGx5IHJlcG9ydCBpdCBhcyAxMjQuXHJcbiAgICAgIHZhbHVlID0gY3VycmVudDtcclxuICAgICAgb25JbnRlcnJ1cHQgJiYgb25JbnRlcnJ1cHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0MiA9IGxhc3QxO1xyXG4gICAgbGFzdDEgPSBNYXRoLnJvdW5kKHZhbHVlKTtcclxuICAgIHJldHVybiBsYXN0MTtcclxuICB9O1xyXG59LFxyXG4gICAgX3NoaWZ0TWFya2VyID0gZnVuY3Rpb24gX3NoaWZ0TWFya2VyKG1hcmtlciwgZGlyZWN0aW9uLCB2YWx1ZSkge1xyXG4gIHZhciB2YXJzID0ge307XHJcbiAgdmFyc1tkaXJlY3Rpb24ucF0gPSBcIis9XCIgKyB2YWx1ZTtcclxuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xyXG59LFxyXG4gICAgLy8gX21lcmdlQW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMgPT4ge1xyXG4vLyBcdGxldCB0bCA9IGdzYXAudGltZWxpbmUoe3Ntb290aENoaWxkVGltaW5nOiB0cnVlfSkuc3RhcnRUaW1lKE1hdGgubWluKC4uLmFuaW1hdGlvbnMubWFwKGEgPT4gYS5nbG9iYWxUaW1lKDApKSkpO1xyXG4vLyBcdGFuaW1hdGlvbnMuZm9yRWFjaChhID0+IHtsZXQgdGltZSA9IGEudG90YWxUaW1lKCk7IHRsLmFkZChhKTsgYS50b3RhbFRpbWUodGltZSk7IH0pO1xyXG4vLyBcdHRsLnNtb290aENoaWxkVGltaW5nID0gZmFsc2U7XHJcbi8vIFx0cmV0dXJuIHRsO1xyXG4vLyB9LFxyXG4vLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byB0d2VlbiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gcHJvdmlkZWQsIGFuZCB3aGVuIGRvaW5nIHNvIGl0J2xsIGFkZCBhIC50d2VlbiBwcm9wZXJ0eSB0byB0aGUgRlVOQ1RJT04gaXRzZWxmLCBhbmQgcmVtb3ZlIGl0IHdoZW4gdGhlIHR3ZWVuIGNvbXBsZXRlcyBvciBnZXRzIGtpbGxlZC4gVGhpcyBnaXZlcyB1cyBhIHdheSB0byBoYXZlIG11bHRpcGxlIFNjcm9sbFRyaWdnZXJzIHVzZSBhIGNlbnRyYWwgZnVuY3Rpb24gZm9yIGFueSBnaXZlbiBzY3JvbGxlciBhbmQgc2VlIGlmIHRoZXJlJ3MgYSBzY3JvbGwgdHdlZW4gcnVubmluZyAod2hpY2ggd291bGQgYWZmZWN0IGlmL2hvdyB0aGluZ3MgZ2V0IHVwZGF0ZWQpXHJcbl9nZXRUd2VlbkNyZWF0b3IgPSBmdW5jdGlvbiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBkaXJlY3Rpb24pIHtcclxuICB2YXIgZ2V0U2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXHJcbiAgICAgIHByb3AgPSBcIl9zY3JvbGxcIiArIGRpcmVjdGlvbi5wMixcclxuICAgICAgLy8gYWRkIGEgdHdlZW5hYmxlIHByb3BlcnR5IHRvIHRoZSBzY3JvbGxlciB0aGF0J3MgYSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9uLCBsaWtlIF9zY3JvbGxUb3Agb3IgX3Njcm9sbExlZnQuIFRoaXMgd2F5LCBpZiBzb21lb25lIGRvZXMgZ3NhcC5raWxsVHdlZW5zT2Yoc2Nyb2xsZXIpIGl0J2xsIGtpbGwgdGhlIHNjcm9sbCB0d2Vlbi5cclxuICBnZXRUd2VlbiA9IGZ1bmN0aW9uIGdldFR3ZWVuKHNjcm9sbFRvLCB2YXJzLCBpbml0aWFsVmFsdWUsIGNoYW5nZTEsIGNoYW5nZTIpIHtcclxuICAgIHZhciB0d2VlbiA9IGdldFR3ZWVuLnR3ZWVuLFxyXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXHJcbiAgICAgICAgbW9kaWZpZXJzID0ge307XHJcbiAgICBpbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWUgfHwgZ2V0U2Nyb2xsKCk7XHJcblxyXG4gICAgdmFyIGNoZWNrRm9ySW50ZXJydXB0aW9uID0gX2ludGVycnVwdGlvblRyYWNrZXIoZ2V0U2Nyb2xsLCBpbml0aWFsVmFsdWUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdHdlZW4ua2lsbCgpO1xyXG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxyXG5cclxuICAgIGNoYW5nZTEgPSBjaGFuZ2UxIHx8IHNjcm9sbFRvIC0gaW5pdGlhbFZhbHVlO1xyXG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xyXG4gICAgdmFyc1twcm9wXSA9IHNjcm9sbFRvO1xyXG4gICAgdmFycy5pbmhlcml0ID0gZmFsc2U7XHJcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcclxuXHJcbiAgICBtb2RpZmllcnNbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBjaGVja0ZvckludGVycnVwdGlvbihpbml0aWFsVmFsdWUgKyBjaGFuZ2UxICogdHdlZW4ucmF0aW8gKyBjaGFuZ2UyICogdHdlZW4ucmF0aW8gKiB0d2Vlbi5yYXRpbyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhcnMub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKztcclxuICAgICAgZ2V0VHdlZW4udHdlZW4gJiYgX3VwZGF0ZUFsbCgpOyAvLyBpZiBpdCB3YXMgaW50ZXJydXB0ZWQva2lsbGVkLCBsaWtlIGluIGEgY29udGV4dC5yZXZlcnQoKSwgZG9uJ3QgZm9yY2UgYW4gdXBkYXRlQWxsKClcclxuICAgIH07XHJcblxyXG4gICAgdmFycy5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XHJcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZS5jYWxsKHR3ZWVuKTtcclxuICAgIH07XHJcblxyXG4gICAgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbiA9IGdzYXAudG8oc2Nyb2xsZXIsIHZhcnMpO1xyXG4gICAgcmV0dXJuIHR3ZWVuO1xyXG4gIH07XHJcblxyXG4gIHNjcm9sbGVyW3Byb3BdID0gZ2V0U2Nyb2xsO1xyXG5cclxuICBnZXRTY3JvbGwud2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldFR3ZWVuLnR3ZWVuICYmIGdldFR3ZWVuLnR3ZWVuLmtpbGwoKSAmJiAoZ2V0VHdlZW4udHdlZW4gPSAwKTtcclxuICB9O1xyXG5cclxuICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwid2hlZWxcIiwgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlcik7IC8vIFdpbmRvd3MgbWFjaGluZXMgaGFuZGxlIG1vdXNld2hlZWwgc2Nyb2xsaW5nIGluIGNodW5rcyAobGlrZSBcIjMgbGluZXMgcGVyIHNjcm9sbFwiKSBtZWFuaW5nIHRoZSB0eXBpY2FsIHN0cmF0ZWd5IGZvciBjYW5jZWxsaW5nIHRoZSBzY3JvbGwgaXNuJ3QgYXMgc2Vuc2l0aXZlLiBJdCdzIG11Y2ggbW9yZSBsaWtlbHkgdG8gbWF0Y2ggb25lIG9mIHRoZSBwcmV2aW91cyAyIHNjcm9sbCBldmVudCBwb3NpdGlvbnMuIFNvIHdlIGtpbGwgYW55IHNuYXBwaW5nIGFzIHNvb24gYXMgdGhlcmUncyBhIHdoZWVsIGV2ZW50LlxyXG5cclxuXHJcbiAgU2Nyb2xsVHJpZ2dlci5pc1RvdWNoICYmIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ0b3VjaG1vdmVcIiwgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlcik7XHJcbiAgcmV0dXJuIGdldFR3ZWVuO1xyXG59O1xyXG5cclxuZXhwb3J0IHZhciBTY3JvbGxUcmlnZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbikge1xyXG4gICAgX2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcIik7XHJcblxyXG4gICAgX2NvbnRleHQodGhpcyk7XHJcblxyXG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XHJcbiAgfVxyXG5cclxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XHJcblxyXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzLCBhbmltYXRpb24pIHtcclxuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcclxuICAgIHRoaXMudmFycyAmJiB0aGlzLmtpbGwodHJ1ZSwgdHJ1ZSk7IC8vIGluIGNhc2UgaXQncyBiZWluZyBpbml0dGVkIGFnYWluXHJcblxyXG4gICAgaWYgKCFfZW5hYmxlZCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMucmVmcmVzaCA9IHRoaXMua2lsbCA9IF9wYXNzVGhyb3VnaDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhcnMgPSBfc2V0RGVmYXVsdHMoX2lzU3RyaW5nKHZhcnMpIHx8IF9pc051bWJlcih2YXJzKSB8fCB2YXJzLm5vZGVUeXBlID8ge1xyXG4gICAgICB0cmlnZ2VyOiB2YXJzXHJcbiAgICB9IDogdmFycywgX2RlZmF1bHRzKTtcclxuXHJcbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxyXG4gICAgICAgIG9uVXBkYXRlID0gX3ZhcnMub25VcGRhdGUsXHJcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBfdmFycy50b2dnbGVDbGFzcyxcclxuICAgICAgICBpZCA9IF92YXJzLmlkLFxyXG4gICAgICAgIG9uVG9nZ2xlID0gX3ZhcnMub25Ub2dnbGUsXHJcbiAgICAgICAgb25SZWZyZXNoID0gX3ZhcnMub25SZWZyZXNoLFxyXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXHJcbiAgICAgICAgdHJpZ2dlciA9IF92YXJzLnRyaWdnZXIsXHJcbiAgICAgICAgcGluID0gX3ZhcnMucGluLFxyXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxyXG4gICAgICAgIGludmFsaWRhdGVPblJlZnJlc2ggPSBfdmFycy5pbnZhbGlkYXRlT25SZWZyZXNoLFxyXG4gICAgICAgIGFudGljaXBhdGVQaW4gPSBfdmFycy5hbnRpY2lwYXRlUGluLFxyXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcclxuICAgICAgICBvblNuYXBDb21wbGV0ZSA9IF92YXJzLm9uU25hcENvbXBsZXRlLFxyXG4gICAgICAgIG9uY2UgPSBfdmFycy5vbmNlLFxyXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxyXG4gICAgICAgIHBpblJlcGFyZW50ID0gX3ZhcnMucGluUmVwYXJlbnQsXHJcbiAgICAgICAgcGluU3BhY2VyID0gX3ZhcnMucGluU3BhY2VyLFxyXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcclxuICAgICAgICBmYXN0U2Nyb2xsRW5kID0gX3ZhcnMuZmFzdFNjcm9sbEVuZCxcclxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgPSBfdmFycy5wcmV2ZW50T3ZlcmxhcHMsXHJcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcclxuICAgICAgICBpc1RvZ2dsZSA9ICFzY3J1YiAmJiBzY3J1YiAhPT0gMCxcclxuICAgICAgICBzY3JvbGxlciA9IF9nZXRUYXJnZXQodmFycy5zY3JvbGxlciB8fCBfd2luKSxcclxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcclxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpLFxyXG4gICAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSAoXCJwaW5UeXBlXCIgaW4gdmFycyA/IHZhcnMucGluVHlwZSA6IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwicGluVHlwZVwiKSB8fCBpc1ZpZXdwb3J0ICYmIFwiZml4ZWRcIikgPT09IFwiZml4ZWRcIixcclxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxyXG4gICAgICAgIHRvZ2dsZUFjdGlvbnMgPSBpc1RvZ2dsZSAmJiB2YXJzLnRvZ2dsZUFjdGlvbnMuc3BsaXQoXCIgXCIpLFxyXG4gICAgICAgIG1hcmtlcnMgPSBcIm1hcmtlcnNcIiBpbiB2YXJzID8gdmFycy5tYXJrZXJzIDogX2RlZmF1bHRzLm1hcmtlcnMsXHJcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxyXG4gICAgICAgIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIG9uUmVmcmVzaEluaXQgPSB2YXJzLm9uUmVmcmVzaEluaXQgJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xyXG4gICAgfSxcclxuICAgICAgICBnZXRTY3JvbGxlclNpemUgPSBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbiksXHJcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcclxuICAgICAgICBsYXN0U25hcCA9IDAsXHJcbiAgICAgICAgbGFzdFJlZnJlc2ggPSAwLFxyXG4gICAgICAgIHByZXZQcm9ncmVzcyA9IDAsXHJcbiAgICAgICAgc2Nyb2xsRnVuYyA9IF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxyXG4gICAgICAgIHR3ZWVuVG8sXHJcbiAgICAgICAgcGluQ2FjaGUsXHJcbiAgICAgICAgc25hcEZ1bmMsXHJcbiAgICAgICAgc2Nyb2xsMSxcclxuICAgICAgICBzY3JvbGwyLFxyXG4gICAgICAgIHN0YXJ0LFxyXG4gICAgICAgIGVuZCxcclxuICAgICAgICBtYXJrZXJTdGFydCxcclxuICAgICAgICBtYXJrZXJFbmQsXHJcbiAgICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyLFxyXG4gICAgICAgIG1hcmtlckVuZFRyaWdnZXIsXHJcbiAgICAgICAgbWFya2VyVmFycyxcclxuICAgICAgICBleGVjdXRpbmdPblJlZnJlc2gsXHJcbiAgICAgICAgY2hhbmdlLFxyXG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUsXHJcbiAgICAgICAgcGluQWN0aXZlU3RhdGUsXHJcbiAgICAgICAgcGluU3RhdGUsXHJcbiAgICAgICAgc3BhY2VyLFxyXG4gICAgICAgIG9mZnNldCxcclxuICAgICAgICBwaW5HZXR0ZXIsXHJcbiAgICAgICAgcGluU2V0dGVyLFxyXG4gICAgICAgIHBpblN0YXJ0LFxyXG4gICAgICAgIHBpbkNoYW5nZSxcclxuICAgICAgICBzcGFjaW5nU3RhcnQsXHJcbiAgICAgICAgc3BhY2VyU3RhdGUsXHJcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIsXHJcbiAgICAgICAgcGluTW92ZXMsXHJcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyLFxyXG4gICAgICAgIGNzLFxyXG4gICAgICAgIHNuYXAxLFxyXG4gICAgICAgIHNuYXAyLFxyXG4gICAgICAgIHNjcnViVHdlZW4sXHJcbiAgICAgICAgc2NydWJTbW9vdGgsXHJcbiAgICAgICAgc25hcER1ckNsYW1wLFxyXG4gICAgICAgIHNuYXBEZWxheWVkQ2FsbCxcclxuICAgICAgICBwcmV2U2Nyb2xsLFxyXG4gICAgICAgIHByZXZBbmltUHJvZ3Jlc3MsXHJcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXHJcbiAgICAgICAgY3VzdG9tUmV2ZXJ0UmV0dXJuOyAvLyBmb3IgdGhlIHNha2Ugb2YgZWZmaWNpZW5jeSwgX3N0YXJ0Q2xhbXAvX2VuZENsYW1wIHNlcnZlIGxpa2UgYSB0cnV0aHkgdmFsdWUgaW5kaWNhdGluZyB0aGF0IGNsYW1waW5nIHdhcyBlbmFibGVkIG9uIHRoZSBzdGFydC9lbmQsIGFuZCBBTFNPIHN0b3JlIHRoZSBhY3R1YWwgcHJlLWNsYW1wZWQgbnVtZXJpYyB2YWx1ZS4gV2UgdGFwIGludG8gdGhhdCBpbiBTY3JvbGxTbW9vdGhlciBmb3Igc3BlZWQgZWZmZWN0cy4gU28gZm9yIGV4YW1wbGUsIGlmIHN0YXJ0PVwiY2xhbXAodG9wIGJvdHRvbSlcIiByZXN1bHRzIGluIGEgc3RhcnQgb2YgLTEwMCBuYXR1cmFsbHksIGl0IHdvdWxkIGdldCBjbGFtcGVkIHRvIDAgYnV0IC0xMDAgd291bGQgYmUgc3RvcmVkIGluIF9zdGFydENsYW1wLlxyXG5cclxuXHJcbiAgICBzZWxmLl9zdGFydENsYW1wID0gc2VsZi5fZW5kQ2xhbXAgPSBmYWxzZTtcclxuICAgIHNlbGYuX2RpciA9IGRpcmVjdGlvbjtcclxuICAgIGFudGljaXBhdGVQaW4gKj0gNDU7XHJcbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XHJcbiAgICBzZWxmLnNjcm9sbCA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lLmJpbmQoY29udGFpbmVyQW5pbWF0aW9uKSA6IHNjcm9sbEZ1bmM7XHJcbiAgICBzY3JvbGwxID0gc2Nyb2xsRnVuYygpO1xyXG4gICAgc2VsZi52YXJzID0gdmFycztcclxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbiB8fCB2YXJzLmFuaW1hdGlvbjtcclxuXHJcbiAgICBpZiAoXCJyZWZyZXNoUHJpb3JpdHlcIiBpbiB2YXJzKSB7XHJcbiAgICAgIF9zb3J0ID0gMTtcclxuICAgICAgdmFycy5yZWZyZXNoUHJpb3JpdHkgPT09IC05OTk5ICYmIChfcHJpbWFyeSA9IHNlbGYpOyAvLyB1c2VkIGJ5IFNjcm9sbFNtb290aGVyXHJcbiAgICB9XHJcblxyXG4gICAgc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCA9IHNjcm9sbGVyQ2FjaGUudHdlZW5TY3JvbGwgfHwge1xyXG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXHJcbiAgICAgIGxlZnQ6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF9ob3Jpem9udGFsKVxyXG4gICAgfTtcclxuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcclxuXHJcbiAgICBzZWxmLnNjcnViRHVyYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgc2NydWJTbW9vdGggPSBfaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlO1xyXG5cclxuICAgICAgaWYgKCFzY3J1YlNtb290aCkge1xyXG4gICAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wcm9ncmVzcygxKS5raWxsKCk7XHJcbiAgICAgICAgc2NydWJUd2VlbiA9IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4uZHVyYXRpb24odmFsdWUpIDogc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XHJcbiAgICAgICAgICBlYXNlOiBcImV4cG9cIixcclxuICAgICAgICAgIHRvdGFsUHJvZ3Jlc3M6IFwiKz0wXCIsXHJcbiAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcclxuICAgICAgICAgIGR1cmF0aW9uOiBzY3J1YlNtb290aCxcclxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcclxuICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvblNjcnViQ29tcGxldGUgJiYgb25TY3J1YkNvbXBsZXRlKHNlbGYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xyXG4gICAgICBhbmltYXRpb24uX2luaXR0ZWQgJiYgIXNlbGYuaXNSZXZlcnRlZCB8fCBhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiBhbmltYXRpb24uZHVyYXRpb24oKSAmJiBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpOyAvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgU2Nyb2xsVHJpZ2dlciBnZXRzIHJlLWluaXR0ZWQsIGEgZnJvbSgpIHR3ZWVuIHdpdGggYSBzdGFnZ2VyIGNvdWxkIGdldCBpbml0dGVkIGluaXRpYWxseSBhbmQgdGhlbiByZXZlcnRlZCBvbiB0aGUgcmUtaW5pdCB3aGljaCBtZWFucyBpdCdsbCBuZWVkIHRvIGdldCByZW5kZXJlZCBhZ2FpbiBoZXJlIHRvIHByb3Blcmx5IGRpc3BsYXkgdGhpbmdzLiBPdGhlcndpc2UsIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8zNjc3Ny1zY3JvbGxzbW9vdGhlci1zcGxpdHRleHQtbmV4dGpzLyBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vZVlQeVBwZD9lZGl0b3JzPTAwMTBcclxuXHJcbiAgICAgIHNlbGYuYW5pbWF0aW9uID0gYW5pbWF0aW9uLnBhdXNlKCk7XHJcbiAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gc2VsZjtcclxuICAgICAgc2VsZi5zY3J1YkR1cmF0aW9uKHNjcnViKTtcclxuICAgICAgc25hcDEgPSAwO1xyXG4gICAgICBpZCB8fCAoaWQgPSBhbmltYXRpb24udmFycy5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNuYXApIHtcclxuICAgICAgLy8gVE9ETzogcG90ZW50aWFsIGlkZWE6IHVzZSBsZWdpdGltYXRlIENTUyBzY3JvbGwgc25hcHBpbmcgYnkgcHVzaGluZyBpbnZpc2libGUgZWxlbWVudHMgaW50byB0aGUgRE9NIHRoYXQgc2VydmUgYXMgc25hcCBwb3NpdGlvbnMsIGFuZCB0b2dnbGUgdGhlIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgb25Ub2dnbGUuIFNlZSBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9KakxyZ1dNIGZvciBhIHF1aWNrIHByb29mIG9mIGNvbmNlcHQuXHJcbiAgICAgIGlmICghX2lzT2JqZWN0KHNuYXApIHx8IHNuYXAucHVzaCkge1xyXG4gICAgICAgIHNuYXAgPSB7XHJcbiAgICAgICAgICBzbmFwVG86IHNuYXBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBcInNjcm9sbEJlaGF2aW9yXCIgaW4gX2JvZHkuc3R5bGUgJiYgZ3NhcC5zZXQoaXNWaWV3cG9ydCA/IFtfYm9keSwgX2RvY0VsXSA6IHNjcm9sbGVyLCB7XHJcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXHJcbiAgICAgIH0pOyAvLyBzbW9vdGggc2Nyb2xsaW5nIGRvZXNuJ3Qgd29yayB3aXRoIHNuYXAuXHJcblxyXG4gICAgICBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gX2lzRnVuY3Rpb24obykgJiYgby50YXJnZXQgPT09IChpc1ZpZXdwb3J0ID8gX2RvYy5zY3JvbGxpbmdFbGVtZW50IHx8IF9kb2NFbCA6IHNjcm9sbGVyKSAmJiAoby5zbW9vdGggPSBmYWxzZSk7XHJcbiAgICAgIH0pOyAvLyBub3RlOiBzZXQgc21vb3RoIHRvIGZhbHNlIG9uIGJvdGggdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjcm9sbCBnZXR0ZXJzL3NldHRlcnNcclxuXHJcblxyXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikgOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNEaXJlY3Rpb25hbFwiID8gX2dldExhYmVsQXREaXJlY3Rpb24oYW5pbWF0aW9uKSA6IHNuYXAuZGlyZWN0aW9uYWwgIT09IGZhbHNlID8gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xyXG4gICAgICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKHNuYXAuc25hcFRvKSh2YWx1ZSwgX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwID8gMCA6IHN0LmRpcmVjdGlvbik7XHJcbiAgICAgIH0gOiBnc2FwLnV0aWxzLnNuYXAoc25hcC5zbmFwVG8pO1xyXG4gICAgICBzbmFwRHVyQ2xhbXAgPSBzbmFwLmR1cmF0aW9uIHx8IHtcclxuICAgICAgICBtaW46IDAuMSxcclxuICAgICAgICBtYXg6IDJcclxuICAgICAgfTtcclxuICAgICAgc25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xyXG4gICAgICBzbmFwRGVsYXllZENhbGwgPSBnc2FwLmRlbGF5ZWRDYWxsKHNuYXAuZGVsYXkgfHwgc2NydWJTbW9vdGggLyAyIHx8IDAuMSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY3JvbGwgPSBzY3JvbGxGdW5jKCksXHJcbiAgICAgICAgICAgIHJlZnJlc2hlZFJlY2VudGx5ID0gX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwLFxyXG4gICAgICAgICAgICB0d2VlbiA9IHR3ZWVuVG8udHdlZW47XHJcblxyXG4gICAgICAgIGlmICgocmVmcmVzaGVkUmVjZW50bHkgfHwgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwKSAmJiAhdHdlZW4gJiYgIV9wb2ludGVySXNEb3duICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcclxuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IChzY3JvbGwgLSBzdGFydCkgLyBjaGFuZ2UsXHJcbiAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSByZWZyZXNoZWRSZWNlbnRseSA/IDAgOiAodG90YWxQcm9ncmVzcyAtIHNuYXAyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMCxcclxuICAgICAgICAgICAgICBjaGFuZ2UxID0gZ3NhcC51dGlscy5jbGFtcCgtcHJvZ3Jlc3MsIDEgLSBwcm9ncmVzcywgX2Ficyh2ZWxvY2l0eSAvIDIpICogdmVsb2NpdHkgLyAwLjE4NSksXHJcbiAgICAgICAgICAgICAgbmF0dXJhbEVuZCA9IHByb2dyZXNzICsgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UgPyAwIDogY2hhbmdlMSksXHJcbiAgICAgICAgICAgICAgZW5kVmFsdWUsXHJcbiAgICAgICAgICAgICAgZW5kU2Nyb2xsLFxyXG4gICAgICAgICAgICAgIF9zbmFwID0gc25hcCxcclxuICAgICAgICAgICAgICBvblN0YXJ0ID0gX3NuYXAub25TdGFydCxcclxuICAgICAgICAgICAgICBfb25JbnRlcnJ1cHQgPSBfc25hcC5vbkludGVycnVwdCxcclxuICAgICAgICAgICAgICBfb25Db21wbGV0ZSA9IF9zbmFwLm9uQ29tcGxldGU7XHJcbiAgICAgICAgICBlbmRWYWx1ZSA9IHNuYXBGdW5jKG5hdHVyYWxFbmQsIHNlbGYpO1xyXG4gICAgICAgICAgX2lzTnVtYmVyKGVuZFZhbHVlKSB8fCAoZW5kVmFsdWUgPSBuYXR1cmFsRW5kKTsgLy8gaW4gY2FzZSB0aGUgZnVuY3Rpb24gZGlkbid0IHJldHVybiBhIG51bWJlciwgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBuYXR1cmFsRW5kXHJcblxyXG4gICAgICAgICAgZW5kU2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIGlmICh0d2VlbiAmJiAhdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uZGF0YSA8PSBfYWJzKGVuZFNjcm9sbCAtIHNjcm9sbCkpIHtcclxuICAgICAgICAgICAgICAvLyB0aGVyZSdzIGFuIG92ZXJsYXBwaW5nIHNuYXAhIFNvIHdlIG11c3QgZmlndXJlIG91dCB3aGljaCBvbmUgaXMgY2xvc2VyIGFuZCBsZXQgdGhhdCB0d2VlbiBsaXZlLlxyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICBjaGFuZ2UxID0gZW5kVmFsdWUgLSBwcm9ncmVzcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogc25hcER1ckNsYW1wKF9hYnMoTWF0aC5tYXgoX2FicyhuYXR1cmFsRW5kIC0gdG90YWxQcm9ncmVzcyksIF9hYnMoZW5kVmFsdWUgLSB0b3RhbFByb2dyZXNzKSkgKiAwLjE4NSAvIHZlbG9jaXR5IC8gMC4wNSB8fCAwKSksXHJcbiAgICAgICAgICAgICAgZWFzZTogc25hcC5lYXNlIHx8IFwicG93ZXIzXCIsXHJcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxyXG4gICAgICAgICAgICAgIC8vIHJlY29yZCB0aGUgZGlzdGFuY2Ugc28gdGhhdCBpZiBhbm90aGVyIHNuYXAgdHdlZW4gb2NjdXJzIChjb25mbGljdCkgd2UgY2FuIHByaW9yaXRpemUgdGhlIGNsb3Nlc3Qgc25hcC5cclxuICAgICAgICAgICAgICBvbkludGVycnVwdDogZnVuY3Rpb24gb25JbnRlcnJ1cHQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGFzdFNuYXAgPSBzY3JvbGxGdW5jKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc29sdXRpb24gb2YgdGhlIHNjcm9sbGJhciBpcyBsaW1pdGVkLCBzbyB3ZSBzaG91bGQgY29ycmVjdCB0aGUgc2NydWJiZWQgYW5pbWF0aW9uJ3MgcGxheWhlYWQgYXQgdGhlIGVuZCB0byBtYXRjaCBFWEFDVExZIHdoZXJlIGl0IHdhcyBzdXBwb3NlZCB0byBzbmFwXHJcbiAgICAgICAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnJlc2V0VG8oXCJ0b3RhbFByb2dyZXNzXCIsIGVuZFZhbHVlLCBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyKSA6IGFuaW1hdGlvbi5wcm9ncmVzcyhlbmRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc25hcDEgPSBzbmFwMiA9IGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgPyBhbmltYXRpb24udG90YWxQcm9ncmVzcygpIDogc2VsZi5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgIG9uU25hcENvbXBsZXRlICYmIG9uU25hcENvbXBsZXRlKHNlbGYpO1xyXG4gICAgICAgICAgICAgICAgX29uQ29tcGxldGUgJiYgX29uQ29tcGxldGUoc2VsZik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBzY3JvbGwsIGNoYW5nZTEgKiBjaGFuZ2UsIGVuZFNjcm9sbCAtIHNjcm9sbCAtIGNoYW5nZTEgKiBjaGFuZ2UpO1xyXG4gICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlzQWN0aXZlICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcclxuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkucGF1c2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcclxuICAgIHRyaWdnZXIgPSBzZWxmLnRyaWdnZXIgPSBfZ2V0VGFyZ2V0KHRyaWdnZXIgfHwgcGluICE9PSB0cnVlICYmIHBpbik7IC8vIGlmIGEgdHJpZ2dlciBoYXMgc29tZSBraW5kIG9mIHNjcm9sbC1yZWxhdGVkIGVmZmVjdCBhcHBsaWVkIHRoYXQgY291bGQgY29udGFtaW5hdGUgdGhlIFwieVwiIG9yIFwieFwiIHBvc2l0aW9uIChsaWtlIGEgU2Nyb2xsU21vb3RoZXIgZWZmZWN0KSwgd2UgbmVlZGVkIGEgd2F5IHRvIHRlbXBvcmFyaWx5IHJldmVydCBpdCwgc28gd2UgdXNlIHRoZSBzdFJldmVydCBwcm9wZXJ0eSBvZiB0aGUgZ3NDYWNoZS4gSXQgY2FuIHJldHVybiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgd2UnbGwgY2FsbCBhdCB0aGUgZW5kIHNvIGl0IGNhbiByZXR1cm4gdG8gaXRzIG5vcm1hbCBzdGF0ZS5cclxuXHJcbiAgICBjdXN0b21SZXZlcnRSZXR1cm4gPSB0cmlnZ2VyICYmIHRyaWdnZXIuX2dzYXAgJiYgdHJpZ2dlci5fZ3NhcC5zdFJldmVydDtcclxuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiAoY3VzdG9tUmV2ZXJ0UmV0dXJuID0gY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpKTtcclxuICAgIHBpbiA9IHBpbiA9PT0gdHJ1ZSA/IHRyaWdnZXIgOiBfZ2V0VGFyZ2V0KHBpbik7XHJcbiAgICBfaXNTdHJpbmcodG9nZ2xlQ2xhc3MpICYmICh0b2dnbGVDbGFzcyA9IHtcclxuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcclxuICAgICAgY2xhc3NOYW1lOiB0b2dnbGVDbGFzc1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHBpbikge1xyXG4gICAgICBwaW5TcGFjaW5nID09PSBmYWxzZSB8fCBwaW5TcGFjaW5nID09PSBfbWFyZ2luIHx8IChwaW5TcGFjaW5nID0gIXBpblNwYWNpbmcgJiYgcGluLnBhcmVudE5vZGUgJiYgcGluLnBhcmVudE5vZGUuc3R5bGUgJiYgX2dldENvbXB1dGVkU3R5bGUocGluLnBhcmVudE5vZGUpLmRpc3BsYXkgPT09IFwiZmxleFwiID8gZmFsc2UgOiBfcGFkZGluZyk7IC8vIGlmIHRoZSBwYXJlbnQgaXMgZGlzcGxheTogZmxleCwgZG9uJ3QgYXBwbHkgcGluU3BhY2luZyBieSBkZWZhdWx0LiBXZSBzaG91bGQgY2hlY2sgdGhhdCBwaW4ucGFyZW50Tm9kZSBpcyBhbiBlbGVtZW50IChub3Qgc2hhZG93IGRvbSB3aW5kb3cpXHJcblxyXG4gICAgICBzZWxmLnBpbiA9IHBpbjtcclxuICAgICAgcGluQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUocGluKTtcclxuXHJcbiAgICAgIGlmICghcGluQ2FjaGUuc3BhY2VyKSB7XHJcbiAgICAgICAgLy8gcmVjb3JkIHRoZSBzcGFjZXIgYW5kIHBpbk9yaWdpbmFsU3RhdGUgb24gdGhlIGNhY2hlIGluIGNhc2Ugc29tZW9uZSB0cmllcyBwaW5uaW5nIHRoZSBzYW1lIGVsZW1lbnQgd2l0aCBNVUxUSVBMRSBTY3JvbGxUcmlnZ2VycyAtIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSBtdWx0aXBsZSBzcGFjZXJzIG9yIHJlY29yZCB0aGUgXCJvcmlnaW5hbFwiIHBpbiBzdGF0ZSBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFmZmVjdGVkIGJ5IGFub3RoZXIgU2Nyb2xsVHJpZ2dlci5cclxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XHJcbiAgICAgICAgICBwaW5TcGFjZXIgPSBfZ2V0VGFyZ2V0KHBpblNwYWNlcik7XHJcbiAgICAgICAgICBwaW5TcGFjZXIgJiYgIXBpblNwYWNlci5ub2RlVHlwZSAmJiAocGluU3BhY2VyID0gcGluU3BhY2VyLmN1cnJlbnQgfHwgcGluU3BhY2VyLm5hdGl2ZUVsZW1lbnQpOyAvLyBmb3IgUmVhY3QgJiBBbmd1bGFyXHJcblxyXG4gICAgICAgICAgcGluQ2FjaGUuc3BhY2VySXNOYXRpdmUgPSAhIXBpblNwYWNlcjtcclxuICAgICAgICAgIHBpblNwYWNlciAmJiAocGluQ2FjaGUuc3BhY2VyU3RhdGUgPSBfZ2V0U3RhdGUocGluU3BhY2VyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBwaW5TcGFjZXIgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcclxuICAgICAgICBpZCAmJiBzcGFjZXIuY2xhc3NMaXN0LmFkZChcInBpbi1zcGFjZXItXCIgKyBpZCk7XHJcbiAgICAgICAgcGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGluT3JpZ2luYWxTdGF0ZSA9IHBpbkNhY2hlLnBpblN0YXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXJzLmZvcmNlM0QgIT09IGZhbHNlICYmIGdzYXAuc2V0KHBpbiwge1xyXG4gICAgICAgIGZvcmNlM0Q6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIHNlbGYuc3BhY2VyID0gc3BhY2VyID0gcGluQ2FjaGUuc3BhY2VyO1xyXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XHJcbiAgICAgIHNwYWNpbmdTdGFydCA9IGNzW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXTtcclxuICAgICAgcGluR2V0dGVyID0gZ3NhcC5nZXRQcm9wZXJ0eShwaW4pO1xyXG4gICAgICBwaW5TZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKHBpbiwgZGlyZWN0aW9uLmEsIF9weCk7IC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cclxuXHJcbiAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcclxuXHJcbiAgICAgIHBpblN0YXRlID0gX2dldFN0YXRlKHBpbik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1hcmtlcnMpIHtcclxuICAgICAgbWFya2VyVmFycyA9IF9pc09iamVjdChtYXJrZXJzKSA/IF9zZXREZWZhdWx0cyhtYXJrZXJzLCBfbWFya2VyRGVmYXVsdHMpIDogX21hcmtlckRlZmF1bHRzO1xyXG4gICAgICBtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xyXG4gICAgICBtYXJrZXJFbmRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLWVuZFwiLCBpZCwgc2Nyb2xsZXIsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgMCwgbWFya2VyU3RhcnRUcmlnZ2VyKTtcclxuICAgICAgb2Zmc2V0ID0gbWFya2VyU3RhcnRUcmlnZ2VyW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xyXG5cclxuICAgICAgdmFyIGNvbnRlbnQgPSBfZ2V0VGFyZ2V0KF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiY29udGVudFwiKSB8fCBzY3JvbGxlcik7XHJcblxyXG4gICAgICBtYXJrZXJTdGFydCA9IHRoaXMubWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xyXG4gICAgICBtYXJrZXJFbmQgPSB0aGlzLm1hcmtlckVuZCA9IF9jcmVhdGVNYXJrZXIoXCJlbmRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xyXG4gICAgICBjb250YWluZXJBbmltYXRpb24gJiYgKGNhTWFya2VyU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihbbWFya2VyU3RhcnQsIG1hcmtlckVuZF0sIGRpcmVjdGlvbi5hLCBfcHgpKTtcclxuXHJcbiAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbiAmJiAhKF9wcm94aWVzLmxlbmd0aCAmJiBfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImZpeGVkTWFya2Vyc1wiKSA9PT0gdHJ1ZSkpIHtcclxuICAgICAgICBfbWFrZVBvc2l0aW9uYWJsZShpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcik7XHJcblxyXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLCB7XHJcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLmEsIF9weCk7XHJcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24uYSwgX3B4KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcclxuICAgICAgdmFyIG9sZE9uVXBkYXRlID0gY29udGFpbmVyQW5pbWF0aW9uLnZhcnMub25VcGRhdGUsXHJcbiAgICAgICAgICBvbGRQYXJhbXMgPSBjb250YWluZXJBbmltYXRpb24udmFycy5vblVwZGF0ZVBhcmFtcztcclxuICAgICAgY29udGFpbmVyQW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XHJcbiAgICAgICAgb2xkT25VcGRhdGUgJiYgb2xkT25VcGRhdGUuYXBwbHkoY29udGFpbmVyQW5pbWF0aW9uLCBvbGRQYXJhbXMgfHwgW10pO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX3RyaWdnZXJzW190cmlnZ2Vycy5pbmRleE9mKHNlbGYpIC0gMV07XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSArIDFdO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnJldmVydCA9IGZ1bmN0aW9uIChyZXZlcnQsIHRlbXApIHtcclxuICAgICAgaWYgKCF0ZW1wKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYua2lsbCh0cnVlKTtcclxuICAgICAgfSAvLyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGdzYXAuY29udGV4dCgpIGFuZCBnc2FwLm1hdGNoTWVkaWEoKSB3aGljaCBjYWxsIHJldmVydCgpXHJcblxyXG5cclxuICAgICAgdmFyIHIgPSByZXZlcnQgIT09IGZhbHNlIHx8ICFzZWxmLmVuYWJsZWQsXHJcbiAgICAgICAgICBwcmV2UmVmcmVzaGluZyA9IF9yZWZyZXNoaW5nO1xyXG5cclxuICAgICAgaWYgKHIgIT09IHNlbGYuaXNSZXZlcnRlZCkge1xyXG4gICAgICAgIGlmIChyKSB7XHJcbiAgICAgICAgICBwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2Nyb2xsRnVuYygpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXHJcblxyXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcztcclxuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICByZXR1cm4gbS5zdHlsZS5kaXNwbGF5ID0gciA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgX3JlZnJlc2hpbmcgPSBzZWxmO1xyXG4gICAgICAgICAgc2VsZi51cGRhdGUocik7IC8vIG1ha2Ugc3VyZSB0aGUgcGluIGlzIGJhY2sgaW4gaXRzIG9yaWdpbmFsIHBvc2l0aW9uIHNvIHRoYXQgYWxsIHRoZSBtZWFzdXJlbWVudHMgYXJlIGNvcnJlY3QuIGRvIHRoaXMgQkVGT1JFIHN3YXBwaW5nIHRoZSBwaW4gb3V0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGluICYmICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpKSB7XHJcbiAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICBfc3dhcFBpbk91dChwaW4sIHNwYWNlciwgcGluT3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pLCBzcGFjZXJTdGF0ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByIHx8IHNlbGYudXBkYXRlKHIpOyAvLyB3aGVuIHdlJ3JlIHJlc3RvcmluZywgdGhlIHVwZGF0ZSBzaG91bGQgcnVuIEFGVEVSIHN3YXBwaW5nIHRoZSBwaW4gaW50byBpdHMgcGluLXNwYWNlci5cclxuXHJcbiAgICAgICAgX3JlZnJlc2hpbmcgPSBwcmV2UmVmcmVzaGluZzsgLy8gcmVzdG9yZS4gV2Ugc2V0IGl0IHRvIHRydWUgZHVyaW5nIHRoZSB1cGRhdGUoKSBzbyB0aGF0IHRoaW5ncyBmaXJlIHByb3Blcmx5IGluIHRoZXJlLlxyXG5cclxuICAgICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSByO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChzb2Z0LCBmb3JjZSwgcG9zaXRpb24sIHBpbk9mZnNldCkge1xyXG4gICAgICAvLyBwb3NpdGlvbiBpcyB0eXBpY2FsbHkgb25seSBkZWZpbmVkIGlmIGl0J3MgY29taW5nIGZyb20gc2V0UG9zaXRpb25zKCkgLSBpdCdzIGEgd2F5IHRvIHNraXAgdGhlIG5vcm1hbCBwYXJzaW5nLiBwaW5PZmZzZXQgaXMgYWxzbyBvbmx5IGZyb20gc2V0UG9zaXRpb25zKCkgYW5kIGlzIG1vc3RseSByZWxhdGVkIHRvIGZhbmN5IHN0dWZmIHdlIG5lZWQgdG8gZG8gaW4gU2Nyb2xsU21vb3RoZXIgd2l0aCBlZmZlY3RzXHJcbiAgICAgIGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGluICYmIHNvZnQgJiYgX2xhc3RTY3JvbGxUaW1lKSB7XHJcbiAgICAgICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgIV9yZWZyZXNoaW5nQWxsICYmIG9uUmVmcmVzaEluaXQgJiYgb25SZWZyZXNoSW5pdChzZWxmKTtcclxuICAgICAgX3JlZnJlc2hpbmcgPSBzZWxmO1xyXG5cclxuICAgICAgaWYgKHR3ZWVuVG8udHdlZW4gJiYgIXBvc2l0aW9uKSB7XHJcbiAgICAgICAgLy8gd2Ugc2tpcCB0aGlzIGlmIGEgcG9zaXRpb24gaXMgcGFzc2VkIGluIGJlY2F1c2UgdHlwaWNhbGx5IHRoYXQncyBmcm9tIC5zZXRQb3NpdGlvbnMoKSBhbmQgaXQncyBiZXN0IHRvIGFsbG93IGluLXByb2dyZXNzIHNuYXBwaW5nIHRvIGNvbnRpbnVlLlxyXG4gICAgICAgIHR3ZWVuVG8udHdlZW4ua2lsbCgpO1xyXG4gICAgICAgIHR3ZWVuVG8udHdlZW4gPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcclxuXHJcbiAgICAgIGlmIChpbnZhbGlkYXRlT25SZWZyZXNoICYmIGFuaW1hdGlvbikge1xyXG4gICAgICAgIGFuaW1hdGlvbi5yZXZlcnQoe1xyXG4gICAgICAgICAga2lsbDogZmFsc2VcclxuICAgICAgICB9KS5pbnZhbGlkYXRlKCk7XHJcbiAgICAgICAgYW5pbWF0aW9uLmdldENoaWxkcmVuICYmIGFuaW1hdGlvbi5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgcmV0dXJuIHQudmFycy5pbW1lZGlhdGVSZW5kZXIgJiYgdC5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSk7IC8vIGFueSBmcm9tKCkgb3IgZnJvbVRvKCkgdHdlZW5zIGluc2lkZSBhIHRpbWVsaW5lIHNob3VsZCByZW5kZXIgaW1tZWRpYXRlbHkgKHdlbGwsIHVubGVzcyB0aGV5IGhhdmUgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSlcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5pc1JldmVydGVkIHx8IHNlbGYucmV2ZXJ0KHRydWUsIHRydWUpO1xyXG4gICAgICBzZWxmLl9zdWJQaW5PZmZzZXQgPSBmYWxzZTsgLy8gd2UnbGwgc2V0IHRoaXMgdG8gdHJ1ZSBpbiB0aGUgc3ViLXBpbnMgaWYgd2UgZmluZCBhbnlcclxuXHJcbiAgICAgIHZhciBzaXplID0gZ2V0U2Nyb2xsZXJTaXplKCksXHJcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxyXG4gICAgICAgICAgbWF4ID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxyXG4gICAgICAgICAgaXNGaXJzdFJlZnJlc2ggPSBjaGFuZ2UgPD0gMC4wMSB8fCAhY2hhbmdlLFxyXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcclxuICAgICAgICAgIG90aGVyUGluT2Zmc2V0ID0gcGluT2Zmc2V0IHx8IDAsXHJcbiAgICAgICAgICBwYXJzZWRFbmQgPSBfaXNPYmplY3QocG9zaXRpb24pID8gcG9zaXRpb24uZW5kIDogdmFycy5lbmQsXHJcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXHJcbiAgICAgICAgICBwYXJzZWRTdGFydCA9IF9pc09iamVjdChwb3NpdGlvbikgPyBwb3NpdGlvbi5zdGFydCA6IHZhcnMuc3RhcnQgfHwgKHZhcnMuc3RhcnQgPT09IDAgfHwgIXRyaWdnZXIgPyAwIDogcGluID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpLFxyXG4gICAgICAgICAgcGlubmVkQ29udGFpbmVyID0gc2VsZi5waW5uZWRDb250YWluZXIgPSB2YXJzLnBpbm5lZENvbnRhaW5lciAmJiBfZ2V0VGFyZ2V0KHZhcnMucGlubmVkQ29udGFpbmVyLCBzZWxmKSxcclxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXHJcbiAgICAgICAgICBpID0gdHJpZ2dlckluZGV4LFxyXG4gICAgICAgICAgY3MsXHJcbiAgICAgICAgICBib3VuZHMsXHJcbiAgICAgICAgICBzY3JvbGwsXHJcbiAgICAgICAgICBpc1ZlcnRpY2FsLFxyXG4gICAgICAgICAgb3ZlcnJpZGUsXHJcbiAgICAgICAgICBjdXJUcmlnZ2VyLFxyXG4gICAgICAgICAgY3VyUGluLFxyXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXHJcbiAgICAgICAgICBpbml0dGVkLFxyXG4gICAgICAgICAgcmV2ZXJ0ZWRQaW5zLFxyXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3csXHJcbiAgICAgICAgICBtYXJrZXJTdGFydE9mZnNldCxcclxuICAgICAgICAgIG1hcmtlckVuZE9mZnNldDtcclxuXHJcbiAgICAgIGlmIChtYXJrZXJzICYmIF9pc09iamVjdChwb3NpdGlvbikpIHtcclxuICAgICAgICAvLyBpZiB3ZSBhbHRlciB0aGUgc3RhcnQvZW5kIHBvc2l0aW9ucyB3aXRoIC5zZXRQb3NpdGlvbnMoKSwgaXQgZ2VuZXJhbGx5IGZlZWRzIGluIGFic29sdXRlIE5VTUJFUlMgd2hpY2ggZG9uJ3QgY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHdoZXJlIHRvIGxpbmUgdXAgdGhlIG1hcmtlcnMsIHNvIHRvIGtlZXAgaXQgaW50dWl0aXZlLCB3ZSByZWNvcmQgaG93IGZhciB0aGUgdHJpZ2dlciBwb3NpdGlvbnMgc2hpZnQgYWZ0ZXIgYXBwbHlpbmcgdGhlIG5ldyBudW1iZXJzIGFuZCB0aGVuIG9mZnNldCBieSB0aGF0IG11Y2ggaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi4gV2UgZG8gdGhlIHNhbWUgdG8gdGhlIGFzc29jaWF0ZWQgdHJpZ2dlciBtYXJrZXJzIHRvbyBvZiBjb3Vyc2UuXHJcbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgPSBnc2FwLmdldFByb3BlcnR5KG1hcmtlclN0YXJ0VHJpZ2dlciwgZGlyZWN0aW9uLnApO1xyXG4gICAgICAgIG1hcmtlckVuZE9mZnNldCA9IGdzYXAuZ2V0UHJvcGVydHkobWFya2VyRW5kVHJpZ2dlciwgZGlyZWN0aW9uLnApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xyXG4gICAgICAgIC8vIHVzZXIgbWlnaHQgdHJ5IHRvIHBpbiB0aGUgc2FtZSBlbGVtZW50IG1vcmUgdGhhbiBvbmNlLCBzbyB3ZSBtdXN0IGZpbmQgYW55IHByaW9yIHRyaWdnZXJzIHdpdGggdGhlIHNhbWUgcGluLCByZXZlcnQgdGhlbSwgYW5kIGRldGVybWluZSBob3cgbG9uZyB0aGV5J3JlIHBpbm5pbmcgc28gdGhhdCB3ZSBjYW4gb2Zmc2V0IHRoaW5ncyBhcHByb3ByaWF0ZWx5LiBNYWtlIHN1cmUgd2UgcmV2ZXJ0IGZyb20gbGFzdCB0byBmaXJzdCBzbyB0aGF0IHRoaW5ncyBcInJld2luZFwiIHByb3Blcmx5LlxyXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XHJcbiAgICAgICAgY3VyVHJpZ2dlci5lbmQgfHwgY3VyVHJpZ2dlci5yZWZyZXNoKDAsIDEpIHx8IChfcmVmcmVzaGluZyA9IHNlbGYpOyAvLyBpZiBpdCdzIGEgdGltZWxpbmUtYmFzZWQgdHJpZ2dlciB0aGF0IGhhc24ndCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkIHlldCBiZWNhdXNlIGl0J3Mgd2FpdGluZyBmb3IgMSB0aWNrLCBqdXN0IGZvcmNlIHRoZSByZWZyZXNoKCkgaGVyZSwgb3RoZXJ3aXNlIGlmIGl0IGNvbnRhaW5zIGEgcGluIHRoYXQncyBzdXBwb3NlZCB0byBhZmZlY3Qgb3RoZXIgU2Nyb2xsVHJpZ2dlcnMgZnVydGhlciBkb3duIHRoZSBwYWdlLCB0aGV5IHdvbid0IGJlIGFkanVzdGVkIHByb3Blcmx5LlxyXG5cclxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcclxuXHJcbiAgICAgICAgaWYgKGN1clBpbiAmJiAoY3VyUGluID09PSB0cmlnZ2VyIHx8IGN1clBpbiA9PT0gcGluIHx8IGN1clBpbiA9PT0gcGlubmVkQ29udGFpbmVyKSAmJiAhY3VyVHJpZ2dlci5pc1JldmVydGVkKSB7XHJcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcclxuICAgICAgICAgIHJldmVydGVkUGlucy51bnNoaWZ0KGN1clRyaWdnZXIpOyAvLyB3ZSdsbCByZXZlcnQgZnJvbSBmaXJzdCB0byBsYXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgcmVhY2ggdGhlaXIgZW5kIHN0YXRlIHByb3Blcmx5XHJcblxyXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQodHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VyVHJpZ2dlciAhPT0gX3RyaWdnZXJzW2ldKSB7XHJcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxyXG4gICAgICAgICAgdHJpZ2dlckluZGV4LS07XHJcbiAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xyXG4gICAgICBwYXJzZWRTdGFydCA9IF9wYXJzZUNsYW1wKHBhcnNlZFN0YXJ0LCBcInN0YXJ0XCIsIHNlbGYpO1xyXG4gICAgICBzdGFydCA9IF9wYXJzZVBvc2l0aW9uKHBhcnNlZFN0YXJ0LCB0cmlnZ2VyLCBzaXplLCBkaXJlY3Rpb24sIHNjcm9sbEZ1bmMoKSwgbWFya2VyU3RhcnQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbiwgc2VsZi5fc3RhcnRDbGFtcCAmJiBcIl9zdGFydENsYW1wXCIpIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcclxuICAgICAgX2lzRnVuY3Rpb24ocGFyc2VkRW5kKSAmJiAocGFyc2VkRW5kID0gcGFyc2VkRW5kKHNlbGYpKTtcclxuXHJcbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xyXG4gICAgICAgIGlmICh+cGFyc2VkRW5kLmluZGV4T2YoXCIgXCIpKSB7XHJcbiAgICAgICAgICBwYXJzZWRFbmQgPSAoX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0LnNwbGl0KFwiIFwiKVswXSA6IFwiXCIpICsgcGFyc2VkRW5kO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvZmZzZXQgPSBfb2Zmc2V0VG9QeChwYXJzZWRFbmQuc3Vic3RyKDIpLCBzaXplKTtcclxuICAgICAgICAgIHBhcnNlZEVuZCA9IF9pc1N0cmluZyhwYXJzZWRTdGFydCkgPyBwYXJzZWRTdGFydCA6IChjb250YWluZXJBbmltYXRpb24gPyBnc2FwLnV0aWxzLm1hcFJhbmdlKDAsIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpLCBjb250YWluZXJBbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5zdGFydCwgY29udGFpbmVyQW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIuZW5kLCBzdGFydCkgOiBzdGFydCkgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cclxuXHJcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdHJpZ2dlcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhcnNlZEVuZCA9IF9wYXJzZUNsYW1wKHBhcnNlZEVuZCwgXCJlbmRcIiwgc2VsZik7XHJcbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbiwgc2VsZi5fZW5kQ2xhbXAgJiYgXCJfZW5kQ2xhbXBcIikpIHx8IC0wLjAwMTtcclxuICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgaSA9IHRyaWdnZXJJbmRleDtcclxuXHJcbiAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBjdXJUcmlnZ2VyID0gX3RyaWdnZXJzW2ldO1xyXG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xyXG5cclxuICAgICAgICBpZiAoY3VyUGluICYmIGN1clRyaWdnZXIuc3RhcnQgLSBjdXJUcmlnZ2VyLl9waW5QdXNoIDw9IHN0YXJ0ICYmICFjb250YWluZXJBbmltYXRpb24gJiYgY3VyVHJpZ2dlci5lbmQgPiAwKSB7XHJcbiAgICAgICAgICBjcyA9IGN1clRyaWdnZXIuZW5kIC0gKHNlbGYuX3N0YXJ0Q2xhbXAgPyBNYXRoLm1heCgwLCBjdXJUcmlnZ2VyLnN0YXJ0KSA6IGN1clRyaWdnZXIuc3RhcnQpO1xyXG5cclxuICAgICAgICAgIGlmICgoY3VyUGluID09PSB0cmlnZ2VyICYmIGN1clRyaWdnZXIuc3RhcnQgLSBjdXJUcmlnZ2VyLl9waW5QdXNoIDwgc3RhcnQgfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmIGlzTmFOKHBhcnNlZFN0YXJ0KSkge1xyXG4gICAgICAgICAgICAvLyBudW1lcmljIHN0YXJ0IHZhbHVlcyBzaG91bGRuJ3QgYmUgb2Zmc2V0IGF0IGFsbCAtIHRyZWF0IHRoZW0gYXMgYWJzb2x1dGVcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGNzICogKDEgLSBjdXJUcmlnZ2VyLnByb2dyZXNzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjdXJQaW4gPT09IHBpbiAmJiAob3RoZXJQaW5PZmZzZXQgKz0gY3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xyXG4gICAgICBlbmQgKz0gb2Zmc2V0O1xyXG4gICAgICBzZWxmLl9zdGFydENsYW1wICYmIChzZWxmLl9zdGFydENsYW1wICs9IG9mZnNldCk7XHJcblxyXG4gICAgICBpZiAoc2VsZi5fZW5kQ2xhbXAgJiYgIV9yZWZyZXNoaW5nQWxsKSB7XHJcbiAgICAgICAgc2VsZi5fZW5kQ2xhbXAgPSBlbmQgfHwgLTAuMDAxO1xyXG4gICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoYW5nZSA9IGVuZCAtIHN0YXJ0IHx8IChzdGFydCAtPSAwLjAxKSAmJiAwLjAwMTtcclxuXHJcbiAgICAgIGlmIChpc0ZpcnN0UmVmcmVzaCkge1xyXG4gICAgICAgIC8vIG9uIHRoZSB2ZXJ5IGZpcnN0IHJlZnJlc2goKSwgdGhlIHByZXZQcm9ncmVzcyBjb3VsZG4ndCBoYXZlIGJlZW4gYWNjdXJhdGUgeWV0IGJlY2F1c2UgdGhlIHN0YXJ0L2VuZCB3ZXJlIG5ldmVyIGNhbGN1bGF0ZWQsIHNvIHdlIHNldCBpdCBoZXJlLiBCZWZvcmUgMy4xMS41LCBpdCBjb3VsZCBsZWFkIHRvIGFuIGluYWNjdXJhdGUgc2Nyb2xsIHBvc2l0aW9uIHJlc3RvcmF0aW9uIHdpdGggc25hcHBpbmcuXHJcbiAgICAgICAgcHJldlByb2dyZXNzID0gZ3NhcC51dGlscy5jbGFtcCgwLCAxLCBnc2FwLnV0aWxzLm5vcm1hbGl6ZShzdGFydCwgZW5kLCBwcmV2U2Nyb2xsKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYuX3BpblB1c2ggPSBvdGhlclBpbk9mZnNldDtcclxuXHJcbiAgICAgIGlmIChtYXJrZXJTdGFydCAmJiBvZmZzZXQpIHtcclxuICAgICAgICAvLyBvZmZzZXQgdGhlIG1hcmtlcnMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgY3MgPSB7fTtcclxuICAgICAgICBjc1tkaXJlY3Rpb24uYV0gPSBcIis9XCIgKyBvZmZzZXQ7XHJcbiAgICAgICAgcGlubmVkQ29udGFpbmVyICYmIChjc1tkaXJlY3Rpb24ucF0gPSBcIi09XCIgKyBzY3JvbGxGdW5jKCkpO1xyXG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGluICYmICEoX2NsYW1waW5nTWF4ICYmIHNlbGYuZW5kID49IF9tYXhTY3JvbGwoc2Nyb2xsZXIsIGRpcmVjdGlvbikpKSB7XHJcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xyXG4gICAgICAgIGlzVmVydGljYWwgPSBkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbDtcclxuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxyXG5cclxuICAgICAgICBwaW5TdGFydCA9IHBhcnNlRmxvYXQocGluR2V0dGVyKGRpcmVjdGlvbi5hKSkgKyBvdGhlclBpbk9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKCFtYXggJiYgZW5kID4gMSkge1xyXG4gICAgICAgICAgLy8gbWFrZXMgc3VyZSB0aGUgc2Nyb2xsZXIgaGFzIGEgc2Nyb2xsYmFyLCBvdGhlcndpc2UgaWYgc29tZXRoaW5nIGhhcyB3aWR0aDogMTAwJSwgZm9yIGV4YW1wbGUsIGl0IHdvdWxkIGJlIHRvbyBiaWcgKGV4Y2x1ZGUgdGhlIHNjcm9sbGJhcikuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yNTE4Mi1zY3JvbGx0cmlnZ2VyLXdpZHRoLW9mLXBhZ2UtaW5jcmVhc2Utd2hlcmUtbWFya2Vycy1hcmUtc2V0LXRvLWZhbHNlL1xyXG4gICAgICAgICAgZm9yY2VkT3ZlcmZsb3cgPSAoaXNWaWV3cG9ydCA/IF9kb2Muc2Nyb2xsaW5nRWxlbWVudCB8fCBfZG9jRWwgOiBzY3JvbGxlcikuc3R5bGU7XHJcbiAgICAgICAgICBmb3JjZWRPdmVyZmxvdyA9IHtcclxuICAgICAgICAgICAgc3R5bGU6IGZvcmNlZE92ZXJmbG93LFxyXG4gICAgICAgICAgICB2YWx1ZTogZm9yY2VkT3ZlcmZsb3dbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV1cclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgaWYgKGlzVmlld3BvcnQgJiYgX2dldENvbXB1dGVkU3R5bGUoX2JvZHkpW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldICE9PSBcInNjcm9sbFwiKSB7XHJcbiAgICAgICAgICAgIC8vIGF2b2lkIGFuIGV4dHJhIHNjcm9sbGJhciBpZiBCT1RIIDxodG1sPiBhbmQgPGJvZHk+IGhhdmUgb3ZlcmZsb3cgc2V0IHRvIFwic2Nyb2xsXCJcclxuICAgICAgICAgICAgZm9yY2VkT3ZlcmZsb3cuc3R5bGVbXCJvdmVyZmxvd1wiICsgZGlyZWN0aW9uLmEudG9VcHBlckNhc2UoKV0gPSBcInNjcm9sbFwiO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xyXG5cclxuICAgICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pOyAvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXHJcblxyXG4gICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKTtcclxuICAgICAgICBvcHBvc2l0ZVNjcm9sbCA9IHVzZUZpeGVkUG9zaXRpb24gJiYgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGlzVmVydGljYWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCkoKTtcclxuXHJcbiAgICAgICAgaWYgKHBpblNwYWNpbmcpIHtcclxuICAgICAgICAgIHNwYWNlclN0YXRlID0gW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyLCBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldCArIF9weF07XHJcbiAgICAgICAgICBzcGFjZXJTdGF0ZS50ID0gc3BhY2VyO1xyXG4gICAgICAgICAgaSA9IHBpblNwYWNpbmcgPT09IF9wYWRkaW5nID8gX2dldFNpemUocGluLCBkaXJlY3Rpb24pICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgOiAwO1xyXG5cclxuICAgICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICAgIHNwYWNlclN0YXRlLnB1c2goZGlyZWN0aW9uLmQsIGkgKyBfcHgpOyAvLyBmb3IgYm94LXNpemluZzogYm9yZGVyLWJveCAobXVzdCBpbmNsdWRlIHBhZGRpbmcpLlxyXG5cclxuICAgICAgICAgICAgc3BhY2VyLnN0eWxlLmZsZXhCYXNpcyAhPT0gXCJhdXRvXCIgJiYgKHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgPSBpICsgX3B4KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xyXG5cclxuICAgICAgICAgIGlmIChwaW5uZWRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgLy8gaW4gU2Nyb2xsVHJpZ2dlci5yZWZyZXNoKCksIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIHBpbkNvbnRhaW5lcidzIHNpemUgYmVjYXVzZSB0aGlzIHBpblNwYWNpbmcgbWF5IHN0cmV0Y2ggaXQgb3V0LCBidXQgd2UgY2FuJ3QganVzdCBhZGQgdGhlIGV4YWN0IGRpc3RhbmNlIGJlY2F1c2UgZGVwZW5kaW5nIG9uIGxheW91dCwgaXQgbWF5IG5vdCBwdXNoIHRoaW5ncyBkb3duIG9yIGl0IG1heSBvbmx5IGRvIHNvIHBhcnRpYWxseS5cclxuICAgICAgICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICBpZiAodC5waW4gPT09IHBpbm5lZENvbnRhaW5lciAmJiB0LnZhcnMucGluU3BhY2luZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHQuX3N1YlBpbk9mZnNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgPSBfZ2V0U2l6ZShwaW4sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICBpICYmIHNwYWNlci5zdHlsZS5mbGV4QmFzaXMgIT09IFwiYXV0b1wiICYmIChzcGFjZXIuc3R5bGUuZmxleEJhc2lzID0gaSArIF9weCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgb3ZlcnJpZGUgPSB7XHJcbiAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCArIChpc1ZlcnRpY2FsID8gc2Nyb2xsIC0gc3RhcnQgOiBvcHBvc2l0ZVNjcm9sbCkgKyBfcHgsXHJcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgKGlzVmVydGljYWwgPyBvcHBvc2l0ZVNjcm9sbCA6IHNjcm9sbCAtIHN0YXJ0KSArIF9weCxcclxuICAgICAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG92ZXJyaWRlW193aWR0aF0gPSBvdmVycmlkZVtcIm1heFwiICsgX1dpZHRoXSA9IE1hdGguY2VpbChib3VuZHMud2lkdGgpICsgX3B4O1xyXG4gICAgICAgICAgb3ZlcnJpZGVbX2hlaWdodF0gPSBvdmVycmlkZVtcIm1heFwiICsgX0hlaWdodF0gPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCkgKyBfcHg7XHJcbiAgICAgICAgICBvdmVycmlkZVtfbWFyZ2luXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfVG9wXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfUmlnaHRdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Cb3R0b21dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9MZWZ0XSA9IFwiMFwiO1xyXG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmddID0gY3NbX3BhZGRpbmddO1xyXG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfVG9wXSA9IGNzW19wYWRkaW5nICsgX1RvcF07XHJcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9SaWdodF0gPSBjc1tfcGFkZGluZyArIF9SaWdodF07XHJcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Cb3R0b21dID0gY3NbX3BhZGRpbmcgKyBfQm90dG9tXTtcclxuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0xlZnRdID0gY3NbX3BhZGRpbmcgKyBfTGVmdF07XHJcbiAgICAgICAgICBwaW5BY3RpdmVTdGF0ZSA9IF9jb3B5U3RhdGUocGluT3JpZ2luYWxTdGF0ZSwgb3ZlcnJpZGUsIHBpblJlcGFyZW50KTtcclxuICAgICAgICAgIF9yZWZyZXNoaW5nQWxsICYmIHNjcm9sbEZ1bmMoMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIG1pZ2h0IGJlIGFmZmVjdGluZyB0aGUgdHJhbnNmb3JtLCBzbyB3ZSBtdXN0IGp1bXAgdG8gdGhlIGVuZCwgY2hlY2sgdGhlIHZhbHVlLCBhbmQgY29tcGVuc2F0ZSBhY2NvcmRpbmdseS4gT3RoZXJ3aXNlLCB3aGVuIGl0IGJlY29tZXMgdW5waW5uZWQsIHRoZSBwaW5TZXR0ZXIoKSB3aWxsIGdldCBzZXQgdG8gYSB2YWx1ZSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB3aGF0ZXZlciB0aGUgYW5pbWF0aW9uIGRpZC5cclxuICAgICAgICAgIGluaXR0ZWQgPSBhbmltYXRpb24uX2luaXR0ZWQ7IC8vIGlmIG5vdCwgd2UgbXVzdCBpbnZhbGlkYXRlKCkgYWZ0ZXIgdGhpcyBzdGVwLCBvdGhlcndpc2UgaXQgY291bGQgbG9jayBpbiBzdGFydGluZyB2YWx1ZXMgcHJlbWF0dXJlbHkuXHJcblxyXG4gICAgICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcygxKTtcclxuXHJcbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgIHBpbkNoYW5nZSA9IHBpbkdldHRlcihkaXJlY3Rpb24uYSkgLSBwaW5TdGFydCArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0O1xyXG4gICAgICAgICAgcGluTW92ZXMgPSBNYXRoLmFicyhjaGFuZ2UgLSBwaW5DaGFuZ2UpID4gMTtcclxuICAgICAgICAgIHVzZUZpeGVkUG9zaXRpb24gJiYgcGluTW92ZXMgJiYgcGluQWN0aXZlU3RhdGUuc3BsaWNlKHBpbkFjdGl2ZVN0YXRlLmxlbmd0aCAtIDIsIDIpOyAvLyB0cmFuc2Zvcm0gaXMgdGhlIGxhc3QgcHJvcGVydHkvdmFsdWUgc2V0IGluIHRoZSBzdGF0ZSBBcnJheS4gU2luY2UgdGhlIGFuaW1hdGlvbiBpcyBjb250cm9sbGluZyB0aGF0LCB3ZSBzaG91bGQgb21pdCBpdC5cclxuXHJcbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgaW5pdHRlZCB8fCBhbmltYXRpb24uaW52YWxpZGF0ZSh0cnVlKTtcclxuICAgICAgICAgIGFuaW1hdGlvbi5wYXJlbnQgfHwgYW5pbWF0aW9uLnRvdGFsVGltZShhbmltYXRpb24udG90YWxUaW1lKCkpOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGEgdG9nZ2xlQWN0aW9uIGNhbGxlZCBwbGF5KCkgYW5kIHRoZW4gcmVmcmVzaCgpIGhhcHBlbnMgYW5kIHdoZW4gd2UgcmVuZGVyKDEpIGFib3ZlLCBpdCB3b3VsZCBjYXVzZSB0aGUgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIGFuZCBnZXQgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQsIHNvIHRoaXMgbWFrZXMgc3VyZSBpdCBnZXRzIHB1dCBiYWNrIGluLlxyXG5cclxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBpbkNoYW5nZSA9IGNoYW5nZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcmNlZE92ZXJmbG93ICYmIChmb3JjZWRPdmVyZmxvdy52YWx1ZSA/IGZvcmNlZE92ZXJmbG93LnN0eWxlW1wib3ZlcmZsb3dcIiArIGRpcmVjdGlvbi5hLnRvVXBwZXJDYXNlKCldID0gZm9yY2VkT3ZlcmZsb3cudmFsdWUgOiBmb3JjZWRPdmVyZmxvdy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm92ZXJmbG93LVwiICsgZGlyZWN0aW9uLmEpKTtcclxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICYmIHNjcm9sbEZ1bmMoKSAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgLy8gaXQgbWF5IGJlIElOU0lERSBhIHBpbm5lZCBlbGVtZW50LCBzbyB3YWxrIHVwIHRoZSB0cmVlIGFuZCBsb29rIGZvciBhbnkgZWxlbWVudHMgd2l0aCBfcGluT2Zmc2V0IHRvIGNvbXBlbnNhdGUgYmVjYXVzZSBhbnl0aGluZyB3aXRoIHBpblNwYWNpbmcgdGhhdCdzIGFscmVhZHkgc2Nyb2xsZWQgd291bGQgdGhyb3cgb2ZmIHRoZSBtZWFzdXJlbWVudHMgaW4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgICBib3VuZHMgPSB0cmlnZ2VyLnBhcmVudE5vZGU7XHJcblxyXG4gICAgICAgIHdoaWxlIChib3VuZHMgJiYgYm91bmRzICE9PSBfYm9keSkge1xyXG4gICAgICAgICAgaWYgKGJvdW5kcy5fcGluT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0IC09IGJvdW5kcy5fcGluT2Zmc2V0O1xyXG4gICAgICAgICAgICBlbmQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXZlcnRlZFBpbnMgJiYgcmV2ZXJ0ZWRQaW5zLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICByZXR1cm4gdC5yZXZlcnQoZmFsc2UsIHRydWUpO1xyXG4gICAgICB9KTtcclxuICAgICAgc2VsZi5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICBzZWxmLmVuZCA9IGVuZDtcclxuICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBfcmVmcmVzaGluZ0FsbCA/IHByZXZTY3JvbGwgOiBzY3JvbGxGdW5jKCk7IC8vIHJlc2V0IHZlbG9jaXR5XHJcblxyXG4gICAgICBpZiAoIWNvbnRhaW5lckFuaW1hdGlvbiAmJiAhX3JlZnJlc2hpbmdBbGwpIHtcclxuICAgICAgICBzY3JvbGwxIDwgcHJldlNjcm9sbCAmJiBzY3JvbGxGdW5jKHByZXZTY3JvbGwpO1xyXG4gICAgICAgIHNlbGYuc2Nyb2xsLnJlYyA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNlbGYucmV2ZXJ0KGZhbHNlLCB0cnVlKTtcclxuICAgICAgbGFzdFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xyXG5cclxuICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xyXG4gICAgICAgIGxhc3RTbmFwID0gLTE7IC8vIGp1c3Qgc28gc25hcHBpbmcgZ2V0cyByZS1lbmFibGVkLCBjbGVhciBvdXQgYW55IHJlY29yZGVkIGxhc3QgdmFsdWVcclxuICAgICAgICAvLyBzZWxmLmlzQWN0aXZlICYmIHNjcm9sbEZ1bmMoc3RhcnQgKyBjaGFuZ2UgKiBwcmV2UHJvZ3Jlc3MpOyAvLyBwcmV2aW91c2x5IHRoaXMgbGluZSB3YXMgaGVyZSB0byBlbnN1cmUgdGhhdCB3aGVuIHNuYXBwaW5nIGtpY2tzIGluLCBpdCdzIGZyb20gdGhlIHByZXZpb3VzIHByb2dyZXNzIGJ1dCBpbiBzb21lIGNhc2VzIHRoYXQncyBub3QgZGVzaXJhYmxlLCBsaWtlIGFuIGFsbC1wYWdlIFNjcm9sbFRyaWdnZXIgd2hlbiBuZXcgY29udGVudCBnZXRzIGFkZGVkIHRvIHRoZSBwYWdlLCB0aGF0J2QgdG90YWxseSBjaGFuZ2UgdGhlIHByb2dyZXNzLlxyXG5cclxuICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3JlZnJlc2hpbmcgPSAwO1xyXG4gICAgICBhbmltYXRpb24gJiYgaXNUb2dnbGUgJiYgKGFuaW1hdGlvbi5faW5pdHRlZCB8fCBwcmV2QW5pbVByb2dyZXNzKSAmJiBhbmltYXRpb24ucHJvZ3Jlc3MoKSAhPT0gcHJldkFuaW1Qcm9ncmVzcyAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocHJldkFuaW1Qcm9ncmVzcyB8fCAwLCB0cnVlKS5yZW5kZXIoYW5pbWF0aW9uLnRpbWUoKSwgdHJ1ZSwgdHJ1ZSk7IC8vIG11c3QgZm9yY2UgYSByZS1yZW5kZXIgYmVjYXVzZSBpZiBzYXZlU3R5bGVzKCkgd2FzIHVzZWQgb24gdGhlIHRhcmdldChzKSwgdGhlIHN0eWxlcyBjb3VsZCBoYXZlIGJlZW4gd2lwZWQgb3V0IGR1cmluZyB0aGUgcmVmcmVzaCgpLlxyXG5cclxuICAgICAgaWYgKGlzRmlyc3RSZWZyZXNoIHx8IHByZXZQcm9ncmVzcyAhPT0gc2VsZi5wcm9ncmVzcyB8fCBjb250YWluZXJBbmltYXRpb24gfHwgaW52YWxpZGF0ZU9uUmVmcmVzaCB8fCBhbmltYXRpb24gJiYgIWFuaW1hdGlvbi5faW5pdHRlZCkge1xyXG4gICAgICAgIC8vIGVuc3VyZXMgdGhhdCB0aGUgZGlyZWN0aW9uIGlzIHNldCBwcm9wZXJseSAod2hlbiByZWZyZXNoaW5nLCBwcm9ncmVzcyBpcyBzZXQgYmFjayB0byAwIGluaXRpYWxseSwgdGhlbiBiYWNrIGFnYWluIHRvIHdoZXJldmVyIGl0IG5lZWRzIHRvIGJlKSBhbmQgdGhhdCBjYWxsYmFja3MgYXJlIHRyaWdnZXJlZC5cclxuICAgICAgICBhbmltYXRpb24gJiYgIWlzVG9nZ2xlICYmIChhbmltYXRpb24uX2luaXR0ZWQgfHwgcHJldlByb2dyZXNzIHx8IGFuaW1hdGlvbi52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpICYmIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBzdGFydCA8IC0wLjAwMSAmJiAhcHJldlByb2dyZXNzID8gZ3NhcC51dGlscy5ub3JtYWxpemUoc3RhcnQsIGVuZCwgMCkgOiBwcmV2UHJvZ3Jlc3MsIHRydWUpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2hlcmUgYW5pbWF0aW9uIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQgYXJlbid0IHRyaWdnZXJlZC5cclxuXHJcbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IGlzRmlyc3RSZWZyZXNoIHx8IChzY3JvbGwxIC0gc3RhcnQpIC8gY2hhbmdlID09PSBwcmV2UHJvZ3Jlc3MgPyAwIDogcHJldlByb2dyZXNzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwaW4gJiYgcGluU3BhY2luZyAmJiAoc3BhY2VyLl9waW5PZmZzZXQgPSBNYXRoLnJvdW5kKHNlbGYucHJvZ3Jlc3MgKiBwaW5DaGFuZ2UpKTtcclxuICAgICAgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLmludmFsaWRhdGUoKTtcclxuXHJcbiAgICAgIGlmICghaXNOYU4obWFya2VyU3RhcnRPZmZzZXQpKSB7XHJcbiAgICAgICAgLy8gbnVtYmVycyB3ZXJlIHBhc3NlZCBpbiBmb3IgdGhlIHBvc2l0aW9uIHdoaWNoIGFyZSBhYnNvbHV0ZSwgc28gaW5zdGVhZCBvZiBqdXN0IHB1dHRpbmcgdGhlIG1hcmtlcnMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSB2aWV3cG9ydCwgd2UgZmlndXJlIG91dCBob3cgZmFyIHRoZXkgc2hpZnRlZCBkb3duIChpdCdzIHNhZmUgdG8gYXNzdW1lIHRoZXkgd2VyZSBvcmlnaW5hbGx5IHBvc2l0aW9uZWQgaW4gY2xvc2VyIHJlbGF0aW9uIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnQgd2l0aCB2YWx1ZXMgbGlrZSBcInRvcFwiLCBcImNlbnRlclwiLCBhIHBlcmNlbnRhZ2Ugb3Igd2hhdGV2ZXIsIHNvIHdlIG9mZnNldCB0aGF0IG11Y2ggaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byBiYXNpY2FsbHkgcmV2ZXJ0IHRoZW0gdG8gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRoeSB3ZXJlIGF0IHByZXZpb3VzbHkuXHJcbiAgICAgICAgbWFya2VyU3RhcnRPZmZzZXQgLT0gZ3NhcC5nZXRQcm9wZXJ0eShtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5wKTtcclxuICAgICAgICBtYXJrZXJFbmRPZmZzZXQgLT0gZ3NhcC5nZXRQcm9wZXJ0eShtYXJrZXJFbmRUcmlnZ2VyLCBkaXJlY3Rpb24ucCk7XHJcblxyXG4gICAgICAgIF9zaGlmdE1hcmtlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQpO1xyXG5cclxuICAgICAgICBfc2hpZnRNYXJrZXIobWFya2VyU3RhcnQsIGRpcmVjdGlvbiwgbWFya2VyU3RhcnRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcclxuXHJcbiAgICAgICAgX3NoaWZ0TWFya2VyKG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbiwgbWFya2VyRW5kT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgX3NoaWZ0TWFya2VyKG1hcmtlckVuZCwgZGlyZWN0aW9uLCBtYXJrZXJFbmRPZmZzZXQgLSAocGluT2Zmc2V0IHx8IDApKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaXNGaXJzdFJlZnJlc2ggJiYgIV9yZWZyZXNoaW5nQWxsICYmIHNlbGYudXBkYXRlKCk7IC8vIGVkZ2UgY2FzZSAtIHdoZW4geW91IHJlbG9hZCBhIHBhZ2Ugd2hlbiBpdCdzIGFscmVhZHkgc2Nyb2xsZWQgZG93biwgc29tZSBicm93c2VycyBmaXJlIGEgXCJzY3JvbGxcIiBldmVudCBiZWZvcmUgRE9NQ29udGVudExvYWRlZCwgdHJpZ2dlcmluZyBhbiB1cGRhdGVBbGwoKS4gSWYgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzZWxmLnByb2dyZXNzIGFzIHBhcnQgb2YgcmVmcmVzaCgpLCB0aGVuIHdoZW4gaXQgaGFwcGVucyBuZXh0LCBpdCBtYXkgcmVjb3JkIHByZXZQcm9ncmVzcyBhcyAwIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndCwgcG90ZW50aWFsbHkgY2F1c2luZyBhIGNhbGxiYWNrIGluIGFuIGFuaW1hdGlvbiB0byBmaXJlIGFnYWluLlxyXG5cclxuICAgICAgaWYgKG9uUmVmcmVzaCAmJiAhX3JlZnJlc2hpbmdBbGwgJiYgIWV4ZWN1dGluZ09uUmVmcmVzaCkge1xyXG4gICAgICAgIC8vIHdoZW4gcmVmcmVzaGluZyBhbGwsIHdlIGRvIGV4dHJhIHdvcmsgdG8gY29ycmVjdCBwaW5uZWRDb250YWluZXIgc2l6ZXMgYW5kIGVuc3VyZSB0aGluZ3MgZG9uJ3QgZXhjZWVkIHRoZSBtYXhTY3JvbGwsIHNvIHdlIHNob3VsZCBkbyBhbGwgdGhlIHJlZnJlc2hlcyBhdCB0aGUgZW5kIGFmdGVyIGFsbCB0aGF0IHdvcmsgc28gdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBhcmUgY29ycmVjdGVkLlxyXG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCA9IHRydWU7XHJcbiAgICAgICAgb25SZWZyZXNoKHNlbGYpO1xyXG4gICAgICAgIGV4ZWN1dGluZ09uUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAoc2Nyb2xsRnVuYygpIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiAxMDAwIHx8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5kQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xyXG5cclxuICAgICAgaWYgKGFuaW1hdGlvbikge1xyXG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogIWFuaW1hdGlvbi5wYXVzZWQoKSA/IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24ucmV2ZXJzZWQoKSkgOiBpc1RvZ2dsZSB8fCBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgc2VsZi5kaXJlY3Rpb24gPCAwLCAxKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmxhYmVsVG9TY3JvbGwgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ubGFiZWxzICYmIChzdGFydCB8fCBzZWxmLnJlZnJlc2goKSB8fCBzdGFydCkgKyBhbmltYXRpb24ubGFiZWxzW2xhYmVsXSAvIGFuaW1hdGlvbi5kdXJhdGlvbigpICogY2hhbmdlIHx8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZ2V0VHJhaWxpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpLFxyXG4gICAgICAgICAgYSA9IHNlbGYuZGlyZWN0aW9uID4gMCA/IF90cmlnZ2Vycy5zbGljZSgwLCBpKS5yZXZlcnNlKCkgOiBfdHJpZ2dlcnMuc2xpY2UoaSArIDEpO1xyXG5cclxuICAgICAgcmV0dXJuIChfaXNTdHJpbmcobmFtZSkgPyBhLmZpbHRlcihmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIHJldHVybiB0LnZhcnMucHJldmVudE92ZXJsYXBzID09PSBuYW1lO1xyXG4gICAgICB9KSA6IGEpLmZpbHRlcihmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmRpcmVjdGlvbiA+IDAgPyB0LmVuZCA8PSBzdGFydCA6IHQuc3RhcnQgPj0gZW5kO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAocmVzZXQsIHJlY29yZFZlbG9jaXR5LCBmb3JjZUZha2UpIHtcclxuICAgICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiAhZm9yY2VGYWtlICYmICFyZXNldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNjcm9sbCA9IF9yZWZyZXNoaW5nQWxsID09PSB0cnVlID8gcHJldlNjcm9sbCA6IHNlbGYuc2Nyb2xsKCksXHJcbiAgICAgICAgICBwID0gcmVzZXQgPyAwIDogKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcclxuICAgICAgICAgIGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXHJcbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzLFxyXG4gICAgICAgICAgaXNBY3RpdmUsXHJcbiAgICAgICAgICB3YXNBY3RpdmUsXHJcbiAgICAgICAgICB0b2dnbGVTdGF0ZSxcclxuICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgIHN0YXRlQ2hhbmdlZCxcclxuICAgICAgICAgIHRvZ2dsZWQsXHJcbiAgICAgICAgICBpc0F0TWF4LFxyXG4gICAgICAgICAgaXNUYWtpbmdBY3Rpb247XHJcblxyXG4gICAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcclxuICAgICAgICBzY3JvbGwyID0gc2Nyb2xsMTtcclxuICAgICAgICBzY3JvbGwxID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsRnVuYygpIDogc2Nyb2xsO1xyXG5cclxuICAgICAgICBpZiAoc25hcCkge1xyXG4gICAgICAgICAgc25hcDIgPSBzbmFwMTtcclxuICAgICAgICAgIHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyBhbnRpY2lwYXRlIHRoZSBwaW5uaW5nIGEgZmV3IHRpY2tzIGFoZWFkIG9mIHRpbWUgYmFzZWQgb24gdmVsb2NpdHkgdG8gYXZvaWQgYSB2aXN1YWwgZ2xpdGNoIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG1vc3QgYnJvd3NlcnMgZG8gc2Nyb2xsaW5nIG9uIGEgc2VwYXJhdGUgdGhyZWFkIChub3Qgc3luY2VkIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS5cclxuXHJcblxyXG4gICAgICBpZiAoYW50aWNpcGF0ZVBpbiAmJiBwaW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBfbGFzdFNjcm9sbFRpbWUpIHtcclxuICAgICAgICBpZiAoIWNsaXBwZWQgJiYgc3RhcnQgPCBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluKSB7XHJcbiAgICAgICAgICBjbGlwcGVkID0gMC4wMDAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2xpcHBlZCA9PT0gMSAmJiBlbmQgPiBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluKSB7XHJcbiAgICAgICAgICBjbGlwcGVkID0gMC45OTk5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNsaXBwZWQgIT09IHByZXZQcm9ncmVzcyAmJiBzZWxmLmVuYWJsZWQpIHtcclxuICAgICAgICBpc0FjdGl2ZSA9IHNlbGYuaXNBY3RpdmUgPSAhIWNsaXBwZWQgJiYgY2xpcHBlZCA8IDE7XHJcbiAgICAgICAgd2FzQWN0aXZlID0gISFwcmV2UHJvZ3Jlc3MgJiYgcHJldlByb2dyZXNzIDwgMTtcclxuICAgICAgICB0b2dnbGVkID0gaXNBY3RpdmUgIT09IHdhc0FjdGl2ZTtcclxuICAgICAgICBzdGF0ZUNoYW5nZWQgPSB0b2dnbGVkIHx8ICEhY2xpcHBlZCAhPT0gISFwcmV2UHJvZ3Jlc3M7IC8vIGNvdWxkIGdvIGZyb20gc3RhcnQgYWxsIHRoZSB3YXkgdG8gZW5kLCB0aHVzIGl0IGRpZG4ndCB0b2dnbGUgYnV0IGl0IGRpZCBjaGFuZ2Ugc3RhdGUgaW4gYSBzZW5zZSAobWF5IG5lZWQgdG8gZmlyZSBhIGNhbGxiYWNrKVxyXG5cclxuICAgICAgICBzZWxmLmRpcmVjdGlvbiA9IGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgPyAxIDogLTE7XHJcbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IGNsaXBwZWQ7XHJcblxyXG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZWQgJiYgIV9yZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICB0b2dnbGVTdGF0ZSA9IGNsaXBwZWQgJiYgIXByZXZQcm9ncmVzcyA/IDAgOiBjbGlwcGVkID09PSAxID8gMSA6IHByZXZQcm9ncmVzcyA9PT0gMSA/IDIgOiAzOyAvLyAwID0gZW50ZXIsIDEgPSBsZWF2ZSwgMiA9IGVudGVyQmFjaywgMyA9IGxlYXZlQmFjayAod2UgcHJpb3JpdGl6ZSB0aGUgRklSU1QgZW5jb3VudGVyLCB0aHVzIGlmIHlvdSBzY3JvbGwgcmVhbGx5IGZhc3QgcGFzdCB0aGUgb25FbnRlciBhbmQgb25MZWF2ZSBpbiBvbmUgdGljaywgaXQnZCBwcmlvcml0aXplIG9uRW50ZXIuXHJcblxyXG4gICAgICAgICAgaWYgKGlzVG9nZ2xlKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbiA9ICF0b2dnbGVkICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSAhPT0gXCJub25lXCIgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdIHx8IHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGVdOyAvLyBpZiBpdCBkaWRuJ3QgdG9nZ2xlLCB0aGF0IG1lYW5zIGl0IHNob3QgcmlnaHQgcGFzdCBhbmQgc2luY2Ugd2UgcHJpb3JpdGl6ZSB0aGUgXCJlbnRlclwiIGFjdGlvbiwgd2Ugc2hvdWxkIHN3aXRjaCB0byB0aGUgXCJsZWF2ZVwiIGluIHRoaXMgY2FzZSAoYnV0IG9ubHkgaWYgb25lIGlzIGRlZmluZWQpXHJcblxyXG4gICAgICAgICAgICBpc1Rha2luZ0FjdGlvbiA9IGFuaW1hdGlvbiAmJiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIgfHwgYWN0aW9uID09PSBcInJlc2V0XCIgfHwgYWN0aW9uIGluIGFuaW1hdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgJiYgKHRvZ2dsZWQgfHwgaXNUYWtpbmdBY3Rpb24pICYmIChpc1Rha2luZ0FjdGlvbiB8fCBzY3J1YiB8fCAhYW5pbWF0aW9uKSAmJiAoX2lzRnVuY3Rpb24ocHJldmVudE92ZXJsYXBzKSA/IHByZXZlbnRPdmVybGFwcyhzZWxmKSA6IHNlbGYuZ2V0VHJhaWxpbmcocHJldmVudE92ZXJsYXBzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICByZXR1cm4gdC5lbmRBbmltYXRpb24oKTtcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGlmICghaXNUb2dnbGUpIHtcclxuICAgICAgICAgIGlmIChzY3J1YlR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXApIHtcclxuICAgICAgICAgICAgc2NydWJUd2Vlbi5fZHAuX3RpbWUgLSBzY3J1YlR3ZWVuLl9zdGFydCAhPT0gc2NydWJUd2Vlbi5fdGltZSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxyXG5cclxuICAgICAgICAgICAgaWYgKHNjcnViVHdlZW4ucmVzZXRUbykge1xyXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gbGVnYWN5IHN1cHBvcnQgKGNvdXJ0ZXN5KSwgYmVmb3JlIDMuMTAuMFxyXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcclxuICAgICAgICAgICAgICBzY3J1YlR3ZWVuLmludmFsaWRhdGUoKS5yZXN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKGNsaXBwZWQsICEhKF9yZWZyZXNoaW5nICYmIChsYXN0UmVmcmVzaCB8fCByZXNldCkpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwaW4pIHtcclxuICAgICAgICAgIHJlc2V0ICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5zdHlsZVtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl0gPSBzcGFjaW5nU3RhcnQpO1xyXG5cclxuICAgICAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBwaW5TZXR0ZXIoX3JvdW5kKHBpblN0YXJ0ICsgcGluQ2hhbmdlICogY2xpcHBlZCkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgaXNBdE1heCA9ICFyZXNldCAmJiBjbGlwcGVkID4gcHJldlByb2dyZXNzICYmIGVuZCArIDEgPiBzY3JvbGwgJiYgc2Nyb2xsICsgMSA+PSBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pOyAvLyBpZiBpdCdzIGF0IHRoZSBWRVJZIGVuZCBvZiB0aGUgcGFnZSwgZG9uJ3Qgc3dpdGNoIGF3YXkgZnJvbSBwb3NpdGlvbjogZml4ZWQgYmVjYXVzZSBpdCdzIHBvaW50bGVzcyBhbmQgaXQgY291bGQgY2F1c2UgYSBicmllZiBmbGFzaCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgYmFjayB1cCAod2hlbiBpdCBnZXRzIHBpbm5lZCBhZ2FpbilcclxuXHJcbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xyXG4gICAgICAgICAgICAgIGlmICghcmVzZXQgJiYgKGlzQWN0aXZlIHx8IGlzQXRNYXgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBfYm9keSwgYm91bmRzLnRvcCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9vZmZzZXQgOiAwKSArIF9weCwgYm91bmRzLmxlZnQgKyAoZGlyZWN0aW9uID09PSBfdmVydGljYWwgPyAwIDogX29mZnNldCkgKyBfcHgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfcmVwYXJlbnQocGluLCBzcGFjZXIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3NldFN0YXRlKGlzQWN0aXZlIHx8IGlzQXRNYXggPyBwaW5BY3RpdmVTdGF0ZSA6IHBpblN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgIHBpbk1vdmVzICYmIGNsaXBwZWQgPCAxICYmIGlzQWN0aXZlIHx8IHBpblNldHRlcihwaW5TdGFydCArIChjbGlwcGVkID09PSAxICYmICFpc0F0TWF4ID8gcGluQ2hhbmdlIDogMCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc25hcCAmJiAhdHdlZW5Uby50d2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwICYmIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IG9uY2UgJiYgY2xpcHBlZCAmJiAoY2xpcHBlZCA8IDEgfHwgIV9saW1pdENhbGxiYWNrcykpICYmIF90b0FycmF5KHRvZ2dsZUNsYXNzLnRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0W2lzQWN0aXZlIHx8IG9uY2UgPyBcImFkZFwiIDogXCJyZW1vdmVcIl0odG9nZ2xlQ2xhc3MuY2xhc3NOYW1lKTtcclxuICAgICAgICB9KTsgLy8gY2xhc3NlcyBjb3VsZCBhZmZlY3QgcG9zaXRpb25pbmcsIHNvIGRvIGl0IGV2ZW4gaWYgcmVzZXQgb3IgcmVmcmVzaGluZyBpcyB0cnVlLlxyXG5cclxuICAgICAgICBvblVwZGF0ZSAmJiAhaXNUb2dnbGUgJiYgIXJlc2V0ICYmIG9uVXBkYXRlKHNlbGYpO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xyXG4gICAgICAgICAgaWYgKGlzVG9nZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Rha2luZ0FjdGlvbikge1xyXG4gICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnBhdXNlKCkudG90YWxQcm9ncmVzcygxKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXNldFwiKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc3RhcnRcIikge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnJlc3RhcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblthY3Rpb25dKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvblVwZGF0ZSAmJiBvblVwZGF0ZShzZWxmKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodG9nZ2xlZCB8fCAhX2xpbWl0Q2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIC8vIG9uIHN0YXJ0dXAsIHRoZSBwYWdlIGNvdWxkIGJlIHNjcm9sbGVkIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgY2FsbGJhY2tzIHRoYXQgZGlkbid0IHRvZ2dsZS4gRm9yIGV4YW1wbGUgb25FbnRlciBzaG91bGRuJ3QgZmlyZSBpZiB0aGUgU2Nyb2xsVHJpZ2dlciBpc24ndCBhY3R1YWxseSBlbnRlcmVkLlxyXG4gICAgICAgICAgICBvblRvZ2dsZSAmJiB0b2dnbGVkICYmIF9jYWxsYmFjayhzZWxmLCBvblRvZ2dsZSk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gJiYgX2NhbGxiYWNrKHNlbGYsIGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0pO1xyXG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cclxuXHJcbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xyXG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXHJcbiAgICAgICAgICAgICAgdG9nZ2xlU3RhdGUgPSBjbGlwcGVkID09PSAxID8gMSA6IDM7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZmFzdFNjcm9sbEVuZCAmJiAhaXNBY3RpdmUgJiYgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA+IChfaXNOdW1iZXIoZmFzdFNjcm9sbEVuZCkgPyBmYXN0U2Nyb2xsRW5kIDogMjUwMCkpIHtcclxuICAgICAgICAgICAgX2VuZEFuaW1hdGlvbihzZWxmLmNhbGxiYWNrQW5pbWF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIGFjdGlvbiA9PT0gXCJyZXZlcnNlXCIgPyAxIDogIWNsaXBwZWQsIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICBvblVwZGF0ZShzZWxmKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXHJcblxyXG5cclxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xyXG4gICAgICAgIHZhciBuID0gY29udGFpbmVyQW5pbWF0aW9uID8gc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkgOiBzY3JvbGw7XHJcbiAgICAgICAgbWFya2VyU3RhcnRTZXR0ZXIobiArIChtYXJrZXJTdGFydFRyaWdnZXIuX2lzRmxpcHBlZCA/IDEgOiAwKSk7XHJcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xyXG4gICAgICBpZiAoIXNlbGYuZW5hYmxlZCkge1xyXG4gICAgICAgIHNlbGYuZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcclxuXHJcbiAgICAgICAgaXNWaWV3cG9ydCB8fCBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XHJcbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcclxuXHJcbiAgICAgICAgaWYgKHJlc2V0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHByZXZQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICBzY3JvbGwxID0gc2Nyb2xsMiA9IGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVmcmVzaCAhPT0gZmFsc2UgJiYgc2VsZi5yZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5nZXRUd2VlbiA9IGZ1bmN0aW9uIChzbmFwKSB7XHJcbiAgICAgIHJldHVybiBzbmFwICYmIHR3ZWVuVG8gPyB0d2VlblRvLnR3ZWVuIDogc2NydWJUd2VlbjtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAobmV3U3RhcnQsIG5ld0VuZCwga2VlcENsYW1wLCBwaW5PZmZzZXQpIHtcclxuICAgICAgLy8gZG9lc24ndCBwZXJzaXN0IGFmdGVyIHJlZnJlc2goKSEgSW50ZW5kZWQgdG8gYmUgYSB3YXkgdG8gb3ZlcnJpZGUgdmFsdWVzIHRoYXQgd2VyZSBzZXQgZHVyaW5nIHJlZnJlc2goKSwgbGlrZSB5b3UgY291bGQgc2V0IGl0IGluIG9uUmVmcmVzaCgpXHJcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcclxuICAgICAgICAvLyBjb252ZXJ0IHJhdGlvcyBpbnRvIHNjcm9sbCBwb3NpdGlvbnMuIFJlbWVtYmVyLCBzdGFydC9lbmQgdmFsdWVzIG9uIFNjcm9sbFRyaWdnZXJzIHRoYXQgaGF2ZSBhIGNvbnRhaW5lckFuaW1hdGlvbiByZWZlciB0byB0aGUgdGltZSAoaW4gc2Vjb25kcyksIE5PVCBzY3JvbGwgcG9zaXRpb25zLlxyXG4gICAgICAgIHZhciBzdCA9IGNvbnRhaW5lckFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLFxyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpLFxyXG4gICAgICAgICAgICBfY2hhbmdlID0gc3QuZW5kIC0gc3Quc3RhcnQ7XHJcblxyXG4gICAgICAgIG5ld1N0YXJ0ID0gc3Quc3RhcnQgKyBfY2hhbmdlICogbmV3U3RhcnQgLyBkdXJhdGlvbjtcclxuICAgICAgICBuZXdFbmQgPSBzdC5zdGFydCArIF9jaGFuZ2UgKiBuZXdFbmQgLyBkdXJhdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5yZWZyZXNoKGZhbHNlLCBmYWxzZSwge1xyXG4gICAgICAgIHN0YXJ0OiBfa2VlcENsYW1wKG5ld1N0YXJ0LCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9zdGFydENsYW1wKSxcclxuICAgICAgICBlbmQ6IF9rZWVwQ2xhbXAobmV3RW5kLCBrZWVwQ2xhbXAgJiYgISFzZWxmLl9lbmRDbGFtcClcclxuICAgICAgfSwgcGluT2Zmc2V0KTtcclxuICAgICAgc2VsZi51cGRhdGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5hZGp1c3RQaW5TcGFjaW5nID0gZnVuY3Rpb24gKGFtb3VudCkge1xyXG4gICAgICBpZiAoc3BhY2VyU3RhdGUgJiYgYW1vdW50KSB7XHJcbiAgICAgICAgdmFyIGkgPSBzcGFjZXJTdGF0ZS5pbmRleE9mKGRpcmVjdGlvbi5kKSArIDE7XHJcbiAgICAgICAgc3BhY2VyU3RhdGVbaV0gPSBwYXJzZUZsb2F0KHNwYWNlclN0YXRlW2ldKSArIGFtb3VudCArIF9weDtcclxuICAgICAgICBzcGFjZXJTdGF0ZVsxXSA9IHBhcnNlRmxvYXQoc3BhY2VyU3RhdGVbMV0pICsgYW1vdW50ICsgX3B4O1xyXG5cclxuICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgYWxsb3dBbmltYXRpb24pIHtcclxuICAgICAgaWYgKHNlbGYuZW5hYmxlZCkge1xyXG4gICAgICAgIHJlc2V0ICE9PSBmYWxzZSAmJiBzZWxmLnJldmVydCh0cnVlLCB0cnVlKTtcclxuICAgICAgICBzZWxmLmVuYWJsZWQgPSBzZWxmLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgYWxsb3dBbmltYXRpb24gfHwgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XHJcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XHJcbiAgICAgICAgcGluQ2FjaGUgJiYgKHBpbkNhY2hlLnVuY2FjaGUgPSAxKTtcclxuICAgICAgICBvblJlZnJlc2hJbml0ICYmIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hJbml0XCIsIG9uUmVmcmVzaEluaXQpO1xyXG5cclxuICAgICAgICBpZiAoc25hcERlbGF5ZWRDYWxsKSB7XHJcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucGF1c2UoKTtcclxuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCkgJiYgKHR3ZWVuVG8udHdlZW4gPSAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNWaWV3cG9ydCkge1xyXG4gICAgICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgaWYgKF90cmlnZ2Vyc1tpXS5zY3JvbGxlciA9PT0gc2Nyb2xsZXIgJiYgX3RyaWdnZXJzW2ldICE9PSBzZWxmKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuOyAvL2Rvbid0IHJlbW92ZSB0aGUgbGlzdGVuZXJzIGlmIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB0cmlnZ2VycyByZWZlcmVuY2luZyBpdC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcclxuXHJcbiAgICAgICAgICBpc1ZpZXdwb3J0IHx8IF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dBbmltYXRpb24pIHtcclxuICAgICAgc2VsZi5kaXNhYmxlKHJldmVydCwgYWxsb3dBbmltYXRpb24pO1xyXG4gICAgICBzY3J1YlR3ZWVuICYmICFhbGxvd0FuaW1hdGlvbiAmJiBzY3J1YlR3ZWVuLmtpbGwoKTtcclxuICAgICAgaWQgJiYgZGVsZXRlIF9pZHNbaWRdO1xyXG5cclxuICAgICAgdmFyIGkgPSBfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKTtcclxuXHJcbiAgICAgIGkgPj0gMCAmJiBfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICBpID09PSBfaSAmJiBfZGlyZWN0aW9uID4gMCAmJiBfaS0tOyAvLyBpZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVmcmVzaCgpIG9yIHVwZGF0ZSgpLCBzcGxpY2luZyB3b3VsZCBjYXVzZSBza2lwcyBpbiB0aGUgaW5kZXgsIHNvIGFkanVzdC4uLlxyXG4gICAgICAvLyBpZiBubyBvdGhlciBTY3JvbGxUcmlnZ2VyIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBzY3JvbGxlciBhcmUgZm91bmQsIHdpcGUgb3V0IGFueSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb24uIE90aGVyd2lzZSwgaW4gYSBzaW5nbGUgcGFnZSBhcHBsaWNhdGlvbiwgZm9yIGV4YW1wbGUsIGl0IGNvdWxkIG1haW50YWluIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IHJlYWxseSBzaG91bGRuJ3QuXHJcblxyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHQuc2Nyb2xsZXIgPT09IHNlbGYuc2Nyb2xsZXIgJiYgKGkgPSAxKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpIHx8IF9yZWZyZXNoaW5nQWxsIHx8IChzZWxmLnNjcm9sbC5yZWMgPSAwKTtcclxuXHJcbiAgICAgIGlmIChhbmltYXRpb24pIHtcclxuICAgICAgICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciA9IG51bGw7XHJcbiAgICAgICAgcmV2ZXJ0ICYmIGFuaW1hdGlvbi5yZXZlcnQoe1xyXG4gICAgICAgICAga2lsbDogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBhbmltYXRpb24ua2lsbCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgcmV0dXJuIG0ucGFyZW50Tm9kZSAmJiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBfcHJpbWFyeSA9PT0gc2VsZiAmJiAoX3ByaW1hcnkgPSAwKTtcclxuXHJcbiAgICAgIGlmIChwaW4pIHtcclxuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xyXG4gICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgcmV0dXJuIHQucGluID09PSBwaW4gJiYgaSsrO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpIHx8IChwaW5DYWNoZS5zcGFjZXIgPSAwKTsgLy8gaWYgdGhlcmUgYXJlbid0IGFueSBtb3JlIFNjcm9sbFRyaWdnZXJzIHdpdGggdGhlIHNhbWUgcGluLCByZW1vdmUgdGhlIHNwYWNlciwgb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGNvbnRhbWluYXRlZCB3aXRoIG9sZC9zdGFsZSB2YWx1ZXMgaWYgdGhlIHVzZXIgcmUtY3JlYXRlcyBhIFNjcm9sbFRyaWdnZXIgZm9yIHRoZSBzYW1lIGVsZW1lbnQuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhcnMub25LaWxsICYmIHZhcnMub25LaWxsKHNlbGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfdHJpZ2dlcnMucHVzaChzZWxmKTtcclxuXHJcbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xyXG4gICAgY3VzdG9tUmV2ZXJ0UmV0dXJuICYmIGN1c3RvbVJldmVydFJldHVybihzZWxmKTtcclxuXHJcbiAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5hZGQgJiYgIWNoYW5nZSkge1xyXG4gICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGlzIGEgdGltZWxpbmUsIGl0IG1heSBub3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IHJlbmRlciBhdCB0aGUgcHJvcGVyIHBsYWNlIG9uIHRoZSBmaXJzdCByZWZyZXNoKCksIHRodXMgd2Ugc2hvdWxkIHNjaGVkdWxlIG9uZSBmb3IgdGhlIG5leHQgdGljay4gSWYgXCJjaGFuZ2VcIiBpcyBkZWZpbmVkLCB3ZSBrbm93IGl0IG11c3QgYmUgcmUtZW5hYmxpbmcsIHRodXMgd2UgY2FuIHJlZnJlc2goKSByaWdodCBhd2F5LlxyXG4gICAgICB2YXIgdXBkYXRlRnVuYyA9IHNlbGYudXBkYXRlOyAvLyBzb21lIGJyb3dzZXJzIG1heSBmaXJlIGEgc2Nyb2xsIGV2ZW50IEJFRk9SRSBhIHRpY2sgZWxhcHNlcyBhbmQvb3IgdGhlIERPTUNvbnRlbnRMb2FkZWQgZmlyZXMuIFNvIHRoZXJlJ3MgYSBjaGFuY2UgdXBkYXRlKCkgd2lsbCBiZSBjYWxsZWQgQkVGT1JFIGEgcmVmcmVzaCgpIGhhcyBoYXBwZW5lZCBvbiBhIFRpbWVsaW5lLWF0dGFjaGVkIFNjcm9sbFRyaWdnZXIgd2hpY2ggbWVhbnMgdGhlIHN0YXJ0L2VuZCB3b24ndCBiZSBjYWxjdWxhdGVkIHlldC4gV2UgZG9uJ3Qgd2FudCB0byBhZGQgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIHRoZSB1cGRhdGUoKSBtZXRob2QgKGxpa2UgY2hlY2sgdG8gc2VlIGlmIGVuZCBpcyBkZWZpbmVkIGFuZCBpZiBub3QsIGZvcmNlIGEgcmVmcmVzaCgpKSBiZWNhdXNlIHRoYXQncyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBoaXQgYSBMT1QgKHBlcmZvcm1hbmNlKS4gU28gd2Ugc3dhcCBvdXQgdGhlIHJlYWwgdXBkYXRlKCkgbWV0aG9kIGZvciB0aGlzIG9uZSB0aGF0J2xsIHJlLWF0dGFjaCBpdCB0aGUgZmlyc3QgdGltZSBpdCBnZXRzIGNhbGxlZCBhbmQgb2YgY291cnNlIGZvcmNlcyBhIHJlZnJlc2goKS5cclxuXHJcbiAgICAgIHNlbGYudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGYudXBkYXRlID0gdXBkYXRlRnVuYztcclxuICAgICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7IC8vIG90aGVyd2lzZSBhIGNhY2hlZCBzY3JvbGwgcG9zaXRpb24gbWF5IGdldCB1c2VkIGluIHRoZSByZWZyZXNoKCkgaW4gYSB2ZXJ5IHJhcmUgc2NlbmFyaW8sIGxpa2UgaWYgU2Nyb2xsVHJpZ2dlcnMgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgRE9NQ29udGVudExvYWRlZCBldmVudCBhbmQgdGhlIHF1ZXVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBmaXJlcyBiZWZvcmVoYW5kLiBTZWUgaHR0cHM6Ly9nc2FwLmNvbS9jb21tdW5pdHkvZm9ydW1zL3RvcGljLzQxMjY3LXNjcm9sbHRyaWdnZXItYnJlYWtzLW9uLXJlZnJlc2gtd2hlbi11c2luZy1kb21jb250ZW50bG9hZGVkL1xyXG5cclxuICAgICAgICBzdGFydCB8fCBlbmQgfHwgc2VsZi5yZWZyZXNoKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsIHNlbGYudXBkYXRlKTtcclxuICAgICAgY2hhbmdlID0gMC4wMTtcclxuICAgICAgc3RhcnQgPSBlbmQgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5yZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGluICYmIF9xdWV1ZVJlZnJlc2hBbGwoKTsgLy8gcGlubmluZyBjb3VsZCBhZmZlY3QgdGhlIHBvc2l0aW9ucyBvZiBvdGhlciB0aGluZ3MsIHNvIG1ha2Ugc3VyZSB3ZSBxdWV1ZSBhIGZ1bGwgcmVmcmVzaCgpXHJcbiAgfTtcclxuXHJcbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcclxuICAgIGlmICghX2NvcmVJbml0dGVkKSB7XHJcbiAgICAgIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XHJcbiAgICAgIF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgU2Nyb2xsVHJpZ2dlci5lbmFibGUoKTtcclxuICAgICAgX2NvcmVJbml0dGVkID0gX2VuYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcclxuICB9O1xyXG5cclxuICBTY3JvbGxUcmlnZ2VyLmRlZmF1bHRzID0gZnVuY3Rpb24gZGVmYXVsdHMoY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgX2RlZmF1bHRzW3BdID0gY29uZmlnW3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9kZWZhdWx0cztcclxuICB9O1xyXG5cclxuICBTY3JvbGxUcmlnZ2VyLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKHJlc2V0LCBraWxsKSB7XHJcbiAgICBfZW5hYmxlZCA9IDA7XHJcblxyXG4gICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcclxuICAgICAgcmV0dXJuIHRyaWdnZXJba2lsbCA/IFwia2lsbFwiIDogXCJkaXNhYmxlXCJdKHJlc2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7XHJcblxyXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XHJcblxyXG4gICAgY2xlYXJJbnRlcnZhbChfc3luY0ludGVydmFsKTtcclxuXHJcbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpO1xyXG5cclxuICAgIF9yZW1vdmVMaXN0ZW5lcihfYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIF9wYXNzVGhyb3VnaCk7XHJcblxyXG4gICAgX211bHRpTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJkb3duLHRvdWNoc3RhcnQsbW91c2Vkb3duXCIsIF9wb2ludGVyRG93bkhhbmRsZXIpO1xyXG5cclxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XHJcblxyXG4gICAgX3Jlc2l6ZURlbGF5LmtpbGwoKTtcclxuXHJcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcik7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMV0pO1xyXG5cclxuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgU2Nyb2xsVHJpZ2dlci5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICBfd2luID0gd2luZG93O1xyXG4gICAgX2RvYyA9IGRvY3VtZW50O1xyXG4gICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcclxuXHJcbiAgICBpZiAoZ3NhcCkge1xyXG4gICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcclxuICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcclxuICAgICAgX2NvbnRleHQgPSBnc2FwLmNvcmUuY29udGV4dCB8fCBfcGFzc1Rocm91Z2g7XHJcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcclxuICAgICAgX3Njcm9sbFJlc3RvcmF0aW9uID0gX3dpbi5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uIHx8IFwiYXV0b1wiO1xyXG4gICAgICBfbGFzdFNjcm9sbCA9IF93aW4ucGFnZVlPZmZzZXQgfHwgMDtcclxuICAgICAgZ3NhcC5jb3JlLmdsb2JhbHMoXCJTY3JvbGxUcmlnZ2VyXCIsIFNjcm9sbFRyaWdnZXIpOyAvLyBtdXN0IHJlZ2lzdGVyIHRoZSBnbG9iYWwgbWFudWFsbHkgYmVjYXVzZSBpbiBJbnRlcm5ldCBFeHBsb3JlciwgZnVuY3Rpb25zIChjbGFzc2VzKSBkb24ndCBoYXZlIGEgXCJuYW1lXCIgcHJvcGVydHkuXHJcblxyXG4gICAgICBpZiAoX2JvZHkpIHtcclxuICAgICAgICBfZW5hYmxlZCA9IDE7XHJcbiAgICAgICAgX2RpdjEwMHZoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTsgLy8gdG8gc29sdmUgbW9iaWxlIGJyb3dzZXIgYWRkcmVzcyBiYXIgc2hvdy9oaWRlIHJlc2l6aW5nLCB3ZSBzaG91bGRuJ3QgcmVseSBvbiB3aW5kb3cuaW5uZXJIZWlnaHQuIEluc3RlYWQsIHVzZSBhIDxkaXY+IHdpdGggaXRzIGhlaWdodCBzZXQgdG8gMTAwdmggYW5kIG1lYXN1cmUgdGhhdCBzaW5jZSB0aGF0J3Mgd2hhdCB0aGUgc2Nyb2xsaW5nIGlzIGJhc2VkIG9uIGFueXdheSBhbmQgaXQncyBub3QgYWZmZWN0ZWQgYnkgYWRkcmVzcyBiYXIgc2hvd2luZy9oaWRpbmcuXHJcblxyXG4gICAgICAgIF9kaXYxMDB2aC5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCI7XHJcbiAgICAgICAgX2RpdjEwMHZoLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cclxuICAgICAgICBfcmVmcmVzaDEwMHZoKCk7XHJcblxyXG4gICAgICAgIF9yYWZCdWdGaXgoKTtcclxuXHJcbiAgICAgICAgT2JzZXJ2ZXIucmVnaXN0ZXIoZ3NhcCk7IC8vIGlzVG91Y2ggaXMgMCBpZiBubyB0b3VjaCwgMSBpZiBPTkxZIHRvdWNoLCBhbmQgMiBpZiBpdCBjYW4gYWNjb21tb2RhdGUgdG91Y2ggYnV0IGFsc28gb3RoZXIgdHlwZXMgbGlrZSBtb3VzZS9wb2ludGVyLlxyXG5cclxuICAgICAgICBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPSBPYnNlcnZlci5pc1RvdWNoO1xyXG4gICAgICAgIF9maXhJT1NCdWcgPSBPYnNlcnZlci5pc1RvdWNoICYmIC8oaVBhZHxpUGhvbmV8aVBvZHxNYWMpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gc2luY2UgMjAxNywgaU9TIGhhcyBoYWQgYSBidWcgdGhhdCBjYXVzZXMgZXZlbnQuY2xpZW50WC9ZIHRvIGJlIGluYWNjdXJhdGUgd2hlbiBhIHNjcm9sbCBvY2N1cnMsIHRodXMgd2UgbXVzdCBhbHRlcm5hdGUgaWdub3JpbmcgZXZlcnkgb3RoZXIgdG91Y2htb3ZlIGV2ZW50IHRvIHdvcmsgYXJvdW5kIGl0LiBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4MTk1NCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwM1xyXG5cclxuICAgICAgICBfaWdub3JlTW9iaWxlUmVzaXplID0gT2JzZXJ2ZXIuaXNUb3VjaCA9PT0gMTtcclxuXHJcbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwid2hlZWxcIiwgX29uU2Nyb2xsKTsgLy8gbW9zdGx5IGZvciAzcmQgcGFydHkgc21vb3RoIHNjcm9sbGluZyBsaWJyYXJpZXMuXHJcblxyXG5cclxuICAgICAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcclxuXHJcbiAgICAgICAgaWYgKGdzYXAubWF0Y2hNZWRpYSkge1xyXG4gICAgICAgICAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhID0gZnVuY3Rpb24gKHZhcnMpIHtcclxuICAgICAgICAgICAgdmFyIG1tID0gZ3NhcC5tYXRjaE1lZGlhKCksXHJcbiAgICAgICAgICAgICAgICBwO1xyXG5cclxuICAgICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcclxuICAgICAgICAgICAgICBtbS5hZGQocCwgdmFyc1twXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtbTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgZ3NhcC5hZGRFdmVudExpc3RlbmVyKFwibWF0Y2hNZWRpYUluaXRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3JldmVydEFsbCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhUmV2ZXJ0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZXZlcnRSZWNvcmRlZCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBnc2FwLmFkZEV2ZW50TGlzdGVuZXIoXCJtYXRjaE1lZGlhXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3JlZnJlc2hBbGwoMCwgMSk7XHJcblxyXG4gICAgICAgICAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBnc2FwLm1hdGNoTWVkaWEoKS5hZGQoXCIob3JpZW50YXRpb246IHBvcnRyYWl0KVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gb3JpZW50YXRpb24gY2hhbmdlcywgd2Ugc2hvdWxkIHRha2UgbmV3IGJhc2UgbWVhc3VyZW1lbnRzIGZvciB0aGUgaWdub3JlTW9iaWxlUmVzaXplIGZlYXR1cmUuXHJcbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF9zZXRCYXNlRGltZW5zaW9ucztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJSZXF1aXJlcyBHU0FQIDMuMTEuMCBvciBsYXRlclwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xyXG5cclxuICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUpLCB0aGUgd2luZG93IHN0b3BzIGRpc3BhdGNoaW5nIHNjcm9sbCBldmVudHMgb24gdGhlIHdpbmRvdyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0LCBidXQgaXQncyBjb25zaXN0ZW50IG9uIHRoZSBkb2N1bWVudCFcclxuXHJcblxyXG4gICAgICAgIHZhciBib2R5SGFzU3R5bGUgPSBfYm9keS5oYXNBdHRyaWJ1dGUoXCJzdHlsZVwiKSxcclxuICAgICAgICAgICAgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXHJcbiAgICAgICAgICAgIGJvcmRlciA9IGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSxcclxuICAgICAgICAgICAgQW5pbWF0aW9uUHJvdG8gPSBnc2FwLmNvcmUuQW5pbWF0aW9uLnByb3RvdHlwZSxcclxuICAgICAgICAgICAgYm91bmRzLFxyXG4gICAgICAgICAgICBpO1xyXG5cclxuICAgICAgICBBbmltYXRpb25Qcm90by5yZXZlcnQgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblByb3RvLCBcInJldmVydFwiLCB7XHJcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWUoLTAuMDEsIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pOyAvLyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoQW5pbWF0aW9uLnJldmVydCgpIHdhcyBhZGRlZCBhZnRlciAzLjEwLjQpXHJcblxyXG4gICAgICAgIGJvZHlTdHlsZS5ib3JkZXJUb3BTdHlsZSA9IFwic29saWRcIjsgLy8gd29ya3MgYXJvdW5kIGFuIGlzc3VlIHdoZXJlIGEgbWFyZ2luIG9mIGEgY2hpbGQgZWxlbWVudCBjb3VsZCB0aHJvdyBvZmYgdGhlIGJvdW5kcyBvZiB0aGUgX2JvZHksIG1ha2luZyBpdCBzZWVtIGxpa2UgdGhlcmUncyBhIG1hcmdpbiB3aGVuIHRoZXJlIGFjdHVhbGx5IGlzbid0LiBUaGUgYm9yZGVyIGVuc3VyZXMgdGhhdCB0aGUgYm91bmRzIGFyZSBhY2N1cmF0ZS5cclxuXHJcbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhfYm9keSk7XHJcbiAgICAgICAgX3ZlcnRpY2FsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy50b3AgKyBfdmVydGljYWwuc2MoKSkgfHwgMDsgLy8gYWNjb21tb2RhdGUgdGhlIG9mZnNldCBvZiB0aGUgPGJvZHk+IGNhdXNlZCBieSBtYXJnaW5zIGFuZC9vciBwYWRkaW5nXHJcblxyXG4gICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcclxuICAgICAgICBib3JkZXIgPyBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBib3JkZXIgOiBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoXCJib3JkZXItdG9wLXN0eWxlXCIpO1xyXG5cclxuICAgICAgICBpZiAoIWJvZHlIYXNTdHlsZSkge1xyXG4gICAgICAgICAgLy8gU1NSIGZyYW1ld29ya3MgbGlrZSBOZXh0LmpzIGNvbXBsYWluIGlmIHRoaXMgYXR0cmlidXRlIGdldHMgYWRkZWQuXHJcbiAgICAgICAgICBfYm9keS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKTsgLy8gaXQncyBub3QgZW5vdWdoIHRvIGp1c3QgcmVtb3ZlQXR0cmlidXRlKCkgLSB3ZSBtdXN0IGZpcnN0IHNldCBpdCB0byBlbXB0eSwgb3RoZXJ3aXNlIE5leHQuanMgY29tcGxhaW5zLlxyXG5cclxuXHJcbiAgICAgICAgICBfYm9keS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcclxuICAgICAgICB9IC8vIFRPRE86ICg/KSBtYXliZSBtb3ZlIHRvIGxldmVyYWdpbmcgdGhlIHZlbG9jaXR5IG1lY2hhbmlzbSBpbiBPYnNlcnZlciBhbmQgc2tpcCBpbnRlcnZhbHMuXHJcblxyXG5cclxuICAgICAgICBfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDI1MCk7XHJcbiAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInRvdWNoY2FuY2VsXCIsIF9wYXNzVGhyb3VnaCk7IC8vIHNvbWUgb2xkZXIgQW5kcm9pZCBkZXZpY2VzIGludGVybWl0dGVudGx5IHN0b3AgZGlzcGF0Y2hpbmcgXCJ0b3VjaG1vdmVcIiBldmVudHMgaWYgd2UgZG9uJ3QgbGlzdGVuIGZvciBcInRvdWNoY2FuY2VsXCIgb24gdGhlIGRvY3VtZW50LlxyXG5cclxuXHJcbiAgICAgICAgX2FkZExpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1ZzogaHR0cHM6Ly9nc2FwLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXHJcblxyXG5cclxuICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgX3BvaW50ZXJEb3duSGFuZGxlcik7XHJcblxyXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XHJcblxyXG4gICAgICAgIF90cmFuc2Zvcm1Qcm9wID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeChcInRyYW5zZm9ybVwiKTtcclxuXHJcbiAgICAgICAgX3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XHJcblxyXG4gICAgICAgIF9jb3JlSW5pdHRlZCA9IF9nZXRUaW1lKCk7XHJcbiAgICAgICAgX3Jlc2l6ZURlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbCgwLjIsIF9yZWZyZXNoQWxsKS5wYXVzZSgpO1xyXG4gICAgICAgIF9hdXRvUmVmcmVzaCA9IFtfZG9jLCBcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHcgPSBfd2luLmlubmVyV2lkdGgsXHJcbiAgICAgICAgICAgICAgaCA9IF93aW4uaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgaWYgKF9kb2MuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIF9wcmV2V2lkdGggPSB3O1xyXG4gICAgICAgICAgICBfcHJldkhlaWdodCA9IGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKF9wcmV2V2lkdGggIT09IHcgfHwgX3ByZXZIZWlnaHQgIT09IGgpIHtcclxuICAgICAgICAgICAgX29uUmVzaXplKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgX2RvYywgXCJET01Db250ZW50TG9hZGVkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcImxvYWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwicmVzaXplXCIsIF9vblJlc2l6ZV07XHJcblxyXG4gICAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcclxuICAgICAgICAgIHJldHVybiB0cmlnZ2VyLmVuYWJsZSgwLCAxKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9zY3JvbGxlcnMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMV0pO1xyXG5cclxuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFNjcm9sbFRyaWdnZXIuY29uZmlnID0gZnVuY3Rpb24gY29uZmlnKHZhcnMpIHtcclxuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xyXG4gICAgdmFyIG1zID0gdmFycy5zeW5jSW50ZXJ2YWw7XHJcbiAgICBtcyAmJiBjbGVhckludGVydmFsKF9zeW5jSW50ZXJ2YWwpIHx8IChfc3luY0ludGVydmFsID0gbXMpICYmIHNldEludGVydmFsKF9zeW5jLCBtcyk7XHJcbiAgICBcImlnbm9yZU1vYmlsZVJlc2l6ZVwiIGluIHZhcnMgJiYgKF9pZ25vcmVNb2JpbGVSZXNpemUgPSBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPT09IDEgJiYgdmFycy5pZ25vcmVNb2JpbGVSZXNpemUpO1xyXG5cclxuICAgIGlmIChcImF1dG9SZWZyZXNoRXZlbnRzXCIgaW4gdmFycykge1xyXG4gICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xyXG4gICAgICBfaWdub3JlUmVzaXplID0gKHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgKyBcIlwiKS5pbmRleE9mKFwicmVzaXplXCIpID09PSAtMTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBTY3JvbGxUcmlnZ2VyLnNjcm9sbGVyUHJveHkgPSBmdW5jdGlvbiBzY3JvbGxlclByb3h5KHRhcmdldCwgdmFycykge1xyXG4gICAgdmFyIHQgPSBfZ2V0VGFyZ2V0KHRhcmdldCksXHJcbiAgICAgICAgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZih0KSxcclxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodCk7XHJcblxyXG4gICAgaWYgKH5pKSB7XHJcbiAgICAgIF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZhcnMpIHtcclxuICAgICAgaXNWaWV3cG9ydCA/IF9wcm94aWVzLnVuc2hpZnQoX3dpbiwgdmFycywgX2JvZHksIHZhcnMsIF9kb2NFbCwgdmFycykgOiBfcHJveGllcy51bnNoaWZ0KHQsIHZhcnMpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIFNjcm9sbFRyaWdnZXIuY2xlYXJNYXRjaE1lZGlhID0gZnVuY3Rpb24gY2xlYXJNYXRjaE1lZGlhKHF1ZXJ5KSB7XHJcbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICByZXR1cm4gdC5fY3R4ICYmIHQuX2N0eC5xdWVyeSA9PT0gcXVlcnkgJiYgdC5fY3R4LmtpbGwodHJ1ZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBTY3JvbGxUcmlnZ2VyLmlzSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIGlzSW5WaWV3cG9ydChlbGVtZW50LCByYXRpbywgaG9yaXpvbnRhbCkge1xyXG4gICAgdmFyIGJvdW5kcyA9IChfaXNTdHJpbmcoZWxlbWVudCkgPyBfZ2V0VGFyZ2V0KGVsZW1lbnQpIDogZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgb2Zmc2V0ID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSAqIHJhdGlvIHx8IDA7XHJcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IGJvdW5kcy5yaWdodCAtIG9mZnNldCA+IDAgJiYgYm91bmRzLmxlZnQgKyBvZmZzZXQgPCBfd2luLmlubmVyV2lkdGggOiBib3VuZHMuYm90dG9tIC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMudG9wICsgb2Zmc2V0IDwgX3dpbi5pbm5lckhlaWdodDtcclxuICB9O1xyXG5cclxuICBTY3JvbGxUcmlnZ2VyLnBvc2l0aW9uSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5WaWV3cG9ydChlbGVtZW50LCByZWZlcmVuY2VQb2ludCwgaG9yaXpvbnRhbCkge1xyXG4gICAgX2lzU3RyaW5nKGVsZW1lbnQpICYmIChlbGVtZW50ID0gX2dldFRhcmdldChlbGVtZW50KSk7XHJcbiAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICBzaXplID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSxcclxuICAgICAgICBvZmZzZXQgPSByZWZlcmVuY2VQb2ludCA9PSBudWxsID8gc2l6ZSAvIDIgOiByZWZlcmVuY2VQb2ludCBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbcmVmZXJlbmNlUG9pbnRdICogc2l6ZSA6IH5yZWZlcmVuY2VQb2ludC5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpIHx8IDA7XHJcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IChib3VuZHMubGVmdCArIG9mZnNldCkgLyBfd2luLmlubmVyV2lkdGggOiAoYm91bmRzLnRvcCArIG9mZnNldCkgLyBfd2luLmlubmVySGVpZ2h0O1xyXG4gIH07XHJcblxyXG4gIFNjcm9sbFRyaWdnZXIua2lsbEFsbCA9IGZ1bmN0aW9uIGtpbGxBbGwoYWxsb3dMaXN0ZW5lcnMpIHtcclxuICAgIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIiAmJiB0LmtpbGwoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChhbGxvd0xpc3RlbmVycyAhPT0gdHJ1ZSkge1xyXG4gICAgICB2YXIgbGlzdGVuZXJzID0gX2xpc3RlbmVycy5raWxsQWxsIHx8IFtdO1xyXG4gICAgICBfbGlzdGVuZXJzID0ge307XHJcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgcmV0dXJuIGYoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFNjcm9sbFRyaWdnZXI7XHJcbn0oKTtcclxuU2Nyb2xsVHJpZ2dlci52ZXJzaW9uID0gXCIzLjEzLjBcIjtcclxuXHJcblNjcm9sbFRyaWdnZXIuc2F2ZVN0eWxlcyA9IGZ1bmN0aW9uICh0YXJnZXRzKSB7XHJcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIHNhdmVkIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gYSBjb25zZWN1dGl2ZSBhbHRlcm5hdGluZyBBcnJheSwgbGlrZSBbZWxlbWVudCwgY3NzVGV4dCwgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgY2FjaGUsIG1hdGNoTWVkaWEsIC4uLl1cclxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnN0eWxlKSB7XHJcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcclxuXHJcbiAgICAgIGkgPj0gMCAmJiBfc2F2ZWRTdHlsZXMuc3BsaWNlKGksIDUpO1xyXG5cclxuICAgICAgX3NhdmVkU3R5bGVzLnB1c2godGFyZ2V0LCB0YXJnZXQuc3R5bGUuY3NzVGV4dCwgdGFyZ2V0LmdldEJCb3ggJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksIF9jb250ZXh0KCkpO1xyXG4gICAgfVxyXG4gIH0pIDogX3NhdmVkU3R5bGVzO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5yZXZlcnQgPSBmdW5jdGlvbiAoc29mdCwgbWVkaWEpIHtcclxuICByZXR1cm4gX3JldmVydEFsbCghc29mdCwgbWVkaWEpO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5jcmVhdGUgPSBmdW5jdGlvbiAodmFycywgYW5pbWF0aW9uKSB7XHJcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xyXG4gIHJldHVybiBzYWZlID8gX29uUmVzaXplKHRydWUpIDogKF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKCkpICYmIF9yZWZyZXNoQWxsKHRydWUpO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBmdW5jdGlvbiAoZm9yY2UpIHtcclxuICByZXR1cm4gKytfc2Nyb2xsZXJzLmNhY2hlICYmIF91cGRhdGVBbGwoZm9yY2UgPT09IHRydWUgPyAyIDogMCk7XHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLmNsZWFyU2Nyb2xsTWVtb3J5ID0gX2NsZWFyU2Nyb2xsTWVtb3J5O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xyXG4gIHJldHVybiBfbWF4U2Nyb2xsKGVsZW1lbnQsIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLmdldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xyXG4gIHJldHVybiBfZ2V0U2Nyb2xsRnVuYyhfZ2V0VGFyZ2V0KGVsZW1lbnQpLCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgcmV0dXJuIF9pZHNbaWRdO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIF90cmlnZ2Vycy5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0LnZhcnMuaWQgIT09IFwiU2Nyb2xsU21vb3RoZXJcIjtcclxuICB9KTtcclxufTsgLy8gaXQncyBjb21tb24gZm9yIHBlb3BsZSB0byBTY3JvbGxUcmlnZ2VyLmdldEFsbCh0ID0+IHQua2lsbCgpKSBvbiBwYWdlIHJvdXRlcywgZm9yIGV4YW1wbGUsIGFuZCB3ZSBkb24ndCB3YW50IGl0IHRvIHJ1aW4gc21vb3RoIHNjcm9sbGluZyBieSBraWxsaW5nIHRoZSBtYWluIFNjcm9sbFNtb290aGVyIG9uZS5cclxuXHJcblxyXG5TY3JvbGxUcmlnZ2VyLmlzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIV9sYXN0U2Nyb2xsVGltZTtcclxufTtcclxuXHJcblNjcm9sbFRyaWdnZXIuc25hcERpcmVjdGlvbmFsID0gX3NuYXBEaXJlY3Rpb25hbDtcclxuXHJcblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xyXG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSB8fCAoX2xpc3RlbmVyc1t0eXBlXSA9IFtdKTtcclxuICB+YS5pbmRleE9mKGNhbGxiYWNrKSB8fCBhLnB1c2goY2FsbGJhY2spO1xyXG59O1xyXG5cclxuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdLFxyXG4gICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gIGkgPj0gMCAmJiBhLnNwbGljZShpLCAxKTtcclxufTtcclxuXHJcblNjcm9sbFRyaWdnZXIuYmF0Y2ggPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycykge1xyXG4gIHZhciByZXN1bHQgPSBbXSxcclxuICAgICAgdmFyc0NvcHkgPSB7fSxcclxuICAgICAgaW50ZXJ2YWwgPSB2YXJzLmludGVydmFsIHx8IDAuMDE2LFxyXG4gICAgICBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxyXG4gICAgICBwcm94eUNhbGxiYWNrID0gZnVuY3Rpb24gcHJveHlDYWxsYmFjayh0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGVsZW1lbnRzID0gW10sXHJcbiAgICAgICAgdHJpZ2dlcnMgPSBbXSxcclxuICAgICAgICBkZWxheSA9IGdzYXAuZGVsYXllZENhbGwoaW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgY2FsbGJhY2soZWxlbWVudHMsIHRyaWdnZXJzKTtcclxuICAgICAgZWxlbWVudHMgPSBbXTtcclxuICAgICAgdHJpZ2dlcnMgPSBbXTtcclxuICAgIH0pLnBhdXNlKCk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcclxuICAgICAgZWxlbWVudHMubGVuZ3RoIHx8IGRlbGF5LnJlc3RhcnQodHJ1ZSk7XHJcbiAgICAgIGVsZW1lbnRzLnB1c2goc2VsZi50cmlnZ2VyKTtcclxuICAgICAgdHJpZ2dlcnMucHVzaChzZWxmKTtcclxuICAgICAgYmF0Y2hNYXggPD0gZWxlbWVudHMubGVuZ3RoICYmIGRlbGF5LnByb2dyZXNzKDEpO1xyXG4gICAgfTtcclxuICB9LFxyXG4gICAgICBwO1xyXG5cclxuICBmb3IgKHAgaW4gdmFycykge1xyXG4gICAgdmFyc0NvcHlbcF0gPSBwLnN1YnN0cigwLCAyKSA9PT0gXCJvblwiICYmIF9pc0Z1bmN0aW9uKHZhcnNbcF0pICYmIHAgIT09IFwib25SZWZyZXNoSW5pdFwiID8gcHJveHlDYWxsYmFjayhwLCB2YXJzW3BdKSA6IHZhcnNbcF07XHJcbiAgfVxyXG5cclxuICBpZiAoX2lzRnVuY3Rpb24oYmF0Y2hNYXgpKSB7XHJcbiAgICBiYXRjaE1heCA9IGJhdGNoTWF4KCk7XHJcblxyXG4gICAgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXgoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICB2YXIgY29uZmlnID0ge307XHJcblxyXG4gICAgZm9yIChwIGluIHZhcnNDb3B5KSB7XHJcbiAgICAgIGNvbmZpZ1twXSA9IHZhcnNDb3B5W3BdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZy50cmlnZ2VyID0gdGFyZ2V0O1xyXG4gICAgcmVzdWx0LnB1c2goU2Nyb2xsVHJpZ2dlci5jcmVhdGUoY29uZmlnKSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07IC8vIHRvIHJlZHVjZSBmaWxlIHNpemUuIGNsYW1wcyB0aGUgc2Nyb2xsIGFuZCBhbHNvIHJldHVybnMgYSBkdXJhdGlvbiBtdWx0aXBsaWVyIHNvIHRoYXQgaWYgdGhlIHNjcm9sbCBnZXRzIGNob3BwZWQgc2hvcnRlciwgdGhlIGR1cmF0aW9uIGdldHMgY3VydGFpbGVkIGFzIHdlbGwgKG90aGVyd2lzZSBpZiB5b3UncmUgdmVyeSBjbG9zZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlLCBmb3IgZXhhbXBsZSwgYW5kIHN3aXBlIHVwIHJlYWxseSBmYXN0LCBpdCdsbCBzdWRkZW5seSBzbG93IGRvd24gYW5kIHRha2UgYSBsb25nIHRpbWUgdG8gcmVhY2ggdGhlIHRvcCkuXHJcblxyXG5cclxudmFyIF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllciA9IGZ1bmN0aW9uIF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllcihzY3JvbGxGdW5jLCBjdXJyZW50LCBlbmQsIG1heCkge1xyXG4gIGN1cnJlbnQgPiBtYXggPyBzY3JvbGxGdW5jKG1heCkgOiBjdXJyZW50IDwgMCAmJiBzY3JvbGxGdW5jKDApO1xyXG4gIHJldHVybiBlbmQgPiBtYXggPyAobWF4IC0gY3VycmVudCkgLyAoZW5kIC0gY3VycmVudCkgOiBlbmQgPCAwID8gY3VycmVudCAvIChjdXJyZW50IC0gZW5kKSA6IDE7XHJcbn0sXHJcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nID0gZnVuY3Rpb24gX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIGRpcmVjdGlvbikge1xyXG4gIGlmIChkaXJlY3Rpb24gPT09IHRydWUpIHtcclxuICAgIHRhcmdldC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gZGlyZWN0aW9uID09PSB0cnVlID8gXCJhdXRvXCIgOiBkaXJlY3Rpb24gPyBcInBhbi1cIiArIGRpcmVjdGlvbiArIChPYnNlcnZlci5pc1RvdWNoID8gXCIgcGluY2gtem9vbVwiIDogXCJcIikgOiBcIm5vbmVcIjsgLy8gbm90ZTogRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgaXQgcGluY2gtem9vbSBwcm9wZXJseSwgYXQgbGVhc3QgaW4gYWRkaXRpb24gdG8gYSBwYW4teCBvciBwYW4teS5cclxuICB9XHJcblxyXG4gIHRhcmdldCA9PT0gX2RvY0VsICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcoX2JvZHksIGRpcmVjdGlvbik7XHJcbn0sXHJcbiAgICBfb3ZlcmZsb3cgPSB7XHJcbiAgYXV0bzogMSxcclxuICBzY3JvbGw6IDFcclxufSxcclxuICAgIF9uZXN0ZWRTY3JvbGwgPSBmdW5jdGlvbiBfbmVzdGVkU2Nyb2xsKF9yZWY1KSB7XHJcbiAgdmFyIGV2ZW50ID0gX3JlZjUuZXZlbnQsXHJcbiAgICAgIHRhcmdldCA9IF9yZWY1LnRhcmdldCxcclxuICAgICAgYXhpcyA9IF9yZWY1LmF4aXM7XHJcblxyXG4gIHZhciBub2RlID0gKGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudCkudGFyZ2V0LFxyXG4gICAgICBjYWNoZSA9IG5vZGUuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKG5vZGUpLFxyXG4gICAgICB0aW1lID0gX2dldFRpbWUoKSxcclxuICAgICAgY3M7XHJcblxyXG4gIGlmICghY2FjaGUuX2lzU2Nyb2xsVCB8fCB0aW1lIC0gY2FjaGUuX2lzU2Nyb2xsVCA+IDIwMDApIHtcclxuICAgIC8vIGNhY2hlIGZvciAyIHNlY29uZHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cclxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IF9ib2R5ICYmIChub2RlLnNjcm9sbEhlaWdodCA8PSBub2RlLmNsaWVudEhlaWdodCAmJiBub2RlLnNjcm9sbFdpZHRoIDw9IG5vZGUuY2xpZW50V2lkdGggfHwgIShfb3ZlcmZsb3dbKGNzID0gX2dldENvbXB1dGVkU3R5bGUobm9kZSkpLm92ZXJmbG93WV0gfHwgX292ZXJmbG93W2NzLm92ZXJmbG93WF0pKSkge1xyXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGNhY2hlLl9pc1Njcm9sbCA9IG5vZGUgJiYgbm9kZSAhPT0gdGFyZ2V0ICYmICFfaXNWaWV3cG9ydChub2RlKSAmJiAoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKTtcclxuICAgIGNhY2hlLl9pc1Njcm9sbFQgPSB0aW1lO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhY2hlLl9pc1Njcm9sbCB8fCBheGlzID09PSBcInhcIikge1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBldmVudC5fZ3NhcEFsbG93ID0gdHJ1ZTtcclxuICB9XHJcbn0sXHJcbiAgICAvLyBjYXB0dXJlIGV2ZW50cyBvbiBzY3JvbGxhYmxlIGVsZW1lbnRzIElOU0lERSB0aGUgPGJvZHk+IGFuZCBhbGxvdyB0aG9zZSBieSBjYWxsaW5nIHN0b3BQcm9wYWdhdGlvbigpIHdoZW4gd2UgZmluZCBhIHNjcm9sbGFibGUgYW5jZXN0b3JcclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XHJcbiAgcmV0dXJuIE9ic2VydmVyLmNyZWF0ZSh7XHJcbiAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgIGNhcHR1cmU6IHRydWUsXHJcbiAgICBkZWJvdW5jZTogZmFsc2UsXHJcbiAgICBsb2NrQXhpczogdHJ1ZSxcclxuICAgIHR5cGU6IHR5cGUsXHJcbiAgICBvbldoZWVsOiBuZXN0ZWQgPSBuZXN0ZWQgJiYgX25lc3RlZFNjcm9sbCxcclxuICAgIG9uUHJlc3M6IG5lc3RlZCxcclxuICAgIG9uRHJhZzogbmVzdGVkLFxyXG4gICAgb25TY3JvbGw6IG5lc3RlZCxcclxuICAgIG9uRW5hYmxlOiBmdW5jdGlvbiBvbkVuYWJsZSgpIHtcclxuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBvbkRpc2FibGU6IGZ1bmN0aW9uIG9uRGlzYWJsZSgpIHtcclxuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0sXHJcbiAgICBfaW5wdXRFeHAgPSAvKGlucHV0fGxhYmVsfHNlbGVjdHx0ZXh0YXJlYSkvaSxcclxuICAgIF9pbnB1dElzRm9jdXNlZCxcclxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xyXG4gIHZhciBpc0lucHV0ID0gX2lucHV0RXhwLnRlc3QoZS50YXJnZXQudGFnTmFtZSk7XHJcblxyXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xyXG4gICAgZS5fZ3NhcEFsbG93ID0gdHJ1ZTtcclxuICAgIF9pbnB1dElzRm9jdXNlZCA9IGlzSW5wdXQ7XHJcbiAgfVxyXG59LFxyXG4gICAgX2dldFNjcm9sbE5vcm1hbGl6ZXIgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsTm9ybWFsaXplcih2YXJzKSB7XHJcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xyXG4gIHZhcnMucHJldmVudERlZmF1bHQgPSB2YXJzLmlzTm9ybWFsaXplciA9IHZhcnMuYWxsb3dDbGlja3MgPSB0cnVlO1xyXG4gIHZhcnMudHlwZSB8fCAodmFycy50eXBlID0gXCJ3aGVlbCx0b3VjaFwiKTtcclxuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xyXG4gIHZhcnMuaWQgPSB2YXJzLmlkIHx8IFwibm9ybWFsaXplclwiO1xyXG5cclxuICB2YXIgX3ZhcnMyID0gdmFycyxcclxuICAgICAgbm9ybWFsaXplU2Nyb2xsWCA9IF92YXJzMi5ub3JtYWxpemVTY3JvbGxYLFxyXG4gICAgICBtb21lbnR1bSA9IF92YXJzMi5tb21lbnR1bSxcclxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXHJcbiAgICAgIG9uUmVsZWFzZSA9IF92YXJzMi5vblJlbGVhc2UsXHJcbiAgICAgIHNlbGYsXHJcbiAgICAgIG1heFksXHJcbiAgICAgIHRhcmdldCA9IF9nZXRUYXJnZXQodmFycy50YXJnZXQpIHx8IF9kb2NFbCxcclxuICAgICAgc21vb3RoZXIgPSBnc2FwLmNvcmUuZ2xvYmFscygpLlNjcm9sbFNtb290aGVyLFxyXG4gICAgICBzbW9vdGhlckluc3RhbmNlID0gc21vb3RoZXIgJiYgc21vb3RoZXIuZ2V0KCksXHJcbiAgICAgIGNvbnRlbnQgPSBfZml4SU9TQnVnICYmICh2YXJzLmNvbnRlbnQgJiYgX2dldFRhcmdldCh2YXJzLmNvbnRlbnQpIHx8IHNtb290aGVySW5zdGFuY2UgJiYgdmFycy5jb250ZW50ICE9PSBmYWxzZSAmJiAhc21vb3RoZXJJbnN0YW5jZS5zbW9vdGgoKSAmJiBzbW9vdGhlckluc3RhbmNlLmNvbnRlbnQoKSksXHJcbiAgICAgIHNjcm9sbEZ1bmNZID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfdmVydGljYWwpLFxyXG4gICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxyXG4gICAgICBzY2FsZSA9IDEsXHJcbiAgICAgIGluaXRpYWxTY2FsZSA9IChPYnNlcnZlci5pc1RvdWNoICYmIF93aW4udmlzdWFsVmlld3BvcnQgPyBfd2luLnZpc3VhbFZpZXdwb3J0LnNjYWxlICogX3dpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IF93aW4ub3V0ZXJXaWR0aCkgLyBfd2luLmlubmVyV2lkdGgsXHJcbiAgICAgIHdoZWVsUmVmcmVzaCA9IDAsXHJcbiAgICAgIHJlc29sdmVNb21lbnR1bUR1cmF0aW9uID0gX2lzRnVuY3Rpb24obW9tZW50dW0pID8gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1vbWVudHVtKHNlbGYpO1xyXG4gIH0gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbW9tZW50dW0gfHwgMi44O1xyXG4gIH0sXHJcbiAgICAgIGxhc3RSZWZyZXNoSUQsXHJcbiAgICAgIHNraXBUb3VjaE1vdmUsXHJcbiAgICAgIGlucHV0T2JzZXJ2ZXIgPSBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHZhcnMudHlwZSwgdHJ1ZSwgYWxsb3dOZXN0ZWRTY3JvbGwpLFxyXG4gICAgICByZXN1bWVUb3VjaE1vdmUgPSBmdW5jdGlvbiByZXN1bWVUb3VjaE1vdmUoKSB7XHJcbiAgICByZXR1cm4gc2tpcFRvdWNoTW92ZSA9IGZhbHNlO1xyXG4gIH0sXHJcbiAgICAgIHNjcm9sbENsYW1wWCA9IF9wYXNzVGhyb3VnaCxcclxuICAgICAgc2Nyb2xsQ2xhbXBZID0gX3Bhc3NUaHJvdWdoLFxyXG4gICAgICB1cGRhdGVDbGFtcHMgPSBmdW5jdGlvbiB1cGRhdGVDbGFtcHMoKSB7XHJcbiAgICBtYXhZID0gX21heFNjcm9sbCh0YXJnZXQsIF92ZXJ0aWNhbCk7XHJcbiAgICBzY3JvbGxDbGFtcFkgPSBfY2xhbXAoX2ZpeElPU0J1ZyA/IDEgOiAwLCBtYXhZKTtcclxuICAgIG5vcm1hbGl6ZVNjcm9sbFggJiYgKHNjcm9sbENsYW1wWCA9IF9jbGFtcCgwLCBfbWF4U2Nyb2xsKHRhcmdldCwgX2hvcml6b250YWwpKSk7XHJcbiAgICBsYXN0UmVmcmVzaElEID0gX3JlZnJlc2hJRDtcclxuICB9LFxyXG4gICAgICByZW1vdmVDb250ZW50T2Zmc2V0ID0gZnVuY3Rpb24gcmVtb3ZlQ29udGVudE9mZnNldCgpIHtcclxuICAgIGNvbnRlbnQuX2dzYXAueSA9IF9yb3VuZChwYXJzZUZsb2F0KGNvbnRlbnQuX2dzYXAueSkgKyBzY3JvbGxGdW5jWS5vZmZzZXQpICsgXCJweFwiO1xyXG4gICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgcGFyc2VGbG9hdChjb250ZW50Ll9nc2FwLnkpICsgXCIsIDAsIDEpXCI7XHJcbiAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGxGdW5jWS5jYWNoZUlEID0gMDtcclxuICB9LFxyXG4gICAgICBpZ25vcmVEcmFnID0gZnVuY3Rpb24gaWdub3JlRHJhZygpIHtcclxuICAgIGlmIChza2lwVG91Y2hNb3ZlKSB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpO1xyXG5cclxuICAgICAgdmFyIG9mZnNldCA9IF9yb3VuZChzZWxmLmRlbHRhWSAvIDIpLFxyXG4gICAgICAgICAgc2Nyb2xsID0gc2Nyb2xsQ2xhbXBZKHNjcm9sbEZ1bmNZLnYgLSBvZmZzZXQpO1xyXG5cclxuICAgICAgaWYgKGNvbnRlbnQgJiYgc2Nyb2xsICE9PSBzY3JvbGxGdW5jWS52ICsgc2Nyb2xsRnVuY1kub2Zmc2V0KSB7XHJcbiAgICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ID0gc2Nyb2xsIC0gc2Nyb2xsRnVuY1kudjtcclxuXHJcbiAgICAgICAgdmFyIHkgPSBfcm91bmQoKHBhcnNlRmxvYXQoY29udGVudCAmJiBjb250ZW50Ll9nc2FwLnkpIHx8IDApIC0gc2Nyb2xsRnVuY1kub2Zmc2V0KTtcclxuXHJcbiAgICAgICAgY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeDNkKDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIFwiICsgeSArIFwiLCAwLCAxKVwiO1xyXG4gICAgICAgIGNvbnRlbnQuX2dzYXAueSA9IHkgKyBcInB4XCI7XHJcbiAgICAgICAgc2Nyb2xsRnVuY1kuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XHJcblxyXG4gICAgICAgIF91cGRhdGVBbGwoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcclxuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xyXG4gIH0sXHJcbiAgICAgIHR3ZWVuLFxyXG4gICAgICBzdGFydFNjcm9sbFgsXHJcbiAgICAgIHN0YXJ0U2Nyb2xsWSxcclxuICAgICAgb25TdG9wRGVsYXllZENhbGwsXHJcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XHJcbiAgICAvLyBpZiB0aGUgd2luZG93IHJlc2l6ZXMsIGxpa2Ugb24gYW4gaVBob25lIHdoaWNoIEFwcGxlIEZPUkNFUyB0aGUgYWRkcmVzcyBiYXIgdG8gc2hvdy9oaWRlIGV2ZW4gaWYgd2UgZXZlbnQucHJldmVudERlZmF1bHQoKSwgaXQgbWF5IGJlIHNjcm9sbGluZyB0b28gZmFyIG5vdyB0aGF0IHRoZSBhZGRyZXNzIGJhciBpcyBzaG93aW5nLCBzbyB3ZSBtdXN0IGR5bmFtaWNhbGx5IGFkanVzdCB0aGUgbW9tZW50dW0gdHdlZW4uXHJcbiAgICB1cGRhdGVDbGFtcHMoKTtcclxuXHJcbiAgICBpZiAodHdlZW4uaXNBY3RpdmUoKSAmJiB0d2Vlbi52YXJzLnNjcm9sbFkgPiBtYXhZKSB7XHJcbiAgICAgIHNjcm9sbEZ1bmNZKCkgPiBtYXhZID8gdHdlZW4ucHJvZ3Jlc3MoMSkgJiYgc2Nyb2xsRnVuY1kobWF4WSkgOiB0d2Vlbi5yZXNldFRvKFwic2Nyb2xsWVwiLCBtYXhZKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb250ZW50ICYmIGdzYXAuc2V0KGNvbnRlbnQsIHtcclxuICAgIHk6IFwiKz0wXCJcclxuICB9KTsgLy8gdG8gZW5zdXJlIHRoZXJlJ3MgYSBjYWNoZSAoZWxlbWVudC5fZ3NhcClcclxuXHJcbiAgdmFycy5pZ25vcmVDaGVjayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICByZXR1cm4gX2ZpeElPU0J1ZyAmJiBlLnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgaWdub3JlRHJhZyhlKSB8fCBzY2FsZSA+IDEuMDUgJiYgZS50eXBlICE9PSBcInRvdWNoc3RhcnRcIiB8fCBzZWxmLmlzR2VzdHVyaW5nIHx8IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMTtcclxuICB9O1xyXG5cclxuICB2YXJzLm9uUHJlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XHJcbiAgICB2YXIgcHJldlNjYWxlID0gc2NhbGU7XHJcbiAgICBzY2FsZSA9IF9yb3VuZCgoX3dpbi52aXN1YWxWaWV3cG9ydCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0LnNjYWxlIHx8IDEpIC8gaW5pdGlhbFNjYWxlKTtcclxuICAgIHR3ZWVuLnBhdXNlKCk7XHJcbiAgICBwcmV2U2NhbGUgIT09IHNjYWxlICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCBzY2FsZSA+IDEuMDEgPyB0cnVlIDogbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xyXG4gICAgc3RhcnRTY3JvbGxYID0gc2Nyb2xsRnVuY1goKTtcclxuICAgIHN0YXJ0U2Nyb2xsWSA9IHNjcm9sbEZ1bmNZKCk7XHJcbiAgICB1cGRhdGVDbGFtcHMoKTtcclxuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xyXG4gIH07XHJcblxyXG4gIHZhcnMub25SZWxlYXNlID0gdmFycy5vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIChzZWxmLCB3YXNEcmFnZ2luZykge1xyXG4gICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcclxuXHJcbiAgICBpZiAoIXdhc0RyYWdnaW5nKSB7XHJcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfc2Nyb2xsZXJzLmNhY2hlKys7IC8vIG1ha2Ugc3VyZSB3ZSdyZSBwdWxsaW5nIHRoZSBub24tY2FjaGVkIHZhbHVlXHJcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXHJcblxyXG4gICAgICB2YXIgZHVyID0gcmVzb2x2ZU1vbWVudHVtRHVyYXRpb24oKSxcclxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXHJcbiAgICAgICAgICBlbmRTY3JvbGw7XHJcblxyXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xyXG4gICAgICAgIGN1cnJlbnRTY3JvbGwgPSBzY3JvbGxGdW5jWCgpO1xyXG4gICAgICAgIGVuZFNjcm9sbCA9IGN1cnJlbnRTY3JvbGwgKyBkdXIgKiAwLjA1ICogLXNlbGYudmVsb2NpdHlYIC8gMC4yMjc7IC8vIHRoZSBjb25zdGFudCAuMjI3IGlzIGZyb20gcG93ZXI0KDAuMDUpLiB2ZWxvY2l0eSBpcyBpbnZlcnRlZCBiZWNhdXNlIHNjcm9sbGluZyBnb2VzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcblxyXG4gICAgICAgIGR1ciAqPSBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuY1gsIGN1cnJlbnRTY3JvbGwsIGVuZFNjcm9sbCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSk7XHJcbiAgICAgICAgdHdlZW4udmFycy5zY3JvbGxYID0gc2Nyb2xsQ2xhbXBYKGVuZFNjcm9sbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1cnJlbnRTY3JvbGwgPSBzY3JvbGxGdW5jWSgpO1xyXG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxyXG5cclxuICAgICAgZHVyICo9IF9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllcihzY3JvbGxGdW5jWSwgY3VycmVudFNjcm9sbCwgZW5kU2Nyb2xsLCBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKSk7XHJcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xyXG4gICAgICB0d2Vlbi5pbnZhbGlkYXRlKCkuZHVyYXRpb24oZHVyKS5wbGF5KDAuMDEpO1xyXG5cclxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCA+PSBtYXhZIC0gMSkge1xyXG4gICAgICAgIC8vIGlPUyBidWc6IGl0J2xsIHNob3cgdGhlIGFkZHJlc3MgYmFyIGJ1dCBOT1QgZmlyZSB0aGUgd2luZG93IFwicmVzaXplXCIgZXZlbnQgdW50aWwgdGhlIGFuaW1hdGlvbiBpcyBkb25lIGJ1dCB3ZSBtdXN0IHByb3RlY3QgYWdhaW5zdCBvdmVyc2hvb3Qgc28gd2UgbGV2ZXJhZ2UgYW4gb25VcGRhdGUgdG8gZG8gc28uXHJcbiAgICAgICAgZ3NhcC50byh7fSwge1xyXG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxyXG4gICAgICAgICAgZHVyYXRpb246IGR1clxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25SZWxlYXNlICYmIG9uUmVsZWFzZShzZWxmKTtcclxuICB9O1xyXG5cclxuICB2YXJzLm9uV2hlZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0d2Vlbi5fdHMgJiYgdHdlZW4ucGF1c2UoKTtcclxuXHJcbiAgICBpZiAoX2dldFRpbWUoKSAtIHdoZWVsUmVmcmVzaCA+IDEwMDApIHtcclxuICAgICAgLy8gYWZ0ZXIgMSBzZWNvbmQsIHJlZnJlc2ggdGhlIGNsYW1wcyBvdGhlcndpc2UgdGhhdCdsbCBvbmx5IGhhcHBlbiB3aGVuIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpIGlzIGNhbGxlZCBvciBmb3IgdG91Y2gtc2Nyb2xsaW5nLlxyXG4gICAgICBsYXN0UmVmcmVzaElEID0gMDtcclxuICAgICAgd2hlZWxSZWZyZXNoID0gX2dldFRpbWUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXJzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHNlbGYsIGR4LCBkeSwgeEFycmF5LCB5QXJyYXkpIHtcclxuICAgIF9yZWZyZXNoSUQgIT09IGxhc3RSZWZyZXNoSUQgJiYgdXBkYXRlQ2xhbXBzKCk7XHJcbiAgICBkeCAmJiBub3JtYWxpemVTY3JvbGxYICYmIHNjcm9sbEZ1bmNYKHNjcm9sbENsYW1wWCh4QXJyYXlbMl0gPT09IGR4ID8gc3RhcnRTY3JvbGxYICsgKHNlbGYuc3RhcnRYIC0gc2VsZi54KSA6IHNjcm9sbEZ1bmNYKCkgKyBkeCAtIHhBcnJheVsxXSkpOyAvLyBmb3IgbW9yZSBwcmVjaXNpb24sIHdlIHRyYWNrIHBvaW50ZXIvdG91Y2ggbW92ZW1lbnQgZnJvbSB0aGUgc3RhcnQsIG90aGVyd2lzZSBpdCdsbCBkcmlmdC5cclxuXHJcbiAgICBpZiAoZHkpIHtcclxuICAgICAgc2Nyb2xsRnVuY1kub2Zmc2V0ICYmIHJlbW92ZUNvbnRlbnRPZmZzZXQoKTtcclxuICAgICAgdmFyIGlzVG91Y2ggPSB5QXJyYXlbMl0gPT09IGR5LFxyXG4gICAgICAgICAgeSA9IGlzVG91Y2ggPyBzdGFydFNjcm9sbFkgKyBzZWxmLnN0YXJ0WSAtIHNlbGYueSA6IHNjcm9sbEZ1bmNZKCkgKyBkeSAtIHlBcnJheVsxXSxcclxuICAgICAgICAgIHlDbGFtcGVkID0gc2Nyb2xsQ2xhbXBZKHkpO1xyXG4gICAgICBpc1RvdWNoICYmIHkgIT09IHlDbGFtcGVkICYmIChzdGFydFNjcm9sbFkgKz0geUNsYW1wZWQgLSB5KTtcclxuICAgICAgc2Nyb2xsRnVuY1koeUNsYW1wZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIChkeSB8fCBkeCkgJiYgX3VwZGF0ZUFsbCgpO1xyXG4gIH07XHJcblxyXG4gIHZhcnMub25FbmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xyXG5cclxuICAgIFNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInJlZnJlc2hcIiwgb25SZXNpemUpO1xyXG5cclxuICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInJlc2l6ZVwiLCBvblJlc2l6ZSk7XHJcblxyXG4gICAgaWYgKHNjcm9sbEZ1bmNZLnNtb290aCkge1xyXG4gICAgICBzY3JvbGxGdW5jWS50YXJnZXQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIjtcclxuICAgICAgc2Nyb2xsRnVuY1kuc21vb3RoID0gc2Nyb2xsRnVuY1guc21vb3RoID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRPYnNlcnZlci5lbmFibGUoKTtcclxuICB9O1xyXG5cclxuICB2YXJzLm9uRGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcodGFyZ2V0LCB0cnVlKTtcclxuXHJcbiAgICBfcmVtb3ZlTGlzdGVuZXIoX3dpbiwgXCJyZXNpemVcIiwgb25SZXNpemUpO1xyXG5cclxuICAgIFNjcm9sbFRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlZnJlc2hcIiwgb25SZXNpemUpO1xyXG4gICAgaW5wdXRPYnNlcnZlci5raWxsKCk7XHJcbiAgfTtcclxuXHJcbiAgdmFycy5sb2NrQXhpcyA9IHZhcnMubG9ja0F4aXMgIT09IGZhbHNlO1xyXG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XHJcbiAgc2VsZi5pT1MgPSBfZml4SU9TQnVnOyAvLyB1c2VkIGluIHRoZSBPYnNlcnZlciBnZXRDYWNoZWRTY3JvbGwoKSBmdW5jdGlvbiB0byB3b3JrIGFyb3VuZCBhbiBpT1MgYnVnIHRoYXQgd3JlYWtzIGhhdm9jIHdpdGggVG91Y2hFdmVudC5jbGllbnRZIGlmIHdlIGFsbG93IHNjcm9sbCB0byBnbyBhbGwgdGhlIHdheSBiYWNrIHRvIDAuXHJcblxyXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxyXG5cclxuICBfZml4SU9TQnVnICYmIGdzYXAudGlja2VyLmFkZChfcGFzc1Rocm91Z2gpOyAvLyBwcmV2ZW50IHRoZSB0aWNrZXIgZnJvbSBzbGVlcGluZ1xyXG5cclxuICBvblN0b3BEZWxheWVkQ2FsbCA9IHNlbGYuX2RjO1xyXG4gIHR3ZWVuID0gZ3NhcC50byhzZWxmLCB7XHJcbiAgICBlYXNlOiBcInBvd2VyNFwiLFxyXG4gICAgcGF1c2VkOiB0cnVlLFxyXG4gICAgaW5oZXJpdDogZmFsc2UsXHJcbiAgICBzY3JvbGxYOiBub3JtYWxpemVTY3JvbGxYID8gXCIrPTAuMVwiIDogXCIrPTBcIixcclxuICAgIHNjcm9sbFk6IFwiKz0wLjFcIixcclxuICAgIG1vZGlmaWVyczoge1xyXG4gICAgICBzY3JvbGxZOiBfaW50ZXJydXB0aW9uVHJhY2tlcihzY3JvbGxGdW5jWSwgc2Nyb2xsRnVuY1koKSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0d2Vlbi5wYXVzZSgpO1xyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIG9uVXBkYXRlOiBfdXBkYXRlQWxsLFxyXG4gICAgb25Db21wbGV0ZTogb25TdG9wRGVsYXllZENhbGwudmFycy5vbkNvbXBsZXRlXHJcbiAgfSk7IC8vIHdlIG5lZWQgdGhlIG1vZGlmaWVyIHRvIHNlbnNlIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgYWx0ZXJlZCBvdXRzaWRlIG9mIHRoZSBtb21lbnR1bSB0d2VlbiAobGlrZSB3aXRoIGEgc2Nyb2xsVG8gdHdlZW4pIHNvIHdlIGNhbiBwYXVzZSgpIGl0IHRvIHByZXZlbnQgY29uZmxpY3RzLlxyXG5cclxuICByZXR1cm4gc2VsZjtcclxufTtcclxuXHJcblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgaWYgKF9pc0Z1bmN0aW9uKGZ1bmMpKSB7XHJcbiAgICByZXR1cm4gX3RyaWdnZXJzLnNvcnQoZnVuYyk7XHJcbiAgfVxyXG5cclxuICB2YXIgc2Nyb2xsID0gX3dpbi5wYWdlWU9mZnNldCB8fCAwO1xyXG4gIFNjcm9sbFRyaWdnZXIuZ2V0QWxsKCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgcmV0dXJuIHQuX3NvcnRZID0gdC50cmlnZ2VyID8gc2Nyb2xsICsgdC50cmlnZ2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IHQuc3RhcnQgKyBfd2luLmlubmVySGVpZ2h0O1xyXG4gIH0pO1xyXG4gIHJldHVybiBfdHJpZ2dlcnMuc29ydChmdW5jIHx8IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gKGEudmFycy5yZWZyZXNoUHJpb3JpdHkgfHwgMCkgKiAtMWU2ICsgKGEudmFycy5jb250YWluZXJBbmltYXRpb24gPyAxZTYgOiBhLl9zb3J0WSkgLSAoKGIudmFycy5jb250YWluZXJBbmltYXRpb24gPyAxZTYgOiBiLl9zb3J0WSkgKyAoYi52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYpO1xyXG4gIH0pOyAvLyBhbnl0aGluZyB3aXRoIGEgY29udGFpbmVyQW5pbWF0aW9uIHNob3VsZCByZWZyZXNoIGxhc3QuXHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLm9ic2VydmUgPSBmdW5jdGlvbiAodmFycykge1xyXG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLm5vcm1hbGl6ZVNjcm9sbCA9IGZ1bmN0aW9uICh2YXJzKSB7XHJcbiAgaWYgKHR5cGVvZiB2YXJzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICByZXR1cm4gX25vcm1hbGl6ZXI7XHJcbiAgfVxyXG5cclxuICBpZiAodmFycyA9PT0gdHJ1ZSAmJiBfbm9ybWFsaXplcikge1xyXG4gICAgcmV0dXJuIF9ub3JtYWxpemVyLmVuYWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHZhcnMgPT09IGZhbHNlKSB7XHJcbiAgICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5raWxsKCk7XHJcbiAgICBfbm9ybWFsaXplciA9IHZhcnM7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgbm9ybWFsaXplciA9IHZhcnMgaW5zdGFuY2VvZiBPYnNlcnZlciA/IHZhcnMgOiBfZ2V0U2Nyb2xsTm9ybWFsaXplcih2YXJzKTtcclxuICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci50YXJnZXQgPT09IG5vcm1hbGl6ZXIudGFyZ2V0ICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcclxuICBfaXNWaWV3cG9ydChub3JtYWxpemVyLnRhcmdldCkgJiYgKF9ub3JtYWxpemVyID0gbm9ybWFsaXplcik7XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZXI7XHJcbn07XHJcblxyXG5TY3JvbGxUcmlnZ2VyLmNvcmUgPSB7XHJcbiAgLy8gc21hbGxlciBmaWxlIHNpemUgd2F5IHRvIGxldmVyYWdlIGluIFNjcm9sbFNtb290aGVyIGFuZCBPYnNlcnZlclxyXG4gIF9nZXRWZWxvY2l0eVByb3A6IF9nZXRWZWxvY2l0eVByb3AsXHJcbiAgX2lucHV0T2JzZXJ2ZXI6IF9pbnB1dE9ic2VydmVyLFxyXG4gIF9zY3JvbGxlcnM6IF9zY3JvbGxlcnMsXHJcbiAgX3Byb3hpZXM6IF9wcm94aWVzLFxyXG4gIGJyaWRnZToge1xyXG4gICAgLy8gd2hlbiBub3JtYWxpemVTY3JvbGwgc2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIChzcyA9IHNldFNjcm9sbClcclxuICAgIHNzOiBmdW5jdGlvbiBzcygpIHtcclxuICAgICAgX2xhc3RTY3JvbGxUaW1lIHx8IF9kaXNwYXRjaChcInNjcm9sbFN0YXJ0XCIpO1xyXG4gICAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xyXG4gICAgfSxcclxuICAgIC8vIGEgd2F5IHRvIGdldCB0aGUgX3JlZnJlc2hpbmcgdmFsdWUgaW4gT2JzZXJ2ZXJcclxuICAgIHJlZjogZnVuY3Rpb24gcmVmKCkge1xyXG4gICAgICByZXR1cm4gX3JlZnJlc2hpbmc7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcik7XHJcbmV4cG9ydCB7IFNjcm9sbFRyaWdnZXIgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/ScrollTrigger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gsap/SplitText.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/SplitText.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SplitText: () => (/* binding */ SplitText),\n/* harmony export */   \"default\": () => (/* binding */ SplitText)\n/* harmony export */ });\n/*!\r\n * SplitText 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\r\n * @author: Jack Doyle\r\n */\r\n\r\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\r\n}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\r\n  if (specialCharsRegEx) {\r\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\r\n    if (charsFound.size) {\r\n      while (--i > -1) {\r\n        word = collection[i];\r\n        for (char of charsFound) {\r\n          if (char.startsWith(word) && char.length > word.length) {\r\n            slots = 0;\r\n            combined = word;\r\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\r\n            }\r\n            if (slots && combined.length === char.length) {\r\n              collection[i] = char;\r\n              collection.splice(i + 1, slots);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return collection;\r\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\r\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\r\n    let el = document.createElement(tag), i = collection.length + 1;\r\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\r\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\r\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\r\n    if (tag !== \"span\") {\r\n      el.style.position = \"relative\";\r\n      el.style.display = display;\r\n    }\r\n    el.textContent = text;\r\n    collection.push(el);\r\n    return el;\r\n  };\r\n  incrementClass && (className = className.replace(\"++\", \"\"));\r\n  wrapper.collection = collection;\r\n  return wrapper;\r\n}, _getLineWrapper = (element, nodes, config, collection) => {\r\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\r\n  return (startIndex, endIndex) => {\r\n    let newLine = lineWrapper(\"\");\r\n    newLine.style.textAlign = textAlign;\r\n    element.insertBefore(newLine, nodes[startIndex]);\r\n    for (; startIndex < endIndex; startIndex++) {\r\n      newLine.appendChild(nodes[startIndex]);\r\n    }\r\n    newLine.normalize();\r\n  };\r\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\r\n  var _a;\r\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\r\n  if (typeof wordDelimiter === \"object\") {\r\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\r\n    wordDelimString = wordDelimiter.replaceWith || \"\";\r\n  } else {\r\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\r\n  }\r\n  wordDelimIsNotSpace = wordDelimString !== \" \";\r\n  for (; i < nodes.length; i++) {\r\n    curNode = nodes[i];\r\n    if (curNode.nodeType === 3) {\r\n      curTextContent = curNode.textContent || \"\";\r\n      if (reduceWhiteSpace) {\r\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\r\n      } else if (isPreformatted) {\r\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\r\n      }\r\n      prepareText && (curTextContent = prepareText(curTextContent, element));\r\n      curNode.textContent = curTextContent;\r\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\r\n      lastWordText = words[words.length - 1];\r\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\r\n      lastWordText || words.pop();\r\n      lastBounds = elementBounds;\r\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\r\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\r\n      words[0] || words.shift();\r\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\r\n      deepSlice && isNested || (curNode.textContent = \"\");\r\n      for (j = 1; j <= words.length; j++) {\r\n        wordText = words[j - 1];\r\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\r\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\r\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\r\n          wordText = wordText.slice(1);\r\n        }\r\n        if (!reduceWhiteSpace && wordText === \"\") {\r\n          _insertNodeBefore(wordDelimString, element, curNode);\r\n        } else if (wordText === \" \") {\r\n          element.insertBefore(document.createTextNode(\" \"), curNode);\r\n        } else {\r\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\r\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\r\n            curWordEl = wordsCollection[wordsCollection.length - 1];\r\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\r\n          } else {\r\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\r\n            _insertNodeBefore(curWordEl, element, curNode);\r\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\r\n          }\r\n          if (charWrapper) {\r\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\r\n            for (k = 0; k < curWordChars.length; k++) {\r\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\r\n            }\r\n          }\r\n          if (deepSlice && isNested) {\r\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\r\n            bounds = curWordEl.getBoundingClientRect();\r\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\r\n              clonedNode = element.cloneNode();\r\n              curSubNode = element.childNodes[0];\r\n              while (curSubNode && curSubNode !== curWordEl) {\r\n                tempSubNode = curSubNode;\r\n                curSubNode = curSubNode.nextSibling;\r\n                clonedNode.appendChild(tempSubNode);\r\n              }\r\n              element.parentNode.insertBefore(clonedNode, element);\r\n              prepForCharsOnly && _disallowInline(clonedNode);\r\n            }\r\n            lastBounds = bounds;\r\n          }\r\n          if (j < words.length || endsWithSpace) {\r\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\r\n          }\r\n        }\r\n      }\r\n      element.removeChild(curNode);\r\n      ignoredPreviousSibling = 0;\r\n    } else if (curNode.nodeType === 1) {\r\n      if (ignore && ignore.indexOf(curNode) > -1) {\r\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\r\n        ignoredPreviousSibling = curNode;\r\n      } else {\r\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\r\n        ignoredPreviousSibling = 0;\r\n      }\r\n      prepForCharsOnly && _disallowInline(curNode);\r\n    }\r\n  }\r\n};\r\nconst _SplitText = class _SplitText {\r\n  constructor(elements, config) {\r\n    this.isSplit = false;\r\n    _initIfNecessary();\r\n    this.elements = _elements(elements);\r\n    this.chars = [];\r\n    this.words = [];\r\n    this.lines = [];\r\n    this.masks = [];\r\n    this.vars = config;\r\n    this._split = () => this.isSplit && this.split(this.vars);\r\n    let orig = [], timerId, checkWidths = () => {\r\n      let i = orig.length, o;\r\n      while (i--) {\r\n        o = orig[i];\r\n        let w = o.element.offsetWidth;\r\n        if (w !== o.width) {\r\n          o.width = w;\r\n          this._split();\r\n          return;\r\n        }\r\n      }\r\n    };\r\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\r\n      clearTimeout(timerId);\r\n      timerId = setTimeout(checkWidths, 200);\r\n    }) };\r\n    _context(this);\r\n    this.split(config);\r\n  }\r\n  split(config) {\r\n    this.isSplit && this.revert();\r\n    this.vars = config = config || this.vars || {};\r\n    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\r\n    if (splitCharacters || splitWords || splitLines) {\r\n      this.elements.forEach((element, index) => {\r\n        orig[index] = {\r\n          element,\r\n          html: element.innerHTML,\r\n          ariaL: element.getAttribute(\"aria-label\"),\r\n          ariaH: element.getAttribute(\"aria-hidden\")\r\n        };\r\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\r\n        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\r\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\r\n        if (splitLines) {\r\n          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\r\n          for (i = 0; i < nodes.length; i++) {\r\n            curNode = nodes[i];\r\n            if (curNode.nodeType === 1) {\r\n              if (curNode.nodeName === \"BR\") {\r\n                toRemove.push(curNode);\r\n                wrapLine(lineStartIndex, i + 1);\r\n                lineStartIndex = i + 1;\r\n                lastBounds = allBounds[lineStartIndex];\r\n              } else {\r\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\r\n                  wrapLine(lineStartIndex, i);\r\n                  lineStartIndex = i;\r\n                }\r\n                lastBounds = allBounds[i];\r\n              }\r\n            }\r\n          }\r\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\r\n          toRemove.forEach((el) => {\r\n            var _a;\r\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\r\n          });\r\n        }\r\n        if (!splitWords) {\r\n          for (i = 0; i < words.length; i++) {\r\n            curWord = words[i];\r\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\r\n              if (smartWrap && !splitLines) {\r\n                smartWrapSpan = document.createElement(\"span\");\r\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\r\n                while (curWord.firstChild) {\r\n                  smartWrapSpan.appendChild(curWord.firstChild);\r\n                }\r\n                curWord.replaceWith(smartWrapSpan);\r\n              } else {\r\n                curWord.replaceWith(...curWord.childNodes);\r\n              }\r\n            } else {\r\n              nextSibling = curWord.nextSibling;\r\n              if (nextSibling && nextSibling.nodeType === 3) {\r\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\r\n                curWord.remove();\r\n              }\r\n            }\r\n          }\r\n          words.length = 0;\r\n          element.normalize();\r\n        }\r\n        this.lines.push(...lines);\r\n        this.words.push(...words);\r\n        this.chars.push(...chars);\r\n      });\r\n      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\r\n        let maskEl = el.cloneNode();\r\n        el.replaceWith(maskEl);\r\n        maskEl.appendChild(el);\r\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\r\n        maskEl.style.overflow = \"clip\";\r\n        return maskEl;\r\n      }));\r\n    }\r\n    this.isSplit = true;\r\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\r\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\r\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\r\n    }\r\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\r\n      orig[index].width = element.offsetWidth;\r\n      obs && obs.observe(element);\r\n    });\r\n    return this;\r\n  }\r\n  revert() {\r\n    var _a, _b;\r\n    let { orig, anim, obs } = this._data;\r\n    obs && obs.disconnect();\r\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\r\n      element.innerHTML = html;\r\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\r\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\r\n    });\r\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\r\n    this.isSplit = false;\r\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\r\n    if (anim) {\r\n      this._data.animTime = anim.totalTime();\r\n      anim.revert();\r\n    }\r\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\r\n    return this;\r\n  }\r\n  static create(elements, config) {\r\n    return new _SplitText(elements, config);\r\n  }\r\n  static register(core) {\r\n    gsap = gsap || core || window.gsap;\r\n    if (gsap) {\r\n      _toArray = gsap.utils.toArray;\r\n      _context = gsap.core.context || _context;\r\n    }\r\n    if (!_coreInitted && window.innerWidth > 0) {\r\n      _fonts = document.fonts;\r\n      _coreInitted = true;\r\n    }\r\n  }\r\n};\r\n_SplitText.version = \"3.13.0\";\r\nlet SplitText = _SplitText;\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJDIiwic291cmNlcyI6WyJEOlxcUHl0aG9uXFx0cmF2ZWwtZGV0YWlsLWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGdzYXBcXFNwbGl0VGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogU3BsaXRUZXh0IDMuMTMuMFxyXG4gKiBodHRwczovL2dzYXAuY29tXHJcbiAqXHJcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZS5cclxuICogQGF1dGhvcjogSmFjayBEb3lsZVxyXG4gKi9cclxuXHJcbmxldCBnc2FwLCBfZm9udHMsIF9jb3JlSW5pdHRlZCwgX2luaXRJZk5lY2Vzc2FyeSA9ICgpID0+IF9jb3JlSW5pdHRlZCB8fCBTcGxpdFRleHQucmVnaXN0ZXIod2luZG93LmdzYXApLCBfY2hhclNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IEludGwuU2VnbWVudGVyKCkgOiAwLCBfdG9BcnJheSA9IChyKSA9PiB0eXBlb2YgciA9PT0gXCJzdHJpbmdcIiA/IF90b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocikpIDogXCJsZW5ndGhcIiBpbiByID8gQXJyYXkuZnJvbShyKSA6IFtyXSwgX2VsZW1lbnRzID0gKHRhcmdldHMpID0+IF90b0FycmF5KHRhcmdldHMpLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSwgX2VtcHR5QXJyYXkgPSBbXSwgX2NvbnRleHQgPSBmdW5jdGlvbigpIHtcclxufSwgX3NwYWNlc1JlZ0V4ID0gL1xccysvZywgX2Vtb2ppU2FmZVJlZ0V4ID0gbmV3IFJlZ0V4cChcIlxcXFxwe1JJfVxcXFxwe1JJfXxcXFxccHtFbW9qaX0oXFxcXHB7RU1vZH18XFxcXHV7RkUwRn1cXFxcdXsyMEUzfT98W1xcXFx1e0UwMDIwfS1cXFxcdXtFMDA3RX1dK1xcXFx1e0UwMDdGfSk/KFxcXFx1ezIwMER9XFxcXHB7RW1vaml9KFxcXFxwe0VNb2R9fFxcXFx1e0ZFMEZ9XFxcXHV7MjBFM30/fFtcXFxcdXtFMDAyMH0tXFxcXHV7RTAwN0V9XStcXFxcdXtFMDA3Rn0pPykqfC5cIiwgXCJndVwiKSwgX2VtcHR5Qm91bmRzID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSwgX3N0cmV0Y2hUb0ZpdFNwZWNpYWxDaGFycyA9IChjb2xsZWN0aW9uLCBzcGVjaWFsQ2hhcnNSZWdFeCkgPT4ge1xyXG4gIGlmIChzcGVjaWFsQ2hhcnNSZWdFeCkge1xyXG4gICAgbGV0IGNoYXJzRm91bmQgPSBuZXcgU2V0KGNvbGxlY3Rpb24uam9pbihcIlwiKS5tYXRjaChzcGVjaWFsQ2hhcnNSZWdFeCkgfHwgX2VtcHR5QXJyYXkpLCBpID0gY29sbGVjdGlvbi5sZW5ndGgsIHNsb3RzLCB3b3JkLCBjaGFyLCBjb21iaW5lZDtcclxuICAgIGlmIChjaGFyc0ZvdW5kLnNpemUpIHtcclxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XHJcbiAgICAgICAgd29yZCA9IGNvbGxlY3Rpb25baV07XHJcbiAgICAgICAgZm9yIChjaGFyIG9mIGNoYXJzRm91bmQpIHtcclxuICAgICAgICAgIGlmIChjaGFyLnN0YXJ0c1dpdGgod29yZCkgJiYgY2hhci5sZW5ndGggPiB3b3JkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzbG90cyA9IDA7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkID0gd29yZDtcclxuICAgICAgICAgICAgd2hpbGUgKGNoYXIuc3RhcnRzV2l0aChjb21iaW5lZCArPSBjb2xsZWN0aW9uW2kgKyArK3Nsb3RzXSkgJiYgY29tYmluZWQubGVuZ3RoIDwgY2hhci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2xvdHMgJiYgY29tYmluZWQubGVuZ3RoID09PSBjaGFyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgIGNvbGxlY3Rpb25baV0gPSBjaGFyO1xyXG4gICAgICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGkgKyAxLCBzbG90cyk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbn0sIF9kaXNhbGxvd0lubGluZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiKSwgX2luc2VydE5vZGVCZWZvcmUgPSAobmV3Q2hpbGQsIHBhcmVudCwgZXhpc3RpbmdDaGlsZCkgPT4gcGFyZW50Lmluc2VydEJlZm9yZSh0eXBlb2YgbmV3Q2hpbGQgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdDaGlsZCkgOiBuZXdDaGlsZCwgZXhpc3RpbmdDaGlsZCksIF9nZXRXcmFwcGVyID0gKHR5cGUsIGNvbmZpZywgY29sbGVjdGlvbikgPT4ge1xyXG4gIGxldCBjbGFzc05hbWUgPSBjb25maWdbdHlwZSArIFwic0NsYXNzXCJdIHx8IFwiXCIsIHsgdGFnID0gXCJkaXZcIiwgYXJpYSA9IFwiYXV0b1wiLCBwcm9wSW5kZXggPSBmYWxzZSB9ID0gY29uZmlnLCBkaXNwbGF5ID0gdHlwZSA9PT0gXCJsaW5lXCIgPyBcImJsb2NrXCIgOiBcImlubGluZS1ibG9ja1wiLCBpbmNyZW1lbnRDbGFzcyA9IGNsYXNzTmFtZS5pbmRleE9mKFwiKytcIikgPiAtMSwgd3JhcHBlciA9ICh0ZXh0KSA9PiB7XHJcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyksIGkgPSBjb2xsZWN0aW9uLmxlbmd0aCArIDE7XHJcbiAgICBjbGFzc05hbWUgJiYgKGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArIChpbmNyZW1lbnRDbGFzcyA/IFwiIFwiICsgY2xhc3NOYW1lICsgaSA6IFwiXCIpKTtcclxuICAgIHByb3BJbmRleCAmJiBlbC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tXCIgKyB0eXBlLCBpICsgXCJcIik7XHJcbiAgICBhcmlhICE9PSBcIm5vbmVcIiAmJiBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICBpZiAodGFnICE9PSBcInNwYW5cIikge1xyXG4gICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XHJcbiAgICB9XHJcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XHJcbiAgICBjb2xsZWN0aW9uLnB1c2goZWwpO1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcbiAgaW5jcmVtZW50Q2xhc3MgJiYgKGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKFwiKytcIiwgXCJcIikpO1xyXG4gIHdyYXBwZXIuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XHJcbiAgcmV0dXJuIHdyYXBwZXI7XHJcbn0sIF9nZXRMaW5lV3JhcHBlciA9IChlbGVtZW50LCBub2RlcywgY29uZmlnLCBjb2xsZWN0aW9uKSA9PiB7XHJcbiAgbGV0IGxpbmVXcmFwcGVyID0gX2dldFdyYXBwZXIoXCJsaW5lXCIsIGNvbmZpZywgY29sbGVjdGlvbiksIHRleHRBbGlnbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnRleHRBbGlnbiB8fCBcImxlZnRcIjtcclxuICByZXR1cm4gKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB7XHJcbiAgICBsZXQgbmV3TGluZSA9IGxpbmVXcmFwcGVyKFwiXCIpO1xyXG4gICAgbmV3TGluZS5zdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XHJcbiAgICBlbGVtZW50Lmluc2VydEJlZm9yZShuZXdMaW5lLCBub2Rlc1tzdGFydEluZGV4XSk7XHJcbiAgICBmb3IgKDsgc3RhcnRJbmRleCA8IGVuZEluZGV4OyBzdGFydEluZGV4KyspIHtcclxuICAgICAgbmV3TGluZS5hcHBlbmRDaGlsZChub2Rlc1tzdGFydEluZGV4XSk7XHJcbiAgICB9XHJcbiAgICBuZXdMaW5lLm5vcm1hbGl6ZSgpO1xyXG4gIH07XHJcbn0sIF9zcGxpdFdvcmRzQW5kQ2hhcnNSZWN1cnNpdmVseSA9IChlbGVtZW50LCBjb25maWcsIHdvcmRXcmFwcGVyLCBjaGFyV3JhcHBlciwgcHJlcEZvckNoYXJzT25seSwgZGVlcFNsaWNlLCBpZ25vcmUsIGNoYXJTcGxpdFJlZ0V4LCBzcGVjaWFsQ2hhcnNSZWdFeCwgaXNOZXN0ZWQpID0+IHtcclxuICB2YXIgX2E7XHJcbiAgbGV0IG5vZGVzID0gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpLCBpID0gMCwgeyB3b3JkRGVsaW1pdGVyLCByZWR1Y2VXaGl0ZVNwYWNlID0gdHJ1ZSwgcHJlcGFyZVRleHQgfSA9IGNvbmZpZywgZWxlbWVudEJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxhc3RCb3VuZHMgPSBlbGVtZW50Qm91bmRzLCBpc1ByZWZvcm1hdHRlZCA9ICFyZWR1Y2VXaGl0ZVNwYWNlICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLndoaXRlU3BhY2Uuc3Vic3RyaW5nKDAsIDMpID09PSBcInByZVwiLCBpZ25vcmVkUHJldmlvdXNTaWJsaW5nID0gMCwgd29yZHNDb2xsZWN0aW9uID0gd29yZFdyYXBwZXIuY29sbGVjdGlvbiwgd29yZERlbGltSXNOb3RTcGFjZSwgd29yZERlbGltU3RyaW5nLCB3b3JkRGVsaW1TcGxpdHRlciwgY3VyTm9kZSwgd29yZHMsIGN1cldvcmRFbCwgc3RhcnRzV2l0aFNwYWNlLCBlbmRzV2l0aFNwYWNlLCBqLCBib3VuZHMsIGN1cldvcmRDaGFycywgY2xvbmVkTm9kZSwgY3VyU3ViTm9kZSwgdGVtcFN1Yk5vZGUsIGN1clRleHRDb250ZW50LCB3b3JkVGV4dCwgbGFzdFdvcmRUZXh0LCBrO1xyXG4gIGlmICh0eXBlb2Ygd29yZERlbGltaXRlciA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgd29yZERlbGltU3BsaXR0ZXIgPSB3b3JkRGVsaW1pdGVyLmRlbGltaXRlciB8fCB3b3JkRGVsaW1pdGVyO1xyXG4gICAgd29yZERlbGltU3RyaW5nID0gd29yZERlbGltaXRlci5yZXBsYWNlV2l0aCB8fCBcIlwiO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3b3JkRGVsaW1TdHJpbmcgPSB3b3JkRGVsaW1pdGVyID09PSBcIlwiID8gXCJcIiA6IHdvcmREZWxpbWl0ZXIgfHwgXCIgXCI7XHJcbiAgfVxyXG4gIHdvcmREZWxpbUlzTm90U3BhY2UgPSB3b3JkRGVsaW1TdHJpbmcgIT09IFwiIFwiO1xyXG4gIGZvciAoOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGN1ck5vZGUgPSBub2Rlc1tpXTtcclxuICAgIGlmIChjdXJOb2RlLm5vZGVUeXBlID09PSAzKSB7XHJcbiAgICAgIGN1clRleHRDb250ZW50ID0gY3VyTm9kZS50ZXh0Q29udGVudCB8fCBcIlwiO1xyXG4gICAgICBpZiAocmVkdWNlV2hpdGVTcGFjZSkge1xyXG4gICAgICAgIGN1clRleHRDb250ZW50ID0gY3VyVGV4dENvbnRlbnQucmVwbGFjZShfc3BhY2VzUmVnRXgsIFwiIFwiKTtcclxuICAgICAgfSBlbHNlIGlmIChpc1ByZWZvcm1hdHRlZCkge1xyXG4gICAgICAgIGN1clRleHRDb250ZW50ID0gY3VyVGV4dENvbnRlbnQucmVwbGFjZSgvXFxuL2csIHdvcmREZWxpbVN0cmluZyArIFwiXFxuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHByZXBhcmVUZXh0ICYmIChjdXJUZXh0Q29udGVudCA9IHByZXBhcmVUZXh0KGN1clRleHRDb250ZW50LCBlbGVtZW50KSk7XHJcbiAgICAgIGN1ck5vZGUudGV4dENvbnRlbnQgPSBjdXJUZXh0Q29udGVudDtcclxuICAgICAgd29yZHMgPSB3b3JkRGVsaW1TdHJpbmcgfHwgd29yZERlbGltU3BsaXR0ZXIgPyBjdXJUZXh0Q29udGVudC5zcGxpdCh3b3JkRGVsaW1TcGxpdHRlciB8fCB3b3JkRGVsaW1TdHJpbmcpIDogY3VyVGV4dENvbnRlbnQubWF0Y2goY2hhclNwbGl0UmVnRXgpIHx8IF9lbXB0eUFycmF5O1xyXG4gICAgICBsYXN0V29yZFRleHQgPSB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXTtcclxuICAgICAgZW5kc1dpdGhTcGFjZSA9IHdvcmREZWxpbUlzTm90U3BhY2UgPyBsYXN0V29yZFRleHQuc2xpY2UoLTEpID09PSBcIiBcIiA6ICFsYXN0V29yZFRleHQ7XHJcbiAgICAgIGxhc3RXb3JkVGV4dCB8fCB3b3Jkcy5wb3AoKTtcclxuICAgICAgbGFzdEJvdW5kcyA9IGVsZW1lbnRCb3VuZHM7XHJcbiAgICAgIHN0YXJ0c1dpdGhTcGFjZSA9IHdvcmREZWxpbUlzTm90U3BhY2UgPyB3b3Jkc1swXS5jaGFyQXQoMCkgPT09IFwiIFwiIDogIXdvcmRzWzBdO1xyXG4gICAgICBzdGFydHNXaXRoU3BhY2UgJiYgX2luc2VydE5vZGVCZWZvcmUoXCIgXCIsIGVsZW1lbnQsIGN1ck5vZGUpO1xyXG4gICAgICB3b3Jkc1swXSB8fCB3b3Jkcy5zaGlmdCgpO1xyXG4gICAgICBfc3RyZXRjaFRvRml0U3BlY2lhbENoYXJzKHdvcmRzLCBzcGVjaWFsQ2hhcnNSZWdFeCk7XHJcbiAgICAgIGRlZXBTbGljZSAmJiBpc05lc3RlZCB8fCAoY3VyTm9kZS50ZXh0Q29udGVudCA9IFwiXCIpO1xyXG4gICAgICBmb3IgKGogPSAxOyBqIDw9IHdvcmRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgd29yZFRleHQgPSB3b3Jkc1tqIC0gMV07XHJcbiAgICAgICAgaWYgKCFyZWR1Y2VXaGl0ZVNwYWNlICYmIGlzUHJlZm9ybWF0dGVkICYmIHdvcmRUZXh0LmNoYXJBdCgwKSA9PT0gXCJcXG5cIikge1xyXG4gICAgICAgICAgKF9hID0gY3VyTm9kZS5wcmV2aW91c1NpYmxpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcclxuICAgICAgICAgIF9pbnNlcnROb2RlQmVmb3JlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgZWxlbWVudCwgY3VyTm9kZSk7XHJcbiAgICAgICAgICB3b3JkVGV4dCA9IHdvcmRUZXh0LnNsaWNlKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlZHVjZVdoaXRlU3BhY2UgJiYgd29yZFRleHQgPT09IFwiXCIpIHtcclxuICAgICAgICAgIF9pbnNlcnROb2RlQmVmb3JlKHdvcmREZWxpbVN0cmluZywgZWxlbWVudCwgY3VyTm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh3b3JkVGV4dCA9PT0gXCIgXCIpIHtcclxuICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSwgY3VyTm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHdvcmREZWxpbUlzTm90U3BhY2UgJiYgd29yZFRleHQuY2hhckF0KDApID09PSBcIiBcIiAmJiBfaW5zZXJ0Tm9kZUJlZm9yZShcIiBcIiwgZWxlbWVudCwgY3VyTm9kZSk7XHJcbiAgICAgICAgICBpZiAoaWdub3JlZFByZXZpb3VzU2libGluZyAmJiBqID09PSAxICYmICFzdGFydHNXaXRoU3BhY2UgJiYgd29yZHNDb2xsZWN0aW9uLmluZGV4T2YoaWdub3JlZFByZXZpb3VzU2libGluZy5wYXJlbnROb2RlKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGN1cldvcmRFbCA9IHdvcmRzQ29sbGVjdGlvblt3b3Jkc0NvbGxlY3Rpb24ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGN1cldvcmRFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGFyV3JhcHBlciA/IFwiXCIgOiB3b3JkVGV4dCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3VyV29yZEVsID0gd29yZFdyYXBwZXIoY2hhcldyYXBwZXIgPyBcIlwiIDogd29yZFRleHQpO1xyXG4gICAgICAgICAgICBfaW5zZXJ0Tm9kZUJlZm9yZShjdXJXb3JkRWwsIGVsZW1lbnQsIGN1ck5vZGUpO1xyXG4gICAgICAgICAgICBpZ25vcmVkUHJldmlvdXNTaWJsaW5nICYmIGogPT09IDEgJiYgIXN0YXJ0c1dpdGhTcGFjZSAmJiBjdXJXb3JkRWwuaW5zZXJ0QmVmb3JlKGlnbm9yZWRQcmV2aW91c1NpYmxpbmcsIGN1cldvcmRFbC5maXJzdENoaWxkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjaGFyV3JhcHBlcikge1xyXG4gICAgICAgICAgICBjdXJXb3JkQ2hhcnMgPSBfY2hhclNlZ21lbnRlciA/IF9zdHJldGNoVG9GaXRTcGVjaWFsQ2hhcnMoWy4uLl9jaGFyU2VnbWVudGVyLnNlZ21lbnQod29yZFRleHQpXS5tYXAoKHMpID0+IHMuc2VnbWVudCksIHNwZWNpYWxDaGFyc1JlZ0V4KSA6IHdvcmRUZXh0Lm1hdGNoKGNoYXJTcGxpdFJlZ0V4KSB8fCBfZW1wdHlBcnJheTtcclxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cldvcmRDaGFycy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgIGN1cldvcmRFbC5hcHBlbmRDaGlsZChjdXJXb3JkQ2hhcnNba10gPT09IFwiIFwiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpIDogY2hhcldyYXBwZXIoY3VyV29yZENoYXJzW2tdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChkZWVwU2xpY2UgJiYgaXNOZXN0ZWQpIHtcclxuICAgICAgICAgICAgY3VyVGV4dENvbnRlbnQgPSBjdXJOb2RlLnRleHRDb250ZW50ID0gY3VyVGV4dENvbnRlbnQuc3Vic3RyaW5nKHdvcmRUZXh0Lmxlbmd0aCArIDEsIGN1clRleHRDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGJvdW5kcyA9IGN1cldvcmRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgaWYgKGJvdW5kcy50b3AgPiBsYXN0Qm91bmRzLnRvcCAmJiBib3VuZHMubGVmdCA8PSBsYXN0Qm91bmRzLmxlZnQpIHtcclxuICAgICAgICAgICAgICBjbG9uZWROb2RlID0gZWxlbWVudC5jbG9uZU5vZGUoKTtcclxuICAgICAgICAgICAgICBjdXJTdWJOb2RlID0gZWxlbWVudC5jaGlsZE5vZGVzWzBdO1xyXG4gICAgICAgICAgICAgIHdoaWxlIChjdXJTdWJOb2RlICYmIGN1clN1Yk5vZGUgIT09IGN1cldvcmRFbCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcFN1Yk5vZGUgPSBjdXJTdWJOb2RlO1xyXG4gICAgICAgICAgICAgICAgY3VyU3ViTm9kZSA9IGN1clN1Yk5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWROb2RlLmFwcGVuZENoaWxkKHRlbXBTdWJOb2RlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZWROb2RlLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICBwcmVwRm9yQ2hhcnNPbmx5ICYmIF9kaXNhbGxvd0lubGluZShjbG9uZWROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0Qm91bmRzID0gYm91bmRzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGogPCB3b3Jkcy5sZW5ndGggfHwgZW5kc1dpdGhTcGFjZSkge1xyXG4gICAgICAgICAgICBfaW5zZXJ0Tm9kZUJlZm9yZShqID49IHdvcmRzLmxlbmd0aCA/IFwiIFwiIDogd29yZERlbGltSXNOb3RTcGFjZSAmJiB3b3JkVGV4dC5zbGljZSgtMSkgPT09IFwiIFwiID8gXCIgXCIgKyB3b3JkRGVsaW1TdHJpbmcgOiB3b3JkRGVsaW1TdHJpbmcsIGVsZW1lbnQsIGN1ck5vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGN1ck5vZGUpO1xyXG4gICAgICBpZ25vcmVkUHJldmlvdXNTaWJsaW5nID0gMDtcclxuICAgIH0gZWxzZSBpZiAoY3VyTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICBpZiAoaWdub3JlICYmIGlnbm9yZS5pbmRleE9mKGN1ck5vZGUpID4gLTEpIHtcclxuICAgICAgICB3b3Jkc0NvbGxlY3Rpb24uaW5kZXhPZihjdXJOb2RlLnByZXZpb3VzU2libGluZykgPiAtMSAmJiB3b3Jkc0NvbGxlY3Rpb25bd29yZHNDb2xsZWN0aW9uLmxlbmd0aCAtIDFdLmFwcGVuZENoaWxkKGN1ck5vZGUpO1xyXG4gICAgICAgIGlnbm9yZWRQcmV2aW91c1NpYmxpbmcgPSBjdXJOb2RlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9zcGxpdFdvcmRzQW5kQ2hhcnNSZWN1cnNpdmVseShjdXJOb2RlLCBjb25maWcsIHdvcmRXcmFwcGVyLCBjaGFyV3JhcHBlciwgcHJlcEZvckNoYXJzT25seSwgZGVlcFNsaWNlLCBpZ25vcmUsIGNoYXJTcGxpdFJlZ0V4LCBzcGVjaWFsQ2hhcnNSZWdFeCwgdHJ1ZSk7XHJcbiAgICAgICAgaWdub3JlZFByZXZpb3VzU2libGluZyA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgcHJlcEZvckNoYXJzT25seSAmJiBfZGlzYWxsb3dJbmxpbmUoY3VyTm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5jb25zdCBfU3BsaXRUZXh0ID0gY2xhc3MgX1NwbGl0VGV4dCB7XHJcbiAgY29uc3RydWN0b3IoZWxlbWVudHMsIGNvbmZpZykge1xyXG4gICAgdGhpcy5pc1NwbGl0ID0gZmFsc2U7XHJcbiAgICBfaW5pdElmTmVjZXNzYXJ5KCk7XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gX2VsZW1lbnRzKGVsZW1lbnRzKTtcclxuICAgIHRoaXMuY2hhcnMgPSBbXTtcclxuICAgIHRoaXMud29yZHMgPSBbXTtcclxuICAgIHRoaXMubGluZXMgPSBbXTtcclxuICAgIHRoaXMubWFza3MgPSBbXTtcclxuICAgIHRoaXMudmFycyA9IGNvbmZpZztcclxuICAgIHRoaXMuX3NwbGl0ID0gKCkgPT4gdGhpcy5pc1NwbGl0ICYmIHRoaXMuc3BsaXQodGhpcy52YXJzKTtcclxuICAgIGxldCBvcmlnID0gW10sIHRpbWVySWQsIGNoZWNrV2lkdGhzID0gKCkgPT4ge1xyXG4gICAgICBsZXQgaSA9IG9yaWcubGVuZ3RoLCBvO1xyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgbyA9IG9yaWdbaV07XHJcbiAgICAgICAgbGV0IHcgPSBvLmVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgaWYgKHcgIT09IG8ud2lkdGgpIHtcclxuICAgICAgICAgIG8ud2lkdGggPSB3O1xyXG4gICAgICAgICAgdGhpcy5fc3BsaXQoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLl9kYXRhID0geyBvcmlnLCBvYnM6IHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XHJcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KGNoZWNrV2lkdGhzLCAyMDApO1xyXG4gICAgfSkgfTtcclxuICAgIF9jb250ZXh0KHRoaXMpO1xyXG4gICAgdGhpcy5zcGxpdChjb25maWcpO1xyXG4gIH1cclxuICBzcGxpdChjb25maWcpIHtcclxuICAgIHRoaXMuaXNTcGxpdCAmJiB0aGlzLnJldmVydCgpO1xyXG4gICAgdGhpcy52YXJzID0gY29uZmlnID0gY29uZmlnIHx8IHRoaXMudmFycyB8fCB7fTtcclxuICAgIGxldCB7IHR5cGUgPSBcImNoYXJzLHdvcmRzLGxpbmVzXCIsIGFyaWEgPSBcImF1dG9cIiwgZGVlcFNsaWNlID0gdHJ1ZSwgc21hcnRXcmFwLCBvblNwbGl0LCBhdXRvU3BsaXQgPSBmYWxzZSwgc3BlY2lhbENoYXJzLCBtYXNrIH0gPSB0aGlzLnZhcnMsIHNwbGl0TGluZXMgPSB0eXBlLmluZGV4T2YoXCJsaW5lc1wiKSA+IC0xLCBzcGxpdENoYXJhY3RlcnMgPSB0eXBlLmluZGV4T2YoXCJjaGFyc1wiKSA+IC0xLCBzcGxpdFdvcmRzID0gdHlwZS5pbmRleE9mKFwid29yZHNcIikgPiAtMSwgb25seVNwbGl0Q2hhcmFjdGVycyA9IHNwbGl0Q2hhcmFjdGVycyAmJiAhc3BsaXRXb3JkcyAmJiAhc3BsaXRMaW5lcywgc3BlY2lhbENoYXJzUmVnRXggPSBzcGVjaWFsQ2hhcnMgJiYgKFwicHVzaFwiIGluIHNwZWNpYWxDaGFycyA/IG5ldyBSZWdFeHAoXCIoPzpcIiArIHNwZWNpYWxDaGFycy5qb2luKFwifFwiKSArIFwiKVwiLCBcImd1XCIpIDogc3BlY2lhbENoYXJzKSwgZmluYWxDaGFyU3BsaXRSZWdFeCA9IHNwZWNpYWxDaGFyc1JlZ0V4ID8gbmV3IFJlZ0V4cChzcGVjaWFsQ2hhcnNSZWdFeC5zb3VyY2UgKyBcInxcIiArIF9lbW9qaVNhZmVSZWdFeC5zb3VyY2UsIFwiZ3VcIikgOiBfZW1vamlTYWZlUmVnRXgsIGlnbm9yZSA9ICEhY29uZmlnLmlnbm9yZSAmJiBfZWxlbWVudHMoY29uZmlnLmlnbm9yZSksIHsgb3JpZywgYW5pbVRpbWUsIG9icyB9ID0gdGhpcy5fZGF0YSwgb25TcGxpdFJlc3VsdDtcclxuICAgIGlmIChzcGxpdENoYXJhY3RlcnMgfHwgc3BsaXRXb3JkcyB8fCBzcGxpdExpbmVzKSB7XHJcbiAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgICBvcmlnW2luZGV4XSA9IHtcclxuICAgICAgICAgIGVsZW1lbnQsXHJcbiAgICAgICAgICBodG1sOiBlbGVtZW50LmlubmVySFRNTCxcclxuICAgICAgICAgIGFyaWFMOiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiksXHJcbiAgICAgICAgICBhcmlhSDogZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXJpYSA9PT0gXCJhdXRvXCIgPyBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgKGVsZW1lbnQudGV4dENvbnRlbnQgfHwgXCJcIikudHJpbSgpKSA6IGFyaWEgPT09IFwiaGlkZGVuXCIgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XHJcbiAgICAgICAgbGV0IGNoYXJzID0gW10sIHdvcmRzID0gW10sIGxpbmVzID0gW10sIGNoYXJXcmFwcGVyID0gc3BsaXRDaGFyYWN0ZXJzID8gX2dldFdyYXBwZXIoXCJjaGFyXCIsIGNvbmZpZywgY2hhcnMpIDogbnVsbCwgd29yZFdyYXBwZXIgPSBfZ2V0V3JhcHBlcihcIndvcmRcIiwgY29uZmlnLCB3b3JkcyksIGksIGN1cldvcmQsIHNtYXJ0V3JhcFNwYW4sIG5leHRTaWJsaW5nO1xyXG4gICAgICAgIF9zcGxpdFdvcmRzQW5kQ2hhcnNSZWN1cnNpdmVseShlbGVtZW50LCBjb25maWcsIHdvcmRXcmFwcGVyLCBjaGFyV3JhcHBlciwgb25seVNwbGl0Q2hhcmFjdGVycywgZGVlcFNsaWNlICYmIChzcGxpdExpbmVzIHx8IG9ubHlTcGxpdENoYXJhY3RlcnMpLCBpZ25vcmUsIGZpbmFsQ2hhclNwbGl0UmVnRXgsIHNwZWNpYWxDaGFyc1JlZ0V4LCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHNwbGl0TGluZXMpIHtcclxuICAgICAgICAgIGxldCBub2RlcyA9IF90b0FycmF5KGVsZW1lbnQuY2hpbGROb2RlcyksIHdyYXBMaW5lID0gX2dldExpbmVXcmFwcGVyKGVsZW1lbnQsIG5vZGVzLCBjb25maWcsIGxpbmVzKSwgY3VyTm9kZSwgdG9SZW1vdmUgPSBbXSwgbGluZVN0YXJ0SW5kZXggPSAwLCBhbGxCb3VuZHMgPSBub2Rlcy5tYXAoKG4pID0+IG4ubm9kZVR5cGUgPT09IDEgPyBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogX2VtcHR5Qm91bmRzKSwgbGFzdEJvdW5kcyA9IF9lbXB0eUJvdW5kcztcclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjdXJOb2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChjdXJOb2RlLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGN1ck5vZGUubm9kZU5hbWUgPT09IFwiQlJcIikge1xyXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChjdXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIHdyYXBMaW5lKGxpbmVTdGFydEluZGV4LCBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgbGFzdEJvdW5kcyA9IGFsbEJvdW5kc1tsaW5lU3RhcnRJbmRleF07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpICYmIGFsbEJvdW5kc1tpXS50b3AgPiBsYXN0Qm91bmRzLnRvcCAmJiBhbGxCb3VuZHNbaV0ubGVmdCA8PSBsYXN0Qm91bmRzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgd3JhcExpbmUobGluZVN0YXJ0SW5kZXgsIGkpO1xyXG4gICAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0Qm91bmRzID0gYWxsQm91bmRzW2ldO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGluZVN0YXJ0SW5kZXggPCBpICYmIHdyYXBMaW5lKGxpbmVTdGFydEluZGV4LCBpKTtcclxuICAgICAgICAgIHRvUmVtb3ZlLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGVsLnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChlbCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcGxpdFdvcmRzKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VyV29yZCA9IHdvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc3BsaXRDaGFyYWN0ZXJzIHx8ICFjdXJXb3JkLm5leHRTaWJsaW5nIHx8IGN1cldvcmQubmV4dFNpYmxpbmcubm9kZVR5cGUgIT09IDMpIHtcclxuICAgICAgICAgICAgICBpZiAoc21hcnRXcmFwICYmICFzcGxpdExpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBzbWFydFdyYXBTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgICAgICAgICBzbWFydFdyYXBTcGFuLnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vd3JhcFwiO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cldvcmQuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICBzbWFydFdyYXBTcGFuLmFwcGVuZENoaWxkKGN1cldvcmQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJXb3JkLnJlcGxhY2VXaXRoKHNtYXJ0V3JhcFNwYW4pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJXb3JkLnJlcGxhY2VXaXRoKC4uLmN1cldvcmQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nID0gY3VyV29yZC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcubm9kZVR5cGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLnRleHRDb250ZW50ID0gKGN1cldvcmQudGV4dENvbnRlbnQgfHwgXCJcIikgKyAobmV4dFNpYmxpbmcudGV4dENvbnRlbnQgfHwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICBjdXJXb3JkLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgd29yZHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgIGVsZW1lbnQubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGluZXMucHVzaCguLi5saW5lcyk7XHJcbiAgICAgICAgdGhpcy53b3Jkcy5wdXNoKC4uLndvcmRzKTtcclxuICAgICAgICB0aGlzLmNoYXJzLnB1c2goLi4uY2hhcnMpO1xyXG4gICAgICB9KTtcclxuICAgICAgbWFzayAmJiB0aGlzW21hc2tdICYmIHRoaXMubWFza3MucHVzaCguLi50aGlzW21hc2tdLm1hcCgoZWwpID0+IHtcclxuICAgICAgICBsZXQgbWFza0VsID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICAgICAgZWwucmVwbGFjZVdpdGgobWFza0VsKTtcclxuICAgICAgICBtYXNrRWwuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSAmJiAobWFza0VsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKC8oXFxiXFx3K1xcYikvZywgXCIkMS1tYXNrXCIpKTtcclxuICAgICAgICBtYXNrRWwuc3R5bGUub3ZlcmZsb3cgPSBcImNsaXBcIjtcclxuICAgICAgICByZXR1cm4gbWFza0VsO1xyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmlzU3BsaXQgPSB0cnVlO1xyXG4gICAgX2ZvbnRzICYmIChhdXRvU3BsaXQgPyBfZm9udHMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRpbmdkb25lXCIsIHRoaXMuX3NwbGl0KSA6IF9mb250cy5zdGF0dXMgPT09IFwibG9hZGluZ1wiICYmIGNvbnNvbGUud2FybihcIlNwbGl0VGV4dCBjYWxsZWQgYmVmb3JlIGZvbnRzIGxvYWRlZFwiKSk7XHJcbiAgICBpZiAoKG9uU3BsaXRSZXN1bHQgPSBvblNwbGl0ICYmIG9uU3BsaXQodGhpcykpICYmIG9uU3BsaXRSZXN1bHQudG90YWxUaW1lKSB7XHJcbiAgICAgIHRoaXMuX2RhdGEuYW5pbSA9IGFuaW1UaW1lID8gb25TcGxpdFJlc3VsdC50b3RhbFRpbWUoYW5pbVRpbWUpIDogb25TcGxpdFJlc3VsdDtcclxuICAgIH1cclxuICAgIHNwbGl0TGluZXMgJiYgYXV0b1NwbGl0ICYmIHRoaXMuZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcclxuICAgICAgb3JpZ1tpbmRleF0ud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICBvYnMgJiYgb2JzLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICByZXZlcnQoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgbGV0IHsgb3JpZywgYW5pbSwgb2JzIH0gPSB0aGlzLl9kYXRhO1xyXG4gICAgb2JzICYmIG9icy5kaXNjb25uZWN0KCk7XHJcbiAgICBvcmlnLmZvckVhY2goKHsgZWxlbWVudCwgaHRtbCwgYXJpYUwsIGFyaWFIIH0pID0+IHtcclxuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICBhcmlhTCA/IGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBhcmlhTCkgOiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIik7XHJcbiAgICAgIGFyaWFIID8gZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBhcmlhSCkgOiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmNoYXJzLmxlbmd0aCA9IHRoaXMud29yZHMubGVuZ3RoID0gdGhpcy5saW5lcy5sZW5ndGggPSBvcmlnLmxlbmd0aCA9IHRoaXMubWFza3MubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuaXNTcGxpdCA9IGZhbHNlO1xyXG4gICAgX2ZvbnRzID09IG51bGwgPyB2b2lkIDAgOiBfZm9udHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRpbmdkb25lXCIsIHRoaXMuX3NwbGl0KTtcclxuICAgIGlmIChhbmltKSB7XHJcbiAgICAgIHRoaXMuX2RhdGEuYW5pbVRpbWUgPSBhbmltLnRvdGFsVGltZSgpO1xyXG4gICAgICBhbmltLnJldmVydCgpO1xyXG4gICAgfVxyXG4gICAgKF9iID0gKF9hID0gdGhpcy52YXJzKS5vblJldmVydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIHN0YXRpYyBjcmVhdGUoZWxlbWVudHMsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBfU3BsaXRUZXh0KGVsZW1lbnRzLCBjb25maWcpO1xyXG4gIH1cclxuICBzdGF0aWMgcmVnaXN0ZXIoY29yZSkge1xyXG4gICAgZ3NhcCA9IGdzYXAgfHwgY29yZSB8fCB3aW5kb3cuZ3NhcDtcclxuICAgIGlmIChnc2FwKSB7XHJcbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xyXG4gICAgICBfY29udGV4dCA9IGdzYXAuY29yZS5jb250ZXh0IHx8IF9jb250ZXh0O1xyXG4gICAgfVxyXG4gICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgd2luZG93LmlubmVyV2lkdGggPiAwKSB7XHJcbiAgICAgIF9mb250cyA9IGRvY3VtZW50LmZvbnRzO1xyXG4gICAgICBfY29yZUluaXR0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuX1NwbGl0VGV4dC52ZXJzaW9uID0gXCIzLjEzLjBcIjtcclxubGV0IFNwbGl0VGV4dCA9IF9TcGxpdFRleHQ7XHJcblxyXG5leHBvcnQgeyBTcGxpdFRleHQsIFNwbGl0VGV4dCBhcyBkZWZhdWx0IH07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/SplitText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Back: () => (/* binding */ Back),\n/* harmony export */   Bounce: () => (/* binding */ Bounce),\n/* harmony export */   Circ: () => (/* binding */ Circ),\n/* harmony export */   Cubic: () => (/* binding */ Cubic),\n/* harmony export */   Elastic: () => (/* binding */ Elastic),\n/* harmony export */   Expo: () => (/* binding */ Expo),\n/* harmony export */   GSCache: () => (/* binding */ GSCache),\n/* harmony export */   Linear: () => (/* binding */ Linear),\n/* harmony export */   Power0: () => (/* binding */ Power0),\n/* harmony export */   Power1: () => (/* binding */ Power1),\n/* harmony export */   Power2: () => (/* binding */ Power2),\n/* harmony export */   Power3: () => (/* binding */ Power3),\n/* harmony export */   Power4: () => (/* binding */ Power4),\n/* harmony export */   PropTween: () => (/* binding */ PropTween),\n/* harmony export */   Quad: () => (/* binding */ Quad),\n/* harmony export */   Quart: () => (/* binding */ Quart),\n/* harmony export */   Quint: () => (/* binding */ Quint),\n/* harmony export */   Sine: () => (/* binding */ Sine),\n/* harmony export */   SteppedEase: () => (/* binding */ SteppedEase),\n/* harmony export */   Strong: () => (/* binding */ Strong),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   TimelineLite: () => (/* binding */ Timeline),\n/* harmony export */   TimelineMax: () => (/* binding */ Timeline),\n/* harmony export */   Tween: () => (/* binding */ Tween),\n/* harmony export */   TweenLite: () => (/* binding */ Tween),\n/* harmony export */   TweenMax: () => (/* binding */ Tween),\n/* harmony export */   _checkPlugin: () => (/* binding */ _checkPlugin),\n/* harmony export */   _colorExp: () => (/* binding */ _colorExp),\n/* harmony export */   _colorStringFilter: () => (/* binding */ _colorStringFilter),\n/* harmony export */   _config: () => (/* binding */ _config),\n/* harmony export */   _forEachName: () => (/* binding */ _forEachName),\n/* harmony export */   _getCache: () => (/* binding */ _getCache),\n/* harmony export */   _getProperty: () => (/* binding */ _getProperty),\n/* harmony export */   _getSetter: () => (/* binding */ _getSetter),\n/* harmony export */   _isString: () => (/* binding */ _isString),\n/* harmony export */   _isUndefined: () => (/* binding */ _isUndefined),\n/* harmony export */   _missingPlugin: () => (/* binding */ _missingPlugin),\n/* harmony export */   _numExp: () => (/* binding */ _numExp),\n/* harmony export */   _numWithUnitExp: () => (/* binding */ _numWithUnitExp),\n/* harmony export */   _parseRelative: () => (/* binding */ _parseRelative),\n/* harmony export */   _plugins: () => (/* binding */ _plugins),\n/* harmony export */   _relExp: () => (/* binding */ _relExp),\n/* harmony export */   _removeLinkedListItem: () => (/* binding */ _removeLinkedListItem),\n/* harmony export */   _renderComplexString: () => (/* binding */ _renderComplexString),\n/* harmony export */   _replaceRandom: () => (/* binding */ _replaceRandom),\n/* harmony export */   _round: () => (/* binding */ _round),\n/* harmony export */   _roundModifier: () => (/* binding */ _roundModifier),\n/* harmony export */   _setDefaults: () => (/* binding */ _setDefaults),\n/* harmony export */   _sortPropTweensByPriority: () => (/* binding */ _sortPropTweensByPriority),\n/* harmony export */   _ticker: () => (/* binding */ _ticker),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   \"default\": () => (/* binding */ gsap),\n/* harmony export */   distribute: () => (/* binding */ distribute),\n/* harmony export */   getUnit: () => (/* binding */ getUnit),\n/* harmony export */   gsap: () => (/* binding */ gsap),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   mapRange: () => (/* binding */ mapRange),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   selector: () => (/* binding */ selector),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   snap: () => (/* binding */ snap),\n/* harmony export */   splitColor: () => (/* binding */ splitColor),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   unitize: () => (/* binding */ unitize),\n/* harmony export */   wrap: () => (/* binding */ wrap),\n/* harmony export */   wrapYoyo: () => (/* binding */ wrapYoyo)\n/* harmony export */ });\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\r\n\r\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\r\n\r\n/*!\r\n * GSAP 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\r\n * Subject to the terms at https://gsap.com/standard-license\r\n * @author: Jack Doyle, jack@greensock.com\r\n*/\r\n\r\n/* eslint-disable */\r\nvar _config = {\r\n  autoSleep: 120,\r\n  force3D: \"auto\",\r\n  nullTargetWarn: 1,\r\n  units: {\r\n    lineHeight: \"\"\r\n  }\r\n},\r\n    _defaults = {\r\n  duration: .5,\r\n  overwrite: false,\r\n  delay: 0\r\n},\r\n    _suppressOverwrites,\r\n    _reverting,\r\n    _context,\r\n    _bigNum = 1e8,\r\n    _tinyNum = 1 / _bigNum,\r\n    _2PI = Math.PI * 2,\r\n    _HALF_PI = _2PI / 4,\r\n    _gsID = 0,\r\n    _sqrt = Math.sqrt,\r\n    _cos = Math.cos,\r\n    _sin = Math.sin,\r\n    _isString = function _isString(value) {\r\n  return typeof value === \"string\";\r\n},\r\n    _isFunction = function _isFunction(value) {\r\n  return typeof value === \"function\";\r\n},\r\n    _isNumber = function _isNumber(value) {\r\n  return typeof value === \"number\";\r\n},\r\n    _isUndefined = function _isUndefined(value) {\r\n  return typeof value === \"undefined\";\r\n},\r\n    _isObject = function _isObject(value) {\r\n  return typeof value === \"object\";\r\n},\r\n    _isNotFalse = function _isNotFalse(value) {\r\n  return value !== false;\r\n},\r\n    _windowExists = function _windowExists() {\r\n  return typeof window !== \"undefined\";\r\n},\r\n    _isFuncOrString = function _isFuncOrString(value) {\r\n  return _isFunction(value) || _isString(value);\r\n},\r\n    _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function () {},\r\n    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\r\n_isArray = Array.isArray,\r\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\r\n    //only numbers (including negatives and decimals) but NOT relative values.\r\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\r\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\r\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\r\n    _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\r\n    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\r\n_relExp = /[+-]=-?[.\\d]+/,\r\n    _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi,\r\n    // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\r\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i,\r\n    _globalTimeline,\r\n    _win,\r\n    _coreInitted,\r\n    _doc,\r\n    _globals = {},\r\n    _installScope = {},\r\n    _coreReady,\r\n    _install = function _install(scope) {\r\n  return (_installScope = _merge(scope, _globals)) && gsap;\r\n},\r\n    _missingPlugin = function _missingPlugin(property, value) {\r\n  return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\r\n},\r\n    _warn = function _warn(message, suppress) {\r\n  return !suppress && console.warn(message);\r\n},\r\n    _addGlobal = function _addGlobal(name, obj) {\r\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\r\n},\r\n    _emptyFunc = function _emptyFunc() {\r\n  return 0;\r\n},\r\n    _startAtRevertConfig = {\r\n  suppressEvents: true,\r\n  isStart: true,\r\n  kill: false\r\n},\r\n    _revertConfigNoKill = {\r\n  suppressEvents: true,\r\n  kill: false\r\n},\r\n    _revertConfig = {\r\n  suppressEvents: true\r\n},\r\n    _reservedProps = {},\r\n    _lazyTweens = [],\r\n    _lazyLookup = {},\r\n    _lastRenderedFrame,\r\n    _plugins = {},\r\n    _effects = {},\r\n    _nextGCFrame = 30,\r\n    _harnessPlugins = [],\r\n    _callbackNames = \"\",\r\n    _harness = function _harness(targets) {\r\n  var target = targets[0],\r\n      harnessPlugin,\r\n      i;\r\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\r\n\r\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\r\n    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\r\n    i = _harnessPlugins.length;\r\n\r\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\r\n\r\n    harnessPlugin = _harnessPlugins[i];\r\n  }\r\n\r\n  i = targets.length;\r\n\r\n  while (i--) {\r\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\r\n  }\r\n\r\n  return targets;\r\n},\r\n    _getCache = function _getCache(target) {\r\n  return target._gsap || _harness(toArray(target))[0]._gsap;\r\n},\r\n    _getProperty = function _getProperty(target, property, v) {\r\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\r\n},\r\n    _forEachName = function _forEachName(names, func) {\r\n  return (names = names.split(\",\")).forEach(func) || names;\r\n},\r\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\r\n_round = function _round(value) {\r\n  return Math.round(value * 100000) / 100000 || 0;\r\n},\r\n    _roundPrecise = function _roundPrecise(value) {\r\n  return Math.round(value * 10000000) / 10000000 || 0;\r\n},\r\n    // increased precision mostly for timing values.\r\n_parseRelative = function _parseRelative(start, value) {\r\n  var operator = value.charAt(0),\r\n      end = parseFloat(value.substr(2));\r\n  start = parseFloat(start);\r\n  return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\r\n},\r\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\r\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\r\n  var l = toFind.length,\r\n      i = 0;\r\n\r\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\r\n\r\n  return i < l;\r\n},\r\n    _lazyRender = function _lazyRender() {\r\n  var l = _lazyTweens.length,\r\n      a = _lazyTweens.slice(0),\r\n      i,\r\n      tween;\r\n\r\n  _lazyLookup = {};\r\n  _lazyTweens.length = 0;\r\n\r\n  for (i = 0; i < l; i++) {\r\n    tween = a[i];\r\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\r\n  }\r\n},\r\n    _isRevertWorthy = function _isRevertWorthy(animation) {\r\n  return !!(animation._initted || animation._startAt || animation.add);\r\n},\r\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\r\n  _lazyTweens.length && !_reverting && _lazyRender();\r\n  animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));\r\n  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\r\n},\r\n    _numericIfPossible = function _numericIfPossible(value) {\r\n  var n = parseFloat(value);\r\n  return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\r\n},\r\n    _passThrough = function _passThrough(p) {\r\n  return p;\r\n},\r\n    _setDefaults = function _setDefaults(obj, defaults) {\r\n  for (var p in defaults) {\r\n    p in obj || (obj[p] = defaults[p]);\r\n  }\r\n\r\n  return obj;\r\n},\r\n    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\r\n  return function (obj, defaults) {\r\n    for (var p in defaults) {\r\n      p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\r\n    }\r\n  };\r\n},\r\n    _merge = function _merge(base, toMerge) {\r\n  for (var p in toMerge) {\r\n    base[p] = toMerge[p];\r\n  }\r\n\r\n  return base;\r\n},\r\n    _mergeDeep = function _mergeDeep(base, toMerge) {\r\n  for (var p in toMerge) {\r\n    p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\r\n  }\r\n\r\n  return base;\r\n},\r\n    _copyExcluding = function _copyExcluding(obj, excluding) {\r\n  var copy = {},\r\n      p;\r\n\r\n  for (p in obj) {\r\n    p in excluding || (copy[p] = obj[p]);\r\n  }\r\n\r\n  return copy;\r\n},\r\n    _inheritDefaults = function _inheritDefaults(vars) {\r\n  var parent = vars.parent || _globalTimeline,\r\n      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\r\n\r\n  if (_isNotFalse(vars.inherit)) {\r\n    while (parent) {\r\n      func(vars, parent.vars.defaults);\r\n      parent = parent.parent || parent._dp;\r\n    }\r\n  }\r\n\r\n  return vars;\r\n},\r\n    _arraysMatch = function _arraysMatch(a1, a2) {\r\n  var i = a1.length,\r\n      match = i === a2.length;\r\n\r\n  while (match && i-- && a1[i] === a2[i]) {}\r\n\r\n  return i < 0;\r\n},\r\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\r\n  if (firstProp === void 0) {\r\n    firstProp = \"_first\";\r\n  }\r\n\r\n  if (lastProp === void 0) {\r\n    lastProp = \"_last\";\r\n  }\r\n\r\n  var prev = parent[lastProp],\r\n      t;\r\n\r\n  if (sortBy) {\r\n    t = child[sortBy];\r\n\r\n    while (prev && prev[sortBy] > t) {\r\n      prev = prev._prev;\r\n    }\r\n  }\r\n\r\n  if (prev) {\r\n    child._next = prev._next;\r\n    prev._next = child;\r\n  } else {\r\n    child._next = parent[firstProp];\r\n    parent[firstProp] = child;\r\n  }\r\n\r\n  if (child._next) {\r\n    child._next._prev = child;\r\n  } else {\r\n    parent[lastProp] = child;\r\n  }\r\n\r\n  child._prev = prev;\r\n  child.parent = child._dp = parent;\r\n  return child;\r\n},\r\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\r\n  if (firstProp === void 0) {\r\n    firstProp = \"_first\";\r\n  }\r\n\r\n  if (lastProp === void 0) {\r\n    lastProp = \"_last\";\r\n  }\r\n\r\n  var prev = child._prev,\r\n      next = child._next;\r\n\r\n  if (prev) {\r\n    prev._next = next;\r\n  } else if (parent[firstProp] === child) {\r\n    parent[firstProp] = next;\r\n  }\r\n\r\n  if (next) {\r\n    next._prev = prev;\r\n  } else if (parent[lastProp] === child) {\r\n    parent[lastProp] = prev;\r\n  }\r\n\r\n  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\r\n},\r\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\r\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\r\n  child._act = 0;\r\n},\r\n    _uncache = function _uncache(animation, child) {\r\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\r\n    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\r\n    var a = animation;\r\n\r\n    while (a) {\r\n      a._dirty = 1;\r\n      a = a.parent;\r\n    }\r\n  }\r\n\r\n  return animation;\r\n},\r\n    _recacheAncestors = function _recacheAncestors(animation) {\r\n  var parent = animation.parent;\r\n\r\n  while (parent && parent.parent) {\r\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\r\n    parent._dirty = 1;\r\n    parent.totalDuration();\r\n    parent = parent.parent;\r\n  }\r\n\r\n  return animation;\r\n},\r\n    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\r\n  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\r\n},\r\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\r\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\r\n},\r\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\r\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\r\n},\r\n    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\r\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\r\n  var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));\r\n  return tTime && whole === tTime ? whole - 1 : whole;\r\n},\r\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\r\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\r\n},\r\n    _setEnd = function _setEnd(animation) {\r\n  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\r\n},\r\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\r\n  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\r\n  var parent = animation._dp;\r\n\r\n  if (parent && parent.smoothChildTiming && animation._ts) {\r\n    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\r\n\r\n    _setEnd(animation);\r\n\r\n    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\r\n  }\r\n\r\n  return animation;\r\n},\r\n\r\n/*\r\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\r\n\tlet cycleDuration = duration + repeatDelay,\r\n\t\ttime = _round(clampedTotalTime % cycleDuration);\r\n\tif (time > duration) {\r\n\t\ttime = duration;\r\n\t}\r\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\r\n},\r\n*/\r\n_postAddChecks = function _postAddChecks(timeline, child) {\r\n  var t;\r\n\r\n  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\r\n    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\r\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\r\n\r\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\r\n      child.render(t, true);\r\n    }\r\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\r\n\r\n\r\n  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\r\n    //in case any of the ancestors had completed but should now be enabled...\r\n    if (timeline._dur < timeline.duration()) {\r\n      t = timeline;\r\n\r\n      while (t._dp) {\r\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\r\n\r\n        t = t._dp;\r\n      }\r\n    }\r\n\r\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\r\n  }\r\n},\r\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\r\n  child.parent && _removeFromParent(child);\r\n  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\r\n  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\r\n\r\n  _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\r\n\r\n  _isFromOrFromStart(child) || (timeline._recent = child);\r\n  skipChecks || _postAddChecks(timeline, child);\r\n  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\r\n\r\n  return timeline;\r\n},\r\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\r\n  return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\r\n},\r\n    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\r\n  _initTween(tween, time, tTime);\r\n\r\n  if (!tween._initted) {\r\n    return 1;\r\n  }\r\n\r\n  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\r\n    _lazyTweens.push(tween);\r\n\r\n    tween._lazy = [tTime, suppressEvents];\r\n    return 1;\r\n  }\r\n},\r\n    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\r\n  var parent = _ref.parent;\r\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\r\n},\r\n    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\r\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\r\n  var data = _ref2.data;\r\n  return data === \"isFromStart\" || data === \"isStart\";\r\n},\r\n    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\r\n  var prevRatio = tween.ratio,\r\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,\r\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\r\n  repeatDelay = tween._rDelay,\r\n      tTime = 0,\r\n      pt,\r\n      iteration,\r\n      prevIteration;\r\n\r\n  if (repeatDelay && tween._repeat) {\r\n    // in case there's a zero-duration tween that has a repeat with a repeatDelay\r\n    tTime = _clamp(0, tween._tDur, totalTime);\r\n    iteration = _animationCycle(tTime, repeatDelay);\r\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\r\n\r\n    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\r\n      // if iteration changed\r\n      prevRatio = 1 - ratio;\r\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\r\n    }\r\n  }\r\n\r\n  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\r\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\r\n      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\r\n      return;\r\n    }\r\n\r\n    prevIteration = tween._zTime;\r\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\r\n\r\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\r\n\r\n    tween.ratio = ratio;\r\n    tween._from && (ratio = 1 - ratio);\r\n    tween._time = 0;\r\n    tween._tTime = tTime;\r\n    pt = tween._pt;\r\n\r\n    while (pt) {\r\n      pt.r(ratio, pt.d);\r\n      pt = pt._next;\r\n    }\r\n\r\n    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\r\n    tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\r\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\r\n\r\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\r\n      ratio && _removeFromParent(tween, 1);\r\n\r\n      if (!suppressEvents && !_reverting) {\r\n        _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\r\n\r\n        tween._prom && tween._prom();\r\n      }\r\n    }\r\n  } else if (!tween._zTime) {\r\n    tween._zTime = totalTime;\r\n  }\r\n},\r\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\r\n  var child;\r\n\r\n  if (time > prevTime) {\r\n    child = animation._first;\r\n\r\n    while (child && child._start <= time) {\r\n      if (child.data === \"isPause\" && child._start > prevTime) {\r\n        return child;\r\n      }\r\n\r\n      child = child._next;\r\n    }\r\n  } else {\r\n    child = animation._last;\r\n\r\n    while (child && child._start >= time) {\r\n      if (child.data === \"isPause\" && child._start < prevTime) {\r\n        return child;\r\n      }\r\n\r\n      child = child._prev;\r\n    }\r\n  }\r\n},\r\n    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\r\n  var repeat = animation._repeat,\r\n      dur = _roundPrecise(duration) || 0,\r\n      totalProgress = animation._tTime / animation._tDur;\r\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\r\n  animation._dur = dur;\r\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\r\n  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\r\n  animation.parent && _setEnd(animation);\r\n  skipUncache || _uncache(animation.parent, animation);\r\n  return animation;\r\n},\r\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\r\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\r\n},\r\n    _zeroPosition = {\r\n  _start: 0,\r\n  endTime: _emptyFunc,\r\n  totalDuration: _emptyFunc\r\n},\r\n    _parsePosition = function _parsePosition(animation, position, percentAnimation) {\r\n  var labels = animation.labels,\r\n      recent = animation._recent || _zeroPosition,\r\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\r\n      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\r\n  i,\r\n      offset,\r\n      isPercent;\r\n\r\n  if (_isString(position) && (isNaN(position) || position in labels)) {\r\n    //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\r\n    offset = position.charAt(0);\r\n    isPercent = position.substr(-1) === \"%\";\r\n    i = position.indexOf(\"=\");\r\n\r\n    if (offset === \"<\" || offset === \">\") {\r\n      i >= 0 && (position = position.replace(/=/, \"\"));\r\n      return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\r\n    }\r\n\r\n    if (i < 0) {\r\n      position in labels || (labels[position] = clippedDuration);\r\n      return labels[position];\r\n    }\r\n\r\n    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\r\n\r\n    if (isPercent && percentAnimation) {\r\n      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\r\n    }\r\n\r\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\r\n  }\r\n\r\n  return position == null ? clippedDuration : +position;\r\n},\r\n    _createTweenType = function _createTweenType(type, params, timeline) {\r\n  var isLegacy = _isNumber(params[1]),\r\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\r\n      vars = params[varsIndex],\r\n      irVars,\r\n      parent;\r\n\r\n  isLegacy && (vars.duration = params[1]);\r\n  vars.parent = timeline;\r\n\r\n  if (type) {\r\n    irVars = vars;\r\n    parent = timeline;\r\n\r\n    while (parent && !(\"immediateRender\" in irVars)) {\r\n      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\r\n      irVars = parent.vars.defaults || {};\r\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\r\n    }\r\n\r\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\r\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\r\n  }\r\n\r\n  return new Tween(params[0], vars, params[varsIndex + 1]);\r\n},\r\n    _conditionalReturn = function _conditionalReturn(value, func) {\r\n  return value || value === 0 ? func(value) : func;\r\n},\r\n    _clamp = function _clamp(min, max, value) {\r\n  return value < min ? min : value > max ? max : value;\r\n},\r\n    getUnit = function getUnit(value, v) {\r\n  return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\r\n},\r\n    // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\r\nclamp = function clamp(min, max, value) {\r\n  return _conditionalReturn(value, function (v) {\r\n    return _clamp(min, max, v);\r\n  });\r\n},\r\n    _slice = [].slice,\r\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\r\n  return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\r\n},\r\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\r\n  if (accumulator === void 0) {\r\n    accumulator = [];\r\n  }\r\n\r\n  return ar.forEach(function (value) {\r\n    var _accumulator;\r\n\r\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\r\n  }) || accumulator;\r\n},\r\n    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\r\ntoArray = function toArray(value, scope, leaveStrings) {\r\n  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\r\n},\r\n    selector = function selector(value) {\r\n  value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\r\n  return function (v) {\r\n    var el = value.current || value.nativeElement || value;\r\n    return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\r\n  };\r\n},\r\n    shuffle = function shuffle(a) {\r\n  return a.sort(function () {\r\n    return .5 - Math.random();\r\n  });\r\n},\r\n    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = (Math.random() * i) | 0, v = a[--i], a[i] = a[j], a[j] = v); return a;\r\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\r\ndistribute = function distribute(v) {\r\n  if (_isFunction(v)) {\r\n    return v;\r\n  }\r\n\r\n  var vars = _isObject(v) ? v : {\r\n    each: v\r\n  },\r\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\r\n  ease = _parseEase(vars.ease),\r\n      from = vars.from || 0,\r\n      base = parseFloat(vars.base) || 0,\r\n      cache = {},\r\n      isDecimal = from > 0 && from < 1,\r\n      ratios = isNaN(from) || isDecimal,\r\n      axis = vars.axis,\r\n      ratioX = from,\r\n      ratioY = from;\r\n\r\n  if (_isString(from)) {\r\n    ratioX = ratioY = {\r\n      center: .5,\r\n      edges: .5,\r\n      end: 1\r\n    }[from] || 0;\r\n  } else if (!isDecimal && ratios) {\r\n    ratioX = from[0];\r\n    ratioY = from[1];\r\n  }\r\n\r\n  return function (i, target, a) {\r\n    var l = (a || vars).length,\r\n        distances = cache[l],\r\n        originX,\r\n        originY,\r\n        x,\r\n        y,\r\n        d,\r\n        j,\r\n        max,\r\n        min,\r\n        wrapAt;\r\n\r\n    if (!distances) {\r\n      wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\r\n\r\n      if (!wrapAt) {\r\n        max = -_bigNum;\r\n\r\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\r\n\r\n        wrapAt < l && wrapAt--;\r\n      }\r\n\r\n      distances = cache[l] = [];\r\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\r\n      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\r\n      max = 0;\r\n      min = _bigNum;\r\n\r\n      for (j = 0; j < l; j++) {\r\n        x = j % wrapAt - originX;\r\n        y = originY - (j / wrapAt | 0);\r\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\r\n        d > max && (max = d);\r\n        d < min && (min = d);\r\n      }\r\n\r\n      from === \"random\" && shuffle(distances);\r\n      distances.max = max - min;\r\n      distances.min = min;\r\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\r\n      distances.b = l < 0 ? base - l : base;\r\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\r\n\r\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\r\n    }\r\n\r\n    l = (distances[i] - distances.min) / distances.max || 0;\r\n    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\r\n  };\r\n},\r\n    _roundModifier = function _roundModifier(v) {\r\n  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\r\n  var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\r\n\r\n  return function (raw) {\r\n    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\r\n\r\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\r\n  };\r\n},\r\n    snap = function snap(snapTo, value) {\r\n  var isArray = _isArray(snapTo),\r\n      radius,\r\n      is2D;\r\n\r\n  if (!isArray && _isObject(snapTo)) {\r\n    radius = isArray = snapTo.radius || _bigNum;\r\n\r\n    if (snapTo.values) {\r\n      snapTo = toArray(snapTo.values);\r\n\r\n      if (is2D = !_isNumber(snapTo[0])) {\r\n        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\r\n      }\r\n    } else {\r\n      snapTo = _roundModifier(snapTo.increment);\r\n    }\r\n  }\r\n\r\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\r\n    is2D = snapTo(raw);\r\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\r\n  } : function (raw) {\r\n    var x = parseFloat(is2D ? raw.x : raw),\r\n        y = parseFloat(is2D ? raw.y : 0),\r\n        min = _bigNum,\r\n        closest = 0,\r\n        i = snapTo.length,\r\n        dx,\r\n        dy;\r\n\r\n    while (i--) {\r\n      if (is2D) {\r\n        dx = snapTo[i].x - x;\r\n        dy = snapTo[i].y - y;\r\n        dx = dx * dx + dy * dy;\r\n      } else {\r\n        dx = Math.abs(snapTo[i] - x);\r\n      }\r\n\r\n      if (dx < min) {\r\n        min = dx;\r\n        closest = i;\r\n      }\r\n    }\r\n\r\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\r\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\r\n  });\r\n},\r\n    random = function random(min, max, roundingIncrement, returnFunction) {\r\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\r\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\r\n  });\r\n},\r\n    pipe = function pipe() {\r\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\r\n    functions[_key] = arguments[_key];\r\n  }\r\n\r\n  return function (value) {\r\n    return functions.reduce(function (v, f) {\r\n      return f(v);\r\n    }, value);\r\n  };\r\n},\r\n    unitize = function unitize(func, unit) {\r\n  return function (value) {\r\n    return func(parseFloat(value)) + (unit || getUnit(value));\r\n  };\r\n},\r\n    normalize = function normalize(min, max, value) {\r\n  return mapRange(min, max, 0, 1, value);\r\n},\r\n    _wrapArray = function _wrapArray(a, wrapper, value) {\r\n  return _conditionalReturn(value, function (index) {\r\n    return a[~~wrapper(index)];\r\n  });\r\n},\r\n    wrap = function wrap(min, max, value) {\r\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\r\n  var range = max - min;\r\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\r\n    return (range + (value - min) % range) % range + min;\r\n  });\r\n},\r\n    wrapYoyo = function wrapYoyo(min, max, value) {\r\n  var range = max - min,\r\n      total = range * 2;\r\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\r\n    value = (total + (value - min) % total) % total || 0;\r\n    return min + (value > range ? total - value : value);\r\n  });\r\n},\r\n    _replaceRandom = function _replaceRandom(value) {\r\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\r\n  var prev = 0,\r\n      s = \"\",\r\n      i,\r\n      nums,\r\n      end,\r\n      isArray;\r\n\r\n  while (~(i = value.indexOf(\"random(\", prev))) {\r\n    end = value.indexOf(\")\", i);\r\n    isArray = value.charAt(i + 7) === \"[\";\r\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\r\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\r\n    prev = end + 1;\r\n  }\r\n\r\n  return s + value.substr(prev, value.length - prev);\r\n},\r\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\r\n  var inRange = inMax - inMin,\r\n      outRange = outMax - outMin;\r\n  return _conditionalReturn(value, function (value) {\r\n    return outMin + ((value - inMin) / inRange * outRange || 0);\r\n  });\r\n},\r\n    interpolate = function interpolate(start, end, progress, mutate) {\r\n  var func = isNaN(start + end) ? 0 : function (p) {\r\n    return (1 - p) * start + p * end;\r\n  };\r\n\r\n  if (!func) {\r\n    var isString = _isString(start),\r\n        master = {},\r\n        p,\r\n        i,\r\n        interpolators,\r\n        l,\r\n        il;\r\n\r\n    progress === true && (mutate = 1) && (progress = null);\r\n\r\n    if (isString) {\r\n      start = {\r\n        p: start\r\n      };\r\n      end = {\r\n        p: end\r\n      };\r\n    } else if (_isArray(start) && !_isArray(end)) {\r\n      interpolators = [];\r\n      l = start.length;\r\n      il = l - 2;\r\n\r\n      for (i = 1; i < l; i++) {\r\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\r\n      }\r\n\r\n      l--;\r\n\r\n      func = function func(p) {\r\n        p *= l;\r\n        var i = Math.min(il, ~~p);\r\n        return interpolators[i](p - i);\r\n      };\r\n\r\n      progress = end;\r\n    } else if (!mutate) {\r\n      start = _merge(_isArray(start) ? [] : {}, start);\r\n    }\r\n\r\n    if (!interpolators) {\r\n      for (p in end) {\r\n        _addPropTween.call(master, start, p, \"get\", end[p]);\r\n      }\r\n\r\n      func = function func(p) {\r\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\r\n      };\r\n    }\r\n  }\r\n\r\n  return _conditionalReturn(progress, func);\r\n},\r\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\r\n  //used for nextLabel() and previousLabel()\r\n  var labels = timeline.labels,\r\n      min = _bigNum,\r\n      p,\r\n      distance,\r\n      label;\r\n\r\n  for (p in labels) {\r\n    distance = labels[p] - fromTime;\r\n\r\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\r\n      label = p;\r\n      min = distance;\r\n    }\r\n  }\r\n\r\n  return label;\r\n},\r\n    _callback = function _callback(animation, type, executeLazyFirst) {\r\n  var v = animation.vars,\r\n      callback = v[type],\r\n      prevContext = _context,\r\n      context = animation._ctx,\r\n      params,\r\n      scope,\r\n      result;\r\n\r\n  if (!callback) {\r\n    return;\r\n  }\r\n\r\n  params = v[type + \"Params\"];\r\n  scope = v.callbackScope || animation;\r\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\r\n\r\n  context && (_context = context);\r\n  result = params ? callback.apply(scope, params) : callback.call(scope);\r\n  _context = prevContext;\r\n  return result;\r\n},\r\n    _interrupt = function _interrupt(animation) {\r\n  _removeFromParent(animation);\r\n\r\n  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\r\n  animation.progress() < 1 && _callback(animation, \"onInterrupt\");\r\n  return animation;\r\n},\r\n    _quickTween,\r\n    _registerPluginQueue = [],\r\n    _createPlugin = function _createPlugin(config) {\r\n  if (!config) return;\r\n  config = !config.name && config[\"default\"] || config; // UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\r\n\r\n  if (_windowExists() || config.headless) {\r\n    // edge case: some build tools may pass in a null/undefined value\r\n    var name = config.name,\r\n        isFunc = _isFunction(config),\r\n        Plugin = name && !isFunc && config.init ? function () {\r\n      this._props = [];\r\n    } : config,\r\n        //in case someone passes in an object that's not a plugin, like CustomEase\r\n    instanceDefaults = {\r\n      init: _emptyFunc,\r\n      render: _renderPropTweens,\r\n      add: _addPropTween,\r\n      kill: _killPropTweensOf,\r\n      modifier: _addPluginModifier,\r\n      rawVars: 0\r\n    },\r\n        statics = {\r\n      targetTest: 0,\r\n      get: 0,\r\n      getSetter: _getSetter,\r\n      aliases: {},\r\n      register: 0\r\n    };\r\n\r\n    _wake();\r\n\r\n    if (config !== Plugin) {\r\n      if (_plugins[name]) {\r\n        return;\r\n      }\r\n\r\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\r\n\r\n\r\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\r\n\r\n\r\n      _plugins[Plugin.prop = name] = Plugin;\r\n\r\n      if (config.targetTest) {\r\n        _harnessPlugins.push(Plugin);\r\n\r\n        _reservedProps[name] = 1;\r\n      }\r\n\r\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\r\n    }\r\n\r\n    _addGlobal(name, Plugin);\r\n\r\n    config.register && config.register(gsap, Plugin, PropTween);\r\n  } else {\r\n    _registerPluginQueue.push(config);\r\n  }\r\n},\r\n\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * COLORS\r\n * --------------------------------------------------------------------------------------\r\n */\r\n_255 = 255,\r\n    _colorLookup = {\r\n  aqua: [0, _255, _255],\r\n  lime: [0, _255, 0],\r\n  silver: [192, 192, 192],\r\n  black: [0, 0, 0],\r\n  maroon: [128, 0, 0],\r\n  teal: [0, 128, 128],\r\n  blue: [0, 0, _255],\r\n  navy: [0, 0, 128],\r\n  white: [_255, _255, _255],\r\n  olive: [128, 128, 0],\r\n  yellow: [_255, _255, 0],\r\n  orange: [_255, 165, 0],\r\n  gray: [128, 128, 128],\r\n  purple: [128, 0, 128],\r\n  green: [0, 128, 0],\r\n  red: [_255, 0, 0],\r\n  pink: [_255, 192, 203],\r\n  cyan: [0, _255, _255],\r\n  transparent: [_255, _255, _255, 0]\r\n},\r\n    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\r\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\r\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\r\n_hue = function _hue(h, m1, m2) {\r\n  h += h < 0 ? 1 : h > 1 ? -1 : 0;\r\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\r\n},\r\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\r\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\r\n      r,\r\n      g,\r\n      b,\r\n      h,\r\n      s,\r\n      l,\r\n      max,\r\n      min,\r\n      d,\r\n      wasHSL;\r\n\r\n  if (!a) {\r\n    if (v.substr(-1) === \",\") {\r\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\r\n      v = v.substr(0, v.length - 1);\r\n    }\r\n\r\n    if (_colorLookup[v]) {\r\n      a = _colorLookup[v];\r\n    } else if (v.charAt(0) === \"#\") {\r\n      if (v.length < 6) {\r\n        //for shorthand like #9F0 or #9F0F (could have alpha)\r\n        r = v.charAt(1);\r\n        g = v.charAt(2);\r\n        b = v.charAt(3);\r\n        v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\r\n      }\r\n\r\n      if (v.length === 9) {\r\n        // hex with alpha, like #fd5e53ff\r\n        a = parseInt(v.substr(1, 6), 16);\r\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\r\n      }\r\n\r\n      v = parseInt(v.substr(1), 16);\r\n      a = [v >> 16, v >> 8 & _255, v & _255];\r\n    } else if (v.substr(0, 3) === \"hsl\") {\r\n      a = wasHSL = v.match(_strictNumExp);\r\n\r\n      if (!toHSL) {\r\n        h = +a[0] % 360 / 360;\r\n        s = +a[1] / 100;\r\n        l = +a[2] / 100;\r\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\r\n        r = l * 2 - g;\r\n        a.length > 3 && (a[3] *= 1); //cast as number\r\n\r\n        a[0] = _hue(h + 1 / 3, r, g);\r\n        a[1] = _hue(h, r, g);\r\n        a[2] = _hue(h - 1 / 3, r, g);\r\n      } else if (~v.indexOf(\"=\")) {\r\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\r\n        a = v.match(_numExp);\r\n        forceAlpha && a.length < 4 && (a[3] = 1);\r\n        return a;\r\n      }\r\n    } else {\r\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\r\n    }\r\n\r\n    a = a.map(Number);\r\n  }\r\n\r\n  if (toHSL && !wasHSL) {\r\n    r = a[0] / _255;\r\n    g = a[1] / _255;\r\n    b = a[2] / _255;\r\n    max = Math.max(r, g, b);\r\n    min = Math.min(r, g, b);\r\n    l = (max + min) / 2;\r\n\r\n    if (max === min) {\r\n      h = s = 0;\r\n    } else {\r\n      d = max - min;\r\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\r\n      h *= 60;\r\n    }\r\n\r\n    a[0] = ~~(h + .5);\r\n    a[1] = ~~(s * 100 + .5);\r\n    a[2] = ~~(l * 100 + .5);\r\n  }\r\n\r\n  forceAlpha && a.length < 4 && (a[3] = 1);\r\n  return a;\r\n},\r\n    _colorOrderData = function _colorOrderData(v) {\r\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\r\n  var values = [],\r\n      c = [],\r\n      i = -1;\r\n  v.split(_colorExp).forEach(function (v) {\r\n    var a = v.match(_numWithUnitExp) || [];\r\n    values.push.apply(values, a);\r\n    c.push(i += a.length + 1);\r\n  });\r\n  values.c = c;\r\n  return values;\r\n},\r\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\r\n  var result = \"\",\r\n      colors = (s + result).match(_colorExp),\r\n      type = toHSL ? \"hsla(\" : \"rgba(\",\r\n      i = 0,\r\n      c,\r\n      shell,\r\n      d,\r\n      l;\r\n\r\n  if (!colors) {\r\n    return s;\r\n  }\r\n\r\n  colors = colors.map(function (color) {\r\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\r\n  });\r\n\r\n  if (orderMatchData) {\r\n    d = _colorOrderData(s);\r\n    c = orderMatchData.c;\r\n\r\n    if (c.join(result) !== d.c.join(result)) {\r\n      shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\r\n      l = shell.length - 1;\r\n\r\n      for (; i < l; i++) {\r\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!shell) {\r\n    shell = s.split(_colorExp);\r\n    l = shell.length - 1;\r\n\r\n    for (; i < l; i++) {\r\n      result += shell[i] + colors[i];\r\n    }\r\n  }\r\n\r\n  return result + shell[l];\r\n},\r\n    _colorExp = function () {\r\n  var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\",\r\n      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\r\n  p;\r\n\r\n  for (p in _colorLookup) {\r\n    s += \"|\" + p + \"\\\\b\";\r\n  }\r\n\r\n  return new RegExp(s + \")\", \"gi\");\r\n}(),\r\n    _hslExp = /hsl[a]?\\(/,\r\n    _colorStringFilter = function _colorStringFilter(a) {\r\n  var combined = a.join(\" \"),\r\n      toHSL;\r\n  _colorExp.lastIndex = 0;\r\n\r\n  if (_colorExp.test(combined)) {\r\n    toHSL = _hslExp.test(combined);\r\n    a[1] = _formatColors(a[1], toHSL);\r\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\r\n\r\n    return true;\r\n  }\r\n},\r\n\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * TICKER\r\n * --------------------------------------------------------------------------------------\r\n */\r\n_tickerActive,\r\n    _ticker = function () {\r\n  var _getTime = Date.now,\r\n      _lagThreshold = 500,\r\n      _adjustedLag = 33,\r\n      _startTime = _getTime(),\r\n      _lastUpdate = _startTime,\r\n      _gap = 1000 / 240,\r\n      _nextTime = _gap,\r\n      _listeners = [],\r\n      _id,\r\n      _req,\r\n      _raf,\r\n      _self,\r\n      _delta,\r\n      _i,\r\n      _tick = function _tick(v) {\r\n    var elapsed = _getTime() - _lastUpdate,\r\n        manual = v === true,\r\n        overlap,\r\n        dispatch,\r\n        time,\r\n        frame;\r\n\r\n    (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\r\n    _lastUpdate += elapsed;\r\n    time = _lastUpdate - _startTime;\r\n    overlap = time - _nextTime;\r\n\r\n    if (overlap > 0 || manual) {\r\n      frame = ++_self.frame;\r\n      _delta = time - _self.time * 1000;\r\n      _self.time = time = time / 1000;\r\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\r\n      dispatch = 1;\r\n    }\r\n\r\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\r\n\r\n    if (dispatch) {\r\n      for (_i = 0; _i < _listeners.length; _i++) {\r\n        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\r\n        _listeners[_i](time, _delta, frame, v);\r\n      }\r\n    }\r\n  };\r\n\r\n  _self = {\r\n    time: 0,\r\n    frame: 0,\r\n    tick: function tick() {\r\n      _tick(true);\r\n    },\r\n    deltaRatio: function deltaRatio(fps) {\r\n      return _delta / (1000 / (fps || 60));\r\n    },\r\n    wake: function wake() {\r\n      if (_coreReady) {\r\n        if (!_coreInitted && _windowExists()) {\r\n          _win = _coreInitted = window;\r\n          _doc = _win.document || {};\r\n          _globals.gsap = gsap;\r\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\r\n\r\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\r\n\r\n          _registerPluginQueue.forEach(_createPlugin);\r\n        }\r\n\r\n        _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\r\n        _id && _self.sleep();\r\n\r\n        _req = _raf || function (f) {\r\n          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\r\n        };\r\n\r\n        _tickerActive = 1;\r\n\r\n        _tick(2);\r\n      }\r\n    },\r\n    sleep: function sleep() {\r\n      (_raf ? cancelAnimationFrame : clearTimeout)(_id);\r\n      _tickerActive = 0;\r\n      _req = _emptyFunc;\r\n    },\r\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\r\n      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\r\n\r\n      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\r\n    },\r\n    fps: function fps(_fps) {\r\n      _gap = 1000 / (_fps || 240);\r\n      _nextTime = _self.time * 1000 + _gap;\r\n    },\r\n    add: function add(callback, once, prioritize) {\r\n      var func = once ? function (t, d, f, v) {\r\n        callback(t, d, f, v);\r\n\r\n        _self.remove(func);\r\n      } : callback;\r\n\r\n      _self.remove(callback);\r\n\r\n      _listeners[prioritize ? \"unshift\" : \"push\"](func);\r\n\r\n      _wake();\r\n\r\n      return func;\r\n    },\r\n    remove: function remove(callback, i) {\r\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\r\n    },\r\n    _listeners: _listeners\r\n  };\r\n  return _self;\r\n}(),\r\n    _wake = function _wake() {\r\n  return !_tickerActive && _ticker.wake();\r\n},\r\n    //also ensures the core classes are initialized.\r\n\r\n/*\r\n* -------------------------------------------------\r\n* EASING\r\n* -------------------------------------------------\r\n*/\r\n_easeMap = {},\r\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\r\n    _quotesExp = /[\"']/g,\r\n    _parseObjectInString = function _parseObjectInString(value) {\r\n  //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\r\n  var obj = {},\r\n      split = value.substr(1, value.length - 3).split(\":\"),\r\n      key = split[0],\r\n      i = 1,\r\n      l = split.length,\r\n      index,\r\n      val,\r\n      parsedVal;\r\n\r\n  for (; i < l; i++) {\r\n    val = split[i];\r\n    index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\r\n    parsedVal = val.substr(0, index);\r\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\r\n    key = val.substr(index + 1).trim();\r\n  }\r\n\r\n  return obj;\r\n},\r\n    _valueInParentheses = function _valueInParentheses(value) {\r\n  var open = value.indexOf(\"(\") + 1,\r\n      close = value.indexOf(\")\"),\r\n      nested = value.indexOf(\"(\", open);\r\n  return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\r\n},\r\n    _configEaseFromString = function _configEaseFromString(name) {\r\n  //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\r\n  var split = (name + \"\").split(\"(\"),\r\n      ease = _easeMap[split[0]];\r\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\r\n},\r\n    _invertEase = function _invertEase(ease) {\r\n  return function (p) {\r\n    return 1 - ease(1 - p);\r\n  };\r\n},\r\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\r\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\r\n  var child = timeline._first,\r\n      ease;\r\n\r\n  while (child) {\r\n    if (child instanceof Timeline) {\r\n      _propagateYoyoEase(child, isYoyo);\r\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\r\n      if (child.timeline) {\r\n        _propagateYoyoEase(child.timeline, isYoyo);\r\n      } else {\r\n        ease = child._ease;\r\n        child._ease = child._yEase;\r\n        child._yEase = ease;\r\n        child._yoyo = isYoyo;\r\n      }\r\n    }\r\n\r\n    child = child._next;\r\n  }\r\n},\r\n    _parseEase = function _parseEase(ease, defaultEase) {\r\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\r\n},\r\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\r\n  if (easeOut === void 0) {\r\n    easeOut = function easeOut(p) {\r\n      return 1 - easeIn(1 - p);\r\n    };\r\n  }\r\n\r\n  if (easeInOut === void 0) {\r\n    easeInOut = function easeInOut(p) {\r\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\r\n    };\r\n  }\r\n\r\n  var ease = {\r\n    easeIn: easeIn,\r\n    easeOut: easeOut,\r\n    easeInOut: easeInOut\r\n  },\r\n      lowercaseName;\r\n\r\n  _forEachName(names, function (name) {\r\n    _easeMap[name] = _globals[name] = ease;\r\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\r\n\r\n    for (var p in ease) {\r\n      _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\r\n    }\r\n  });\r\n\r\n  return ease;\r\n},\r\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\r\n  return function (p) {\r\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\r\n  };\r\n},\r\n    _configElastic = function _configElastic(type, amplitude, period) {\r\n  var p1 = amplitude >= 1 ? amplitude : 1,\r\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\r\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\r\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\r\n      easeOut = function easeOut(p) {\r\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\r\n  },\r\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\r\n    return 1 - easeOut(1 - p);\r\n  } : _easeInOutFromOut(easeOut);\r\n\r\n  p2 = _2PI / p2; //precalculate to optimize\r\n\r\n  ease.config = function (amplitude, period) {\r\n    return _configElastic(type, amplitude, period);\r\n  };\r\n\r\n  return ease;\r\n},\r\n    _configBack = function _configBack(type, overshoot) {\r\n  if (overshoot === void 0) {\r\n    overshoot = 1.70158;\r\n  }\r\n\r\n  var easeOut = function easeOut(p) {\r\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\r\n  },\r\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\r\n    return 1 - easeOut(1 - p);\r\n  } : _easeInOutFromOut(easeOut);\r\n\r\n  ease.config = function (overshoot) {\r\n    return _configBack(type, overshoot);\r\n  };\r\n\r\n  return ease;\r\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\r\n// _weightedEase = ratio => {\r\n// \tlet y = 0.5 + ratio / 2;\r\n// \treturn p => (2 * (1 - p) * p * y + p * p);\r\n// },\r\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\r\n// _weightedEaseStrong = ratio => {\r\n// \tratio = .5 + ratio / 2;\r\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\r\n// \t\tb = ratio - o,\r\n// \t\tc = ratio + o;\r\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\r\n// };\r\n\r\n\r\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function (name, i) {\r\n  var power = i < 5 ? i + 1 : i;\r\n\r\n  _insertEase(name + \",Power\" + (power - 1), i ? function (p) {\r\n    return Math.pow(p, power);\r\n  } : function (p) {\r\n    return p;\r\n  }, function (p) {\r\n    return 1 - Math.pow(1 - p, power);\r\n  }, function (p) {\r\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\r\n  });\r\n});\r\n\r\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\r\n\r\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\r\n\r\n(function (n, c) {\r\n  var n1 = 1 / c,\r\n      n2 = 2 * n1,\r\n      n3 = 2.5 * n1,\r\n      easeOut = function easeOut(p) {\r\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\r\n  };\r\n\r\n  _insertEase(\"Bounce\", function (p) {\r\n    return 1 - easeOut(1 - p);\r\n  }, easeOut);\r\n})(7.5625, 2.75);\r\n\r\n_insertEase(\"Expo\", function (p) {\r\n  return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);\r\n}); // previously 2 ** (10 * (p - 1)) but that doesn't end up with the value quite at the right spot so we do a blended ease to ensure it lands where it should perfectly.\r\n\r\n\r\n_insertEase(\"Circ\", function (p) {\r\n  return -(_sqrt(1 - p * p) - 1);\r\n});\r\n\r\n_insertEase(\"Sine\", function (p) {\r\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\r\n});\r\n\r\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\r\n\r\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\r\n  config: function config(steps, immediateStart) {\r\n    if (steps === void 0) {\r\n      steps = 1;\r\n    }\r\n\r\n    var p1 = 1 / steps,\r\n        p2 = steps + (immediateStart ? 0 : 1),\r\n        p3 = immediateStart ? 1 : 0,\r\n        max = 1 - _tinyNum;\r\n    return function (p) {\r\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\r\n    };\r\n  }\r\n};\r\n_defaults.ease = _easeMap[\"quad.out\"];\r\n\r\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function (name) {\r\n  return _callbackNames += name + \",\" + name + \"Params,\";\r\n});\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * CACHE\r\n * --------------------------------------------------------------------------------------\r\n */\r\n\r\n\r\nvar GSCache = function GSCache(target, harness) {\r\n  this.id = _gsID++;\r\n  target._gsap = this;\r\n  this.target = target;\r\n  this.harness = harness;\r\n  this.get = harness ? harness.get : _getProperty;\r\n  this.set = harness ? harness.getSetter : _getSetter;\r\n};\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * ANIMATION\r\n * --------------------------------------------------------------------------------------\r\n */\r\n\r\nvar Animation = /*#__PURE__*/function () {\r\n  function Animation(vars) {\r\n    this.vars = vars;\r\n    this._delay = +vars.delay || 0;\r\n\r\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\r\n      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\r\n      this._rDelay = vars.repeatDelay || 0;\r\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\r\n    }\r\n\r\n    this._ts = 1;\r\n\r\n    _setDuration(this, +vars.duration, 1, 1);\r\n\r\n    this.data = vars.data;\r\n\r\n    if (_context) {\r\n      this._ctx = _context;\r\n\r\n      _context.data.push(this);\r\n    }\r\n\r\n    _tickerActive || _ticker.wake();\r\n  }\r\n\r\n  var _proto = Animation.prototype;\r\n\r\n  _proto.delay = function delay(value) {\r\n    if (value || value === 0) {\r\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\r\n      this._delay = value;\r\n      return this;\r\n    }\r\n\r\n    return this._delay;\r\n  };\r\n\r\n  _proto.duration = function duration(value) {\r\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\r\n  };\r\n\r\n  _proto.totalDuration = function totalDuration(value) {\r\n    if (!arguments.length) {\r\n      return this._tDur;\r\n    }\r\n\r\n    this._dirty = 0;\r\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\r\n  };\r\n\r\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\r\n    _wake();\r\n\r\n    if (!arguments.length) {\r\n      return this._tTime;\r\n    }\r\n\r\n    var parent = this._dp;\r\n\r\n    if (parent && parent.smoothChildTiming && this._ts) {\r\n      _alignPlayhead(this, _totalTime);\r\n\r\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\r\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\r\n\r\n      while (parent && parent.parent) {\r\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\r\n          parent.totalTime(parent._tTime, true);\r\n        }\r\n\r\n        parent = parent.parent;\r\n      }\r\n\r\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\r\n        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\r\n        _addToTimeline(this._dp, this, this._start - this._delay);\r\n      }\r\n    }\r\n\r\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\r\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\r\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\r\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\r\n      //   this._lock = 1;\r\n\r\n      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\r\n      //}\r\n\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.time = function time(value, suppressEvents) {\r\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\r\n  };\r\n\r\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\r\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;\r\n  };\r\n\r\n  _proto.progress = function progress(value, suppressEvents) {\r\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\r\n  };\r\n\r\n  _proto.iteration = function iteration(value, suppressEvents) {\r\n    var cycleDuration = this.duration() + this._rDelay;\r\n\r\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\r\n  } // potential future addition:\r\n  // isPlayingBackwards() {\r\n  // \tlet animation = this,\r\n  // \t\torientation = 1; // 1 = forward, -1 = backward\r\n  // \twhile (animation) {\r\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\r\n  // \t\tanimation = animation.parent;\r\n  // \t}\r\n  // \treturn orientation < 0;\r\n  // }\r\n  ;\r\n\r\n  _proto.timeScale = function timeScale(value, suppressEvents) {\r\n    if (!arguments.length) {\r\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\r\n    }\r\n\r\n    if (this._rts === value) {\r\n      return this;\r\n    }\r\n\r\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\r\n    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\r\n    //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\r\n    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\r\n\r\n    this._rts = +value || 0;\r\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\r\n\r\n    this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);\r\n\r\n    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\r\n\r\n\r\n    return _recacheAncestors(this);\r\n  };\r\n\r\n  _proto.paused = function paused(value) {\r\n    if (!arguments.length) {\r\n      return this._ps;\r\n    } // possible future addition - if an animation is removed from its parent and then .restart() or .play() or .resume() is called, perhaps we should force it back into the globalTimeline but be careful because what if it's already at its end? We don't want it to just persist forever and not get released for GC.\r\n    // !this.parent && !value && this._tTime < this._tDur && this !== _globalTimeline && _globalTimeline.add(this);\r\n\r\n\r\n    if (this._ps !== value) {\r\n      this._ps = value;\r\n\r\n      if (value) {\r\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\r\n\r\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\r\n      } else {\r\n        _wake();\r\n\r\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\r\n\r\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.startTime = function startTime(value) {\r\n    if (arguments.length) {\r\n      this._start = value;\r\n      var parent = this.parent || this._dp;\r\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\r\n      return this;\r\n    }\r\n\r\n    return this._start;\r\n  };\r\n\r\n  _proto.endTime = function endTime(includeRepeats) {\r\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\r\n  };\r\n\r\n  _proto.rawTime = function rawTime(wrapRepeats) {\r\n    var parent = this.parent || this._dp; // _dp = detached parent\r\n\r\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\r\n  };\r\n\r\n  _proto.revert = function revert(config) {\r\n    if (config === void 0) {\r\n      config = _revertConfig;\r\n    }\r\n\r\n    var prevIsReverting = _reverting;\r\n    _reverting = config;\r\n\r\n    if (_isRevertWorthy(this)) {\r\n      this.timeline && this.timeline.revert(config);\r\n      this.totalTime(-0.01, config.suppressEvents);\r\n    }\r\n\r\n    this.data !== \"nested\" && config.kill !== false && this.kill();\r\n    _reverting = prevIsReverting;\r\n    return this;\r\n  };\r\n\r\n  _proto.globalTime = function globalTime(rawTime) {\r\n    var animation = this,\r\n        time = arguments.length ? rawTime : animation.rawTime();\r\n\r\n    while (animation) {\r\n      time = animation._start + time / (Math.abs(animation._ts) || 1);\r\n      animation = animation._dp;\r\n    }\r\n\r\n    return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\r\n  };\r\n\r\n  _proto.repeat = function repeat(value) {\r\n    if (arguments.length) {\r\n      this._repeat = value === Infinity ? -2 : value;\r\n      return _onUpdateTotalDuration(this);\r\n    }\r\n\r\n    return this._repeat === -2 ? Infinity : this._repeat;\r\n  };\r\n\r\n  _proto.repeatDelay = function repeatDelay(value) {\r\n    if (arguments.length) {\r\n      var time = this._time;\r\n      this._rDelay = value;\r\n\r\n      _onUpdateTotalDuration(this);\r\n\r\n      return time ? this.time(time) : this;\r\n    }\r\n\r\n    return this._rDelay;\r\n  };\r\n\r\n  _proto.yoyo = function yoyo(value) {\r\n    if (arguments.length) {\r\n      this._yoyo = value;\r\n      return this;\r\n    }\r\n\r\n    return this._yoyo;\r\n  };\r\n\r\n  _proto.seek = function seek(position, suppressEvents) {\r\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\r\n  };\r\n\r\n  _proto.restart = function restart(includeDelay, suppressEvents) {\r\n    this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\r\n    this._dur || (this._zTime = -_tinyNum); // ensures onComplete fires on a zero-duration animation that gets restarted.\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto.play = function play(from, suppressEvents) {\r\n    from != null && this.seek(from, suppressEvents);\r\n    return this.reversed(false).paused(false);\r\n  };\r\n\r\n  _proto.reverse = function reverse(from, suppressEvents) {\r\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\r\n    return this.reversed(true).paused(false);\r\n  };\r\n\r\n  _proto.pause = function pause(atTime, suppressEvents) {\r\n    atTime != null && this.seek(atTime, suppressEvents);\r\n    return this.paused(true);\r\n  };\r\n\r\n  _proto.resume = function resume() {\r\n    return this.paused(false);\r\n  };\r\n\r\n  _proto.reversed = function reversed(value) {\r\n    if (arguments.length) {\r\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\r\n\r\n      return this;\r\n    }\r\n\r\n    return this._rts < 0;\r\n  };\r\n\r\n  _proto.invalidate = function invalidate() {\r\n    this._initted = this._act = 0;\r\n    this._zTime = -_tinyNum;\r\n    return this;\r\n  };\r\n\r\n  _proto.isActive = function isActive() {\r\n    var parent = this.parent || this._dp,\r\n        start = this._start,\r\n        rawTime;\r\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\r\n  };\r\n\r\n  _proto.eventCallback = function eventCallback(type, callback, params) {\r\n    var vars = this.vars;\r\n\r\n    if (arguments.length > 1) {\r\n      if (!callback) {\r\n        delete vars[type];\r\n      } else {\r\n        vars[type] = callback;\r\n        params && (vars[type + \"Params\"] = params);\r\n        type === \"onUpdate\" && (this._onUpdate = callback);\r\n      }\r\n\r\n      return this;\r\n    }\r\n\r\n    return vars[type];\r\n  };\r\n\r\n  _proto.then = function then(onFulfilled) {\r\n    var self = this;\r\n    return new Promise(function (resolve) {\r\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\r\n          _resolve = function _resolve() {\r\n        var _then = self.then;\r\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\r\n\r\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\r\n        resolve(f);\r\n        self.then = _then;\r\n      };\r\n\r\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\r\n        _resolve();\r\n      } else {\r\n        self._prom = _resolve;\r\n      }\r\n    });\r\n  };\r\n\r\n  _proto.kill = function kill() {\r\n    _interrupt(this);\r\n  };\r\n\r\n  return Animation;\r\n}();\r\n\r\n_setDefaults(Animation.prototype, {\r\n  _time: 0,\r\n  _start: 0,\r\n  _end: 0,\r\n  _tTime: 0,\r\n  _tDur: 0,\r\n  _dirty: 0,\r\n  _repeat: 0,\r\n  _yoyo: false,\r\n  parent: null,\r\n  _initted: false,\r\n  _rDelay: 0,\r\n  _ts: 1,\r\n  _dp: 0,\r\n  ratio: 0,\r\n  _zTime: -_tinyNum,\r\n  _prom: 0,\r\n  _ps: false,\r\n  _rts: 1\r\n});\r\n/*\r\n * -------------------------------------------------\r\n * TIMELINE\r\n * -------------------------------------------------\r\n */\r\n\r\n\r\nvar Timeline = /*#__PURE__*/function (_Animation) {\r\n  _inheritsLoose(Timeline, _Animation);\r\n\r\n  function Timeline(vars, position) {\r\n    var _this;\r\n\r\n    if (vars === void 0) {\r\n      vars = {};\r\n    }\r\n\r\n    _this = _Animation.call(this, vars) || this;\r\n    _this.labels = {};\r\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\r\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\r\n    _this._sort = _isNotFalse(vars.sortChildren);\r\n    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\r\n    vars.reversed && _this.reverse();\r\n    vars.paused && _this.paused(true);\r\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\r\n    return _this;\r\n  }\r\n\r\n  var _proto2 = Timeline.prototype;\r\n\r\n  _proto2.to = function to(targets, vars, position) {\r\n    _createTweenType(0, arguments, this);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto2.from = function from(targets, vars, position) {\r\n    _createTweenType(1, arguments, this);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\r\n    _createTweenType(2, arguments, this);\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto2.set = function set(targets, vars, position) {\r\n    vars.duration = 0;\r\n    vars.parent = this;\r\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\r\n    vars.immediateRender = !!vars.immediateRender;\r\n    new Tween(targets, vars, _parsePosition(this, position), 1);\r\n    return this;\r\n  };\r\n\r\n  _proto2.call = function call(callback, params, position) {\r\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\r\n  } //ONLY for backward compatibility! Maybe delete?\r\n  ;\r\n\r\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\r\n    vars.duration = duration;\r\n    vars.stagger = vars.stagger || stagger;\r\n    vars.onComplete = onCompleteAll;\r\n    vars.onCompleteParams = onCompleteAllParams;\r\n    vars.parent = this;\r\n    new Tween(targets, vars, _parsePosition(this, position));\r\n    return this;\r\n  };\r\n\r\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\r\n    vars.runBackwards = 1;\r\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\r\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\r\n  };\r\n\r\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\r\n    toVars.startAt = fromVars;\r\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\r\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\r\n  };\r\n\r\n  _proto2.render = function render(totalTime, suppressEvents, force) {\r\n    var prevTime = this._time,\r\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\r\n        dur = this._dur,\r\n        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),\r\n        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\r\n    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\r\n        time,\r\n        child,\r\n        next,\r\n        iteration,\r\n        cycleDuration,\r\n        prevPaused,\r\n        pauseTween,\r\n        timeScale,\r\n        prevStart,\r\n        prevIteration,\r\n        yoyo,\r\n        isYoyo;\r\n    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\r\n\r\n    if (tTime !== this._tTime || force || crossingStart) {\r\n      if (prevTime !== this._time && dur) {\r\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\r\n        tTime += this._time - prevTime;\r\n        totalTime += this._time - prevTime;\r\n      }\r\n\r\n      time = tTime;\r\n      prevStart = this._start;\r\n      timeScale = this._ts;\r\n      prevPaused = !timeScale;\r\n\r\n      if (crossingStart) {\r\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\r\n\r\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\r\n      }\r\n\r\n      if (this._repeat) {\r\n        //adjust the time for repeats and yoyos\r\n        yoyo = this._yoyo;\r\n        cycleDuration = dur + this._rDelay;\r\n\r\n        if (this._repeat < -1 && totalTime < 0) {\r\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\r\n        }\r\n\r\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\r\n\r\n        if (tTime === tDur) {\r\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\r\n          iteration = this._repeat;\r\n          time = dur;\r\n        } else {\r\n          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\r\n\r\n          iteration = ~~prevIteration;\r\n\r\n          if (iteration && iteration === prevIteration) {\r\n            time = dur;\r\n            iteration--;\r\n          }\r\n\r\n          time > dur && (time = dur);\r\n        }\r\n\r\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\r\n        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://gsap.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\r\n\r\n        if (yoyo && iteration & 1) {\r\n          time = dur - time;\r\n          isYoyo = 1;\r\n        }\r\n        /*\r\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\r\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\r\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\r\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\r\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\r\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\r\n        */\r\n\r\n\r\n        if (iteration !== prevIteration && !this._lock) {\r\n          var rewinding = yoyo && prevIteration & 1,\r\n              doesWrap = rewinding === (yoyo && iteration & 1);\r\n          iteration < prevIteration && (rewinding = !rewinding);\r\n          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\r\n\r\n          this._lock = 1;\r\n          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\r\n          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\r\n\r\n          !suppressEvents && this.parent && _callback(this, \"onRepeat\");\r\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\r\n\r\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\r\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\r\n            return this;\r\n          }\r\n\r\n          dur = this._dur; // in case the duration changed in the onRepeat\r\n\r\n          tDur = this._tDur;\r\n\r\n          if (doesWrap) {\r\n            this._lock = 2;\r\n            prevTime = rewinding ? dur : -0.0001;\r\n            this.render(prevTime, true);\r\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\r\n          }\r\n\r\n          this._lock = 0;\r\n\r\n          if (!this._ts && !prevPaused) {\r\n            return this;\r\n          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\r\n\r\n\r\n          _propagateYoyoEase(this, isYoyo);\r\n        }\r\n      }\r\n\r\n      if (this._hasPause && !this._forcing && this._lock < 2) {\r\n        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\r\n\r\n        if (pauseTween) {\r\n          tTime -= time - (time = pauseTween._start);\r\n        }\r\n      }\r\n\r\n      this._tTime = tTime;\r\n      this._time = time;\r\n      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\r\n\r\n      if (!this._initted) {\r\n        this._onUpdate = this.vars.onUpdate;\r\n        this._initted = 1;\r\n        this._zTime = totalTime;\r\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\r\n      }\r\n\r\n      if (!prevTime && tTime && !suppressEvents && !prevIteration) {\r\n        _callback(this, \"onStart\");\r\n\r\n        if (this._tTime !== tTime) {\r\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\r\n          return this;\r\n        }\r\n      }\r\n\r\n      if (time >= prevTime && totalTime >= 0) {\r\n        child = this._first;\r\n\r\n        while (child) {\r\n          next = child._next;\r\n\r\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\r\n            if (child.parent !== this) {\r\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\r\n              return this.render(totalTime, suppressEvents, force);\r\n            }\r\n\r\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\r\n\r\n            if (time !== this._time || !this._ts && !prevPaused) {\r\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\r\n              pauseTween = 0;\r\n              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that the next time render() is called it'll be forced (to render any remaining children)\r\n\r\n              break;\r\n            }\r\n          }\r\n\r\n          child = next;\r\n        }\r\n      } else {\r\n        child = this._last;\r\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\r\n\r\n        while (child) {\r\n          next = child._prev;\r\n\r\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\r\n            if (child.parent !== this) {\r\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\r\n              return this.render(totalTime, suppressEvents, force);\r\n            }\r\n\r\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\r\n\r\n            if (time !== this._time || !this._ts && !prevPaused) {\r\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\r\n              pauseTween = 0;\r\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\r\n\r\n              break;\r\n            }\r\n          }\r\n\r\n          child = next;\r\n        }\r\n      }\r\n\r\n      if (pauseTween && !suppressEvents) {\r\n        this.pause();\r\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\r\n\r\n        if (this._ts) {\r\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\r\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\r\n\r\n          _setEnd(this);\r\n\r\n          return this.render(totalTime, suppressEvents, force);\r\n        }\r\n      }\r\n\r\n      this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\r\n      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\r\n        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\r\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\r\n\r\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\r\n          _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\r\n\r\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto2.add = function add(child, position) {\r\n    var _this2 = this;\r\n\r\n    _isNumber(position) || (position = _parsePosition(this, position, child));\r\n\r\n    if (!(child instanceof Animation)) {\r\n      if (_isArray(child)) {\r\n        child.forEach(function (obj) {\r\n          return _this2.add(obj, position);\r\n        });\r\n        return this;\r\n      }\r\n\r\n      if (_isString(child)) {\r\n        return this.addLabel(child, position);\r\n      }\r\n\r\n      if (_isFunction(child)) {\r\n        child = Tween.delayedCall(0, child);\r\n      } else {\r\n        return this;\r\n      }\r\n    }\r\n\r\n    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\r\n  };\r\n\r\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\r\n    if (nested === void 0) {\r\n      nested = true;\r\n    }\r\n\r\n    if (tweens === void 0) {\r\n      tweens = true;\r\n    }\r\n\r\n    if (timelines === void 0) {\r\n      timelines = true;\r\n    }\r\n\r\n    if (ignoreBeforeTime === void 0) {\r\n      ignoreBeforeTime = -_bigNum;\r\n    }\r\n\r\n    var a = [],\r\n        child = this._first;\r\n\r\n    while (child) {\r\n      if (child._start >= ignoreBeforeTime) {\r\n        if (child instanceof Tween) {\r\n          tweens && a.push(child);\r\n        } else {\r\n          timelines && a.push(child);\r\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\r\n        }\r\n      }\r\n\r\n      child = child._next;\r\n    }\r\n\r\n    return a;\r\n  };\r\n\r\n  _proto2.getById = function getById(id) {\r\n    var animations = this.getChildren(1, 1, 1),\r\n        i = animations.length;\r\n\r\n    while (i--) {\r\n      if (animations[i].vars.id === id) {\r\n        return animations[i];\r\n      }\r\n    }\r\n  };\r\n\r\n  _proto2.remove = function remove(child) {\r\n    if (_isString(child)) {\r\n      return this.removeLabel(child);\r\n    }\r\n\r\n    if (_isFunction(child)) {\r\n      return this.killTweensOf(child);\r\n    }\r\n\r\n    child.parent === this && _removeLinkedListItem(this, child);\r\n\r\n    if (child === this._recent) {\r\n      this._recent = this._last;\r\n    }\r\n\r\n    return _uncache(this);\r\n  };\r\n\r\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\r\n    if (!arguments.length) {\r\n      return this._tTime;\r\n    }\r\n\r\n    this._forcing = 1;\r\n\r\n    if (!this._dp && this._ts) {\r\n      //special case for the global timeline (or any other that has no parent or detached parent).\r\n      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\r\n    }\r\n\r\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\r\n\r\n    this._forcing = 0;\r\n    return this;\r\n  };\r\n\r\n  _proto2.addLabel = function addLabel(label, position) {\r\n    this.labels[label] = _parsePosition(this, position);\r\n    return this;\r\n  };\r\n\r\n  _proto2.removeLabel = function removeLabel(label) {\r\n    delete this.labels[label];\r\n    return this;\r\n  };\r\n\r\n  _proto2.addPause = function addPause(position, callback, params) {\r\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\r\n    t.data = \"isPause\";\r\n    this._hasPause = 1;\r\n    return _addToTimeline(this, t, _parsePosition(this, position));\r\n  };\r\n\r\n  _proto2.removePause = function removePause(position) {\r\n    var child = this._first;\r\n    position = _parsePosition(this, position);\r\n\r\n    while (child) {\r\n      if (child._start === position && child.data === \"isPause\") {\r\n        _removeFromParent(child);\r\n      }\r\n\r\n      child = child._next;\r\n    }\r\n  };\r\n\r\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\r\n    var tweens = this.getTweensOf(targets, onlyActive),\r\n        i = tweens.length;\r\n\r\n    while (i--) {\r\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\r\n    var a = [],\r\n        parsedTargets = toArray(targets),\r\n        child = this._first,\r\n        isGlobalTime = _isNumber(onlyActive),\r\n        // a number is interpreted as a global time. If the animation spans\r\n    children;\r\n\r\n    while (child) {\r\n      if (child instanceof Tween) {\r\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\r\n          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\r\n          a.push(child);\r\n        }\r\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\r\n        a.push.apply(a, children);\r\n      }\r\n\r\n      child = child._next;\r\n    }\r\n\r\n    return a;\r\n  } // potential future feature - targets() on timelines\r\n  // targets() {\r\n  // \tlet result = [];\r\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\r\n  // \treturn result.filter((v, i) => result.indexOf(v) === i);\r\n  // }\r\n  ;\r\n\r\n  _proto2.tweenTo = function tweenTo(position, vars) {\r\n    vars = vars || {};\r\n\r\n    var tl = this,\r\n        endTime = _parsePosition(tl, position),\r\n        _vars = vars,\r\n        startAt = _vars.startAt,\r\n        _onStart = _vars.onStart,\r\n        onStartParams = _vars.onStartParams,\r\n        immediateRender = _vars.immediateRender,\r\n        initted,\r\n        tween = Tween.to(tl, _setDefaults({\r\n      ease: vars.ease || \"none\",\r\n      lazy: false,\r\n      immediateRender: false,\r\n      time: endTime,\r\n      overwrite: \"auto\",\r\n      duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\r\n      onStart: function onStart() {\r\n        tl.pause();\r\n\r\n        if (!initted) {\r\n          var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\r\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\r\n          initted = 1;\r\n        }\r\n\r\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\r\n      }\r\n    }, vars));\r\n\r\n    return immediateRender ? tween.render(0) : tween;\r\n  };\r\n\r\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\r\n    return this.tweenTo(toPosition, _setDefaults({\r\n      startAt: {\r\n        time: _parsePosition(this, fromPosition)\r\n      }\r\n    }, vars));\r\n  };\r\n\r\n  _proto2.recent = function recent() {\r\n    return this._recent;\r\n  };\r\n\r\n  _proto2.nextLabel = function nextLabel(afterTime) {\r\n    if (afterTime === void 0) {\r\n      afterTime = this._time;\r\n    }\r\n\r\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\r\n  };\r\n\r\n  _proto2.previousLabel = function previousLabel(beforeTime) {\r\n    if (beforeTime === void 0) {\r\n      beforeTime = this._time;\r\n    }\r\n\r\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\r\n  };\r\n\r\n  _proto2.currentLabel = function currentLabel(value) {\r\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\r\n  };\r\n\r\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\r\n    if (ignoreBeforeTime === void 0) {\r\n      ignoreBeforeTime = 0;\r\n    }\r\n\r\n    var child = this._first,\r\n        labels = this.labels,\r\n        p;\r\n\r\n    while (child) {\r\n      if (child._start >= ignoreBeforeTime) {\r\n        child._start += amount;\r\n        child._end += amount;\r\n      }\r\n\r\n      child = child._next;\r\n    }\r\n\r\n    if (adjustLabels) {\r\n      for (p in labels) {\r\n        if (labels[p] >= ignoreBeforeTime) {\r\n          labels[p] += amount;\r\n        }\r\n      }\r\n    }\r\n\r\n    return _uncache(this);\r\n  };\r\n\r\n  _proto2.invalidate = function invalidate(soft) {\r\n    var child = this._first;\r\n    this._lock = 0;\r\n\r\n    while (child) {\r\n      child.invalidate(soft);\r\n      child = child._next;\r\n    }\r\n\r\n    return _Animation.prototype.invalidate.call(this, soft);\r\n  };\r\n\r\n  _proto2.clear = function clear(includeLabels) {\r\n    if (includeLabels === void 0) {\r\n      includeLabels = true;\r\n    }\r\n\r\n    var child = this._first,\r\n        next;\r\n\r\n    while (child) {\r\n      next = child._next;\r\n      this.remove(child);\r\n      child = next;\r\n    }\r\n\r\n    this._dp && (this._time = this._tTime = this._pTime = 0);\r\n    includeLabels && (this.labels = {});\r\n    return _uncache(this);\r\n  };\r\n\r\n  _proto2.totalDuration = function totalDuration(value) {\r\n    var max = 0,\r\n        self = this,\r\n        child = self._last,\r\n        prevStart = _bigNum,\r\n        prev,\r\n        start,\r\n        parent;\r\n\r\n    if (arguments.length) {\r\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\r\n    }\r\n\r\n    if (self._dirty) {\r\n      parent = self.parent;\r\n\r\n      while (child) {\r\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\r\n\r\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\r\n\r\n        start = child._start;\r\n\r\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\r\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\r\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\r\n\r\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\r\n        } else {\r\n          prevStart = start;\r\n        }\r\n\r\n        if (start < 0 && child._ts) {\r\n          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\r\n          max -= start;\r\n\r\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\r\n            self._start += start / self._ts;\r\n            self._time -= start;\r\n            self._tTime -= start;\r\n          }\r\n\r\n          self.shiftChildren(-start, false, -1e999);\r\n          prevStart = 0;\r\n        }\r\n\r\n        child._end > max && child._ts && (max = child._end);\r\n        child = prev;\r\n      }\r\n\r\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\r\n\r\n      self._dirty = 0;\r\n    }\r\n\r\n    return self._tDur;\r\n  };\r\n\r\n  Timeline.updateRoot = function updateRoot(time) {\r\n    if (_globalTimeline._ts) {\r\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\r\n\r\n      _lastRenderedFrame = _ticker.frame;\r\n    }\r\n\r\n    if (_ticker.frame >= _nextGCFrame) {\r\n      _nextGCFrame += _config.autoSleep || 120;\r\n      var child = _globalTimeline._first;\r\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\r\n        while (child && !child._ts) {\r\n          child = child._next;\r\n        }\r\n\r\n        child || _ticker.sleep();\r\n      }\r\n    }\r\n  };\r\n\r\n  return Timeline;\r\n}(Animation);\r\n\r\n_setDefaults(Timeline.prototype, {\r\n  _lock: 0,\r\n  _hasPause: 0,\r\n  _forcing: 0\r\n});\r\n\r\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\r\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\r\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\r\n      index = 0,\r\n      matchIndex = 0,\r\n      result,\r\n      startNums,\r\n      color,\r\n      endNum,\r\n      chunk,\r\n      startNum,\r\n      hasRandom,\r\n      a;\r\n  pt.b = start;\r\n  pt.e = end;\r\n  start += \"\"; //ensure values are strings\r\n\r\n  end += \"\";\r\n\r\n  if (hasRandom = ~end.indexOf(\"random(\")) {\r\n    end = _replaceRandom(end);\r\n  }\r\n\r\n  if (stringFilter) {\r\n    a = [start, end];\r\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\r\n\r\n    start = a[0];\r\n    end = a[1];\r\n  }\r\n\r\n  startNums = start.match(_complexStringNumExp) || [];\r\n\r\n  while (result = _complexStringNumExp.exec(end)) {\r\n    endNum = result[0];\r\n    chunk = end.substring(index, result.index);\r\n\r\n    if (color) {\r\n      color = (color + 1) % 5;\r\n    } else if (chunk.substr(-5) === \"rgba(\") {\r\n      color = 1;\r\n    }\r\n\r\n    if (endNum !== startNums[matchIndex++]) {\r\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\r\n\r\n      pt._pt = {\r\n        _next: pt._pt,\r\n        p: chunk || matchIndex === 1 ? chunk : \",\",\r\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\r\n        s: startNum,\r\n        c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\r\n        m: color && color < 4 ? Math.round : 0\r\n      };\r\n      index = _complexStringNumExp.lastIndex;\r\n    }\r\n  }\r\n\r\n  pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\r\n\r\n  pt.fp = funcParam;\r\n\r\n  if (_relExp.test(end) || hasRandom) {\r\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\r\n  }\r\n\r\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\r\n\r\n  return pt;\r\n},\r\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\r\n  _isFunction(end) && (end = end(index || 0, target, targets));\r\n  var currentValue = target[prop],\r\n      parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](),\r\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\r\n      pt;\r\n\r\n  if (_isString(end)) {\r\n    if (~end.indexOf(\"random(\")) {\r\n      end = _replaceRandom(end);\r\n    }\r\n\r\n    if (end.charAt(1) === \"=\") {\r\n      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\r\n\r\n      if (pt || pt === 0) {\r\n        // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\r\n        end = pt;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!optional || parsedStart !== end || _forceAllPropTweens) {\r\n    if (!isNaN(parsedStart * end) && end !== \"\") {\r\n      // fun fact: any number multiplied by \"\" is evaluated as the number 0!\r\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\r\n      funcParam && (pt.fp = funcParam);\r\n      modifier && pt.modifier(modifier, this, target);\r\n      return this._pt = pt;\r\n    }\r\n\r\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\r\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\r\n  }\r\n},\r\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\r\n_processVars = function _processVars(vars, index, target, targets, tween) {\r\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\r\n\r\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\r\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\r\n  }\r\n\r\n  var copy = {},\r\n      p;\r\n\r\n  for (p in vars) {\r\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\r\n  }\r\n\r\n  return copy;\r\n},\r\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\r\n  var plugin, pt, ptLookup, i;\r\n\r\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\r\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\r\n\r\n    if (tween !== _quickTween) {\r\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\r\n\r\n      i = plugin._props.length;\r\n\r\n      while (i--) {\r\n        ptLookup[plugin._props[i]] = pt;\r\n      }\r\n    }\r\n  }\r\n\r\n  return plugin;\r\n},\r\n    _overwritingTween,\r\n    //store a reference temporarily so we can avoid overwriting itself.\r\n_forceAllPropTweens,\r\n    _initTween = function _initTween(tween, time, tTime) {\r\n  var vars = tween.vars,\r\n      ease = vars.ease,\r\n      startAt = vars.startAt,\r\n      immediateRender = vars.immediateRender,\r\n      lazy = vars.lazy,\r\n      onUpdate = vars.onUpdate,\r\n      runBackwards = vars.runBackwards,\r\n      yoyoEase = vars.yoyoEase,\r\n      keyframes = vars.keyframes,\r\n      autoRevert = vars.autoRevert,\r\n      dur = tween._dur,\r\n      prevStartAt = tween._startAt,\r\n      targets = tween._targets,\r\n      parent = tween.parent,\r\n      fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets,\r\n      autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites,\r\n      tl = tween.timeline,\r\n      cleanVars,\r\n      i,\r\n      p,\r\n      pt,\r\n      target,\r\n      hasPriority,\r\n      gsData,\r\n      harness,\r\n      plugin,\r\n      ptLookup,\r\n      index,\r\n      harnessVars,\r\n      overwritten;\r\n  tl && (!keyframes || !ease) && (ease = \"none\");\r\n  tween._ease = _parseEase(ease, _defaults.ease);\r\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\r\n\r\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\r\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\r\n    yoyoEase = tween._yEase;\r\n    tween._yEase = tween._ease;\r\n    tween._ease = yoyoEase;\r\n  }\r\n\r\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\r\n\r\n  if (!tl || keyframes && !vars.stagger) {\r\n    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\r\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\r\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\r\n\r\n    cleanVars = _copyExcluding(vars, _reservedProps);\r\n\r\n    if (prevStartAt) {\r\n      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\r\n\r\n      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\r\n      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\r\n\r\n      prevStartAt._lazy = 0;\r\n    }\r\n\r\n    if (startAt) {\r\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\r\n        data: \"isStart\",\r\n        overwrite: false,\r\n        parent: parent,\r\n        immediateRender: true,\r\n        lazy: !prevStartAt && _isNotFalse(lazy),\r\n        startAt: null,\r\n        delay: 0,\r\n        onUpdate: onUpdate && function () {\r\n          return _callback(tween, \"onUpdate\");\r\n        },\r\n        stagger: 0\r\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\r\n\r\n\r\n      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\r\n\r\n      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\r\n\r\n      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\r\n\r\n      if (immediateRender) {\r\n        if (dur && time <= 0 && tTime <= 0) {\r\n          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\r\n          time && (tween._zTime = time);\r\n          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\r\n        }\r\n      }\r\n    } else if (runBackwards && dur) {\r\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\r\n      if (!prevStartAt) {\r\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\r\n\r\n        p = _setDefaults({\r\n          overwrite: false,\r\n          data: \"isFromStart\",\r\n          //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\r\n          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\r\n          immediateRender: immediateRender,\r\n          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\r\n          stagger: 0,\r\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\r\n\r\n        }, cleanVars);\r\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\r\n\r\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\r\n\r\n        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\r\n\r\n        tween._startAt._sat = tween; // used in globalTime()\r\n\r\n        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\r\n        tween._zTime = time;\r\n\r\n        if (!immediateRender) {\r\n          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\r\n\r\n        } else if (!time) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    tween._pt = tween._ptCache = 0;\r\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\r\n\r\n    for (i = 0; i < targets.length; i++) {\r\n      target = targets[i];\r\n      gsData = target._gsap || _harness(targets)[i]._gsap;\r\n      tween._ptLookup[i] = ptLookup = {};\r\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\r\n\r\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\r\n\r\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\r\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\r\n\r\n        plugin._props.forEach(function (name) {\r\n          ptLookup[name] = pt;\r\n        });\r\n\r\n        plugin.priority && (hasPriority = 1);\r\n      }\r\n\r\n      if (!harness || harnessVars) {\r\n        for (p in cleanVars) {\r\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\r\n            plugin.priority && (hasPriority = 1);\r\n          } else {\r\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\r\n          }\r\n        }\r\n      }\r\n\r\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\r\n\r\n      if (autoOverwrite && tween._pt) {\r\n        _overwritingTween = tween;\r\n\r\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\r\n\r\n\r\n        overwritten = !tween.parent;\r\n        _overwritingTween = 0;\r\n      }\r\n\r\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\r\n    }\r\n\r\n    hasPriority && _sortPropTweensByPriority(tween);\r\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\r\n  }\r\n\r\n  tween._onUpdate = onUpdate;\r\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\r\n\r\n  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\r\n},\r\n    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\r\n  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],\r\n      pt,\r\n      rootPT,\r\n      lookup,\r\n      i;\r\n\r\n  if (!ptCache) {\r\n    ptCache = tween._ptCache[property] = [];\r\n    lookup = tween._ptLookup;\r\n    i = tween._targets.length;\r\n\r\n    while (i--) {\r\n      pt = lookup[i][property];\r\n\r\n      if (pt && pt.d && pt.d._pt) {\r\n        // it's a plugin, so find the nested PropTween\r\n        pt = pt.d._pt;\r\n\r\n        while (pt && pt.p !== property && pt.fp !== property) {\r\n          // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\r\n          pt = pt._next;\r\n        }\r\n      }\r\n\r\n      if (!pt) {\r\n        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\r\n        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\r\n        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\r\n\r\n        tween.vars[property] = \"+=0\";\r\n\r\n        _initTween(tween, time);\r\n\r\n        _forceAllPropTweens = 0;\r\n        return skipRecursion ? _warn(property + \" not eligible for reset\") : 1; // if someone tries to do a quickTo() on a special property like borderRadius which must get split into 4 different properties, that's not eligible for .resetTo().\r\n      }\r\n\r\n      ptCache.push(pt);\r\n    }\r\n  }\r\n\r\n  i = ptCache.length;\r\n\r\n  while (i--) {\r\n    rootPT = ptCache[i];\r\n    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\r\n\r\n    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\r\n    pt.c = value - pt.s;\r\n    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\r\n\r\n    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\r\n  }\r\n},\r\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\r\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\r\n      propertyAliases = harness && harness.aliases,\r\n      copy,\r\n      p,\r\n      i,\r\n      aliases;\r\n\r\n  if (!propertyAliases) {\r\n    return vars;\r\n  }\r\n\r\n  copy = _merge({}, vars);\r\n\r\n  for (p in propertyAliases) {\r\n    if (p in copy) {\r\n      aliases = propertyAliases[p].split(\",\");\r\n      i = aliases.length;\r\n\r\n      while (i--) {\r\n        copy[aliases[i]] = copy[p];\r\n      }\r\n    }\r\n  }\r\n\r\n  return copy;\r\n},\r\n    // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\r\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\r\n  var ease = obj.ease || easeEach || \"power1.inOut\",\r\n      p,\r\n      a;\r\n\r\n  if (_isArray(obj)) {\r\n    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\r\n\r\n    obj.forEach(function (value, i) {\r\n      return a.push({\r\n        t: i / (obj.length - 1) * 100,\r\n        v: value,\r\n        e: ease\r\n      });\r\n    });\r\n  } else {\r\n    for (p in obj) {\r\n      a = allProps[p] || (allProps[p] = []);\r\n      p === \"ease\" || a.push({\r\n        t: parseFloat(prop),\r\n        v: obj[p],\r\n        e: ease\r\n      });\r\n    }\r\n  }\r\n},\r\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\r\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\r\n},\r\n    _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\",\r\n    _staggerPropsToSkip = {};\r\n\r\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function (name) {\r\n  return _staggerPropsToSkip[name] = 1;\r\n});\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * TWEEN\r\n * --------------------------------------------------------------------------------------\r\n */\r\n\r\n\r\nvar Tween = /*#__PURE__*/function (_Animation2) {\r\n  _inheritsLoose(Tween, _Animation2);\r\n\r\n  function Tween(targets, vars, position, skipInherit) {\r\n    var _this3;\r\n\r\n    if (typeof vars === \"number\") {\r\n      position.duration = vars;\r\n      vars = position;\r\n      position = null;\r\n    }\r\n\r\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\r\n    var _this3$vars = _this3.vars,\r\n        duration = _this3$vars.duration,\r\n        delay = _this3$vars.delay,\r\n        immediateRender = _this3$vars.immediateRender,\r\n        stagger = _this3$vars.stagger,\r\n        overwrite = _this3$vars.overwrite,\r\n        keyframes = _this3$vars.keyframes,\r\n        defaults = _this3$vars.defaults,\r\n        scrollTrigger = _this3$vars.scrollTrigger,\r\n        yoyoEase = _this3$vars.yoyoEase,\r\n        parent = vars.parent || _globalTimeline,\r\n        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets),\r\n        tl,\r\n        i,\r\n        copy,\r\n        l,\r\n        p,\r\n        curTarget,\r\n        staggerFunc,\r\n        staggerVarsToMerge;\r\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\r\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\r\n\r\n    _this3._overwrite = overwrite;\r\n\r\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\r\n      vars = _this3.vars;\r\n      tl = _this3.timeline = new Timeline({\r\n        data: \"nested\",\r\n        defaults: defaults || {},\r\n        targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\r\n      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\r\n\r\n      tl.kill();\r\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\r\n      tl._start = 0;\r\n\r\n      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\r\n        l = parsedTargets.length;\r\n        staggerFunc = stagger && distribute(stagger);\r\n\r\n        if (_isObject(stagger)) {\r\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\r\n          for (p in stagger) {\r\n            if (~_staggerTweenProps.indexOf(p)) {\r\n              staggerVarsToMerge || (staggerVarsToMerge = {});\r\n              staggerVarsToMerge[p] = stagger[p];\r\n            }\r\n          }\r\n        }\r\n\r\n        for (i = 0; i < l; i++) {\r\n          copy = _copyExcluding(vars, _staggerPropsToSkip);\r\n          copy.stagger = 0;\r\n          yoyoEase && (copy.yoyoEase = yoyoEase);\r\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\r\n          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\r\n\r\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\r\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\r\n\r\n          if (!stagger && l === 1 && copy.delay) {\r\n            // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\r\n            _this3._delay = delay = copy.delay;\r\n            _this3._start += delay;\r\n            copy.delay = 0;\r\n          }\r\n\r\n          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\r\n          tl._ease = _easeMap.none;\r\n        }\r\n\r\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\r\n      } else if (keyframes) {\r\n        _inheritDefaults(_setDefaults(tl.vars.defaults, {\r\n          ease: \"none\"\r\n        }));\r\n\r\n        tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\r\n        var time = 0,\r\n            a,\r\n            kf,\r\n            v;\r\n\r\n        if (_isArray(keyframes)) {\r\n          keyframes.forEach(function (frame) {\r\n            return tl.to(parsedTargets, frame, \">\");\r\n          });\r\n          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\r\n        } else {\r\n          copy = {};\r\n\r\n          for (p in keyframes) {\r\n            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\r\n          }\r\n\r\n          for (p in copy) {\r\n            a = copy[p].sort(function (a, b) {\r\n              return a.t - b.t;\r\n            });\r\n            time = 0;\r\n\r\n            for (i = 0; i < a.length; i++) {\r\n              kf = a[i];\r\n              v = {\r\n                ease: kf.e,\r\n                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\r\n              };\r\n              v[p] = kf.v;\r\n              tl.to(parsedTargets, v, time);\r\n              time += v.duration;\r\n            }\r\n          }\r\n\r\n          tl.duration() < duration && tl.to({}, {\r\n            duration: duration - tl.duration()\r\n          }); // in case keyframes didn't go to 100%\r\n        }\r\n      }\r\n\r\n      duration || _this3.duration(duration = tl.duration());\r\n    } else {\r\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\r\n    }\r\n\r\n    if (overwrite === true && !_suppressOverwrites) {\r\n      _overwritingTween = _assertThisInitialized(_this3);\r\n\r\n      _globalTimeline.killTweensOf(parsedTargets);\r\n\r\n      _overwritingTween = 0;\r\n    }\r\n\r\n    _addToTimeline(parent, _assertThisInitialized(_this3), position);\r\n\r\n    vars.reversed && _this3.reverse();\r\n    vars.paused && _this3.paused(true);\r\n\r\n    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\r\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\r\n\r\n      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\r\n\r\n    }\r\n\r\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\r\n    return _this3;\r\n  }\r\n\r\n  var _proto3 = Tween.prototype;\r\n\r\n  _proto3.render = function render(totalTime, suppressEvents, force) {\r\n    var prevTime = this._time,\r\n        tDur = this._tDur,\r\n        dur = this._dur,\r\n        isNegative = totalTime < 0,\r\n        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,\r\n        time,\r\n        pt,\r\n        iteration,\r\n        cycleDuration,\r\n        prevIteration,\r\n        isYoyo,\r\n        ratio,\r\n        timeline,\r\n        yoyoEase;\r\n\r\n    if (!dur) {\r\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\r\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {\r\n      // this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\r\n      time = tTime;\r\n      timeline = this.timeline;\r\n\r\n      if (this._repeat) {\r\n        //adjust the time for repeats and yoyos\r\n        cycleDuration = dur + this._rDelay;\r\n\r\n        if (this._repeat < -1 && isNegative) {\r\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\r\n        }\r\n\r\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\r\n\r\n        if (tTime === tDur) {\r\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\r\n          iteration = this._repeat;\r\n          time = dur;\r\n        } else {\r\n          prevIteration = _roundPrecise(tTime / cycleDuration); // full decimal version of iterations, not the previous iteration (we're reusing prevIteration variable for efficiency)\r\n\r\n          iteration = ~~prevIteration;\r\n\r\n          if (iteration && iteration === prevIteration) {\r\n            time = dur;\r\n            iteration--;\r\n          } else if (time > dur) {\r\n            time = dur;\r\n          }\r\n        }\r\n\r\n        isYoyo = this._yoyo && iteration & 1;\r\n\r\n        if (isYoyo) {\r\n          yoyoEase = this._yEase;\r\n          time = dur - time;\r\n        }\r\n\r\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\r\n\r\n        if (time === prevTime && !force && this._initted && iteration === prevIteration) {\r\n          //could be during the repeatDelay part. No need to render and fire callbacks.\r\n          this._tTime = tTime;\r\n          return this;\r\n        }\r\n\r\n        if (iteration !== prevIteration) {\r\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\r\n\r\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {\r\n            // this._time will === cycleDuration when we render at EXACTLY the end of an iteration. Without this condition, it'd often do the repeatRefresh render TWICE (again on the very next tick).\r\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\r\n\r\n            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!this._initted) {\r\n        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\r\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\r\n\r\n          return this;\r\n        }\r\n\r\n        if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\r\n          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values. But we also don't want to dump if we're doing a repeatRefresh render!\r\n          return this;\r\n        }\r\n\r\n        if (dur !== this._dur) {\r\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\r\n          return this.render(totalTime, suppressEvents, force);\r\n        }\r\n      }\r\n\r\n      this._tTime = tTime;\r\n      this._time = time;\r\n\r\n      if (!this._act && this._ts) {\r\n        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\r\n\r\n        this._lazy = 0;\r\n      }\r\n\r\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\r\n\r\n      if (this._from) {\r\n        this.ratio = ratio = 1 - ratio;\r\n      }\r\n\r\n      if (!prevTime && tTime && !suppressEvents && !prevIteration) {\r\n        _callback(this, \"onStart\");\r\n\r\n        if (this._tTime !== tTime) {\r\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\r\n          return this;\r\n        }\r\n      }\r\n\r\n      pt = this._pt;\r\n\r\n      while (pt) {\r\n        pt.r(ratio, pt.d);\r\n        pt = pt._next;\r\n      }\r\n\r\n      timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\r\n\r\n      if (this._onUpdate && !suppressEvents) {\r\n        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\r\n\r\n        _callback(this, \"onUpdate\");\r\n      }\r\n\r\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\r\n\r\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\r\n        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\r\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\r\n\r\n        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\r\n          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\r\n          _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\r\n\r\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  _proto3.targets = function targets() {\r\n    return this._targets;\r\n  };\r\n\r\n  _proto3.invalidate = function invalidate(soft) {\r\n    // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\r\n    (!soft || !this.vars.runBackwards) && (this._startAt = 0);\r\n    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\r\n    this._ptLookup = [];\r\n    this.timeline && this.timeline.invalidate(soft);\r\n    return _Animation2.prototype.invalidate.call(this, soft);\r\n  };\r\n\r\n  _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\r\n    _tickerActive || _ticker.wake();\r\n    this._ts || this.play();\r\n    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),\r\n        ratio;\r\n    this._initted || _initTween(this, time);\r\n    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\r\n    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\r\n    // if (_isObject(property)) { // performance optimization\r\n    // \tfor (p in property) {\r\n    // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\r\n    // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\r\n    // \t\t}\r\n    // \t}\r\n    // } else {\r\n\r\n    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\r\n      return this.resetTo(property, value, start, startIsRelative, 1); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\r\n    } //}\r\n\r\n\r\n    _alignPlayhead(this, 0);\r\n\r\n    this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\r\n    return this.render(0);\r\n  };\r\n\r\n  _proto3.kill = function kill(targets, vars) {\r\n    if (vars === void 0) {\r\n      vars = \"all\";\r\n    }\r\n\r\n    if (!targets && (!vars || vars === \"all\")) {\r\n      this._lazy = this._pt = 0;\r\n      this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);\r\n      return this;\r\n    }\r\n\r\n    if (this.timeline) {\r\n      var tDur = this.timeline.totalDuration();\r\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\r\n\r\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\r\n\r\n      return this;\r\n    }\r\n\r\n    var parsedTargets = this._targets,\r\n        killingTargets = targets ? toArray(targets) : parsedTargets,\r\n        propTweenLookup = this._ptLookup,\r\n        firstPT = this._pt,\r\n        overwrittenProps,\r\n        curLookup,\r\n        curOverwriteProps,\r\n        props,\r\n        p,\r\n        pt,\r\n        i;\r\n\r\n    if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\r\n      vars === \"all\" && (this._pt = 0);\r\n      return _interrupt(this);\r\n    }\r\n\r\n    overwrittenProps = this._op = this._op || [];\r\n\r\n    if (vars !== \"all\") {\r\n      //so people can pass in a comma-delimited list of property names\r\n      if (_isString(vars)) {\r\n        p = {};\r\n\r\n        _forEachName(vars, function (name) {\r\n          return p[name] = 1;\r\n        });\r\n\r\n        vars = p;\r\n      }\r\n\r\n      vars = _addAliasesToVars(parsedTargets, vars);\r\n    }\r\n\r\n    i = parsedTargets.length;\r\n\r\n    while (i--) {\r\n      if (~killingTargets.indexOf(parsedTargets[i])) {\r\n        curLookup = propTweenLookup[i];\r\n\r\n        if (vars === \"all\") {\r\n          overwrittenProps[i] = vars;\r\n          props = curLookup;\r\n          curOverwriteProps = {};\r\n        } else {\r\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\r\n          props = vars;\r\n        }\r\n\r\n        for (p in props) {\r\n          pt = curLookup && curLookup[p];\r\n\r\n          if (pt) {\r\n            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\r\n              _removeLinkedListItem(this, pt, \"_pt\");\r\n            }\r\n\r\n            delete curLookup[p];\r\n          }\r\n\r\n          if (curOverwriteProps !== \"all\") {\r\n            curOverwriteProps[p] = 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\r\n\r\n    return this;\r\n  };\r\n\r\n  Tween.to = function to(targets, vars) {\r\n    return new Tween(targets, vars, arguments[2]);\r\n  };\r\n\r\n  Tween.from = function from(targets, vars) {\r\n    return _createTweenType(1, arguments);\r\n  };\r\n\r\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\r\n    return new Tween(callback, 0, {\r\n      immediateRender: false,\r\n      lazy: false,\r\n      overwrite: false,\r\n      delay: delay,\r\n      onComplete: callback,\r\n      onReverseComplete: callback,\r\n      onCompleteParams: params,\r\n      onReverseCompleteParams: params,\r\n      callbackScope: scope\r\n    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\r\n  };\r\n\r\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\r\n    return _createTweenType(2, arguments);\r\n  };\r\n\r\n  Tween.set = function set(targets, vars) {\r\n    vars.duration = 0;\r\n    vars.repeatDelay || (vars.repeat = 0);\r\n    return new Tween(targets, vars);\r\n  };\r\n\r\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\r\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\r\n  };\r\n\r\n  return Tween;\r\n}(Animation);\r\n\r\n_setDefaults(Tween.prototype, {\r\n  _targets: [],\r\n  _lazy: 0,\r\n  _startAt: 0,\r\n  _op: 0,\r\n  _onInit: 0\r\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\r\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\r\n// \tTween.prototype[name] = function() {\r\n// \t\tlet tl = new Timeline();\r\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\r\n// \t}\r\n// });\r\n//for backward compatibility. Leverage the timeline calls.\r\n\r\n\r\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function (name) {\r\n  Tween[name] = function () {\r\n    var tl = new Timeline(),\r\n        params = _slice.call(arguments, 0);\r\n\r\n    params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\r\n    return tl[name].apply(tl, params);\r\n  };\r\n});\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * PROPTWEEN\r\n * --------------------------------------------------------------------------------------\r\n */\r\n\r\n\r\nvar _setterPlain = function _setterPlain(target, property, value) {\r\n  return target[property] = value;\r\n},\r\n    _setterFunc = function _setterFunc(target, property, value) {\r\n  return target[property](value);\r\n},\r\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\r\n  return target[property](data.fp, value);\r\n},\r\n    _setterAttribute = function _setterAttribute(target, property, value) {\r\n  return target.setAttribute(property, value);\r\n},\r\n    _getSetter = function _getSetter(target, property) {\r\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\r\n},\r\n    _renderPlain = function _renderPlain(ratio, data) {\r\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\r\n},\r\n    _renderBoolean = function _renderBoolean(ratio, data) {\r\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\r\n},\r\n    _renderComplexString = function _renderComplexString(ratio, data) {\r\n  var pt = data._pt,\r\n      s = \"\";\r\n\r\n  if (!ratio && data.b) {\r\n    //b = beginning string\r\n    s = data.b;\r\n  } else if (ratio === 1 && data.e) {\r\n    //e = ending string\r\n    s = data.e;\r\n  } else {\r\n    while (pt) {\r\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\r\n\r\n      pt = pt._next;\r\n    }\r\n\r\n    s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\r\n  }\r\n\r\n  data.set(data.t, data.p, s, data);\r\n},\r\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\r\n  var pt = data._pt;\r\n\r\n  while (pt) {\r\n    pt.r(ratio, pt.d);\r\n    pt = pt._next;\r\n  }\r\n},\r\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\r\n  var pt = this._pt,\r\n      next;\r\n\r\n  while (pt) {\r\n    next = pt._next;\r\n    pt.p === property && pt.modifier(modifier, tween, target);\r\n    pt = next;\r\n  }\r\n},\r\n    _killPropTweensOf = function _killPropTweensOf(property) {\r\n  var pt = this._pt,\r\n      hasNonDependentRemaining,\r\n      next;\r\n\r\n  while (pt) {\r\n    next = pt._next;\r\n\r\n    if (pt.p === property && !pt.op || pt.op === property) {\r\n      _removeLinkedListItem(this, pt, \"_pt\");\r\n    } else if (!pt.dep) {\r\n      hasNonDependentRemaining = 1;\r\n    }\r\n\r\n    pt = next;\r\n  }\r\n\r\n  return !hasNonDependentRemaining;\r\n},\r\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\r\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\r\n},\r\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\r\n  var pt = parent._pt,\r\n      next,\r\n      pt2,\r\n      first,\r\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\r\n\r\n  while (pt) {\r\n    next = pt._next;\r\n    pt2 = first;\r\n\r\n    while (pt2 && pt2.pr > pt.pr) {\r\n      pt2 = pt2._next;\r\n    }\r\n\r\n    if (pt._prev = pt2 ? pt2._prev : last) {\r\n      pt._prev._next = pt;\r\n    } else {\r\n      first = pt;\r\n    }\r\n\r\n    if (pt._next = pt2) {\r\n      pt2._prev = pt;\r\n    } else {\r\n      last = pt;\r\n    }\r\n\r\n    pt = next;\r\n  }\r\n\r\n  parent._pt = first;\r\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\r\n\r\n\r\nvar PropTween = /*#__PURE__*/function () {\r\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\r\n    this.t = target;\r\n    this.s = start;\r\n    this.c = change;\r\n    this.p = prop;\r\n    this.r = renderer || _renderPlain;\r\n    this.d = data || this;\r\n    this.set = setter || _setterPlain;\r\n    this.pr = priority || 0;\r\n    this._next = next;\r\n\r\n    if (next) {\r\n      next._prev = this;\r\n    }\r\n  }\r\n\r\n  var _proto4 = PropTween.prototype;\r\n\r\n  _proto4.modifier = function modifier(func, tween, target) {\r\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\r\n\r\n    this.set = _setterWithModifier;\r\n    this.m = func;\r\n    this.mt = target; //modifier target\r\n\r\n    this.tween = tween;\r\n  };\r\n\r\n  return PropTween;\r\n}(); //Initialization tasks\r\n\r\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function (name) {\r\n  return _reservedProps[name] = 1;\r\n});\r\n\r\n_globals.TweenMax = _globals.TweenLite = Tween;\r\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\r\n_globalTimeline = new Timeline({\r\n  sortChildren: false,\r\n  defaults: _defaults,\r\n  autoRemoveChildren: true,\r\n  id: \"root\",\r\n  smoothChildTiming: true\r\n});\r\n_config.stringFilter = _colorStringFilter;\r\n\r\nvar _media = [],\r\n    _listeners = {},\r\n    _emptyArray = [],\r\n    _lastMediaTime = 0,\r\n    _contextID = 0,\r\n    _dispatch = function _dispatch(type) {\r\n  return (_listeners[type] || _emptyArray).map(function (f) {\r\n    return f();\r\n  });\r\n},\r\n    _onMediaChange = function _onMediaChange() {\r\n  var time = Date.now(),\r\n      matches = [];\r\n\r\n  if (time - _lastMediaTime > 2) {\r\n    _dispatch(\"matchMediaInit\");\r\n\r\n    _media.forEach(function (c) {\r\n      var queries = c.queries,\r\n          conditions = c.conditions,\r\n          match,\r\n          p,\r\n          anyMatch,\r\n          toggled;\r\n\r\n      for (p in queries) {\r\n        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\r\n\r\n        match && (anyMatch = 1);\r\n\r\n        if (match !== conditions[p]) {\r\n          conditions[p] = match;\r\n          toggled = 1;\r\n        }\r\n      }\r\n\r\n      if (toggled) {\r\n        c.revert();\r\n        anyMatch && matches.push(c);\r\n      }\r\n    });\r\n\r\n    _dispatch(\"matchMediaRevert\");\r\n\r\n    matches.forEach(function (c) {\r\n      return c.onMatch(c, function (func) {\r\n        return c.add(null, func);\r\n      });\r\n    });\r\n    _lastMediaTime = time;\r\n\r\n    _dispatch(\"matchMedia\");\r\n  }\r\n};\r\n\r\nvar Context = /*#__PURE__*/function () {\r\n  function Context(func, scope) {\r\n    this.selector = scope && selector(scope);\r\n    this.data = [];\r\n    this._r = []; // returned/cleanup functions\r\n\r\n    this.isReverted = false;\r\n    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\r\n\r\n    func && this.add(func);\r\n  }\r\n\r\n  var _proto5 = Context.prototype;\r\n\r\n  _proto5.add = function add(name, func, scope) {\r\n    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\r\n    // if (name && _isFunction(name.revert)) {\r\n    // \tthis.data.push(name);\r\n    // \treturn (name._ctx = this);\r\n    // }\r\n    if (_isFunction(name)) {\r\n      scope = func;\r\n      func = name;\r\n      name = _isFunction;\r\n    }\r\n\r\n    var self = this,\r\n        f = function f() {\r\n      var prev = _context,\r\n          prevSelector = self.selector,\r\n          result;\r\n      prev && prev !== self && prev.data.push(self);\r\n      scope && (self.selector = selector(scope));\r\n      _context = self;\r\n      result = func.apply(self, arguments);\r\n      _isFunction(result) && self._r.push(result);\r\n      _context = prev;\r\n      self.selector = prevSelector;\r\n      self.isReverted = false;\r\n      return result;\r\n    };\r\n\r\n    self.last = f;\r\n    return name === _isFunction ? f(self, function (func) {\r\n      return self.add(null, func);\r\n    }) : name ? self[name] = f : f;\r\n  };\r\n\r\n  _proto5.ignore = function ignore(func) {\r\n    var prev = _context;\r\n    _context = null;\r\n    func(this);\r\n    _context = prev;\r\n  };\r\n\r\n  _proto5.getTweens = function getTweens() {\r\n    var a = [];\r\n    this.data.forEach(function (e) {\r\n      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\r\n    });\r\n    return a;\r\n  };\r\n\r\n  _proto5.clear = function clear() {\r\n    this._r.length = this.data.length = 0;\r\n  };\r\n\r\n  _proto5.kill = function kill(revert, matchMedia) {\r\n    var _this4 = this;\r\n\r\n    if (revert) {\r\n      (function () {\r\n        var tweens = _this4.getTweens(),\r\n            i = _this4.data.length,\r\n            t;\r\n\r\n        while (i--) {\r\n          // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\r\n          t = _this4.data[i];\r\n\r\n          if (t.data === \"isFlip\") {\r\n            t.revert();\r\n            t.getChildren(true, true, false).forEach(function (tween) {\r\n              return tweens.splice(tweens.indexOf(tween), 1);\r\n            });\r\n          }\r\n        } // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\r\n\r\n\r\n        tweens.map(function (t) {\r\n          return {\r\n            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\r\n            t: t\r\n          };\r\n        }).sort(function (a, b) {\r\n          return b.g - a.g || -Infinity;\r\n        }).forEach(function (o) {\r\n          return o.t.revert(revert);\r\n        }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\r\n\r\n        i = _this4.data.length;\r\n\r\n        while (i--) {\r\n          // make sure we loop backwards so that, for example, SplitTexts that were created later on the same element get reverted first\r\n          t = _this4.data[i];\r\n\r\n          if (t instanceof Timeline) {\r\n            if (t.data !== \"nested\") {\r\n              t.scrollTrigger && t.scrollTrigger.revert();\r\n              t.kill(); // don't revert() the timeline because that's duplicating efforts since we already reverted all the tweens\r\n            }\r\n          } else {\r\n            !(t instanceof Tween) && t.revert && t.revert(revert);\r\n          }\r\n        }\r\n\r\n        _this4._r.forEach(function (f) {\r\n          return f(revert, _this4);\r\n        });\r\n\r\n        _this4.isReverted = true;\r\n      })();\r\n    } else {\r\n      this.data.forEach(function (e) {\r\n        return e.kill && e.kill();\r\n      });\r\n    }\r\n\r\n    this.clear();\r\n\r\n    if (matchMedia) {\r\n      var i = _media.length;\r\n\r\n      while (i--) {\r\n        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\r\n        _media[i].id === this.id && _media.splice(i, 1);\r\n      }\r\n    }\r\n  } // killWithCleanup() {\r\n  // \tthis.kill();\r\n  // \tthis._r.forEach(f => f(false, this));\r\n  // }\r\n  ;\r\n\r\n  _proto5.revert = function revert(config) {\r\n    this.kill(config || {});\r\n  };\r\n\r\n  return Context;\r\n}();\r\n\r\nvar MatchMedia = /*#__PURE__*/function () {\r\n  function MatchMedia(scope) {\r\n    this.contexts = [];\r\n    this.scope = scope;\r\n    _context && _context.data.push(this);\r\n  }\r\n\r\n  var _proto6 = MatchMedia.prototype;\r\n\r\n  _proto6.add = function add(conditions, func, scope) {\r\n    _isObject(conditions) || (conditions = {\r\n      matches: conditions\r\n    });\r\n    var context = new Context(0, scope || this.scope),\r\n        cond = context.conditions = {},\r\n        mq,\r\n        p,\r\n        active;\r\n    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\r\n\r\n    this.contexts.push(context);\r\n    func = context.add(\"onMatch\", func);\r\n    context.queries = conditions;\r\n\r\n    for (p in conditions) {\r\n      if (p === \"all\") {\r\n        active = 1;\r\n      } else {\r\n        mq = _win.matchMedia(conditions[p]);\r\n\r\n        if (mq) {\r\n          _media.indexOf(context) < 0 && _media.push(context);\r\n          (cond[p] = mq.matches) && (active = 1);\r\n          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\r\n        }\r\n      }\r\n    }\r\n\r\n    active && func(context, function (f) {\r\n      return context.add(null, f);\r\n    });\r\n    return this;\r\n  } // refresh() {\r\n  // \tlet time = _lastMediaTime,\r\n  // \t\tmedia = _media;\r\n  // \t_lastMediaTime = -1;\r\n  // \t_media = this.contexts;\r\n  // \t_onMediaChange();\r\n  // \t_lastMediaTime = time;\r\n  // \t_media = media;\r\n  // }\r\n  ;\r\n\r\n  _proto6.revert = function revert(config) {\r\n    this.kill(config || {});\r\n  };\r\n\r\n  _proto6.kill = function kill(revert) {\r\n    this.contexts.forEach(function (c) {\r\n      return c.kill(revert, true);\r\n    });\r\n  };\r\n\r\n  return MatchMedia;\r\n}();\r\n/*\r\n * --------------------------------------------------------------------------------------\r\n * GSAP\r\n * --------------------------------------------------------------------------------------\r\n */\r\n\r\n\r\nvar _gsap = {\r\n  registerPlugin: function registerPlugin() {\r\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n      args[_key2] = arguments[_key2];\r\n    }\r\n\r\n    args.forEach(function (config) {\r\n      return _createPlugin(config);\r\n    });\r\n  },\r\n  timeline: function timeline(vars) {\r\n    return new Timeline(vars);\r\n  },\r\n  getTweensOf: function getTweensOf(targets, onlyActive) {\r\n    return _globalTimeline.getTweensOf(targets, onlyActive);\r\n  },\r\n  getProperty: function getProperty(target, property, unit, uncache) {\r\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\r\n\r\n    var getter = _getCache(target || {}).get,\r\n        format = unit ? _passThrough : _numericIfPossible;\r\n\r\n    unit === \"native\" && (unit = \"\");\r\n    return !target ? target : !property ? function (property, unit, uncache) {\r\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\r\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\r\n  },\r\n  quickSetter: function quickSetter(target, property, unit) {\r\n    target = toArray(target);\r\n\r\n    if (target.length > 1) {\r\n      var setters = target.map(function (t) {\r\n        return gsap.quickSetter(t, property, unit);\r\n      }),\r\n          l = setters.length;\r\n      return function (value) {\r\n        var i = l;\r\n\r\n        while (i--) {\r\n          setters[i](value);\r\n        }\r\n      };\r\n    }\r\n\r\n    target = target[0] || {};\r\n\r\n    var Plugin = _plugins[property],\r\n        cache = _getCache(target),\r\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\r\n        // in case it's an alias, like \"rotate\" for \"rotation\".\r\n    setter = Plugin ? function (value) {\r\n      var p = new Plugin();\r\n      _quickTween._pt = 0;\r\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\r\n      p.render(1, p);\r\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\r\n    } : cache.set(target, p);\r\n\r\n    return Plugin ? setter : function (value) {\r\n      return setter(target, p, unit ? value + unit : value, cache, 1);\r\n    };\r\n  },\r\n  quickTo: function quickTo(target, property, vars) {\r\n    var _setDefaults2;\r\n\r\n    var tween = gsap.to(target, _setDefaults((_setDefaults2 = {}, _setDefaults2[property] = \"+=0.1\", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})),\r\n        func = function func(value, start, startIsRelative) {\r\n      return tween.resetTo(property, value, start, startIsRelative);\r\n    };\r\n\r\n    func.tween = tween;\r\n    return func;\r\n  },\r\n  isTweening: function isTweening(targets) {\r\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\r\n  },\r\n  defaults: function defaults(value) {\r\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\r\n    return _mergeDeep(_defaults, value || {});\r\n  },\r\n  config: function config(value) {\r\n    return _mergeDeep(_config, value || {});\r\n  },\r\n  registerEffect: function registerEffect(_ref3) {\r\n    var name = _ref3.name,\r\n        effect = _ref3.effect,\r\n        plugins = _ref3.plugins,\r\n        defaults = _ref3.defaults,\r\n        extendTimeline = _ref3.extendTimeline;\r\n    (plugins || \"\").split(\",\").forEach(function (pluginName) {\r\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\r\n    });\r\n\r\n    _effects[name] = function (targets, vars, tl) {\r\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\r\n    };\r\n\r\n    if (extendTimeline) {\r\n      Timeline.prototype[name] = function (targets, vars, position) {\r\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\r\n      };\r\n    }\r\n  },\r\n  registerEase: function registerEase(name, ease) {\r\n    _easeMap[name] = _parseEase(ease);\r\n  },\r\n  parseEase: function parseEase(ease, defaultEase) {\r\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\r\n  },\r\n  getById: function getById(id) {\r\n    return _globalTimeline.getById(id);\r\n  },\r\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\r\n    if (vars === void 0) {\r\n      vars = {};\r\n    }\r\n\r\n    var tl = new Timeline(vars),\r\n        child,\r\n        next;\r\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\r\n\r\n    _globalTimeline.remove(tl);\r\n\r\n    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\r\n\r\n    tl._time = tl._tTime = _globalTimeline._time;\r\n    child = _globalTimeline._first;\r\n\r\n    while (child) {\r\n      next = child._next;\r\n\r\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\r\n        _addToTimeline(tl, child, child._start - child._delay);\r\n      }\r\n\r\n      child = next;\r\n    }\r\n\r\n    _addToTimeline(_globalTimeline, tl, 0);\r\n\r\n    return tl;\r\n  },\r\n  context: function context(func, scope) {\r\n    return func ? new Context(func, scope) : _context;\r\n  },\r\n  matchMedia: function matchMedia(scope) {\r\n    return new MatchMedia(scope);\r\n  },\r\n  matchMediaRefresh: function matchMediaRefresh() {\r\n    return _media.forEach(function (c) {\r\n      var cond = c.conditions,\r\n          found,\r\n          p;\r\n\r\n      for (p in cond) {\r\n        if (cond[p]) {\r\n          cond[p] = false;\r\n          found = 1;\r\n        }\r\n      }\r\n\r\n      found && c.revert();\r\n    }) || _onMediaChange();\r\n  },\r\n  addEventListener: function addEventListener(type, callback) {\r\n    var a = _listeners[type] || (_listeners[type] = []);\r\n    ~a.indexOf(callback) || a.push(callback);\r\n  },\r\n  removeEventListener: function removeEventListener(type, callback) {\r\n    var a = _listeners[type],\r\n        i = a && a.indexOf(callback);\r\n    i >= 0 && a.splice(i, 1);\r\n  },\r\n  utils: {\r\n    wrap: wrap,\r\n    wrapYoyo: wrapYoyo,\r\n    distribute: distribute,\r\n    random: random,\r\n    snap: snap,\r\n    normalize: normalize,\r\n    getUnit: getUnit,\r\n    clamp: clamp,\r\n    splitColor: splitColor,\r\n    toArray: toArray,\r\n    selector: selector,\r\n    mapRange: mapRange,\r\n    pipe: pipe,\r\n    unitize: unitize,\r\n    interpolate: interpolate,\r\n    shuffle: shuffle\r\n  },\r\n  install: _install,\r\n  effects: _effects,\r\n  ticker: _ticker,\r\n  updateRoot: Timeline.updateRoot,\r\n  plugins: _plugins,\r\n  globalTimeline: _globalTimeline,\r\n  core: {\r\n    PropTween: PropTween,\r\n    globals: _addGlobal,\r\n    Tween: Tween,\r\n    Timeline: Timeline,\r\n    Animation: Animation,\r\n    getCache: _getCache,\r\n    _removeLinkedListItem: _removeLinkedListItem,\r\n    reverting: function reverting() {\r\n      return _reverting;\r\n    },\r\n    context: function context(toAdd) {\r\n      if (toAdd && _context) {\r\n        _context.data.push(toAdd);\r\n\r\n        toAdd._ctx = _context;\r\n      }\r\n\r\n      return _context;\r\n    },\r\n    suppressOverwrites: function suppressOverwrites(value) {\r\n      return _suppressOverwrites = value;\r\n    }\r\n  }\r\n};\r\n\r\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function (name) {\r\n  return _gsap[name] = Tween[name];\r\n});\r\n\r\n_ticker.add(Timeline.updateRoot);\r\n\r\n_quickTween = _gsap.to({}, {\r\n  duration: 0\r\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\r\n\r\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\r\n  var pt = plugin._pt;\r\n\r\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\r\n    pt = pt._next;\r\n  }\r\n\r\n  return pt;\r\n},\r\n    _addModifiers = function _addModifiers(tween, modifiers) {\r\n  var targets = tween._targets,\r\n      p,\r\n      i,\r\n      pt;\r\n\r\n  for (p in modifiers) {\r\n    i = targets.length;\r\n\r\n    while (i--) {\r\n      pt = tween._ptLookup[i][p];\r\n\r\n      if (pt && (pt = pt.d)) {\r\n        if (pt._pt) {\r\n          // is a plugin\r\n          pt = _getPluginPropTween(pt, p);\r\n        }\r\n\r\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\r\n      }\r\n    }\r\n  }\r\n},\r\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\r\n  return {\r\n    name: name,\r\n    headless: 1,\r\n    rawVars: 1,\r\n    //don't pre-process function-based values or \"random()\" strings.\r\n    init: function init(target, vars, tween) {\r\n      tween._onInit = function (tween) {\r\n        var temp, p;\r\n\r\n        if (_isString(vars)) {\r\n          temp = {};\r\n\r\n          _forEachName(vars, function (name) {\r\n            return temp[name] = 1;\r\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\r\n\r\n\r\n          vars = temp;\r\n        }\r\n\r\n        if (modifier) {\r\n          temp = {};\r\n\r\n          for (p in vars) {\r\n            temp[p] = modifier(vars[p]);\r\n          }\r\n\r\n          vars = temp;\r\n        }\r\n\r\n        _addModifiers(tween, vars);\r\n      };\r\n    }\r\n  };\r\n}; //register core plugins\r\n\r\n\r\nvar gsap = _gsap.registerPlugin({\r\n  name: \"attr\",\r\n  init: function init(target, vars, tween, index, targets) {\r\n    var p, pt, v;\r\n    this.tween = tween;\r\n\r\n    for (p in vars) {\r\n      v = target.getAttribute(p) || \"\";\r\n      pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\r\n      pt.op = p;\r\n      pt.b = v; // record the beginning value so we can revert()\r\n\r\n      this._props.push(p);\r\n    }\r\n  },\r\n  render: function render(ratio, data) {\r\n    var pt = data._pt;\r\n\r\n    while (pt) {\r\n      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\r\n\r\n      pt = pt._next;\r\n    }\r\n  }\r\n}, {\r\n  name: \"endArray\",\r\n  headless: 1,\r\n  init: function init(target, value) {\r\n    var i = value.length;\r\n\r\n    while (i--) {\r\n      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\r\n    }\r\n  }\r\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\r\n\r\nTween.version = Timeline.version = gsap.version = \"3.13.0\";\r\n_coreReady = 1;\r\n_windowExists() && _wake();\r\nvar Power0 = _easeMap.Power0,\r\n    Power1 = _easeMap.Power1,\r\n    Power2 = _easeMap.Power2,\r\n    Power3 = _easeMap.Power3,\r\n    Power4 = _easeMap.Power4,\r\n    Linear = _easeMap.Linear,\r\n    Quad = _easeMap.Quad,\r\n    Cubic = _easeMap.Cubic,\r\n    Quart = _easeMap.Quart,\r\n    Quint = _easeMap.Quint,\r\n    Strong = _easeMap.Strong,\r\n    Elastic = _easeMap.Elastic,\r\n    Back = _easeMap.Back,\r\n    SteppedEase = _easeMap.SteppedEase,\r\n    Bounce = _easeMap.Bounce,\r\n    Sine = _easeMap.Sine,\r\n    Expo = _easeMap.Expo,\r\n    Circ = _easeMap.Circ;\r\n\r\n //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3NhcC9nc2FwLWNvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsd0NBQXdDLHVCQUF1Qix5RkFBeUY7QUFDeEo7QUFDQSxnREFBZ0QsMERBQTBELDJDQUEyQztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtKQUErSjtBQUMvSjtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJDQUEyQztBQUNwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwySUFBMkk7QUFDM0k7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3TUFBd007QUFDeE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRyxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxrQ0FBa0M7QUFDbEMsUUFBUTtBQUNSO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrTUFBK007QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFxRCw2TkFBNk4sT0FBTyxXQUFXLEtBQUs7QUFDL1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1UEFBdVA7QUFDdlA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0STtBQUM1STtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHlFQUF5RSxJQUFJO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4S0FBOEssSUFBSTtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVMsR0FBRztBQUNa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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUlBQXVJO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21KO0FBQ3FILENBQUM7QUFDelEiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3NhcFxcZ3NhcC1jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxyXG5cclxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XHJcblxyXG4vKiFcclxuICogR1NBUCAzLjEzLjBcclxuICogaHR0cHM6Ly9nc2FwLmNvbVxyXG4gKlxyXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZVxyXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cclxuKi9cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlICovXHJcbnZhciBfY29uZmlnID0ge1xyXG4gIGF1dG9TbGVlcDogMTIwLFxyXG4gIGZvcmNlM0Q6IFwiYXV0b1wiLFxyXG4gIG51bGxUYXJnZXRXYXJuOiAxLFxyXG4gIHVuaXRzOiB7XHJcbiAgICBsaW5lSGVpZ2h0OiBcIlwiXHJcbiAgfVxyXG59LFxyXG4gICAgX2RlZmF1bHRzID0ge1xyXG4gIGR1cmF0aW9uOiAuNSxcclxuICBvdmVyd3JpdGU6IGZhbHNlLFxyXG4gIGRlbGF5OiAwXHJcbn0sXHJcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxyXG4gICAgX3JldmVydGluZyxcclxuICAgIF9jb250ZXh0LFxyXG4gICAgX2JpZ051bSA9IDFlOCxcclxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXHJcbiAgICBfMlBJID0gTWF0aC5QSSAqIDIsXHJcbiAgICBfSEFMRl9QSSA9IF8yUEkgLyA0LFxyXG4gICAgX2dzSUQgPSAwLFxyXG4gICAgX3NxcnQgPSBNYXRoLnNxcnQsXHJcbiAgICBfY29zID0gTWF0aC5jb3MsXHJcbiAgICBfc2luID0gTWF0aC5zaW4sXHJcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG59LFxyXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcclxufSxcclxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbn0sXHJcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xyXG59LFxyXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcclxufSxcclxuICAgIF9pc05vdEZhbHNlID0gZnVuY3Rpb24gX2lzTm90RmFsc2UodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xyXG59LFxyXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XHJcbn0sXHJcbiAgICBfaXNGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfaXNGdW5jT3JTdHJpbmcodmFsdWUpIHtcclxuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpIHx8IF9pc1N0cmluZyh2YWx1ZSk7XHJcbn0sXHJcbiAgICBfaXNUeXBlZEFycmF5ID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uICgpIHt9LFxyXG4gICAgLy8gbm90ZTogSUUxMCBoYXMgQXJyYXlCdWZmZXIsIGJ1dCBOT1QgQXJyYXlCdWZmZXIuaXNWaWV3KCkuXHJcbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcclxuICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxyXG4gICAgLy9vbmx5IG51bWJlcnMgKGluY2x1ZGluZyBuZWdhdGl2ZXMgYW5kIGRlY2ltYWxzKSBidXQgTk9UIHJlbGF0aXZlIHZhbHVlcy5cclxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcclxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXHJcbl9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXHJcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcclxuICAgIC8vZHVwbGljYXRlIHNvIHRoYXQgd2hpbGUgd2UncmUgbG9vcGluZyB0aHJvdWdoIG1hdGNoZXMgZnJvbSBleGVjKCksIGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGxhc3RJbmRleCBvZiBfbnVtRXhwIHdoaWNoIHdlIHVzZSB0byBzZWFyY2ggZm9yIGNvbG9ycyB0b28uXHJcbl9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxyXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxyXG4gICAgLy8gcHJldmlvdXNseSAvWyNcXC0rLl0qXFxiW2EtelxcZFxcLT0rJS5dKy9naSBidXQgZGlkbid0IGNhdGNoIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuX3VuaXRFeHAgPSAvXlsrXFwtPWVcXHNcXGRdKlxcZCtbLlxcZF0qKFthLXpdKnwlKVxccyokL2ksXHJcbiAgICBfZ2xvYmFsVGltZWxpbmUsXHJcbiAgICBfd2luLFxyXG4gICAgX2NvcmVJbml0dGVkLFxyXG4gICAgX2RvYyxcclxuICAgIF9nbG9iYWxzID0ge30sXHJcbiAgICBfaW5zdGFsbFNjb3BlID0ge30sXHJcbiAgICBfY29yZVJlYWR5LFxyXG4gICAgX2luc3RhbGwgPSBmdW5jdGlvbiBfaW5zdGFsbChzY29wZSkge1xyXG4gIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xyXG59LFxyXG4gICAgX21pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiBfbWlzc2luZ1BsdWdpbihwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcclxufSxcclxuICAgIF93YXJuID0gZnVuY3Rpb24gX3dhcm4obWVzc2FnZSwgc3VwcHJlc3MpIHtcclxuICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxufSxcclxuICAgIF9hZGRHbG9iYWwgPSBmdW5jdGlvbiBfYWRkR2xvYmFsKG5hbWUsIG9iaikge1xyXG4gIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XHJcbn0sXHJcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcclxuICByZXR1cm4gMDtcclxufSxcclxuICAgIF9zdGFydEF0UmV2ZXJ0Q29uZmlnID0ge1xyXG4gIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxyXG4gIGlzU3RhcnQ6IHRydWUsXHJcbiAga2lsbDogZmFsc2VcclxufSxcclxuICAgIF9yZXZlcnRDb25maWdOb0tpbGwgPSB7XHJcbiAgc3VwcHJlc3NFdmVudHM6IHRydWUsXHJcbiAga2lsbDogZmFsc2VcclxufSxcclxuICAgIF9yZXZlcnRDb25maWcgPSB7XHJcbiAgc3VwcHJlc3NFdmVudHM6IHRydWVcclxufSxcclxuICAgIF9yZXNlcnZlZFByb3BzID0ge30sXHJcbiAgICBfbGF6eVR3ZWVucyA9IFtdLFxyXG4gICAgX2xhenlMb29rdXAgPSB7fSxcclxuICAgIF9sYXN0UmVuZGVyZWRGcmFtZSxcclxuICAgIF9wbHVnaW5zID0ge30sXHJcbiAgICBfZWZmZWN0cyA9IHt9LFxyXG4gICAgX25leHRHQ0ZyYW1lID0gMzAsXHJcbiAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcclxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcclxuICAgIF9oYXJuZXNzID0gZnVuY3Rpb24gX2hhcm5lc3ModGFyZ2V0cykge1xyXG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxyXG4gICAgICBoYXJuZXNzUGx1Z2luLFxyXG4gICAgICBpO1xyXG4gIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xyXG5cclxuICBpZiAoIShoYXJuZXNzUGx1Z2luID0gKHRhcmdldC5fZ3NhcCB8fCB7fSkuaGFybmVzcykpIHtcclxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRhcmdldCB3aXRoIGEgaGFybmVzcy4gV2UgYXNzdW1lIHRhcmdldHMgcGFzc2VkIGludG8gYW4gYW5pbWF0aW9uIHdpbGwgYmUgb2Ygc2ltaWxhciB0eXBlLCBtZWFuaW5nIHRoZSBzYW1lIGtpbmQgb2YgaGFybmVzcyBjYW4gYmUgdXNlZCBmb3IgdGhlbSBhbGwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcclxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHt9XHJcblxyXG4gICAgaGFybmVzc1BsdWdpbiA9IF9oYXJuZXNzUGx1Z2luc1tpXTtcclxuICB9XHJcblxyXG4gIGkgPSB0YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgdGFyZ2V0c1tpXSAmJiAodGFyZ2V0c1tpXS5fZ3NhcCB8fCAodGFyZ2V0c1tpXS5fZ3NhcCA9IG5ldyBHU0NhY2hlKHRhcmdldHNbaV0sIGhhcm5lc3NQbHVnaW4pKSkgfHwgdGFyZ2V0cy5zcGxpY2UoaSwgMSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGFyZ2V0cztcclxufSxcclxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcclxuICByZXR1cm4gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRvQXJyYXkodGFyZ2V0KSlbMF0uX2dzYXA7XHJcbn0sXHJcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xyXG4gIHJldHVybiAodiA9IHRhcmdldFtwcm9wZXJ0eV0pICYmIF9pc0Z1bmN0aW9uKHYpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgdjtcclxufSxcclxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xyXG4gIHJldHVybiAobmFtZXMgPSBuYW1lcy5zcGxpdChcIixcIikpLmZvckVhY2goZnVuYykgfHwgbmFtZXM7XHJcbn0sXHJcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXHJcbl9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xyXG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xyXG59LFxyXG4gICAgX3JvdW5kUHJlY2lzZSA9IGZ1bmN0aW9uIF9yb3VuZFByZWNpc2UodmFsdWUpIHtcclxuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMDAwKSAvIDEwMDAwMDAwIHx8IDA7XHJcbn0sXHJcbiAgICAvLyBpbmNyZWFzZWQgcHJlY2lzaW9uIG1vc3RseSBmb3IgdGltaW5nIHZhbHVlcy5cclxuX3BhcnNlUmVsYXRpdmUgPSBmdW5jdGlvbiBfcGFyc2VSZWxhdGl2ZShzdGFydCwgdmFsdWUpIHtcclxuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXHJcbiAgICAgIGVuZCA9IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKTtcclxuICBzdGFydCA9IHBhcnNlRmxvYXQoc3RhcnQpO1xyXG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcclxufSxcclxuICAgIF9hcnJheUNvbnRhaW5zQW55ID0gZnVuY3Rpb24gX2FycmF5Q29udGFpbnNBbnkodG9TZWFyY2gsIHRvRmluZCkge1xyXG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxyXG4gIHZhciBsID0gdG9GaW5kLmxlbmd0aCxcclxuICAgICAgaSA9IDA7XHJcblxyXG4gIGZvciAoOyB0b1NlYXJjaC5pbmRleE9mKHRvRmluZFtpXSkgPCAwICYmICsraSA8IGw7KSB7fVxyXG5cclxuICByZXR1cm4gaSA8IGw7XHJcbn0sXHJcbiAgICBfbGF6eVJlbmRlciA9IGZ1bmN0aW9uIF9sYXp5UmVuZGVyKCkge1xyXG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxyXG4gICAgICBhID0gX2xhenlUd2VlbnMuc2xpY2UoMCksXHJcbiAgICAgIGksXHJcbiAgICAgIHR3ZWVuO1xyXG5cclxuICBfbGF6eUxvb2t1cCA9IHt9O1xyXG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgIHR3ZWVuID0gYVtpXTtcclxuICAgIHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICYmICh0d2Vlbi5yZW5kZXIodHdlZW4uX2xhenlbMF0sIHR3ZWVuLl9sYXp5WzFdLCB0cnVlKS5fbGF6eSA9IDApO1xyXG4gIH1cclxufSxcclxuICAgIF9pc1JldmVydFdvcnRoeSA9IGZ1bmN0aW9uIF9pc1JldmVydFdvcnRoeShhbmltYXRpb24pIHtcclxuICByZXR1cm4gISEoYW5pbWF0aW9uLl9pbml0dGVkIHx8IGFuaW1hdGlvbi5fc3RhcnRBdCB8fCBhbmltYXRpb24uYWRkKTtcclxufSxcclxuICAgIF9sYXp5U2FmZVJlbmRlciA9IGZ1bmN0aW9uIF9sYXp5U2FmZVJlbmRlcihhbmltYXRpb24sIHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xyXG4gIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiAhX3JldmVydGluZyAmJiBfbGF6eVJlbmRlcigpO1xyXG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8ICEhKF9yZXZlcnRpbmcgJiYgdGltZSA8IDAgJiYgX2lzUmV2ZXJ0V29ydGh5KGFuaW1hdGlvbikpKTtcclxuICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgIV9yZXZlcnRpbmcgJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIHNvbWVvbmUgY2FsbHMgc2VlaygpIG9yIHRpbWUoKSBvciBwcm9ncmVzcygpLCB0aGV5IGV4cGVjdCBhbiBpbW1lZGlhdGUgcmVuZGVyLlxyXG59LFxyXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XHJcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICByZXR1cm4gKG4gfHwgbiA9PT0gMCkgJiYgKHZhbHVlICsgXCJcIikubWF0Y2goX2RlbGltaXRlZFZhbHVlRXhwKS5sZW5ndGggPCAyID8gbiA6IF9pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcclxufSxcclxuICAgIF9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIF9wYXNzVGhyb3VnaChwKSB7XHJcbiAgcmV0dXJuIHA7XHJcbn0sXHJcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xyXG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcclxuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqO1xyXG59LFxyXG4gICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhleGNsdWRlRHVyYXRpb24pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgcCBpbiBvYmogfHwgcCA9PT0gXCJkdXJhdGlvblwiICYmIGV4Y2x1ZGVEdXJhdGlvbiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn0sXHJcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xyXG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xyXG4gICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYmFzZTtcclxufSxcclxuICAgIF9tZXJnZURlZXAgPSBmdW5jdGlvbiBfbWVyZ2VEZWVwKGJhc2UsIHRvTWVyZ2UpIHtcclxuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcclxuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYmFzZTtcclxufSxcclxuICAgIF9jb3B5RXhjbHVkaW5nID0gZnVuY3Rpb24gX2NvcHlFeGNsdWRpbmcob2JqLCBleGNsdWRpbmcpIHtcclxuICB2YXIgY29weSA9IHt9LFxyXG4gICAgICBwO1xyXG5cclxuICBmb3IgKHAgaW4gb2JqKSB7XHJcbiAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29weTtcclxufSxcclxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcclxuICB2YXIgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxyXG4gICAgICBmdW5jID0gdmFycy5rZXlmcmFtZXMgPyBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhfaXNBcnJheSh2YXJzLmtleWZyYW1lcykpIDogX3NldERlZmF1bHRzO1xyXG5cclxuICBpZiAoX2lzTm90RmFsc2UodmFycy5pbmhlcml0KSkge1xyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcclxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCB8fCBwYXJlbnQuX2RwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZhcnM7XHJcbn0sXHJcbiAgICBfYXJyYXlzTWF0Y2ggPSBmdW5jdGlvbiBfYXJyYXlzTWF0Y2goYTEsIGEyKSB7XHJcbiAgdmFyIGkgPSBhMS5sZW5ndGgsXHJcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xyXG5cclxuICB3aGlsZSAobWF0Y2ggJiYgaS0tICYmIGExW2ldID09PSBhMltpXSkge31cclxuXHJcbiAgcmV0dXJuIGkgPCAwO1xyXG59LFxyXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xyXG4gIGlmIChmaXJzdFByb3AgPT09IHZvaWQgMCkge1xyXG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcclxuICB9XHJcblxyXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcclxuICB9XHJcblxyXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcclxuICAgICAgdDtcclxuXHJcbiAgaWYgKHNvcnRCeSkge1xyXG4gICAgdCA9IGNoaWxkW3NvcnRCeV07XHJcblxyXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xyXG4gICAgICBwcmV2ID0gcHJldi5fcHJldjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChwcmV2KSB7XHJcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XHJcbiAgICBwcmV2Ll9uZXh0ID0gY2hpbGQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XHJcbiAgICBwYXJlbnRbZmlyc3RQcm9wXSA9IGNoaWxkO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoaWxkLl9uZXh0KSB7XHJcbiAgICBjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwYXJlbnRbbGFzdFByb3BdID0gY2hpbGQ7XHJcbiAgfVxyXG5cclxuICBjaGlsZC5fcHJldiA9IHByZXY7XHJcbiAgY2hpbGQucGFyZW50ID0gY2hpbGQuX2RwID0gcGFyZW50O1xyXG4gIHJldHVybiBjaGlsZDtcclxufSxcclxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9yZW1vdmVMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wKSB7XHJcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xyXG4gIH1cclxuXHJcbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcclxuICAgIGxhc3RQcm9wID0gXCJfbGFzdFwiO1xyXG4gIH1cclxuXHJcbiAgdmFyIHByZXYgPSBjaGlsZC5fcHJldixcclxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xyXG5cclxuICBpZiAocHJldikge1xyXG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XHJcbiAgfSBlbHNlIGlmIChwYXJlbnRbZmlyc3RQcm9wXSA9PT0gY2hpbGQpIHtcclxuICAgIHBhcmVudFtmaXJzdFByb3BdID0gbmV4dDtcclxuICB9XHJcblxyXG4gIGlmIChuZXh0KSB7XHJcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcclxuICB9IGVsc2UgaWYgKHBhcmVudFtsYXN0UHJvcF0gPT09IGNoaWxkKSB7XHJcbiAgICBwYXJlbnRbbGFzdFByb3BdID0gcHJldjtcclxuICB9XHJcblxyXG4gIGNoaWxkLl9uZXh0ID0gY2hpbGQuX3ByZXYgPSBjaGlsZC5wYXJlbnQgPSBudWxsOyAvLyBkb24ndCBkZWxldGUgdGhlIF9kcCBqdXN0IHNvIHdlIGNhbiByZXZlcnQgaWYgbmVjZXNzYXJ5LiBCdXQgcGFyZW50IHNob3VsZCBiZSBudWxsIHRvIGluZGljYXRlIHRoZSBpdGVtIGlzbid0IGluIGEgbGlua2VkIGxpc3QuXHJcbn0sXHJcbiAgICBfcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkLCBvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlKSB7XHJcbiAgY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xyXG4gIGNoaWxkLl9hY3QgPSAwO1xyXG59LFxyXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XHJcbiAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xyXG4gICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBpZiBhIGNoaWxkIGFuaW1hdGlvbiBpcyBwYXNzZWQgaW4gd2Ugc2hvdWxkIG9ubHkgdW5jYWNoZSBpZiB0aGF0IGNoaWxkIEVYVEVORFMgdGhlIGFuaW1hdGlvbiAoaXRzIGVuZCB0aW1lIGlzIGJleW9uZCB0aGUgZW5kKVxyXG4gICAgdmFyIGEgPSBhbmltYXRpb247XHJcblxyXG4gICAgd2hpbGUgKGEpIHtcclxuICAgICAgYS5fZGlydHkgPSAxO1xyXG4gICAgICBhID0gYS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYW5pbWF0aW9uO1xyXG59LFxyXG4gICAgX3JlY2FjaGVBbmNlc3RvcnMgPSBmdW5jdGlvbiBfcmVjYWNoZUFuY2VzdG9ycyhhbmltYXRpb24pIHtcclxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLnBhcmVudDtcclxuXHJcbiAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XHJcbiAgICAvL3NvbWV0aW1lcyB3ZSBtdXN0IGZvcmNlIGEgcmUtc29ydCBvZiBhbGwgY2hpbGRyZW4gYW5kIHVwZGF0ZSB0aGUgZHVyYXRpb24vdG90YWxEdXJhdGlvbiBvZiBhbGwgYW5jZXN0b3IgdGltZWxpbmVzIGltbWVkaWF0ZWx5IGluIGNhc2UsIGZvciBleGFtcGxlLCBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyIGxvb3AsIG9uZSB0d2VlbiBhbHRlcnMgYW5vdGhlciB0d2VlbidzIHRpbWVTY2FsZSB3aGljaCBzaG92ZXMgaXRzIHN0YXJ0VGltZSBiZWZvcmUgMCwgZm9yY2luZyB0aGUgcGFyZW50IHRpbWVsaW5lIHRvIHNoaWZ0IGFyb3VuZCBhbmQgc2hpZnRDaGlsZHJlbigpIHdoaWNoIGNvdWxkIGFmZmVjdCB0aGF0IG5leHQgdHdlZW4ncyByZW5kZXIgKHN0YXJ0VGltZSkuIERvZXNuJ3QgbWF0dGVyIGZvciB0aGUgcm9vdCB0aW1lbGluZSB0aG91Z2guXHJcbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcclxuICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFuaW1hdGlvbjtcclxufSxcclxuICAgIF9yZXdpbmRTdGFydEF0ID0gZnVuY3Rpb24gX3Jld2luZFN0YXJ0QXQodHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XHJcbiAgcmV0dXJuIHR3ZWVuLl9zdGFydEF0ICYmIChfcmV2ZXJ0aW5nID8gdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpIDogdHdlZW4udmFycy5pbW1lZGlhdGVSZW5kZXIgJiYgIXR3ZWVuLnZhcnMuYXV0b1JldmVydCB8fCB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCBmb3JjZSkpO1xyXG59LFxyXG4gICAgX2hhc05vUGF1c2VkQW5jZXN0b3JzID0gZnVuY3Rpb24gX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbikge1xyXG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xyXG59LFxyXG4gICAgX2VsYXBzZWRDeWNsZUR1cmF0aW9uID0gZnVuY3Rpb24gX2VsYXBzZWRDeWNsZUR1cmF0aW9uKGFuaW1hdGlvbikge1xyXG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XHJcbn0sXHJcbiAgICAvLyBmZWVkIGluIHRoZSB0b3RhbFRpbWUgYW5kIGN5Y2xlRHVyYXRpb24gYW5kIGl0J2xsIHJldHVybiB0aGUgY3ljbGUgKGl0ZXJhdGlvbiBtaW51cyAxKSBhbmQgaWYgdGhlIHBsYXloZWFkIGlzIGV4YWN0bHkgYXQgdGhlIHZlcnkgRU5ELCBpdCB3aWxsIE5PVCBidW1wIHVwIHRvIHRoZSBuZXh0IGN5Y2xlLlxyXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcclxuICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKHRUaW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAvIGN5Y2xlRHVyYXRpb24pKTtcclxuICByZXR1cm4gdFRpbWUgJiYgd2hvbGUgPT09IHRUaW1lID8gd2hvbGUgLSAxIDogd2hvbGU7XHJcbn0sXHJcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XHJcbiAgcmV0dXJuIChwYXJlbnRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyArIChjaGlsZC5fdHMgPj0gMCA/IDAgOiBjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cik7XHJcbn0sXHJcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcclxuICByZXR1cm4gYW5pbWF0aW9uLl9lbmQgPSBfcm91bmRQcmVjaXNlKGFuaW1hdGlvbi5fc3RhcnQgKyAoYW5pbWF0aW9uLl90RHVyIC8gTWF0aC5hYnMoYW5pbWF0aW9uLl90cyB8fCBhbmltYXRpb24uX3J0cyB8fCBfdGlueU51bSkgfHwgMCkpO1xyXG59LFxyXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xyXG4gIC8vIGFkanVzdHMgdGhlIGFuaW1hdGlvbidzIF9zdGFydCBhbmQgX2VuZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHRvdGFsVGltZSAob25seSBpZiB0aGUgcGFyZW50J3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSBhbmQgdGhlIGFuaW1hdGlvbiBpc24ndCBwYXVzZWQpLiBJdCBkb2Vzbid0IGRvIGFueSByZW5kZXJpbmcgb3IgZm9yY2luZyB0aGluZ3MgYmFjayBpbnRvIHBhcmVudCB0aW1lbGluZXMsIGV0Yy4gLSB0aGF0J3Mgd2hhdCB0b3RhbFRpbWUoKSBpcyBmb3IuXHJcbiAgdmFyIHBhcmVudCA9IGFuaW1hdGlvbi5fZHA7XHJcblxyXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcclxuICAgIGFuaW1hdGlvbi5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xyXG5cclxuICAgIF9zZXRFbmQoYW5pbWF0aW9uKTtcclxuXHJcbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXHJcbiAgfVxyXG5cclxuICByZXR1cm4gYW5pbWF0aW9uO1xyXG59LFxyXG5cclxuLypcclxuX3RvdGFsVGltZVRvVGltZSA9IChjbGFtcGVkVG90YWxUaW1lLCBkdXJhdGlvbiwgcmVwZWF0LCByZXBlYXREZWxheSwgeW95bykgPT4ge1xyXG5cdGxldCBjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyByZXBlYXREZWxheSxcclxuXHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xyXG5cdGlmICh0aW1lID4gZHVyYXRpb24pIHtcclxuXHRcdHRpbWUgPSBkdXJhdGlvbjtcclxuXHR9XHJcblx0cmV0dXJuICh5b3lvICYmICh+fihjbGFtcGVkVG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgJiAxKSkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xyXG59LFxyXG4qL1xyXG5fcG9zdEFkZENoZWNrcyA9IGZ1bmN0aW9uIF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCkge1xyXG4gIHZhciB0O1xyXG5cclxuICBpZiAoY2hpbGQuX3RpbWUgfHwgIWNoaWxkLl9kdXIgJiYgY2hpbGQuX2luaXR0ZWQgfHwgY2hpbGQuX3N0YXJ0IDwgdGltZWxpbmUuX3RpbWUgJiYgKGNoaWxkLl9kdXIgfHwgIWNoaWxkLmFkZCkpIHtcclxuICAgIC8vIGluIGNhc2UsIGZvciBleGFtcGxlLCB0aGUgX3N0YXJ0IGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZCwgb3IgaWYgaXQncyBiZWluZyBpbnNlcnRlZCBpbnRvIGEgdGltZWxpbmUgQkVGT1JFIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuIFNwZWNpYWwgY2FzZTogaWYgaXQncyBhIHRpbWVsaW5lIChoYXMgLmFkZCgpIG1ldGhvZCkgYW5kIG5vIGR1cmF0aW9uLCB3ZSBjYW4gc2tpcCByZW5kZXJpbmcgYmVjYXVzZSB0aGUgdXNlciBtYXkgYmUgcG9wdWxhdGluZyBpdCBBRlRFUiBhZGRpbmcgaXQgdG8gYSBwYXJlbnQgdGltZWxpbmUgKHVuY29udmVudGlvbmFsLCBidXQgcG9zc2libGUsIGFuZCB3ZSB3b3VsZG4ndCB3YW50IGl0IHRvIGdldCByZW1vdmVkIGlmIHRoZSBwYXJlbnQncyBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSkuXHJcbiAgICB0ID0gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZWxpbmUucmF3VGltZSgpLCBjaGlsZCk7XHJcblxyXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcclxuICAgICAgY2hpbGQucmVuZGVyKHQsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXHJcblxyXG5cclxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcclxuICAgIC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9ycyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQuLi5cclxuICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xyXG4gICAgICB0ID0gdGltZWxpbmU7XHJcblxyXG4gICAgICB3aGlsZSAodC5fZHApIHtcclxuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXHJcblxyXG4gICAgICAgIHQgPSB0Ll9kcDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cclxuICB9XHJcbn0sXHJcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcclxuICBjaGlsZC5wYXJlbnQgJiYgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xyXG4gIGNoaWxkLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoKF9pc051bWJlcihwb3NpdGlvbikgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIHx8IHRpbWVsaW5lICE9PSBfZ2xvYmFsVGltZWxpbmUgPyBfcGFyc2VQb3NpdGlvbih0aW1lbGluZSwgcG9zaXRpb24sIGNoaWxkKSA6IHRpbWVsaW5lLl90aW1lKSArIGNoaWxkLl9kZWxheSk7XHJcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XHJcblxyXG4gIF9hZGRMaW5rZWRMaXN0SXRlbSh0aW1lbGluZSwgY2hpbGQsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGltZWxpbmUuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XHJcblxyXG4gIF9pc0Zyb21PckZyb21TdGFydChjaGlsZCkgfHwgKHRpbWVsaW5lLl9yZWNlbnQgPSBjaGlsZCk7XHJcbiAgc2tpcENoZWNrcyB8fCBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpO1xyXG4gIHRpbWVsaW5lLl90cyA8IDAgJiYgX2FsaWduUGxheWhlYWQodGltZWxpbmUsIHRpbWVsaW5lLl90VGltZSk7IC8vIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIG5ldyBjaGlsZCBtYWtlcyBpdCBsb25nZXIsIHdlIG1heSBuZWVkIHRvIGFkanVzdCB0aGUgcGFyZW50J3MgX3N0YXJ0IChwdXNoIGl0IGJhY2spXHJcblxyXG4gIHJldHVybiB0aW1lbGluZTtcclxufSxcclxuICAgIF9zY3JvbGxUcmlnZ2VyID0gZnVuY3Rpb24gX3Njcm9sbFRyaWdnZXIoYW5pbWF0aW9uLCB0cmlnZ2VyKSB7XHJcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcclxufSxcclxuICAgIF9hdHRlbXB0SW5pdFR3ZWVuID0gZnVuY3Rpb24gX2F0dGVtcHRJbml0VHdlZW4odHdlZW4sIHRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cywgdFRpbWUpIHtcclxuICBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCB0VGltZSk7XHJcblxyXG4gIGlmICghdHdlZW4uX2luaXR0ZWQpIHtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgIV9yZXZlcnRpbmcgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xyXG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XHJcblxyXG4gICAgdHdlZW4uX2xhenkgPSBbdFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxufSxcclxuICAgIF9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQgPSBmdW5jdGlvbiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KF9yZWYpIHtcclxuICB2YXIgcGFyZW50ID0gX3JlZi5wYXJlbnQ7XHJcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xyXG59LFxyXG4gICAgLy8gY2hlY2sgcGFyZW50J3MgX2xvY2sgYmVjYXVzZSB3aGVuIGEgdGltZWxpbmUgcmVwZWF0cy95b3lvcyBhbmQgZG9lcyBpdHMgYXJ0aWZpY2lhbCB3cmFwcGluZywgd2Ugc2hvdWxkbid0IGZvcmNlIHRoZSByYXRpbyBiYWNrIHRvIDBcclxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XHJcbiAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xyXG4gIHJldHVybiBkYXRhID09PSBcImlzRnJvbVN0YXJ0XCIgfHwgZGF0YSA9PT0gXCJpc1N0YXJ0XCI7XHJcbn0sXHJcbiAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4gPSBmdW5jdGlvbiBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odHdlZW4sIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XHJcbiAgdmFyIHByZXZSYXRpbyA9IHR3ZWVuLnJhdGlvLFxyXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXHJcbiAgICAgIC8vIGlmIHRoZSB0d2VlbiBvciBpdHMgcGFyZW50IGlzIHJldmVyc2VkIGFuZCB0aGUgdG90YWxUaW1lIGlzIDAsIHdlIHNob3VsZCBnbyB0byBhIHJhdGlvIG9mIDAuIEVkZ2UgY2FzZTogaWYgYSBmcm9tKCkgb3IgZnJvbVRvKCkgc3RhZ2dlciB0d2VlbiBpcyBwbGFjZWQgbGF0ZXIgaW4gYSB0aW1lbGluZSwgdGhlIFwic3RhcnRBdFwiIHplcm8tZHVyYXRpb24gdHdlZW4gY291bGQgaW5pdGlhbGx5IHJlbmRlciBhdCBhIHRpbWUgd2hlbiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgaXMgdGVjaG5pY2FsbHkgQkVGT1JFIHdoZXJlIHRoaXMgdHdlZW4gaXMsIHNvIG1ha2Ugc3VyZSB0aGF0IGFueSBcImZyb21cIiBhbmQgXCJmcm9tVG9cIiBzdGFydEF0IHR3ZWVucyBhcmUgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUgYXQgYSByYXRpbyBvZiAxLlxyXG4gIHJlcGVhdERlbGF5ID0gdHdlZW4uX3JEZWxheSxcclxuICAgICAgdFRpbWUgPSAwLFxyXG4gICAgICBwdCxcclxuICAgICAgaXRlcmF0aW9uLFxyXG4gICAgICBwcmV2SXRlcmF0aW9uO1xyXG5cclxuICBpZiAocmVwZWF0RGVsYXkgJiYgdHdlZW4uX3JlcGVhdCkge1xyXG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcclxuICAgIHRUaW1lID0gX2NsYW1wKDAsIHR3ZWVuLl90RHVyLCB0b3RhbFRpbWUpO1xyXG4gICAgaXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCByZXBlYXREZWxheSk7XHJcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XHJcblxyXG4gICAgaWYgKGl0ZXJhdGlvbiAhPT0gX2FuaW1hdGlvbkN5Y2xlKHR3ZWVuLl90VGltZSwgcmVwZWF0RGVsYXkpKSB7XHJcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXHJcbiAgICAgIHByZXZSYXRpbyA9IDEgLSByYXRpbztcclxuICAgICAgdHdlZW4udmFycy5yZXBlYXRSZWZyZXNoICYmIHR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmludmFsaWRhdGUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IF9yZXZlcnRpbmcgfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xyXG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xyXG4gICAgICAvLyBpZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xyXG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lIHx8IChzdXBwcmVzc0V2ZW50cyA/IF90aW55TnVtIDogMCk7IC8vIHdoZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxyXG5cclxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXHJcblxyXG4gICAgdHdlZW4ucmF0aW8gPSByYXRpbztcclxuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XHJcbiAgICB0d2Vlbi5fdGltZSA9IDA7XHJcbiAgICB0d2Vlbi5fdFRpbWUgPSB0VGltZTtcclxuICAgIHB0ID0gdHdlZW4uX3B0O1xyXG5cclxuICAgIHdoaWxlIChwdCkge1xyXG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcclxuICAgICAgcHQgPSBwdC5fbmV4dDtcclxuICAgIH1cclxuXHJcbiAgICB0b3RhbFRpbWUgPCAwICYmIF9yZXdpbmRTdGFydEF0KHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCB0cnVlKTtcclxuICAgIHR3ZWVuLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xyXG4gICAgdFRpbWUgJiYgdHdlZW4uX3JlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdHdlZW4ucGFyZW50ICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblJlcGVhdFwiKTtcclxuXHJcbiAgICBpZiAoKHRvdGFsVGltZSA+PSB0d2Vlbi5fdER1ciB8fCB0b3RhbFRpbWUgPCAwKSAmJiB0d2Vlbi5yYXRpbyA9PT0gcmF0aW8pIHtcclxuICAgICAgcmF0aW8gJiYgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4sIDEpO1xyXG5cclxuICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhX3JldmVydGluZykge1xyXG4gICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHR3ZWVuLl9wcm9tICYmIHR3ZWVuLl9wcm9tKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCF0d2Vlbi5felRpbWUpIHtcclxuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZTtcclxuICB9XHJcbn0sXHJcbiAgICBfZmluZE5leHRQYXVzZVR3ZWVuID0gZnVuY3Rpb24gX2ZpbmROZXh0UGF1c2VUd2VlbihhbmltYXRpb24sIHByZXZUaW1lLCB0aW1lKSB7XHJcbiAgdmFyIGNoaWxkO1xyXG5cclxuICBpZiAodGltZSA+IHByZXZUaW1lKSB7XHJcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XHJcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY2hpbGQgPSBhbmltYXRpb24uX2xhc3Q7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XHJcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPCBwcmV2VGltZSkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcclxuICAgIH1cclxuICB9XHJcbn0sXHJcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcclxuICB2YXIgcmVwZWF0ID0gYW5pbWF0aW9uLl9yZXBlYXQsXHJcbiAgICAgIGR1ciA9IF9yb3VuZFByZWNpc2UoZHVyYXRpb24pIHx8IDAsXHJcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xyXG4gIHRvdGFsUHJvZ3Jlc3MgJiYgIWxlYXZlUGxheWhlYWQgJiYgKGFuaW1hdGlvbi5fdGltZSAqPSBkdXIgLyBhbmltYXRpb24uX2R1cik7XHJcbiAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XHJcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XHJcbiAgdG90YWxQcm9ncmVzcyA+IDAgJiYgIWxlYXZlUGxheWhlYWQgJiYgX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcyk7XHJcbiAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XHJcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcclxuICByZXR1cm4gYW5pbWF0aW9uO1xyXG59LFxyXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XHJcbiAgcmV0dXJuIGFuaW1hdGlvbiBpbnN0YW5jZW9mIFRpbWVsaW5lID8gX3VuY2FjaGUoYW5pbWF0aW9uKSA6IF9zZXREdXJhdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5fZHVyKTtcclxufSxcclxuICAgIF96ZXJvUG9zaXRpb24gPSB7XHJcbiAgX3N0YXJ0OiAwLFxyXG4gIGVuZFRpbWU6IF9lbXB0eUZ1bmMsXHJcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xyXG59LFxyXG4gICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSB7XHJcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXHJcbiAgICAgIHJlY2VudCA9IGFuaW1hdGlvbi5fcmVjZW50IHx8IF96ZXJvUG9zaXRpb24sXHJcbiAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcclxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuICBpLFxyXG4gICAgICBvZmZzZXQsXHJcbiAgICAgIGlzUGVyY2VudDtcclxuXHJcbiAgaWYgKF9pc1N0cmluZyhwb3NpdGlvbikgJiYgKGlzTmFOKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiBpbiBsYWJlbHMpKSB7XHJcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxyXG4gICAgb2Zmc2V0ID0gcG9zaXRpb24uY2hhckF0KDApO1xyXG4gICAgaXNQZXJjZW50ID0gcG9zaXRpb24uc3Vic3RyKC0xKSA9PT0gXCIlXCI7XHJcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XHJcblxyXG4gICAgaWYgKG9mZnNldCA9PT0gXCI8XCIgfHwgb2Zmc2V0ID09PSBcIj5cIikge1xyXG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcclxuICAgICAgcmV0dXJuIChvZmZzZXQgPT09IFwiPFwiID8gcmVjZW50Ll9zdGFydCA6IHJlY2VudC5lbmRUaW1lKHJlY2VudC5fcmVwZWF0ID49IDApKSArIChwYXJzZUZsb2F0KHBvc2l0aW9uLnN1YnN0cigxKSkgfHwgMCkgKiAoaXNQZXJjZW50ID8gKGkgPCAwID8gcmVjZW50IDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpIC8gMTAwIDogMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIHBvc2l0aW9uIGluIGxhYmVscyB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XHJcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xyXG4gICAgfVxyXG5cclxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xyXG5cclxuICAgIGlmIChpc1BlcmNlbnQgJiYgcGVyY2VudEFuaW1hdGlvbikge1xyXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcclxufSxcclxuICAgIF9jcmVhdGVUd2VlblR5cGUgPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW5UeXBlKHR5cGUsIHBhcmFtcywgdGltZWxpbmUpIHtcclxuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcclxuICAgICAgdmFyc0luZGV4ID0gKGlzTGVnYWN5ID8gMiA6IDEpICsgKHR5cGUgPCAyID8gMCA6IDEpLFxyXG4gICAgICB2YXJzID0gcGFyYW1zW3ZhcnNJbmRleF0sXHJcbiAgICAgIGlyVmFycyxcclxuICAgICAgcGFyZW50O1xyXG5cclxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XHJcbiAgdmFycy5wYXJlbnQgPSB0aW1lbGluZTtcclxuXHJcbiAgaWYgKHR5cGUpIHtcclxuICAgIGlyVmFycyA9IHZhcnM7XHJcbiAgICBwYXJlbnQgPSB0aW1lbGluZTtcclxuXHJcbiAgICB3aGlsZSAocGFyZW50ICYmICEoXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiBpclZhcnMpKSB7XHJcbiAgICAgIC8vIGluaGVyaXRhbmNlIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGJ1dCBzb21lb25lIG1heSBoYXZlIHNldCBhIGRlZmF1bHQgaW4gYW4gYW5jZXN0b3IgdGltZWxpbmUuIFdlIGNvdWxkIGRvIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoX2luaGVyaXREZWZhdWx0cyh2YXJzKS5pbW1lZGlhdGVSZW5kZXIpIGJ1dCB0aGF0J2QgZXhhY3QgYSBzbGlnaHQgcGVyZm9ybWFuY2UgcGVuYWx0eSBiZWNhdXNlIF9pbmhlcml0RGVmYXVsdHMoKSBhbHNvIHJ1bnMgaW4gdGhlIFR3ZWVuIGNvbnN0cnVjdG9yLiBXZSdyZSBwYXlpbmcgYSBzbWFsbCBrYiBwcmljZSBoZXJlIHRvIGdhaW4gc3BlZWQuXHJcbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xyXG4gICAgICBwYXJlbnQgPSBfaXNOb3RGYWxzZShwYXJlbnQudmFycy5pbmhlcml0KSAmJiBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UoaXJWYXJzLmltbWVkaWF0ZVJlbmRlcik7XHJcbiAgICB0eXBlIDwgMiA/IHZhcnMucnVuQmFja3dhcmRzID0gMSA6IHZhcnMuc3RhcnRBdCA9IHBhcmFtc1t2YXJzSW5kZXggLSAxXTsgLy8gXCJmcm9tXCIgdmFyc1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ldyBUd2VlbihwYXJhbXNbMF0sIHZhcnMsIHBhcmFtc1t2YXJzSW5kZXggKyAxXSk7XHJcbn0sXHJcbiAgICBfY29uZGl0aW9uYWxSZXR1cm4gPSBmdW5jdGlvbiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmMpIHtcclxuICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBmdW5jKHZhbHVlKSA6IGZ1bmM7XHJcbn0sXHJcbiAgICBfY2xhbXAgPSBmdW5jdGlvbiBfY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcclxufSxcclxuICAgIGdldFVuaXQgPSBmdW5jdGlvbiBnZXRVbml0KHZhbHVlLCB2KSB7XHJcbiAgcmV0dXJuICFfaXNTdHJpbmcodmFsdWUpIHx8ICEodiA9IF91bml0RXhwLmV4ZWModmFsdWUpKSA/IFwiXCIgOiB2WzFdO1xyXG59LFxyXG4gICAgLy8gbm90ZTogcHJvdGVjdCBhZ2FpbnN0IHBhZGRlZCBudW1iZXJzIGFzIHN0cmluZ3MsIGxpa2UgXCIxMDAuMTAwXCIuIFRoYXQgc2hvdWxkbid0IHJldHVybiBcIjAwXCIgYXMgdGhlIHVuaXQuIElmIGl0J3MgbnVtZXJpYywgcmV0dXJuIG5vIHVuaXQuXHJcbmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XHJcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiBfY2xhbXAobWluLCBtYXgsIHYpO1xyXG4gIH0pO1xyXG59LFxyXG4gICAgX3NsaWNlID0gW10uc2xpY2UsXHJcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XHJcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XHJcbn0sXHJcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XHJcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcclxuICAgIGFjY3VtdWxhdG9yID0gW107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBfYWNjdW11bGF0b3I7XHJcblxyXG4gICAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyB8fCBfaXNBcnJheUxpa2UodmFsdWUsIDEpID8gKF9hY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yKS5wdXNoLmFwcGx5KF9hY2N1bXVsYXRvciwgdG9BcnJheSh2YWx1ZSkpIDogYWNjdW11bGF0b3IucHVzaCh2YWx1ZSk7XHJcbiAgfSkgfHwgYWNjdW11bGF0b3I7XHJcbn0sXHJcbiAgICAvL3Rha2VzIGFueSB2YWx1ZSBhbmQgcmV0dXJucyBhbiBhcnJheS4gSWYgaXQncyBhIHN0cmluZyAoYW5kIGxlYXZlU3RyaW5ncyBpc24ndCB0cnVlKSwgaXQnbGwgdXNlIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKSBhbmQgY29udmVydCB0aGF0IHRvIGFuIGFycmF5LiBJdCdsbCBhbHNvIGFjY2VwdCBpdGVyYWJsZXMgbGlrZSBqUXVlcnkgb2JqZWN0cy5cclxudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIHNjb3BlLCBsZWF2ZVN0cmluZ3MpIHtcclxuICByZXR1cm4gX2NvbnRleHQgJiYgIXNjb3BlICYmIF9jb250ZXh0LnNlbGVjdG9yID8gX2NvbnRleHQuc2VsZWN0b3IodmFsdWUpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xyXG59LFxyXG4gICAgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3Rvcih2YWx1ZSkge1xyXG4gIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xyXG4gIHJldHVybiBmdW5jdGlvbiAodikge1xyXG4gICAgdmFyIGVsID0gdmFsdWUuY3VycmVudCB8fCB2YWx1ZS5uYXRpdmVFbGVtZW50IHx8IHZhbHVlO1xyXG4gICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcclxuICB9O1xyXG59LFxyXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xyXG4gIHJldHVybiBhLnNvcnQoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIC41IC0gTWF0aC5yYW5kb20oKTtcclxuICB9KTtcclxufSxcclxuICAgIC8vIGFsdGVybmF0aXZlIHRoYXQncyBhIGJpdCBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibHkgZGl2ZXJzZSBidXQgYmlnZ2VyOiAgIGZvciAobGV0IGosIHYsIGkgPSBhLmxlbmd0aDsgaTsgaiA9IChNYXRoLnJhbmRvbSgpICogaSkgfCAwLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcclxuLy9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xyXG5kaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XHJcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XHJcbiAgICByZXR1cm4gdjtcclxuICB9XHJcblxyXG4gIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcclxuICAgIGVhY2g6IHZcclxuICB9LFxyXG4gICAgICAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxyXG4gIGVhc2UgPSBfcGFyc2VFYXNlKHZhcnMuZWFzZSksXHJcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcclxuICAgICAgYmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxyXG4gICAgICBjYWNoZSA9IHt9LFxyXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcclxuICAgICAgcmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxyXG4gICAgICBheGlzID0gdmFycy5heGlzLFxyXG4gICAgICByYXRpb1ggPSBmcm9tLFxyXG4gICAgICByYXRpb1kgPSBmcm9tO1xyXG5cclxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XHJcbiAgICByYXRpb1ggPSByYXRpb1kgPSB7XHJcbiAgICAgIGNlbnRlcjogLjUsXHJcbiAgICAgIGVkZ2VzOiAuNSxcclxuICAgICAgZW5kOiAxXHJcbiAgICB9W2Zyb21dIHx8IDA7XHJcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xyXG4gICAgcmF0aW9YID0gZnJvbVswXTtcclxuICAgIHJhdGlvWSA9IGZyb21bMV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGksIHRhcmdldCwgYSkge1xyXG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXHJcbiAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXHJcbiAgICAgICAgb3JpZ2luWCxcclxuICAgICAgICBvcmlnaW5ZLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICBkLFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgbWF4LFxyXG4gICAgICAgIG1pbixcclxuICAgICAgICB3cmFwQXQ7XHJcblxyXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcclxuICAgICAgd3JhcEF0ID0gdmFycy5ncmlkID09PSBcImF1dG9cIiA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XHJcblxyXG4gICAgICBpZiAoIXdyYXBBdCkge1xyXG4gICAgICAgIG1heCA9IC1fYmlnTnVtO1xyXG5cclxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XHJcblxyXG4gICAgICAgIHdyYXBBdCA8IGwgJiYgd3JhcEF0LS07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XHJcbiAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xyXG4gICAgICBvcmlnaW5ZID0gd3JhcEF0ID09PSBfYmlnTnVtID8gMCA6IHJhdGlvcyA/IGwgKiByYXRpb1kgLyB3cmFwQXQgLSAuNSA6IGZyb20gLyB3cmFwQXQgfCAwO1xyXG4gICAgICBtYXggPSAwO1xyXG4gICAgICBtaW4gPSBfYmlnTnVtO1xyXG5cclxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcclxuICAgICAgICB5ID0gb3JpZ2luWSAtIChqIC8gd3JhcEF0IHwgMCk7XHJcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcclxuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcclxuICAgICAgICBkIDwgbWluICYmIChtaW4gPSBkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnJvbSA9PT0gXCJyYW5kb21cIiAmJiBzaHVmZmxlKGRpc3RhbmNlcyk7XHJcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XHJcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XHJcbiAgICAgIGRpc3RhbmNlcy52ID0gbCA9IChwYXJzZUZsb2F0KHZhcnMuYW1vdW50KSB8fCBwYXJzZUZsb2F0KHZhcnMuZWFjaCkgKiAod3JhcEF0ID4gbCA/IGwgLSAxIDogIWF4aXMgPyBNYXRoLm1heCh3cmFwQXQsIGwgLyB3cmFwQXQpIDogYXhpcyA9PT0gXCJ5XCIgPyBsIC8gd3JhcEF0IDogd3JhcEF0KSB8fCAwKSAqIChmcm9tID09PSBcImVkZ2VzXCIgPyAtMSA6IDEpO1xyXG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xyXG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcclxuXHJcbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xyXG4gICAgfVxyXG5cclxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XHJcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXHJcbiAgfTtcclxufSxcclxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xyXG4gIC8vcGFzcyBpbiAwLjEgZ2V0IGEgZnVuY3Rpb24gdGhhdCdsbCByb3VuZCB0byB0aGUgbmVhcmVzdCB0ZW50aCwgb3IgNSB0byByb3VuZCB0byB0aGUgY2xvc2VzdCA1LCBvciAwLjAwMSB0byB0aGUgY2xvc2VzdCAxMDAwdGgsIGV0Yy5cclxuICB2YXIgcCA9IE1hdGgucG93KDEwLCAoKHYgKyBcIlwiKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoKTsgLy90byBhdm9pZCBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAobGlrZSAyNCAqIDAuMSA9PSAyLjQwMDAwMDAwMDAwMDAwMDQpLCB3ZSBjaG9wIG9mZiBhdCBhIHNwZWNpZmljIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyAobXVjaCBmYXN0ZXIgdGhhbiB0b0ZpeGVkKCkpXHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAocmF3KSB7XHJcbiAgICB2YXIgbiA9IF9yb3VuZFByZWNpc2UoTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJhdykgLyB2KSAqIHYgKiBwKTtcclxuXHJcbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxyXG4gIH07XHJcbn0sXHJcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XHJcbiAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheShzbmFwVG8pLFxyXG4gICAgICByYWRpdXMsXHJcbiAgICAgIGlzMkQ7XHJcblxyXG4gIGlmICghaXNBcnJheSAmJiBfaXNPYmplY3Qoc25hcFRvKSkge1xyXG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcclxuXHJcbiAgICBpZiAoc25hcFRvLnZhbHVlcykge1xyXG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xyXG5cclxuICAgICAgaWYgKGlzMkQgPSAhX2lzTnVtYmVyKHNuYXBUb1swXSkpIHtcclxuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyBmdW5jdGlvbiAocmF3KSB7XHJcbiAgICBpczJEID0gc25hcFRvKHJhdyk7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcclxuICB9IDogZnVuY3Rpb24gKHJhdykge1xyXG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGlzMkQgPyByYXcueCA6IHJhdyksXHJcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXHJcbiAgICAgICAgbWluID0gX2JpZ051bSxcclxuICAgICAgICBjbG9zZXN0ID0gMCxcclxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcclxuICAgICAgICBkeCxcclxuICAgICAgICBkeTtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGlmIChpczJEKSB7XHJcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XHJcbiAgICAgICAgZHkgPSBzbmFwVG9baV0ueSAtIHk7XHJcbiAgICAgICAgZHggPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkeCA9IE1hdGguYWJzKHNuYXBUb1tpXSAtIHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZHggPCBtaW4pIHtcclxuICAgICAgICBtaW4gPSBkeDtcclxuICAgICAgICBjbG9zZXN0ID0gaTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsb3Nlc3QgPSAhcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMgPyBzbmFwVG9bY2xvc2VzdF0gOiByYXc7XHJcbiAgICByZXR1cm4gaXMyRCB8fCBjbG9zZXN0ID09PSByYXcgfHwgX2lzTnVtYmVyKHJhdykgPyBjbG9zZXN0IDogY2xvc2VzdCArIGdldFVuaXQocmF3KTtcclxuICB9KTtcclxufSxcclxuICAgIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgcm91bmRpbmdJbmNyZW1lbnQsIHJldHVybkZ1bmN0aW9uKSB7XHJcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IE1hdGgucG93KDEwLCAocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbjtcclxuICB9KTtcclxufSxcclxuICAgIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jdGlvbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAodiwgZikge1xyXG4gICAgICByZXR1cm4gZih2KTtcclxuICAgIH0sIHZhbHVlKTtcclxuICB9O1xyXG59LFxyXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKTtcclxuICB9O1xyXG59LFxyXG4gICAgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xyXG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xyXG59LFxyXG4gICAgX3dyYXBBcnJheSA9IGZ1bmN0aW9uIF93cmFwQXJyYXkoYSwgd3JhcHBlciwgdmFsdWUpIHtcclxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgIHJldHVybiBhW35+d3JhcHBlcihpbmRleCldO1xyXG4gIH0pO1xyXG59LFxyXG4gICAgd3JhcCA9IGZ1bmN0aW9uIHdyYXAobWluLCBtYXgsIHZhbHVlKSB7XHJcbiAgLy8gTk9URTogd3JhcCgpIENBTk5PVCBiZSBhbiBhcnJvdyBmdW5jdGlvbiEgQSB2ZXJ5IG9kZCBjb21waWxpbmcgYnVnIGNhdXNlcyBwcm9ibGVtcyAodW5yZWxhdGVkIHRvIEdTQVApLlxyXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcclxuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwKDAsIG1pbi5sZW5ndGgpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiAocmFuZ2UgKyAodmFsdWUgLSBtaW4pICUgcmFuZ2UpICUgcmFuZ2UgKyBtaW47XHJcbiAgfSk7XHJcbn0sXHJcbiAgICB3cmFwWW95byA9IGZ1bmN0aW9uIHdyYXBZb3lvKG1pbiwgbWF4LCB2YWx1ZSkge1xyXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcclxuICAgICAgdG90YWwgPSByYW5nZSAqIDI7XHJcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcFlveW8oMCwgbWluLmxlbmd0aCAtIDEpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XHJcbiAgICByZXR1cm4gbWluICsgKHZhbHVlID4gcmFuZ2UgPyB0b3RhbCAtIHZhbHVlIDogdmFsdWUpO1xyXG4gIH0pO1xyXG59LFxyXG4gICAgX3JlcGxhY2VSYW5kb20gPSBmdW5jdGlvbiBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkge1xyXG4gIC8vcmVwbGFjZXMgYWxsIG9jY3VycmVuY2VzIG9mIHJhbmRvbSguLi4pIGluIGEgc3RyaW5nIHdpdGggdGhlIGNhbGN1bGF0ZWQgcmFuZG9tIHZhbHVlLiBjYW4gYmUgYSByYW5nZSBsaWtlIHJhbmRvbSgtMTAwLCAxMDAsIDUpIG9yIGFuIGFycmF5IGxpa2UgcmFuZG9tKFswLCAxMDAsIDUwMF0pXHJcbiAgdmFyIHByZXYgPSAwLFxyXG4gICAgICBzID0gXCJcIixcclxuICAgICAgaSxcclxuICAgICAgbnVtcyxcclxuICAgICAgZW5kLFxyXG4gICAgICBpc0FycmF5O1xyXG5cclxuICB3aGlsZSAofihpID0gdmFsdWUuaW5kZXhPZihcInJhbmRvbShcIiwgcHJldikpKSB7XHJcbiAgICBlbmQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBpKTtcclxuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcclxuICAgIG51bXMgPSB2YWx1ZS5zdWJzdHIoaSArIDcsIGVuZCAtIGkgLSA3KS5tYXRjaChpc0FycmF5ID8gX2RlbGltaXRlZFZhbHVlRXhwIDogX3N0cmljdE51bUV4cCk7XHJcbiAgICBzICs9IHZhbHVlLnN1YnN0cihwcmV2LCBpIC0gcHJldikgKyByYW5kb20oaXNBcnJheSA/IG51bXMgOiArbnVtc1swXSwgaXNBcnJheSA/IDAgOiArbnVtc1sxXSwgK251bXNbMl0gfHwgMWUtNSk7XHJcbiAgICBwcmV2ID0gZW5kICsgMTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xyXG59LFxyXG4gICAgbWFwUmFuZ2UgPSBmdW5jdGlvbiBtYXBSYW5nZShpbk1pbiwgaW5NYXgsIG91dE1pbiwgb3V0TWF4LCB2YWx1ZSkge1xyXG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcclxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XHJcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcclxuICB9KTtcclxufSxcclxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xyXG4gIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gKDEgLSBwKSAqIHN0YXJ0ICsgcCAqIGVuZDtcclxuICB9O1xyXG5cclxuICBpZiAoIWZ1bmMpIHtcclxuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXHJcbiAgICAgICAgbWFzdGVyID0ge30sXHJcbiAgICAgICAgcCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGludGVycG9sYXRvcnMsXHJcbiAgICAgICAgbCxcclxuICAgICAgICBpbDtcclxuXHJcbiAgICBwcm9ncmVzcyA9PT0gdHJ1ZSAmJiAobXV0YXRlID0gMSkgJiYgKHByb2dyZXNzID0gbnVsbCk7XHJcblxyXG4gICAgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICAgIHN0YXJ0ID0ge1xyXG4gICAgICAgIHA6IHN0YXJ0XHJcbiAgICAgIH07XHJcbiAgICAgIGVuZCA9IHtcclxuICAgICAgICBwOiBlbmRcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoX2lzQXJyYXkoc3RhcnQpICYmICFfaXNBcnJheShlbmQpKSB7XHJcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcclxuICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcclxuICAgICAgaWwgPSBsIC0gMjtcclxuXHJcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaSAtIDFdLCBzdGFydFtpXSkpOyAvL2J1aWxkIHRoZSBpbnRlcnBvbGF0b3JzIHVwIGZyb250IGFzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG1hbnkgdGltZXMsIGl0IGNhbiBqdXN0IHJldXNlIHRoZW0uXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGwtLTtcclxuXHJcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcclxuICAgICAgICBwICo9IGw7XHJcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcclxuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBwcm9ncmVzcyA9IGVuZDtcclxuICAgIH0gZWxzZSBpZiAoIW11dGF0ZSkge1xyXG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XHJcbiAgICAgIGZvciAocCBpbiBlbmQpIHtcclxuICAgICAgICBfYWRkUHJvcFR3ZWVuLmNhbGwobWFzdGVyLCBzdGFydCwgcCwgXCJnZXRcIiwgZW5kW3BdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xyXG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHByb2dyZXNzLCBmdW5jKTtcclxufSxcclxuICAgIF9nZXRMYWJlbEluRGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsSW5EaXJlY3Rpb24odGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkge1xyXG4gIC8vdXNlZCBmb3IgbmV4dExhYmVsKCkgYW5kIHByZXZpb3VzTGFiZWwoKVxyXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXHJcbiAgICAgIG1pbiA9IF9iaWdOdW0sXHJcbiAgICAgIHAsXHJcbiAgICAgIGRpc3RhbmNlLFxyXG4gICAgICBsYWJlbDtcclxuXHJcbiAgZm9yIChwIGluIGxhYmVscykge1xyXG4gICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcclxuXHJcbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcclxuICAgICAgbGFiZWwgPSBwO1xyXG4gICAgICBtaW4gPSBkaXN0YW5jZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBsYWJlbDtcclxufSxcclxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhhbmltYXRpb24sIHR5cGUsIGV4ZWN1dGVMYXp5Rmlyc3QpIHtcclxuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxyXG4gICAgICBjYWxsYmFjayA9IHZbdHlwZV0sXHJcbiAgICAgIHByZXZDb250ZXh0ID0gX2NvbnRleHQsXHJcbiAgICAgIGNvbnRleHQgPSBhbmltYXRpb24uX2N0eCxcclxuICAgICAgcGFyYW1zLFxyXG4gICAgICBzY29wZSxcclxuICAgICAgcmVzdWx0O1xyXG5cclxuICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcclxuICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XHJcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXHJcblxyXG4gIGNvbnRleHQgJiYgKF9jb250ZXh0ID0gY29udGV4dCk7XHJcbiAgcmVzdWx0ID0gcGFyYW1zID8gY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcykgOiBjYWxsYmFjay5jYWxsKHNjb3BlKTtcclxuICBfY29udGV4dCA9IHByZXZDb250ZXh0O1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn0sXHJcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcclxuICBfcmVtb3ZlRnJvbVBhcmVudChhbmltYXRpb24pO1xyXG5cclxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKCEhX3JldmVydGluZyk7XHJcbiAgYW5pbWF0aW9uLnByb2dyZXNzKCkgPCAxICYmIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XHJcbiAgcmV0dXJuIGFuaW1hdGlvbjtcclxufSxcclxuICAgIF9xdWlja1R3ZWVuLFxyXG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUgPSBbXSxcclxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xyXG4gIGlmICghY29uZmlnKSByZXR1cm47XHJcbiAgY29uZmlnID0gIWNvbmZpZy5uYW1lICYmIGNvbmZpZ1tcImRlZmF1bHRcIl0gfHwgY29uZmlnOyAvLyBVTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXHJcblxyXG4gIGlmIChfd2luZG93RXhpc3RzKCkgfHwgY29uZmlnLmhlYWRsZXNzKSB7XHJcbiAgICAvLyBlZGdlIGNhc2U6IHNvbWUgYnVpbGQgdG9vbHMgbWF5IHBhc3MgaW4gYSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxyXG4gICAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcclxuICAgICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxyXG4gICAgICAgIFBsdWdpbiA9IG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcclxuICAgIH0gOiBjb25maWcsXHJcbiAgICAgICAgLy9pbiBjYXNlIHNvbWVvbmUgcGFzc2VzIGluIGFuIG9iamVjdCB0aGF0J3Mgbm90IGEgcGx1Z2luLCBsaWtlIEN1c3RvbUVhc2VcclxuICAgIGluc3RhbmNlRGVmYXVsdHMgPSB7XHJcbiAgICAgIGluaXQ6IF9lbXB0eUZ1bmMsXHJcbiAgICAgIHJlbmRlcjogX3JlbmRlclByb3BUd2VlbnMsXHJcbiAgICAgIGFkZDogX2FkZFByb3BUd2VlbixcclxuICAgICAga2lsbDogX2tpbGxQcm9wVHdlZW5zT2YsXHJcbiAgICAgIG1vZGlmaWVyOiBfYWRkUGx1Z2luTW9kaWZpZXIsXHJcbiAgICAgIHJhd1ZhcnM6IDBcclxuICAgIH0sXHJcbiAgICAgICAgc3RhdGljcyA9IHtcclxuICAgICAgdGFyZ2V0VGVzdDogMCxcclxuICAgICAgZ2V0OiAwLFxyXG4gICAgICBnZXRTZXR0ZXI6IF9nZXRTZXR0ZXIsXHJcbiAgICAgIGFsaWFzZXM6IHt9LFxyXG4gICAgICByZWdpc3RlcjogMFxyXG4gICAgfTtcclxuXHJcbiAgICBfd2FrZSgpO1xyXG5cclxuICAgIGlmIChjb25maWcgIT09IFBsdWdpbikge1xyXG4gICAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9zZXREZWZhdWx0cyhQbHVnaW4sIF9zZXREZWZhdWx0cyhfY29weUV4Y2x1ZGluZyhjb25maWcsIGluc3RhbmNlRGVmYXVsdHMpLCBzdGF0aWNzKSk7IC8vc3RhdGljIG1ldGhvZHNcclxuXHJcblxyXG4gICAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXHJcblxyXG5cclxuICAgICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcclxuXHJcbiAgICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xyXG4gICAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XHJcblxyXG4gICAgICAgIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmFtZSA9IChuYW1lID09PSBcImNzc1wiID8gXCJDU1NcIiA6IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKSkgKyBcIlBsdWdpblwiOyAvL2ZvciB0aGUgZ2xvYmFsIG5hbWUuIFwibW90aW9uUGF0aFwiIHNob3VsZCBiZWNvbWUgTW90aW9uUGF0aFBsdWdpblxyXG4gICAgfVxyXG5cclxuICAgIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcclxuXHJcbiAgICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcclxuICB9IGVsc2Uge1xyXG4gICAgX3JlZ2lzdGVyUGx1Z2luUXVldWUucHVzaChjb25maWcpO1xyXG4gIH1cclxufSxcclxuXHJcbi8qXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIENPTE9SU1xyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXzI1NSA9IDI1NSxcclxuICAgIF9jb2xvckxvb2t1cCA9IHtcclxuICBhcXVhOiBbMCwgXzI1NSwgXzI1NV0sXHJcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxyXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxyXG4gIGJsYWNrOiBbMCwgMCwgMF0sXHJcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcclxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxyXG4gIGJsdWU6IFswLCAwLCBfMjU1XSxcclxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcclxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxyXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxyXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxyXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXHJcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxyXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcclxuICBncmVlbjogWzAsIDEyOCwgMF0sXHJcbiAgcmVkOiBbXzI1NSwgMCwgMF0sXHJcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcclxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXHJcbiAgdHJhbnNwYXJlbnQ6IFtfMjU1LCBfMjU1LCBfMjU1LCAwXVxyXG59LFxyXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGlkZWEgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCBjb2xvciBuYW1lIHZhbHVlcyAtIHB1dCB0aGlzIGluIHRoZSB0aWNrZXIud2FrZSgpIHdoZXJlIHdlIHNldCB0aGUgX2RvYzpcclxuLy8gbGV0IGN0eCA9IF9kb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbi8vIF9mb3JFYWNoTmFtZShcImFxdWEsbGltZSxzaWx2ZXIsYmxhY2ssbWFyb29uLHRlYWwsYmx1ZSxuYXZ5LHdoaXRlLG9saXZlLHllbGxvdyxvcmFuZ2UsZ3JheSxwdXJwbGUsZ3JlZW4scmVkLHBpbmssY3lhblwiLCBjb2xvciA9PiB7Y3R4LmZpbGxTdHlsZSA9IGNvbG9yOyBfY29sb3JMb29rdXBbY29sb3JdID0gc3BsaXRDb2xvcihjdHguZmlsbFN0eWxlKX0pO1xyXG5faHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcclxuICBoICs9IGggPCAwID8gMSA6IGggPiAxID8gLTEgOiAwO1xyXG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xyXG59LFxyXG4gICAgc3BsaXRDb2xvciA9IGZ1bmN0aW9uIHNwbGl0Q29sb3IodiwgdG9IU0wsIGZvcmNlQWxwaGEpIHtcclxuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXHJcbiAgICAgIHIsXHJcbiAgICAgIGcsXHJcbiAgICAgIGIsXHJcbiAgICAgIGgsXHJcbiAgICAgIHMsXHJcbiAgICAgIGwsXHJcbiAgICAgIG1heCxcclxuICAgICAgbWluLFxyXG4gICAgICBkLFxyXG4gICAgICB3YXNIU0w7XHJcblxyXG4gIGlmICghYSkge1xyXG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcclxuICAgICAgLy9zb21ldGltZXMgYSB0cmFpbGluZyBjb21tYSBpcyBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNob3AgaXQgb2ZmICh0eXBpY2FsbHkgZnJvbSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyBsaWtlIGEgdGV4dFNoYWRvdzpcIjJweCAycHggMnB4IGJsdWUsIDVweCA1cHggNXB4IHJnYigyNTUsMCwwKVwiIC0gaW4gdGhpcyBleGFtcGxlIFwiYmx1ZSxcIiBoYXMgYSB0cmFpbGluZyBjb21tYS4gV2UgY291bGQgc3RyaXAgaXQgb3V0IGluc2lkZSBwYXJzZUNvbXBsZXgoKSBidXQgd2UnZCBuZWVkIHRvIGRvIGl0IHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgcGx1cyBpdCB3b3VsZG4ndCBwcm92aWRlIHByb3RlY3Rpb24gZnJvbSBvdGhlciBwb3RlbnRpYWwgc2NlbmFyaW9zIGxpa2UgaWYgdGhlIHVzZXIgcGFzc2VzIGluIGEgc2ltaWxhciB2YWx1ZS5cclxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xyXG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xyXG4gICAgfSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcclxuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xyXG4gICAgICAgIC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXHJcbiAgICAgICAgciA9IHYuY2hhckF0KDEpO1xyXG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcclxuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XHJcbiAgICAgICAgdiA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiICsgKHYubGVuZ3RoID09PSA1ID8gdi5jaGFyQXQoNCkgKyB2LmNoYXJBdCg0KSA6IFwiXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodi5sZW5ndGggPT09IDkpIHtcclxuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcclxuICAgICAgICBhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcclxuICAgICAgICByZXR1cm4gW2EgPj4gMTYsIGEgPj4gOCAmIF8yNTUsIGEgJiBfMjU1LCBwYXJzZUludCh2LnN1YnN0cig3KSwgMTYpIC8gMjU1XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdiA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XHJcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xyXG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xyXG4gICAgICBhID0gd2FzSFNMID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKTtcclxuXHJcbiAgICAgIGlmICghdG9IU0wpIHtcclxuICAgICAgICBoID0gK2FbMF0gJSAzNjAgLyAzNjA7XHJcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xyXG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcclxuICAgICAgICBnID0gbCA8PSAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcclxuICAgICAgICByID0gbCAqIDIgLSBnO1xyXG4gICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxyXG5cclxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xyXG4gICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xyXG4gICAgICAgIGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XHJcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcclxuICAgICAgICAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cclxuICAgICAgICBhID0gdi5tYXRjaChfbnVtRXhwKTtcclxuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgYSA9IGEubWFwKE51bWJlcik7XHJcbiAgfVxyXG5cclxuICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xyXG4gICAgciA9IGFbMF0gLyBfMjU1O1xyXG4gICAgZyA9IGFbMV0gLyBfMjU1O1xyXG4gICAgYiA9IGFbMl0gLyBfMjU1O1xyXG4gICAgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XHJcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XHJcblxyXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgIGggPSBzID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQgPSBtYXggLSBtaW47XHJcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcclxuICAgICAgaCA9IG1heCA9PT0gciA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09PSBnID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICBoICo9IDYwO1xyXG4gICAgfVxyXG5cclxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xyXG4gICAgYVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XHJcbiAgICBhWzJdID0gfn4obCAqIDEwMCArIC41KTtcclxuICB9XHJcblxyXG4gIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XHJcbiAgcmV0dXJuIGE7XHJcbn0sXHJcbiAgICBfY29sb3JPcmRlckRhdGEgPSBmdW5jdGlvbiBfY29sb3JPcmRlckRhdGEodikge1xyXG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxyXG4gIHZhciB2YWx1ZXMgPSBbXSxcclxuICAgICAgYyA9IFtdLFxyXG4gICAgICBpID0gLTE7XHJcbiAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgIHZhciBhID0gdi5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xyXG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcclxuICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XHJcbiAgfSk7XHJcbiAgdmFsdWVzLmMgPSBjO1xyXG4gIHJldHVybiB2YWx1ZXM7XHJcbn0sXHJcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcclxuICB2YXIgcmVzdWx0ID0gXCJcIixcclxuICAgICAgY29sb3JzID0gKHMgKyByZXN1bHQpLm1hdGNoKF9jb2xvckV4cCksXHJcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcclxuICAgICAgaSA9IDAsXHJcbiAgICAgIGMsXHJcbiAgICAgIHNoZWxsLFxyXG4gICAgICBkLFxyXG4gICAgICBsO1xyXG5cclxuICBpZiAoIWNvbG9ycykge1xyXG4gICAgcmV0dXJuIHM7XHJcbiAgfVxyXG5cclxuICBjb2xvcnMgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcclxuICB9KTtcclxuXHJcbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XHJcbiAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xyXG4gICAgYyA9IG9yZGVyTWF0Y2hEYXRhLmM7XHJcblxyXG4gICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XHJcbiAgICAgIHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XHJcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFzaGVsbCkge1xyXG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XHJcbiAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcclxuXHJcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0ICsgc2hlbGxbbF07XHJcbn0sXHJcbiAgICBfY29sb3JFeHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHMgPSBcIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17Myw0fSl7MSwyfVxcXFxiXCIsXHJcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXHJcbiAgcDtcclxuXHJcbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xyXG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XHJcbn0oKSxcclxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXHJcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xyXG4gIHZhciBjb21iaW5lZCA9IGEuam9pbihcIiBcIiksXHJcbiAgICAgIHRvSFNMO1xyXG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xyXG5cclxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XHJcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XHJcbiAgICBhWzFdID0gX2Zvcm1hdENvbG9ycyhhWzFdLCB0b0hTTCk7XHJcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59LFxyXG5cclxuLypcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogVElDS0VSXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqL1xyXG5fdGlja2VyQWN0aXZlLFxyXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcclxuICAgICAgX2xhZ1RocmVzaG9sZCA9IDUwMCxcclxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXHJcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxyXG4gICAgICBfbGFzdFVwZGF0ZSA9IF9zdGFydFRpbWUsXHJcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxyXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxyXG4gICAgICBfbGlzdGVuZXJzID0gW10sXHJcbiAgICAgIF9pZCxcclxuICAgICAgX3JlcSxcclxuICAgICAgX3JhZixcclxuICAgICAgX3NlbGYsXHJcbiAgICAgIF9kZWx0YSxcclxuICAgICAgX2ksXHJcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xyXG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXHJcbiAgICAgICAgbWFudWFsID0gdiA9PT0gdHJ1ZSxcclxuICAgICAgICBvdmVybGFwLFxyXG4gICAgICAgIGRpc3BhdGNoLFxyXG4gICAgICAgIHRpbWUsXHJcbiAgICAgICAgZnJhbWU7XHJcblxyXG4gICAgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkIHx8IGVsYXBzZWQgPCAwKSAmJiAoX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnKTtcclxuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XHJcbiAgICB0aW1lID0gX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lO1xyXG4gICAgb3ZlcmxhcCA9IHRpbWUgLSBfbmV4dFRpbWU7XHJcblxyXG4gICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xyXG4gICAgICBmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XHJcbiAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcclxuICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcclxuICAgICAgX25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcclxuICAgICAgZGlzcGF0Y2ggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpOyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxyXG5cclxuICAgIGlmIChkaXNwYXRjaCkge1xyXG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBfbGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIC8vIHVzZSBfaSBhbmQgY2hlY2sgX2xpc3RlbmVycy5sZW5ndGggaW5zdGVhZCBvZiBhIHZhcmlhYmxlIGJlY2F1c2UgYSBsaXN0ZW5lciBjb3VsZCBnZXQgcmVtb3ZlZCBkdXJpbmcgdGhlIGxvb3AsIGFuZCBpZiB0aGF0IGhhcHBlbnMgdG8gYW4gZWxlbWVudCBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgaW5kZXgsIGl0J2QgdGhyb3cgdGhpbmdzIG9mZiBpbiB0aGUgbG9vcC5cclxuICAgICAgICBfbGlzdGVuZXJzW19pXSh0aW1lLCBfZGVsdGEsIGZyYW1lLCB2KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9zZWxmID0ge1xyXG4gICAgdGltZTogMCxcclxuICAgIGZyYW1lOiAwLFxyXG4gICAgdGljazogZnVuY3Rpb24gdGljaygpIHtcclxuICAgICAgX3RpY2sodHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgZGVsdGFSYXRpbzogZnVuY3Rpb24gZGVsdGFSYXRpbyhmcHMpIHtcclxuICAgICAgcmV0dXJuIF9kZWx0YSAvICgxMDAwIC8gKGZwcyB8fCA2MCkpO1xyXG4gICAgfSxcclxuICAgIHdha2U6IGZ1bmN0aW9uIHdha2UoKSB7XHJcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XHJcbiAgICAgICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgX3dpbmRvd0V4aXN0cygpKSB7XHJcbiAgICAgICAgICBfd2luID0gX2NvcmVJbml0dGVkID0gd2luZG93O1xyXG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XHJcbiAgICAgICAgICBfZ2xvYmFscy5nc2FwID0gZ3NhcDtcclxuICAgICAgICAgIChfd2luLmdzYXBWZXJzaW9ucyB8fCAoX3dpbi5nc2FwVmVyc2lvbnMgPSBbXSkpLnB1c2goZ3NhcC52ZXJzaW9uKTtcclxuXHJcbiAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xyXG5cclxuICAgICAgICAgIF9yZWdpc3RlclBsdWdpblF1ZXVlLmZvckVhY2goX2NyZWF0ZVBsdWdpbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfcmFmID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcbiAgICAgICAgX2lkICYmIF9zZWxmLnNsZWVwKCk7XHJcblxyXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcclxuXHJcbiAgICAgICAgX3RpY2soMik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzbGVlcDogZnVuY3Rpb24gc2xlZXAoKSB7XHJcbiAgICAgIChfcmFmID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XHJcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xyXG4gICAgICBfcmVxID0gX2VtcHR5RnVuYztcclxuICAgIH0sXHJcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XHJcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgSW5maW5pdHk7IC8vIHplcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcclxuXHJcbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnIHx8IDMzLCBfbGFnVGhyZXNob2xkKTtcclxuICAgIH0sXHJcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XHJcbiAgICAgIF9nYXAgPSAxMDAwIC8gKF9mcHMgfHwgMjQwKTtcclxuICAgICAgX25leHRUaW1lID0gX3NlbGYudGltZSAqIDEwMDAgKyBfZ2FwO1xyXG4gICAgfSxcclxuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNhbGxiYWNrLCBvbmNlLCBwcmlvcml0aXplKSB7XHJcbiAgICAgIHZhciBmdW5jID0gb25jZSA/IGZ1bmN0aW9uICh0LCBkLCBmLCB2KSB7XHJcbiAgICAgICAgY2FsbGJhY2sodCwgZCwgZiwgdik7XHJcblxyXG4gICAgICAgIF9zZWxmLnJlbW92ZShmdW5jKTtcclxuICAgICAgfSA6IGNhbGxiYWNrO1xyXG5cclxuICAgICAgX3NlbGYucmVtb3ZlKGNhbGxiYWNrKTtcclxuXHJcbiAgICAgIF9saXN0ZW5lcnNbcHJpb3JpdGl6ZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGZ1bmMpO1xyXG5cclxuICAgICAgX3dha2UoKTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XHJcbiAgICAgIH4oaSA9IF9saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykpICYmIF9saXN0ZW5lcnMuc3BsaWNlKGksIDEpICYmIF9pID49IGkgJiYgX2ktLTtcclxuICAgIH0sXHJcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXHJcbiAgfTtcclxuICByZXR1cm4gX3NlbGY7XHJcbn0oKSxcclxuICAgIF93YWtlID0gZnVuY3Rpb24gX3dha2UoKSB7XHJcbiAgcmV0dXJuICFfdGlja2VyQWN0aXZlICYmIF90aWNrZXIud2FrZSgpO1xyXG59LFxyXG4gICAgLy9hbHNvIGVuc3VyZXMgdGhlIGNvcmUgY2xhc3NlcyBhcmUgaW5pdGlhbGl6ZWQuXHJcblxyXG4vKlxyXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuKiBFQVNJTkdcclxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiovXHJcbl9lYXNlTWFwID0ge30sXHJcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxyXG4gICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxyXG4gICAgX3BhcnNlT2JqZWN0SW5TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPYmplY3RJblN0cmluZyh2YWx1ZSkge1xyXG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxyXG4gIHZhciBvYmogPSB7fSxcclxuICAgICAgc3BsaXQgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMykuc3BsaXQoXCI6XCIpLFxyXG4gICAgICBrZXkgPSBzcGxpdFswXSxcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGwgPSBzcGxpdC5sZW5ndGgsXHJcbiAgICAgIGluZGV4LFxyXG4gICAgICB2YWwsXHJcbiAgICAgIHBhcnNlZFZhbDtcclxuXHJcbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhbCA9IHNwbGl0W2ldO1xyXG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xyXG4gICAgcGFyc2VkVmFsID0gdmFsLnN1YnN0cigwLCBpbmRleCk7XHJcbiAgICBvYmpba2V5XSA9IGlzTmFOKHBhcnNlZFZhbCkgPyBwYXJzZWRWYWwucmVwbGFjZShfcXVvdGVzRXhwLCBcIlwiKS50cmltKCkgOiArcGFyc2VkVmFsO1xyXG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn0sXHJcbiAgICBfdmFsdWVJblBhcmVudGhlc2VzID0gZnVuY3Rpb24gX3ZhbHVlSW5QYXJlbnRoZXNlcyh2YWx1ZSkge1xyXG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxyXG4gICAgICBjbG9zZSA9IHZhbHVlLmluZGV4T2YoXCIpXCIpLFxyXG4gICAgICBuZXN0ZWQgPSB2YWx1ZS5pbmRleE9mKFwiKFwiLCBvcGVuKTtcclxuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xyXG59LFxyXG4gICAgX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nKG5hbWUpIHtcclxuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXHJcbiAgdmFyIHNwbGl0ID0gKG5hbWUgKyBcIlwiKS5zcGxpdChcIihcIiksXHJcbiAgICAgIGVhc2UgPSBfZWFzZU1hcFtzcGxpdFswXV07XHJcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XHJcbn0sXHJcbiAgICBfaW52ZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnZlcnRFYXNlKGVhc2UpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcclxuICAgIHJldHVybiAxIC0gZWFzZSgxIC0gcCk7XHJcbiAgfTtcclxufSxcclxuICAgIC8vIGFsbG93IHlveW9FYXNlIHRvIGJlIHNldCBpbiBjaGlsZHJlbiBhbmQgaGF2ZSB0aG9zZSBhZmZlY3RlZCB3aGVuIHRoZSBwYXJlbnQvYW5jZXN0b3IgdGltZWxpbmUgeW95b3MuXHJcbl9wcm9wYWdhdGVZb3lvRWFzZSA9IGZ1bmN0aW9uIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKSB7XHJcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxyXG4gICAgICBlYXNlO1xyXG5cclxuICB3aGlsZSAoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XHJcbiAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZCwgaXNZb3lvKTtcclxuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XHJcbiAgICAgIGlmIChjaGlsZC50aW1lbGluZSkge1xyXG4gICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZShjaGlsZC50aW1lbGluZSwgaXNZb3lvKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlYXNlID0gY2hpbGQuX2Vhc2U7XHJcbiAgICAgICAgY2hpbGQuX2Vhc2UgPSBjaGlsZC5feUVhc2U7XHJcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcclxuICAgICAgICBjaGlsZC5feW95byA9IGlzWW95bztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XHJcbiAgfVxyXG59LFxyXG4gICAgX3BhcnNlRWFzZSA9IGZ1bmN0aW9uIF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcclxuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xyXG59LFxyXG4gICAgX2luc2VydEVhc2UgPSBmdW5jdGlvbiBfaW5zZXJ0RWFzZShuYW1lcywgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQpIHtcclxuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XHJcbiAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XHJcbiAgICAgIHJldHVybiAxIC0gZWFzZUluKDEgLSBwKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcclxuICAgIGVhc2VJbk91dCA9IGZ1bmN0aW9uIGVhc2VJbk91dChwKSB7XHJcbiAgICAgIHJldHVybiBwIDwgLjUgPyBlYXNlSW4ocCAqIDIpIC8gMiA6IDEgLSBlYXNlSW4oKDEgLSBwKSAqIDIpIC8gMjtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB2YXIgZWFzZSA9IHtcclxuICAgIGVhc2VJbjogZWFzZUluLFxyXG4gICAgZWFzZU91dDogZWFzZU91dCxcclxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XHJcbiAgfSxcclxuICAgICAgbG93ZXJjYXNlTmFtZTtcclxuXHJcbiAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XHJcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XHJcblxyXG4gICAgZm9yICh2YXIgcCBpbiBlYXNlKSB7XHJcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZWFzZTtcclxufSxcclxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xyXG4gICAgcmV0dXJuIHAgPCAuNSA/ICgxIC0gZWFzZU91dCgxIC0gcCAqIDIpKSAvIDIgOiAuNSArIGVhc2VPdXQoKHAgLSAuNSkgKiAyKSAvIDI7XHJcbiAgfTtcclxufSxcclxuICAgIF9jb25maWdFbGFzdGljID0gZnVuY3Rpb24gX2NvbmZpZ0VsYXN0aWModHlwZSwgYW1wbGl0dWRlLCBwZXJpb2QpIHtcclxuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXHJcbiAgICAgIC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXHJcbiAgcDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXHJcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxyXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XHJcbiAgICByZXR1cm4gcCA9PT0gMSA/IDEgOiBwMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogX3NpbigocCAtIHAzKSAqIHAyKSArIDE7XHJcbiAgfSxcclxuICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcclxuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XHJcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xyXG5cclxuICBwMiA9IF8yUEkgLyBwMjsgLy9wcmVjYWxjdWxhdGUgdG8gb3B0aW1pemVcclxuXHJcbiAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAoYW1wbGl0dWRlLCBwZXJpb2QpIHtcclxuICAgIHJldHVybiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGVhc2U7XHJcbn0sXHJcbiAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xyXG4gIGlmIChvdmVyc2hvb3QgPT09IHZvaWQgMCkge1xyXG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcclxuICB9XHJcblxyXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XHJcbiAgICByZXR1cm4gcCA/IC0tcCAqIHAgKiAoKG92ZXJzaG9vdCArIDEpICogcCArIG92ZXJzaG9vdCkgKyAxIDogMDtcclxuICB9LFxyXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xyXG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcclxuICB9IDogX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCk7XHJcblxyXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKG92ZXJzaG9vdCkge1xyXG4gICAgcmV0dXJuIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIGVhc2U7XHJcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cclxuLy8gX3dlaWdodGVkRWFzZSA9IHJhdGlvID0+IHtcclxuLy8gXHRsZXQgeSA9IDAuNSArIHJhdGlvIC8gMjtcclxuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcclxuLy8gfSxcclxuLy8gYSBzdHJvbmdlciAoYnV0IG1vcmUgZXhwZW5zaXZlIGtiL2NwdSkgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIHRoYXQgbGV0cyB5b3UgZmVlZCBpbiBhIHZhbHVlIGJldHdlZW4gLTEgKGVhc2VJbikgYW5kIDEgKGVhc2VPdXQpIHdoZXJlIDAgaXMgbGluZWFyLlxyXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xyXG4vLyBcdHJhdGlvID0gLjUgKyByYXRpbyAvIDI7XHJcbi8vIFx0bGV0IG8gPSAxIC8gMyAqIChyYXRpbyA8IC41ID8gcmF0aW8gOiAxIC0gcmF0aW8pLFxyXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcclxuLy8gXHRcdGMgPSByYXRpbyArIG87XHJcbi8vIFx0cmV0dXJuIHAgPT4gcCA9PT0gMSA/IHAgOiAzICogYiAqICgxIC0gcCkgKiAoMSAtIHApICogcCArIDMgKiBjICogKDEgLSBwKSAqIHAgKiBwICsgcCAqIHAgKiBwO1xyXG4vLyB9O1xyXG5cclxuXHJcbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xyXG4gIHZhciBwb3dlciA9IGkgPCA1ID8gaSArIDEgOiBpO1xyXG5cclxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcclxuICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XHJcbiAgfSA6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gcDtcclxuICB9LCBmdW5jdGlvbiAocCkge1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gcCwgcG93ZXIpO1xyXG4gIH0sIGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuX2Vhc2VNYXAuTGluZWFyLmVhc2VOb25lID0gX2Vhc2VNYXAubm9uZSA9IF9lYXNlTWFwLkxpbmVhci5lYXNlSW47XHJcblxyXG5faW5zZXJ0RWFzZShcIkVsYXN0aWNcIiwgX2NvbmZpZ0VsYXN0aWMoXCJpblwiKSwgX2NvbmZpZ0VsYXN0aWMoXCJvdXRcIiksIF9jb25maWdFbGFzdGljKCkpO1xyXG5cclxuKGZ1bmN0aW9uIChuLCBjKSB7XHJcbiAgdmFyIG4xID0gMSAvIGMsXHJcbiAgICAgIG4yID0gMiAqIG4xLFxyXG4gICAgICBuMyA9IDIuNSAqIG4xLFxyXG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XHJcbiAgICByZXR1cm4gcCA8IG4xID8gbiAqIHAgKiBwIDogcCA8IG4yID8gbiAqIE1hdGgucG93KHAgLSAxLjUgLyBjLCAyKSArIC43NSA6IHAgPCBuMyA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogTWF0aC5wb3cocCAtIDIuNjI1IC8gYywgMikgKyAuOTg0Mzc1O1xyXG4gIH07XHJcblxyXG4gIF9pbnNlcnRFYXNlKFwiQm91bmNlXCIsIGZ1bmN0aW9uIChwKSB7XHJcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xyXG4gIH0sIGVhc2VPdXQpO1xyXG59KSg3LjU2MjUsIDIuNzUpO1xyXG5cclxuX2luc2VydEVhc2UoXCJFeHBvXCIsIGZ1bmN0aW9uIChwKSB7XHJcbiAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgKiBwICsgcCAqIHAgKiBwICogcCAqIHAgKiBwICogKDEgLSBwKTtcclxufSk7IC8vIHByZXZpb3VzbHkgMiAqKiAoMTAgKiAocCAtIDEpKSBidXQgdGhhdCBkb2Vzbid0IGVuZCB1cCB3aXRoIHRoZSB2YWx1ZSBxdWl0ZSBhdCB0aGUgcmlnaHQgc3BvdCBzbyB3ZSBkbyBhIGJsZW5kZWQgZWFzZSB0byBlbnN1cmUgaXQgbGFuZHMgd2hlcmUgaXQgc2hvdWxkIHBlcmZlY3RseS5cclxuXHJcblxyXG5faW5zZXJ0RWFzZShcIkNpcmNcIiwgZnVuY3Rpb24gKHApIHtcclxuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XHJcbn0pO1xyXG5cclxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XHJcbiAgcmV0dXJuIHAgPT09IDEgPyAxIDogLV9jb3MocCAqIF9IQUxGX1BJKSArIDE7XHJcbn0pO1xyXG5cclxuX2luc2VydEVhc2UoXCJCYWNrXCIsIF9jb25maWdCYWNrKFwiaW5cIiksIF9jb25maWdCYWNrKFwib3V0XCIpLCBfY29uZmlnQmFjaygpKTtcclxuXHJcbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcclxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcclxuICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ZXBzID0gMTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXHJcbiAgICAgICAgcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKSxcclxuICAgICAgICBwMyA9IGltbWVkaWF0ZVN0YXJ0ID8gMSA6IDAsXHJcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgIHJldHVybiAoKHAyICogX2NsYW1wKDAsIG1heCwgcCkgfCAwKSArIHAzKSAqIHAxO1xyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcclxuXHJcbl9mb3JFYWNoTmFtZShcIm9uQ29tcGxldGUsb25VcGRhdGUsb25TdGFydCxvblJlcGVhdCxvblJldmVyc2VDb21wbGV0ZSxvbkludGVycnVwdFwiLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XHJcbn0pO1xyXG4vKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBDQUNIRVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xyXG4gIHRoaXMuaWQgPSBfZ3NJRCsrO1xyXG4gIHRhcmdldC5fZ3NhcCA9IHRoaXM7XHJcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcclxuICB0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcclxuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XHJcbn07XHJcbi8qXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIEFOSU1BVElPTlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcbmV4cG9ydCB2YXIgQW5pbWF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xyXG4gICAgdGhpcy52YXJzID0gdmFycztcclxuICAgIHRoaXMuX2RlbGF5ID0gK3ZhcnMuZGVsYXkgfHwgMDtcclxuXHJcbiAgICBpZiAodGhpcy5fcmVwZWF0ID0gdmFycy5yZXBlYXQgPT09IEluZmluaXR5ID8gLTIgOiB2YXJzLnJlcGVhdCB8fCAwKSB7XHJcbiAgICAgIC8vIFRPRE86IHJlcGVhdDogSW5maW5pdHkgb24gYSB0aW1lbGluZSdzIGNoaWxkcmVuIG11c3QgZmxhZyB0aGF0IHRpbWVsaW5lIGludGVybmFsbHkgYW5kIGFmZmVjdCBpdHMgdG90YWxEdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHN0b3AgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiB3aGVuIHJlYWNoaW5nIHRoZSBzdGFydC5cclxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xyXG4gICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3RzID0gMTtcclxuXHJcbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcclxuXHJcbiAgICBpZiAoX2NvbnRleHQpIHtcclxuICAgICAgdGhpcy5fY3R4ID0gX2NvbnRleHQ7XHJcblxyXG4gICAgICBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcclxuICB9XHJcblxyXG4gIHZhciBfcHJvdG8gPSBBbmltYXRpb24ucHJvdG90eXBlO1xyXG5cclxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlIHx8IHZhbHVlID09PSAwKSB7XHJcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0ICsgdmFsdWUgLSB0aGlzLl9kZWxheSk7XHJcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9kZWxheTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsRHVyYXRpb24odGhpcy5fcmVwZWF0ID4gMCA/IHZhbHVlICsgKHZhbHVlICsgdGhpcy5fckRlbGF5KSAqIHRoaXMuX3JlcGVhdCA6IHZhbHVlKSA6IHRoaXMudG90YWxEdXJhdGlvbigpICYmIHRoaXMuX2R1cjtcclxuICB9O1xyXG5cclxuICBfcHJvdG8udG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdER1cjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kaXJ0eSA9IDA7XHJcbiAgICByZXR1cm4gX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX3JlcGVhdCA8IDAgPyB2YWx1ZSA6ICh2YWx1ZSAtIHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JEZWxheSkgLyAodGhpcy5fcmVwZWF0ICsgMSkpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpIHtcclxuICAgIF93YWtlKCk7XHJcblxyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XHJcblxyXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5fdHMpIHtcclxuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XHJcblxyXG4gICAgICAhcGFyZW50Ll9kcCB8fCBwYXJlbnQucGFyZW50IHx8IF9wb3N0QWRkQ2hlY2tzKHBhcmVudCwgdGhpcyk7IC8vIGVkZ2UgY2FzZTogaWYgdGhpcyBpcyBhIGNoaWxkIG9mIGEgdGltZWxpbmUgdGhhdCBhbHJlYWR5IGNvbXBsZXRlZCwgZm9yIGV4YW1wbGUsIHdlIG11c3QgcmUtYWN0aXZhdGUgdGhlIHBhcmVudC5cclxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXHJcblxyXG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnQpIHtcclxuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcclxuICAgICAgICAgIHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuX2RwLmF1dG9SZW1vdmVDaGlsZHJlbiAmJiAodGhpcy5fdHMgPiAwICYmIF90b3RhbFRpbWUgPCB0aGlzLl90RHVyIHx8IHRoaXMuX3RzIDwgMCAmJiBfdG90YWxUaW1lID4gMCB8fCAhdGhpcy5fdER1ciAmJiAhX3RvdGFsVGltZSkpIHtcclxuICAgICAgICAvL2lmIHRoZSBhbmltYXRpb24gZG9lc24ndCBoYXZlIGEgcGFyZW50LCBwdXQgaXQgYmFjayBpbnRvIGl0cyBsYXN0IHBhcmVudCAocmVjb3JkZWQgYXMgX2RwIGZvciBleGFjdGx5IGNhc2VzIGxpa2UgdGhpcykuIExpbWl0IHRvIHBhcmVudHMgd2l0aCBhdXRvUmVtb3ZlQ2hpbGRyZW4gKGxpa2UgZ2xvYmFsVGltZWxpbmUpIHNvIHRoYXQgaWYgdGhlIHVzZXIgbWFudWFsbHkgcmVtb3ZlcyBhbiBhbmltYXRpb24gZnJvbSBhIHRpbWVsaW5lIGFuZCB0aGVuIGFsdGVycyBpdHMgcGxheWhlYWQsIGl0IGRvZXNuJ3QgZ2V0IGFkZGVkIGJhY2sgaW4uXHJcbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3RUaW1lICE9PSBfdG90YWxUaW1lIHx8ICF0aGlzLl9kdXIgJiYgIXN1cHByZXNzRXZlbnRzIHx8IHRoaXMuX2luaXR0ZWQgJiYgTWF0aC5hYnModGhpcy5felRpbWUpID09PSBfdGlueU51bSB8fCAhX3RvdGFsVGltZSAmJiAhdGhpcy5faW5pdHRlZCAmJiAodGhpcy5hZGQgfHwgdGhpcy5fcHRMb29rdXApKSB7XHJcbiAgICAgIC8vIGNoZWNrIGZvciBfcHRMb29rdXAgb24gYSBUd2VlbiBpbnN0YW5jZSB0byBlbnN1cmUgaXQgaGFzIGFjdHVhbGx5IGZpbmlzaGVkIGJlaW5nIGluc3RhbnRpYXRlZCwgb3RoZXJ3aXNlIGlmIHRoaXMucmV2ZXJzZSgpIGdldHMgY2FsbGVkIGluIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIGl0IGNvdWxkIHRyaWdnZXIgYSByZW5kZXIoKSBoZXJlIGV2ZW4gdGhvdWdoIHRoZSBfdGFyZ2V0cyB3ZXJlbid0IHBvcHVsYXRlZCwgdGh1cyB3aGVuIF9pbml0KCkgaXMgY2FsbGVkIHRoZXJlIHdvbid0IGJlIGFueSBQcm9wVHdlZW5zIChpdCdsbCBhY3QgbGlrZSB0aGUgdHdlZW4gaXMgbm9uLWZ1bmN0aW9uYWwpXHJcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxyXG4gICAgICAvL2lmICghdGhpcy5fbG9jaykgeyAvLyBhdm9pZCBlbmRsZXNzIHJlY3Vyc2lvbiAobm90IHN1cmUgd2UgbmVlZCB0aGlzIHlldCBvciBpZiBpdCdzIHdvcnRoIHRoZSBwZXJmb3JtYW5jZSBoaXQpXHJcbiAgICAgIC8vICAgdGhpcy5fbG9jayA9IDE7XHJcblxyXG4gICAgICBfbGF6eVNhZmVSZW5kZXIodGhpcywgX3RvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMpOyAvLyAgIHRoaXMuX2xvY2sgPSAwO1xyXG4gICAgICAvL31cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZShNYXRoLm1pbih0aGlzLnRvdGFsRHVyYXRpb24oKSwgdmFsdWUgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcykpICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgfHwgKHZhbHVlID8gdGhpcy5fZHVyIDogMCksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3RpbWU7IC8vIG5vdGU6IGlmIHRoZSBtb2R1bHVzIHJlc3VsdHMgaW4gMCwgdGhlIHBsYXloZWFkIGNvdWxkIGJlIGV4YWN0bHkgYXQgdGhlIGVuZCBvciB0aGUgYmVnaW5uaW5nLCBhbmQgd2UgYWx3YXlzIGRlZmVyIHRvIHRoZSBFTkQgd2l0aCBhIG5vbi16ZXJvIHZhbHVlLCBvdGhlcndpc2UgaWYgeW91IHNldCB0aGUgdGltZSgpIHRvIHRoZSB2ZXJ5IGVuZCAoZHVyYXRpb24oKSksIGl0IHdvdWxkIHJlbmRlciBhdCB0aGUgU1RBUlQhXHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0b3RhbFByb2dyZXNzKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RUaW1lIC8gdGhpcy5fdER1cikgOiB0aGlzLnJhd1RpbWUoKSA+PSAwICYmIHRoaXMuX2luaXR0ZWQgPyAxIDogMDtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXdUaW1lKCkgPiAwID8gMSA6IDA7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLml0ZXJhdGlvbiA9IGZ1bmN0aW9uIGl0ZXJhdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcclxuICAgIHZhciBjeWNsZUR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpICsgdGhpcy5fckRlbGF5O1xyXG5cclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZSArICh2YWx1ZSAtIDEpICogY3ljbGVEdXJhdGlvbiwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5fcmVwZWF0ID8gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKSArIDEgOiAxO1xyXG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBhZGRpdGlvbjpcclxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XHJcbiAgLy8gXHRsZXQgYW5pbWF0aW9uID0gdGhpcyxcclxuICAvLyBcdFx0b3JpZW50YXRpb24gPSAxOyAvLyAxID0gZm9yd2FyZCwgLTEgPSBiYWNrd2FyZFxyXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xyXG4gIC8vIFx0XHRvcmllbnRhdGlvbiAqPSBhbmltYXRpb24ucmV2ZXJzZWQoKSB8fCAoYW5pbWF0aW9uLnJlcGVhdCgpICYmICEoYW5pbWF0aW9uLml0ZXJhdGlvbigpICYgMSkpID8gLTEgOiAxO1xyXG4gIC8vIFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24ucGFyZW50O1xyXG4gIC8vIFx0fVxyXG4gIC8vIFx0cmV0dXJuIG9yaWVudGF0aW9uIDwgMDtcclxuICAvLyB9XHJcbiAgO1xyXG5cclxuICBfcHJvdG8udGltZVNjYWxlID0gZnVuY3Rpb24gdGltZVNjYWxlKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7IC8vIG1ha2Ugc3VyZSB0byBkbyB0aGUgcGFyZW50VG9DaGlsZFRvdGFsVGltZSgpIEJFRk9SRSBzZXR0aW5nIHRoZSBuZXcgX3RzIGJlY2F1c2UgdGhlIG9sZCBvbmUgbXVzdCBiZSB1c2VkIGluIHRoYXQgY2FsY3VsYXRpb24uXHJcbiAgICAvLyBmdXR1cmUgYWRkaXRpb24/IFVwIHNpZGU6IGZhc3QgYW5kIG1pbmltYWwgZmlsZSBzaXplLiBEb3duIHNpZGU6IG9ubHkgd29ya3Mgb24gdGhpcyBhbmltYXRpb247IGlmIGEgdGltZWxpbmUgaXMgcmV2ZXJzZWQsIGZvciBleGFtcGxlLCBpdHMgY2hpbGRyZW5zJyBvblJldmVyc2Ugd291bGRuJ3QgZ2V0IGNhbGxlZC5cclxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcclxuICAgIC8vIHByaW9yaXRpemUgcmVuZGVyaW5nIHdoZXJlIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBsaW5lcyB1cCBpbnN0ZWFkIG9mIHRoaXMuX3RUaW1lIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgYSB0d2VlbiB0aGF0J3MgYW5pbWF0aW5nIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgaW4gdGhlIHNhbWUgcmVuZGVyaW5nIGxvb3AgKHNhbWUgcGFyZW50KSwgdGh1cyBpZiB0aGUgdGltZVNjYWxlIHR3ZWVuIHJlbmRlcnMgZmlyc3QsIGl0IHdvdWxkIGFsdGVyIF9zdGFydCBCRUZPUkUgX3RUaW1lIHdhcyBzZXQgb24gdGhhdCB0aWNrIChpbiB0aGUgcmVuZGVyaW5nIGxvb3ApLCBlZmZlY3RpdmVseSBmcmVlemluZyBpdCB1bnRpbCB0aGUgdGltZVNjYWxlIHR3ZWVuIGZpbmlzaGVzLlxyXG5cclxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xyXG4gICAgdGhpcy5fdHMgPSB0aGlzLl9wcyB8fCB2YWx1ZSA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0czsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSB3aGljaCB3b3VsZCBiZSAwIGlmIHRoZSBhbmltYXRpb24gaXMgcGF1c2VkLlxyXG5cclxuICAgIHRoaXMudG90YWxUaW1lKF9jbGFtcCgtTWF0aC5hYnModGhpcy5fZGVsYXkpLCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgdFRpbWUpLCBzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpO1xyXG5cclxuICAgIF9zZXRFbmQodGhpcyk7IC8vIGlmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyB3YXMgZmFsc2UsIHRoZSBlbmQgdGltZSBkaWRuJ3QgZ2V0IHVwZGF0ZWQgaW4gdGhlIF9hbGlnblBsYXloZWFkKCkgbWV0aG9kLCBzbyBkbyBpdCBoZXJlLlxyXG5cclxuXHJcbiAgICByZXR1cm4gX3JlY2FjaGVBbmNlc3RvcnModGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCh2YWx1ZSkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wcztcclxuICAgIH0gLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIC0gaWYgYW4gYW5pbWF0aW9uIGlzIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCB0aGVuIC5yZXN0YXJ0KCkgb3IgLnBsYXkoKSBvciAucmVzdW1lKCkgaXMgY2FsbGVkLCBwZXJoYXBzIHdlIHNob3VsZCBmb3JjZSBpdCBiYWNrIGludG8gdGhlIGdsb2JhbFRpbWVsaW5lIGJ1dCBiZSBjYXJlZnVsIGJlY2F1c2Ugd2hhdCBpZiBpdCdzIGFscmVhZHkgYXQgaXRzIGVuZD8gV2UgZG9uJ3Qgd2FudCBpdCB0byBqdXN0IHBlcnNpc3QgZm9yZXZlciBhbmQgbm90IGdldCByZWxlYXNlZCBmb3IgR0MuXHJcbiAgICAvLyAhdGhpcy5wYXJlbnQgJiYgIXZhbHVlICYmIHRoaXMuX3RUaW1lIDwgdGhpcy5fdER1ciAmJiB0aGlzICE9PSBfZ2xvYmFsVGltZWxpbmUgJiYgX2dsb2JhbFRpbWVsaW5lLmFkZCh0aGlzKTtcclxuXHJcblxyXG4gICAgaWYgKHRoaXMuX3BzICE9PSB2YWx1ZSkge1xyXG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xyXG5cclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXHJcblxyXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fYWN0ID0gMDsgLy8gX3RzIGlzIHRoZSBmdW5jdGlvbmFsIHRpbWVTY2FsZSwgc28gYSBwYXVzZWQgdHdlZW4gd291bGQgZWZmZWN0aXZlbHkgaGF2ZSBhIHRpbWVTY2FsZSBvZiAwLiBXZSByZWNvcmQgdGhlIFwicmVhbFwiIHRpbWVTY2FsZSBhcyBfcnRzIChyZWNvcmRlZCB0aW1lIHNjYWxlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF93YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXHJcblxyXG4gICAgICAgIHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsIHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkpOyAvLyBlZGdlIGNhc2U6IGFuaW1hdGlvbi5wcm9ncmVzcygxKS5wYXVzZSgpLnBsYXkoKSB3b3VsZG4ndCByZW5kZXIgYWdhaW4gYmVjYXVzZSB0aGUgcGxheWhlYWQgaXMgYWxyZWFkeSBhdCB0aGUgZW5kLCBidXQgdGhlIGNhbGwgdG8gdG90YWxUaW1lKCkgYmVsb3cgd2lsbCBhZGQgaXQgYmFjayB0byBpdHMgcGFyZW50Li4uYW5kIG5vdCByZW1vdmUgaXQgYWdhaW4gKHNpbmNlIHJlbW92aW5nIG9ubHkgaGFwcGVucyB1cG9uIHJlbmRlcmluZyBhdCBhIG5ldyB0aW1lKS4gT2Zmc2V0dGluZyB0aGUgX3RUaW1lIHNsaWdodGx5IGlzIGRvbmUgc2ltcGx5IHRvIGNhdXNlIHRoZSBmaW5hbCByZW5kZXIgaW4gdG90YWxUaW1lKCkgdGhhdCdsbCBwb3AgaXQgb2ZmIGl0cyB0aW1lbGluZSAoaWYgYXV0b1JlbW92ZUNoaWxkcmVuIGlzIHRydWUsIG9mIGNvdXJzZSkuIENoZWNrIHRvIG1ha2Ugc3VyZSBfelRpbWUgaXNuJ3QgLV90aW55TnVtIHRvIGF2b2lkIGFuIGVkZ2UgY2FzZSB3aGVyZSB0aGUgcGxheWhlYWQgaXMgcHVzaGVkIHRvIHRoZSBlbmQgYnV0IElOU0lERSBhIHR3ZWVuL2NhbGxiYWNrLCB0aGUgdGltZWxpbmUgaXRzZWxmIGlzIHBhdXNlZCB0aHVzIGhhbHRpbmcgcmVuZGVyaW5nIGFuZCBsZWF2aW5nIGEgZmV3IHVucmVuZGVyZWQuIFdoZW4gcmVzdW1pbmcsIGl0IHdvdWxkbid0IHJlbmRlciB0aG9zZSBvdGhlcndpc2UuXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xyXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XHJcbiAgICAgIHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0O1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5lbmRUaW1lID0gZnVuY3Rpb24gZW5kVGltZShpbmNsdWRlUmVwZWF0cykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xyXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwOyAvLyBfZHAgPSBkZXRhY2hlZCBwYXJlbnRcclxuXHJcbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGNvbmZpZyA9IF9yZXZlcnRDb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByZXZJc1JldmVydGluZyA9IF9yZXZlcnRpbmc7XHJcbiAgICBfcmV2ZXJ0aW5nID0gY29uZmlnO1xyXG5cclxuICAgIGlmIChfaXNSZXZlcnRXb3J0aHkodGhpcykpIHtcclxuICAgICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLnJldmVydChjb25maWcpO1xyXG4gICAgICB0aGlzLnRvdGFsVGltZSgtMC4wMSwgY29uZmlnLnN1cHByZXNzRXZlbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmRhdGEgIT09IFwibmVzdGVkXCIgJiYgY29uZmlnLmtpbGwgIT09IGZhbHNlICYmIHRoaXMua2lsbCgpO1xyXG4gICAgX3JldmVydGluZyA9IHByZXZJc1JldmVydGluZztcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XHJcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcyxcclxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xyXG5cclxuICAgIHdoaWxlIChhbmltYXRpb24pIHtcclxuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKE1hdGguYWJzKGFuaW1hdGlvbi5fdHMpIHx8IDEpO1xyXG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAhdGhpcy5wYXJlbnQgJiYgdGhpcy5fc2F0ID8gdGhpcy5fc2F0Lmdsb2JhbFRpbWUocmF3VGltZSkgOiB0aW1lOyAvLyB0aGUgX3N0YXJ0QXQgdHdlZW5zIGZvciAuZnJvbVRvKCkgYW5kIC5mcm9tKCkgdGhhdCBoYXZlIGltbWVkaWF0ZVJlbmRlciBzaG91bGQgYWx3YXlzIGJlIEZJUlNUIGluIHRoZSB0aW1lbGluZSAoaW1wb3J0YW50IGZvciBjb250ZXh0LnJldmVydCgpKS4gXCJfc2F0XCIgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuLCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCB0d2VlbiB0aGF0IGNyZWF0ZWQgdGhlIF9zdGFydEF0LiBXZSBtdXN0IGRpc2Nlcm4gaWYgdGhhdCB0d2VlbiBoYWQgaW1tZWRpYXRlUmVuZGVyIHNvIHRoYXQgd2UgY2FuIGtub3cgd2hldGhlciBvciBub3QgdG8gcHJpb3JpdGl6ZSBpdCBpbiByZXZlcnQoKS5cclxuICB9O1xyXG5cclxuICBfcHJvdG8ucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9yZXBlYXQgPSB2YWx1ZSA9PT0gSW5maW5pdHkgPyAtMiA6IHZhbHVlO1xyXG4gICAgICByZXR1cm4gX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5yZXBlYXREZWxheSA9IGZ1bmN0aW9uIHJlcGVhdERlbGF5KHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICB2YXIgdGltZSA9IHRoaXMuX3RpbWU7XHJcbiAgICAgIHRoaXMuX3JEZWxheSA9IHZhbHVlO1xyXG5cclxuICAgICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbih0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xyXG4gIH07XHJcblxyXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5feW95byA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5feW95bztcclxuICB9O1xyXG5cclxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5yZXN0YXJ0ID0gZnVuY3Rpb24gcmVzdGFydChpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XHJcbiAgICB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcclxuICAgIHRoaXMuX2R1ciB8fCAodGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBlbnN1cmVzIG9uQ29tcGxldGUgZmlyZXMgb24gYSB6ZXJvLWR1cmF0aW9uIGFuaW1hdGlvbiB0aGF0IGdldHMgcmVzdGFydGVkLlxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheShmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xyXG4gICAgZnJvbSAhPSBudWxsICYmIHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XHJcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcclxuICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xyXG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ucGF1c2UgPSBmdW5jdGlvbiBwYXVzZShhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XHJcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XHJcbiAgICByZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLnJldmVyc2VkID0gZnVuY3Rpb24gcmV2ZXJzZWQodmFsdWUpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTsgLy8gaW4gY2FzZSB0aW1lU2NhbGUgaXMgemVybywgcmV2ZXJzaW5nIHdvdWxkIGhhdmUgbm8gZWZmZWN0IHNvIHdlIHVzZSBfdGlueU51bS5cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcclxuICAgIHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9hY3QgPSAwO1xyXG4gICAgdGhpcy5felRpbWUgPSAtX3RpbnlOdW07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcCxcclxuICAgICAgICBzdGFydCA9IHRoaXMuX3N0YXJ0LFxyXG4gICAgICAgIHJhd1RpbWU7XHJcbiAgICByZXR1cm4gISEoIXBhcmVudCB8fCB0aGlzLl90cyAmJiB0aGlzLl9pbml0dGVkICYmIHBhcmVudC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gcGFyZW50LnJhd1RpbWUodHJ1ZSkpID49IHN0YXJ0ICYmIHJhd1RpbWUgPCB0aGlzLmVuZFRpbWUodHJ1ZSkgLSBfdGlueU51bSk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcclxuICAgIHZhciB2YXJzID0gdGhpcy52YXJzO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyc1t0eXBlXSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xyXG4gICAgICAgIHR5cGUgPT09IFwib25VcGRhdGVcIiAmJiAodGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YXJzW3R5cGVdO1xyXG4gIH07XHJcblxyXG4gIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgIHZhciBmID0gX2lzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBfcGFzc1Rocm91Z2gsXHJcbiAgICAgICAgICBfcmVzb2x2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlKCkge1xyXG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcclxuICAgICAgICBzZWxmLnRoZW4gPSBudWxsOyAvLyB0ZW1wb3JhcmlseSBudWxsIHRoZSB0aGVuKCkgbWV0aG9kIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzMyMilcclxuXHJcbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XHJcbiAgICAgICAgcmVzb2x2ZShmKTtcclxuICAgICAgICBzZWxmLnRoZW4gPSBfdGhlbjtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xyXG4gICAgICAgIF9yZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8ua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XHJcbiAgICBfaW50ZXJydXB0KHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBBbmltYXRpb247XHJcbn0oKTtcclxuXHJcbl9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XHJcbiAgX3RpbWU6IDAsXHJcbiAgX3N0YXJ0OiAwLFxyXG4gIF9lbmQ6IDAsXHJcbiAgX3RUaW1lOiAwLFxyXG4gIF90RHVyOiAwLFxyXG4gIF9kaXJ0eTogMCxcclxuICBfcmVwZWF0OiAwLFxyXG4gIF95b3lvOiBmYWxzZSxcclxuICBwYXJlbnQ6IG51bGwsXHJcbiAgX2luaXR0ZWQ6IGZhbHNlLFxyXG4gIF9yRGVsYXk6IDAsXHJcbiAgX3RzOiAxLFxyXG4gIF9kcDogMCxcclxuICByYXRpbzogMCxcclxuICBfelRpbWU6IC1fdGlueU51bSxcclxuICBfcHJvbTogMCxcclxuICBfcHM6IGZhbHNlLFxyXG4gIF9ydHM6IDFcclxufSk7XHJcbi8qXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogVElNRUxJTkVcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFRpbWVsaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uKSB7XHJcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xyXG5cclxuICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCBwb3NpdGlvbikge1xyXG4gICAgdmFyIF90aGlzO1xyXG5cclxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcclxuICAgICAgdmFycyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMpIHx8IHRoaXM7XHJcbiAgICBfdGhpcy5sYWJlbHMgPSB7fTtcclxuICAgIF90aGlzLnNtb290aENoaWxkVGltaW5nID0gISF2YXJzLnNtb290aENoaWxkVGltaW5nO1xyXG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcclxuICAgIF90aGlzLl9zb3J0ID0gX2lzTm90RmFsc2UodmFycy5zb3J0Q2hpbGRyZW4pO1xyXG4gICAgX2dsb2JhbFRpbWVsaW5lICYmIF9hZGRUb1RpbWVsaW5lKHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHBvc2l0aW9uKTtcclxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMucmV2ZXJzZSgpO1xyXG4gICAgdmFycy5wYXVzZWQgJiYgX3RoaXMucGF1c2VkKHRydWUpO1xyXG4gICAgdmFycy5zY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCB2YXJzLnNjcm9sbFRyaWdnZXIpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XHJcblxyXG4gIF9wcm90bzIudG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xyXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcclxuICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBfcHJvdG8yLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzLCBwb3NpdGlvbikge1xyXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMsIHRoaXMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XHJcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcclxuICAgIHZhcnMucGFyZW50ID0gdGhpcztcclxuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XHJcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XHJcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pLCAxKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2ssIHBhcmFtcywgcG9zaXRpb24pIHtcclxuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgcG9zaXRpb24pO1xyXG4gIH0gLy9PTkxZIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5ISBNYXliZSBkZWxldGU/XHJcbiAgO1xyXG5cclxuICBfcHJvdG8yLnN0YWdnZXJUbyA9IGZ1bmN0aW9uIHN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcclxuICAgIHZhcnMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xyXG4gICAgdmFycy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZUFsbDtcclxuICAgIHZhcnMub25Db21wbGV0ZVBhcmFtcyA9IG9uQ29tcGxldGVBbGxQYXJhbXM7XHJcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XHJcbiAgICBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcclxuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcclxuICAgIF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24gc3RhZ2dlckZyb21Ubyh0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcclxuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XHJcbiAgICBfaW5oZXJpdERlZmF1bHRzKHRvVmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodG9WYXJzLmltbWVkaWF0ZVJlbmRlcik7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XHJcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxyXG4gICAgICAgIHREdXIgPSB0aGlzLl9kaXJ0eSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5fdER1cixcclxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXHJcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPD0gMCA/IDAgOiBfcm91bmRQcmVjaXNlKHRvdGFsVGltZSksXHJcbiAgICAgICAgLy8gaWYgYSBwYXVzZWQgdGltZWxpbmUgaXMgcmVzdW1lZCAob3IgaXRzIF9zdGFydCBpcyB1cGRhdGVkIGZvciBhbm90aGVyIHJlYXNvbi4uLndoaWNoIHJvdW5kcyBpdCksIHRoYXQgY291bGQgcmVzdWx0IGluIHRoZSBwbGF5aGVhZCBzaGlmdGluZyBhICoqdGlueSoqIGFtb3VudCBhbmQgYSB6ZXJvLWR1cmF0aW9uIGNoaWxkIGF0IHRoYXQgc3BvdCBtYXkgZ2V0IHJlbmRlcmVkIGF0IGEgZGlmZmVyZW50IHJhdGlvLCBsaWtlIGl0cyB0b3RhbFRpbWUgaW4gcmVuZGVyKCkgbWF5IGJlIDFlLTE3IGluc3RlYWQgb2YgMCwgZm9yIGV4YW1wbGUuXHJcbiAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxyXG4gICAgICAgIHRpbWUsXHJcbiAgICAgICAgY2hpbGQsXHJcbiAgICAgICAgbmV4dCxcclxuICAgICAgICBpdGVyYXRpb24sXHJcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcclxuICAgICAgICBwcmV2UGF1c2VkLFxyXG4gICAgICAgIHBhdXNlVHdlZW4sXHJcbiAgICAgICAgdGltZVNjYWxlLFxyXG4gICAgICAgIHByZXZTdGFydCxcclxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxyXG4gICAgICAgIHlveW8sXHJcbiAgICAgICAgaXNZb3lvO1xyXG4gICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcclxuXHJcbiAgICBpZiAodFRpbWUgIT09IHRoaXMuX3RUaW1lIHx8IGZvcmNlIHx8IGNyb3NzaW5nU3RhcnQpIHtcclxuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xyXG4gICAgICAgIC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cclxuICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XHJcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGltZSA9IHRUaW1lO1xyXG4gICAgICBwcmV2U3RhcnQgPSB0aGlzLl9zdGFydDtcclxuICAgICAgdGltZVNjYWxlID0gdGhpcy5fdHM7XHJcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xyXG5cclxuICAgICAgaWYgKGNyb3NzaW5nU3RhcnQpIHtcclxuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxyXG5cclxuICAgICAgICAodG90YWxUaW1lIHx8ICFzdXBwcmVzc0V2ZW50cykgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3JlcGVhdCkge1xyXG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xyXG4gICAgICAgIHlveW8gPSB0aGlzLl95b3lvO1xyXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXHJcblxyXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xyXG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcclxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcclxuICAgICAgICAgIHRpbWUgPSBkdXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByZXZJdGVyYXRpb24gPSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7IC8vIGZ1bGwgZGVjaW1hbCB2ZXJzaW9uIG9mIGl0ZXJhdGlvbnMsIG5vdCB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICh3ZSdyZSByZXVzaW5nIHByZXZJdGVyYXRpb24gdmFyaWFibGUgZm9yIGVmZmljaWVuY3kpXHJcblxyXG4gICAgICAgICAgaXRlcmF0aW9uID0gfn5wcmV2SXRlcmF0aW9uO1xyXG5cclxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSBwcmV2SXRlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiB0aGlzLl90VGltZSAtIHByZXZJdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uIC0gdGhpcy5fZHVyIDw9IDAgJiYgKHByZXZJdGVyYXRpb24gPSBpdGVyYXRpb24pOyAvLyBlZGdlIGNhc2UgLSBpZiBzb21lb25lIGRvZXMgYWRkUGF1c2UoKSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSByZXBlYXRpbmcgdGltZWxpbmUsIHRoYXQgcGF1c2UgaXMgdGVjaG5pY2FsbHkgYXQgdGhlIHNhbWUgc3BvdCBhcyB0aGUgZW5kIHdoaWNoIGNhdXNlcyB0aGlzLl90aW1lIHRvIGdldCBzZXQgdG8gMCB3aGVuIHRoZSB0b3RhbFRpbWUgd291bGQgbm9ybWFsbHkgcGxhY2UgdGhlIHBsYXloZWFkIGF0IHRoZSBlbmQuIFNlZSBodHRwczovL2dzYXAuY29tL2ZvcnVtcy90b3BpYy8yMzgyMy1jbG9zaW5nLW5hdi1hbmltYXRpb24tbm90LXdvcmtpbmctb24taWUtYW5kLWlwaG9uZS02LW1heWJlLW90aGVyLW9sZGVyLWJyb3dzZXIvP3RhYj1jb21tZW50cyNjb21tZW50LTExMzAwNSBhbHNvLCB0aGlzLl90VGltZSAtIHByZXZJdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uIC0gdGhpcy5fZHVyIDw9IDAganVzdCBjaGVja3MgdG8gbWFrZSBzdXJlIGl0IHdhc24ndCBwcmV2aW91c2x5IGluIHRoZSBcInJlcGVhdERlbGF5XCIgcG9ydGlvblxyXG5cclxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XHJcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcclxuICAgICAgICAgIGlzWW95byA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgbWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcclxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxyXG4gICAgICAgIHdvdWxkIGdldCB0cmFuc2xhdGVkIHRvIDIuOCBzZWNvbmRzIGlmIHRoZSB0aW1lbGluZSB5b3lvcyBvciAwLjIgc2Vjb25kcyBpZiBpdCBqdXN0IHJlcGVhdHMpLCB0aGVyZVxyXG4gICAgICAgIGNvdWxkIGJlIGEgY2FsbGJhY2sgb3IgYSBzaG9ydCB0d2VlbiB0aGF0J3MgYXQgMi45NSBvciAzIHNlY29uZHMgaW4gd2hpY2ggd291bGRuJ3QgcmVuZGVyLiBTb1xyXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcclxuICAgICAgICBlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZSB3b3JrLlxyXG4gICAgICAgICovXHJcblxyXG5cclxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmICF0aGlzLl9sb2NrKSB7XHJcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcclxuICAgICAgICAgICAgICBkb2VzV3JhcCA9IHJld2luZGluZyA9PT0gKHlveW8gJiYgaXRlcmF0aW9uICYgMSk7XHJcbiAgICAgICAgICBpdGVyYXRpb24gPCBwcmV2SXRlcmF0aW9uICYmIChyZXdpbmRpbmcgPSAhcmV3aW5kaW5nKTtcclxuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IHRUaW1lICUgZHVyID8gZHVyIDogdFRpbWU7IC8vIGlmIHRoZSBwbGF5aGVhZCBpcyBsYW5kaW5nIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBhbiBpdGVyYXRpb24sIHVzZSB0aGF0IHRvdGFsVGltZSByYXRoZXIgdGhhbiBvbmx5IHRoZSBkdXJhdGlvbiwgb3RoZXJ3aXNlIGl0J2xsIHNraXAgdGhlIDJuZCByZW5kZXIgc2luY2UgaXQncyBlZmZlY3RpdmVseSBhdCB0aGUgc2FtZSB0aW1lLlxyXG5cclxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xyXG4gICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmRQcmVjaXNlKGl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24pKSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcclxuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxyXG5cclxuICAgICAgICAgICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcclxuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XHJcblxyXG4gICAgICAgICAgaWYgKHByZXZUaW1lICYmIHByZXZUaW1lICE9PSB0aGlzLl90aW1lIHx8IHByZXZQYXVzZWQgIT09ICF0aGlzLl90cyB8fCB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXRoaXMucGFyZW50ICYmICF0aGlzLl9hY3QpIHtcclxuICAgICAgICAgICAgLy8gaWYgcHJldlRpbWUgaXMgMCBhbmQgd2UgcmVuZGVyIGF0IHRoZSB2ZXJ5IGVuZCwgX3RpbWUgd2lsbCBiZSB0aGUgZW5kLCB0aHVzIHdvbid0IG1hdGNoLiBTbyBpbiB0aGlzIGVkZ2UgY2FzZSwgcHJldlRpbWUgd29uJ3QgbWF0Y2ggX3RpbWUgYnV0IHRoYXQncyBva2F5LiBJZiBpdCBnZXRzIGtpbGxlZCBpbiB0aGUgb25SZXBlYXQsIGVqZWN0IGFzIHdlbGwuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGR1ciA9IHRoaXMuX2R1cjsgLy8gaW4gY2FzZSB0aGUgZHVyYXRpb24gY2hhbmdlZCBpbiB0aGUgb25SZXBlYXRcclxuXHJcbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcclxuXHJcbiAgICAgICAgICBpZiAoZG9lc1dyYXApIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XHJcbiAgICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gZHVyIDogLTAuMDAwMTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xyXG5cclxuICAgICAgICAgIGlmICghdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICB9IC8vaW4gb3JkZXIgZm9yIHlveW9FYXNlIHRvIHdvcmsgcHJvcGVybHkgd2hlbiB0aGVyZSdzIGEgc3RhZ2dlciwgd2UgbXVzdCBzd2FwIG91dCB0aGUgZWFzZSBpbiBlYWNoIHN1Yi10d2Vlbi5cclxuXHJcblxyXG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKHRoaXMsIGlzWW95byk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcclxuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XHJcblxyXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuKSB7XHJcbiAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xyXG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcclxuICAgICAgdGhpcy5fYWN0ID0gIXRpbWVTY2FsZTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcclxuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcclxuICAgICAgICB0aGlzLl9pbml0dGVkID0gMTtcclxuICAgICAgICB0aGlzLl96VGltZSA9IHRvdGFsVGltZTtcclxuICAgICAgICBwcmV2VGltZSA9IDA7IC8vIHVwb24gaW5pdCwgdGhlIHBsYXloZWFkIHNob3VsZCBhbHdheXMgZ28gZm9yd2FyZDsgc29tZW9uZSBjb3VsZCBpbnZhbGlkYXRlKCkgYSBjb21wbGV0ZWQgdGltZWxpbmUgYW5kIHRoZW4gaWYgdGhleSByZXN0YXJ0KCksIHRoYXQgd291bGQgbWFrZSBjaGlsZCB0d2VlbnMgcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgd2hpY2ggY291bGQgbG9jayBpbiB0aGUgd3Jvbmcgc3RhcnRpbmcgdmFsdWVzIGlmIHRoZXkgYnVpbGQgb24gZWFjaCBvdGhlciwgbGlrZSB0bC50byhvYmosIHt4OiAxMDB9KS50byhvYmosIHt4OiAwfSkuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcHJldlRpbWUgJiYgdFRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFwcmV2SXRlcmF0aW9uKSB7XHJcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xyXG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRpbWUgPj0gcHJldlRpbWUgJiYgdG90YWxUaW1lID49IDApIHtcclxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xyXG5cclxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcclxuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcclxuXHJcbiAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgLy8gYW4gZXh0cmVtZSBlZGdlIGNhc2UgLSB0aGUgY2hpbGQncyByZW5kZXIgY291bGQgZG8gc29tZXRoaW5nIGxpa2Uga2lsbCgpIHRoZSBcIm5leHRcIiBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0LCBvciByZXBhcmVudCBpdC4gSW4gdGhhdCBjYXNlIHdlIG11c3QgcmUtaW5pdGlhdGUgdGhlIHdob2xlIHJlbmRlciB0byBiZSBzYWZlLlxyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xyXG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcclxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcclxuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IC1fdGlueU51bSk7IC8vIGl0IGRpZG4ndCBmaW5pc2ggcmVuZGVyaW5nLCBzbyBmbGFnIHpUaW1lIGFzIG5lZ2F0aXZlIHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcclxuICAgICAgICB2YXIgYWRqdXN0ZWRUaW1lID0gdG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6IHRpbWU7IC8vd2hlbiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoaXMgdGltZWxpbmUsIHdlIG11c3QgcGFzcyB0aGF0IGluZm9ybWF0aW9uIGRvd24gdG8gdGhlIGNoaWxkIGFuaW1hdGlvbnMgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBrbm93IHdoZXRoZXIgdG8gcmVuZGVyIHRoZWlyIHN0YXJ0aW5nIG9yIGVuZGluZyB2YWx1ZXMuXHJcblxyXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICAgICAgbmV4dCA9IGNoaWxkLl9wcmV2O1xyXG5cclxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAvLyBhbiBleHRyZW1lIGVkZ2UgY2FzZSAtIHRoZSBjaGlsZCdzIHJlbmRlciBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZSBraWxsKCkgdGhlIFwibmV4dFwiIG9uZSBpbiB0aGUgbGlua2VkIGxpc3QsIG9yIHJlcGFyZW50IGl0LiBJbiB0aGF0IGNhc2Ugd2UgbXVzdCByZS1pbml0aWF0ZSB0aGUgd2hvbGUgcmVuZGVyIHRvIGJlIHNhZmUuXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgX2lzUmV2ZXJ0V29ydGh5KGNoaWxkKSk7IC8vIGlmIHJldmVydGluZywgd2Ugc2hvdWxkIGFsd2F5cyBmb3JjZSByZW5kZXJzIG9mIGluaXR0ZWQgdHdlZW5zIChidXQgcmVtZW1iZXIgdGhhdCAuZnJvbVRvKCkgb3IgLmZyb20oKSBtYXkgaGF2ZSBhIF9zdGFydEF0IGJ1dCBub3QgX2luaXR0ZWQgeWV0KS4gSWYsIGZvciBleGFtcGxlLCBhIC5mcm9tVG8oKSB0d2VlbiB3aXRoIGEgc3RhZ2dlciAod2hpY2ggY3JlYXRlcyBhbiBpbnRlcm5hbCB0aW1lbGluZSkgZ2V0cyByZXZlcnRlZCBCRUZPUkUgc29tZSBvZiBpdHMgY2hpbGQgdHdlZW5zIHJlbmRlciBmb3IgdGhlIGZpcnN0IHRpbWUsIGl0IG1heSBub3QgcHJvcGVybHkgdHJpZ2dlciB0aGVtIHRvIHJldmVydC5cclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lICE9PSB0aGlzLl90aW1lIHx8ICF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xyXG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcclxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcclxuICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IGFkanVzdGVkVGltZSA/IC1fdGlueU51bSA6IF90aW55TnVtKTsgLy8gaXQgZGlkbid0IGZpbmlzaCByZW5kZXJpbmcsIHNvIGFkanVzdCB6VGltZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcclxuICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgcGF1c2VUd2Vlbi5yZW5kZXIodGltZSA+PSBwcmV2VGltZSA/IDAgOiAtX3RpbnlOdW0pLl96VGltZSA9IHRpbWUgPj0gcHJldlRpbWUgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl90cykge1xyXG4gICAgICAgICAgLy90aGUgY2FsbGJhY2sgcmVzdW1lZCBwbGF5YmFjayEgU28gc2luY2Ugd2UgbWF5IGhhdmUgaGVsZCBiYWNrIHRoZSBwbGF5aGVhZCBkdWUgdG8gd2hlcmUgdGhlIHBhdXNlIGlzIHBvc2l0aW9uZWQsIGdvIGFoZWFkIGFuZCBqdW1wIHRvIHdoZXJlIGl0J3MgU1VQUE9TRUQgdG8gYmUgKGlmIG5vIHBhdXNlIGhhcHBlbmVkKS5cclxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxyXG5cclxuICAgICAgICAgIF9zZXRFbmQodGhpcyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX29uVXBkYXRlICYmICFzdXBwcmVzc0V2ZW50cyAmJiBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiLCB0cnVlKTtcclxuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RUaW1lID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcclxuICAgICAgICAvLyByZW1lbWJlciwgYSBjaGlsZCdzIGNhbGxiYWNrIG1heSBhbHRlciB0aGlzIHRpbWVsaW5lJ3MgcGxheWhlYWQgb3IgdGltZVNjYWxlIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIGFkZCBzb21lIG9mIHRoZXNlIGNoZWNrcy5cclxuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxyXG5cclxuICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEodG90YWxUaW1lIDwgMCAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSB8fCAhdER1cikpIHtcclxuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XHJcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xyXG5cclxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xyXG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZChvYmosIHBvc2l0aW9uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKF9pc1N0cmluZyhjaGlsZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XHJcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XHJcbiAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHtcclxuICAgICAgbmVzdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcclxuICAgICAgdHdlZW5zID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcclxuICAgICAgdGltZWxpbmVzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYSA9IFtdLFxyXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xyXG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuKSB7XHJcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGltZWxpbmVzICYmIGEucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcclxuICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5nZXRDaGlsZHJlbigxLCAxLCAxKSxcclxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcclxuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKGNoaWxkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hpbGQucGFyZW50ID09PSB0aGlzICYmIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBjaGlsZCk7XHJcblxyXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcclxuICAgICAgdGhpcy5fcmVjZW50ID0gdGhpcy5fbGFzdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xyXG5cclxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcclxuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cclxuICAgICAgdGhpcy5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKF90aWNrZXIudGltZSAtICh0aGlzLl90cyA+IDAgPyBfdG90YWxUaW1lMiAvIHRoaXMuX3RzIDogKHRoaXMudG90YWxEdXJhdGlvbigpIC0gX3RvdGFsVGltZTIpIC8gLXRoaXMuX3RzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX0FuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmNhbGwodGhpcywgX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKTtcclxuXHJcbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuYWRkTGFiZWwgPSBmdW5jdGlvbiBhZGRMYWJlbChsYWJlbCwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xyXG4gICAgZGVsZXRlIHRoaXMubGFiZWxzW2xhYmVsXTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xyXG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xyXG4gICAgdC5kYXRhID0gXCJpc1BhdXNlXCI7XHJcbiAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XHJcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcclxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xyXG4gICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XHJcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9wcm90bzIua2lsbFR3ZWVuc09mID0gZnVuY3Rpb24ga2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKSB7XHJcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSxcclxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XHJcbiAgICB2YXIgYSA9IFtdLFxyXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxyXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXHJcbiAgICAgICAgaXNHbG9iYWxUaW1lID0gX2lzTnVtYmVyKG9ubHlBY3RpdmUpLFxyXG4gICAgICAgIC8vIGEgbnVtYmVyIGlzIGludGVycHJldGVkIGFzIGEgZ2xvYmFsIHRpbWUuIElmIHRoZSBhbmltYXRpb24gc3BhbnNcclxuICAgIGNoaWxkcmVuO1xyXG5cclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xyXG4gICAgICAgIGlmIChfYXJyYXlDb250YWluc0FueShjaGlsZC5fdGFyZ2V0cywgcGFyc2VkVGFyZ2V0cykgJiYgKGlzR2xvYmFsVGltZSA/ICghX292ZXJ3cml0aW5nVHdlZW4gfHwgY2hpbGQuX2luaXR0ZWQgJiYgY2hpbGQuX3RzKSAmJiBjaGlsZC5nbG9iYWxUaW1lKDApIDw9IG9ubHlBY3RpdmUgJiYgY2hpbGQuZ2xvYmFsVGltZShjaGlsZC50b3RhbER1cmF0aW9uKCkpID4gb25seUFjdGl2ZSA6ICFvbmx5QWN0aXZlIHx8IGNoaWxkLmlzQWN0aXZlKCkpKSB7XHJcbiAgICAgICAgICAvLyBub3RlOiBpZiB0aGlzIGlzIGZvciBvdmVyd3JpdGluZywgaXQgc2hvdWxkIG9ubHkgYmUgZm9yIHR3ZWVucyB0aGF0IGFyZW4ndCBwYXVzZWQgYW5kIGFyZSBpbml0dGVkLlxyXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoKGNoaWxkcmVuID0gY2hpbGQuZ2V0VHdlZW5zT2YocGFyc2VkVGFyZ2V0cywgb25seUFjdGl2ZSkpLmxlbmd0aCkge1xyXG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGZlYXR1cmUgLSB0YXJnZXRzKCkgb24gdGltZWxpbmVzXHJcbiAgLy8gdGFyZ2V0cygpIHtcclxuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcclxuICAvLyBcdHRoaXMuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpLmZvckVhY2godCA9PiByZXN1bHQucHVzaCguLi50LnRhcmdldHMoKSkpO1xyXG4gIC8vIFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoKHYsIGkpID0+IHJlc3VsdC5pbmRleE9mKHYpID09PSBpKTtcclxuICAvLyB9XHJcbiAgO1xyXG5cclxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XHJcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcclxuXHJcbiAgICB2YXIgdGwgPSB0aGlzLFxyXG4gICAgICAgIGVuZFRpbWUgPSBfcGFyc2VQb3NpdGlvbih0bCwgcG9zaXRpb24pLFxyXG4gICAgICAgIF92YXJzID0gdmFycyxcclxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcclxuICAgICAgICBfb25TdGFydCA9IF92YXJzLm9uU3RhcnQsXHJcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXHJcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxyXG4gICAgICAgIGluaXR0ZWQsXHJcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcclxuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxyXG4gICAgICBsYXp5OiBmYWxzZSxcclxuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcclxuICAgICAgdGltZTogZW5kVGltZSxcclxuICAgICAgb3ZlcndyaXRlOiBcImF1dG9cIixcclxuICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcclxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcclxuICAgICAgICB0bC5wYXVzZSgpO1xyXG5cclxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcclxuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKTtcclxuICAgICAgICAgIHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uICYmIF9zZXREdXJhdGlvbih0d2VlbiwgZHVyYXRpb24sIDAsIDEpLnJlbmRlcih0d2Vlbi5fdGltZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICBpbml0dGVkID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXHJcbiAgICAgIH1cclxuICAgIH0sIHZhcnMpKTtcclxuXHJcbiAgICByZXR1cm4gaW1tZWRpYXRlUmVuZGVyID8gdHdlZW4ucmVuZGVyKDApIDogdHdlZW47XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi50d2VlbkZyb21UbyA9IGZ1bmN0aW9uIHR3ZWVuRnJvbVRvKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xyXG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xyXG4gICAgICBzdGFydEF0OiB7XHJcbiAgICAgICAgdGltZTogX3BhcnNlUG9zaXRpb24odGhpcywgZnJvbVBvc2l0aW9uKVxyXG4gICAgICB9XHJcbiAgICB9LCB2YXJzKSk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVjZW50O1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIubmV4dExhYmVsID0gZnVuY3Rpb24gbmV4dExhYmVsKGFmdGVyVGltZSkge1xyXG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xyXG4gICAgaWYgKGJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xyXG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XHJcbiAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxyXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxyXG4gICAgICAgIHA7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xyXG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XHJcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFkanVzdExhYmVscykge1xyXG4gICAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XHJcbiAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XHJcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8yLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKHNvZnQpIHtcclxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xyXG4gICAgdGhpcy5fbG9jayA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoc29mdCk7XHJcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xyXG4gICAgaWYgKGluY2x1ZGVMYWJlbHMgPT09IHZvaWQgMCkge1xyXG4gICAgICBpbmNsdWRlTGFiZWxzID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcclxuICAgICAgICBuZXh0O1xyXG5cclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XHJcbiAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcclxuICAgICAgY2hpbGQgPSBuZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2RwICYmICh0aGlzLl90aW1lID0gdGhpcy5fdFRpbWUgPSB0aGlzLl9wVGltZSA9IDApO1xyXG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XHJcbiAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xyXG4gICAgdmFyIG1heCA9IDAsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxyXG4gICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXHJcbiAgICAgICAgcHJldixcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBwYXJlbnQ7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHNlbGYudGltZVNjYWxlKChzZWxmLl9yZXBlYXQgPCAwID8gc2VsZi5kdXJhdGlvbigpIDogc2VsZi50b3RhbER1cmF0aW9uKCkpIC8gKHNlbGYucmV2ZXJzZWQoKSA/IC12YWx1ZSA6IHZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYuX2RpcnR5KSB7XHJcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xyXG5cclxuICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXHJcblxyXG4gICAgICAgIGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIGFuaW1hdGlvbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXHJcblxyXG4gICAgICAgIHN0YXJ0ID0gY2hpbGQuX3N0YXJ0O1xyXG5cclxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcclxuICAgICAgICAgIC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2VcclxuICAgICAgICAgIHNlbGYuX2xvY2sgPSAxOyAvL3ByZXZlbnQgZW5kbGVzcyByZWN1cnNpdmUgY2FsbHMgLSB0aGVyZSBhcmUgbWV0aG9kcyB0aGF0IGdldCB0cmlnZ2VyZWQgdGhhdCBjaGVjayBkdXJhdGlvbi90b3RhbER1cmF0aW9uIHdoZW4gd2UgYWRkKCkuXHJcblxyXG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcclxuICAgICAgICAgIC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXHJcbiAgICAgICAgICBtYXggLT0gc3RhcnQ7XHJcblxyXG4gICAgICAgICAgaWYgKCFwYXJlbnQgJiYgIXNlbGYuX2RwIHx8IHBhcmVudCAmJiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcpIHtcclxuICAgICAgICAgICAgc2VsZi5fc3RhcnQgKz0gc3RhcnQgLyBzZWxmLl90cztcclxuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcclxuICAgICAgICAgICAgc2VsZi5fdFRpbWUgLT0gc3RhcnQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VsZi5zaGlmdENoaWxkcmVuKC1zdGFydCwgZmFsc2UsIC0xZTk5OSk7XHJcbiAgICAgICAgICBwcmV2U3RhcnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQuX2VuZCA+IG1heCAmJiBjaGlsZC5fdHMgJiYgKG1heCA9IGNoaWxkLl9lbmQpO1xyXG4gICAgICAgIGNoaWxkID0gcHJldjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XHJcblxyXG4gICAgICBzZWxmLl9kaXJ0eSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlbGYuX3REdXI7XHJcbiAgfTtcclxuXHJcbiAgVGltZWxpbmUudXBkYXRlUm9vdCA9IGZ1bmN0aW9uIHVwZGF0ZVJvb3QodGltZSkge1xyXG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcclxuICAgICAgX2xhenlTYWZlUmVuZGVyKF9nbG9iYWxUaW1lbGluZSwgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZSwgX2dsb2JhbFRpbWVsaW5lKSk7XHJcblxyXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xyXG4gICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xyXG4gICAgICB2YXIgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xyXG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XHJcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hpbGQgfHwgX3RpY2tlci5zbGVlcCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRpbWVsaW5lO1xyXG59KEFuaW1hdGlvbik7XHJcblxyXG5fc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XHJcbiAgX2xvY2s6IDAsXHJcbiAgX2hhc1BhdXNlOiAwLFxyXG4gIF9mb3JjaW5nOiAwXHJcbn0pO1xyXG5cclxudmFyIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XHJcbiAgLy9ub3RlOiB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxyXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXHJcbiAgICAgIGluZGV4ID0gMCxcclxuICAgICAgbWF0Y2hJbmRleCA9IDAsXHJcbiAgICAgIHJlc3VsdCxcclxuICAgICAgc3RhcnROdW1zLFxyXG4gICAgICBjb2xvcixcclxuICAgICAgZW5kTnVtLFxyXG4gICAgICBjaHVuayxcclxuICAgICAgc3RhcnROdW0sXHJcbiAgICAgIGhhc1JhbmRvbSxcclxuICAgICAgYTtcclxuICBwdC5iID0gc3RhcnQ7XHJcbiAgcHQuZSA9IGVuZDtcclxuICBzdGFydCArPSBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3NcclxuXHJcbiAgZW5kICs9IFwiXCI7XHJcblxyXG4gIGlmIChoYXNSYW5kb20gPSB+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XHJcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xyXG4gICAgYSA9IFtzdGFydCwgZW5kXTtcclxuICAgIHN0cmluZ0ZpbHRlcihhLCB0YXJnZXQsIHByb3ApOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuXHJcblxyXG4gICAgc3RhcnQgPSBhWzBdO1xyXG4gICAgZW5kID0gYVsxXTtcclxuICB9XHJcblxyXG4gIHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9jb21wbGV4U3RyaW5nTnVtRXhwKSB8fCBbXTtcclxuXHJcbiAgd2hpbGUgKHJlc3VsdCA9IF9jb21wbGV4U3RyaW5nTnVtRXhwLmV4ZWMoZW5kKSkge1xyXG4gICAgZW5kTnVtID0gcmVzdWx0WzBdO1xyXG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xyXG5cclxuICAgIGlmIChjb2xvcikge1xyXG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcclxuICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XHJcbiAgICAgIGNvbG9yID0gMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5kTnVtICE9PSBzdGFydE51bXNbbWF0Y2hJbmRleCsrXSkge1xyXG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxyXG5cclxuICAgICAgcHQuX3B0ID0ge1xyXG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXHJcbiAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXHJcbiAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXHJcbiAgICAgICAgczogc3RhcnROdW0sXHJcbiAgICAgICAgYzogZW5kTnVtLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kTnVtKSAtIHN0YXJ0TnVtIDogcGFyc2VGbG9hdChlbmROdW0pIC0gc3RhcnROdW0sXHJcbiAgICAgICAgbTogY29sb3IgJiYgY29sb3IgPCA0ID8gTWF0aC5yb3VuZCA6IDBcclxuICAgICAgfTtcclxuICAgICAgaW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXHJcblxyXG4gIHB0LmZwID0gZnVuY1BhcmFtO1xyXG5cclxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XHJcbiAgICBwdC5lID0gMDsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxyXG4gIH1cclxuXHJcbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxyXG5cclxuICByZXR1cm4gcHQ7XHJcbn0sXHJcbiAgICBfYWRkUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFByb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIGluZGV4LCB0YXJnZXRzLCBtb2RpZmllciwgc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0sIG9wdGlvbmFsKSB7XHJcbiAgX2lzRnVuY3Rpb24oZW5kKSAmJiAoZW5kID0gZW5kKGluZGV4IHx8IDAsIHRhcmdldCwgdGFyZ2V0cykpO1xyXG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXHJcbiAgICAgIHBhcnNlZFN0YXJ0ID0gc3RhcnQgIT09IFwiZ2V0XCIgPyBzdGFydCA6ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogZnVuY1BhcmFtID8gdGFyZ2V0W3Byb3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pID8gcHJvcCA6IFwiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0oZnVuY1BhcmFtKSA6IHRhcmdldFtwcm9wXSgpLFxyXG4gICAgICBzZXR0ZXIgPSAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IF9zZXR0ZXJQbGFpbiA6IGZ1bmNQYXJhbSA/IF9zZXR0ZXJGdW5jV2l0aFBhcmFtIDogX3NldHRlckZ1bmMsXHJcbiAgICAgIHB0O1xyXG5cclxuICBpZiAoX2lzU3RyaW5nKGVuZCkpIHtcclxuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XHJcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XHJcbiAgICAgIHB0ID0gX3BhcnNlUmVsYXRpdmUocGFyc2VkU3RhcnQsIGVuZCkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XHJcblxyXG4gICAgICBpZiAocHQgfHwgcHQgPT09IDApIHtcclxuICAgICAgICAvLyB0byBhdm9pZCBpc05hTiwgbGlrZSBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHZhbHVlIGxpa2UgXCIhPSB3aGF0ZXZlclwiXHJcbiAgICAgICAgZW5kID0gcHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghb3B0aW9uYWwgfHwgcGFyc2VkU3RhcnQgIT09IGVuZCB8fCBfZm9yY2VBbGxQcm9wVHdlZW5zKSB7XHJcbiAgICBpZiAoIWlzTmFOKHBhcnNlZFN0YXJ0ICogZW5kKSAmJiBlbmQgIT09IFwiXCIpIHtcclxuICAgICAgLy8gZnVuIGZhY3Q6IGFueSBudW1iZXIgbXVsdGlwbGllZCBieSBcIlwiIGlzIGV2YWx1YXRlZCBhcyB0aGUgbnVtYmVyIDAhXHJcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xyXG4gICAgICBmdW5jUGFyYW0gJiYgKHB0LmZwID0gZnVuY1BhcmFtKTtcclxuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xyXG4gICAgfVxyXG5cclxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcclxuICAgIHJldHVybiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHRoaXMsIHRhcmdldCwgcHJvcCwgcGFyc2VkU3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIgfHwgX2NvbmZpZy5zdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSk7XHJcbiAgfVxyXG59LFxyXG4gICAgLy9jcmVhdGVzIGEgY29weSBvZiB0aGUgdmFycyBvYmplY3QgYW5kIHByb2Nlc3NlcyBhbnkgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIChwdXR0aW5nIHRoZSByZXN1bHRpbmcgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIGNvcHkpIGFzIHdlbGwgYXMgc3RyaW5ncyB3aXRoIFwicmFuZG9tKClcIiBpbiB0aGVtLiBJdCBkb2VzIE5PVCBwcm9jZXNzIHJlbGF0aXZlIHZhbHVlcy5cclxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XHJcbiAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcclxuXHJcbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcclxuICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcclxuICB9XHJcblxyXG4gIHZhciBjb3B5ID0ge30sXHJcbiAgICAgIHA7XHJcblxyXG4gIGZvciAocCBpbiB2YXJzKSB7XHJcbiAgICBjb3B5W3BdID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnNbcF0sIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjb3B5O1xyXG59LFxyXG4gICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xyXG4gIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcclxuXHJcbiAgaWYgKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3Byb3BlcnR5XSgpKS5pbml0KHRhcmdldCwgcGx1Z2luLnJhd1ZhcnMgPyB2YXJzW3Byb3BlcnR5XSA6IF9wcm9jZXNzVmFycyh2YXJzW3Byb3BlcnR5XSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpICE9PSBmYWxzZSkge1xyXG4gICAgdHdlZW4uX3B0ID0gcHQgPSBuZXcgUHJvcFR3ZWVuKHR3ZWVuLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgcGx1Z2luLnJlbmRlciwgcGx1Z2luLCAwLCBwbHVnaW4ucHJpb3JpdHkpO1xyXG5cclxuICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcclxuICAgICAgcHRMb29rdXAgPSB0d2Vlbi5fcHRMb29rdXBbdHdlZW4uX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpXTsgLy9ub3RlOiB3ZSBjYW4ndCB1c2UgdHdlZW4uX3B0TG9va3VwW2luZGV4XSBiZWNhdXNlIGZvciBzdGFnZ2VyZWQgdHdlZW5zLCB0aGUgaW5kZXggZnJvbSB0aGUgZnVsbFRhcmdldHMgYXJyYXkgd29uJ3QgbWF0Y2ggd2hhdCBpdCBpcyBpbiBlYWNoIGluZGl2aWR1YWwgdHdlZW4gdGhhdCBzcGF3bnMgZnJvbSB0aGUgc3RhZ2dlci5cclxuXHJcbiAgICAgIGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGx1Z2luO1xyXG59LFxyXG4gICAgX292ZXJ3cml0aW5nVHdlZW4sXHJcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXHJcbl9mb3JjZUFsbFByb3BUd2VlbnMsXHJcbiAgICBfaW5pdFR3ZWVuID0gZnVuY3Rpb24gX2luaXRUd2Vlbih0d2VlbiwgdGltZSwgdFRpbWUpIHtcclxuICB2YXIgdmFycyA9IHR3ZWVuLnZhcnMsXHJcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXHJcbiAgICAgIHN0YXJ0QXQgPSB2YXJzLnN0YXJ0QXQsXHJcbiAgICAgIGltbWVkaWF0ZVJlbmRlciA9IHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxyXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxyXG4gICAgICBvblVwZGF0ZSA9IHZhcnMub25VcGRhdGUsXHJcbiAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxyXG4gICAgICB5b3lvRWFzZSA9IHZhcnMueW95b0Vhc2UsXHJcbiAgICAgIGtleWZyYW1lcyA9IHZhcnMua2V5ZnJhbWVzLFxyXG4gICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxyXG4gICAgICBkdXIgPSB0d2Vlbi5fZHVyLFxyXG4gICAgICBwcmV2U3RhcnRBdCA9IHR3ZWVuLl9zdGFydEF0LFxyXG4gICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXHJcbiAgICAgIHBhcmVudCA9IHR3ZWVuLnBhcmVudCxcclxuICAgICAgZnVsbFRhcmdldHMgPSBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogdGFyZ2V0cyxcclxuICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxyXG4gICAgICB0bCA9IHR3ZWVuLnRpbWVsaW5lLFxyXG4gICAgICBjbGVhblZhcnMsXHJcbiAgICAgIGksXHJcbiAgICAgIHAsXHJcbiAgICAgIHB0LFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGhhc1ByaW9yaXR5LFxyXG4gICAgICBnc0RhdGEsXHJcbiAgICAgIGhhcm5lc3MsXHJcbiAgICAgIHBsdWdpbixcclxuICAgICAgcHRMb29rdXAsXHJcbiAgICAgIGluZGV4LFxyXG4gICAgICBoYXJuZXNzVmFycyxcclxuICAgICAgb3ZlcndyaXR0ZW47XHJcbiAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xyXG4gIHR3ZWVuLl9lYXNlID0gX3BhcnNlRWFzZShlYXNlLCBfZGVmYXVsdHMuZWFzZSk7XHJcbiAgdHdlZW4uX3lFYXNlID0geW95b0Vhc2UgPyBfaW52ZXJ0RWFzZShfcGFyc2VFYXNlKHlveW9FYXNlID09PSB0cnVlID8gZWFzZSA6IHlveW9FYXNlLCBfZGVmYXVsdHMuZWFzZSkpIDogMDtcclxuXHJcbiAgaWYgKHlveW9FYXNlICYmIHR3ZWVuLl95b3lvICYmICF0d2Vlbi5fcmVwZWF0KSB7XHJcbiAgICAvL3RoZXJlIG11c3QgaGF2ZSBiZWVuIGEgcGFyZW50IHRpbWVsaW5lIHdpdGggeW95bzp0cnVlIHRoYXQgaXMgY3VycmVudGx5IGluIGl0cyB5b3lvIHBoYXNlLCBzbyBmbGlwIHRoZSBlYXNlcy5cclxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xyXG4gICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XHJcbiAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xyXG4gIH1cclxuXHJcbiAgdHdlZW4uX2Zyb20gPSAhdGwgJiYgISF2YXJzLnJ1bkJhY2t3YXJkczsgLy9uZXN0ZWQgdGltZWxpbmVzIHNob3VsZCBuZXZlciBydW4gYmFja3dhcmRzIC0gdGhlIGJhY2t3YXJkcy1uZXNzIGlzIGluIHRoZSBjaGlsZCB0d2VlbnMuXHJcblxyXG4gIGlmICghdGwgfHwga2V5ZnJhbWVzICYmICF2YXJzLnN0YWdnZXIpIHtcclxuICAgIC8vaWYgdGhlcmUncyBhbiBpbnRlcm5hbCB0aW1lbGluZSwgc2tpcCBhbGwgdGhlIHBhcnNpbmcgYmVjYXVzZSB3ZSBwYXNzZWQgdGhhdCB0YXNrIGRvd24gdGhlIGNoYWluLlxyXG4gICAgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XHJcbiAgICBoYXJuZXNzVmFycyA9IGhhcm5lc3MgJiYgdmFyc1toYXJuZXNzLnByb3BdOyAvL3NvbWVvbmUgbWF5IG5lZWQgdG8gc3BlY2lmeSBDU1Mtc3BlY2lmaWMgdmFsdWVzIEFORCBub24tQ1NTIHZhbHVlcywgbGlrZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gXCJ4XCIgcHJvcGVydHkgcGx1cyBpdCdzIGEgc3RhbmRhcmQgRE9NIGVsZW1lbnQuIFdlIGFsbG93IHBlb3BsZSB0byBkaXN0aW5ndWlzaCBieSB3cmFwcGluZyBwbHVnaW4tc3BlY2lmaWMgc3R1ZmYgaW4gYSBjc3M6e30gb2JqZWN0IGZvciBleGFtcGxlLlxyXG5cclxuICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcclxuXHJcbiAgICBpZiAocHJldlN0YXJ0QXQpIHtcclxuICAgICAgcHJldlN0YXJ0QXQuX3pUaW1lIDwgMCAmJiBwcmV2U3RhcnRBdC5wcm9ncmVzcygxKTsgLy8gaW4gY2FzZSBpdCdzIGEgbGF6eSBzdGFydEF0IHRoYXQgaGFzbid0IHJlbmRlcmVkIHlldC5cclxuXHJcbiAgICAgIHRpbWUgPCAwICYmIHJ1bkJhY2t3YXJkcyAmJiBpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQgPyBwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpIDogcHJldlN0YXJ0QXQucmV2ZXJ0KHJ1bkJhY2t3YXJkcyAmJiBkdXIgPyBfcmV2ZXJ0Q29uZmlnTm9LaWxsIDogX3N0YXJ0QXRSZXZlcnRDb25maWcpOyAvLyBpZiBpdCdzIGEgXCJzdGFydEF0XCIgKG5vdCBcImZyb20oKVwiIG9yIHJ1bkJhY2t3YXJkczogdHJ1ZSksIHdlIG9ubHkgbmVlZCB0byBkbyBhIHNoYWxsb3cgcmV2ZXJ0IChrZWVwIHRyYW5zZm9ybXMgY2FjaGVkIGluIENTU1BsdWdpbilcclxuICAgICAgLy8gZG9uJ3QganVzdCBfcmVtb3ZlRnJvbVBhcmVudChwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpKSBiZWNhdXNlIHRoYXQnbGwgbGVhdmUgaW5saW5lIHN0eWxlcy4gV2UncmUgY3JlYXRpbmcgYSBuZXcgX3N0YXJ0QXQgZm9yIFwic3RhcnRBdFwiIHR3ZWVucyB0aGF0IHJlLWNhcHR1cmUgdGhpbmdzIHRvIGVuc3VyZSB0aGF0IGlmIHRoZSBwcmUtdHdlZW4gdmFsdWVzIGNoYW5nZWQgc2luY2UgdGhlIHR3ZWVuIHdhcyBjcmVhdGVkLCB0aGV5J3JlIHJlY29yZGVkLlxyXG5cclxuICAgICAgcHJldlN0YXJ0QXQuX2xhenkgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGFydEF0KSB7XHJcbiAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIF9zZXREZWZhdWx0cyh7XHJcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXHJcbiAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcclxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXHJcbiAgICAgICAgbGF6eTogIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxyXG4gICAgICAgIHN0YXJ0QXQ6IG51bGwsXHJcbiAgICAgICAgZGVsYXk6IDAsXHJcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlICYmIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiBfY2FsbGJhY2sodHdlZW4sIFwib25VcGRhdGVcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGFnZ2VyOiAwXHJcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcclxuXHJcblxyXG4gICAgICB0d2Vlbi5fc3RhcnRBdC5fZHAgPSAwOyAvLyBkb24ndCBhbGxvdyBpdCB0byBnZXQgcHV0IGJhY2sgaW50byByb290IHRpbWVsaW5lISBMaWtlIHdoZW4gcmV2ZXJ0KCkgaXMgY2FsbGVkIGFuZCB0b3RhbFRpbWUoKSBnZXRzIHNldC5cclxuXHJcbiAgICAgIHR3ZWVuLl9zdGFydEF0Ll9zYXQgPSB0d2VlbjsgLy8gdXNlZCBpbiBnbG9iYWxUaW1lKCkuIF9zYXQgc3RhbmRzIGZvciBfc3RhcnRBdFR3ZWVuXHJcblxyXG4gICAgICB0aW1lIDwgMCAmJiAoX3JldmVydGluZyB8fCAhaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0KSAmJiB0d2Vlbi5fc3RhcnRBdC5yZXZlcnQoX3JldmVydENvbmZpZ05vS2lsbCk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXHJcblxyXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyKSB7XHJcbiAgICAgICAgaWYgKGR1ciAmJiB0aW1lIDw9IDAgJiYgdFRpbWUgPD0gMCkge1xyXG4gICAgICAgICAgLy8gY2hlY2sgdFRpbWUgaGVyZSBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGEgeW95byB0d2VlbiB3aG9zZSBwbGF5aGVhZCBnZXRzIHB1c2hlZCB0byB0aGUgZW5kIGxpa2UgdHdlZW4ucHJvZ3Jlc3MoMSksIHdlIHNob3VsZCBhbGxvdyBpdCB0aHJvdWdoIHNvIHRoYXQgdGhlIG9uQ29tcGxldGUgZ2V0cyBmaXJlZCBwcm9wZXJseS5cclxuICAgICAgICAgIHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xyXG4gICAgICAgICAgcmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChydW5CYWNrd2FyZHMgJiYgZHVyKSB7XHJcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcclxuICAgICAgaWYgKCFwcmV2U3RhcnRBdCkge1xyXG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcclxuXHJcbiAgICAgICAgcCA9IF9zZXREZWZhdWx0cyh7XHJcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxyXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxyXG4gICAgICAgICAgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXHJcbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgIXByZXZTdGFydEF0ICYmIF9pc05vdEZhbHNlKGxhenkpLFxyXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXHJcbiAgICAgICAgICAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXHJcbiAgICAgICAgICBzdGFnZ2VyOiAwLFxyXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OiBnc2FwLnV0aWxzLndyYXAoWy0xMDAsMTAwXSksIHN0YWdnZXI6IDAuNX0pXHJcblxyXG4gICAgICAgIH0sIGNsZWFuVmFycyk7XHJcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcclxuXHJcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgcCkpO1xyXG5cclxuICAgICAgICB0d2Vlbi5fc3RhcnRBdC5fZHAgPSAwOyAvLyBkb24ndCBhbGxvdyBpdCB0byBnZXQgcHV0IGJhY2sgaW50byByb290IHRpbWVsaW5lIVxyXG5cclxuICAgICAgICB0d2Vlbi5fc3RhcnRBdC5fc2F0ID0gdHdlZW47IC8vIHVzZWQgaW4gZ2xvYmFsVGltZSgpXHJcblxyXG4gICAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nID8gdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpIDogdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XHJcbiAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcclxuXHJcbiAgICAgICAgaWYgKCFpbW1lZGlhdGVSZW5kZXIpIHtcclxuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtLCBfdGlueU51bSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHR3ZWVuLl9wdCA9IHR3ZWVuLl9wdENhY2hlID0gMDtcclxuICAgIGxhenkgPSBkdXIgJiYgX2lzTm90RmFsc2UobGF6eSkgfHwgbGF6eSAmJiAhZHVyO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XHJcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcclxuICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcclxuICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pZiBvdGhlciB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0IGhhdmUgcmVjZW50bHkgaW5pdHRlZCBidXQgaGF2ZW4ndCByZW5kZXJlZCB5ZXQsIHdlJ3ZlIGdvdCB0byBmb3JjZSB0aGUgcmVuZGVyIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmUgY29ycmVjdCAoaW1hZ2luZSBwb3B1bGF0aW5nIGEgdGltZWxpbmUgd2l0aCBhIGJ1bmNoIG9mIHNlcXVlbnRpYWwgdHdlZW5zIGFuZCB0aGVuIGp1bXBpbmcgdG8gdGhlIGVuZClcclxuXHJcbiAgICAgIGluZGV4ID0gZnVsbFRhcmdldHMgPT09IHRhcmdldHMgPyBpIDogZnVsbFRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcclxuXHJcbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICBwdExvb2t1cFtuYW1lXSA9IHB0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBwbHVnaW4ucHJpb3JpdHkgJiYgKGhhc1ByaW9yaXR5ID0gMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xyXG4gICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcclxuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcclxuICAgICAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdHdlZW4uX29wICYmIHR3ZWVuLl9vcFtpXSAmJiB0d2Vlbi5raWxsKHRhcmdldCwgdHdlZW4uX29wW2ldKTtcclxuXHJcbiAgICAgIGlmIChhdXRvT3ZlcndyaXRlICYmIHR3ZWVuLl9wdCkge1xyXG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gdHdlZW47XHJcblxyXG4gICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSh0aW1lKSk7IC8vIG1ha2Ugc3VyZSB0aGUgb3ZlcndyaXRpbmcgZG9lc24ndCBvdmVyd3JpdGUgVEhJUyB0d2VlbiEhIVxyXG5cclxuXHJcbiAgICAgICAgb3ZlcndyaXR0ZW4gPSAhdHdlZW4ucGFyZW50O1xyXG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHR3ZWVuKTtcclxuICAgIHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cclxuICB9XHJcblxyXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xyXG4gIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47IC8vIGlmIG92ZXJ3cml0dGVuUHJvcHMgcmVzdWx0ZWQgaW4gdGhlIGVudGlyZSB0d2VlbiBiZWluZyBraWxsZWQsIGRvIE5PVCBmbGFnIGl0IGFzIGluaXR0ZWQgb3IgZWxzZSBpdCBtYXkgcmVuZGVyIGZvciBvbmUgdGljay5cclxuXHJcbiAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7IC8vIGlmIHRoZXJlJ3MgYSAwJSBrZXlmcmFtZSwgaXQnbGwgcmVuZGVyIGluIHRoZSBcImJlZm9yZVwiIHN0YXRlIGZvciBhbnkgc3RhZ2dlcmVkL2RlbGF5ZWQgYW5pbWF0aW9ucyB0aHVzIHdoZW4gdGhlIGZvbGxvd2luZyB0d2VlbiBpbml0aWFsaXplcywgaXQnbGwgdXNlIHRoZSBcImJlZm9yZVwiIHN0YXRlIGluc3RlYWQgb2YgdGhlIFwiYWZ0ZXJcIiBzdGF0ZSBhcyB0aGUgaW5pdGlhbCB2YWx1ZXMuXHJcbn0sXHJcbiAgICBfdXBkYXRlUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF91cGRhdGVQcm9wVHdlZW5zKHR3ZWVuLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lLCBza2lwUmVjdXJzaW9uKSB7XHJcbiAgdmFyIHB0Q2FjaGUgPSAodHdlZW4uX3B0ICYmIHR3ZWVuLl9wdENhY2hlIHx8ICh0d2Vlbi5fcHRDYWNoZSA9IHt9KSlbcHJvcGVydHldLFxyXG4gICAgICBwdCxcclxuICAgICAgcm9vdFBULFxyXG4gICAgICBsb29rdXAsXHJcbiAgICAgIGk7XHJcblxyXG4gIGlmICghcHRDYWNoZSkge1xyXG4gICAgcHRDYWNoZSA9IHR3ZWVuLl9wdENhY2hlW3Byb3BlcnR5XSA9IFtdO1xyXG4gICAgbG9va3VwID0gdHdlZW4uX3B0TG9va3VwO1xyXG4gICAgaSA9IHR3ZWVuLl90YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHB0ID0gbG9va3VwW2ldW3Byb3BlcnR5XTtcclxuXHJcbiAgICAgIGlmIChwdCAmJiBwdC5kICYmIHB0LmQuX3B0KSB7XHJcbiAgICAgICAgLy8gaXQncyBhIHBsdWdpbiwgc28gZmluZCB0aGUgbmVzdGVkIFByb3BUd2VlblxyXG4gICAgICAgIHB0ID0gcHQuZC5fcHQ7XHJcblxyXG4gICAgICAgIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wZXJ0eSAmJiBwdC5mcCAhPT0gcHJvcGVydHkpIHtcclxuICAgICAgICAgIC8vIFwiZnBcIiBpcyBmdW5jdGlvblBhcmFtIGZvciB0aGluZ3MgbGlrZSBzZXR0aW5nIENTUyB2YXJpYWJsZXMgd2hpY2ggcmVxdWlyZSAuc2V0UHJvcGVydHkoXCItLXZhci1uYW1lXCIsIHZhbHVlKVxyXG4gICAgICAgICAgcHQgPSBwdC5fbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcHQpIHtcclxuICAgICAgICAvLyB0aGVyZSBpcyBubyBQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIHRoYXQgcHJvcGVydHksIHNvIHdlIG11c3QgRk9SQ0Ugb25lIHRvIGJlIGNyZWF0ZWQgYW5kIGRpdGNoIG91dCBvZiB0aGlzXHJcbiAgICAgICAgLy8gaWYgdGhlIHR3ZWVuIGhhcyBvdGhlciBwcm9wZXJ0aWVzIHRoYXQgYWxyZWFkeSByZW5kZXJlZCBhdCBuZXcgcG9zaXRpb25zLCB3ZSdkIG5vcm1hbGx5IGhhdmUgdG8gcmV3aW5kIHRvIHB1dCB0aGVtIGJhY2sgbGlrZSB0d2Vlbi5yZW5kZXIoMCwgdHJ1ZSkgYmVmb3JlIGZvcmNpbmcgYW4gX2luaXRUd2VlbigpLCBidXQgdGhhdCBjYW4gY3JlYXRlIGFub3RoZXIgZWRnZSBjYXNlIGxpa2UgdHdlZW5pbmcgYSB0aW1lbGluZSdzIHByb2dyZXNzIHdvdWxkIHRyaWdnZXIgb25VcGRhdGVzIHRvIGZpcmUgd2hpY2ggY291bGQgbW92ZSBvdGhlciB0aGluZ3MgYXJvdW5kLiBJdCdzIGJldHRlciB0byBqdXN0IGluZm9ybSB1c2VycyB0aGF0IC5yZXNldFRvKCkgc2hvdWxkIE9OTFkgYmUgdXNlZCBmb3IgdHdlZW5zIHRoYXQgYWxyZWFkeSBoYXZlIHRoYXQgcHJvcGVydHkuIEZvciBleGFtcGxlLCB5b3UgY2FuJ3QgZ3NhcC50byguLi57IHk6IDAgfSkgYW5kIHRoZW4gdHdlZW4ucmVzdFRvKFwieFwiLCAyMDApIGZvciBleGFtcGxlLlxyXG4gICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAxOyAvLyBvdGhlcndpc2UsIHdoZW4gd2UgX2FkZFByb3BUd2VlbigpIGFuZCBpdCBmaW5kcyBubyBjaGFuZ2UgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMsIGl0IHNraXBzIGNyZWF0aW5nIGEgUHJvcFR3ZWVuIChmb3IgZWZmaWNpZW5jeS4uLndoeSB0d2VlbiB3aGVuIHRoZXJlJ3Mgbm8gZGlmZmVyZW5jZT8pIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgTkVFRCB0aGF0IFByb3BUd2VlbiBjcmVhdGVkIHNvIHdlIGNhbiBlZGl0IGl0LlxyXG5cclxuICAgICAgICB0d2Vlbi52YXJzW3Byb3BlcnR5XSA9IFwiKz0wXCI7XHJcblxyXG4gICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xyXG5cclxuICAgICAgICBfZm9yY2VBbGxQcm9wVHdlZW5zID0gMDtcclxuICAgICAgICByZXR1cm4gc2tpcFJlY3Vyc2lvbiA/IF93YXJuKHByb3BlcnR5ICsgXCIgbm90IGVsaWdpYmxlIGZvciByZXNldFwiKSA6IDE7IC8vIGlmIHNvbWVvbmUgdHJpZXMgdG8gZG8gYSBxdWlja1RvKCkgb24gYSBzcGVjaWFsIHByb3BlcnR5IGxpa2UgYm9yZGVyUmFkaXVzIHdoaWNoIG11c3QgZ2V0IHNwbGl0IGludG8gNCBkaWZmZXJlbnQgcHJvcGVydGllcywgdGhhdCdzIG5vdCBlbGlnaWJsZSBmb3IgLnJlc2V0VG8oKS5cclxuICAgICAgfVxyXG5cclxuICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGkgPSBwdENhY2hlLmxlbmd0aDtcclxuXHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgcm9vdFBUID0gcHRDYWNoZVtpXTtcclxuICAgIHB0ID0gcm9vdFBULl9wdCB8fCByb290UFQ7IC8vIGNvbXBsZXggdmFsdWVzIG1heSBoYXZlIG5lc3RlZCBQcm9wVHdlZW5zLiBXZSBvbmx5IGFjY29tbW9kYXRlIHRoZSBGSVJTVCB2YWx1ZS5cclxuXHJcbiAgICBwdC5zID0gKHN0YXJ0IHx8IHN0YXJ0ID09PSAwKSAmJiAhc3RhcnRJc1JlbGF0aXZlID8gc3RhcnQgOiBwdC5zICsgKHN0YXJ0IHx8IDApICsgcmF0aW8gKiBwdC5jO1xyXG4gICAgcHQuYyA9IHZhbHVlIC0gcHQucztcclxuICAgIHJvb3RQVC5lICYmIChyb290UFQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHJvb3RQVC5lKSk7IC8vIG1haW5seSBmb3IgQ1NTUGx1Z2luIChlbmQgdmFsdWUpXHJcblxyXG4gICAgcm9vdFBULmIgJiYgKHJvb3RQVC5iID0gcHQucyArIGdldFVuaXQocm9vdFBULmIpKTsgLy8gKGJlZ2lubmluZyB2YWx1ZSlcclxuICB9XHJcbn0sXHJcbiAgICBfYWRkQWxpYXNlc1RvVmFycyA9IGZ1bmN0aW9uIF9hZGRBbGlhc2VzVG9WYXJzKHRhcmdldHMsIHZhcnMpIHtcclxuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXHJcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxyXG4gICAgICBjb3B5LFxyXG4gICAgICBwLFxyXG4gICAgICBpLFxyXG4gICAgICBhbGlhc2VzO1xyXG5cclxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xyXG4gICAgcmV0dXJuIHZhcnM7XHJcbiAgfVxyXG5cclxuICBjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcclxuXHJcbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xyXG4gICAgaWYgKHAgaW4gY29weSkge1xyXG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcclxuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29weTtcclxufSxcclxuICAgIC8vIHBhcnNlcyBtdWx0aXBsZSBmb3JtYXRzLCBsaWtlIHtcIjAlXCI6IHt4OiAxMDB9LCB7XCI1MCVcIjoge3g6IC0yMH19IGFuZCB7IHg6IHtcIjAlXCI6IDEwMCwgXCI1MCVcIjogLTIwfSB9LCBhbmQgYW4gXCJlYXNlXCIgY2FuIGJlIHNldCBvbiBhbnkgb2JqZWN0LiBXZSBwb3B1bGF0ZSBhbiBcImFsbFByb3BzXCIgb2JqZWN0IHdpdGggYW4gQXJyYXkgZm9yIGVhY2ggcHJvcGVydHksIGxpa2Uge3g6IFt7fSwge31dLCB5Olt7fSwge31dfSB3aXRoIGRhdGEgZm9yIGVhY2ggcHJvcGVydHkgdHdlZW4uIFRoZSBvYmplY3RzIGhhdmUgYSBcInRcIiAodGltZSksIFwidlwiLCAodmFsdWUpLCBhbmQgXCJlXCIgKGVhc2UpIHByb3BlcnR5LiBUaGlzIGFsbG93cyB1cyB0byBwaWVjZSB0b2dldGhlciBhIHRpbWVsaW5lIGxhdGVyLlxyXG5fcGFyc2VLZXlmcmFtZSA9IGZ1bmN0aW9uIF9wYXJzZUtleWZyYW1lKHByb3AsIG9iaiwgYWxsUHJvcHMsIGVhc2VFYWNoKSB7XHJcbiAgdmFyIGVhc2UgPSBvYmouZWFzZSB8fCBlYXNlRWFjaCB8fCBcInBvd2VyMS5pbk91dFwiLFxyXG4gICAgICBwLFxyXG4gICAgICBhO1xyXG5cclxuICBpZiAoX2lzQXJyYXkob2JqKSkge1xyXG4gICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTsgLy8gdCA9IHRpbWUgKG91dCBvZiAxMDApLCB2ID0gdmFsdWUsIGUgPSBlYXNlXHJcblxyXG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XHJcbiAgICAgIHJldHVybiBhLnB1c2goe1xyXG4gICAgICAgIHQ6IGkgLyAob2JqLmxlbmd0aCAtIDEpICogMTAwLFxyXG4gICAgICAgIHY6IHZhbHVlLFxyXG4gICAgICAgIGU6IGVhc2VcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChwIGluIG9iaikge1xyXG4gICAgICBhID0gYWxsUHJvcHNbcF0gfHwgKGFsbFByb3BzW3BdID0gW10pO1xyXG4gICAgICBwID09PSBcImVhc2VcIiB8fCBhLnB1c2goe1xyXG4gICAgICAgIHQ6IHBhcnNlRmxvYXQocHJvcCksXHJcbiAgICAgICAgdjogb2JqW3BdLFxyXG4gICAgICAgIGU6IGVhc2VcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59LFxyXG4gICAgX3BhcnNlRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlRnVuY09yU3RyaW5nKHZhbHVlLCB0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSB7XHJcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xyXG59LFxyXG4gICAgX3N0YWdnZXJUd2VlblByb3BzID0gX2NhbGxiYWNrTmFtZXMgKyBcInJlcGVhdCxyZXBlYXREZWxheSx5b3lvLHJlcGVhdFJlZnJlc2gseW95b0Vhc2UsYXV0b1JldmVydFwiLFxyXG4gICAgX3N0YWdnZXJQcm9wc1RvU2tpcCA9IHt9O1xyXG5cclxuX2ZvckVhY2hOYW1lKF9zdGFnZ2VyVHdlZW5Qcm9wcyArIFwiLGlkLHN0YWdnZXIsZGVsYXksZHVyYXRpb24scGF1c2VkLHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4gX3N0YWdnZXJQcm9wc1RvU2tpcFtuYW1lXSA9IDE7XHJcbn0pO1xyXG4vKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBUV0VFTlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgdmFyIFR3ZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0aW9uMikge1xyXG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XHJcblxyXG4gIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xyXG4gICAgdmFyIF90aGlzMztcclxuXHJcbiAgICBpZiAodHlwZW9mIHZhcnMgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xyXG4gICAgICB2YXJzID0gcG9zaXRpb247XHJcbiAgICAgIHBvc2l0aW9uID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpczMgPSBfQW5pbWF0aW9uMi5jYWxsKHRoaXMsIHNraXBJbmhlcml0ID8gdmFycyA6IF9pbmhlcml0RGVmYXVsdHModmFycykpIHx8IHRoaXM7XHJcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcclxuICAgICAgICBkdXJhdGlvbiA9IF90aGlzMyR2YXJzLmR1cmF0aW9uLFxyXG4gICAgICAgIGRlbGF5ID0gX3RoaXMzJHZhcnMuZGVsYXksXHJcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxyXG4gICAgICAgIHN0YWdnZXIgPSBfdGhpczMkdmFycy5zdGFnZ2VyLFxyXG4gICAgICAgIG92ZXJ3cml0ZSA9IF90aGlzMyR2YXJzLm92ZXJ3cml0ZSxcclxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXHJcbiAgICAgICAgZGVmYXVsdHMgPSBfdGhpczMkdmFycy5kZWZhdWx0cyxcclxuICAgICAgICBzY3JvbGxUcmlnZ2VyID0gX3RoaXMzJHZhcnMuc2Nyb2xsVHJpZ2dlcixcclxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxyXG4gICAgICAgIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcclxuICAgICAgICBwYXJzZWRUYXJnZXRzID0gKF9pc0FycmF5KHRhcmdldHMpIHx8IF9pc1R5cGVkQXJyYXkodGFyZ2V0cykgPyBfaXNOdW1iZXIodGFyZ2V0c1swXSkgOiBcImxlbmd0aFwiIGluIHZhcnMpID8gW3RhcmdldHNdIDogdG9BcnJheSh0YXJnZXRzKSxcclxuICAgICAgICB0bCxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGNvcHksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBwLFxyXG4gICAgICAgIGN1clRhcmdldCxcclxuICAgICAgICBzdGFnZ2VyRnVuYyxcclxuICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2U7XHJcbiAgICBfdGhpczMuX3RhcmdldHMgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aCA/IF9oYXJuZXNzKHBhcnNlZFRhcmdldHMpIDogX3dhcm4oXCJHU0FQIHRhcmdldCBcIiArIHRhcmdldHMgKyBcIiBub3QgZm91bmQuIGh0dHBzOi8vZ3NhcC5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xyXG4gICAgX3RoaXMzLl9wdExvb2t1cCA9IFtdOyAvL1Byb3BUd2VlbiBsb29rdXAuIEFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIHRhcmdldCwgaGF2aW5nIGtleXMgZm9yIGVhY2ggdHdlZW5pbmcgcHJvcGVydHlcclxuXHJcbiAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcclxuXHJcbiAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XHJcbiAgICAgIHZhcnMgPSBfdGhpczMudmFycztcclxuICAgICAgdGwgPSBfdGhpczMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xyXG4gICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXHJcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9LFxyXG4gICAgICAgIHRhcmdldHM6IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC52YXJzLnRhcmdldHMgOiBwYXJzZWRUYXJnZXRzXHJcbiAgICAgIH0pOyAvLyB3ZSBuZWVkIHRvIHN0b3JlIHRoZSB0YXJnZXRzIGJlY2F1c2UgZm9yIHN0YWdnZXJzIGFuZCBrZXlmcmFtZXMsIHdlIGVuZCB1cCBjcmVhdGluZyBhbiBpbmRpdmlkdWFsIHR3ZWVuIGZvciBlYWNoIGJ1dCBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgbmVlZCB0byBrbm93IHRoZSBpbmRleCBhbmQgdGhlIHdob2xlIEFycmF5IG9mIHRhcmdldHMuXHJcblxyXG4gICAgICB0bC5raWxsKCk7XHJcbiAgICAgIHRsLnBhcmVudCA9IHRsLl9kcCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcclxuICAgICAgdGwuX3N0YXJ0ID0gMDtcclxuXHJcbiAgICAgIGlmIChzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xyXG4gICAgICAgIGwgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcclxuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgJiYgZGlzdHJpYnV0ZShzdGFnZ2VyKTtcclxuXHJcbiAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xyXG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cclxuICAgICAgICAgIGZvciAocCBpbiBzdGFnZ2VyKSB7XHJcbiAgICAgICAgICAgIGlmICh+X3N0YWdnZXJUd2VlblByb3BzLmluZGV4T2YocCkpIHtcclxuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgfHwgKHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9KTtcclxuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICBjb3B5ID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3N0YWdnZXJQcm9wc1RvU2tpcCk7XHJcbiAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xyXG4gICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XHJcbiAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XHJcbiAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldOyAvL2Rvbid0IGp1c3QgY29weSBkdXJhdGlvbiBvciBkZWxheSBiZWNhdXNlIGlmIHRoZXkncmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24sIHdlJ2QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AgYmVjYXVzZSBfaXNGdW5jT3JTdHJpbmcoKSB3b3VsZCBldmFsdWF0ZSBhcyB0cnVlIGluIHRoZSBjaGlsZCB0d2VlbnMsIGVudGVyaW5nIHRoaXMgbG9vcCwgZXRjLiBTbyB3ZSBwYXJzZSB0aGUgdmFsdWUgc3RyYWlnaHQgZnJvbSB2YXJzIGFuZCBkZWZhdWx0IHRvIDAuXHJcblxyXG4gICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcclxuICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcclxuXHJcbiAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHNvbWVvbmUgZG9lcyBkZWxheTpcInJhbmRvbSgxLCA1KVwiLCByZXBlYXQ6LTEsIGZvciBleGFtcGxlLCB0aGUgZGVsYXkgc2hvdWxkbid0IGJlIGluc2lkZSB0aGUgcmVwZWF0LlxyXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xyXG4gICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xyXG4gICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0bC50byhjdXJUYXJnZXQsIGNvcHksIHN0YWdnZXJGdW5jID8gc3RhZ2dlckZ1bmMoaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSA6IDApO1xyXG4gICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXHJcbiAgICAgIH0gZWxzZSBpZiAoa2V5ZnJhbWVzKSB7XHJcbiAgICAgICAgX2luaGVyaXREZWZhdWx0cyhfc2V0RGVmYXVsdHModGwudmFycy5kZWZhdWx0cywge1xyXG4gICAgICAgICAgZWFzZTogXCJub25lXCJcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHRsLl9lYXNlID0gX3BhcnNlRWFzZShrZXlmcmFtZXMuZWFzZSB8fCB2YXJzLmVhc2UgfHwgXCJub25lXCIpO1xyXG4gICAgICAgIHZhciB0aW1lID0gMCxcclxuICAgICAgICAgICAgYSxcclxuICAgICAgICAgICAga2YsXHJcbiAgICAgICAgICAgIHY7XHJcblxyXG4gICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XHJcbiAgICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRsLmR1cmF0aW9uKCk7IC8vIHRvIGVuc3VyZSB0bC5fZHVyIGlzIGNhY2hlZCBiZWNhdXNlIHdlIHRhcCBpbnRvIGl0IGZvciBwZXJmb3JtYW5jZSBwdXJwb3NlcyBpbiB0aGUgcmVuZGVyKCkgbWV0aG9kLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb3B5ID0ge307XHJcblxyXG4gICAgICAgICAgZm9yIChwIGluIGtleWZyYW1lcykge1xyXG4gICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAocCBpbiBjb3B5KSB7XHJcbiAgICAgICAgICAgIGEgPSBjb3B5W3BdLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYS50IC0gYi50O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGltZSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGtmID0gYVtpXTtcclxuICAgICAgICAgICAgICB2ID0ge1xyXG4gICAgICAgICAgICAgICAgZWFzZToga2YuZSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAoa2YudCAtIChpID8gYVtpIC0gMV0udCA6IDApKSAvIDEwMCAqIGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB2W3BdID0ga2YudjtcclxuICAgICAgICAgICAgICB0bC50byhwYXJzZWRUYXJnZXRzLCB2LCB0aW1lKTtcclxuICAgICAgICAgICAgICB0aW1lICs9IHYuZHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcclxuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC0gdGwuZHVyYXRpb24oKVxyXG4gICAgICAgICAgfSk7IC8vIGluIGNhc2Uga2V5ZnJhbWVzIGRpZG4ndCBnbyB0byAxMDAlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF90aGlzMy50aW1lbGluZSA9IDA7IC8vc3BlZWQgb3B0aW1pemF0aW9uLCBmYXN0ZXIgbG9va3VwcyAobm8gZ29pbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbilcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3ZlcndyaXRlID09PSB0cnVlICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzKSB7XHJcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xyXG5cclxuICAgICAgX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZihwYXJzZWRUYXJnZXRzKTtcclxuXHJcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBfYWRkVG9UaW1lbGluZShwYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgcG9zaXRpb24pO1xyXG5cclxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcclxuICAgIHZhcnMucGF1c2VkICYmIF90aGlzMy5wYXVzZWQodHJ1ZSk7XHJcblxyXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xyXG4gICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcclxuXHJcbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSB8fCAwKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBzY3JvbGxUcmlnZ2VyKTtcclxuICAgIHJldHVybiBfdGhpczM7XHJcbiAgfVxyXG5cclxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcclxuXHJcbiAgX3Byb3RvMy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcclxuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXHJcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXHJcbiAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxyXG4gICAgICAgIGlzTmVnYXRpdmUgPSB0b3RhbFRpbWUgPCAwLFxyXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmICFpc05lZ2F0aXZlID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcclxuICAgICAgICB0aW1lLFxyXG4gICAgICAgIHB0LFxyXG4gICAgICAgIGl0ZXJhdGlvbixcclxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxyXG4gICAgICAgIHByZXZJdGVyYXRpb24sXHJcbiAgICAgICAgaXNZb3lvLFxyXG4gICAgICAgIHJhdGlvLFxyXG4gICAgICAgIHRpbWVsaW5lLFxyXG4gICAgICAgIHlveW9FYXNlO1xyXG5cclxuICAgIGlmICghZHVyKSB7XHJcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICF0aGlzLl9pbml0dGVkICYmIHRoaXMuX3RUaW1lIHx8IHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5felRpbWUgPCAwICE9PSBpc05lZ2F0aXZlIHx8IHRoaXMuX2xhenkpIHtcclxuICAgICAgLy8gdGhpcyBzZW5zZXMgaWYgd2UncmUgY3Jvc3Npbmcgb3ZlciB0aGUgc3RhcnQgdGltZSwgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHJlY29yZCBfelRpbWUgYW5kIGZvcmNlIHRoZSByZW5kZXIsIGJ1dCB3ZSBkbyBpdCBpbiB0aGlzIGxlbmd0aHkgY29uZGl0aW9uYWwgd2F5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zICh1c3VhbGx5IHdlIGNhbiBza2lwIHRoZSBjYWxjdWxhdGlvbnMpOiB0aGlzLl9pbml0dGVkICYmICh0aGlzLl96VGltZSA8IDApICE9PSAodG90YWxUaW1lIDwgMClcclxuICAgICAgdGltZSA9IHRUaW1lO1xyXG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmU7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XHJcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXHJcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcclxuXHJcbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XHJcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxyXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xyXG4gICAgICAgICAgdGltZSA9IGR1cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9yb3VuZFByZWNpc2UodFRpbWUgLyBjeWNsZUR1cmF0aW9uKTsgLy8gZnVsbCBkZWNpbWFsIHZlcnNpb24gb2YgaXRlcmF0aW9ucywgbm90IHRoZSBwcmV2aW91cyBpdGVyYXRpb24gKHdlJ3JlIHJldXNpbmcgcHJldkl0ZXJhdGlvbiB2YXJpYWJsZSBmb3IgZWZmaWNpZW5jeSlcclxuXHJcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fnByZXZJdGVyYXRpb247XHJcblxyXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHByZXZJdGVyYXRpb24pIHtcclxuICAgICAgICAgICAgdGltZSA9IGR1cjtcclxuICAgICAgICAgICAgaXRlcmF0aW9uLS07XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiBkdXIpIHtcclxuICAgICAgICAgICAgdGltZSA9IGR1cjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcclxuXHJcbiAgICAgICAgaWYgKGlzWW95bykge1xyXG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcclxuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XHJcblxyXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCAmJiBpdGVyYXRpb24gPT09IHByZXZJdGVyYXRpb24pIHtcclxuICAgICAgICAgIC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSB7XHJcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2sgJiYgdGltZSAhPT0gY3ljbGVEdXJhdGlvbiAmJiB0aGlzLl9pbml0dGVkKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuX3RpbWUgd2lsbCA9PT0gY3ljbGVEdXJhdGlvbiB3aGVuIHdlIHJlbmRlciBhdCBFWEFDVExZIHRoZSBlbmQgb2YgYW4gaXRlcmF0aW9uLiBXaXRob3V0IHRoaXMgY29uZGl0aW9uLCBpdCdkIG9mdGVuIGRvIHRoZSByZXBlYXRSZWZyZXNoIHJlbmRlciBUV0lDRSAoYWdhaW4gb24gdGhlIHZlcnkgbmV4dCB0aWNrKS5cclxuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKF9yb3VuZFByZWNpc2UoY3ljbGVEdXJhdGlvbiAqIGl0ZXJhdGlvbiksIHRydWUpLmludmFsaWRhdGUoKS5fbG9jayA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcclxuICAgICAgICBpZiAoX2F0dGVtcHRJbml0VHdlZW4odGhpcywgaXNOZWdhdGl2ZSA/IHRvdGFsVGltZSA6IHRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cywgdFRpbWUpKSB7XHJcbiAgICAgICAgICB0aGlzLl90VGltZSA9IDA7IC8vIGluIGNvbnN0cnVjdG9yIGlmIGltbWVkaWF0ZVJlbmRlciBpcyB0cnVlLCB3ZSBzZXQgX3RUaW1lIHRvIC1fdGlueU51bSB0byBoYXZlIHRoZSBwbGF5aGVhZCBjcm9zcyB0aGUgc3RhcnRpbmcgcG9pbnQgYnV0IHdlIGNhbid0IGxlYXZlIF90VGltZSBhcyBhIG5lZ2F0aXZlIG51bWJlci5cclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiAhKGZvcmNlICYmIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbikpIHtcclxuICAgICAgICAgIC8vIHJhcmUgZWRnZSBjYXNlIC0gZHVyaW5nIGluaXRpYWxpemF0aW9uLCBhbiBvblVwZGF0ZSBpbiB0aGUgX3N0YXJ0QXQgKC5mcm9tVG8oKSkgbWlnaHQgZm9yY2UgdGhpcyB0d2VlbiB0byByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkaXRjaCB0aGlzIHJlbmRlcigpIGNhbGwgc28gdGhhdCBpdCBkb2Vzbid0IHJldmVydCB0aGUgdmFsdWVzLiBCdXQgd2UgYWxzbyBkb24ndCB3YW50IHRvIGR1bXAgaWYgd2UncmUgZG9pbmcgYSByZXBlYXRSZWZyZXNoIHJlbmRlciFcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XHJcbiAgICAgICAgICAvLyB3aGlsZSBpbml0dGluZywgYSBwbHVnaW4gbGlrZSBJbmVydGlhUGx1Z2luIG1pZ2h0IGFsdGVyIHRoZSBkdXJhdGlvbiwgc28gcmVydW4gZnJvbSB0aGUgc3RhcnQgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcmVuZGVycyBhcyBpdCBzaG91bGQuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcclxuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuX2FjdCAmJiB0aGlzLl90cykge1xyXG4gICAgICAgIHRoaXMuX2FjdCA9IDE7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxyXG5cclxuICAgICAgICB0aGlzLl9sYXp5ID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gKHlveW9FYXNlIHx8IHRoaXMuX2Vhc2UpKHRpbWUgLyBkdXIpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcclxuICAgICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAxIC0gcmF0aW87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcHJldlRpbWUgJiYgdFRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFwcmV2SXRlcmF0aW9uKSB7XHJcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xyXG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcHQgPSB0aGlzLl9wdDtcclxuXHJcbiAgICAgIHdoaWxlIChwdCkge1xyXG4gICAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xyXG4gICAgICAgIHB0ID0gcHQuX25leHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnJlbmRlcih0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZWxpbmUuX2R1ciAqIHRpbWVsaW5lLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHx8IHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcclxuICAgICAgICBpc05lZ2F0aXZlICYmIF9yZXdpbmRTdGFydEF0KHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cclxuXHJcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25VcGRhdGVcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3JlcGVhdCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcclxuXHJcbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcclxuICAgICAgICBpc05lZ2F0aXZlICYmICF0aGlzLl9vblVwZGF0ZSAmJiBfcmV3aW5kU3RhcnRBdCh0aGlzLCB0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0aGlzLl90RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHdlJ3JlIHJlbmRlcmluZyBhdCBleGFjdGx5IGEgdGltZSBvZiAwLCBhcyB0aGVyZSBjb3VsZCBiZSBhdXRvUmV2ZXJ0IHZhbHVlcyB0aGF0IHNob3VsZCBnZXQgc2V0IG9uIHRoZSBuZXh0IHRpY2sgKGlmIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIGJleW9uZCB0aGUgc3RhcnRUaW1lLCBuZWdhdGl2ZSB0b3RhbFRpbWUpLiBEb24ndCByZW1vdmUgaWYgdGhlIHRpbWVsaW5lIGlzIHJldmVyc2VkIGFuZCB0aGUgcGxheWhlYWQgaXNuJ3QgYXQgMCwgb3RoZXJ3aXNlIHRsLnByb2dyZXNzKDEpLnJldmVyc2UoKSB3b24ndCB3b3JrLiBPbmx5IHJlbW92ZSBpZiB0aGUgcGxheWhlYWQgaXMgYXQgdGhlIGVuZCBhbmQgdGltZVNjYWxlIGlzIHBvc2l0aXZlLCBvciBpZiB0aGUgcGxheWhlYWQgaXMgYXQgMCBhbmQgdGhlIHRpbWVTY2FsZSBpcyBuZWdhdGl2ZS5cclxuXHJcbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKGlzTmVnYXRpdmUgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgaXNZb3lvKSkge1xyXG4gICAgICAgICAgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XHJcbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzMudGFyZ2V0cyA9IGZ1bmN0aW9uIHRhcmdldHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcclxuICB9O1xyXG5cclxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKHNvZnQpIHtcclxuICAgIC8vIFwic29mdFwiIGdpdmVzIHVzIGEgd2F5IHRvIGNsZWFyIG91dCBldmVyeXRoaW5nIEVYQ0VQVCB0aGUgcmVjb3JkZWQgcHJlLVwiZnJvbVwiIHBvcnRpb24gb2YgZnJvbSgpIHR3ZWVucy4gT3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgaWYgeW91IHR3ZWVuLnByb2dyZXNzKDEpLnJlbmRlcigwLCB0cnVlIHRydWUpLmludmFsaWRhdGUoKSwgdGhlIFwiZnJvbVwiIHZhbHVlcyB3b3VsZCBwZXJzaXN0IGFuZCB0aGVuIG9uIHRoZSBuZXh0IHJlbmRlciwgdGhlIGZyb20oKSB0d2VlbnMgd291bGQgaW5pdGlhbGl6ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgbWF0Y2ggdGhlIFwiZnJvbVwiIHZhbHVlcywgdGh1cyBhbmltYXRlIGZyb20gdGhlIHNhbWUgdmFsdWUgdG8gdGhlIHNhbWUgdmFsdWUgKG5vIGFuaW1hdGlvbikuIFdlIHRhcCBpbnRvIHRoaXMgaW4gU2Nyb2xsVHJpZ2dlcidzIHJlZnJlc2goKSB3aGVyZSB3ZSBtdXN0IHB1c2ggYSB0d2VlbiB0byBjb21wbGV0aW9uIGFuZCB0aGVuIGJhY2sgYWdhaW4gYnV0IGhvbm9yIGl0cyBpbml0IHN0YXRlIGluIGNhc2UgdGhlIHR3ZWVuIGlzIGRlcGVuZGVudCBvbiBhbm90aGVyIHR3ZWVuIGZ1cnRoZXIgdXAgb24gdGhlIHBhZ2UuXHJcbiAgICAoIXNvZnQgfHwgIXRoaXMudmFycy5ydW5CYWNrd2FyZHMpICYmICh0aGlzLl9zdGFydEF0ID0gMCk7XHJcbiAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XHJcbiAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xyXG4gICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoc29mdCk7XHJcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8zLnJlc2V0VG8gPSBmdW5jdGlvbiByZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgc2tpcFJlY3Vyc2lvbikge1xyXG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcclxuICAgIHRoaXMuX3RzIHx8IHRoaXMucGxheSgpO1xyXG4gICAgdmFyIHRpbWUgPSBNYXRoLm1pbih0aGlzLl9kdXIsICh0aGlzLl9kcC5fdGltZSAtIHRoaXMuX3N0YXJ0KSAqIHRoaXMuX3RzKSxcclxuICAgICAgICByYXRpbztcclxuICAgIHRoaXMuX2luaXR0ZWQgfHwgX2luaXRUd2Vlbih0aGlzLCB0aW1lKTtcclxuICAgIHJhdGlvID0gdGhpcy5fZWFzZSh0aW1lIC8gdGhpcy5fZHVyKTsgLy8gZG9uJ3QganVzdCBnZXQgdHdlZW4ucmF0aW8gYmVjYXVzZSBpdCBtYXkgbm90IGhhdmUgcmVuZGVyZWQgeWV0LlxyXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cclxuICAgIC8vIGlmIChfaXNPYmplY3QocHJvcGVydHkpKSB7IC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxyXG4gICAgLy8gXHRmb3IgKHAgaW4gcHJvcGVydHkpIHtcclxuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XHJcbiAgICAvLyBcdFx0XHRyZXR1cm4gdGhpcy5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7IC8vIGlmIGEgUHJvcFR3ZWVuIHdhc24ndCBmb3VuZCBmb3IgdGhlIHByb3BlcnR5LCBpdCdsbCBnZXQgZm9yY2VkIHdpdGggYSByZS1pbml0aWFsaXphdGlvbiBzbyB3ZSBuZWVkIHRvIGp1bXAgb3V0IGFuZCBzdGFydCBvdmVyIGFnYWluLlxyXG4gICAgLy8gXHRcdH1cclxuICAgIC8vIFx0fVxyXG4gICAgLy8gfSBlbHNlIHtcclxuXHJcbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSwgc2tpcFJlY3Vyc2lvbikpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIDEpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cclxuICAgIH0gLy99XHJcblxyXG5cclxuICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIDApO1xyXG5cclxuICAgIHRoaXMucGFyZW50IHx8IF9hZGRMaW5rZWRMaXN0SXRlbSh0aGlzLl9kcCwgdGhpcywgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aGlzLl9kcC5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcclxuICAgIHJldHVybiB0aGlzLnJlbmRlcigwKTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcclxuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcclxuICAgICAgdmFycyA9IFwiYWxsXCI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xyXG4gICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xyXG4gICAgICB0aGlzLnBhcmVudCA/IF9pbnRlcnJ1cHQodGhpcykgOiB0aGlzLnNjcm9sbFRyaWdnZXIgJiYgdGhpcy5zY3JvbGxUcmlnZ2VyLmtpbGwoISFfcmV2ZXJ0aW5nKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcclxuICAgICAgdGhpcy50aW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgdmFycywgX292ZXJ3cml0aW5nVHdlZW4gJiYgX292ZXJ3cml0aW5nVHdlZW4udmFycy5vdmVyd3JpdGUgIT09IHRydWUpLl9maXJzdCB8fCBfaW50ZXJydXB0KHRoaXMpOyAvLyBpZiBub3RoaW5nIGlzIGxlZnQgdHdlZW5pbmcsIGludGVycnVwdC5cclxuXHJcbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcclxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcclxuICAgICAgICBwcm9wVHdlZW5Mb29rdXAgPSB0aGlzLl9wdExvb2t1cCxcclxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXHJcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcclxuICAgICAgICBjdXJMb29rdXAsXHJcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAgcCxcclxuICAgICAgICBwdCxcclxuICAgICAgICBpO1xyXG5cclxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xyXG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xyXG4gICAgICByZXR1cm4gX2ludGVycnVwdCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3AgPSB0aGlzLl9vcCB8fCBbXTtcclxuXHJcbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xyXG4gICAgICAvL3NvIHBlb3BsZSBjYW4gcGFzcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXHJcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcclxuICAgICAgICBwID0ge307XHJcblxyXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXJzID0gcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xyXG4gICAgICAgIGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcclxuXHJcbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcclxuICAgICAgICAgIG92ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzO1xyXG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XHJcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xyXG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XHJcbiAgICAgICAgICBwdCA9IGN1ckxvb2t1cCAmJiBjdXJMb29rdXBbcF07XHJcblxyXG4gICAgICAgICAgaWYgKHB0KSB7XHJcbiAgICAgICAgICAgIGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XHJcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xyXG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xyXG4gIH07XHJcblxyXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcclxuICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxuXHJcbiAgVHdlZW4uZGVsYXllZENhbGwgPSBmdW5jdGlvbiBkZWxheWVkQ2FsbChkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcclxuICAgIHJldHVybiBuZXcgVHdlZW4oY2FsbGJhY2ssIDAsIHtcclxuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcclxuICAgICAgbGF6eTogZmFsc2UsXHJcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXHJcbiAgICAgIGRlbGF5OiBkZWxheSxcclxuICAgICAgb25Db21wbGV0ZTogY2FsbGJhY2ssXHJcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlOiBjYWxsYmFjayxcclxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxyXG4gICAgICBvblJldmVyc2VDb21wbGV0ZVBhcmFtczogcGFyYW1zLFxyXG4gICAgICBjYWxsYmFja1Njb3BlOiBzY29wZVxyXG4gICAgfSk7IC8vIHdlIG11c3QgdXNlIG9uUmV2ZXJzZUNvbXBsZXRlIHRvbyBmb3IgdGhpbmdzIGxpa2UgdGltZWxpbmUuYWRkKCgpID0+IHsuLi59KSB3aGljaCBzaG91bGQgYmUgdHJpZ2dlcmVkIGluIEJPVEggZGlyZWN0aW9ucyAoZm9yd2FyZCBhbmQgcmV2ZXJzZSlcclxuICB9O1xyXG5cclxuICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcclxuICB9O1xyXG5cclxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xyXG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XHJcbiAgICB2YXJzLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xyXG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcclxuICB9O1xyXG5cclxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcclxuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVHdlZW47XHJcbn0oQW5pbWF0aW9uKTtcclxuXHJcbl9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtcclxuICBfdGFyZ2V0czogW10sXHJcbiAgX2xhenk6IDAsXHJcbiAgX3N0YXJ0QXQ6IDAsXHJcbiAgX29wOiAwLFxyXG4gIF9vbkluaXQ6IDBcclxufSk7IC8vYWRkIHRoZSBwZXJ0aW5lbnQgdGltZWxpbmUgbWV0aG9kcyB0byBUd2VlbiBpbnN0YW5jZXMgc28gdGhhdCB1c2VycyBjYW4gY2hhaW4gY29udmVuaWVudGx5IGFuZCBjcmVhdGUgYSB0aW1lbGluZSBhdXRvbWF0aWNhbGx5LiAocmVtb3ZlZCBkdWUgdG8gY29uY2VybnMgdGhhdCBpdCdkIHVsdGltYXRlbHkgYWRkIHRvIG1vcmUgY29uZnVzaW9uIGVzcGVjaWFsbHkgZm9yIGJlZ2lubmVycylcclxuLy8gX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sc2V0LGNhbGwsYWRkLGFkZExhYmVsLGFkZFBhdXNlXCIsIG5hbWUgPT4ge1xyXG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4vLyBcdFx0bGV0IHRsID0gbmV3IFRpbWVsaW5lKCk7XHJcbi8vIFx0XHRyZXR1cm4gX2FkZFRvVGltZWxpbmUodGwsIHRoaXMpW25hbWVdLmFwcGx5KHRsLCB0b0FycmF5KGFyZ3VtZW50cykpO1xyXG4vLyBcdH1cclxuLy8gfSk7XHJcbi8vZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIExldmVyYWdlIHRoZSB0aW1lbGluZSBjYWxscy5cclxuXHJcblxyXG5fZm9yRWFjaE5hbWUoXCJzdGFnZ2VyVG8sc3RhZ2dlckZyb20sc3RhZ2dlckZyb21Ub1wiLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKCksXHJcbiAgICAgICAgcGFyYW1zID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgICBwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xyXG4gICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xyXG4gIH07XHJcbn0pO1xyXG4vKlxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBQUk9QVFdFRU5cclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICovXHJcblxyXG5cclxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XHJcbn0sXHJcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0odmFsdWUpO1xyXG59LFxyXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xyXG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKTtcclxufSxcclxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XHJcbiAgcmV0dXJuIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHZhbHVlKTtcclxufSxcclxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcclxuICByZXR1cm4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbjtcclxufSxcclxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xyXG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKTtcclxufSxcclxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcclxuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XHJcbn0sXHJcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XHJcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXHJcbiAgICAgIHMgPSBcIlwiO1xyXG5cclxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xyXG4gICAgLy9iID0gYmVnaW5uaW5nIHN0cmluZ1xyXG4gICAgcyA9IGRhdGEuYjtcclxuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xyXG4gICAgLy9lID0gZW5kaW5nIHN0cmluZ1xyXG4gICAgcyA9IGRhdGEuZTtcclxuICB9IGVsc2Uge1xyXG4gICAgd2hpbGUgKHB0KSB7XHJcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cclxuXHJcbiAgICAgIHB0ID0gcHQuX25leHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcyArPSBkYXRhLmM7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBjaHVuayBvZiBub24tbnVtZXJpYyB0ZXh0LlxyXG4gIH1cclxuXHJcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIHMsIGRhdGEpO1xyXG59LFxyXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xyXG4gIHZhciBwdCA9IGRhdGEuX3B0O1xyXG5cclxuICB3aGlsZSAocHQpIHtcclxuICAgIHB0LnIocmF0aW8sIHB0LmQpO1xyXG4gICAgcHQgPSBwdC5fbmV4dDtcclxuICB9XHJcbn0sXHJcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XHJcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXHJcbiAgICAgIG5leHQ7XHJcblxyXG4gIHdoaWxlIChwdCkge1xyXG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xyXG4gICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xyXG4gICAgcHQgPSBuZXh0O1xyXG4gIH1cclxufSxcclxuICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcclxuICB2YXIgcHQgPSB0aGlzLl9wdCxcclxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxyXG4gICAgICBuZXh0O1xyXG5cclxuICB3aGlsZSAocHQpIHtcclxuICAgIG5leHQgPSBwdC5fbmV4dDtcclxuXHJcbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xyXG4gICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xyXG4gICAgfSBlbHNlIGlmICghcHQuZGVwKSB7XHJcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcHQgPSBuZXh0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XHJcbn0sXHJcbiAgICBfc2V0dGVyV2l0aE1vZGlmaWVyID0gZnVuY3Rpb24gX3NldHRlcldpdGhNb2RpZmllcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xyXG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xyXG59LFxyXG4gICAgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSA9IGZ1bmN0aW9uIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkocGFyZW50KSB7XHJcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcclxuICAgICAgbmV4dCxcclxuICAgICAgcHQyLFxyXG4gICAgICBmaXJzdCxcclxuICAgICAgbGFzdDsgLy9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcclxuXHJcbiAgd2hpbGUgKHB0KSB7XHJcbiAgICBuZXh0ID0gcHQuX25leHQ7XHJcbiAgICBwdDIgPSBmaXJzdDtcclxuXHJcbiAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XHJcbiAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSB7XHJcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmaXJzdCA9IHB0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwdC5fbmV4dCA9IHB0Mikge1xyXG4gICAgICBwdDIuX3ByZXYgPSBwdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxhc3QgPSBwdDtcclxuICAgIH1cclxuXHJcbiAgICBwdCA9IG5leHQ7XHJcbiAgfVxyXG5cclxuICBwYXJlbnQuX3B0ID0gZmlyc3Q7XHJcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXHJcblxyXG5cclxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFByb3BUd2VlbihuZXh0LCB0YXJnZXQsIHByb3AsIHN0YXJ0LCBjaGFuZ2UsIHJlbmRlcmVyLCBkYXRhLCBzZXR0ZXIsIHByaW9yaXR5KSB7XHJcbiAgICB0aGlzLnQgPSB0YXJnZXQ7XHJcbiAgICB0aGlzLnMgPSBzdGFydDtcclxuICAgIHRoaXMuYyA9IGNoYW5nZTtcclxuICAgIHRoaXMucCA9IHByb3A7XHJcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XHJcbiAgICB0aGlzLmQgPSBkYXRhIHx8IHRoaXM7XHJcbiAgICB0aGlzLnNldCA9IHNldHRlciB8fCBfc2V0dGVyUGxhaW47XHJcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcclxuICAgIHRoaXMuX25leHQgPSBuZXh0O1xyXG5cclxuICAgIGlmIChuZXh0KSB7XHJcbiAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIF9wcm90bzQgPSBQcm9wVHdlZW4ucHJvdG90eXBlO1xyXG5cclxuICBfcHJvdG80Lm1vZGlmaWVyID0gZnVuY3Rpb24gbW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xyXG4gICAgdGhpcy5tU2V0ID0gdGhpcy5tU2V0IHx8IHRoaXMuc2V0OyAvL2luIGNhc2UgaXQgd2FzIGFscmVhZHkgc2V0IChhIFByb3BUd2VlbiBjYW4gb25seSBoYXZlIG9uZSBtb2RpZmllcilcclxuXHJcbiAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XHJcbiAgICB0aGlzLm0gPSBmdW5jO1xyXG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcclxuXHJcbiAgICB0aGlzLnR3ZWVuID0gdHdlZW47XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFByb3BUd2VlbjtcclxufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXHJcblxyXG5fZm9yRWFjaE5hbWUoX2NhbGxiYWNrTmFtZXMgKyBcInBhcmVudCxkdXJhdGlvbixlYXNlLGRlbGF5LG92ZXJ3cml0ZSxydW5CYWNrd2FyZHMsc3RhcnRBdCx5b3lvLGltbWVkaWF0ZVJlbmRlcixyZXBlYXQscmVwZWF0RGVsYXksZGF0YSxwYXVzZWQscmV2ZXJzZWQsbGF6eSxjYWxsYmFja1Njb3BlLHN0cmluZ0ZpbHRlcixpZCx5b3lvRWFzZSxzdGFnZ2VyLGluaGVyaXQscmVwZWF0UmVmcmVzaCxrZXlmcmFtZXMsYXV0b1JldmVydCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcclxufSk7XHJcblxyXG5fZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xyXG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xyXG5fZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xyXG4gIHNvcnRDaGlsZHJlbjogZmFsc2UsXHJcbiAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcclxuICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXHJcbiAgaWQ6IFwicm9vdFwiLFxyXG4gIHNtb290aENoaWxkVGltaW5nOiB0cnVlXHJcbn0pO1xyXG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcclxuXHJcbnZhciBfbWVkaWEgPSBbXSxcclxuICAgIF9saXN0ZW5lcnMgPSB7fSxcclxuICAgIF9lbXB0eUFycmF5ID0gW10sXHJcbiAgICBfbGFzdE1lZGlhVGltZSA9IDAsXHJcbiAgICBfY29udGV4dElEID0gMCxcclxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XHJcbiAgcmV0dXJuIChfbGlzdGVuZXJzW3R5cGVdIHx8IF9lbXB0eUFycmF5KS5tYXAoZnVuY3Rpb24gKGYpIHtcclxuICAgIHJldHVybiBmKCk7XHJcbiAgfSk7XHJcbn0sXHJcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKCkge1xyXG4gIHZhciB0aW1lID0gRGF0ZS5ub3coKSxcclxuICAgICAgbWF0Y2hlcyA9IFtdO1xyXG5cclxuICBpZiAodGltZSAtIF9sYXN0TWVkaWFUaW1lID4gMikge1xyXG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYUluaXRcIik7XHJcblxyXG4gICAgX21lZGlhLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgdmFyIHF1ZXJpZXMgPSBjLnF1ZXJpZXMsXHJcbiAgICAgICAgICBjb25kaXRpb25zID0gYy5jb25kaXRpb25zLFxyXG4gICAgICAgICAgbWF0Y2gsXHJcbiAgICAgICAgICBwLFxyXG4gICAgICAgICAgYW55TWF0Y2gsXHJcbiAgICAgICAgICB0b2dnbGVkO1xyXG5cclxuICAgICAgZm9yIChwIGluIHF1ZXJpZXMpIHtcclxuICAgICAgICBtYXRjaCA9IF93aW4ubWF0Y2hNZWRpYShxdWVyaWVzW3BdKS5tYXRjaGVzOyAvLyBGaXJlZm94IGRvZXNuJ3QgdXBkYXRlIHRoZSBcIm1hdGNoZXNcIiBwcm9wZXJ0eSBvZiB0aGUgTWVkaWFRdWVyeUxpc3Qgb2JqZWN0IGNvcnJlY3RseSAtIGl0IG9ubHkgZG9lcyBzbyBhcyBpdCBjYWxscyBpdHMgY2hhbmdlIGhhbmRsZXIgLSBzbyB3ZSBtdXN0IHJlLWNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IGhlcmUgdG8gZW5zdXJlIGl0J3MgYWNjdXJhdGUuXHJcblxyXG4gICAgICAgIG1hdGNoICYmIChhbnlNYXRjaCA9IDEpO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2ggIT09IGNvbmRpdGlvbnNbcF0pIHtcclxuICAgICAgICAgIGNvbmRpdGlvbnNbcF0gPSBtYXRjaDtcclxuICAgICAgICAgIHRvZ2dsZWQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRvZ2dsZWQpIHtcclxuICAgICAgICBjLnJldmVydCgpO1xyXG4gICAgICAgIGFueU1hdGNoICYmIG1hdGNoZXMucHVzaChjKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgX2Rpc3BhdGNoKFwibWF0Y2hNZWRpYVJldmVydFwiKTtcclxuXHJcbiAgICBtYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgcmV0dXJuIGMub25NYXRjaChjLCBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIHJldHVybiBjLmFkZChudWxsLCBmdW5jKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIF9sYXN0TWVkaWFUaW1lID0gdGltZTtcclxuXHJcbiAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciBDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBDb250ZXh0KGZ1bmMsIHNjb3BlKSB7XHJcbiAgICB0aGlzLnNlbGVjdG9yID0gc2NvcGUgJiYgc2VsZWN0b3Ioc2NvcGUpO1xyXG4gICAgdGhpcy5kYXRhID0gW107XHJcbiAgICB0aGlzLl9yID0gW107IC8vIHJldHVybmVkL2NsZWFudXAgZnVuY3Rpb25zXHJcblxyXG4gICAgdGhpcy5pc1JldmVydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmlkID0gX2NvbnRleHRJRCsrOyAvLyB0byB3b3JrIGFyb3VuZCBpc3N1ZXMgdGhhdCBmcmFtZXdvcmtzIGxpa2UgVnVlIGNhdXNlIGJ5IG1ha2luZyB0aGluZ3MgaW50byBQcm94aWVzIHdoaWNoIG1ha2UgaXQgaW1wb3NzaWJsZSB0byBkbyBzb21ldGhpbmcgbGlrZSBfbWVkaWEuaW5kZXhPZih0aGlzKSBiZWNhdXNlIFwidGhpc1wiIHdvdWxkIG5vIGxvbmdlciByZWZlciB0byB0aGUgQ29udGV4dCBpbnN0YW5jZSBpdHNlbGYgLSBpdCdkIHJlZmVyIHRvIGEgUHJveHkhIFdlIG5lZWRlZCBhIHdheSB0byBpZGVudGlmeSB0aGUgY29udGV4dCB1bmlxdWVseVxyXG5cclxuICAgIGZ1bmMgJiYgdGhpcy5hZGQoZnVuYyk7XHJcbiAgfVxyXG5cclxuICB2YXIgX3Byb3RvNSA9IENvbnRleHQucHJvdG90eXBlO1xyXG5cclxuICBfcHJvdG81LmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBmdW5jLCBzY29wZSkge1xyXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIGlmIHdlIG5lZWQgdGhlIGFiaWxpdHkgdG8gYWRkKCkgYW4gYW5pbWF0aW9uIHRvIGEgY29udGV4dCBhbmQgZm9yIHdoYXRldmVyIHJlYXNvbiBjYW5ub3QgY3JlYXRlIHRoYXQgYW5pbWF0aW9uIGluc2lkZSBvZiBhIGNvbnRleHQuYWRkKCgpID0+IHsuLi59KSBmdW5jdGlvbi5cclxuICAgIC8vIGlmIChuYW1lICYmIF9pc0Z1bmN0aW9uKG5hbWUucmV2ZXJ0KSkge1xyXG4gICAgLy8gXHR0aGlzLmRhdGEucHVzaChuYW1lKTtcclxuICAgIC8vIFx0cmV0dXJuIChuYW1lLl9jdHggPSB0aGlzKTtcclxuICAgIC8vIH1cclxuICAgIGlmIChfaXNGdW5jdGlvbihuYW1lKSkge1xyXG4gICAgICBzY29wZSA9IGZ1bmM7XHJcbiAgICAgIGZ1bmMgPSBuYW1lO1xyXG4gICAgICBuYW1lID0gX2lzRnVuY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGYgPSBmdW5jdGlvbiBmKCkge1xyXG4gICAgICB2YXIgcHJldiA9IF9jb250ZXh0LFxyXG4gICAgICAgICAgcHJldlNlbGVjdG9yID0gc2VsZi5zZWxlY3RvcixcclxuICAgICAgICAgIHJlc3VsdDtcclxuICAgICAgcHJldiAmJiBwcmV2ICE9PSBzZWxmICYmIHByZXYuZGF0YS5wdXNoKHNlbGYpO1xyXG4gICAgICBzY29wZSAmJiAoc2VsZi5zZWxlY3RvciA9IHNlbGVjdG9yKHNjb3BlKSk7XHJcbiAgICAgIF9jb250ZXh0ID0gc2VsZjtcclxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICBfaXNGdW5jdGlvbihyZXN1bHQpICYmIHNlbGYuX3IucHVzaChyZXN1bHQpO1xyXG4gICAgICBfY29udGV4dCA9IHByZXY7XHJcbiAgICAgIHNlbGYuc2VsZWN0b3IgPSBwcmV2U2VsZWN0b3I7XHJcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmxhc3QgPSBmO1xyXG4gICAgcmV0dXJuIG5hbWUgPT09IF9pc0Z1bmN0aW9uID8gZihzZWxmLCBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICByZXR1cm4gc2VsZi5hZGQobnVsbCwgZnVuYyk7XHJcbiAgICB9KSA6IG5hbWUgPyBzZWxmW25hbWVdID0gZiA6IGY7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvNS5pZ25vcmUgPSBmdW5jdGlvbiBpZ25vcmUoZnVuYykge1xyXG4gICAgdmFyIHByZXYgPSBfY29udGV4dDtcclxuICAgIF9jb250ZXh0ID0gbnVsbDtcclxuICAgIGZ1bmModGhpcyk7XHJcbiAgICBfY29udGV4dCA9IHByZXY7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvNS5nZXRUd2VlbnMgPSBmdW5jdGlvbiBnZXRUd2VlbnMoKSB7XHJcbiAgICB2YXIgYSA9IFtdO1xyXG4gICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb250ZXh0ID8gYS5wdXNoLmFwcGx5KGEsIGUuZ2V0VHdlZW5zKCkpIDogZSBpbnN0YW5jZW9mIFR3ZWVuICYmICEoZS5wYXJlbnQgJiYgZS5wYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIikgJiYgYS5wdXNoKGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYTtcclxuICB9O1xyXG5cclxuICBfcHJvdG81LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9yLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzUua2lsbCA9IGZ1bmN0aW9uIGtpbGwocmV2ZXJ0LCBtYXRjaE1lZGlhKSB7XHJcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuXHJcbiAgICBpZiAocmV2ZXJ0KSB7XHJcbiAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHR3ZWVucyA9IF90aGlzNC5nZXRUd2VlbnMoKSxcclxuICAgICAgICAgICAgaSA9IF90aGlzNC5kYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgdDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgLy8gRmxpcCBwbHVnaW4gdHdlZW5zIGFyZSB2ZXJ5IGRpZmZlcmVudCBpbiB0aGF0IHRoZXkgc2hvdWxkIGFjdHVhbGx5IGJlIHB1c2hlZCB0byB0aGVpciBlbmQuIFRoZSBwbHVnaW4gcmVwbGFjZXMgdGhlIHRpbWVsaW5lJ3MgLnJldmVydCgpIG1ldGhvZCB0byBkbyBleGFjdGx5IHRoYXQuIEJ1dCB3ZSBhbHNvIG5lZWQgdG8gcmVtb3ZlIGFueSBvZiB0aG9zZSBuZXN0ZWQgdHdlZW5zIGluc2lkZSB0aGUgZmxpcCB0aW1lbGluZSBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGluZGl2aWR1YWxseSByZXZlcnRlZC5cclxuICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcclxuXHJcbiAgICAgICAgICBpZiAodC5kYXRhID09PSBcImlzRmxpcFwiKSB7XHJcbiAgICAgICAgICAgIHQucmV2ZXJ0KCk7XHJcbiAgICAgICAgICAgIHQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpLmZvckVhY2goZnVuY3Rpb24gKHR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVucy5zcGxpY2UodHdlZW5zLmluZGV4T2YodHdlZW4pLCAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSAvLyBzYXZlIGFzIGFuIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBjYWNoZSB0aGUgZ2xvYmFsVGltZSBmb3IgZWFjaCB0d2VlbiB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBkdXJpbmcgdGhlIHNvcnRcclxuXHJcblxyXG4gICAgICAgIHR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGc6IHQuX2R1ciB8fCB0Ll9kZWxheSB8fCB0Ll9zYXQgJiYgIXQuX3NhdC52YXJzLmltbWVkaWF0ZVJlbmRlciA/IHQuZ2xvYmFsVGltZSgwKSA6IC1JbmZpbml0eSxcclxuICAgICAgICAgICAgdDogdFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICByZXR1cm4gYi5nIC0gYS5nIHx8IC1JbmZpbml0eTtcclxuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICByZXR1cm4gby50LnJldmVydChyZXZlcnQpO1xyXG4gICAgICAgIH0pOyAvLyBub3RlOiBhbGwgb2YgdGhlIF9zdGFydEF0IHR3ZWVucyBzaG91bGQgYmUgcmV2ZXJ0ZWQgaW4gcmV2ZXJzZSBvcmRlciB0aGF0IHRoZXkgd2VyZSBjcmVhdGVkLCBhbmQgdGhleSdsbCBhbGwgaGF2ZSB0aGUgc2FtZSBnbG9iYWxUaW1lICgtMSkgc28gdGhlIFwiIHx8IC0xXCIgaW4gdGhlIHNvcnQga2VlcHMgdGhlIG9yZGVyIHByb3Blcmx5LlxyXG5cclxuICAgICAgICBpID0gX3RoaXM0LmRhdGEubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgbG9vcCBiYWNrd2FyZHMgc28gdGhhdCwgZm9yIGV4YW1wbGUsIFNwbGl0VGV4dHMgdGhhdCB3ZXJlIGNyZWF0ZWQgbGF0ZXIgb24gdGhlIHNhbWUgZWxlbWVudCBnZXQgcmV2ZXJ0ZWQgZmlyc3RcclxuICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcclxuXHJcbiAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIGlmICh0LmRhdGEgIT09IFwibmVzdGVkXCIpIHtcclxuICAgICAgICAgICAgICB0LnNjcm9sbFRyaWdnZXIgJiYgdC5zY3JvbGxUcmlnZ2VyLnJldmVydCgpO1xyXG4gICAgICAgICAgICAgIHQua2lsbCgpOyAvLyBkb24ndCByZXZlcnQoKSB0aGUgdGltZWxpbmUgYmVjYXVzZSB0aGF0J3MgZHVwbGljYXRpbmcgZWZmb3J0cyBzaW5jZSB3ZSBhbHJlYWR5IHJldmVydGVkIGFsbCB0aGUgdHdlZW5zXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICEodCBpbnN0YW5jZW9mIFR3ZWVuKSAmJiB0LnJldmVydCAmJiB0LnJldmVydChyZXZlcnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX3RoaXM0Ll9yLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgIHJldHVybiBmKHJldmVydCwgX3RoaXM0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3RoaXM0LmlzUmV2ZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICB9KSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gZS5raWxsICYmIGUua2lsbCgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNsZWFyKCk7XHJcblxyXG4gICAgaWYgKG1hdGNoTWVkaWEpIHtcclxuICAgICAgdmFyIGkgPSBfbWVkaWEubGVuZ3RoO1xyXG5cclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIC8vIHByZXZpb3VzbHksIHdlIGNoZWNrZWQgX21lZGlhLmluZGV4T2YodGhpcyksIGJ1dCBzb21lIGZyYW1ld29ya3MgbGlrZSBWdWUgZW5mb3JjZSBQcm94eSBvYmplY3RzIHRoYXQgbWFrZSBpdCBpbXBvc3NpYmxlIHRvIGdldCB0aGUgcHJvcGVyIHJlc3VsdCB0aGF0IHdheSwgc28gd2UgbXVzdCB1c2UgYSB1bmlxdWUgSUQgbnVtYmVyIGluc3RlYWQuXHJcbiAgICAgICAgX21lZGlhW2ldLmlkID09PSB0aGlzLmlkICYmIF9tZWRpYS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IC8vIGtpbGxXaXRoQ2xlYW51cCgpIHtcclxuICAvLyBcdHRoaXMua2lsbCgpO1xyXG4gIC8vIFx0dGhpcy5fci5mb3JFYWNoKGYgPT4gZihmYWxzZSwgdGhpcykpO1xyXG4gIC8vIH1cclxuICA7XHJcblxyXG4gIF9wcm90bzUucmV2ZXJ0ID0gZnVuY3Rpb24gcmV2ZXJ0KGNvbmZpZykge1xyXG4gICAgdGhpcy5raWxsKGNvbmZpZyB8fCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENvbnRleHQ7XHJcbn0oKTtcclxuXHJcbnZhciBNYXRjaE1lZGlhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBNYXRjaE1lZGlhKHNjb3BlKSB7XHJcbiAgICB0aGlzLmNvbnRleHRzID0gW107XHJcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XHJcbiAgICBfY29udGV4dCAmJiBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XHJcbiAgfVxyXG5cclxuICB2YXIgX3Byb3RvNiA9IE1hdGNoTWVkaWEucHJvdG90eXBlO1xyXG5cclxuICBfcHJvdG82LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25kaXRpb25zLCBmdW5jLCBzY29wZSkge1xyXG4gICAgX2lzT2JqZWN0KGNvbmRpdGlvbnMpIHx8IChjb25kaXRpb25zID0ge1xyXG4gICAgICBtYXRjaGVzOiBjb25kaXRpb25zXHJcbiAgICB9KTtcclxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoMCwgc2NvcGUgfHwgdGhpcy5zY29wZSksXHJcbiAgICAgICAgY29uZCA9IGNvbnRleHQuY29uZGl0aW9ucyA9IHt9LFxyXG4gICAgICAgIG1xLFxyXG4gICAgICAgIHAsXHJcbiAgICAgICAgYWN0aXZlO1xyXG4gICAgX2NvbnRleHQgJiYgIWNvbnRleHQuc2VsZWN0b3IgJiYgKGNvbnRleHQuc2VsZWN0b3IgPSBfY29udGV4dC5zZWxlY3Rvcik7IC8vIGluIGNhc2UgYSBjb250ZXh0IGlzIGNyZWF0ZWQgaW5zaWRlIGEgY29udGV4dC4gTGlrZSBhIGdzYXAubWF0Y2hNZWRpYSgpIHRoYXQncyBpbnNpZGUgYSBzY29wZWQgZ3NhcC5jb250ZXh0KClcclxuXHJcbiAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XHJcbiAgICBmdW5jID0gY29udGV4dC5hZGQoXCJvbk1hdGNoXCIsIGZ1bmMpO1xyXG4gICAgY29udGV4dC5xdWVyaWVzID0gY29uZGl0aW9ucztcclxuXHJcbiAgICBmb3IgKHAgaW4gY29uZGl0aW9ucykge1xyXG4gICAgICBpZiAocCA9PT0gXCJhbGxcIikge1xyXG4gICAgICAgIGFjdGl2ZSA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEoY29uZGl0aW9uc1twXSk7XHJcblxyXG4gICAgICAgIGlmIChtcSkge1xyXG4gICAgICAgICAgX21lZGlhLmluZGV4T2YoY29udGV4dCkgPCAwICYmIF9tZWRpYS5wdXNoKGNvbnRleHQpO1xyXG4gICAgICAgICAgKGNvbmRbcF0gPSBtcS5tYXRjaGVzKSAmJiAoYWN0aXZlID0gMSk7XHJcbiAgICAgICAgICBtcS5hZGRMaXN0ZW5lciA/IG1xLmFkZExpc3RlbmVyKF9vbk1lZGlhQ2hhbmdlKSA6IG1xLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX29uTWVkaWFDaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFjdGl2ZSAmJiBmdW5jKGNvbnRleHQsIGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgIHJldHVybiBjb250ZXh0LmFkZChudWxsLCBmKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSAvLyByZWZyZXNoKCkge1xyXG4gIC8vIFx0bGV0IHRpbWUgPSBfbGFzdE1lZGlhVGltZSxcclxuICAvLyBcdFx0bWVkaWEgPSBfbWVkaWE7XHJcbiAgLy8gXHRfbGFzdE1lZGlhVGltZSA9IC0xO1xyXG4gIC8vIFx0X21lZGlhID0gdGhpcy5jb250ZXh0cztcclxuICAvLyBcdF9vbk1lZGlhQ2hhbmdlKCk7XHJcbiAgLy8gXHRfbGFzdE1lZGlhVGltZSA9IHRpbWU7XHJcbiAgLy8gXHRfbWVkaWEgPSBtZWRpYTtcclxuICAvLyB9XHJcbiAgO1xyXG5cclxuICBfcHJvdG82LnJldmVydCA9IGZ1bmN0aW9uIHJldmVydChjb25maWcpIHtcclxuICAgIHRoaXMua2lsbChjb25maWcgfHwge30pO1xyXG4gIH07XHJcblxyXG4gIF9wcm90bzYua2lsbCA9IGZ1bmN0aW9uIGtpbGwocmV2ZXJ0KSB7XHJcbiAgICB0aGlzLmNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgcmV0dXJuIGMua2lsbChyZXZlcnQsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE1hdGNoTWVkaWE7XHJcbn0oKTtcclxuLypcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogR1NBUFxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKi9cclxuXHJcblxyXG52YXIgX2dzYXAgPSB7XHJcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xyXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgIH1cclxuXHJcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xyXG4gICAgcmV0dXJuIG5ldyBUaW1lbGluZSh2YXJzKTtcclxuICB9LFxyXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XHJcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpO1xyXG4gIH0sXHJcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcclxuICAgIF9pc1N0cmluZyh0YXJnZXQpICYmICh0YXJnZXQgPSB0b0FycmF5KHRhcmdldClbMF0pOyAvL2luIGNhc2Ugc2VsZWN0b3IgdGV4dCBvciBhbiBhcnJheSBpcyBwYXNzZWQgaW5cclxuXHJcbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxyXG4gICAgICAgIGZvcm1hdCA9IHVuaXQgPyBfcGFzc1Rocm91Z2ggOiBfbnVtZXJpY0lmUG9zc2libGU7XHJcblxyXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xyXG4gICAgcmV0dXJuICF0YXJnZXQgPyB0YXJnZXQgOiAhcHJvcGVydHkgPyBmdW5jdGlvbiAocHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcclxuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XHJcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcclxuICB9LFxyXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XHJcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XHJcblxyXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIHJldHVybiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KTtcclxuICAgICAgfSksXHJcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgaSA9IGw7XHJcblxyXG4gICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbMF0gfHwge307XHJcblxyXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcclxuICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxyXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcclxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxyXG4gICAgc2V0dGVyID0gUGx1Z2luID8gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xyXG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xyXG4gICAgICBwLmluaXQodGFyZ2V0LCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIF9xdWlja1R3ZWVuLCAwLCBbdGFyZ2V0XSk7XHJcbiAgICAgIHAucmVuZGVyKDEsIHApO1xyXG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xyXG4gICAgfSA6IGNhY2hlLnNldCh0YXJnZXQsIHApO1xyXG5cclxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHNldHRlcih0YXJnZXQsIHAsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xyXG4gICAgfTtcclxuICB9LFxyXG4gIHF1aWNrVG86IGZ1bmN0aW9uIHF1aWNrVG8odGFyZ2V0LCBwcm9wZXJ0eSwgdmFycykge1xyXG4gICAgdmFyIF9zZXREZWZhdWx0czI7XHJcblxyXG4gICAgdmFyIHR3ZWVuID0gZ3NhcC50byh0YXJnZXQsIF9zZXREZWZhdWx0cygoX3NldERlZmF1bHRzMiA9IHt9LCBfc2V0RGVmYXVsdHMyW3Byb3BlcnR5XSA9IFwiKz0wLjFcIiwgX3NldERlZmF1bHRzMi5wYXVzZWQgPSB0cnVlLCBfc2V0RGVmYXVsdHMyLnN0YWdnZXIgPSAwLCBfc2V0RGVmYXVsdHMyKSwgdmFycyB8fCB7fSkpLFxyXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKSB7XHJcbiAgICAgIHJldHVybiB0d2Vlbi5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmMudHdlZW4gPSB0d2VlbjtcclxuICAgIHJldHVybiBmdW5jO1xyXG4gIH0sXHJcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XHJcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmdldFR3ZWVuc09mKHRhcmdldHMsIHRydWUpLmxlbmd0aCA+IDA7XHJcbiAgfSxcclxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcclxuICAgIHZhbHVlICYmIHZhbHVlLmVhc2UgJiYgKHZhbHVlLmVhc2UgPSBfcGFyc2VFYXNlKHZhbHVlLmVhc2UsIF9kZWZhdWx0cy5lYXNlKSk7XHJcbiAgICByZXR1cm4gX21lcmdlRGVlcChfZGVmYXVsdHMsIHZhbHVlIHx8IHt9KTtcclxuICB9LFxyXG4gIGNvbmZpZzogZnVuY3Rpb24gY29uZmlnKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gX21lcmdlRGVlcChfY29uZmlnLCB2YWx1ZSB8fCB7fSk7XHJcbiAgfSxcclxuICByZWdpc3RlckVmZmVjdDogZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoX3JlZjMpIHtcclxuICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcclxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXHJcbiAgICAgICAgcGx1Z2lucyA9IF9yZWYzLnBsdWdpbnMsXHJcbiAgICAgICAgZGVmYXVsdHMgPSBfcmVmMy5kZWZhdWx0cyxcclxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xyXG4gICAgKHBsdWdpbnMgfHwgXCJcIikuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcclxuICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgJiYgIV9wbHVnaW5zW3BsdWdpbk5hbWVdICYmICFfZ2xvYmFsc1twbHVnaW5OYW1lXSAmJiBfd2FybihuYW1lICsgXCIgZWZmZWN0IHJlcXVpcmVzIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbi5cIik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xyXG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XHJcbiAgICAgIFRpbWVsaW5lLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChfZWZmZWN0c1tuYW1lXSh0YXJnZXRzLCBfaXNPYmplY3QodmFycykgPyB2YXJzIDogKHBvc2l0aW9uID0gdmFycykgJiYge30sIHRoaXMpLCBwb3NpdGlvbik7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSxcclxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XHJcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9wYXJzZUVhc2UoZWFzZSk7XHJcbiAgfSxcclxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfcGFyc2VFYXNlKGVhc2UsIGRlZmF1bHRFYXNlKSA6IF9lYXNlTWFwO1xyXG4gIH0sXHJcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xyXG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRCeUlkKGlkKTtcclxuICB9LFxyXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xyXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xyXG4gICAgICB2YXJzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKHZhcnMpLFxyXG4gICAgICAgIGNoaWxkLFxyXG4gICAgICAgIG5leHQ7XHJcbiAgICB0bC5zbW9vdGhDaGlsZFRpbWluZyA9IF9pc05vdEZhbHNlKHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcpO1xyXG5cclxuICAgIF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xyXG5cclxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxyXG5cclxuICAgIHRsLl90aW1lID0gdGwuX3RUaW1lID0gX2dsb2JhbFRpbWVsaW5lLl90aW1lO1xyXG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xyXG5cclxuICAgIHdoaWxlIChjaGlsZCkge1xyXG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XHJcblxyXG4gICAgICBpZiAoaW5jbHVkZURlbGF5ZWRDYWxscyB8fCAhKCFjaGlsZC5fZHVyICYmIGNoaWxkIGluc3RhbmNlb2YgVHdlZW4gJiYgY2hpbGQudmFycy5vbkNvbXBsZXRlID09PSBjaGlsZC5fdGFyZ2V0c1swXSkpIHtcclxuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoaWxkID0gbmV4dDtcclxuICAgIH1cclxuXHJcbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcclxuXHJcbiAgICByZXR1cm4gdGw7XHJcbiAgfSxcclxuICBjb250ZXh0OiBmdW5jdGlvbiBjb250ZXh0KGZ1bmMsIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gZnVuYyA/IG5ldyBDb250ZXh0KGZ1bmMsIHNjb3BlKSA6IF9jb250ZXh0O1xyXG4gIH0sXHJcbiAgbWF0Y2hNZWRpYTogZnVuY3Rpb24gbWF0Y2hNZWRpYShzY29wZSkge1xyXG4gICAgcmV0dXJuIG5ldyBNYXRjaE1lZGlhKHNjb3BlKTtcclxuICB9LFxyXG4gIG1hdGNoTWVkaWFSZWZyZXNoOiBmdW5jdGlvbiBtYXRjaE1lZGlhUmVmcmVzaCgpIHtcclxuICAgIHJldHVybiBfbWVkaWEuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgICB2YXIgY29uZCA9IGMuY29uZGl0aW9ucyxcclxuICAgICAgICAgIGZvdW5kLFxyXG4gICAgICAgICAgcDtcclxuXHJcbiAgICAgIGZvciAocCBpbiBjb25kKSB7XHJcbiAgICAgICAgaWYgKGNvbmRbcF0pIHtcclxuICAgICAgICAgIGNvbmRbcF0gPSBmYWxzZTtcclxuICAgICAgICAgIGZvdW5kID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvdW5kICYmIGMucmV2ZXJ0KCk7XHJcbiAgICB9KSB8fCBfb25NZWRpYUNoYW5nZSgpO1xyXG4gIH0sXHJcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xyXG4gICAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcclxuICB9LFxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcclxuICAgIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcclxuICAgICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xyXG4gIH0sXHJcbiAgdXRpbHM6IHtcclxuICAgIHdyYXA6IHdyYXAsXHJcbiAgICB3cmFwWW95bzogd3JhcFlveW8sXHJcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxyXG4gICAgcmFuZG9tOiByYW5kb20sXHJcbiAgICBzbmFwOiBzbmFwLFxyXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXHJcbiAgICBnZXRVbml0OiBnZXRVbml0LFxyXG4gICAgY2xhbXA6IGNsYW1wLFxyXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcclxuICAgIHRvQXJyYXk6IHRvQXJyYXksXHJcbiAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXHJcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXHJcbiAgICBwaXBlOiBwaXBlLFxyXG4gICAgdW5pdGl6ZTogdW5pdGl6ZSxcclxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcclxuICAgIHNodWZmbGU6IHNodWZmbGVcclxuICB9LFxyXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxyXG4gIGVmZmVjdHM6IF9lZmZlY3RzLFxyXG4gIHRpY2tlcjogX3RpY2tlcixcclxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxyXG4gIHBsdWdpbnM6IF9wbHVnaW5zLFxyXG4gIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXHJcbiAgY29yZToge1xyXG4gICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXHJcbiAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxyXG4gICAgVHdlZW46IFR3ZWVuLFxyXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lLFxyXG4gICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXHJcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxyXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXHJcbiAgICByZXZlcnRpbmc6IGZ1bmN0aW9uIHJldmVydGluZygpIHtcclxuICAgICAgcmV0dXJuIF9yZXZlcnRpbmc7XHJcbiAgICB9LFxyXG4gICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dCh0b0FkZCkge1xyXG4gICAgICBpZiAodG9BZGQgJiYgX2NvbnRleHQpIHtcclxuICAgICAgICBfY29udGV4dC5kYXRhLnB1c2godG9BZGQpO1xyXG5cclxuICAgICAgICB0b0FkZC5fY3R4ID0gX2NvbnRleHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBfY29udGV4dDtcclxuICAgIH0sXHJcbiAgICBzdXBwcmVzc092ZXJ3cml0ZXM6IGZ1bmN0aW9uIHN1cHByZXNzT3ZlcndyaXRlcyh2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbl9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcclxuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcclxufSk7XHJcblxyXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcclxuXHJcbl9xdWlja1R3ZWVuID0gX2dzYXAudG8oe30sIHtcclxuICBkdXJhdGlvbjogMFxyXG59KTsgLy8gLS0tLSBFWFRSQSBQTFVHSU5TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XHJcbiAgdmFyIHB0ID0gcGx1Z2luLl9wdDtcclxuXHJcbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcclxuICAgIHB0ID0gcHQuX25leHQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcHQ7XHJcbn0sXHJcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XHJcbiAgdmFyIHRhcmdldHMgPSB0d2Vlbi5fdGFyZ2V0cyxcclxuICAgICAgcCxcclxuICAgICAgaSxcclxuICAgICAgcHQ7XHJcblxyXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcclxuICAgIGkgPSB0YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xyXG5cclxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XHJcbiAgICAgICAgaWYgKHB0Ll9wdCkge1xyXG4gICAgICAgICAgLy8gaXMgYSBwbHVnaW5cclxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSxcclxuICAgIF9idWlsZE1vZGlmaWVyUGx1Z2luID0gZnVuY3Rpb24gX2J1aWxkTW9kaWZpZXJQbHVnaW4obmFtZSwgbW9kaWZpZXIpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbmFtZTogbmFtZSxcclxuICAgIGhlYWRsZXNzOiAxLFxyXG4gICAgcmF3VmFyczogMSxcclxuICAgIC8vZG9uJ3QgcHJlLXByb2Nlc3MgZnVuY3Rpb24tYmFzZWQgdmFsdWVzIG9yIFwicmFuZG9tKClcIiBzdHJpbmdzLlxyXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XHJcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcclxuICAgICAgICB2YXIgdGVtcCwgcDtcclxuXHJcbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xyXG4gICAgICAgICAgdGVtcCA9IHt9O1xyXG5cclxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGVtcFtuYW1lXSA9IDE7XHJcbiAgICAgICAgICB9KTsgLy9pZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0byByb3VuZFByb3BzLCBsaWtlIFwieCx5XCIsIHdlIHJvdW5kIHRvIHdob2xlIG51bWJlcnMuXHJcblxyXG5cclxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vZGlmaWVyKSB7XHJcbiAgICAgICAgICB0ZW1wID0ge307XHJcblxyXG4gICAgICAgICAgZm9yIChwIGluIHZhcnMpIHtcclxuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufTsgLy9yZWdpc3RlciBjb3JlIHBsdWdpbnNcclxuXHJcblxyXG5leHBvcnQgdmFyIGdzYXAgPSBfZ3NhcC5yZWdpc3RlclBsdWdpbih7XHJcbiAgbmFtZTogXCJhdHRyXCIsXHJcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xyXG4gICAgdmFyIHAsIHB0LCB2O1xyXG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xyXG5cclxuICAgIGZvciAocCBpbiB2YXJzKSB7XHJcbiAgICAgIHYgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHApIHx8IFwiXCI7XHJcbiAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCAodiB8fCAwKSArIFwiXCIsIHZhcnNbcF0sIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcclxuICAgICAgcHQub3AgPSBwO1xyXG4gICAgICBwdC5iID0gdjsgLy8gcmVjb3JkIHRoZSBiZWdpbm5pbmcgdmFsdWUgc28gd2UgY2FuIHJldmVydCgpXHJcblxyXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcclxuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xyXG5cclxuICAgIHdoaWxlIChwdCkge1xyXG4gICAgICBfcmV2ZXJ0aW5nID8gcHQuc2V0KHB0LnQsIHB0LnAsIHB0LmIsIHB0KSA6IHB0LnIocmF0aW8sIHB0LmQpOyAvLyBpZiByZXZlcnRpbmcsIGdvIGJhY2sgdG8gdGhlIG9yaWdpbmFsIChwdC5iKVxyXG5cclxuICAgICAgcHQgPSBwdC5fbmV4dDtcclxuICAgIH1cclxuICB9XHJcbn0sIHtcclxuICBuYW1lOiBcImVuZEFycmF5XCIsXHJcbiAgaGVhZGxlc3M6IDEsXHJcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcclxuXHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldLCAwLCAwLCAwLCAwLCAwLCAxKTtcclxuICAgIH1cclxuICB9XHJcbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXHJcblxyXG5Ud2Vlbi52ZXJzaW9uID0gVGltZWxpbmUudmVyc2lvbiA9IGdzYXAudmVyc2lvbiA9IFwiMy4xMy4wXCI7XHJcbl9jb3JlUmVhZHkgPSAxO1xyXG5fd2luZG93RXhpc3RzKCkgJiYgX3dha2UoKTtcclxudmFyIFBvd2VyMCA9IF9lYXNlTWFwLlBvd2VyMCxcclxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcclxuICAgIFBvd2VyMiA9IF9lYXNlTWFwLlBvd2VyMixcclxuICAgIFBvd2VyMyA9IF9lYXNlTWFwLlBvd2VyMyxcclxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcclxuICAgIExpbmVhciA9IF9lYXNlTWFwLkxpbmVhcixcclxuICAgIFF1YWQgPSBfZWFzZU1hcC5RdWFkLFxyXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcclxuICAgIFF1YXJ0ID0gX2Vhc2VNYXAuUXVhcnQsXHJcbiAgICBRdWludCA9IF9lYXNlTWFwLlF1aW50LFxyXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxyXG4gICAgRWxhc3RpYyA9IF9lYXNlTWFwLkVsYXN0aWMsXHJcbiAgICBCYWNrID0gX2Vhc2VNYXAuQmFjayxcclxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXHJcbiAgICBCb3VuY2UgPSBfZWFzZU1hcC5Cb3VuY2UsXHJcbiAgICBTaW5lID0gX2Vhc2VNYXAuU2luZSxcclxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxyXG4gICAgQ2lyYyA9IF9lYXNlTWFwLkNpcmM7XHJcbmV4cG9ydCB7IFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYyB9O1xyXG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXHJcblxyXG5leHBvcnQgeyBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSwgX2ZvckVhY2hOYW1lLCBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5LCBfY29sb3JTdHJpbmdGaWx0ZXIsIF9yZXBsYWNlUmFuZG9tLCBfY2hlY2tQbHVnaW4sIF9wbHVnaW5zLCBfdGlja2VyLCBfY29uZmlnLCBfcm91bmRNb2RpZmllciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAsIF9wYXJzZVJlbGF0aXZlIH07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/gsap-core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/gsap/index.js":
/*!************************************!*\
  !*** ./node_modules/gsap/index.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),\n/* harmony export */   Bounce: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),\n/* harmony export */   CSSPlugin: () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin),\n/* harmony export */   Circ: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),\n/* harmony export */   Cubic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),\n/* harmony export */   Elastic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),\n/* harmony export */   Expo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),\n/* harmony export */   Linear: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),\n/* harmony export */   Power0: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),\n/* harmony export */   Power1: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),\n/* harmony export */   Power2: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),\n/* harmony export */   Power3: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),\n/* harmony export */   Power4: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),\n/* harmony export */   Quad: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),\n/* harmony export */   Quart: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),\n/* harmony export */   Quint: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),\n/* harmony export */   Sine: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),\n/* harmony export */   SteppedEase: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),\n/* harmony export */   Strong: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),\n/* harmony export */   TimelineLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),\n/* harmony export */   TimelineMax: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),\n/* harmony export */   TweenLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),\n/* harmony export */   TweenMax: () => (/* binding */ TweenMaxWithCSS),\n/* harmony export */   \"default\": () => (/* binding */ gsapWithCSS),\n/* harmony export */   gsap: () => (/* binding */ gsapWithCSS)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ \"(ssr)/./node_modules/gsap/gsap-core.js\");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ \"(ssr)/./node_modules/gsap/CSSPlugin.js\");\n\r\n\r\nvar gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,\r\n    // to protect from tree shaking\r\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3NhcC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcU47QUFDMUs7QUFDM0Msa0JBQWtCLCtDQUFJLGdCQUFnQixvREFBUyxLQUFLLCtDQUFJO0FBQ3hEO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3NhcFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ3NhcCwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjLCBUd2VlbkxpdGUsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXggfSBmcm9tIFwiLi9nc2FwLWNvcmUuanNcIjtcclxuaW1wb3J0IHsgQ1NTUGx1Z2luIH0gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XHJcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLFxyXG4gICAgLy8gdG8gcHJvdGVjdCBmcm9tIHRyZWUgc2hha2luZ1xyXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xyXG5leHBvcnQgeyBnc2FwV2l0aENTUyBhcyBnc2FwLCBnc2FwV2l0aENTUyBhcyBkZWZhdWx0LCBDU1NQbHVnaW4sIFR3ZWVuTWF4V2l0aENTUyBhcyBUd2Vlbk1heCwgVHdlZW5MaXRlLCBUaW1lbGluZU1heCwgVGltZWxpbmVMaXRlLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/gsap/index.js\n");

/***/ })

};
;