"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalTrackRecorder: () => (/* binding */ LocalTrackRecorder),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   attributes: () => (/* binding */ attributeTypings),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\r\n  m.forEach(function (e) {\r\n    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\r\n      if (k !== 'default' && !(k in n)) {\r\n        var d = Object.getOwnPropertyDescriptor(e, k);\r\n        Object.defineProperty(n, k, d.get ? d : {\r\n          enumerable: true,\r\n          get: function () { return e[k]; }\r\n        });\r\n      }\r\n    });\r\n  });\r\n  return Object.freeze(n);\r\n}\r\n\r\nvar e = Object.defineProperty;\r\nvar h = (i, s, t) => s in i ? e(i, s, {\r\n  enumerable: true,\r\n  configurable: true,\r\n  writable: true,\r\n  value: t\r\n}) : i[s] = t;\r\nvar o = (i, s, t) => h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\r\nclass _ {\r\n  constructor() {\r\n    o(this, \"_locking\");\r\n    o(this, \"_locks\");\r\n    this._locking = Promise.resolve(), this._locks = 0;\r\n  }\r\n  isLocked() {\r\n    return this._locks > 0;\r\n  }\r\n  lock() {\r\n    this._locks += 1;\r\n    let s;\r\n    const t = new Promise(l => s = () => {\r\n        this._locks -= 1, l();\r\n      }),\r\n      c = this._locking.then(() => s);\r\n    return this._locking = this._locking.then(() => t), c;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Assert that condition is truthy or throw error (with message)\r\n */\r\nfunction assert(condition, msg) {\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\r\n  if (!condition) {\r\n    throw new Error(msg);\r\n  }\r\n}\r\nconst FLOAT32_MAX = 3.4028234663852886e38,\r\n  FLOAT32_MIN = -34028234663852886e22,\r\n  UINT32_MAX = 0xffffffff,\r\n  INT32_MAX = 0x7fffffff,\r\n  INT32_MIN = -2147483648;\r\n/**\r\n * Assert a valid signed protobuf 32-bit integer.\r\n */\r\nfunction assertInt32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\r\n  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n/**\r\n * Assert a valid unsigned protobuf 32-bit integer.\r\n */\r\nfunction assertUInt32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\r\n  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n/**\r\n * Assert a valid protobuf float value.\r\n */\r\nfunction assertFloat32(arg) {\r\n  if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\r\n  if (!Number.isFinite(arg)) return;\r\n  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\r\n/**\r\n * Get reflection information from a generated enum.\r\n * If this function is called on something other than a generated\r\n * enum, it raises an error.\r\n */\r\nfunction getEnumType(enumObject) {\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\r\n  const t = enumObject[enumTypeSymbol];\r\n  assert(t, \"missing enum type on enum object\");\r\n  return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\r\n}\r\n/**\r\n * Sets reflection information on a generated enum.\r\n */\r\nfunction setEnumType(enumObject, typeName, values, opt) {\r\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\r\n  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(v => ({\r\n    no: v.no,\r\n    name: v.name,\r\n    localName: enumObject[v.no]\r\n  })));\r\n}\r\n/**\r\n * Create a new EnumType with the given values.\r\n */\r\nfunction makeEnumType(typeName, values,\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n_opt) {\r\n  const names = Object.create(null);\r\n  const numbers = Object.create(null);\r\n  const normalValues = [];\r\n  for (const value of values) {\r\n    // We do not surface options at this time\r\n    // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\r\n    const n = normalizeEnumValue(value);\r\n    normalValues.push(n);\r\n    names[value.name] = n;\r\n    numbers[value.no] = n;\r\n  }\r\n  return {\r\n    typeName,\r\n    values: normalValues,\r\n    // We do not surface options at this time\r\n    // options: opt?.options ?? Object.create(null),\r\n    findName(name) {\r\n      return names[name];\r\n    },\r\n    findNumber(no) {\r\n      return numbers[no];\r\n    }\r\n  };\r\n}\r\n/**\r\n * Create a new enum object with the given values.\r\n * Sets reflection information.\r\n */\r\nfunction makeEnum(typeName, values, opt) {\r\n  const enumObject = {};\r\n  for (const value of values) {\r\n    const n = normalizeEnumValue(value);\r\n    enumObject[n.localName] = n.no;\r\n    enumObject[n.no] = n.localName;\r\n  }\r\n  setEnumType(enumObject, typeName, values);\r\n  return enumObject;\r\n}\r\nfunction normalizeEnumValue(value) {\r\n  if (\"localName\" in value) {\r\n    return value;\r\n  }\r\n  return Object.assign(Object.assign({}, value), {\r\n    localName: value.name\r\n  });\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Message is the base class of every message, generated, or created at\r\n * runtime.\r\n *\r\n * It is _not_ safe to extend this class. If you want to create a message at\r\n * run time, use proto3.makeMessageType().\r\n */\r\nclass Message {\r\n  /**\r\n   * Compare with a message of the same type.\r\n   * Note that this function disregards extensions and unknown fields.\r\n   */\r\n  equals(other) {\r\n    return this.getType().runtime.util.equals(this.getType(), this, other);\r\n  }\r\n  /**\r\n   * Create a deep copy.\r\n   */\r\n  clone() {\r\n    return this.getType().runtime.util.clone(this);\r\n  }\r\n  /**\r\n   * Parse from binary data, merging fields.\r\n   *\r\n   * Repeated fields are appended. Map entries are added, overwriting\r\n   * existing keys.\r\n   *\r\n   * If a message field is already present, it will be merged with the\r\n   * new data.\r\n   */\r\n  fromBinary(bytes, options) {\r\n    const type = this.getType(),\r\n      format = type.runtime.bin,\r\n      opt = format.makeReadOptions(options);\r\n    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\r\n    return this;\r\n  }\r\n  /**\r\n   * Parse a message from a JSON value.\r\n   */\r\n  fromJson(jsonValue, options) {\r\n    const type = this.getType(),\r\n      format = type.runtime.json,\r\n      opt = format.makeReadOptions(options);\r\n    format.readMessage(type, jsonValue, opt, this);\r\n    return this;\r\n  }\r\n  /**\r\n   * Parse a message from a JSON string.\r\n   */\r\n  fromJsonString(jsonString, options) {\r\n    let json;\r\n    try {\r\n      json = JSON.parse(jsonString);\r\n    } catch (e) {\r\n      throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\r\n    }\r\n    return this.fromJson(json, options);\r\n  }\r\n  /**\r\n   * Serialize the message to binary data.\r\n   */\r\n  toBinary(options) {\r\n    const type = this.getType(),\r\n      bin = type.runtime.bin,\r\n      opt = bin.makeWriteOptions(options),\r\n      writer = opt.writerFactory();\r\n    bin.writeMessage(this, writer, opt);\r\n    return writer.finish();\r\n  }\r\n  /**\r\n   * Serialize the message to a JSON value, a JavaScript value that can be\r\n   * passed to JSON.stringify().\r\n   */\r\n  toJson(options) {\r\n    const type = this.getType(),\r\n      json = type.runtime.json,\r\n      opt = json.makeWriteOptions(options);\r\n    return json.writeMessage(this, opt);\r\n  }\r\n  /**\r\n   * Serialize the message to a JSON string.\r\n   */\r\n  toJsonString(options) {\r\n    var _a;\r\n    const value = this.toJson(options);\r\n    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\r\n  }\r\n  /**\r\n   * Override for serialization behavior. This will be invoked when calling\r\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\r\n   *\r\n   * Note that this will not serialize google.protobuf.Any with a packed\r\n   * message because the protobuf JSON format specifies that it needs to be\r\n   * unpacked, and this is only possible with a type registry to look up the\r\n   * message type.  As a result, attempting to serialize a message with this\r\n   * type will throw an Error.\r\n   *\r\n   * This method is protected because you should not need to invoke it\r\n   * directly -- instead use JSON.stringify or toJsonString for\r\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\r\n   * use toJson.\r\n   */\r\n  toJSON() {\r\n    return this.toJson({\r\n      emitDefaultValues: true\r\n    });\r\n  }\r\n  /**\r\n   * Retrieve the MessageType of this message - a singleton that represents\r\n   * the protobuf message declaration and provides metadata for reflection-\r\n   * based operations.\r\n   */\r\n  getType() {\r\n    // Any class that extends Message _must_ provide a complete static\r\n    // implementation of MessageType.\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\r\n    return Object.getPrototypeOf(this).constructor;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Create a new message type using the given runtime.\r\n */\r\nfunction makeMessageType(runtime, typeName, fields, opt) {\r\n  var _a;\r\n  const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\r\n  const type = {\r\n    [localName]: function (data) {\r\n      runtime.util.initFields(this);\r\n      runtime.util.initPartial(data, this);\r\n    }\r\n  }[localName];\r\n  Object.setPrototypeOf(type.prototype, new Message());\r\n  Object.assign(type, {\r\n    runtime,\r\n    typeName,\r\n    fields: runtime.util.newFieldList(fields),\r\n    fromBinary(bytes, options) {\r\n      return new type().fromBinary(bytes, options);\r\n    },\r\n    fromJson(jsonValue, options) {\r\n      return new type().fromJson(jsonValue, options);\r\n    },\r\n    fromJsonString(jsonString, options) {\r\n      return new type().fromJsonString(jsonString, options);\r\n    },\r\n    equals(a, b) {\r\n      return runtime.util.equals(type, a, b);\r\n    }\r\n  });\r\n  return type;\r\n}\r\n\r\n// Copyright 2008 Google Inc.  All rights reserved.\r\n//\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are\r\n// met:\r\n//\r\n// * Redistributions of source code must retain the above copyright\r\n// notice, this list of conditions and the following disclaimer.\r\n// * Redistributions in binary form must reproduce the above\r\n// copyright notice, this list of conditions and the following disclaimer\r\n// in the documentation and/or other materials provided with the\r\n// distribution.\r\n// * Neither the name of Google Inc. nor the names of its\r\n// contributors may be used to endorse or promote products derived from\r\n// this software without specific prior written permission.\r\n//\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n//\r\n// Code generated by the Protocol Buffer compiler is owned by the owner\r\n// of the input file used when generating it.  This code is not\r\n// standalone and requires a support library to be linked with it.  This\r\n// support library is itself covered by the above license.\r\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */\r\n/**\r\n * Read a 64 bit varint as two JS numbers.\r\n *\r\n * Returns tuple:\r\n * [0]: low bits\r\n * [1]: high bits\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\r\n */\r\nfunction varint64read() {\r\n  let lowBits = 0;\r\n  let highBits = 0;\r\n  for (let shift = 0; shift < 28; shift += 7) {\r\n    let b = this.buf[this.pos++];\r\n    lowBits |= (b & 0x7f) << shift;\r\n    if ((b & 0x80) == 0) {\r\n      this.assertBounds();\r\n      return [lowBits, highBits];\r\n    }\r\n  }\r\n  let middleByte = this.buf[this.pos++];\r\n  // last four bits of the first 32 bit number\r\n  lowBits |= (middleByte & 0x0f) << 28;\r\n  // 3 upper bits are part of the next 32 bit number\r\n  highBits = (middleByte & 0x70) >> 4;\r\n  if ((middleByte & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return [lowBits, highBits];\r\n  }\r\n  for (let shift = 3; shift <= 31; shift += 7) {\r\n    let b = this.buf[this.pos++];\r\n    highBits |= (b & 0x7f) << shift;\r\n    if ((b & 0x80) == 0) {\r\n      this.assertBounds();\r\n      return [lowBits, highBits];\r\n    }\r\n  }\r\n  throw new Error(\"invalid varint\");\r\n}\r\n/**\r\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\r\n */\r\nfunction varint64write(lo, hi, bytes) {\r\n  for (let i = 0; i < 28; i = i + 7) {\r\n    const shift = lo >>> i;\r\n    const hasNext = !(shift >>> 7 == 0 && hi == 0);\r\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\r\n    bytes.push(byte);\r\n    if (!hasNext) {\r\n      return;\r\n    }\r\n  }\r\n  const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\r\n  const hasMoreBits = !(hi >> 3 == 0);\r\n  bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\r\n  if (!hasMoreBits) {\r\n    return;\r\n  }\r\n  for (let i = 3; i < 31; i = i + 7) {\r\n    const shift = hi >>> i;\r\n    const hasNext = !(shift >>> 7 == 0);\r\n    const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\r\n    bytes.push(byte);\r\n    if (!hasNext) {\r\n      return;\r\n    }\r\n  }\r\n  bytes.push(hi >>> 31 & 0x01);\r\n}\r\n// constants for binary math\r\nconst TWO_PWR_32_DBL = 0x100000000;\r\n/**\r\n * Parse decimal string of 64 bit integer value as two JS numbers.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction int64FromString(dec) {\r\n  // Check for minus sign.\r\n  const minus = dec[0] === \"-\";\r\n  if (minus) {\r\n    dec = dec.slice(1);\r\n  }\r\n  // Work 6 decimal digits at a time, acting like we're converting base 1e6\r\n  // digits to binary. This is safe to do with floating point math because\r\n  // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\r\n  const base = 1e6;\r\n  let lowBits = 0;\r\n  let highBits = 0;\r\n  function add1e6digit(begin, end) {\r\n    // Note: Number('') is 0.\r\n    const digit1e6 = Number(dec.slice(begin, end));\r\n    highBits *= base;\r\n    lowBits = lowBits * base + digit1e6;\r\n    // Carry bits from lowBits to\r\n    if (lowBits >= TWO_PWR_32_DBL) {\r\n      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\r\n      lowBits = lowBits % TWO_PWR_32_DBL;\r\n    }\r\n  }\r\n  add1e6digit(-24, -18);\r\n  add1e6digit(-18, -12);\r\n  add1e6digit(-12, -6);\r\n  add1e6digit(-6);\r\n  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\r\n}\r\n/**\r\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\r\n * into a decimal string.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction int64ToString(lo, hi) {\r\n  let bits = newBits(lo, hi);\r\n  // If we're treating the input as a signed value and the high bit is set, do\r\n  // a manual two's complement conversion before the decimal conversion.\r\n  const negative = bits.hi & 0x80000000;\r\n  if (negative) {\r\n    bits = negate(bits.lo, bits.hi);\r\n  }\r\n  const result = uInt64ToString(bits.lo, bits.hi);\r\n  return negative ? \"-\" + result : result;\r\n}\r\n/**\r\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\r\n * into a decimal string.\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\r\n */\r\nfunction uInt64ToString(lo, hi) {\r\n  ({\r\n    lo,\r\n    hi\r\n  } = toUnsigned(lo, hi));\r\n  // Skip the expensive conversion if the number is small enough to use the\r\n  // built-in conversions.\r\n  // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\r\n  // highBits <= 0x1FFFFF can be safely expressed with a double and retain\r\n  // integer precision.\r\n  // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\r\n  if (hi <= 0x1FFFFF) {\r\n    return String(TWO_PWR_32_DBL * hi + lo);\r\n  }\r\n  // What this code is doing is essentially converting the input number from\r\n  // base-2 to base-1e7, which allows us to represent the 64-bit range with\r\n  // only 3 (very large) digits. Those digits are then trivial to convert to\r\n  // a base-10 string.\r\n  // The magic numbers used here are -\r\n  // 2^24 = 16777216 = (1,6777216) in base-1e7.\r\n  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\r\n  // Split 32:32 representation into 16:24:24 representation so our\r\n  // intermediate digits don't overflow.\r\n  const low = lo & 0xFFFFFF;\r\n  const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\r\n  const high = hi >> 16 & 0xFFFF;\r\n  // Assemble our three base-1e7 digits, ignoring carries. The maximum\r\n  // value in a digit at this step is representable as a 48-bit integer, which\r\n  // can be stored in a 64-bit floating point number.\r\n  let digitA = low + mid * 6777216 + high * 6710656;\r\n  let digitB = mid + high * 8147497;\r\n  let digitC = high * 2;\r\n  // Apply carries from A to B and from B to C.\r\n  const base = 10000000;\r\n  if (digitA >= base) {\r\n    digitB += Math.floor(digitA / base);\r\n    digitA %= base;\r\n  }\r\n  if (digitB >= base) {\r\n    digitC += Math.floor(digitB / base);\r\n    digitB %= base;\r\n  }\r\n  // If digitC is 0, then we should have returned in the trivial code path\r\n  // at the top for non-safe integers. Given this, we can assume both digitB\r\n  // and digitA need leading zeros.\r\n  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\r\n}\r\nfunction toUnsigned(lo, hi) {\r\n  return {\r\n    lo: lo >>> 0,\r\n    hi: hi >>> 0\r\n  };\r\n}\r\nfunction newBits(lo, hi) {\r\n  return {\r\n    lo: lo | 0,\r\n    hi: hi | 0\r\n  };\r\n}\r\n/**\r\n * Returns two's compliment negation of input.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\r\n */\r\nfunction negate(lowBits, highBits) {\r\n  highBits = ~highBits;\r\n  if (lowBits) {\r\n    lowBits = ~lowBits + 1;\r\n  } else {\r\n    // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\r\n    // adding 1 to that, results in 0x100000000, which leaves\r\n    // the low bits 0x0 and simply adds one to the high bits.\r\n    highBits += 1;\r\n  }\r\n  return newBits(lowBits, highBits);\r\n}\r\n/**\r\n * Returns decimal representation of digit1e7 with leading zeros.\r\n */\r\nconst decimalFrom1e7WithLeadingZeros = digit1e7 => {\r\n  const partial = String(digit1e7);\r\n  return \"0000000\".slice(partial.length) + partial;\r\n};\r\n/**\r\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\r\n *\r\n * Copyright 2008 Google Inc.  All rights reserved.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\r\n */\r\nfunction varint32write(value, bytes) {\r\n  if (value >= 0) {\r\n    // write value as varint 32\r\n    while (value > 0x7f) {\r\n      bytes.push(value & 0x7f | 0x80);\r\n      value = value >>> 7;\r\n    }\r\n    bytes.push(value);\r\n  } else {\r\n    for (let i = 0; i < 9; i++) {\r\n      bytes.push(value & 127 | 128);\r\n      value = value >> 7;\r\n    }\r\n    bytes.push(1);\r\n  }\r\n}\r\n/**\r\n * Read an unsigned 32 bit varint.\r\n *\r\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\r\n */\r\nfunction varint32read() {\r\n  let b = this.buf[this.pos++];\r\n  let result = b & 0x7f;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 7;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 14;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x7f) << 21;\r\n  if ((b & 0x80) == 0) {\r\n    this.assertBounds();\r\n    return result;\r\n  }\r\n  // Extract only last 4 bits\r\n  b = this.buf[this.pos++];\r\n  result |= (b & 0x0f) << 28;\r\n  for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];\r\n  if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\r\n  this.assertBounds();\r\n  // Result can have 32 bits, convert it to unsigned\r\n  return result >>> 0;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nfunction makeInt64Support() {\r\n  const dv = new DataView(new ArrayBuffer(8));\r\n  // note that Safari 14 implements BigInt, but not the DataView methods\r\n  const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\r\n  if (ok) {\r\n    const MIN = BigInt(\"-9223372036854775808\"),\r\n      MAX = BigInt(\"9223372036854775807\"),\r\n      UMIN = BigInt(\"0\"),\r\n      UMAX = BigInt(\"18446744073709551615\");\r\n    return {\r\n      zero: BigInt(0),\r\n      supported: true,\r\n      parse(value) {\r\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\r\n        if (bi > MAX || bi < MIN) {\r\n          throw new Error(\"int64 invalid: \".concat(value));\r\n        }\r\n        return bi;\r\n      },\r\n      uParse(value) {\r\n        const bi = typeof value == \"bigint\" ? value : BigInt(value);\r\n        if (bi > UMAX || bi < UMIN) {\r\n          throw new Error(\"uint64 invalid: \".concat(value));\r\n        }\r\n        return bi;\r\n      },\r\n      enc(value) {\r\n        dv.setBigInt64(0, this.parse(value), true);\r\n        return {\r\n          lo: dv.getInt32(0, true),\r\n          hi: dv.getInt32(4, true)\r\n        };\r\n      },\r\n      uEnc(value) {\r\n        dv.setBigInt64(0, this.uParse(value), true);\r\n        return {\r\n          lo: dv.getInt32(0, true),\r\n          hi: dv.getInt32(4, true)\r\n        };\r\n      },\r\n      dec(lo, hi) {\r\n        dv.setInt32(0, lo, true);\r\n        dv.setInt32(4, hi, true);\r\n        return dv.getBigInt64(0, true);\r\n      },\r\n      uDec(lo, hi) {\r\n        dv.setInt32(0, lo, true);\r\n        dv.setInt32(4, hi, true);\r\n        return dv.getBigUint64(0, true);\r\n      }\r\n    };\r\n  }\r\n  const assertInt64String = value => assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\r\n  const assertUInt64String = value => assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\r\n  return {\r\n    zero: \"0\",\r\n    supported: false,\r\n    parse(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertInt64String(value);\r\n      return value;\r\n    },\r\n    uParse(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertUInt64String(value);\r\n      return value;\r\n    },\r\n    enc(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertInt64String(value);\r\n      return int64FromString(value);\r\n    },\r\n    uEnc(value) {\r\n      if (typeof value != \"string\") {\r\n        value = value.toString();\r\n      }\r\n      assertUInt64String(value);\r\n      return int64FromString(value);\r\n    },\r\n    dec(lo, hi) {\r\n      return int64ToString(lo, hi);\r\n    },\r\n    uDec(lo, hi) {\r\n      return uInt64ToString(lo, hi);\r\n    }\r\n  };\r\n}\r\nconst protoInt64 = makeInt64Support();\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Scalar value types. This is a subset of field types declared by protobuf\r\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\r\n * are omitted, but the numerical values are identical.\r\n */\r\nvar ScalarType;\r\n(function (ScalarType) {\r\n  // 0 is reserved for errors.\r\n  // Order is weird for historical reasons.\r\n  ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\r\n  ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\r\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\r\n  // negative values are likely.\r\n  ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\r\n  ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\r\n  // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\r\n  // negative values are likely.\r\n  ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\r\n  ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\r\n  ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\r\n  ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\r\n  ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\r\n  // Tag-delimited aggregate.\r\n  // Group type is deprecated and not supported in proto3. However, Proto3\r\n  // implementations should still be able to parse the group wire format and\r\n  // treat group fields as unknown fields.\r\n  // TYPE_GROUP = 10,\r\n  // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\r\n  // New in version 2.\r\n  ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\r\n  ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\r\n  // TYPE_ENUM = 14,\r\n  ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\r\n  ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\r\n  ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\r\n  ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\r\n})(ScalarType || (ScalarType = {}));\r\n/**\r\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\r\n * sint64, fixed64, sfixed64).\r\n *\r\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\r\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\r\n * String if `[jstype = JS_STRING]` is specified.\r\n *\r\n * ```protobuf\r\n * uint64 field_a = 1; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\r\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\r\n * ```\r\n */\r\nvar LongType;\r\n(function (LongType) {\r\n  /**\r\n   * Use JavaScript BigInt.\r\n   */\r\n  LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\r\n  /**\r\n   * Use JavaScript String.\r\n   *\r\n   * Field option `[jstype = JS_STRING]`.\r\n   */\r\n  LongType[LongType[\"STRING\"] = 1] = \"STRING\";\r\n})(LongType || (LongType = {}));\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns true if both scalar values are equal.\r\n */\r\nfunction scalarEquals(type, a, b) {\r\n  if (a === b) {\r\n    // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\r\n    return true;\r\n  }\r\n  // Special case BYTES - we need to compare each byte individually\r\n  if (type == ScalarType.BYTES) {\r\n    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\r\n      return false;\r\n    }\r\n    if (a.length !== b.length) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i]) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  // Special case 64-bit integers - we support number, string and bigint representation.\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n  switch (type) {\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      // Loose comparison will match between 0n, 0 and \"0\".\r\n      return a == b;\r\n  }\r\n  // Anything that hasn't been caught by strict comparison or special cased\r\n  // BYTES and 64-bit integers is not equal.\r\n  return false;\r\n}\r\n/**\r\n * Returns the zero value for the given scalar type.\r\n */\r\nfunction scalarZeroValue(type, longType) {\r\n  switch (type) {\r\n    case ScalarType.BOOL:\r\n      return false;\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\r\n      return longType == 0 ? protoInt64.zero : \"0\";\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FLOAT:\r\n      return 0.0;\r\n    case ScalarType.BYTES:\r\n      return new Uint8Array(0);\r\n    case ScalarType.STRING:\r\n      return \"\";\r\n    default:\r\n      // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\r\n      // We do not use individual cases to save a few bytes code size.\r\n      return 0;\r\n  }\r\n}\r\n/**\r\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\r\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\r\n *\r\n * In proto3, zero-values are not written to the wire, unless the field is\r\n * optional or repeated.\r\n */\r\nfunction isScalarZeroValue(type, value) {\r\n  switch (type) {\r\n    case ScalarType.BOOL:\r\n      return value === false;\r\n    case ScalarType.STRING:\r\n      return value === \"\";\r\n    case ScalarType.BYTES:\r\n      return value instanceof Uint8Array && !value.byteLength;\r\n    default:\r\n      return value == 0;\r\n    // Loose comparison matches 0n, 0 and \"0\"\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */\r\n/**\r\n * Protobuf binary format wire types.\r\n *\r\n * A wire type provides just enough information to find the length of the\r\n * following value.\r\n *\r\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\r\n */\r\nvar WireType;\r\n(function (WireType) {\r\n  /**\r\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\r\n   */\r\n  WireType[WireType[\"Varint\"] = 0] = \"Varint\";\r\n  /**\r\n   * Used for fixed64, sfixed64, double.\r\n   * Always 8 bytes with little-endian byte order.\r\n   */\r\n  WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\r\n  /**\r\n   * Used for string, bytes, embedded messages, packed repeated fields\r\n   *\r\n   * Only repeated numeric types (types which use the varint, 32-bit,\r\n   * or 64-bit wire types) can be packed. In proto3, such fields are\r\n   * packed by default.\r\n   */\r\n  WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\r\n  /**\r\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\r\n   * in editions with message_encoding = DELIMITED.\r\n   */\r\n  WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\r\n  /**\r\n   * End of a tag-delimited aggregate.\r\n   */\r\n  WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\r\n  /**\r\n   * Used for fixed32, sfixed32, float.\r\n   * Always 4 bytes with little-endian byte order.\r\n   */\r\n  WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\r\n})(WireType || (WireType = {}));\r\nclass BinaryWriter {\r\n  constructor(textEncoder) {\r\n    /**\r\n     * Previous fork states.\r\n     */\r\n    this.stack = [];\r\n    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\r\n    this.chunks = [];\r\n    this.buf = [];\r\n  }\r\n  /**\r\n   * Return all bytes written and reset this writer.\r\n   */\r\n  finish() {\r\n    this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\r\n    let len = 0;\r\n    for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;\r\n    let bytes = new Uint8Array(len);\r\n    let offset = 0;\r\n    for (let i = 0; i < this.chunks.length; i++) {\r\n      bytes.set(this.chunks[i], offset);\r\n      offset += this.chunks[i].length;\r\n    }\r\n    this.chunks = [];\r\n    return bytes;\r\n  }\r\n  /**\r\n   * Start a new fork for length-delimited data like a message\r\n   * or a packed repeated field.\r\n   *\r\n   * Must be joined later with `join()`.\r\n   */\r\n  fork() {\r\n    this.stack.push({\r\n      chunks: this.chunks,\r\n      buf: this.buf\r\n    });\r\n    this.chunks = [];\r\n    this.buf = [];\r\n    return this;\r\n  }\r\n  /**\r\n   * Join the last fork. Write its length and bytes, then\r\n   * return to the previous state.\r\n   */\r\n  join() {\r\n    // get chunk of fork\r\n    let chunk = this.finish();\r\n    // restore previous state\r\n    let prev = this.stack.pop();\r\n    if (!prev) throw new Error(\"invalid state, fork stack empty\");\r\n    this.chunks = prev.chunks;\r\n    this.buf = prev.buf;\r\n    // write length of chunk as varint\r\n    this.uint32(chunk.byteLength);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Writes a tag (field number and wire type).\r\n   *\r\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\r\n   *\r\n   * Generated code should compute the tag ahead of time and call `uint32()`.\r\n   */\r\n  tag(fieldNo, type) {\r\n    return this.uint32((fieldNo << 3 | type) >>> 0);\r\n  }\r\n  /**\r\n   * Write a chunk of raw bytes.\r\n   */\r\n  raw(chunk) {\r\n    if (this.buf.length) {\r\n      this.chunks.push(new Uint8Array(this.buf));\r\n      this.buf = [];\r\n    }\r\n    this.chunks.push(chunk);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `uint32` value, an unsigned 32 bit varint.\r\n   */\r\n  uint32(value) {\r\n    assertUInt32(value);\r\n    // write value as varint 32, inlined for speed\r\n    while (value > 0x7f) {\r\n      this.buf.push(value & 0x7f | 0x80);\r\n      value = value >>> 7;\r\n    }\r\n    this.buf.push(value);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `int32` value, a signed 32 bit varint.\r\n   */\r\n  int32(value) {\r\n    assertInt32(value);\r\n    varint32write(value, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `bool` value, a variant.\r\n   */\r\n  bool(value) {\r\n    this.buf.push(value ? 1 : 0);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `bytes` value, length-delimited arbitrary data.\r\n   */\r\n  bytes(value) {\r\n    this.uint32(value.byteLength); // write length of chunk as varint\r\n    return this.raw(value);\r\n  }\r\n  /**\r\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\r\n   */\r\n  string(value) {\r\n    let chunk = this.textEncoder.encode(value);\r\n    this.uint32(chunk.byteLength); // write length of chunk as varint\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `float` value, 32-bit floating point number.\r\n   */\r\n  float(value) {\r\n    assertFloat32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setFloat32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `double` value, a 64-bit floating point number.\r\n   */\r\n  double(value) {\r\n    let chunk = new Uint8Array(8);\r\n    new DataView(chunk.buffer).setFloat64(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\r\n   */\r\n  fixed32(value) {\r\n    assertUInt32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setUint32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\r\n   */\r\n  sfixed32(value) {\r\n    assertInt32(value);\r\n    let chunk = new Uint8Array(4);\r\n    new DataView(chunk.buffer).setInt32(0, value, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\r\n   */\r\n  sint32(value) {\r\n    assertInt32(value);\r\n    // zigzag encode\r\n    value = (value << 1 ^ value >> 31) >>> 0;\r\n    varint32write(value, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\r\n   */\r\n  sfixed64(value) {\r\n    let chunk = new Uint8Array(8),\r\n      view = new DataView(chunk.buffer),\r\n      tc = protoInt64.enc(value);\r\n    view.setInt32(0, tc.lo, true);\r\n    view.setInt32(4, tc.hi, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\r\n   */\r\n  fixed64(value) {\r\n    let chunk = new Uint8Array(8),\r\n      view = new DataView(chunk.buffer),\r\n      tc = protoInt64.uEnc(value);\r\n    view.setInt32(0, tc.lo, true);\r\n    view.setInt32(4, tc.hi, true);\r\n    return this.raw(chunk);\r\n  }\r\n  /**\r\n   * Write a `int64` value, a signed 64-bit varint.\r\n   */\r\n  int64(value) {\r\n    let tc = protoInt64.enc(value);\r\n    varint64write(tc.lo, tc.hi, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\r\n   */\r\n  sint64(value) {\r\n    let tc = protoInt64.enc(value),\r\n      // zigzag encode\r\n      sign = tc.hi >> 31,\r\n      lo = tc.lo << 1 ^ sign,\r\n      hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\r\n    varint64write(lo, hi, this.buf);\r\n    return this;\r\n  }\r\n  /**\r\n   * Write a `uint64` value, an unsigned 64-bit varint.\r\n   */\r\n  uint64(value) {\r\n    let tc = protoInt64.uEnc(value);\r\n    varint64write(tc.lo, tc.hi, this.buf);\r\n    return this;\r\n  }\r\n}\r\nclass BinaryReader {\r\n  constructor(buf, textDecoder) {\r\n    this.varint64 = varint64read; // dirty cast for `this`\r\n    /**\r\n     * Read a `uint32` field, an unsigned 32 bit varint.\r\n     */\r\n    this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\r\n    this.buf = buf;\r\n    this.len = buf.length;\r\n    this.pos = 0;\r\n    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\r\n    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\r\n  }\r\n  /**\r\n   * Reads a tag - field number and wire type.\r\n   */\r\n  tag() {\r\n    let tag = this.uint32(),\r\n      fieldNo = tag >>> 3,\r\n      wireType = tag & 7;\r\n    if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\r\n    return [fieldNo, wireType];\r\n  }\r\n  /**\r\n   * Skip one element and return the skipped data.\r\n   *\r\n   * When skipping StartGroup, provide the tags field number to check for\r\n   * matching field number in the EndGroup tag.\r\n   */\r\n  skip(wireType, fieldNo) {\r\n    let start = this.pos;\r\n    switch (wireType) {\r\n      case WireType.Varint:\r\n        while (this.buf[this.pos++] & 0x80) {\r\n          // ignore\r\n        }\r\n        break;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore TS7029: Fallthrough case in switch\r\n      case WireType.Bit64:\r\n        this.pos += 4;\r\n      // eslint-disable-next-line\r\n      // @ts-ignore TS7029: Fallthrough case in switch\r\n      case WireType.Bit32:\r\n        this.pos += 4;\r\n        break;\r\n      case WireType.LengthDelimited:\r\n        let len = this.uint32();\r\n        this.pos += len;\r\n        break;\r\n      case WireType.StartGroup:\r\n        for (;;) {\r\n          const [fn, wt] = this.tag();\r\n          if (wt === WireType.EndGroup) {\r\n            if (fieldNo !== undefined && fn !== fieldNo) {\r\n              throw new Error(\"invalid end group tag\");\r\n            }\r\n            break;\r\n          }\r\n          this.skip(wt, fn);\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error(\"cant skip wire type \" + wireType);\r\n    }\r\n    this.assertBounds();\r\n    return this.buf.subarray(start, this.pos);\r\n  }\r\n  /**\r\n   * Throws error if position in byte array is out of range.\r\n   */\r\n  assertBounds() {\r\n    if (this.pos > this.len) throw new RangeError(\"premature EOF\");\r\n  }\r\n  /**\r\n   * Read a `int32` field, a signed 32 bit varint.\r\n   */\r\n  int32() {\r\n    return this.uint32() | 0;\r\n  }\r\n  /**\r\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\r\n   */\r\n  sint32() {\r\n    let zze = this.uint32();\r\n    // decode zigzag\r\n    return zze >>> 1 ^ -(zze & 1);\r\n  }\r\n  /**\r\n   * Read a `int64` field, a signed 64-bit varint.\r\n   */\r\n  int64() {\r\n    return protoInt64.dec(...this.varint64());\r\n  }\r\n  /**\r\n   * Read a `uint64` field, an unsigned 64-bit varint.\r\n   */\r\n  uint64() {\r\n    return protoInt64.uDec(...this.varint64());\r\n  }\r\n  /**\r\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\r\n   */\r\n  sint64() {\r\n    let [lo, hi] = this.varint64();\r\n    // decode zig zag\r\n    let s = -(lo & 1);\r\n    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\r\n    hi = hi >>> 1 ^ s;\r\n    return protoInt64.dec(lo, hi);\r\n  }\r\n  /**\r\n   * Read a `bool` field, a variant.\r\n   */\r\n  bool() {\r\n    let [lo, hi] = this.varint64();\r\n    return lo !== 0 || hi !== 0;\r\n  }\r\n  /**\r\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\r\n   */\r\n  fixed32() {\r\n    return this.view.getUint32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\r\n   */\r\n  sfixed32() {\r\n    return this.view.getInt32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\r\n   */\r\n  fixed64() {\r\n    return protoInt64.uDec(this.sfixed32(), this.sfixed32());\r\n  }\r\n  /**\r\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\r\n   */\r\n  sfixed64() {\r\n    return protoInt64.dec(this.sfixed32(), this.sfixed32());\r\n  }\r\n  /**\r\n   * Read a `float` field, 32-bit floating point number.\r\n   */\r\n  float() {\r\n    return this.view.getFloat32((this.pos += 4) - 4, true);\r\n  }\r\n  /**\r\n   * Read a `double` field, a 64-bit floating point number.\r\n   */\r\n  double() {\r\n    return this.view.getFloat64((this.pos += 8) - 8, true);\r\n  }\r\n  /**\r\n   * Read a `bytes` field, length-delimited arbitrary data.\r\n   */\r\n  bytes() {\r\n    let len = this.uint32(),\r\n      start = this.pos;\r\n    this.pos += len;\r\n    this.assertBounds();\r\n    return this.buf.subarray(start, start + len);\r\n  }\r\n  /**\r\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\r\n   */\r\n  string() {\r\n    return this.textDecoder.decode(this.bytes());\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Create a new extension using the given runtime.\r\n */\r\nfunction makeExtension(runtime, typeName, extendee, field) {\r\n  let fi;\r\n  return {\r\n    typeName,\r\n    extendee,\r\n    get field() {\r\n      if (!fi) {\r\n        const i = typeof field == \"function\" ? field() : field;\r\n        i.name = typeName.split(\".\").pop();\r\n        i.jsonName = \"[\".concat(typeName, \"]\");\r\n        fi = runtime.util.newFieldList([i]).list()[0];\r\n      }\r\n      return fi;\r\n    },\r\n    runtime\r\n  };\r\n}\r\n/**\r\n * Create a container that allows us to read extension fields into it with the\r\n * same logic as regular fields.\r\n */\r\nfunction createExtensionContainer(extension) {\r\n  const localName = extension.field.localName;\r\n  const container = Object.create(null);\r\n  container[localName] = initExtensionField(extension);\r\n  return [container, () => container[localName]];\r\n}\r\nfunction initExtensionField(ext) {\r\n  const field = ext.field;\r\n  if (field.repeated) {\r\n    return [];\r\n  }\r\n  if (field.default !== undefined) {\r\n    return field.default;\r\n  }\r\n  switch (field.kind) {\r\n    case \"enum\":\r\n      return field.T.values[0].no;\r\n    case \"scalar\":\r\n      return scalarZeroValue(field.T, field.L);\r\n    case \"message\":\r\n      // eslint-disable-next-line no-case-declarations\r\n      const T = field.T,\r\n        value = new T();\r\n      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\r\n    case \"map\":\r\n      throw \"map fields are not allowed to be extensions\";\r\n  }\r\n}\r\n/**\r\n * Helper to filter unknown fields, optimized based on field type.\r\n */\r\nfunction filterUnknownFields(unknownFields, field) {\r\n  if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\r\n    // singular scalar fields do not merge, we pick the last\r\n    for (let i = unknownFields.length - 1; i >= 0; --i) {\r\n      if (unknownFields[i].no == field.no) {\r\n        return [unknownFields[i]];\r\n      }\r\n    }\r\n    return [];\r\n  }\r\n  return unknownFields.filter(uf => uf.no === field.no);\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */\r\n// lookup table from base64 character to byte\r\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\r\n// lookup table from base64 character *code* to byte because lookup by number is fast\r\nlet decTable = [];\r\nfor (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;\r\n// support base64url variants\r\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\r\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\r\nconst protoBase64 = {\r\n  /**\r\n   * Decodes a base64 string to a byte array.\r\n   *\r\n   * - ignores white-space, including line breaks and tabs\r\n   * - allows inner padding (can decode concatenated base64 strings)\r\n   * - does not require padding\r\n   * - understands base64url encoding:\r\n   *   \"-\" instead of \"+\",\r\n   *   \"_\" instead of \"/\",\r\n   *   no padding\r\n   */\r\n  dec(base64Str) {\r\n    // estimate byte size, not accounting for inner padding and whitespace\r\n    let es = base64Str.length * 3 / 4;\r\n    if (base64Str[base64Str.length - 2] == \"=\") es -= 2;else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\r\n    let bytes = new Uint8Array(es),\r\n      bytePos = 0,\r\n      // position in byte array\r\n      groupPos = 0,\r\n      // position in base64 group\r\n      b,\r\n      // current byte\r\n      p = 0; // previous byte\r\n    for (let i = 0; i < base64Str.length; i++) {\r\n      b = decTable[base64Str.charCodeAt(i)];\r\n      if (b === undefined) {\r\n        switch (base64Str[i]) {\r\n          // @ts-ignore TS7029: Fallthrough case in switch\r\n          case \"=\":\r\n            groupPos = 0;\r\n          // reset state when padding found\r\n          // @ts-ignore TS7029: Fallthrough case in switch\r\n          case \"\\n\":\r\n          case \"\\r\":\r\n          case \"\\t\":\r\n          case \" \":\r\n            continue;\r\n          // skip white-space, and padding\r\n          default:\r\n            throw Error(\"invalid base64 string.\");\r\n        }\r\n      }\r\n      switch (groupPos) {\r\n        case 0:\r\n          p = b;\r\n          groupPos = 1;\r\n          break;\r\n        case 1:\r\n          bytes[bytePos++] = p << 2 | (b & 48) >> 4;\r\n          p = b;\r\n          groupPos = 2;\r\n          break;\r\n        case 2:\r\n          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\r\n          p = b;\r\n          groupPos = 3;\r\n          break;\r\n        case 3:\r\n          bytes[bytePos++] = (p & 3) << 6 | b;\r\n          groupPos = 0;\r\n          break;\r\n      }\r\n    }\r\n    if (groupPos == 1) throw Error(\"invalid base64 string.\");\r\n    return bytes.subarray(0, bytePos);\r\n  },\r\n  /**\r\n   * Encode a byte array to a base64 string.\r\n   */\r\n  enc(bytes) {\r\n    let base64 = \"\",\r\n      groupPos = 0,\r\n      // position in base64 group\r\n      b,\r\n      // current byte\r\n      p = 0; // carry over from previous byte\r\n    for (let i = 0; i < bytes.length; i++) {\r\n      b = bytes[i];\r\n      switch (groupPos) {\r\n        case 0:\r\n          base64 += encTable[b >> 2];\r\n          p = (b & 3) << 4;\r\n          groupPos = 1;\r\n          break;\r\n        case 1:\r\n          base64 += encTable[p | b >> 4];\r\n          p = (b & 15) << 2;\r\n          groupPos = 2;\r\n          break;\r\n        case 2:\r\n          base64 += encTable[p | b >> 6];\r\n          base64 += encTable[b & 63];\r\n          groupPos = 0;\r\n          break;\r\n      }\r\n    }\r\n    // add output padding\r\n    if (groupPos) {\r\n      base64 += encTable[p];\r\n      base64 += \"=\";\r\n      if (groupPos == 1) base64 += \"=\";\r\n    }\r\n    return base64;\r\n  }\r\n};\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Retrieve an extension value from a message.\r\n *\r\n * The function never returns undefined. Use hasExtension() to check whether an\r\n * extension is set. If the extension is not set, this function returns the\r\n * default value (if one was specified in the protobuf source), or the zero value\r\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\r\n * an empty message instance for message fields).\r\n *\r\n * Extensions are stored as unknown fields on a message. To mutate an extension\r\n * value, make sure to store the new value with setExtension() after mutating.\r\n *\r\n * If the extension does not extend the given message, an error is raised.\r\n */\r\nfunction getExtension(message, extension, options) {\r\n  assertExtendee(extension, message);\r\n  const opt = extension.runtime.bin.makeReadOptions(options);\r\n  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\r\n  const [container, get] = createExtensionContainer(extension);\r\n  for (const uf of ufs) {\r\n    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\r\n  }\r\n  return get();\r\n}\r\n/**\r\n * Set an extension value on a message. If the message already has a value for\r\n * this extension, the value is replaced.\r\n *\r\n * If the extension does not extend the given message, an error is raised.\r\n */\r\nfunction setExtension(message, extension, value, options) {\r\n  assertExtendee(extension, message);\r\n  const readOpt = extension.runtime.bin.makeReadOptions(options);\r\n  const writeOpt = extension.runtime.bin.makeWriteOptions(options);\r\n  if (hasExtension(message, extension)) {\r\n    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter(uf => uf.no != extension.field.no);\r\n    message.getType().runtime.bin.discardUnknownFields(message);\r\n    for (const uf of ufs) {\r\n      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\r\n    }\r\n  }\r\n  const writer = writeOpt.writerFactory();\r\n  let f = extension.field;\r\n  // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\r\n  // We patch the field info to use explicit presence:\r\n  if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\r\n    f = Object.assign(Object.assign({}, extension.field), {\r\n      opt: true\r\n    });\r\n  }\r\n  extension.runtime.bin.writeField(f, value, writer, writeOpt);\r\n  const reader = readOpt.readerFactory(writer.finish());\r\n  while (reader.pos < reader.len) {\r\n    const [no, wireType] = reader.tag();\r\n    const data = reader.skip(wireType, no);\r\n    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\r\n  }\r\n}\r\n/**\r\n * Check whether an extension is set on a message.\r\n */\r\nfunction hasExtension(message, extension) {\r\n  const messageType = message.getType();\r\n  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(uf => uf.no == extension.field.no);\r\n}\r\nfunction assertExtendee(extension, message) {\r\n  assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns true if the field is set.\r\n */\r\nfunction isFieldSet(field, target) {\r\n  const localName = field.localName;\r\n  if (field.repeated) {\r\n    return target[localName].length > 0;\r\n  }\r\n  if (field.oneof) {\r\n    return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\r\n  }\r\n  switch (field.kind) {\r\n    case \"enum\":\r\n    case \"scalar\":\r\n      if (field.opt || field.req) {\r\n        // explicit presence\r\n        return target[localName] !== undefined;\r\n      }\r\n      // implicit presence\r\n      if (field.kind == \"enum\") {\r\n        return target[localName] !== field.T.values[0].no;\r\n      }\r\n      return !isScalarZeroValue(field.T, target[localName]);\r\n    case \"message\":\r\n      return target[localName] !== undefined;\r\n    case \"map\":\r\n      return Object.keys(target[localName]).length > 0;\r\n    // eslint-disable-line @typescript-eslint/no-unsafe-argument\r\n  }\r\n}\r\n/**\r\n * Resets the field, so that isFieldSet() will return false.\r\n */\r\nfunction clearField(field, target) {\r\n  const localName = field.localName;\r\n  const implicitPresence = !field.opt && !field.req;\r\n  if (field.repeated) {\r\n    target[localName] = [];\r\n  } else if (field.oneof) {\r\n    target[field.oneof.localName] = {\r\n      case: undefined\r\n    };\r\n  } else {\r\n    switch (field.kind) {\r\n      case \"map\":\r\n        target[localName] = {};\r\n        break;\r\n      case \"enum\":\r\n        target[localName] = implicitPresence ? field.T.values[0].no : undefined;\r\n        break;\r\n      case \"scalar\":\r\n        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\r\n        break;\r\n      case \"message\":\r\n        target[localName] = undefined;\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Check whether the given object is any subtype of Message or is a specific\r\n * Message by passing the type.\r\n *\r\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\r\n * `isMessage` is that it compares identity by the message type name, not by\r\n * class identity. This makes it robust against the dual package hazard and\r\n * similar situations, where the same message is duplicated.\r\n *\r\n * This function is _mostly_ equivalent to the `instanceof` operator. For\r\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\r\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\r\n * `isMessage` should be preferred over `instanceof`.\r\n *\r\n * However, due to the fact that `isMessage` does not use class identity, there\r\n * are subtle differences between this function and `instanceof`. Notably,\r\n * calling `isMessage` on an explicit type of Message will return false.\r\n */\r\nfunction isMessage(arg, type) {\r\n  if (arg === null || typeof arg != \"object\") {\r\n    return false;\r\n  }\r\n  if (!Object.getOwnPropertyNames(Message.prototype).every(m => m in arg && typeof arg[m] == \"function\")) {\r\n    return false;\r\n  }\r\n  const actualType = arg.getType();\r\n  if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\r\n    return false;\r\n  }\r\n  return type === undefined ? true : actualType.typeName == type.typeName;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Wrap a primitive message field value in its corresponding wrapper\r\n * message. This function is idempotent.\r\n */\r\nfunction wrapField(type, value) {\r\n  if (isMessage(value) || !type.fieldWrapper) {\r\n    return value;\r\n  }\r\n  return type.fieldWrapper.wrapField(value);\r\n}\r\n({\r\n  \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\r\n  \"google.protobuf.FloatValue\": ScalarType.FLOAT,\r\n  \"google.protobuf.Int64Value\": ScalarType.INT64,\r\n  \"google.protobuf.UInt64Value\": ScalarType.UINT64,\r\n  \"google.protobuf.Int32Value\": ScalarType.INT32,\r\n  \"google.protobuf.UInt32Value\": ScalarType.UINT32,\r\n  \"google.protobuf.BoolValue\": ScalarType.BOOL,\r\n  \"google.protobuf.StringValue\": ScalarType.STRING,\r\n  \"google.protobuf.BytesValue\": ScalarType.BYTES\r\n});\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */\r\n// Default options for parsing JSON.\r\nconst jsonReadDefaults = {\r\n  ignoreUnknownFields: false\r\n};\r\n// Default options for serializing to JSON.\r\nconst jsonWriteDefaults = {\r\n  emitDefaultValues: false,\r\n  enumAsInteger: false,\r\n  useProtoFieldName: false,\r\n  prettySpaces: 0\r\n};\r\nfunction makeReadOptions$1(options) {\r\n  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\r\n}\r\nfunction makeWriteOptions$1(options) {\r\n  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\r\n}\r\nconst tokenNull = Symbol();\r\nconst tokenIgnoredUnknownEnum = Symbol();\r\nfunction makeJsonFormat() {\r\n  return {\r\n    makeReadOptions: makeReadOptions$1,\r\n    makeWriteOptions: makeWriteOptions$1,\r\n    readMessage(type, json, options, message) {\r\n      if (json == null || Array.isArray(json) || typeof json != \"object\") {\r\n        throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\r\n      }\r\n      message = message !== null && message !== void 0 ? message : new type();\r\n      const oneofSeen = new Map();\r\n      const registry = options.typeRegistry;\r\n      for (const [jsonKey, jsonValue] of Object.entries(json)) {\r\n        const field = type.fields.findJsonName(jsonKey);\r\n        if (field) {\r\n          if (field.oneof) {\r\n            if (jsonValue === null && field.kind == \"scalar\") {\r\n              // see conformance test Required.Proto3.JsonInput.OneofFieldNull{First,Second}\r\n              continue;\r\n            }\r\n            const seen = oneofSeen.get(field.oneof);\r\n            if (seen !== undefined) {\r\n              throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: multiple keys for oneof \\\"\").concat(field.oneof.name, \"\\\" present: \\\"\").concat(seen, \"\\\", \\\"\").concat(jsonKey, \"\\\"\"));\r\n            }\r\n            oneofSeen.set(field.oneof, jsonKey);\r\n          }\r\n          readField$1(message, jsonValue, field, options, type);\r\n        } else {\r\n          let found = false;\r\n          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\r\n            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\r\n            if (ext && ext.extendee.typeName == type.typeName) {\r\n              found = true;\r\n              const [container, get] = createExtensionContainer(ext);\r\n              readField$1(container, jsonValue, ext.field, options, ext);\r\n              // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\r\n              // so that users can bring their own binary reader and writer factories\r\n              // if necessary.\r\n              setExtension(message, ext, get(), options);\r\n            }\r\n          }\r\n          if (!found && !options.ignoreUnknownFields) {\r\n            throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: key \\\"\").concat(jsonKey, \"\\\" is unknown\"));\r\n          }\r\n        }\r\n      }\r\n      return message;\r\n    },\r\n    writeMessage(message, options) {\r\n      const type = message.getType();\r\n      const json = {};\r\n      let field;\r\n      try {\r\n        for (field of type.fields.byNumber()) {\r\n          if (!isFieldSet(field, message)) {\r\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n            if (field.req) {\r\n              throw \"required field not set\";\r\n            }\r\n            if (!options.emitDefaultValues) {\r\n              continue;\r\n            }\r\n            if (!canEmitFieldDefaultValue(field)) {\r\n              continue;\r\n            }\r\n          }\r\n          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\r\n          const jsonValue = writeField$1(field, value, options);\r\n          if (jsonValue !== undefined) {\r\n            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\r\n          }\r\n        }\r\n        const registry = options.typeRegistry;\r\n        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\r\n          for (const uf of type.runtime.bin.listUnknownFields(message)) {\r\n            const ext = registry.findExtensionFor(type.typeName, uf.no);\r\n            if (ext && hasExtension(message, ext)) {\r\n              // We pass on the options as BinaryReadOptions, so that users can bring their own\r\n              // binary reader factory if necessary.\r\n              const value = getExtension(message, ext, options);\r\n              const jsonValue = writeField$1(ext.field, value, options);\r\n              if (jsonValue !== undefined) {\r\n                json[ext.field.jsonName] = jsonValue;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (e) {\r\n        const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\r\n        const r = e instanceof Error ? e.message : String(e);\r\n        throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\r\n      }\r\n      return json;\r\n    },\r\n    readScalar(type, json, longType) {\r\n      // The signature of our internal function has changed. For backwards-\r\n      // compatibility, we support the old form that is part of the public API\r\n      // through the interface JsonFormat.\r\n      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\r\n    },\r\n    writeScalar(type, value, emitDefaultValues) {\r\n      // The signature of our internal function has changed. For backwards-\r\n      // compatibility, we support the old form that is part of the public API\r\n      // through the interface JsonFormat.\r\n      if (value === undefined) {\r\n        return undefined;\r\n      }\r\n      if (emitDefaultValues || isScalarZeroValue(type, value)) {\r\n        return writeScalar$1(type, value);\r\n      }\r\n      return undefined;\r\n    },\r\n    debug: debugJsonValue\r\n  };\r\n}\r\nfunction debugJsonValue(json) {\r\n  if (json === null) {\r\n    return \"null\";\r\n  }\r\n  switch (typeof json) {\r\n    case \"object\":\r\n      return Array.isArray(json) ? \"array\" : \"object\";\r\n    case \"string\":\r\n      return json.length > 100 ? \"string\" : \"\\\"\".concat(json.split('\"').join('\\\\\"'), \"\\\"\");\r\n    default:\r\n      return String(json);\r\n  }\r\n}\r\n// Read a JSON value for a field.\r\n// The \"parentType\" argument is only used to provide context in errors.\r\nfunction readField$1(target, jsonValue, field, options, parentType) {\r\n  let localName = field.localName;\r\n  if (field.repeated) {\r\n    assert(field.kind != \"map\");\r\n    if (jsonValue === null) {\r\n      return;\r\n    }\r\n    if (!Array.isArray(jsonValue)) {\r\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\r\n    }\r\n    const targetArray = target[localName];\r\n    for (const jsonItem of jsonValue) {\r\n      if (jsonItem === null) {\r\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\r\n      }\r\n      switch (field.kind) {\r\n        case \"message\":\r\n          targetArray.push(field.T.fromJson(jsonItem, options));\r\n          break;\r\n        case \"enum\":\r\n          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\r\n          if (enumValue !== tokenIgnoredUnknownEnum) {\r\n            targetArray.push(enumValue);\r\n          }\r\n          break;\r\n        case \"scalar\":\r\n          try {\r\n            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\r\n          } catch (e) {\r\n            let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\r\n            if (e instanceof Error && e.message.length > 0) {\r\n              m += \": \".concat(e.message);\r\n            }\r\n            throw new Error(m);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  } else if (field.kind == \"map\") {\r\n    if (jsonValue === null) {\r\n      return;\r\n    }\r\n    if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\r\n      throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\r\n    }\r\n    const targetMap = target[localName];\r\n    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {\r\n      if (jsonMapValue === null) {\r\n        throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\r\n      }\r\n      let key;\r\n      try {\r\n        key = readMapKey(field.K, jsonMapKey);\r\n      } catch (e) {\r\n        let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n        if (e instanceof Error && e.message.length > 0) {\r\n          m += \": \".concat(e.message);\r\n        }\r\n        throw new Error(m);\r\n      }\r\n      switch (field.V.kind) {\r\n        case \"message\":\r\n          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\r\n          break;\r\n        case \"enum\":\r\n          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\r\n          if (enumValue !== tokenIgnoredUnknownEnum) {\r\n            targetMap[key] = enumValue;\r\n          }\r\n          break;\r\n        case \"scalar\":\r\n          try {\r\n            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\r\n          } catch (e) {\r\n            let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n            if (e instanceof Error && e.message.length > 0) {\r\n              m += \": \".concat(e.message);\r\n            }\r\n            throw new Error(m);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  } else {\r\n    if (field.oneof) {\r\n      target = target[field.oneof.localName] = {\r\n        case: localName\r\n      };\r\n      localName = \"value\";\r\n    }\r\n    switch (field.kind) {\r\n      case \"message\":\r\n        const messageType = field.T;\r\n        if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\r\n          return;\r\n        }\r\n        let currentValue = target[localName];\r\n        if (isMessage(currentValue)) {\r\n          currentValue.fromJson(jsonValue, options);\r\n        } else {\r\n          target[localName] = currentValue = messageType.fromJson(jsonValue, options);\r\n          if (messageType.fieldWrapper && !field.oneof) {\r\n            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\r\n          }\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\r\n        switch (enumValue) {\r\n          case tokenNull:\r\n            clearField(field, target);\r\n            break;\r\n          case tokenIgnoredUnknownEnum:\r\n            break;\r\n          default:\r\n            target[localName] = enumValue;\r\n            break;\r\n        }\r\n        break;\r\n      case \"scalar\":\r\n        try {\r\n          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\r\n          switch (scalarValue) {\r\n            case tokenNull:\r\n              clearField(field, target);\r\n              break;\r\n            default:\r\n              target[localName] = scalarValue;\r\n              break;\r\n          }\r\n        } catch (e) {\r\n          let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\r\n          if (e instanceof Error && e.message.length > 0) {\r\n            m += \": \".concat(e.message);\r\n          }\r\n          throw new Error(m);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n}\r\nfunction readMapKey(type, json) {\r\n  if (type === ScalarType.BOOL) {\r\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n    switch (json) {\r\n      case \"true\":\r\n        json = true;\r\n        break;\r\n      case \"false\":\r\n        json = false;\r\n        break;\r\n    }\r\n  }\r\n  return readScalar$1(type, json, LongType.BIGINT, true).toString();\r\n}\r\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\r\n  if (json === null) {\r\n    if (nullAsZeroValue) {\r\n      return scalarZeroValue(type, longType);\r\n    }\r\n    return tokenNull;\r\n  }\r\n  // every valid case in the switch below returns, and every fall\r\n  // through is regarded as a failure.\r\n  switch (type) {\r\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\r\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FLOAT:\r\n      if (json === \"NaN\") return Number.NaN;\r\n      if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\r\n      if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\r\n      if (json === \"\") {\r\n        // empty string is not a number\r\n        break;\r\n      }\r\n      if (typeof json == \"string\" && json.trim().length !== json.length) {\r\n        // extra whitespace\r\n        break;\r\n      }\r\n      if (typeof json != \"string\" && typeof json != \"number\") {\r\n        break;\r\n      }\r\n      const float = Number(json);\r\n      if (Number.isNaN(float)) {\r\n        // not a number\r\n        break;\r\n      }\r\n      if (!Number.isFinite(float)) {\r\n        // infinity and -infinity are handled by string representation above, so this is an error\r\n        break;\r\n      }\r\n      if (type == ScalarType.FLOAT) assertFloat32(float);\r\n      return float;\r\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\r\n    case ScalarType.INT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n    case ScalarType.UINT32:\r\n      let int32;\r\n      if (typeof json == \"number\") int32 = json;else if (typeof json == \"string\" && json.length > 0) {\r\n        if (json.trim().length === json.length) int32 = Number(json);\r\n      }\r\n      if (int32 === undefined) break;\r\n      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);else assertInt32(int32);\r\n      return int32;\r\n    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      if (typeof json != \"number\" && typeof json != \"string\") break;\r\n      const long = protoInt64.parse(json);\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      return longType ? long.toString() : long;\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.UINT64:\r\n      if (typeof json != \"number\" && typeof json != \"string\") break;\r\n      const uLong = protoInt64.uParse(json);\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      return longType ? uLong.toString() : uLong;\r\n    // bool:\r\n    case ScalarType.BOOL:\r\n      if (typeof json !== \"boolean\") break;\r\n      return json;\r\n    // string:\r\n    case ScalarType.STRING:\r\n      if (typeof json !== \"string\") {\r\n        break;\r\n      }\r\n      // A string must always contain UTF-8 encoded or 7-bit ASCII.\r\n      // We validate with encodeURIComponent, which appears to be the fastest widely available option.\r\n      try {\r\n        encodeURIComponent(json);\r\n      } catch (e) {\r\n        throw new Error(\"invalid UTF8\");\r\n      }\r\n      return json;\r\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\r\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\r\n    case ScalarType.BYTES:\r\n      if (json === \"\") return new Uint8Array(0);\r\n      if (typeof json !== \"string\") break;\r\n      return protoBase64.dec(json);\r\n  }\r\n  throw new Error();\r\n}\r\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\r\n  if (json === null) {\r\n    if (type.typeName == \"google.protobuf.NullValue\") {\r\n      return 0; // google.protobuf.NullValue.NULL_VALUE = 0\r\n    }\r\n    return nullAsZeroValue ? type.values[0].no : tokenNull;\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\r\n  switch (typeof json) {\r\n    case \"number\":\r\n      if (Number.isInteger(json)) {\r\n        return json;\r\n      }\r\n      break;\r\n    case \"string\":\r\n      const value = type.findName(json);\r\n      if (value !== undefined) {\r\n        return value.no;\r\n      }\r\n      if (ignoreUnknownFields) {\r\n        return tokenIgnoredUnknownEnum;\r\n      }\r\n      break;\r\n  }\r\n  throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\r\n}\r\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\r\nfunction canEmitFieldDefaultValue(field) {\r\n  if (field.repeated || field.kind == \"map\") {\r\n    // maps are {}, repeated fields are []\r\n    return true;\r\n  }\r\n  if (field.oneof) {\r\n    // oneof fields are never emitted\r\n    return false;\r\n  }\r\n  if (field.kind == \"message\") {\r\n    // singular message field are allowed to emit JSON null, but we do not\r\n    return false;\r\n  }\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n  if (field.opt || field.req) {\r\n    // the field uses explicit presence, so we cannot emit a zero value\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nfunction writeField$1(field, value, options) {\r\n  if (field.kind == \"map\") {\r\n    assert(typeof value == \"object\" && value != null);\r\n    const jsonObj = {};\r\n    const entries = Object.entries(value);\r\n    switch (field.V.kind) {\r\n      case \"scalar\":\r\n        for (const [entryKey, entryValue] of entries) {\r\n          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\r\n        }\r\n        break;\r\n      case \"message\":\r\n        for (const [entryKey, entryValue] of entries) {\r\n          // JSON standard allows only (double quoted) string as property key\r\n          jsonObj[entryKey.toString()] = entryValue.toJson(options);\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        const enumType = field.V.T;\r\n        for (const [entryKey, entryValue] of entries) {\r\n          // JSON standard allows only (double quoted) string as property key\r\n          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\r\n        }\r\n        break;\r\n    }\r\n    return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\r\n  }\r\n  if (field.repeated) {\r\n    assert(Array.isArray(value));\r\n    const jsonArr = [];\r\n    switch (field.kind) {\r\n      case \"scalar\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(writeScalar$1(field.T, value[i]));\r\n        }\r\n        break;\r\n      case \"enum\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\r\n        }\r\n        break;\r\n      case \"message\":\r\n        for (let i = 0; i < value.length; i++) {\r\n          jsonArr.push(value[i].toJson(options));\r\n        }\r\n        break;\r\n    }\r\n    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\r\n  }\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n      return writeScalar$1(field.T, value);\r\n    case \"enum\":\r\n      return writeEnum(field.T, value, options.enumAsInteger);\r\n    case \"message\":\r\n      return wrapField(field.T, value).toJson(options);\r\n  }\r\n}\r\nfunction writeEnum(type, value, enumAsInteger) {\r\n  var _a;\r\n  assert(typeof value == \"number\");\r\n  if (type.typeName == \"google.protobuf.NullValue\") {\r\n    return null;\r\n  }\r\n  if (enumAsInteger) {\r\n    return value;\r\n  }\r\n  const val = type.findNumber(value);\r\n  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\r\n}\r\nfunction writeScalar$1(type, value) {\r\n  switch (type) {\r\n    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\r\n    case ScalarType.INT32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.UINT32:\r\n      assert(typeof value == \"number\");\r\n      return value;\r\n    // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\r\n    // Either numbers or strings are accepted. Exponent notation is also accepted.\r\n    case ScalarType.FLOAT:\r\n    // assertFloat32(value);\r\n    case ScalarType.DOUBLE:\r\n      // eslint-disable-line no-fallthrough\r\n      assert(typeof value == \"number\");\r\n      if (Number.isNaN(value)) return \"NaN\";\r\n      if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\r\n      if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\r\n      return value;\r\n    // string:\r\n    case ScalarType.STRING:\r\n      assert(typeof value == \"string\");\r\n      return value;\r\n    // bool:\r\n    case ScalarType.BOOL:\r\n      assert(typeof value == \"boolean\");\r\n      return value;\r\n    // JSON value will be a decimal string. Either numbers or strings are accepted.\r\n    case ScalarType.UINT64:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.INT64:\r\n    case ScalarType.SFIXED64:\r\n    case ScalarType.SINT64:\r\n      assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\r\n      return value.toString();\r\n    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\r\n    // Either standard or URL-safe base64 encoding with/without paddings are accepted.\r\n    case ScalarType.BYTES:\r\n      assert(value instanceof Uint8Array);\r\n      return protoBase64.enc(value);\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */\r\nconst unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\r\n// Default options for parsing binary data.\r\nconst readDefaults = {\r\n  readUnknownFields: true,\r\n  readerFactory: bytes => new BinaryReader(bytes)\r\n};\r\n// Default options for serializing binary data.\r\nconst writeDefaults = {\r\n  writeUnknownFields: true,\r\n  writerFactory: () => new BinaryWriter()\r\n};\r\nfunction makeReadOptions(options) {\r\n  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\r\n}\r\nfunction makeWriteOptions(options) {\r\n  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\r\n}\r\nfunction makeBinaryFormat() {\r\n  return {\r\n    makeReadOptions,\r\n    makeWriteOptions,\r\n    listUnknownFields(message) {\r\n      var _a;\r\n      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\r\n    },\r\n    discardUnknownFields(message) {\r\n      delete message[unknownFieldsSymbol];\r\n    },\r\n    writeUnknownFields(message, writer) {\r\n      const m = message;\r\n      const c = m[unknownFieldsSymbol];\r\n      if (c) {\r\n        for (const f of c) {\r\n          writer.tag(f.no, f.wireType).raw(f.data);\r\n        }\r\n      }\r\n    },\r\n    onUnknownField(message, no, wireType, data) {\r\n      const m = message;\r\n      if (!Array.isArray(m[unknownFieldsSymbol])) {\r\n        m[unknownFieldsSymbol] = [];\r\n      }\r\n      m[unknownFieldsSymbol].push({\r\n        no,\r\n        wireType,\r\n        data\r\n      });\r\n    },\r\n    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\r\n      const type = message.getType();\r\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\r\n      let fieldNo, wireType;\r\n      while (reader.pos < end) {\r\n        [fieldNo, wireType] = reader.tag();\r\n        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\r\n          break;\r\n        }\r\n        const field = type.fields.find(fieldNo);\r\n        if (!field) {\r\n          const data = reader.skip(wireType, fieldNo);\r\n          if (options.readUnknownFields) {\r\n            this.onUnknownField(message, fieldNo, wireType, data);\r\n          }\r\n          continue;\r\n        }\r\n        readField(message, reader, field, wireType, options);\r\n      }\r\n      if (delimitedMessageEncoding && (\r\n      // eslint-disable-line @typescript-eslint/strict-boolean-expressions\r\n      wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\r\n        throw new Error(\"invalid end group tag\");\r\n      }\r\n    },\r\n    readField,\r\n    writeMessage(message, writer, options) {\r\n      const type = message.getType();\r\n      for (const field of type.fields.byNumber()) {\r\n        if (!isFieldSet(field, message)) {\r\n          if (field.req) {\r\n            throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\r\n          }\r\n          continue;\r\n        }\r\n        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\r\n        writeField(field, value, writer, options);\r\n      }\r\n      if (options.writeUnknownFields) {\r\n        this.writeUnknownFields(message, writer);\r\n      }\r\n      return writer;\r\n    },\r\n    writeField(field, value, writer, options) {\r\n      // The behavior of our internal function has changed, it does no longer\r\n      // accept `undefined` values for singular scalar and map.\r\n      // For backwards-compatibility, we support the old form that is part of\r\n      // the public API through the interface BinaryFormat.\r\n      if (value === undefined) {\r\n        return undefined;\r\n      }\r\n      writeField(field, value, writer, options);\r\n    }\r\n  };\r\n}\r\nfunction readField(target,\r\n// eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\r\nreader, field, wireType, options) {\r\n  let {\r\n    repeated,\r\n    localName\r\n  } = field;\r\n  if (field.oneof) {\r\n    target = target[field.oneof.localName];\r\n    if (target.case != localName) {\r\n      delete target.value;\r\n    }\r\n    target.case = localName;\r\n    localName = \"value\";\r\n  }\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n    case \"enum\":\r\n      const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\r\n      let read = readScalar;\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\r\n      if (field.kind == \"scalar\" && field.L > 0) {\r\n        read = readScalarLTString;\r\n      }\r\n      if (repeated) {\r\n        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\r\n        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\r\n        if (isPacked) {\r\n          let e = reader.uint32() + reader.pos;\r\n          while (reader.pos < e) {\r\n            arr.push(read(reader, scalarType));\r\n          }\r\n        } else {\r\n          arr.push(read(reader, scalarType));\r\n        }\r\n      } else {\r\n        target[localName] = read(reader, scalarType);\r\n      }\r\n      break;\r\n    case \"message\":\r\n      const messageType = field.T;\r\n      if (repeated) {\r\n        // safe to assume presence of array, oneof cannot contain repeated values\r\n        target[localName].push(readMessageField(reader, new messageType(), options, field));\r\n      } else {\r\n        if (isMessage(target[localName])) {\r\n          readMessageField(reader, target[localName], options, field);\r\n        } else {\r\n          target[localName] = readMessageField(reader, new messageType(), options, field);\r\n          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\r\n            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    case \"map\":\r\n      let [mapKey, mapVal] = readMapEntry(field, reader, options);\r\n      // safe to assume presence of map object, oneof cannot contain repeated values\r\n      target[localName][mapKey] = mapVal;\r\n      break;\r\n  }\r\n}\r\n// Read a message, avoiding MessageType.fromBinary() to re-use the\r\n// BinaryReadOptions and the IBinaryReader.\r\nfunction readMessageField(reader, message, options, field) {\r\n  const format = message.getType().runtime.bin;\r\n  const delimited = field === null || field === void 0 ? void 0 : field.delimited;\r\n  format.readMessage(message, reader, delimited ? field.no : reader.uint32(),\r\n  // eslint-disable-line @typescript-eslint/strict-boolean-expressions\r\n  options, delimited);\r\n  return message;\r\n}\r\n// Read a map field, expecting key field = 1, value field = 2\r\nfunction readMapEntry(field, reader, options) {\r\n  const length = reader.uint32(),\r\n    end = reader.pos + length;\r\n  let key, val;\r\n  while (reader.pos < end) {\r\n    const [fieldNo] = reader.tag();\r\n    switch (fieldNo) {\r\n      case 1:\r\n        key = readScalar(reader, field.K);\r\n        break;\r\n      case 2:\r\n        switch (field.V.kind) {\r\n          case \"scalar\":\r\n            val = readScalar(reader, field.V.T);\r\n            break;\r\n          case \"enum\":\r\n            val = reader.int32();\r\n            break;\r\n          case \"message\":\r\n            val = readMessageField(reader, new field.V.T(), options, undefined);\r\n            break;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n  if (key === undefined) {\r\n    key = scalarZeroValue(field.K, LongType.BIGINT);\r\n  }\r\n  if (typeof key != \"string\" && typeof key != \"number\") {\r\n    key = key.toString();\r\n  }\r\n  if (val === undefined) {\r\n    switch (field.V.kind) {\r\n      case \"scalar\":\r\n        val = scalarZeroValue(field.V.T, LongType.BIGINT);\r\n        break;\r\n      case \"enum\":\r\n        val = field.V.T.values[0].no;\r\n        break;\r\n      case \"message\":\r\n        val = new field.V.T();\r\n        break;\r\n    }\r\n  }\r\n  return [key, val];\r\n}\r\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\r\n// sint64, fixed64, sfixed64) as string instead of bigint.\r\nfunction readScalarLTString(reader, type) {\r\n  const v = readScalar(reader, type);\r\n  return typeof v == \"bigint\" ? v.toString() : v;\r\n}\r\n// Does not use scalarTypeInfo() for better performance.\r\nfunction readScalar(reader, type) {\r\n  switch (type) {\r\n    case ScalarType.STRING:\r\n      return reader.string();\r\n    case ScalarType.BOOL:\r\n      return reader.bool();\r\n    case ScalarType.DOUBLE:\r\n      return reader.double();\r\n    case ScalarType.FLOAT:\r\n      return reader.float();\r\n    case ScalarType.INT32:\r\n      return reader.int32();\r\n    case ScalarType.INT64:\r\n      return reader.int64();\r\n    case ScalarType.UINT64:\r\n      return reader.uint64();\r\n    case ScalarType.FIXED64:\r\n      return reader.fixed64();\r\n    case ScalarType.BYTES:\r\n      return reader.bytes();\r\n    case ScalarType.FIXED32:\r\n      return reader.fixed32();\r\n    case ScalarType.SFIXED32:\r\n      return reader.sfixed32();\r\n    case ScalarType.SFIXED64:\r\n      return reader.sfixed64();\r\n    case ScalarType.SINT64:\r\n      return reader.sint64();\r\n    case ScalarType.UINT32:\r\n      return reader.uint32();\r\n    case ScalarType.SINT32:\r\n      return reader.sint32();\r\n  }\r\n}\r\nfunction writeField(field, value, writer, options) {\r\n  assert(value !== undefined);\r\n  const repeated = field.repeated;\r\n  switch (field.kind) {\r\n    case \"scalar\":\r\n    case \"enum\":\r\n      let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\r\n      if (repeated) {\r\n        assert(Array.isArray(value));\r\n        if (field.packed) {\r\n          writePacked(writer, scalarType, field.no, value);\r\n        } else {\r\n          for (const item of value) {\r\n            writeScalar(writer, scalarType, field.no, item);\r\n          }\r\n        }\r\n      } else {\r\n        writeScalar(writer, scalarType, field.no, value);\r\n      }\r\n      break;\r\n    case \"message\":\r\n      if (repeated) {\r\n        assert(Array.isArray(value));\r\n        for (const item of value) {\r\n          writeMessageField(writer, options, field, item);\r\n        }\r\n      } else {\r\n        writeMessageField(writer, options, field, value);\r\n      }\r\n      break;\r\n    case \"map\":\r\n      assert(typeof value == \"object\" && value != null);\r\n      for (const [key, val] of Object.entries(value)) {\r\n        writeMapEntry(writer, options, field, key, val);\r\n      }\r\n      break;\r\n  }\r\n}\r\nfunction writeMapEntry(writer, options, field, key, value) {\r\n  writer.tag(field.no, WireType.LengthDelimited);\r\n  writer.fork();\r\n  // javascript only allows number or string for object properties\r\n  // we convert from our representation to the protobuf type\r\n  let keyValue = key;\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\r\n  switch (field.K) {\r\n    case ScalarType.INT32:\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.UINT32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.SINT32:\r\n      keyValue = Number.parseInt(key);\r\n      break;\r\n    case ScalarType.BOOL:\r\n      assert(key == \"true\" || key == \"false\");\r\n      keyValue = key == \"true\";\r\n      break;\r\n  }\r\n  // write key, expecting key field number = 1\r\n  writeScalar(writer, field.K, 1, keyValue);\r\n  // write value, expecting value field number = 2\r\n  switch (field.V.kind) {\r\n    case \"scalar\":\r\n      writeScalar(writer, field.V.T, 2, value);\r\n      break;\r\n    case \"enum\":\r\n      writeScalar(writer, ScalarType.INT32, 2, value);\r\n      break;\r\n    case \"message\":\r\n      assert(value !== undefined);\r\n      writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\r\n      break;\r\n  }\r\n  writer.join();\r\n}\r\n// Value must not be undefined\r\nfunction writeMessageField(writer, options, field, value) {\r\n  const message = wrapField(field.T, value);\r\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\r\n  if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\r\n}\r\nfunction writeScalar(writer, type, fieldNo, value) {\r\n  assert(value !== undefined);\r\n  let [wireType, method] = scalarTypeInfo(type);\r\n  writer.tag(fieldNo, wireType)[method](value);\r\n}\r\nfunction writePacked(writer, type, fieldNo, value) {\r\n  if (!value.length) {\r\n    return;\r\n  }\r\n  writer.tag(fieldNo, WireType.LengthDelimited).fork();\r\n  let [, method] = scalarTypeInfo(type);\r\n  for (let i = 0; i < value.length; i++) {\r\n    writer[method](value[i]);\r\n  }\r\n  writer.join();\r\n}\r\n/**\r\n * Get information for writing a scalar value.\r\n *\r\n * Returns tuple:\r\n * [0]: appropriate WireType\r\n * [1]: name of the appropriate method of IBinaryWriter\r\n * [2]: whether the given value is a default value for proto3 semantics\r\n *\r\n * If argument `value` is omitted, [2] is always false.\r\n */\r\n// TODO replace call-sites writeScalar() and writePacked(), then remove\r\nfunction scalarTypeInfo(type) {\r\n  let wireType = WireType.Varint;\r\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\r\n  switch (type) {\r\n    case ScalarType.BYTES:\r\n    case ScalarType.STRING:\r\n      wireType = WireType.LengthDelimited;\r\n      break;\r\n    case ScalarType.DOUBLE:\r\n    case ScalarType.FIXED64:\r\n    case ScalarType.SFIXED64:\r\n      wireType = WireType.Bit64;\r\n      break;\r\n    case ScalarType.FIXED32:\r\n    case ScalarType.SFIXED32:\r\n    case ScalarType.FLOAT:\r\n      wireType = WireType.Bit32;\r\n      break;\r\n  }\r\n  const method = ScalarType[type].toLowerCase();\r\n  return [wireType, method];\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */\r\nfunction makeUtilCommon() {\r\n  return {\r\n    setEnumType,\r\n    initPartial(source, target) {\r\n      if (source === undefined) {\r\n        return;\r\n      }\r\n      const type = target.getType();\r\n      for (const member of type.fields.byMember()) {\r\n        const localName = member.localName,\r\n          t = target,\r\n          s = source;\r\n        if (s[localName] == null) {\r\n          // TODO if source is a Message instance, we should use isFieldSet() here to support future field presence\r\n          continue;\r\n        }\r\n        switch (member.kind) {\r\n          case \"oneof\":\r\n            const sk = s[localName].case;\r\n            if (sk === undefined) {\r\n              continue;\r\n            }\r\n            const sourceField = member.findField(sk);\r\n            let val = s[localName].value;\r\n            if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\r\n              val = new sourceField.T(val);\r\n            } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\r\n              val = toU8Arr(val);\r\n            }\r\n            t[localName] = {\r\n              case: sk,\r\n              value: val\r\n            };\r\n            break;\r\n          case \"scalar\":\r\n          case \"enum\":\r\n            let copy = s[localName];\r\n            if (member.T === ScalarType.BYTES) {\r\n              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\r\n            }\r\n            t[localName] = copy;\r\n            break;\r\n          case \"map\":\r\n            switch (member.V.kind) {\r\n              case \"scalar\":\r\n              case \"enum\":\r\n                if (member.V.T === ScalarType.BYTES) {\r\n                  for (const [k, v] of Object.entries(s[localName])) {\r\n                    t[localName][k] = toU8Arr(v);\r\n                  }\r\n                } else {\r\n                  Object.assign(t[localName], s[localName]);\r\n                }\r\n                break;\r\n              case \"message\":\r\n                const messageType = member.V.T;\r\n                for (const k of Object.keys(s[localName])) {\r\n                  let val = s[localName][k];\r\n                  if (!messageType.fieldWrapper) {\r\n                    // We only take partial input for messages that are not a wrapper type.\r\n                    // For those messages, we recursively normalize the partial input.\r\n                    val = new messageType(val);\r\n                  }\r\n                  t[localName][k] = val;\r\n                }\r\n                break;\r\n            }\r\n            break;\r\n          case \"message\":\r\n            const mt = member.T;\r\n            if (member.repeated) {\r\n              t[localName] = s[localName].map(val => isMessage(val, mt) ? val : new mt(val));\r\n            } else {\r\n              const val = s[localName];\r\n              if (mt.fieldWrapper) {\r\n                if (\r\n                // We can't use BytesValue.typeName as that will create a circular import\r\n                mt.typeName === \"google.protobuf.BytesValue\") {\r\n                  t[localName] = toU8Arr(val);\r\n                } else {\r\n                  t[localName] = val;\r\n                }\r\n              } else {\r\n                t[localName] = isMessage(val, mt) ? val : new mt(val);\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      }\r\n    },\r\n    // TODO use isFieldSet() here to support future field presence\r\n    equals(type, a, b) {\r\n      if (a === b) {\r\n        return true;\r\n      }\r\n      if (!a || !b) {\r\n        return false;\r\n      }\r\n      return type.fields.byMember().every(m => {\r\n        const va = a[m.localName];\r\n        const vb = b[m.localName];\r\n        if (m.repeated) {\r\n          if (va.length !== vb.length) {\r\n            return false;\r\n          }\r\n          // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\r\n          switch (m.kind) {\r\n            case \"message\":\r\n              return va.every((a, i) => m.T.equals(a, vb[i]));\r\n            case \"scalar\":\r\n              return va.every((a, i) => scalarEquals(m.T, a, vb[i]));\r\n            case \"enum\":\r\n              return va.every((a, i) => scalarEquals(ScalarType.INT32, a, vb[i]));\r\n          }\r\n          throw new Error(\"repeated cannot contain \".concat(m.kind));\r\n        }\r\n        switch (m.kind) {\r\n          case \"message\":\r\n            let a = va;\r\n            let b = vb;\r\n            if (m.T.fieldWrapper) {\r\n              if (a !== undefined && !isMessage(a)) {\r\n                a = m.T.fieldWrapper.wrapField(a);\r\n              }\r\n              if (b !== undefined && !isMessage(b)) {\r\n                b = m.T.fieldWrapper.wrapField(b);\r\n              }\r\n            }\r\n            return m.T.equals(a, b);\r\n          case \"enum\":\r\n            return scalarEquals(ScalarType.INT32, va, vb);\r\n          case \"scalar\":\r\n            return scalarEquals(m.T, va, vb);\r\n          case \"oneof\":\r\n            if (va.case !== vb.case) {\r\n              return false;\r\n            }\r\n            const s = m.findField(va.case);\r\n            if (s === undefined) {\r\n              return true;\r\n            }\r\n            // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\r\n            switch (s.kind) {\r\n              case \"message\":\r\n                return s.T.equals(va.value, vb.value);\r\n              case \"enum\":\r\n                return scalarEquals(ScalarType.INT32, va.value, vb.value);\r\n              case \"scalar\":\r\n                return scalarEquals(s.T, va.value, vb.value);\r\n            }\r\n            throw new Error(\"oneof cannot contain \".concat(s.kind));\r\n          case \"map\":\r\n            const keys = Object.keys(va).concat(Object.keys(vb));\r\n            switch (m.V.kind) {\r\n              case \"message\":\r\n                const messageType = m.V.T;\r\n                return keys.every(k => messageType.equals(va[k], vb[k]));\r\n              case \"enum\":\r\n                return keys.every(k => scalarEquals(ScalarType.INT32, va[k], vb[k]));\r\n              case \"scalar\":\r\n                const scalarType = m.V.T;\r\n                return keys.every(k => scalarEquals(scalarType, va[k], vb[k]));\r\n            }\r\n            break;\r\n        }\r\n      });\r\n    },\r\n    // TODO use isFieldSet() here to support future field presence\r\n    clone(message) {\r\n      const type = message.getType(),\r\n        target = new type(),\r\n        any = target;\r\n      for (const member of type.fields.byMember()) {\r\n        const source = message[member.localName];\r\n        let copy;\r\n        if (member.repeated) {\r\n          copy = source.map(cloneSingularField);\r\n        } else if (member.kind == \"map\") {\r\n          copy = any[member.localName];\r\n          for (const [key, v] of Object.entries(source)) {\r\n            copy[key] = cloneSingularField(v);\r\n          }\r\n        } else if (member.kind == \"oneof\") {\r\n          const f = member.findField(source.case);\r\n          copy = f ? {\r\n            case: source.case,\r\n            value: cloneSingularField(source.value)\r\n          } : {\r\n            case: undefined\r\n          };\r\n        } else {\r\n          copy = cloneSingularField(source);\r\n        }\r\n        any[member.localName] = copy;\r\n      }\r\n      for (const uf of type.runtime.bin.listUnknownFields(message)) {\r\n        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\r\n      }\r\n      return target;\r\n    }\r\n  };\r\n}\r\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\r\nfunction cloneSingularField(value) {\r\n  if (value === undefined) {\r\n    return value;\r\n  }\r\n  if (isMessage(value)) {\r\n    return value.clone();\r\n  }\r\n  if (value instanceof Uint8Array) {\r\n    const c = new Uint8Array(value.byteLength);\r\n    c.set(value);\r\n    return c;\r\n  }\r\n  return value;\r\n}\r\n// converts any ArrayLike<number> to Uint8Array if necessary.\r\nfunction toU8Arr(input) {\r\n  return input instanceof Uint8Array ? input : new Uint8Array(input);\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\r\n  return {\r\n    syntax,\r\n    json: makeJsonFormat(),\r\n    bin: makeBinaryFormat(),\r\n    util: Object.assign(Object.assign({}, makeUtilCommon()), {\r\n      newFieldList,\r\n      initFields\r\n    }),\r\n    makeMessageType(typeName, fields, opt) {\r\n      return makeMessageType(this, typeName, fields, opt);\r\n    },\r\n    makeEnum,\r\n    makeEnumType,\r\n    getEnumType,\r\n    makeExtension(typeName, extendee, field) {\r\n      return makeExtension(this, typeName, extendee, field);\r\n    }\r\n  };\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nclass InternalFieldList {\r\n  constructor(fields, normalizer) {\r\n    this._fields = fields;\r\n    this._normalizer = normalizer;\r\n  }\r\n  findJsonName(jsonName) {\r\n    if (!this.jsonNames) {\r\n      const t = {};\r\n      for (const f of this.list()) {\r\n        t[f.jsonName] = t[f.name] = f;\r\n      }\r\n      this.jsonNames = t;\r\n    }\r\n    return this.jsonNames[jsonName];\r\n  }\r\n  find(fieldNo) {\r\n    if (!this.numbers) {\r\n      const t = {};\r\n      for (const f of this.list()) {\r\n        t[f.no] = f;\r\n      }\r\n      this.numbers = t;\r\n    }\r\n    return this.numbers[fieldNo];\r\n  }\r\n  list() {\r\n    if (!this.all) {\r\n      this.all = this._normalizer(this._fields);\r\n    }\r\n    return this.all;\r\n  }\r\n  byNumber() {\r\n    if (!this.numbersAsc) {\r\n      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);\r\n    }\r\n    return this.numbersAsc;\r\n  }\r\n  byMember() {\r\n    if (!this.members) {\r\n      this.members = [];\r\n      const a = this.members;\r\n      let o;\r\n      for (const f of this.list()) {\r\n        if (f.oneof) {\r\n          if (f.oneof !== o) {\r\n            o = f.oneof;\r\n            a.push(o);\r\n          }\r\n        } else {\r\n          a.push(f);\r\n        }\r\n      }\r\n    }\r\n    return this.members;\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Returns the name of a protobuf element in generated code.\r\n *\r\n * Field names - including oneofs - are converted to lowerCamelCase. For\r\n * messages, enumerations and services, the package name is stripped from\r\n * the type name. For nested messages and enumerations, the names are joined\r\n * with an underscore. For methods, the first character is made lowercase.\r\n */\r\n/**\r\n * Returns the name of a field in generated code.\r\n */\r\nfunction localFieldName(protoName, inOneof) {\r\n  const name = protoCamelCase(protoName);\r\n  if (inOneof) {\r\n    // oneof member names are not properties, but values of the `case` property.\r\n    return name;\r\n  }\r\n  return safeObjectProperty(safeMessageProperty(name));\r\n}\r\n/**\r\n * Returns the name of a oneof group in generated code.\r\n */\r\nfunction localOneofName(protoName) {\r\n  return localFieldName(protoName, false);\r\n}\r\n/**\r\n * Returns the JSON name for a protobuf field, exactly like protoc does.\r\n */\r\nconst fieldJsonName = protoCamelCase;\r\n/**\r\n * Converts snake_case to protoCamelCase according to the convention\r\n * used by protoc to convert a field name to a JSON name.\r\n */\r\nfunction protoCamelCase(snakeCase) {\r\n  let capNext = false;\r\n  const b = [];\r\n  for (let i = 0; i < snakeCase.length; i++) {\r\n    let c = snakeCase.charAt(i);\r\n    switch (c) {\r\n      case \"_\":\r\n        capNext = true;\r\n        break;\r\n      case \"0\":\r\n      case \"1\":\r\n      case \"2\":\r\n      case \"3\":\r\n      case \"4\":\r\n      case \"5\":\r\n      case \"6\":\r\n      case \"7\":\r\n      case \"8\":\r\n      case \"9\":\r\n        b.push(c);\r\n        capNext = false;\r\n        break;\r\n      default:\r\n        if (capNext) {\r\n          capNext = false;\r\n          c = c.toUpperCase();\r\n        }\r\n        b.push(c);\r\n        break;\r\n    }\r\n  }\r\n  return b.join(\"\");\r\n}\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by built-in JavaScript properties.\r\n */\r\nconst reservedObjectProperties = new Set([\r\n// names reserved by JavaScript\r\n\"constructor\", \"toString\", \"toJSON\", \"valueOf\"]);\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by the runtime.\r\n */\r\nconst reservedMessageProperties = new Set([\r\n// names reserved by the runtime\r\n\"getType\", \"clone\", \"equals\", \"fromBinary\", \"fromJson\", \"fromJsonString\", \"toBinary\", \"toJson\", \"toJsonString\",\r\n// names reserved by the runtime for the future\r\n\"toObject\"]);\r\nconst fallback = name => \"\".concat(name, \"$\");\r\n/**\r\n * Will wrap names that are Object prototype properties or names reserved\r\n * for `Message`s.\r\n */\r\nconst safeMessageProperty = name => {\r\n  if (reservedMessageProperties.has(name)) {\r\n    return fallback(name);\r\n  }\r\n  return name;\r\n};\r\n/**\r\n * Names that cannot be used for object properties because they are reserved\r\n * by built-in JavaScript properties.\r\n */\r\nconst safeObjectProperty = name => {\r\n  if (reservedObjectProperties.has(name)) {\r\n    return fallback(name);\r\n  }\r\n  return name;\r\n};\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nclass InternalOneofInfo {\r\n  constructor(name) {\r\n    this.kind = \"oneof\";\r\n    this.repeated = false;\r\n    this.packed = false;\r\n    this.opt = false;\r\n    this.req = false;\r\n    this.default = undefined;\r\n    this.fields = [];\r\n    this.name = name;\r\n    this.localName = localOneofName(name);\r\n  }\r\n  addField(field) {\r\n    assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\r\n    this.fields.push(field);\r\n  }\r\n  findField(localName) {\r\n    if (!this._lookup) {\r\n      this._lookup = Object.create(null);\r\n      for (let i = 0; i < this.fields.length; i++) {\r\n        this._lookup[this.fields[i].localName] = this.fields[i];\r\n      }\r\n    }\r\n    return this._lookup[localName];\r\n  }\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Convert a collection of field info to an array of normalized FieldInfo.\r\n *\r\n * The argument `packedByDefault` specifies whether fields that do not specify\r\n * `packed` should be packed (proto3) or unpacked (proto2).\r\n */\r\nfunction normalizeFieldInfos(fieldInfos, packedByDefault) {\r\n  var _a, _b, _c, _d, _e, _f;\r\n  const r = [];\r\n  let o;\r\n  for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos) {\r\n    const f = field;\r\n    f.localName = localFieldName(field.name, field.oneof !== undefined);\r\n    f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\r\n    f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\r\n    if (field.kind == \"scalar\") {\r\n      f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\r\n    }\r\n    f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\r\n    f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\r\n    f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\r\n    if (field.packed === undefined) {\r\n      {\r\n        f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\r\n      }\r\n    }\r\n    // We do not surface options at this time\r\n    // f.options = field.options ?? emptyReadonlyObject;\r\n    if (field.oneof !== undefined) {\r\n      const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\r\n      if (!o || o.name != ooname) {\r\n        o = new InternalOneofInfo(ooname);\r\n      }\r\n      f.oneof = o;\r\n      o.addField(f);\r\n    }\r\n    r.push(f);\r\n  }\r\n  return r;\r\n}\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * Provides functionality for messages defined with the proto3 syntax.\r\n */\r\nconst proto3 = makeProtoRuntime(\"proto3\", fields => {\r\n  return new InternalFieldList(fields, source => normalizeFieldInfos(source));\r\n},\r\n// TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\r\ntarget => {\r\n  for (const member of target.getType().fields.byMember()) {\r\n    if (member.opt) {\r\n      continue;\r\n    }\r\n    const name = member.localName,\r\n      t = target;\r\n    if (member.repeated) {\r\n      t[name] = [];\r\n      continue;\r\n    }\r\n    switch (member.kind) {\r\n      case \"oneof\":\r\n        t[name] = {\r\n          case: undefined\r\n        };\r\n        break;\r\n      case \"enum\":\r\n        t[name] = 0;\r\n        break;\r\n      case \"map\":\r\n        t[name] = {};\r\n        break;\r\n      case \"scalar\":\r\n        t[name] = scalarZeroValue(member.T, member.L);\r\n        break;\r\n    }\r\n  }\r\n});\r\n\r\n// Copyright 2021-2024 Buf Technologies, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n/**\r\n * A Timestamp represents a point in time independent of any time zone or local\r\n * calendar, encoded as a count of seconds and fractions of seconds at\r\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\r\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\r\n * Gregorian calendar backwards to year one.\r\n *\r\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\r\n * second table is needed for interpretation, using a [24-hour linear\r\n * smear](https://developers.google.com/time/smear).\r\n *\r\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\r\n * restricting to that range, we ensure that we can convert to and from [RFC\r\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\r\n *\r\n * # Examples\r\n *\r\n * Example 1: Compute Timestamp from POSIX `time()`.\r\n *\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds(time(NULL));\r\n *     timestamp.set_nanos(0);\r\n *\r\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\r\n *\r\n *     struct timeval tv;\r\n *     gettimeofday(&tv, NULL);\r\n *\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds(tv.tv_sec);\r\n *     timestamp.set_nanos(tv.tv_usec * 1000);\r\n *\r\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\r\n *\r\n *     FILETIME ft;\r\n *     GetSystemTimeAsFileTime(&ft);\r\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\r\n *\r\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\r\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\r\n *     Timestamp timestamp;\r\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\r\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\r\n *\r\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\r\n *\r\n *     long millis = System.currentTimeMillis();\r\n *\r\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\r\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\r\n *\r\n * Example 5: Compute Timestamp from Java `Instant.now()`.\r\n *\r\n *     Instant now = Instant.now();\r\n *\r\n *     Timestamp timestamp =\r\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\r\n *             .setNanos(now.getNano()).build();\r\n *\r\n * Example 6: Compute Timestamp from current time in Python.\r\n *\r\n *     timestamp = Timestamp()\r\n *     timestamp.GetCurrentTime()\r\n *\r\n * # JSON Mapping\r\n *\r\n * In JSON format, the Timestamp type is encoded as a string in the\r\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\r\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\r\n * where {year} is always expressed using four digits while {month}, {day},\r\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\r\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\r\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\r\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\r\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\r\n * able to accept both UTC and other timezones (as indicated by an offset).\r\n *\r\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\r\n * 01:30 UTC on January 15, 2017.\r\n *\r\n * In JavaScript, one can convert a Date object to this format using the\r\n * standard\r\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\r\n * method. In Python, a standard `datetime.datetime` object can be converted\r\n * to this format using\r\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\r\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\r\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\r\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\r\n * ) to obtain a formatter capable of generating timestamps in this format.\r\n *\r\n *\r\n * @generated from message google.protobuf.Timestamp\r\n */\r\nclass Timestamp extends Message {\r\n  constructor(data) {\r\n    super();\r\n    /**\r\n     * Represents seconds of UTC time since Unix epoch\r\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     * 9999-12-31T23:59:59Z inclusive.\r\n     *\r\n     * @generated from field: int64 seconds = 1;\r\n     */\r\n    this.seconds = protoInt64.zero;\r\n    /**\r\n     * Non-negative fractions of a second at nanosecond resolution. Negative\r\n     * second values with fractions must still have non-negative nanos values\r\n     * that count forward in time. Must be from 0 to 999,999,999\r\n     * inclusive.\r\n     *\r\n     * @generated from field: int32 nanos = 2;\r\n     */\r\n    this.nanos = 0;\r\n    proto3.util.initPartial(data, this);\r\n  }\r\n  fromJson(json, options) {\r\n    if (typeof json !== \"string\") {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\r\n    }\r\n    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\r\n    if (!matches) {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\r\n    }\r\n    const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\r\n    if (Number.isNaN(ms)) {\r\n      throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\r\n    }\r\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\r\n      throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\r\n    }\r\n    this.seconds = protoInt64.parse(ms / 1000);\r\n    this.nanos = 0;\r\n    if (matches[7]) {\r\n      this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\r\n    }\r\n    return this;\r\n  }\r\n  toJson(options) {\r\n    const ms = Number(this.seconds) * 1000;\r\n    if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\r\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\r\n    }\r\n    if (this.nanos < 0) {\r\n      throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\r\n    }\r\n    let z = \"Z\";\r\n    if (this.nanos > 0) {\r\n      const nanosStr = (this.nanos + 1000000000).toString().substring(1);\r\n      if (nanosStr.substring(3) === \"000000\") {\r\n        z = \".\" + nanosStr.substring(0, 3) + \"Z\";\r\n      } else if (nanosStr.substring(6) === \"000\") {\r\n        z = \".\" + nanosStr.substring(0, 6) + \"Z\";\r\n      } else {\r\n        z = \".\" + nanosStr + \"Z\";\r\n      }\r\n    }\r\n    return new Date(ms).toISOString().replace(\".000Z\", z);\r\n  }\r\n  toDate() {\r\n    return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\r\n  }\r\n  static now() {\r\n    return Timestamp.fromDate(new Date());\r\n  }\r\n  static fromDate(date) {\r\n    const ms = date.getTime();\r\n    return new Timestamp({\r\n      seconds: protoInt64.parse(Math.floor(ms / 1000)),\r\n      nanos: ms % 1000 * 1000000\r\n    });\r\n  }\r\n  static fromBinary(bytes, options) {\r\n    return new Timestamp().fromBinary(bytes, options);\r\n  }\r\n  static fromJson(jsonValue, options) {\r\n    return new Timestamp().fromJson(jsonValue, options);\r\n  }\r\n  static fromJsonString(jsonString, options) {\r\n    return new Timestamp().fromJsonString(jsonString, options);\r\n  }\r\n  static equals(a, b) {\r\n    return proto3.util.equals(Timestamp, a, b);\r\n  }\r\n}\r\nTimestamp.runtime = proto3;\r\nTimestamp.typeName = \"google.protobuf.Timestamp\";\r\nTimestamp.fields = proto3.util.newFieldList(() => [{\r\n  no: 1,\r\n  name: \"seconds\",\r\n  kind: \"scalar\",\r\n  T: 3 /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"nanos\",\r\n  kind: \"scalar\",\r\n  T: 5 /* ScalarType.INT32 */\r\n}]);\r\n\r\nconst MetricsBatch = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricsBatch\", () => [{\r\n  no: 1,\r\n  name: \"timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"normalized_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 3,\r\n  name: \"str_data\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"time_series\",\r\n  kind: \"message\",\r\n  T: TimeSeriesMetric,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"events\",\r\n  kind: \"message\",\r\n  T: EventMetric,\r\n  repeated: true\r\n}]);\r\nconst TimeSeriesMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimeSeriesMetric\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"samples\",\r\n  kind: \"message\",\r\n  T: MetricSample,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"rid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst MetricSample = /* @__PURE__ */proto3.makeMessageType(\"livekit.MetricSample\", () => [{\r\n  no: 1,\r\n  name: \"timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"normalized_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 3,\r\n  name: \"value\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}]);\r\nconst EventMetric = /* @__PURE__ */proto3.makeMessageType(\"livekit.EventMetric\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"start_timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 5,\r\n  name: \"end_timestamp_ms\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  opt: true\r\n}, {\r\n  no: 6,\r\n  name: \"normalized_start_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp\r\n}, {\r\n  no: 7,\r\n  name: \"normalized_end_timestamp\",\r\n  kind: \"message\",\r\n  T: Timestamp,\r\n  opt: true\r\n}, {\r\n  no: 8,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"rid\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst BackupCodecPolicy$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.BackupCodecPolicy\", [{\r\n  no: 0,\r\n  name: \"PREFER_REGRESSION\"\r\n}, {\r\n  no: 1,\r\n  name: \"SIMULCAST\"\r\n}, {\r\n  no: 2,\r\n  name: \"REGRESSION\"\r\n}]);\r\nconst TrackType = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackType\", [{\r\n  no: 0,\r\n  name: \"AUDIO\"\r\n}, {\r\n  no: 1,\r\n  name: \"VIDEO\"\r\n}, {\r\n  no: 2,\r\n  name: \"DATA\"\r\n}]);\r\nconst TrackSource = /* @__PURE__ */proto3.makeEnum(\"livekit.TrackSource\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"CAMERA\"\r\n}, {\r\n  no: 2,\r\n  name: \"MICROPHONE\"\r\n}, {\r\n  no: 3,\r\n  name: \"SCREEN_SHARE\"\r\n}, {\r\n  no: 4,\r\n  name: \"SCREEN_SHARE_AUDIO\"\r\n}]);\r\nconst VideoQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.VideoQuality\", [{\r\n  no: 0,\r\n  name: \"LOW\"\r\n}, {\r\n  no: 1,\r\n  name: \"MEDIUM\"\r\n}, {\r\n  no: 2,\r\n  name: \"HIGH\"\r\n}, {\r\n  no: 3,\r\n  name: \"OFF\"\r\n}]);\r\nconst ConnectionQuality$1 = /* @__PURE__ */proto3.makeEnum(\"livekit.ConnectionQuality\", [{\r\n  no: 0,\r\n  name: \"POOR\"\r\n}, {\r\n  no: 1,\r\n  name: \"GOOD\"\r\n}, {\r\n  no: 2,\r\n  name: \"EXCELLENT\"\r\n}, {\r\n  no: 3,\r\n  name: \"LOST\"\r\n}]);\r\nconst ClientConfigSetting = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientConfigSetting\", [{\r\n  no: 0,\r\n  name: \"UNSET\"\r\n}, {\r\n  no: 1,\r\n  name: \"DISABLED\"\r\n}, {\r\n  no: 2,\r\n  name: \"ENABLED\"\r\n}]);\r\nconst DisconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.DisconnectReason\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN_REASON\"\r\n}, {\r\n  no: 1,\r\n  name: \"CLIENT_INITIATED\"\r\n}, {\r\n  no: 2,\r\n  name: \"DUPLICATE_IDENTITY\"\r\n}, {\r\n  no: 3,\r\n  name: \"SERVER_SHUTDOWN\"\r\n}, {\r\n  no: 4,\r\n  name: \"PARTICIPANT_REMOVED\"\r\n}, {\r\n  no: 5,\r\n  name: \"ROOM_DELETED\"\r\n}, {\r\n  no: 6,\r\n  name: \"STATE_MISMATCH\"\r\n}, {\r\n  no: 7,\r\n  name: \"JOIN_FAILURE\"\r\n}, {\r\n  no: 8,\r\n  name: \"MIGRATION\"\r\n}, {\r\n  no: 9,\r\n  name: \"SIGNAL_CLOSE\"\r\n}, {\r\n  no: 10,\r\n  name: \"ROOM_CLOSED\"\r\n}, {\r\n  no: 11,\r\n  name: \"USER_UNAVAILABLE\"\r\n}, {\r\n  no: 12,\r\n  name: \"USER_REJECTED\"\r\n}, {\r\n  no: 13,\r\n  name: \"SIP_TRUNK_FAILURE\"\r\n}, {\r\n  no: 14,\r\n  name: \"CONNECTION_TIMEOUT\"\r\n}, {\r\n  no: 15,\r\n  name: \"MEDIA_FAILURE\"\r\n}]);\r\nconst ReconnectReason = /* @__PURE__ */proto3.makeEnum(\"livekit.ReconnectReason\", [{\r\n  no: 0,\r\n  name: \"RR_UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"RR_SIGNAL_DISCONNECTED\"\r\n}, {\r\n  no: 2,\r\n  name: \"RR_PUBLISHER_FAILED\"\r\n}, {\r\n  no: 3,\r\n  name: \"RR_SUBSCRIBER_FAILED\"\r\n}, {\r\n  no: 4,\r\n  name: \"RR_SWITCH_CANDIDATE\"\r\n}]);\r\nconst SubscriptionError = /* @__PURE__ */proto3.makeEnum(\"livekit.SubscriptionError\", [{\r\n  no: 0,\r\n  name: \"SE_UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"SE_CODEC_UNSUPPORTED\"\r\n}, {\r\n  no: 2,\r\n  name: \"SE_TRACK_NOTFOUND\"\r\n}]);\r\nconst AudioTrackFeature = /* @__PURE__ */proto3.makeEnum(\"livekit.AudioTrackFeature\", [{\r\n  no: 0,\r\n  name: \"TF_STEREO\"\r\n}, {\r\n  no: 1,\r\n  name: \"TF_NO_DTX\"\r\n}, {\r\n  no: 2,\r\n  name: \"TF_AUTO_GAIN_CONTROL\"\r\n}, {\r\n  no: 3,\r\n  name: \"TF_ECHO_CANCELLATION\"\r\n}, {\r\n  no: 4,\r\n  name: \"TF_NOISE_SUPPRESSION\"\r\n}, {\r\n  no: 5,\r\n  name: \"TF_ENHANCED_NOISE_CANCELLATION\"\r\n}, {\r\n  no: 6,\r\n  name: \"TF_PRECONNECT_BUFFER\"\r\n}]);\r\nconst Room$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.Room\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"empty_timeout\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 14,\r\n  name: \"departure_timeout\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"max_participants\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"creation_time\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 15,\r\n  name: \"creation_time_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 6,\r\n  name: \"turn_password\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"enabled_codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 8,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"num_participants\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"num_publishers\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 10,\r\n  name: \"active_recording\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 13,\r\n  name: \"version\",\r\n  kind: \"message\",\r\n  T: TimedVersion\r\n}]);\r\nconst Codec = /* @__PURE__ */proto3.makeMessageType(\"livekit.Codec\", () => [{\r\n  no: 1,\r\n  name: \"mime\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"fmtp_line\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantPermission\", () => [{\r\n  no: 1,\r\n  name: \"can_subscribe\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"can_publish\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"can_publish_data\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 9,\r\n  name: \"can_publish_sources\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource),\r\n  repeated: true\r\n}, {\r\n  no: 7,\r\n  name: \"hidden\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"recorder\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 10,\r\n  name: \"can_update_metadata\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 11,\r\n  name: \"agent\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 12,\r\n  name: \"can_subscribe_metrics\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst ParticipantInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"state\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_State)\r\n}, {\r\n  no: 4,\r\n  name: \"tracks\",\r\n  kind: \"message\",\r\n  T: TrackInfo,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"joined_at\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 17,\r\n  name: \"joined_at_ms\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 9,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"permission\",\r\n  kind: \"message\",\r\n  T: ParticipantPermission\r\n}, {\r\n  no: 12,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 13,\r\n  name: \"is_publisher\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 14,\r\n  name: \"kind\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_Kind)\r\n}, {\r\n  no: 15,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 16,\r\n  name: \"disconnect_reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DisconnectReason)\r\n}, {\r\n  no: 18,\r\n  name: \"kind_details\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ParticipantInfo_KindDetail),\r\n  repeated: true\r\n}]);\r\nconst ParticipantInfo_State = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.State\", [{\r\n  no: 0,\r\n  name: \"JOINING\"\r\n}, {\r\n  no: 1,\r\n  name: \"JOINED\"\r\n}, {\r\n  no: 2,\r\n  name: \"ACTIVE\"\r\n}, {\r\n  no: 3,\r\n  name: \"DISCONNECTED\"\r\n}]);\r\nconst ParticipantInfo_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [{\r\n  no: 0,\r\n  name: \"STANDARD\"\r\n}, {\r\n  no: 1,\r\n  name: \"INGRESS\"\r\n}, {\r\n  no: 2,\r\n  name: \"EGRESS\"\r\n}, {\r\n  no: 3,\r\n  name: \"SIP\"\r\n}, {\r\n  no: 4,\r\n  name: \"AGENT\"\r\n}]);\r\nconst ParticipantInfo_KindDetail = /* @__PURE__ */proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [{\r\n  no: 0,\r\n  name: \"CLOUD_AGENT\"\r\n}, {\r\n  no: 1,\r\n  name: \"FORWARDED\"\r\n}]);\r\nconst Encryption_Type = /* @__PURE__ */proto3.makeEnum(\"livekit.Encryption.Type\", [{\r\n  no: 0,\r\n  name: \"NONE\"\r\n}, {\r\n  no: 1,\r\n  name: \"GCM\"\r\n}, {\r\n  no: 2,\r\n  name: \"CUSTOM\"\r\n}]);\r\nconst SimulcastCodecInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", () => [{\r\n  no: 1,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"mid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}]);\r\nconst TrackInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackType)\r\n}, {\r\n  no: 3,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 5,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 7,\r\n  name: \"simulcast\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"disable_dtx\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 9,\r\n  name: \"source\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource)\r\n}, {\r\n  no: 10,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}, {\r\n  no: 11,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 12,\r\n  name: \"mid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 13,\r\n  name: \"codecs\",\r\n  kind: \"message\",\r\n  T: SimulcastCodecInfo,\r\n  repeated: true\r\n}, {\r\n  no: 14,\r\n  name: \"stereo\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 15,\r\n  name: \"disable_red\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 16,\r\n  name: \"encryption\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 17,\r\n  name: \"stream\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 18,\r\n  name: \"version\",\r\n  kind: \"message\",\r\n  T: TimedVersion\r\n}, {\r\n  no: 19,\r\n  name: \"audio_features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}, {\r\n  no: 20,\r\n  name: \"backup_codec_policy\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(BackupCodecPolicy$1)\r\n}]);\r\nconst VideoLayer = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoLayer\", () => [{\r\n  no: 1,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 2,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"bitrate\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"ssrc\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst DataPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataPacket\", () => [{\r\n  no: 1,\r\n  name: \"kind\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DataPacket_Kind)\r\n}, {\r\n  no: 4,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"destination_identities\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"user\",\r\n  kind: \"message\",\r\n  T: UserPacket,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 3,\r\n  name: \"speaker\",\r\n  kind: \"message\",\r\n  T: ActiveSpeakerUpdate,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 6,\r\n  name: \"sip_dtmf\",\r\n  kind: \"message\",\r\n  T: SipDTMF,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 7,\r\n  name: \"transcription\",\r\n  kind: \"message\",\r\n  T: Transcription,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 8,\r\n  name: \"metrics\",\r\n  kind: \"message\",\r\n  T: MetricsBatch,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 9,\r\n  name: \"chat_message\",\r\n  kind: \"message\",\r\n  T: ChatMessage,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 10,\r\n  name: \"rpc_request\",\r\n  kind: \"message\",\r\n  T: RpcRequest,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 11,\r\n  name: \"rpc_ack\",\r\n  kind: \"message\",\r\n  T: RpcAck,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 12,\r\n  name: \"rpc_response\",\r\n  kind: \"message\",\r\n  T: RpcResponse,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 13,\r\n  name: \"stream_header\",\r\n  kind: \"message\",\r\n  T: DataStream_Header,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 14,\r\n  name: \"stream_chunk\",\r\n  kind: \"message\",\r\n  T: DataStream_Chunk,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 15,\r\n  name: \"stream_trailer\",\r\n  kind: \"message\",\r\n  T: DataStream_Trailer,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 16,\r\n  name: \"sequence\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 17,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst DataPacket_Kind = /* @__PURE__ */proto3.makeEnum(\"livekit.DataPacket.Kind\", [{\r\n  no: 0,\r\n  name: \"RELIABLE\"\r\n}, {\r\n  no: 1,\r\n  name: \"LOSSY\"\r\n}]);\r\nconst ActiveSpeakerUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", () => [{\r\n  no: 1,\r\n  name: \"speakers\",\r\n  kind: \"message\",\r\n  T: SpeakerInfo,\r\n  repeated: true\r\n}]);\r\nconst SpeakerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakerInfo\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"level\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}, {\r\n  no: 3,\r\n  name: \"active\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst UserPacket = /* @__PURE__ */proto3.makeMessageType(\"livekit.UserPacket\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 3,\r\n  name: \"destination_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 6,\r\n  name: \"destination_identities\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"topic\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  opt: true\r\n}, {\r\n  no: 8,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  opt: true\r\n}, {\r\n  no: 9,\r\n  name: \"start_time\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 10,\r\n  name: \"end_time\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 11,\r\n  name: \"nonce\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}]);\r\nconst SipDTMF = /* @__PURE__ */proto3.makeMessageType(\"livekit.SipDTMF\", () => [{\r\n  no: 3,\r\n  name: \"code\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"digit\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst Transcription = /* @__PURE__ */proto3.makeMessageType(\"livekit.Transcription\", () => [{\r\n  no: 2,\r\n  name: \"transcribed_participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"track_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"segments\",\r\n  kind: \"message\",\r\n  T: TranscriptionSegment,\r\n  repeated: true\r\n}]);\r\nconst TranscriptionSegment = /* @__PURE__ */proto3.makeMessageType(\"livekit.TranscriptionSegment\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"text\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"start_time\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 4,\r\n  name: \"end_time\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 5,\r\n  name: \"final\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 6,\r\n  name: \"language\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ChatMessage = /* @__PURE__ */proto3.makeMessageType(\"livekit.ChatMessage\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"edit_timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  opt: true\r\n}, {\r\n  no: 4,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"deleted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 6,\r\n  name: \"generated\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst RpcRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcRequest\", () => [{\r\n  no: 1,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"method\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"response_timeout_ms\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst RpcAck = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcAck\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst RpcResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcResponse\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"payload\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  oneof: \"value\"\r\n}, {\r\n  no: 3,\r\n  name: \"error\",\r\n  kind: \"message\",\r\n  T: RpcError$1,\r\n  oneof: \"value\"\r\n}]);\r\nconst RpcError$1 = /* @__PURE__ */proto3.makeMessageType(\"livekit.RpcError\", () => [{\r\n  no: 1,\r\n  name: \"code\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"data\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantTracks = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantTracks\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}]);\r\nconst ServerInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ServerInfo\", () => [{\r\n  no: 1,\r\n  name: \"edition\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ServerInfo_Edition)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"node_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"debug_info\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"agent_protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}]);\r\nconst ServerInfo_Edition = /* @__PURE__ */proto3.makeEnum(\"livekit.ServerInfo.Edition\", [{\r\n  no: 0,\r\n  name: \"Standard\"\r\n}, {\r\n  no: 1,\r\n  name: \"Cloud\"\r\n}]);\r\nconst ClientInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientInfo\", () => [{\r\n  no: 1,\r\n  name: \"sdk\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientInfo_SDK)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"protocol\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 4,\r\n  name: \"os\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"os_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 6,\r\n  name: \"device_model\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 7,\r\n  name: \"browser\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 8,\r\n  name: \"browser_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 9,\r\n  name: \"address\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"network\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 11,\r\n  name: \"other_sdks\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ClientInfo_SDK = /* @__PURE__ */proto3.makeEnum(\"livekit.ClientInfo.SDK\", [{\r\n  no: 0,\r\n  name: \"UNKNOWN\"\r\n}, {\r\n  no: 1,\r\n  name: \"JS\"\r\n}, {\r\n  no: 2,\r\n  name: \"SWIFT\"\r\n}, {\r\n  no: 3,\r\n  name: \"ANDROID\"\r\n}, {\r\n  no: 4,\r\n  name: \"FLUTTER\"\r\n}, {\r\n  no: 5,\r\n  name: \"GO\"\r\n}, {\r\n  no: 6,\r\n  name: \"UNITY\"\r\n}, {\r\n  no: 7,\r\n  name: \"REACT_NATIVE\"\r\n}, {\r\n  no: 8,\r\n  name: \"RUST\"\r\n}, {\r\n  no: 9,\r\n  name: \"PYTHON\"\r\n}, {\r\n  no: 10,\r\n  name: \"CPP\"\r\n}, {\r\n  no: 11,\r\n  name: \"UNITY_WEB\"\r\n}, {\r\n  no: 12,\r\n  name: \"NODE\"\r\n}, {\r\n  no: 13,\r\n  name: \"UNREAL\"\r\n}]);\r\nconst ClientConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.ClientConfiguration\", () => [{\r\n  no: 1,\r\n  name: \"video\",\r\n  kind: \"message\",\r\n  T: VideoConfiguration\r\n}, {\r\n  no: 2,\r\n  name: \"screen\",\r\n  kind: \"message\",\r\n  T: VideoConfiguration\r\n}, {\r\n  no: 3,\r\n  name: \"resume_connection\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}, {\r\n  no: 4,\r\n  name: \"disabled_codecs\",\r\n  kind: \"message\",\r\n  T: DisabledCodecs\r\n}, {\r\n  no: 5,\r\n  name: \"force_relay\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}]);\r\nconst VideoConfiguration = /* @__PURE__ */proto3.makeMessageType(\"livekit.VideoConfiguration\", () => [{\r\n  no: 1,\r\n  name: \"hardware_encoder\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ClientConfigSetting)\r\n}]);\r\nconst DisabledCodecs = /* @__PURE__ */proto3.makeMessageType(\"livekit.DisabledCodecs\", () => [{\r\n  no: 1,\r\n  name: \"codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"publish\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}]);\r\nconst TimedVersion = /* @__PURE__ */proto3.makeMessageType(\"livekit.TimedVersion\", () => [{\r\n  no: 1,\r\n  name: \"unix_micro\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"ticks\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}]);\r\nconst DataStream_OperationType = /* @__PURE__ */proto3.makeEnum(\"livekit.DataStream.OperationType\", [{\r\n  no: 0,\r\n  name: \"CREATE\"\r\n}, {\r\n  no: 1,\r\n  name: \"UPDATE\"\r\n}, {\r\n  no: 2,\r\n  name: \"DELETE\"\r\n}, {\r\n  no: 3,\r\n  name: \"REACTION\"\r\n}]);\r\nconst DataStream_TextHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.TextHeader\", () => [{\r\n  no: 1,\r\n  name: \"operation_type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DataStream_OperationType)\r\n}, {\r\n  no: 2,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"reply_to_stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"attached_stream_ids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"generated\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}], {\r\n  localName: \"DataStream_TextHeader\"\r\n});\r\nconst DataStream_ByteHeader = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", () => [{\r\n  no: 1,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}], {\r\n  localName: \"DataStream_ByteHeader\"\r\n});\r\nconst DataStream_Header = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Header\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"topic\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 4,\r\n  name: \"mime_type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"total_length\",\r\n  kind: \"scalar\",\r\n  T: 4,\r\n  opt: true\r\n}, {\r\n  no: 7,\r\n  name: \"encryption_type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 8,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 9,\r\n  name: \"text_header\",\r\n  kind: \"message\",\r\n  T: DataStream_TextHeader,\r\n  oneof: \"content_header\"\r\n}, {\r\n  no: 10,\r\n  name: \"byte_header\",\r\n  kind: \"message\",\r\n  T: DataStream_ByteHeader,\r\n  oneof: \"content_header\"\r\n}], {\r\n  localName: \"DataStream_Header\"\r\n});\r\nconst DataStream_Chunk = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Chunk\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"chunk_index\",\r\n  kind: \"scalar\",\r\n  T: 4\r\n  /* ScalarType.UINT64 */\r\n}, {\r\n  no: 3,\r\n  name: \"content\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 4,\r\n  name: \"version\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"iv\",\r\n  kind: \"scalar\",\r\n  T: 12,\r\n  opt: true\r\n}], {\r\n  localName: \"DataStream_Chunk\"\r\n});\r\nconst DataStream_Trailer = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataStream.Trailer\", () => [{\r\n  no: 1,\r\n  name: \"stream_id\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}], {\r\n  localName: \"DataStream_Trailer\"\r\n});\r\nconst SignalTarget = /* @__PURE__ */proto3.makeEnum(\"livekit.SignalTarget\", [{\r\n  no: 0,\r\n  name: \"PUBLISHER\"\r\n}, {\r\n  no: 1,\r\n  name: \"SUBSCRIBER\"\r\n}]);\r\nconst StreamState = /* @__PURE__ */proto3.makeEnum(\"livekit.StreamState\", [{\r\n  no: 0,\r\n  name: \"ACTIVE\"\r\n}, {\r\n  no: 1,\r\n  name: \"PAUSED\"\r\n}]);\r\nconst CandidateProtocol = /* @__PURE__ */proto3.makeEnum(\"livekit.CandidateProtocol\", [{\r\n  no: 0,\r\n  name: \"UDP\"\r\n}, {\r\n  no: 1,\r\n  name: \"TCP\"\r\n}, {\r\n  no: 2,\r\n  name: \"TLS\"\r\n}]);\r\nconst SignalRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalRequest\", () => [{\r\n  no: 1,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 2,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 3,\r\n  name: \"trickle\",\r\n  kind: \"message\",\r\n  T: TrickleRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 4,\r\n  name: \"add_track\",\r\n  kind: \"message\",\r\n  T: AddTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 5,\r\n  name: \"mute\",\r\n  kind: \"message\",\r\n  T: MuteTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 6,\r\n  name: \"subscription\",\r\n  kind: \"message\",\r\n  T: UpdateSubscription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 7,\r\n  name: \"track_setting\",\r\n  kind: \"message\",\r\n  T: UpdateTrackSettings,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 8,\r\n  name: \"leave\",\r\n  kind: \"message\",\r\n  T: LeaveRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 10,\r\n  name: \"update_layers\",\r\n  kind: \"message\",\r\n  T: UpdateVideoLayers,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 11,\r\n  name: \"subscription_permission\",\r\n  kind: \"message\",\r\n  T: SubscriptionPermission,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 12,\r\n  name: \"sync_state\",\r\n  kind: \"message\",\r\n  T: SyncState,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 13,\r\n  name: \"simulate\",\r\n  kind: \"message\",\r\n  T: SimulateScenario,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 14,\r\n  name: \"ping\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 15,\r\n  name: \"update_metadata\",\r\n  kind: \"message\",\r\n  T: UpdateParticipantMetadata,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 16,\r\n  name: \"ping_req\",\r\n  kind: \"message\",\r\n  T: Ping,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 17,\r\n  name: \"update_audio_track\",\r\n  kind: \"message\",\r\n  T: UpdateLocalAudioTrack,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 18,\r\n  name: \"update_video_track\",\r\n  kind: \"message\",\r\n  T: UpdateLocalVideoTrack,\r\n  oneof: \"message\"\r\n}]);\r\nconst SignalResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SignalResponse\", () => [{\r\n  no: 1,\r\n  name: \"join\",\r\n  kind: \"message\",\r\n  T: JoinResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 2,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 3,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 4,\r\n  name: \"trickle\",\r\n  kind: \"message\",\r\n  T: TrickleRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 5,\r\n  name: \"update\",\r\n  kind: \"message\",\r\n  T: ParticipantUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 6,\r\n  name: \"track_published\",\r\n  kind: \"message\",\r\n  T: TrackPublishedResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 8,\r\n  name: \"leave\",\r\n  kind: \"message\",\r\n  T: LeaveRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 9,\r\n  name: \"mute\",\r\n  kind: \"message\",\r\n  T: MuteTrackRequest,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 10,\r\n  name: \"speakers_changed\",\r\n  kind: \"message\",\r\n  T: SpeakersChanged,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 11,\r\n  name: \"room_update\",\r\n  kind: \"message\",\r\n  T: RoomUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 12,\r\n  name: \"connection_quality\",\r\n  kind: \"message\",\r\n  T: ConnectionQualityUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 13,\r\n  name: \"stream_state_update\",\r\n  kind: \"message\",\r\n  T: StreamStateUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 14,\r\n  name: \"subscribed_quality_update\",\r\n  kind: \"message\",\r\n  T: SubscribedQualityUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 15,\r\n  name: \"subscription_permission_update\",\r\n  kind: \"message\",\r\n  T: SubscriptionPermissionUpdate,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 16,\r\n  name: \"refresh_token\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 17,\r\n  name: \"track_unpublished\",\r\n  kind: \"message\",\r\n  T: TrackUnpublishedResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 18,\r\n  name: \"pong\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 19,\r\n  name: \"reconnect\",\r\n  kind: \"message\",\r\n  T: ReconnectResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 20,\r\n  name: \"pong_resp\",\r\n  kind: \"message\",\r\n  T: Pong,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 21,\r\n  name: \"subscription_response\",\r\n  kind: \"message\",\r\n  T: SubscriptionResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 22,\r\n  name: \"request_response\",\r\n  kind: \"message\",\r\n  T: RequestResponse,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 23,\r\n  name: \"track_subscribed\",\r\n  kind: \"message\",\r\n  T: TrackSubscribed,\r\n  oneof: \"message\"\r\n}, {\r\n  no: 24,\r\n  name: \"room_moved\",\r\n  kind: \"message\",\r\n  T: RoomMovedResponse,\r\n  oneof: \"message\"\r\n}]);\r\nconst SimulcastCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulcastCodec\", () => [{\r\n  no: 1,\r\n  name: \"codec\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst AddTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.AddTrackRequest\", () => [{\r\n  no: 1,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"type\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackType)\r\n}, {\r\n  no: 4,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 5,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 7,\r\n  name: \"disable_dtx\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 8,\r\n  name: \"source\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(TrackSource)\r\n}, {\r\n  no: 9,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}, {\r\n  no: 10,\r\n  name: \"simulcast_codecs\",\r\n  kind: \"message\",\r\n  T: SimulcastCodec,\r\n  repeated: true\r\n}, {\r\n  no: 11,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 12,\r\n  name: \"stereo\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 13,\r\n  name: \"disable_red\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 14,\r\n  name: \"encryption\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(Encryption_Type)\r\n}, {\r\n  no: 15,\r\n  name: \"stream\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 16,\r\n  name: \"backup_codec_policy\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(BackupCodecPolicy$1)\r\n}, {\r\n  no: 17,\r\n  name: \"audio_features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}]);\r\nconst TrickleRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrickleRequest\", () => [{\r\n  no: 1,\r\n  name: \"candidateInit\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"target\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SignalTarget)\r\n}, {\r\n  no: 3,\r\n  name: \"final\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst MuteTrackRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.MuteTrackRequest\", () => [{\r\n  no: 1,\r\n  name: \"sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"muted\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst JoinResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.JoinResponse\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}, {\r\n  no: 2,\r\n  name: \"participant\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo\r\n}, {\r\n  no: 3,\r\n  name: \"other_participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"server_version\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 5,\r\n  name: \"ice_servers\",\r\n  kind: \"message\",\r\n  T: ICEServer,\r\n  repeated: true\r\n}, {\r\n  no: 6,\r\n  name: \"subscriber_primary\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 7,\r\n  name: \"alternative_url\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 8,\r\n  name: \"client_configuration\",\r\n  kind: \"message\",\r\n  T: ClientConfiguration\r\n}, {\r\n  no: 9,\r\n  name: \"server_region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 10,\r\n  name: \"ping_timeout\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 11,\r\n  name: \"ping_interval\",\r\n  kind: \"scalar\",\r\n  T: 5\r\n  /* ScalarType.INT32 */\r\n}, {\r\n  no: 12,\r\n  name: \"server_info\",\r\n  kind: \"message\",\r\n  T: ServerInfo\r\n}, {\r\n  no: 13,\r\n  name: \"sif_trailer\",\r\n  kind: \"scalar\",\r\n  T: 12\r\n  /* ScalarType.BYTES */\r\n}, {\r\n  no: 14,\r\n  name: \"enabled_publish_codecs\",\r\n  kind: \"message\",\r\n  T: Codec,\r\n  repeated: true\r\n}, {\r\n  no: 15,\r\n  name: \"fast_publish\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst ReconnectResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.ReconnectResponse\", () => [{\r\n  no: 1,\r\n  name: \"ice_servers\",\r\n  kind: \"message\",\r\n  T: ICEServer,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"client_configuration\",\r\n  kind: \"message\",\r\n  T: ClientConfiguration\r\n}, {\r\n  no: 3,\r\n  name: \"server_info\",\r\n  kind: \"message\",\r\n  T: ServerInfo\r\n}, {\r\n  no: 4,\r\n  name: \"last_message_seq\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst TrackPublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPublishedResponse\", () => [{\r\n  no: 1,\r\n  name: \"cid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track\",\r\n  kind: \"message\",\r\n  T: TrackInfo\r\n}]);\r\nconst TrackUnpublishedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SessionDescription = /* @__PURE__ */proto3.makeMessageType(\"livekit.SessionDescription\", () => [{\r\n  no: 1,\r\n  name: \"type\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"sdp\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst ParticipantUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ParticipantUpdate\", () => [{\r\n  no: 1,\r\n  name: \"participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}]);\r\nconst UpdateSubscription = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateSubscription\", () => [{\r\n  no: 1,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"subscribe\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"participant_tracks\",\r\n  kind: \"message\",\r\n  T: ParticipantTracks,\r\n  repeated: true\r\n}]);\r\nconst UpdateTrackSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateTrackSettings\", () => [{\r\n  no: 1,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 3,\r\n  name: \"disabled\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 4,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 5,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 6,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 7,\r\n  name: \"fps\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 8,\r\n  name: \"priority\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst UpdateLocalAudioTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"features\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(AudioTrackFeature),\r\n  repeated: true\r\n}]);\r\nconst UpdateLocalVideoTrack = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"width\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"height\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst LeaveRequest = /* @__PURE__ */proto3.makeMessageType(\"livekit.LeaveRequest\", () => [{\r\n  no: 1,\r\n  name: \"can_reconnect\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(DisconnectReason)\r\n}, {\r\n  no: 3,\r\n  name: \"action\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(LeaveRequest_Action)\r\n}, {\r\n  no: 4,\r\n  name: \"regions\",\r\n  kind: \"message\",\r\n  T: RegionSettings\r\n}]);\r\nconst LeaveRequest_Action = /* @__PURE__ */proto3.makeEnum(\"livekit.LeaveRequest.Action\", [{\r\n  no: 0,\r\n  name: \"DISCONNECT\"\r\n}, {\r\n  no: 1,\r\n  name: \"RESUME\"\r\n}, {\r\n  no: 2,\r\n  name: \"RECONNECT\"\r\n}]);\r\nconst UpdateVideoLayers = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateVideoLayers\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"layers\",\r\n  kind: \"message\",\r\n  T: VideoLayer,\r\n  repeated: true\r\n}]);\r\nconst UpdateParticipantMetadata = /* @__PURE__ */proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", () => [{\r\n  no: 1,\r\n  name: \"metadata\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"name\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"attributes\",\r\n  kind: \"map\",\r\n  K: 9,\r\n  V: {\r\n    kind: \"scalar\",\r\n    T: 9\r\n    /* ScalarType.STRING */\r\n  }\r\n}, {\r\n  no: 4,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst ICEServer = /* @__PURE__ */proto3.makeMessageType(\"livekit.ICEServer\", () => [{\r\n  no: 1,\r\n  name: \"urls\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 2,\r\n  name: \"username\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"credential\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SpeakersChanged = /* @__PURE__ */proto3.makeMessageType(\"livekit.SpeakersChanged\", () => [{\r\n  no: 1,\r\n  name: \"speakers\",\r\n  kind: \"message\",\r\n  T: SpeakerInfo,\r\n  repeated: true\r\n}]);\r\nconst RoomUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomUpdate\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}]);\r\nconst ConnectionQualityInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(ConnectionQuality$1)\r\n}, {\r\n  no: 3,\r\n  name: \"score\",\r\n  kind: \"scalar\",\r\n  T: 2\r\n  /* ScalarType.FLOAT */\r\n}]);\r\nconst ConnectionQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", () => [{\r\n  no: 1,\r\n  name: \"updates\",\r\n  kind: \"message\",\r\n  T: ConnectionQualityInfo,\r\n  repeated: true\r\n}]);\r\nconst StreamStateInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateInfo\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"state\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(StreamState)\r\n}]);\r\nconst StreamStateUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.StreamStateUpdate\", () => [{\r\n  no: 1,\r\n  name: \"stream_states\",\r\n  kind: \"message\",\r\n  T: StreamStateInfo,\r\n  repeated: true\r\n}]);\r\nconst SubscribedQuality = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQuality\", () => [{\r\n  no: 1,\r\n  name: \"quality\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(VideoQuality$1)\r\n}, {\r\n  no: 2,\r\n  name: \"enabled\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst SubscribedCodec = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedCodec\", () => [{\r\n  no: 1,\r\n  name: \"codec\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"qualities\",\r\n  kind: \"message\",\r\n  T: SubscribedQuality,\r\n  repeated: true\r\n}]);\r\nconst SubscribedQualityUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"subscribed_qualities\",\r\n  kind: \"message\",\r\n  T: SubscribedQuality,\r\n  repeated: true\r\n}, {\r\n  no: 3,\r\n  name: \"subscribed_codecs\",\r\n  kind: \"message\",\r\n  T: SubscribedCodec,\r\n  repeated: true\r\n}]);\r\nconst TrackPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackPermission\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"all_tracks\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 3,\r\n  name: \"track_sids\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"participant_identity\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst SubscriptionPermission = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermission\", () => [{\r\n  no: 1,\r\n  name: \"all_participants\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}, {\r\n  no: 2,\r\n  name: \"track_permissions\",\r\n  kind: \"message\",\r\n  T: TrackPermission,\r\n  repeated: true\r\n}]);\r\nconst SubscriptionPermissionUpdate = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", () => [{\r\n  no: 1,\r\n  name: \"participant_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"allowed\",\r\n  kind: \"scalar\",\r\n  T: 8\r\n  /* ScalarType.BOOL */\r\n}]);\r\nconst RoomMovedResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RoomMovedResponse\", () => [{\r\n  no: 1,\r\n  name: \"room\",\r\n  kind: \"message\",\r\n  T: Room$1\r\n}, {\r\n  no: 2,\r\n  name: \"token\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"participant\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo\r\n}, {\r\n  no: 4,\r\n  name: \"other_participants\",\r\n  kind: \"message\",\r\n  T: ParticipantInfo,\r\n  repeated: true\r\n}]);\r\nconst SyncState = /* @__PURE__ */proto3.makeMessageType(\"livekit.SyncState\", () => [{\r\n  no: 1,\r\n  name: \"answer\",\r\n  kind: \"message\",\r\n  T: SessionDescription\r\n}, {\r\n  no: 2,\r\n  name: \"subscription\",\r\n  kind: \"message\",\r\n  T: UpdateSubscription\r\n}, {\r\n  no: 3,\r\n  name: \"publish_tracks\",\r\n  kind: \"message\",\r\n  T: TrackPublishedResponse,\r\n  repeated: true\r\n}, {\r\n  no: 4,\r\n  name: \"data_channels\",\r\n  kind: \"message\",\r\n  T: DataChannelInfo,\r\n  repeated: true\r\n}, {\r\n  no: 5,\r\n  name: \"offer\",\r\n  kind: \"message\",\r\n  T: SessionDescription\r\n}, {\r\n  no: 6,\r\n  name: \"track_sids_disabled\",\r\n  kind: \"scalar\",\r\n  T: 9,\r\n  repeated: true\r\n}, {\r\n  no: 7,\r\n  name: \"datachannel_receive_states\",\r\n  kind: \"message\",\r\n  T: DataChannelReceiveState,\r\n  repeated: true\r\n}]);\r\nconst DataChannelReceiveState = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelReceiveState\", () => [{\r\n  no: 1,\r\n  name: \"publisher_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"last_seq\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}]);\r\nconst DataChannelInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.DataChannelInfo\", () => [{\r\n  no: 1,\r\n  name: \"label\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 3,\r\n  name: \"target\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SignalTarget)\r\n}]);\r\nconst SimulateScenario = /* @__PURE__ */proto3.makeMessageType(\"livekit.SimulateScenario\", () => [{\r\n  no: 1,\r\n  name: \"speaker_update\",\r\n  kind: \"scalar\",\r\n  T: 5,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 2,\r\n  name: \"node_failure\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 3,\r\n  name: \"migration\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 4,\r\n  name: \"server_leave\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 5,\r\n  name: \"switch_candidate_protocol\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(CandidateProtocol),\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 6,\r\n  name: \"subscriber_bandwidth\",\r\n  kind: \"scalar\",\r\n  T: 3,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 7,\r\n  name: \"disconnect_signal_on_resume\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 8,\r\n  name: \"disconnect_signal_on_resume_no_messages\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}, {\r\n  no: 9,\r\n  name: \"leave_request_full_reconnect\",\r\n  kind: \"scalar\",\r\n  T: 8,\r\n  oneof: \"scenario\"\r\n}]);\r\nconst Ping = /* @__PURE__ */proto3.makeMessageType(\"livekit.Ping\", () => [{\r\n  no: 1,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"rtt\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst Pong = /* @__PURE__ */proto3.makeMessageType(\"livekit.Pong\", () => [{\r\n  no: 1,\r\n  name: \"last_ping_timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}, {\r\n  no: 2,\r\n  name: \"timestamp\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst RegionSettings = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionSettings\", () => [{\r\n  no: 1,\r\n  name: \"regions\",\r\n  kind: \"message\",\r\n  T: RegionInfo,\r\n  repeated: true\r\n}]);\r\nconst RegionInfo = /* @__PURE__ */proto3.makeMessageType(\"livekit.RegionInfo\", () => [{\r\n  no: 1,\r\n  name: \"region\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"url\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 3,\r\n  name: \"distance\",\r\n  kind: \"scalar\",\r\n  T: 3\r\n  /* ScalarType.INT64 */\r\n}]);\r\nconst SubscriptionResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.SubscriptionResponse\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}, {\r\n  no: 2,\r\n  name: \"err\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(SubscriptionError)\r\n}]);\r\nconst RequestResponse = /* @__PURE__ */proto3.makeMessageType(\"livekit.RequestResponse\", () => [{\r\n  no: 1,\r\n  name: \"request_id\",\r\n  kind: \"scalar\",\r\n  T: 13\r\n  /* ScalarType.UINT32 */\r\n}, {\r\n  no: 2,\r\n  name: \"reason\",\r\n  kind: \"enum\",\r\n  T: proto3.getEnumType(RequestResponse_Reason)\r\n}, {\r\n  no: 3,\r\n  name: \"message\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\nconst RequestResponse_Reason = /* @__PURE__ */proto3.makeEnum(\"livekit.RequestResponse.Reason\", [{\r\n  no: 0,\r\n  name: \"OK\"\r\n}, {\r\n  no: 1,\r\n  name: \"NOT_FOUND\"\r\n}, {\r\n  no: 2,\r\n  name: \"NOT_ALLOWED\"\r\n}, {\r\n  no: 3,\r\n  name: \"LIMIT_EXCEEDED\"\r\n}]);\r\nconst TrackSubscribed = /* @__PURE__ */proto3.makeMessageType(\"livekit.TrackSubscribed\", () => [{\r\n  no: 1,\r\n  name: \"track_sid\",\r\n  kind: \"scalar\",\r\n  T: 9\r\n  /* ScalarType.STRING */\r\n}]);\r\n\r\nfunction getDefaultExportFromCjs (x) {\r\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\r\n}\r\n\r\nvar loglevel$1 = {exports: {}};\r\n\r\n/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\nvar loglevel = loglevel$1.exports;\r\nvar hasRequiredLoglevel;\r\nfunction requireLoglevel() {\r\n  if (hasRequiredLoglevel) return loglevel$1.exports;\r\n  hasRequiredLoglevel = 1;\r\n  (function (module) {\r\n    (function (root, definition) {\r\n\r\n      if (module.exports) {\r\n        module.exports = definition();\r\n      } else {\r\n        root.log = definition();\r\n      }\r\n    })(loglevel, function () {\r\n\r\n      // Slightly dubious tricks to cut down minimized file size\r\n      var noop = function () {};\r\n      var undefinedType = \"undefined\";\r\n      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\r\n      var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\r\n      var _loggersByName = {};\r\n      var defaultLogger = null;\r\n\r\n      // Cross-browser bind equivalent that works at least back to IE6\r\n      function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n          return method.bind(obj);\r\n        } else {\r\n          try {\r\n            return Function.prototype.bind.call(method, obj);\r\n          } catch (e) {\r\n            // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n            return function () {\r\n              return Function.prototype.apply.apply(method, [obj, arguments]);\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      // Trace() doesn't print the message in IE, so for that case we need to wrap it\r\n      function traceForIE() {\r\n        if (console.log) {\r\n          if (console.log.apply) {\r\n            console.log.apply(console, arguments);\r\n          } else {\r\n            // In old IE, native console methods themselves don't have apply().\r\n            Function.prototype.apply.apply(console.log, [console, arguments]);\r\n          }\r\n        }\r\n        if (console.trace) console.trace();\r\n      }\r\n\r\n      // Build the best logging method possible for this env\r\n      // Wherever possible we want to bind, not wrap, to preserve stack traces\r\n      function realMethod(methodName) {\r\n        if (methodName === 'debug') {\r\n          methodName = 'log';\r\n        }\r\n        if (typeof console === undefinedType) {\r\n          return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\r\n        } else if (methodName === 'trace' && isIE) {\r\n          return traceForIE;\r\n        } else if (console[methodName] !== undefined) {\r\n          return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n          return bindMethod(console, 'log');\r\n        } else {\r\n          return noop;\r\n        }\r\n      }\r\n\r\n      // These private functions always need `this` to be set properly\r\n\r\n      function replaceLoggingMethods() {\r\n        /*jshint validthis:true */\r\n        var level = this.getLevel();\r\n\r\n        // Replace the actual methods.\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n          var methodName = logMethods[i];\r\n          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\r\n        }\r\n\r\n        // Define log.log as an alias for log.debug\r\n        this.log = this.debug;\r\n\r\n        // Return any important warnings.\r\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\r\n          return \"No console available for logging\";\r\n        }\r\n      }\r\n\r\n      // In old IE versions, the console isn't present until you first open it.\r\n      // We build realMethod() replacements here that regenerate logging methods\r\n      function enableLoggingWhenConsoleArrives(methodName) {\r\n        return function () {\r\n          if (typeof console !== undefinedType) {\r\n            replaceLoggingMethods.call(this);\r\n            this[methodName].apply(this, arguments);\r\n          }\r\n        };\r\n      }\r\n\r\n      // By default, we use closely bound real methods wherever possible, and\r\n      // otherwise we wait for a console to appear, and then try again.\r\n      function defaultMethodFactory(methodName, _level, _loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n      }\r\n      function Logger(name, factory) {\r\n        // Private instance variables.\r\n        var self = this;\r\n        /**\r\n         * The level inherited from a parent logger (or a global default). We\r\n         * cache this here rather than delegating to the parent so that it stays\r\n         * in sync with the actual logging methods that we have installed (the\r\n         * parent could change levels but we might not have rebuilt the loggers\r\n         * in this child yet).\r\n         * @type {number}\r\n         */\r\n        var inheritedLevel;\r\n        /**\r\n         * The default level for this logger, if any. If set, this overrides\r\n         * `inheritedLevel`.\r\n         * @type {number|null}\r\n         */\r\n        var defaultLevel;\r\n        /**\r\n         * A user-specific level for this logger. If set, this overrides\r\n         * `defaultLevel`.\r\n         * @type {number|null}\r\n         */\r\n        var userLevel;\r\n        var storageKey = \"loglevel\";\r\n        if (typeof name === \"string\") {\r\n          storageKey += \":\" + name;\r\n        } else if (typeof name === \"symbol\") {\r\n          storageKey = undefined;\r\n        }\r\n        function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n            window.localStorage[storageKey] = levelName;\r\n            return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n            window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n        }\r\n        function getPersistedLevel() {\r\n          var storedLevel;\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n          try {\r\n            storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          // Fallback to cookies if local storage gives us nothing\r\n          if (typeof storedLevel === undefinedType) {\r\n            try {\r\n              var cookie = window.document.cookie;\r\n              var cookieName = encodeURIComponent(storageKey);\r\n              var location = cookie.indexOf(cookieName + \"=\");\r\n              if (location !== -1) {\r\n                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\r\n              }\r\n            } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n            storedLevel = undefined;\r\n          }\r\n          return storedLevel;\r\n        }\r\n        function clearPersistedLevel() {\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n            window.localStorage.removeItem(storageKey);\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n            window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\r\n          } catch (ignore) {}\r\n        }\r\n        function normalizeLevel(input) {\r\n          var level = input;\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n            level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n            return level;\r\n          } else {\r\n            throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\r\n          }\r\n        }\r\n\r\n        /*\r\n         *\r\n         * Public logger API - see https://github.com/pimterry/loglevel for details\r\n         *\r\n         */\r\n\r\n        self.name = name;\r\n        self.levels = {\r\n          \"TRACE\": 0,\r\n          \"DEBUG\": 1,\r\n          \"INFO\": 2,\r\n          \"WARN\": 3,\r\n          \"ERROR\": 4,\r\n          \"SILENT\": 5\r\n        };\r\n        self.methodFactory = factory || defaultMethodFactory;\r\n        self.getLevel = function () {\r\n          if (userLevel != null) {\r\n            return userLevel;\r\n          } else if (defaultLevel != null) {\r\n            return defaultLevel;\r\n          } else {\r\n            return inheritedLevel;\r\n          }\r\n        };\r\n        self.setLevel = function (level, persist) {\r\n          userLevel = normalizeLevel(level);\r\n          if (persist !== false) {\r\n            // defaults to true\r\n            persistLevelIfPossible(userLevel);\r\n          }\r\n\r\n          // NOTE: in v2, this should call rebuild(), which updates children.\r\n          return replaceLoggingMethods.call(self);\r\n        };\r\n        self.setDefaultLevel = function (level) {\r\n          defaultLevel = normalizeLevel(level);\r\n          if (!getPersistedLevel()) {\r\n            self.setLevel(level, false);\r\n          }\r\n        };\r\n        self.resetLevel = function () {\r\n          userLevel = null;\r\n          clearPersistedLevel();\r\n          replaceLoggingMethods.call(self);\r\n        };\r\n        self.enableAll = function (persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n        };\r\n        self.disableAll = function (persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n        };\r\n        self.rebuild = function () {\r\n          if (defaultLogger !== self) {\r\n            inheritedLevel = normalizeLevel(defaultLogger.getLevel());\r\n          }\r\n          replaceLoggingMethods.call(self);\r\n          if (defaultLogger === self) {\r\n            for (var childName in _loggersByName) {\r\n              _loggersByName[childName].rebuild();\r\n            }\r\n          }\r\n        };\r\n\r\n        // Initialize all the internal levels.\r\n        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\r\n        var initialLevel = getPersistedLevel();\r\n        if (initialLevel != null) {\r\n          userLevel = normalizeLevel(initialLevel);\r\n        }\r\n        replaceLoggingMethods.call(self);\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Top-level API\r\n       *\r\n       */\r\n\r\n      defaultLogger = new Logger();\r\n      defaultLogger.getLogger = function getLogger(name) {\r\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n      };\r\n\r\n      // Grab the current global log variable in case of overwrite\r\n      var _log = typeof window !== undefinedType ? window.log : undefined;\r\n      defaultLogger.noConflict = function () {\r\n        if (typeof window !== undefinedType && window.log === defaultLogger) {\r\n          window.log = _log;\r\n        }\r\n        return defaultLogger;\r\n      };\r\n      defaultLogger.getLoggers = function getLoggers() {\r\n        return _loggersByName;\r\n      };\r\n\r\n      // ES6 default export, for compatibility\r\n      defaultLogger['default'] = defaultLogger;\r\n      return defaultLogger;\r\n    });\r\n  })(loglevel$1);\r\n  return loglevel$1.exports;\r\n}\r\n\r\nvar loglevelExports = requireLoglevel();\r\n\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\r\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\r\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\r\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\r\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\r\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\r\n})(LogLevel || (LogLevel = {}));\r\nvar LoggerNames;\r\n(function (LoggerNames) {\r\n  LoggerNames[\"Default\"] = \"livekit\";\r\n  LoggerNames[\"Room\"] = \"livekit-room\";\r\n  LoggerNames[\"Participant\"] = \"livekit-participant\";\r\n  LoggerNames[\"Track\"] = \"livekit-track\";\r\n  LoggerNames[\"Publication\"] = \"livekit-track-publication\";\r\n  LoggerNames[\"Engine\"] = \"livekit-engine\";\r\n  LoggerNames[\"Signal\"] = \"livekit-signal\";\r\n  LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\r\n  LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\r\n  LoggerNames[\"E2EE\"] = \"lk-e2ee\";\r\n})(LoggerNames || (LoggerNames = {}));\r\nlet livekitLogger = loglevelExports.getLogger('livekit');\r\nconst livekitLoggers = Object.values(LoggerNames).map(name => loglevelExports.getLogger(name));\r\nlivekitLogger.setDefaultLevel(LogLevel.info);\r\n/**\r\n * @internal\r\n */\r\nfunction getLogger(name) {\r\n  const logger = loglevelExports.getLogger(name);\r\n  logger.setDefaultLevel(livekitLogger.getLevel());\r\n  return logger;\r\n}\r\nfunction setLogLevel(level, loggerName) {\r\n  if (loggerName) {\r\n    loglevelExports.getLogger(loggerName).setLevel(level);\r\n  } else {\r\n    for (const logger of livekitLoggers) {\r\n      logger.setLevel(level);\r\n    }\r\n  }\r\n}\r\n/**\r\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\r\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\r\n */\r\nfunction setLogExtension(extension, logger) {\r\n  const loggers = logger ? [logger] : livekitLoggers;\r\n  loggers.forEach(logR => {\r\n    const originalFactory = logR.methodFactory;\r\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\r\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\r\n      const logLevel = LogLevel[methodName];\r\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\r\n      return (msg, context) => {\r\n        if (context) rawMethod(msg, context);else rawMethod(msg);\r\n        if (needLog) {\r\n          extension(logLevel, msg, context);\r\n        }\r\n      };\r\n    };\r\n    logR.setLevel(logR.getLevel());\r\n  });\r\n}\r\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');\r\n\r\nconst maxRetryDelay = 7000;\r\nconst DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];\r\nclass DefaultReconnectPolicy {\r\n  constructor(retryDelays) {\r\n    this._retryDelays = retryDelays !== undefined ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;\r\n  }\r\n  nextRetryDelayInMs(context) {\r\n    if (context.retryCount >= this._retryDelays.length) return null;\r\n    const retryDelay = this._retryDelays[context.retryCount];\r\n    if (context.retryCount <= 1) return retryDelay;\r\n    return retryDelay + Math.random() * 1000;\r\n  }\r\n}\r\n\r\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nvar events = {exports: {}};\r\n\r\nvar hasRequiredEvents;\r\nfunction requireEvents() {\r\n  if (hasRequiredEvents) return events.exports;\r\n  hasRequiredEvents = 1;\r\n  var R = typeof Reflect === 'object' ? Reflect : null;\r\n  var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\r\n    return Function.prototype.apply.call(target, receiver, args);\r\n  };\r\n  var ReflectOwnKeys;\r\n  if (R && typeof R.ownKeys === 'function') {\r\n    ReflectOwnKeys = R.ownKeys;\r\n  } else if (Object.getOwnPropertySymbols) {\r\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\r\n    };\r\n  } else {\r\n    ReflectOwnKeys = function ReflectOwnKeys(target) {\r\n      return Object.getOwnPropertyNames(target);\r\n    };\r\n  }\r\n  function ProcessEmitWarning(warning) {\r\n    if (console && console.warn) console.warn(warning);\r\n  }\r\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\r\n    return value !== value;\r\n  };\r\n  function EventEmitter() {\r\n    EventEmitter.init.call(this);\r\n  }\r\n  events.exports = EventEmitter;\r\n  events.exports.once = once;\r\n\r\n  // Backwards-compat with node 0.10.x\r\n  EventEmitter.EventEmitter = EventEmitter;\r\n  EventEmitter.prototype._events = undefined;\r\n  EventEmitter.prototype._eventsCount = 0;\r\n  EventEmitter.prototype._maxListeners = undefined;\r\n\r\n  // By default EventEmitters will print a warning if more than 10 listeners are\r\n  // added to it. This is a useful default which helps finding memory leaks.\r\n  var defaultMaxListeners = 10;\r\n  function checkListener(listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\r\n    }\r\n  }\r\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\r\n    enumerable: true,\r\n    get: function () {\r\n      return defaultMaxListeners;\r\n    },\r\n    set: function (arg) {\r\n      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\r\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\r\n      }\r\n      defaultMaxListeners = arg;\r\n    }\r\n  });\r\n  EventEmitter.init = function () {\r\n    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\r\n      this._events = Object.create(null);\r\n      this._eventsCount = 0;\r\n    }\r\n    this._maxListeners = this._maxListeners || undefined;\r\n  };\r\n\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\r\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\r\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\r\n    }\r\n    this._maxListeners = n;\r\n    return this;\r\n  };\r\n  function _getMaxListeners(that) {\r\n    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\r\n    return that._maxListeners;\r\n  }\r\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\r\n    return _getMaxListeners(this);\r\n  };\r\n  EventEmitter.prototype.emit = function emit(type) {\r\n    var args = [];\r\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\r\n    var doError = type === 'error';\r\n    var events = this._events;\r\n    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\r\n\r\n    // If there is no 'error' event listener then throw.\r\n    if (doError) {\r\n      var er;\r\n      if (args.length > 0) er = args[0];\r\n      if (er instanceof Error) {\r\n        // Note: The comments on the `throw` lines are intentional, they show\r\n        // up in Node's output if this results in an unhandled exception.\r\n        throw er; // Unhandled 'error' event\r\n      }\r\n      // At least give some kind of context to the user\r\n      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\r\n      err.context = er;\r\n      throw err; // Unhandled 'error' event\r\n    }\r\n    var handler = events[type];\r\n    if (handler === undefined) return false;\r\n    if (typeof handler === 'function') {\r\n      ReflectApply(handler, this, args);\r\n    } else {\r\n      var len = handler.length;\r\n      var listeners = arrayClone(handler, len);\r\n      for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\r\n    }\r\n    return true;\r\n  };\r\n  function _addListener(target, type, listener, prepend) {\r\n    var m;\r\n    var events;\r\n    var existing;\r\n    checkListener(listener);\r\n    events = target._events;\r\n    if (events === undefined) {\r\n      events = target._events = Object.create(null);\r\n      target._eventsCount = 0;\r\n    } else {\r\n      // To avoid recursion in the case that type === \"newListener\"! Before\r\n      // adding it to the listeners, first emit \"newListener\".\r\n      if (events.newListener !== undefined) {\r\n        target.emit('newListener', type, listener.listener ? listener.listener : listener);\r\n\r\n        // Re-assign `events` because a newListener handler could have caused the\r\n        // this._events to be assigned to a new object\r\n        events = target._events;\r\n      }\r\n      existing = events[type];\r\n    }\r\n    if (existing === undefined) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      existing = events[type] = listener;\r\n      ++target._eventsCount;\r\n    } else {\r\n      if (typeof existing === 'function') {\r\n        // Adding the second element, need to change to array.\r\n        existing = events[type] = prepend ? [listener, existing] : [existing, listener];\r\n        // If we've already got an array, just append.\r\n      } else if (prepend) {\r\n        existing.unshift(listener);\r\n      } else {\r\n        existing.push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      m = _getMaxListeners(target);\r\n      if (m > 0 && existing.length > m && !existing.warned) {\r\n        existing.warned = true;\r\n        // No error code for this since it is a Warning\r\n        // eslint-disable-next-line no-restricted-syntax\r\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\r\n        w.name = 'MaxListenersExceededWarning';\r\n        w.emitter = target;\r\n        w.type = type;\r\n        w.count = existing.length;\r\n        ProcessEmitWarning(w);\r\n      }\r\n    }\r\n    return target;\r\n  }\r\n  EventEmitter.prototype.addListener = function addListener(type, listener) {\r\n    return _addListener(this, type, listener, false);\r\n  };\r\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\r\n  EventEmitter.prototype.prependListener = function prependListener(type, listener) {\r\n    return _addListener(this, type, listener, true);\r\n  };\r\n  function onceWrapper() {\r\n    if (!this.fired) {\r\n      this.target.removeListener(this.type, this.wrapFn);\r\n      this.fired = true;\r\n      if (arguments.length === 0) return this.listener.call(this.target);\r\n      return this.listener.apply(this.target, arguments);\r\n    }\r\n  }\r\n  function _onceWrap(target, type, listener) {\r\n    var state = {\r\n      fired: false,\r\n      wrapFn: undefined,\r\n      target: target,\r\n      type: type,\r\n      listener: listener\r\n    };\r\n    var wrapped = onceWrapper.bind(state);\r\n    wrapped.listener = listener;\r\n    state.wrapFn = wrapped;\r\n    return wrapped;\r\n  }\r\n  EventEmitter.prototype.once = function once(type, listener) {\r\n    checkListener(listener);\r\n    this.on(type, _onceWrap(this, type, listener));\r\n    return this;\r\n  };\r\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\r\n    checkListener(listener);\r\n    this.prependListener(type, _onceWrap(this, type, listener));\r\n    return this;\r\n  };\r\n\r\n  // Emits a 'removeListener' event if and only if the listener was removed.\r\n  EventEmitter.prototype.removeListener = function removeListener(type, listener) {\r\n    var list, events, position, i, originalListener;\r\n    checkListener(listener);\r\n    events = this._events;\r\n    if (events === undefined) return this;\r\n    list = events[type];\r\n    if (list === undefined) return this;\r\n    if (list === listener || list.listener === listener) {\r\n      if (--this._eventsCount === 0) this._events = Object.create(null);else {\r\n        delete events[type];\r\n        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\r\n      }\r\n    } else if (typeof list !== 'function') {\r\n      position = -1;\r\n      for (i = list.length - 1; i >= 0; i--) {\r\n        if (list[i] === listener || list[i].listener === listener) {\r\n          originalListener = list[i].listener;\r\n          position = i;\r\n          break;\r\n        }\r\n      }\r\n      if (position < 0) return this;\r\n      if (position === 0) list.shift();else {\r\n        spliceOne(list, position);\r\n      }\r\n      if (list.length === 1) events[type] = list[0];\r\n      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\r\n    }\r\n    return this;\r\n  };\r\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\r\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\r\n    var listeners, events, i;\r\n    events = this._events;\r\n    if (events === undefined) return this;\r\n\r\n    // not listening for removeListener, no need to emit\r\n    if (events.removeListener === undefined) {\r\n      if (arguments.length === 0) {\r\n        this._events = Object.create(null);\r\n        this._eventsCount = 0;\r\n      } else if (events[type] !== undefined) {\r\n        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\r\n      }\r\n      return this;\r\n    }\r\n\r\n    // emit removeListener for all listeners on all events\r\n    if (arguments.length === 0) {\r\n      var keys = Object.keys(events);\r\n      var key;\r\n      for (i = 0; i < keys.length; ++i) {\r\n        key = keys[i];\r\n        if (key === 'removeListener') continue;\r\n        this.removeAllListeners(key);\r\n      }\r\n      this.removeAllListeners('removeListener');\r\n      this._events = Object.create(null);\r\n      this._eventsCount = 0;\r\n      return this;\r\n    }\r\n    listeners = events[type];\r\n    if (typeof listeners === 'function') {\r\n      this.removeListener(type, listeners);\r\n    } else if (listeners !== undefined) {\r\n      // LIFO order\r\n      for (i = listeners.length - 1; i >= 0; i--) {\r\n        this.removeListener(type, listeners[i]);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n  function _listeners(target, type, unwrap) {\r\n    var events = target._events;\r\n    if (events === undefined) return [];\r\n    var evlistener = events[type];\r\n    if (evlistener === undefined) return [];\r\n    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\r\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\r\n  }\r\n  EventEmitter.prototype.listeners = function listeners(type) {\r\n    return _listeners(this, type, true);\r\n  };\r\n  EventEmitter.prototype.rawListeners = function rawListeners(type) {\r\n    return _listeners(this, type, false);\r\n  };\r\n  EventEmitter.listenerCount = function (emitter, type) {\r\n    if (typeof emitter.listenerCount === 'function') {\r\n      return emitter.listenerCount(type);\r\n    } else {\r\n      return listenerCount.call(emitter, type);\r\n    }\r\n  };\r\n  EventEmitter.prototype.listenerCount = listenerCount;\r\n  function listenerCount(type) {\r\n    var events = this._events;\r\n    if (events !== undefined) {\r\n      var evlistener = events[type];\r\n      if (typeof evlistener === 'function') {\r\n        return 1;\r\n      } else if (evlistener !== undefined) {\r\n        return evlistener.length;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n  EventEmitter.prototype.eventNames = function eventNames() {\r\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\r\n  };\r\n  function arrayClone(arr, n) {\r\n    var copy = new Array(n);\r\n    for (var i = 0; i < n; ++i) copy[i] = arr[i];\r\n    return copy;\r\n  }\r\n  function spliceOne(list, index) {\r\n    for (; index + 1 < list.length; index++) list[index] = list[index + 1];\r\n    list.pop();\r\n  }\r\n  function unwrapListeners(arr) {\r\n    var ret = new Array(arr.length);\r\n    for (var i = 0; i < ret.length; ++i) {\r\n      ret[i] = arr[i].listener || arr[i];\r\n    }\r\n    return ret;\r\n  }\r\n  function once(emitter, name) {\r\n    return new Promise(function (resolve, reject) {\r\n      function errorListener(err) {\r\n        emitter.removeListener(name, resolver);\r\n        reject(err);\r\n      }\r\n      function resolver() {\r\n        if (typeof emitter.removeListener === 'function') {\r\n          emitter.removeListener('error', errorListener);\r\n        }\r\n        resolve([].slice.call(arguments));\r\n      }\r\n      eventTargetAgnosticAddListener(emitter, name, resolver, {\r\n        once: true\r\n      });\r\n      if (name !== 'error') {\r\n        addErrorHandlerIfEventEmitter(emitter, errorListener, {\r\n          once: true\r\n        });\r\n      }\r\n    });\r\n  }\r\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\r\n    if (typeof emitter.on === 'function') {\r\n      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\r\n    }\r\n  }\r\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\r\n    if (typeof emitter.on === 'function') {\r\n      if (flags.once) {\r\n        emitter.once(name, listener);\r\n      } else {\r\n        emitter.on(name, listener);\r\n      }\r\n    } else if (typeof emitter.addEventListener === 'function') {\r\n      // EventTarget does not have `error` event semantics like Node\r\n      // EventEmitters, we do not listen for `error` events here.\r\n      emitter.addEventListener(name, function wrapListener(arg) {\r\n        // IE does not have builtin `{ once: true }` support so we\r\n        // have to do it manually.\r\n        if (flags.once) {\r\n          emitter.removeEventListener(name, wrapListener);\r\n        }\r\n        listener(arg);\r\n      });\r\n    } else {\r\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\r\n    }\r\n  }\r\n  return events.exports;\r\n}\r\n\r\nvar eventsExports = requireEvents();\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nlet logDisabled_ = true;\r\nlet deprecationWarnings_ = true;\r\n\r\n/**\r\n * Extract browser version out of the provided user agent string.\r\n *\r\n * @param {!string} uastring userAgent string.\r\n * @param {!string} expr Regular expression used as match criteria.\r\n * @param {!number} pos position in the version string to be returned.\r\n * @return {!number} browser version.\r\n */\r\nfunction extractVersion(uastring, expr, pos) {\r\n  const match = uastring.match(expr);\r\n  return match && match.length >= pos && parseFloat(match[pos], 10);\r\n}\r\n\r\n// Wraps the peerconnection event eventNameToWrap in a function\r\n// which returns the modified event object (or false to prevent\r\n// the event).\r\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  const proto = window.RTCPeerConnection.prototype;\r\n  const nativeAddEventListener = proto.addEventListener;\r\n  proto.addEventListener = function (nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap) {\r\n      return nativeAddEventListener.apply(this, arguments);\r\n    }\r\n    const wrappedCallback = e => {\r\n      const modifiedEvent = wrapper(e);\r\n      if (modifiedEvent) {\r\n        if (cb.handleEvent) {\r\n          cb.handleEvent(modifiedEvent);\r\n        } else {\r\n          cb(modifiedEvent);\r\n        }\r\n      }\r\n    };\r\n    this._eventMap = this._eventMap || {};\r\n    if (!this._eventMap[eventNameToWrap]) {\r\n      this._eventMap[eventNameToWrap] = new Map();\r\n    }\r\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\r\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\r\n  };\r\n  const nativeRemoveEventListener = proto.removeEventListener;\r\n  proto.removeEventListener = function (nativeEventName, cb) {\r\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\r\n      return nativeRemoveEventListener.apply(this, arguments);\r\n    }\r\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\r\n    this._eventMap[eventNameToWrap].delete(cb);\r\n    if (this._eventMap[eventNameToWrap].size === 0) {\r\n      delete this._eventMap[eventNameToWrap];\r\n    }\r\n    if (Object.keys(this._eventMap).length === 0) {\r\n      delete this._eventMap;\r\n    }\r\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\r\n  };\r\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\r\n    get() {\r\n      return this['_on' + eventNameToWrap];\r\n    },\r\n    set(cb) {\r\n      if (this['_on' + eventNameToWrap]) {\r\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\r\n        delete this['_on' + eventNameToWrap];\r\n      }\r\n      if (cb) {\r\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n}\r\nfunction disableLog(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\r\n  }\r\n  logDisabled_ = bool;\r\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\r\n}\r\n\r\n/**\r\n * Disable or enable deprecation warnings\r\n * @param {!boolean} bool set to true to disable warnings.\r\n */\r\nfunction disableWarnings(bool) {\r\n  if (typeof bool !== 'boolean') {\r\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\r\n  }\r\n  deprecationWarnings_ = !bool;\r\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\r\n}\r\nfunction log() {\r\n  if (typeof window === 'object') {\r\n    if (logDisabled_) {\r\n      return;\r\n    }\r\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\r\n      console.log.apply(console, arguments);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\r\n */\r\nfunction deprecated(oldMethod, newMethod) {\r\n  if (!deprecationWarnings_) {\r\n    return;\r\n  }\r\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\r\n}\r\n\r\n/**\r\n * Browser detector.\r\n *\r\n * @return {object} result containing browser and version\r\n *     properties.\r\n */\r\nfunction detectBrowser(window) {\r\n  // Returned result object.\r\n  const result = {\r\n    browser: null,\r\n    version: null\r\n  };\r\n\r\n  // Fail early if it's not a browser\r\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\r\n    result.browser = 'Not a browser.';\r\n    return result;\r\n  }\r\n  const {\r\n    navigator\r\n  } = window;\r\n\r\n  // Prefer navigator.userAgentData.\r\n  if (navigator.userAgentData && navigator.userAgentData.brands) {\r\n    const chromium = navigator.userAgentData.brands.find(brand => {\r\n      return brand.brand === 'Chromium';\r\n    });\r\n    if (chromium) {\r\n      return {\r\n        browser: 'chrome',\r\n        version: parseInt(chromium.version, 10)\r\n      };\r\n    }\r\n  }\r\n  if (navigator.mozGetUserMedia) {\r\n    // Firefox.\r\n    result.browser = 'firefox';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1));\r\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection) {\r\n    // Chrome, Chromium, Webview, Opera.\r\n    // Version matches Chrome/WebRTC version.\r\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\r\n    // more complicated fallback to webkitRTCPeerConnection.\r\n    result.browser = 'chrome';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2));\r\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\r\n    // Safari.\r\n    result.browser = 'safari';\r\n    result.version = parseInt(extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1));\r\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\r\n    // Only for internal usage.\r\n    result._safariVersion = extractVersion(navigator.userAgent, /Version\\/(\\d+(\\.?\\d+))/, 1);\r\n  } else {\r\n    // Default fallthrough: not supported.\r\n    result.browser = 'Not a supported browser.';\r\n    return result;\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Checks if something is an object.\r\n *\r\n * @param {*} val The something you want to check.\r\n * @return true if val is an object, false otherwise.\r\n */\r\nfunction isObject(val) {\r\n  return Object.prototype.toString.call(val) === '[object Object]';\r\n}\r\n\r\n/**\r\n * Remove all empty objects and undefined values\r\n * from a nested object -- an enhanced and vanilla version\r\n * of Lodash's `compact`.\r\n */\r\nfunction compactObject(data) {\r\n  if (!isObject(data)) {\r\n    return data;\r\n  }\r\n  return Object.keys(data).reduce(function (accumulator, key) {\r\n    const isObj = isObject(data[key]);\r\n    const value = isObj ? compactObject(data[key]) : data[key];\r\n    const isEmptyObject = isObj && !Object.keys(value).length;\r\n    if (value === undefined || isEmptyObject) {\r\n      return accumulator;\r\n    }\r\n    return Object.assign(accumulator, {\r\n      [key]: value\r\n    });\r\n  }, {});\r\n}\r\n\r\n/* iterates the stats graph recursively. */\r\nfunction walkStats(stats, base, resultSet) {\r\n  if (!base || resultSet.has(base.id)) {\r\n    return;\r\n  }\r\n  resultSet.set(base.id, base);\r\n  Object.keys(base).forEach(name => {\r\n    if (name.endsWith('Id')) {\r\n      walkStats(stats, stats.get(base[name]), resultSet);\r\n    } else if (name.endsWith('Ids')) {\r\n      base[name].forEach(id => {\r\n        walkStats(stats, stats.get(id), resultSet);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n/* filter getStats for a sender/receiver track. */\r\nfunction filterStats(result, track, outbound) {\r\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\r\n  const filteredResult = new Map();\r\n  if (track === null) {\r\n    return filteredResult;\r\n  }\r\n  const trackStats = [];\r\n  result.forEach(value => {\r\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\r\n      trackStats.push(value);\r\n    }\r\n  });\r\n  trackStats.forEach(trackStat => {\r\n    result.forEach(stats => {\r\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\r\n        walkStats(result, stats, filteredResult);\r\n      }\r\n    });\r\n  });\r\n  return filteredResult;\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nconst logging = log;\r\nfunction shimGetUserMedia$2(window, browserDetails) {\r\n  const navigator = window && window.navigator;\r\n  if (!navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  const constraintsToChrome_ = function (c) {\r\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\r\n      return c;\r\n    }\r\n    const cc = {};\r\n    Object.keys(c).forEach(key => {\r\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\r\n        return;\r\n      }\r\n      const r = typeof c[key] === 'object' ? c[key] : {\r\n        ideal: c[key]\r\n      };\r\n      if (r.exact !== undefined && typeof r.exact === 'number') {\r\n        r.min = r.max = r.exact;\r\n      }\r\n      const oldname_ = function (prefix, name) {\r\n        if (prefix) {\r\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\r\n        }\r\n        return name === 'deviceId' ? 'sourceId' : name;\r\n      };\r\n      if (r.ideal !== undefined) {\r\n        cc.optional = cc.optional || [];\r\n        let oc = {};\r\n        if (typeof r.ideal === 'number') {\r\n          oc[oldname_('min', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n          oc = {};\r\n          oc[oldname_('max', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        } else {\r\n          oc[oldname_('', key)] = r.ideal;\r\n          cc.optional.push(oc);\r\n        }\r\n      }\r\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\r\n        cc.mandatory = cc.mandatory || {};\r\n        cc.mandatory[oldname_('', key)] = r.exact;\r\n      } else {\r\n        ['min', 'max'].forEach(mix => {\r\n          if (r[mix] !== undefined) {\r\n            cc.mandatory = cc.mandatory || {};\r\n            cc.mandatory[oldname_(mix, key)] = r[mix];\r\n          }\r\n        });\r\n      }\r\n    });\r\n    if (c.advanced) {\r\n      cc.optional = (cc.optional || []).concat(c.advanced);\r\n    }\r\n    return cc;\r\n  };\r\n  const shimConstraints_ = function (constraints, func) {\r\n    if (browserDetails.version >= 61) {\r\n      return func(constraints);\r\n    }\r\n    constraints = JSON.parse(JSON.stringify(constraints));\r\n    if (constraints && typeof constraints.audio === 'object') {\r\n      const remap = function (obj, a, b) {\r\n        if (a in obj && !(b in obj)) {\r\n          obj[b] = obj[a];\r\n          delete obj[a];\r\n        }\r\n      };\r\n      constraints = JSON.parse(JSON.stringify(constraints));\r\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\r\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\r\n      constraints.audio = constraintsToChrome_(constraints.audio);\r\n    }\r\n    if (constraints && typeof constraints.video === 'object') {\r\n      // Shim facingMode for mobile & surface pro.\r\n      let face = constraints.video.facingMode;\r\n      face = face && (typeof face === 'object' ? face : {\r\n        ideal: face\r\n      });\r\n      const getSupportedFacingModeLies = browserDetails.version < 66;\r\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\r\n        delete constraints.video.facingMode;\r\n        let matches;\r\n        if (face.exact === 'environment' || face.ideal === 'environment') {\r\n          matches = ['back', 'rear'];\r\n        } else if (face.exact === 'user' || face.ideal === 'user') {\r\n          matches = ['front'];\r\n        }\r\n        if (matches) {\r\n          // Look for matches in label, or use last cam for back (typical).\r\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\r\n            devices = devices.filter(d => d.kind === 'videoinput');\r\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\r\n            if (!dev && devices.length && matches.includes('back')) {\r\n              dev = devices[devices.length - 1]; // more likely the back cam\r\n            }\r\n            if (dev) {\r\n              constraints.video.deviceId = face.exact ? {\r\n                exact: dev.deviceId\r\n              } : {\r\n                ideal: dev.deviceId\r\n              };\r\n            }\r\n            constraints.video = constraintsToChrome_(constraints.video);\r\n            logging('chrome: ' + JSON.stringify(constraints));\r\n            return func(constraints);\r\n          });\r\n        }\r\n      }\r\n      constraints.video = constraintsToChrome_(constraints.video);\r\n    }\r\n    logging('chrome: ' + JSON.stringify(constraints));\r\n    return func(constraints);\r\n  };\r\n  const shimError_ = function (e) {\r\n    if (browserDetails.version >= 64) {\r\n      return e;\r\n    }\r\n    return {\r\n      name: {\r\n        PermissionDeniedError: 'NotAllowedError',\r\n        PermissionDismissedError: 'NotAllowedError',\r\n        InvalidStateError: 'NotAllowedError',\r\n        DevicesNotFoundError: 'NotFoundError',\r\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\r\n        TrackStartError: 'NotReadableError',\r\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\r\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\r\n        TabCaptureError: 'AbortError',\r\n        ScreenCaptureError: 'AbortError',\r\n        DeviceCaptureError: 'AbortError'\r\n      }[e.name] || e.name,\r\n      message: e.message,\r\n      constraint: e.constraint || e.constraintName,\r\n      toString() {\r\n        return this.name + (this.message && ': ') + this.message;\r\n      }\r\n    };\r\n  };\r\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\r\n    shimConstraints_(constraints, c => {\r\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\r\n        if (onError) {\r\n          onError(shimError_(e));\r\n        }\r\n      });\r\n    });\r\n  };\r\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\r\n\r\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\r\n  // function which returns a Promise, it does not accept spec-style\r\n  // constraints.\r\n  if (navigator.mediaDevices.getUserMedia) {\r\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function (cs) {\r\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\r\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\r\n          stream.getTracks().forEach(track => {\r\n            track.stop();\r\n          });\r\n          throw new DOMException('', 'NotFoundError');\r\n        }\r\n        return stream;\r\n      }, e => Promise.reject(shimError_(e))));\r\n    };\r\n  }\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimMediaStream(window) {\r\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\r\n}\r\nfunction shimOnTrack$1(window) {\r\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\r\n      get() {\r\n        return this._ontrack;\r\n      },\r\n      set(f) {\r\n        if (this._ontrack) {\r\n          this.removeEventListener('track', this._ontrack);\r\n        }\r\n        this.addEventListener('track', this._ontrack = f);\r\n      },\r\n      enumerable: true,\r\n      configurable: true\r\n    });\r\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n      if (!this._ontrackpoly) {\r\n        this._ontrackpoly = e => {\r\n          // onaddstream does not fire when a track is added to an existing\r\n          // stream. But stream.onaddtrack is implemented so we use that.\r\n          e.stream.addEventListener('addtrack', te => {\r\n            let receiver;\r\n            if (window.RTCPeerConnection.prototype.getReceivers) {\r\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\r\n            } else {\r\n              receiver = {\r\n                track: te.track\r\n              };\r\n            }\r\n            const event = new Event('track');\r\n            event.track = te.track;\r\n            event.receiver = receiver;\r\n            event.transceiver = {\r\n              receiver\r\n            };\r\n            event.streams = [e.stream];\r\n            this.dispatchEvent(event);\r\n          });\r\n          e.stream.getTracks().forEach(track => {\r\n            let receiver;\r\n            if (window.RTCPeerConnection.prototype.getReceivers) {\r\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\r\n            } else {\r\n              receiver = {\r\n                track\r\n              };\r\n            }\r\n            const event = new Event('track');\r\n            event.track = track;\r\n            event.receiver = receiver;\r\n            event.transceiver = {\r\n              receiver\r\n            };\r\n            event.streams = [e.stream];\r\n            this.dispatchEvent(event);\r\n          });\r\n        };\r\n        this.addEventListener('addstream', this._ontrackpoly);\r\n      }\r\n      return origSetRemoteDescription.apply(this, arguments);\r\n    };\r\n  } else {\r\n    // even if RTCRtpTransceiver is in window, it is only used and\r\n    // emitted in unified-plan. Unfortunately this means we need\r\n    // to unconditionally wrap the event.\r\n    wrapPeerConnectionEvent(window, 'track', e => {\r\n      if (!e.transceiver) {\r\n        Object.defineProperty(e, 'transceiver', {\r\n          value: {\r\n            receiver: e.receiver\r\n          }\r\n        });\r\n      }\r\n      return e;\r\n    });\r\n  }\r\n}\r\nfunction shimGetSendersWithDtmf(window) {\r\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\r\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\r\n    const shimSenderWithDtmf = function (pc, track) {\r\n      return {\r\n        track,\r\n        get dtmf() {\r\n          if (this._dtmf === undefined) {\r\n            if (track.kind === 'audio') {\r\n              this._dtmf = pc.createDTMFSender(track);\r\n            } else {\r\n              this._dtmf = null;\r\n            }\r\n          }\r\n          return this._dtmf;\r\n        },\r\n        _pc: pc\r\n      };\r\n    };\r\n\r\n    // augment addTrack when getSenders is not available.\r\n    if (!window.RTCPeerConnection.prototype.getSenders) {\r\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n        this._senders = this._senders || [];\r\n        return this._senders.slice(); // return a copy of the internal state.\r\n      };\r\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n        let sender = origAddTrack.apply(this, arguments);\r\n        if (!sender) {\r\n          sender = shimSenderWithDtmf(this, track);\r\n          this._senders.push(sender);\r\n        }\r\n        return sender;\r\n      };\r\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\r\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n        origRemoveTrack.apply(this, arguments);\r\n        const idx = this._senders.indexOf(sender);\r\n        if (idx !== -1) {\r\n          this._senders.splice(idx, 1);\r\n        }\r\n      };\r\n    }\r\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n      this._senders = this._senders || [];\r\n      origAddStream.apply(this, [stream]);\r\n      stream.getTracks().forEach(track => {\r\n        this._senders.push(shimSenderWithDtmf(this, track));\r\n      });\r\n    };\r\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n      this._senders = this._senders || [];\r\n      origRemoveStream.apply(this, [stream]);\r\n      stream.getTracks().forEach(track => {\r\n        const sender = this._senders.find(s => s.track === track);\r\n        if (sender) {\r\n          // remove sender\r\n          this._senders.splice(this._senders.indexOf(sender), 1);\r\n        }\r\n      });\r\n    };\r\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\r\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n      const senders = origGetSenders.apply(this, []);\r\n      senders.forEach(sender => sender._pc = this);\r\n      return senders;\r\n    };\r\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\r\n      get() {\r\n        if (this._dtmf === undefined) {\r\n          if (this.track.kind === 'audio') {\r\n            this._dtmf = this._pc.createDTMFSender(this.track);\r\n          } else {\r\n            this._dtmf = null;\r\n          }\r\n        }\r\n        return this._dtmf;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimSenderReceiverGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\r\n    return;\r\n  }\r\n\r\n  // shim sender stats.\r\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\r\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n    if (origGetSenders) {\r\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n        const senders = origGetSenders.apply(this, []);\r\n        senders.forEach(sender => sender._pc = this);\r\n        return senders;\r\n      };\r\n    }\r\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n    if (origAddTrack) {\r\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\r\n        const sender = origAddTrack.apply(this, arguments);\r\n        sender._pc = this;\r\n        return sender;\r\n      };\r\n    }\r\n    window.RTCRtpSender.prototype.getStats = function getStats() {\r\n      const sender = this;\r\n      return this._pc.getStats().then(result =>\r\n      /* Note: this will include stats of all senders that\r\n       *   send a track with the same id as sender.track as\r\n       *   it is not possible to identify the RTCRtpSender.\r\n       */\r\n      filterStats(result, sender.track, true));\r\n    };\r\n  }\r\n\r\n  // shim receiver stats.\r\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\r\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\r\n    if (origGetReceivers) {\r\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\r\n        const receivers = origGetReceivers.apply(this, []);\r\n        receivers.forEach(receiver => receiver._pc = this);\r\n        return receivers;\r\n      };\r\n    }\r\n    wrapPeerConnectionEvent(window, 'track', e => {\r\n      e.receiver._pc = e.srcElement;\r\n      return e;\r\n    });\r\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\r\n      const receiver = this;\r\n      return this._pc.getStats().then(result => filterStats(result, receiver.track, false));\r\n    };\r\n  }\r\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\r\n    return;\r\n  }\r\n\r\n  // shim RTCPeerConnection.getStats(track).\r\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\r\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\r\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\r\n      const track = arguments[0];\r\n      let sender;\r\n      let receiver;\r\n      let err;\r\n      this.getSenders().forEach(s => {\r\n        if (s.track === track) {\r\n          if (sender) {\r\n            err = true;\r\n          } else {\r\n            sender = s;\r\n          }\r\n        }\r\n      });\r\n      this.getReceivers().forEach(r => {\r\n        if (r.track === track) {\r\n          if (receiver) {\r\n            err = true;\r\n          } else {\r\n            receiver = r;\r\n          }\r\n        }\r\n        return r.track === track;\r\n      });\r\n      if (err || sender && receiver) {\r\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\r\n      } else if (sender) {\r\n        return sender.getStats();\r\n      } else if (receiver) {\r\n        return receiver.getStats();\r\n      }\r\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\r\n    }\r\n    return origGetStats.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddTrackRemoveTrackWithNative(window) {\r\n  // shim addTrack/removeTrack with native variants in order to make\r\n  // the interactions with legacy getLocalStreams behave as in other browsers.\r\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\r\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\r\n  };\r\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n    if (!stream) {\r\n      return origAddTrack.apply(this, arguments);\r\n    }\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    const sender = origAddTrack.apply(this, arguments);\r\n    if (!this._shimmedLocalStreams[stream.id]) {\r\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\r\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\r\n      this._shimmedLocalStreams[stream.id].push(sender);\r\n    }\r\n    return sender;\r\n  };\r\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    stream.getTracks().forEach(track => {\r\n      const alreadyExists = this.getSenders().find(s => s.track === track);\r\n      if (alreadyExists) {\r\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n      }\r\n    });\r\n    const existingSenders = this.getSenders();\r\n    origAddStream.apply(this, arguments);\r\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\r\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\r\n  };\r\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    delete this._shimmedLocalStreams[stream.id];\r\n    return origRemoveStream.apply(this, arguments);\r\n  };\r\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\r\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\r\n    if (sender) {\r\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\r\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\r\n        if (idx !== -1) {\r\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\r\n        }\r\n        if (this._shimmedLocalStreams[streamId].length === 1) {\r\n          delete this._shimmedLocalStreams[streamId];\r\n        }\r\n      });\r\n    }\r\n    return origRemoveTrack.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  // shim addTrack and removeTrack.\r\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\r\n    return shimAddTrackRemoveTrackWithNative(window);\r\n  }\r\n\r\n  // also shim pc.getLocalStreams when addTrack is shimmed\r\n  // to return the original streams.\r\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\r\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n    const nativeStreams = origGetLocalStreams.apply(this);\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\r\n  };\r\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\r\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    stream.getTracks().forEach(track => {\r\n      const alreadyExists = this.getSenders().find(s => s.track === track);\r\n      if (alreadyExists) {\r\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n      }\r\n    });\r\n    // Add identity mapping for consistency with addTrack.\r\n    // Unless this is being used with a stream from addTrack.\r\n    if (!this._reverseStreams[stream.id]) {\r\n      const newStream = new window.MediaStream(stream.getTracks());\r\n      this._streams[stream.id] = newStream;\r\n      this._reverseStreams[newStream.id] = stream;\r\n      stream = newStream;\r\n    }\r\n    origAddStream.apply(this, [stream]);\r\n  };\r\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\r\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\r\n    delete this._streams[stream.id];\r\n  };\r\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\r\n    if (this.signalingState === 'closed') {\r\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\r\n    }\r\n    const streams = [].slice.call(arguments, 1);\r\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\r\n      // this is not fully correct but all we can manage without\r\n      // [[associated MediaStreams]] internal slot.\r\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\r\n    }\r\n    const alreadyExists = this.getSenders().find(s => s.track === track);\r\n    if (alreadyExists) {\r\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\r\n    }\r\n    this._streams = this._streams || {};\r\n    this._reverseStreams = this._reverseStreams || {};\r\n    const oldStream = this._streams[stream.id];\r\n    if (oldStream) {\r\n      // this is using odd Chrome behaviour, use with caution:\r\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\r\n      // Note: we rely on the high-level addTrack/dtmf shim to\r\n      // create the sender with a dtmf sender.\r\n      oldStream.addTrack(track);\r\n\r\n      // Trigger ONN async.\r\n      Promise.resolve().then(() => {\r\n        this.dispatchEvent(new Event('negotiationneeded'));\r\n      });\r\n    } else {\r\n      const newStream = new window.MediaStream([track]);\r\n      this._streams[stream.id] = newStream;\r\n      this._reverseStreams[newStream.id] = stream;\r\n      this.addStream(newStream);\r\n    }\r\n    return this.getSenders().find(s => s.track === track);\r\n  };\r\n\r\n  // replace the internal stream id with the external one and\r\n  // vice versa.\r\n  function replaceInternalStreamId(pc, description) {\r\n    let sdp = description.sdp;\r\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\r\n      const externalStream = pc._reverseStreams[internalId];\r\n      const internalStream = pc._streams[externalStream.id];\r\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\r\n    });\r\n    return new RTCSessionDescription({\r\n      type: description.type,\r\n      sdp\r\n    });\r\n  }\r\n  function replaceExternalStreamId(pc, description) {\r\n    let sdp = description.sdp;\r\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\r\n      const externalStream = pc._reverseStreams[internalId];\r\n      const internalStream = pc._streams[externalStream.id];\r\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\r\n    });\r\n    return new RTCSessionDescription({\r\n      type: description.type,\r\n      sdp\r\n    });\r\n  }\r\n  ['createOffer', 'createAnswer'].forEach(function (method) {\r\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n    const methodObj = {\r\n      [method]() {\r\n        const args = arguments;\r\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\r\n        if (isLegacyCall) {\r\n          return nativeMethod.apply(this, [description => {\r\n            const desc = replaceInternalStreamId(this, description);\r\n            args[0].apply(null, [desc]);\r\n          }, err => {\r\n            if (args[1]) {\r\n              args[1].apply(null, err);\r\n            }\r\n          }, arguments[2]]);\r\n        }\r\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\r\n      }\r\n    };\r\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n  });\r\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\r\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\r\n    if (!arguments.length || !arguments[0].type) {\r\n      return origSetLocalDescription.apply(this, arguments);\r\n    }\r\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\r\n    return origSetLocalDescription.apply(this, arguments);\r\n  };\r\n\r\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\r\n\r\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\r\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\r\n    get() {\r\n      const description = origLocalDescription.get.apply(this);\r\n      if (description.type === '') {\r\n        return description;\r\n      }\r\n      return replaceInternalStreamId(this, description);\r\n    }\r\n  });\r\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\r\n    if (this.signalingState === 'closed') {\r\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\r\n    }\r\n    // We can not yet check for sender instanceof RTCRtpSender\r\n    // since we shim RTPSender. So we check if sender._pc is set.\r\n    if (!sender._pc) {\r\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\r\n    }\r\n    const isLocal = sender._pc === this;\r\n    if (!isLocal) {\r\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\r\n    }\r\n\r\n    // Search for the native stream the senders track belongs to.\r\n    this._streams = this._streams || {};\r\n    let stream;\r\n    Object.keys(this._streams).forEach(streamid => {\r\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\r\n      if (hasTrack) {\r\n        stream = this._streams[streamid];\r\n      }\r\n    });\r\n    if (stream) {\r\n      if (stream.getTracks().length === 1) {\r\n        // if this is the last track of the stream, remove the stream. This\r\n        // takes care of any shimmed _senders.\r\n        this.removeStream(this._reverseStreams[stream.id]);\r\n      } else {\r\n        // relying on the same odd chrome behaviour as above.\r\n        stream.removeTrack(sender.track);\r\n      }\r\n      this.dispatchEvent(new Event('negotiationneeded'));\r\n    }\r\n  };\r\n}\r\nfunction shimPeerConnection$1(window, browserDetails) {\r\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\r\n    // very basic support for old versions.\r\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\r\n  }\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n\r\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\r\n  if (browserDetails.version < 53) {\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\r\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n      const methodObj = {\r\n        [method]() {\r\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\r\n          return nativeMethod.apply(this, arguments);\r\n        }\r\n      };\r\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n    });\r\n  }\r\n}\r\n\r\n// Attempt to fix ONN in plan-b mode.\r\nfunction fixNegotiationNeeded(window, browserDetails) {\r\n  wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\r\n    const pc = e.target;\r\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\r\n      if (pc.signalingState !== 'stable') {\r\n        return;\r\n      }\r\n    }\r\n    return e;\r\n  });\r\n}\r\n\r\nvar chromeShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  fixNegotiationNeeded: fixNegotiationNeeded,\r\n  shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\r\n  shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\r\n  shimGetSendersWithDtmf: shimGetSendersWithDtmf,\r\n  shimGetUserMedia: shimGetUserMedia$2,\r\n  shimMediaStream: shimMediaStream,\r\n  shimOnTrack: shimOnTrack$1,\r\n  shimPeerConnection: shimPeerConnection$1,\r\n  shimSenderReceiverGetStats: shimSenderReceiverGetStats\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimGetUserMedia$1(window, browserDetails) {\r\n  const navigator = window && window.navigator;\r\n  const MediaStreamTrack = window && window.MediaStreamTrack;\r\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\r\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\r\n    deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\r\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\r\n  };\r\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\r\n    const remap = function (obj, a, b) {\r\n      if (a in obj && !(b in obj)) {\r\n        obj[b] = obj[a];\r\n        delete obj[a];\r\n      }\r\n    };\r\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = function (c) {\r\n      if (typeof c === 'object' && typeof c.audio === 'object') {\r\n        c = JSON.parse(JSON.stringify(c));\r\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\r\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\r\n      }\r\n      return nativeGetUserMedia(c);\r\n    };\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\r\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\r\n      MediaStreamTrack.prototype.getSettings = function () {\r\n        const obj = nativeGetSettings.apply(this, arguments);\r\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\r\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\r\n        return obj;\r\n      };\r\n    }\r\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\r\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\r\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\r\n        if (this.kind === 'audio' && typeof c === 'object') {\r\n          c = JSON.parse(JSON.stringify(c));\r\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\r\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\r\n        }\r\n        return nativeApplyConstraints.apply(this, [c]);\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\r\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  if (!window.navigator.mediaDevices) {\r\n    return;\r\n  }\r\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\r\n    if (!(constraints && constraints.video)) {\r\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\r\n      err.name = 'NotFoundError';\r\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\r\n      err.code = 8;\r\n      return Promise.reject(err);\r\n    }\r\n    if (constraints.video === true) {\r\n      constraints.video = {\r\n        mediaSource: preferredMediaSource\r\n      };\r\n    } else {\r\n      constraints.video.mediaSource = preferredMediaSource;\r\n    }\r\n    return window.navigator.mediaDevices.getUserMedia(constraints);\r\n  };\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimOnTrack(window) {\r\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\r\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n      get() {\r\n        return {\r\n          receiver: this.receiver\r\n        };\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimPeerConnection(window, browserDetails) {\r\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\r\n    return; // probably media.peerconnection.enabled=false in about:config\r\n  }\r\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\r\n    // very basic support for old versions.\r\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\r\n  }\r\n  if (browserDetails.version < 53) {\r\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\r\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\r\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\r\n      const methodObj = {\r\n        [method]() {\r\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\r\n          return nativeMethod.apply(this, arguments);\r\n        }\r\n      };\r\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\r\n    });\r\n  }\r\n  const modernStatsTypes = {\r\n    inboundrtp: 'inbound-rtp',\r\n    outboundrtp: 'outbound-rtp',\r\n    candidatepair: 'candidate-pair',\r\n    localcandidate: 'local-candidate',\r\n    remotecandidate: 'remote-candidate'\r\n  };\r\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\r\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\r\n    const [selector, onSucc, onErr] = arguments;\r\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\r\n      if (browserDetails.version < 53 && !onSucc) {\r\n        // Shim only promise getStats with spec-hyphens in type names\r\n        // Leave callback version alone; misc old uses of forEach before Map\r\n        try {\r\n          stats.forEach(stat => {\r\n            stat.type = modernStatsTypes[stat.type] || stat.type;\r\n          });\r\n        } catch (e) {\r\n          if (e.name !== 'TypeError') {\r\n            throw e;\r\n          }\r\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\r\n          stats.forEach((stat, i) => {\r\n            stats.set(i, Object.assign({}, stat, {\r\n              type: modernStatsTypes[stat.type] || stat.type\r\n            }));\r\n          });\r\n        }\r\n      }\r\n      return stats;\r\n    }).then(onSucc, onErr);\r\n  };\r\n}\r\nfunction shimSenderGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\r\n    return;\r\n  }\r\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\r\n  if (origGetSenders) {\r\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\r\n      const senders = origGetSenders.apply(this, []);\r\n      senders.forEach(sender => sender._pc = this);\r\n      return senders;\r\n    };\r\n  }\r\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\r\n  if (origAddTrack) {\r\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\r\n      const sender = origAddTrack.apply(this, arguments);\r\n      sender._pc = this;\r\n      return sender;\r\n    };\r\n  }\r\n  window.RTCRtpSender.prototype.getStats = function getStats() {\r\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\r\n  };\r\n}\r\nfunction shimReceiverGetStats(window) {\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\r\n    return;\r\n  }\r\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\r\n  if (origGetReceivers) {\r\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\r\n      const receivers = origGetReceivers.apply(this, []);\r\n      receivers.forEach(receiver => receiver._pc = this);\r\n      return receivers;\r\n    };\r\n  }\r\n  wrapPeerConnectionEvent(window, 'track', e => {\r\n    e.receiver._pc = e.srcElement;\r\n    return e;\r\n  });\r\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\r\n    return this._pc.getStats(this.track);\r\n  };\r\n}\r\nfunction shimRemoveStream(window) {\r\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n    deprecated('removeStream', 'removeTrack');\r\n    this.getSenders().forEach(sender => {\r\n      if (sender.track && stream.getTracks().includes(sender.track)) {\r\n        this.removeTrack(sender);\r\n      }\r\n    });\r\n  };\r\n}\r\nfunction shimRTCDataChannel(window) {\r\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\r\n  if (window.DataChannel && !window.RTCDataChannel) {\r\n    window.RTCDataChannel = window.DataChannel;\r\n  }\r\n}\r\nfunction shimAddTransceiver(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\r\n  if (origAddTransceiver) {\r\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\r\n      this.setParametersPromises = [];\r\n      // WebIDL input coercion and validation\r\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\r\n      if (sendEncodings === undefined) {\r\n        sendEncodings = [];\r\n      }\r\n      sendEncodings = [...sendEncodings];\r\n      const shouldPerformCheck = sendEncodings.length > 0;\r\n      if (shouldPerformCheck) {\r\n        // If sendEncodings params are provided, validate grammar\r\n        sendEncodings.forEach(encodingParam => {\r\n          if ('rid' in encodingParam) {\r\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\r\n            if (!ridRegex.test(encodingParam.rid)) {\r\n              throw new TypeError('Invalid RID value provided.');\r\n            }\r\n          }\r\n          if ('scaleResolutionDownBy' in encodingParam) {\r\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\r\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\r\n            }\r\n          }\r\n          if ('maxFramerate' in encodingParam) {\r\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\r\n              throw new RangeError('max_framerate must be >= 0.0');\r\n            }\r\n          }\r\n        });\r\n      }\r\n      const transceiver = origAddTransceiver.apply(this, arguments);\r\n      if (shouldPerformCheck) {\r\n        // Check if the init options were applied. If not we do this in an\r\n        // asynchronous way and save the promise reference in a global object.\r\n        // This is an ugly hack, but at the same time is way more robust than\r\n        // checking the sender parameters before and after the createOffer\r\n        // Also note that after the createoffer we are not 100% sure that\r\n        // the params were asynchronously applied so we might miss the\r\n        // opportunity to recreate offer.\r\n        const {\r\n          sender\r\n        } = transceiver;\r\n        const params = sender.getParameters();\r\n        if (!('encodings' in params) ||\r\n        // Avoid being fooled by patched getParameters() below.\r\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\r\n          params.encodings = sendEncodings;\r\n          sender.sendEncodings = sendEncodings;\r\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\r\n            delete sender.sendEncodings;\r\n          }).catch(() => {\r\n            delete sender.sendEncodings;\r\n          }));\r\n        }\r\n      }\r\n      return transceiver;\r\n    };\r\n  }\r\n}\r\nfunction shimGetParameters(window) {\r\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\r\n    return;\r\n  }\r\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\r\n  if (origGetParameters) {\r\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\r\n      const params = origGetParameters.apply(this, arguments);\r\n      if (!('encodings' in params)) {\r\n        params.encodings = [].concat(this.sendEncodings || [{}]);\r\n      }\r\n      return params;\r\n    };\r\n  }\r\n}\r\nfunction shimCreateOffer(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\r\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\r\n    if (this.setParametersPromises && this.setParametersPromises.length) {\r\n      return Promise.all(this.setParametersPromises).then(() => {\r\n        return origCreateOffer.apply(this, arguments);\r\n      }).finally(() => {\r\n        this.setParametersPromises = [];\r\n      });\r\n    }\r\n    return origCreateOffer.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimCreateAnswer(window) {\r\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\r\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\r\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\r\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\r\n    return;\r\n  }\r\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\r\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\r\n    if (this.setParametersPromises && this.setParametersPromises.length) {\r\n      return Promise.all(this.setParametersPromises).then(() => {\r\n        return origCreateAnswer.apply(this, arguments);\r\n      }).finally(() => {\r\n        this.setParametersPromises = [];\r\n      });\r\n    }\r\n    return origCreateAnswer.apply(this, arguments);\r\n  };\r\n}\r\n\r\nvar firefoxShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  shimAddTransceiver: shimAddTransceiver,\r\n  shimCreateAnswer: shimCreateAnswer,\r\n  shimCreateOffer: shimCreateOffer,\r\n  shimGetDisplayMedia: shimGetDisplayMedia,\r\n  shimGetParameters: shimGetParameters,\r\n  shimGetUserMedia: shimGetUserMedia$1,\r\n  shimOnTrack: shimOnTrack,\r\n  shimPeerConnection: shimPeerConnection,\r\n  shimRTCDataChannel: shimRTCDataChannel,\r\n  shimReceiverGetStats: shimReceiverGetStats,\r\n  shimRemoveStream: shimRemoveStream,\r\n  shimSenderGetStats: shimSenderGetStats\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\nfunction shimLocalStreamsAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      return this._localStreams;\r\n    };\r\n  }\r\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\r\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\r\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      if (!this._localStreams.includes(stream)) {\r\n        this._localStreams.push(stream);\r\n      }\r\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\r\n      // Safari orders by track id.\r\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\r\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\r\n    };\r\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\r\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n        streams[_key - 1] = arguments[_key];\r\n      }\r\n      if (streams) {\r\n        streams.forEach(stream => {\r\n          if (!this._localStreams) {\r\n            this._localStreams = [stream];\r\n          } else if (!this._localStreams.includes(stream)) {\r\n            this._localStreams.push(stream);\r\n          }\r\n        });\r\n      }\r\n      return _addTrack.apply(this, arguments);\r\n    };\r\n  }\r\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\r\n      if (!this._localStreams) {\r\n        this._localStreams = [];\r\n      }\r\n      const index = this._localStreams.indexOf(stream);\r\n      if (index === -1) {\r\n        return;\r\n      }\r\n      this._localStreams.splice(index, 1);\r\n      const tracks = stream.getTracks();\r\n      this.getSenders().forEach(sender => {\r\n        if (tracks.includes(sender.track)) {\r\n          this.removeTrack(sender);\r\n        }\r\n      });\r\n    };\r\n  }\r\n}\r\nfunction shimRemoteStreamsAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\r\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\r\n      return this._remoteStreams ? this._remoteStreams : [];\r\n    };\r\n  }\r\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\r\n      get() {\r\n        return this._onaddstream;\r\n      },\r\n      set(f) {\r\n        if (this._onaddstream) {\r\n          this.removeEventListener('addstream', this._onaddstream);\r\n          this.removeEventListener('track', this._onaddstreampoly);\r\n        }\r\n        this.addEventListener('addstream', this._onaddstream = f);\r\n        this.addEventListener('track', this._onaddstreampoly = e => {\r\n          e.streams.forEach(stream => {\r\n            if (!this._remoteStreams) {\r\n              this._remoteStreams = [];\r\n            }\r\n            if (this._remoteStreams.includes(stream)) {\r\n              return;\r\n            }\r\n            this._remoteStreams.push(stream);\r\n            const event = new Event('addstream');\r\n            event.stream = stream;\r\n            this.dispatchEvent(event);\r\n          });\r\n        });\r\n      }\r\n    });\r\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n      const pc = this;\r\n      if (!this._onaddstreampoly) {\r\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\r\n          e.streams.forEach(stream => {\r\n            if (!pc._remoteStreams) {\r\n              pc._remoteStreams = [];\r\n            }\r\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\r\n              return;\r\n            }\r\n            pc._remoteStreams.push(stream);\r\n            const event = new Event('addstream');\r\n            event.stream = stream;\r\n            pc.dispatchEvent(event);\r\n          });\r\n        });\r\n      }\r\n      return origSetRemoteDescription.apply(pc, arguments);\r\n    };\r\n  }\r\n}\r\nfunction shimCallbacksAPI(window) {\r\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  const prototype = window.RTCPeerConnection.prototype;\r\n  const origCreateOffer = prototype.createOffer;\r\n  const origCreateAnswer = prototype.createAnswer;\r\n  const setLocalDescription = prototype.setLocalDescription;\r\n  const setRemoteDescription = prototype.setRemoteDescription;\r\n  const addIceCandidate = prototype.addIceCandidate;\r\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\r\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\r\n    const promise = origCreateOffer.apply(this, [options]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\r\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\r\n    const promise = origCreateAnswer.apply(this, [options]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  let withCallback = function (description, successCallback, failureCallback) {\r\n    const promise = setLocalDescription.apply(this, [description]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.setLocalDescription = withCallback;\r\n  withCallback = function (description, successCallback, failureCallback) {\r\n    const promise = setRemoteDescription.apply(this, [description]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.setRemoteDescription = withCallback;\r\n  withCallback = function (candidate, successCallback, failureCallback) {\r\n    const promise = addIceCandidate.apply(this, [candidate]);\r\n    if (!failureCallback) {\r\n      return promise;\r\n    }\r\n    promise.then(successCallback, failureCallback);\r\n    return Promise.resolve();\r\n  };\r\n  prototype.addIceCandidate = withCallback;\r\n}\r\nfunction shimGetUserMedia(window) {\r\n  const navigator = window && window.navigator;\r\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n    // shim not needed in Safari 12.1\r\n    const mediaDevices = navigator.mediaDevices;\r\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\r\n    navigator.mediaDevices.getUserMedia = constraints => {\r\n      return _getUserMedia(shimConstraints(constraints));\r\n    };\r\n  }\r\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\r\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\r\n    }.bind(navigator);\r\n  }\r\n}\r\nfunction shimConstraints(constraints) {\r\n  if (constraints && constraints.video !== undefined) {\r\n    return Object.assign({}, constraints, {\r\n      video: compactObject(constraints.video)\r\n    });\r\n  }\r\n  return constraints;\r\n}\r\nfunction shimRTCIceServerUrls(window) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\r\n  const OrigPeerConnection = window.RTCPeerConnection;\r\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\r\n    if (pcConfig && pcConfig.iceServers) {\r\n      const newIceServers = [];\r\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\r\n        let server = pcConfig.iceServers[i];\r\n        if (server.urls === undefined && server.url) {\r\n          deprecated('RTCIceServer.url', 'RTCIceServer.urls');\r\n          server = JSON.parse(JSON.stringify(server));\r\n          server.urls = server.url;\r\n          delete server.url;\r\n          newIceServers.push(server);\r\n        } else {\r\n          newIceServers.push(pcConfig.iceServers[i]);\r\n        }\r\n      }\r\n      pcConfig.iceServers = newIceServers;\r\n    }\r\n    return new OrigPeerConnection(pcConfig, pcConstraints);\r\n  };\r\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\r\n  // wrap static methods. Currently just generateCertificate.\r\n  if ('generateCertificate' in OrigPeerConnection) {\r\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\r\n      get() {\r\n        return OrigPeerConnection.generateCertificate;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimTrackEventTransceiver(window) {\r\n  // Add event.transceiver member over deprecated event.receiver\r\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\r\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\r\n      get() {\r\n        return {\r\n          receiver: this.receiver\r\n        };\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction shimCreateOfferLegacy(window) {\r\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\r\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\r\n    if (offerOptions) {\r\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\r\n        // support bit values\r\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\r\n      }\r\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\r\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\r\n        if (audioTransceiver.direction === 'sendrecv') {\r\n          if (audioTransceiver.setDirection) {\r\n            audioTransceiver.setDirection('sendonly');\r\n          } else {\r\n            audioTransceiver.direction = 'sendonly';\r\n          }\r\n        } else if (audioTransceiver.direction === 'recvonly') {\r\n          if (audioTransceiver.setDirection) {\r\n            audioTransceiver.setDirection('inactive');\r\n          } else {\r\n            audioTransceiver.direction = 'inactive';\r\n          }\r\n        }\r\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\r\n        this.addTransceiver('audio', {\r\n          direction: 'recvonly'\r\n        });\r\n      }\r\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\r\n        // support bit values\r\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\r\n      }\r\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\r\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\r\n        if (videoTransceiver.direction === 'sendrecv') {\r\n          if (videoTransceiver.setDirection) {\r\n            videoTransceiver.setDirection('sendonly');\r\n          } else {\r\n            videoTransceiver.direction = 'sendonly';\r\n          }\r\n        } else if (videoTransceiver.direction === 'recvonly') {\r\n          if (videoTransceiver.setDirection) {\r\n            videoTransceiver.setDirection('inactive');\r\n          } else {\r\n            videoTransceiver.direction = 'inactive';\r\n          }\r\n        }\r\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\r\n        this.addTransceiver('video', {\r\n          direction: 'recvonly'\r\n        });\r\n      }\r\n    }\r\n    return origCreateOffer.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAudioContext(window) {\r\n  if (typeof window !== 'object' || window.AudioContext) {\r\n    return;\r\n  }\r\n  window.AudioContext = window.webkitAudioContext;\r\n}\r\n\r\nvar safariShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  shimAudioContext: shimAudioContext,\r\n  shimCallbacksAPI: shimCallbacksAPI,\r\n  shimConstraints: shimConstraints,\r\n  shimCreateOfferLegacy: shimCreateOfferLegacy,\r\n  shimGetUserMedia: shimGetUserMedia,\r\n  shimLocalStreamsAPI: shimLocalStreamsAPI,\r\n  shimRTCIceServerUrls: shimRTCIceServerUrls,\r\n  shimRemoteStreamsAPI: shimRemoteStreamsAPI,\r\n  shimTrackEventTransceiver: shimTrackEventTransceiver\r\n});\r\n\r\nvar sdp$1 = {exports: {}};\r\n\r\n/* eslint-env node */\r\nvar hasRequiredSdp;\r\nfunction requireSdp() {\r\n  if (hasRequiredSdp) return sdp$1.exports;\r\n  hasRequiredSdp = 1;\r\n  (function (module) {\r\n\r\n    // SDP helpers.\r\n    const SDPUtils = {};\r\n\r\n    // Generate an alphanumeric identifier for cname or mids.\r\n    // TODO: use UUIDs instead? https://gist.github.com/jed/982883\r\n    SDPUtils.generateIdentifier = function () {\r\n      return Math.random().toString(36).substring(2, 12);\r\n    };\r\n\r\n    // The RTCP CNAME used by all peerconnections from the same JS.\r\n    SDPUtils.localCName = SDPUtils.generateIdentifier();\r\n\r\n    // Splits SDP into lines, dealing with both CRLF and LF.\r\n    SDPUtils.splitLines = function (blob) {\r\n      return blob.trim().split('\\n').map(line => line.trim());\r\n    };\r\n    // Splits SDP into sessionpart and mediasections. Ensures CRLF.\r\n    SDPUtils.splitSections = function (blob) {\r\n      const parts = blob.split('\\nm=');\r\n      return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\r\n    };\r\n\r\n    // Returns the session description.\r\n    SDPUtils.getDescription = function (blob) {\r\n      const sections = SDPUtils.splitSections(blob);\r\n      return sections && sections[0];\r\n    };\r\n\r\n    // Returns the individual media sections.\r\n    SDPUtils.getMediaSections = function (blob) {\r\n      const sections = SDPUtils.splitSections(blob);\r\n      sections.shift();\r\n      return sections;\r\n    };\r\n\r\n    // Returns lines that start with a certain prefix.\r\n    SDPUtils.matchPrefix = function (blob, prefix) {\r\n      return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\r\n    };\r\n\r\n    // Parses an ICE candidate line. Sample input:\r\n    // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\r\n    // rport 55996\"\r\n    // Input can be prefixed with a=.\r\n    SDPUtils.parseCandidate = function (line) {\r\n      let parts;\r\n      // Parse both variants.\r\n      if (line.indexOf('a=candidate:') === 0) {\r\n        parts = line.substring(12).split(' ');\r\n      } else {\r\n        parts = line.substring(10).split(' ');\r\n      }\r\n      const candidate = {\r\n        foundation: parts[0],\r\n        component: {\r\n          1: 'rtp',\r\n          2: 'rtcp'\r\n        }[parts[1]] || parts[1],\r\n        protocol: parts[2].toLowerCase(),\r\n        priority: parseInt(parts[3], 10),\r\n        ip: parts[4],\r\n        address: parts[4],\r\n        // address is an alias for ip.\r\n        port: parseInt(parts[5], 10),\r\n        // skip parts[6] == 'typ'\r\n        type: parts[7]\r\n      };\r\n      for (let i = 8; i < parts.length; i += 2) {\r\n        switch (parts[i]) {\r\n          case 'raddr':\r\n            candidate.relatedAddress = parts[i + 1];\r\n            break;\r\n          case 'rport':\r\n            candidate.relatedPort = parseInt(parts[i + 1], 10);\r\n            break;\r\n          case 'tcptype':\r\n            candidate.tcpType = parts[i + 1];\r\n            break;\r\n          case 'ufrag':\r\n            candidate.ufrag = parts[i + 1]; // for backward compatibility.\r\n            candidate.usernameFragment = parts[i + 1];\r\n            break;\r\n          default:\r\n            // extension handling, in particular ufrag. Don't overwrite.\r\n            if (candidate[parts[i]] === undefined) {\r\n              candidate[parts[i]] = parts[i + 1];\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      return candidate;\r\n    };\r\n\r\n    // Translates a candidate object into SDP candidate attribute.\r\n    // This does not include the a= prefix!\r\n    SDPUtils.writeCandidate = function (candidate) {\r\n      const sdp = [];\r\n      sdp.push(candidate.foundation);\r\n      const component = candidate.component;\r\n      if (component === 'rtp') {\r\n        sdp.push(1);\r\n      } else if (component === 'rtcp') {\r\n        sdp.push(2);\r\n      } else {\r\n        sdp.push(component);\r\n      }\r\n      sdp.push(candidate.protocol.toUpperCase());\r\n      sdp.push(candidate.priority);\r\n      sdp.push(candidate.address || candidate.ip);\r\n      sdp.push(candidate.port);\r\n      const type = candidate.type;\r\n      sdp.push('typ');\r\n      sdp.push(type);\r\n      if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\r\n        sdp.push('raddr');\r\n        sdp.push(candidate.relatedAddress);\r\n        sdp.push('rport');\r\n        sdp.push(candidate.relatedPort);\r\n      }\r\n      if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\r\n        sdp.push('tcptype');\r\n        sdp.push(candidate.tcpType);\r\n      }\r\n      if (candidate.usernameFragment || candidate.ufrag) {\r\n        sdp.push('ufrag');\r\n        sdp.push(candidate.usernameFragment || candidate.ufrag);\r\n      }\r\n      return 'candidate:' + sdp.join(' ');\r\n    };\r\n\r\n    // Parses an ice-options line, returns an array of option tags.\r\n    // Sample input:\r\n    // a=ice-options:foo bar\r\n    SDPUtils.parseIceOptions = function (line) {\r\n      return line.substring(14).split(' ');\r\n    };\r\n\r\n    // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\r\n    // a=rtpmap:111 opus/48000/2\r\n    SDPUtils.parseRtpMap = function (line) {\r\n      let parts = line.substring(9).split(' ');\r\n      const parsed = {\r\n        payloadType: parseInt(parts.shift(), 10) // was: id\r\n      };\r\n      parts = parts[0].split('/');\r\n      parsed.name = parts[0];\r\n      parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\r\n      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\r\n      // legacy alias, got renamed back to channels in ORTC.\r\n      parsed.numChannels = parsed.channels;\r\n      return parsed;\r\n    };\r\n\r\n    // Generates a rtpmap line from RTCRtpCodecCapability or\r\n    // RTCRtpCodecParameters.\r\n    SDPUtils.writeRtpMap = function (codec) {\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      const channels = codec.channels || codec.numChannels || 1;\r\n      return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses a extmap line (headerextension from RFC 5285). Sample input:\r\n    // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n    // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\r\n    SDPUtils.parseExtmap = function (line) {\r\n      const parts = line.substring(9).split(' ');\r\n      return {\r\n        id: parseInt(parts[0], 10),\r\n        direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\r\n        uri: parts[1],\r\n        attributes: parts.slice(2).join(' ')\r\n      };\r\n    };\r\n\r\n    // Generates an extmap line from RTCRtpHeaderExtensionParameters or\r\n    // RTCRtpHeaderExtension.\r\n    SDPUtils.writeExtmap = function (headerExtension) {\r\n      return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses a fmtp line, returns dictionary. Sample input:\r\n    // a=fmtp:96 vbr=on;cng=on\r\n    // Also deals with vbr=on; cng=on\r\n    SDPUtils.parseFmtp = function (line) {\r\n      const parsed = {};\r\n      let kv;\r\n      const parts = line.substring(line.indexOf(' ') + 1).split(';');\r\n      for (let j = 0; j < parts.length; j++) {\r\n        kv = parts[j].trim().split('=');\r\n        parsed[kv[0].trim()] = kv[1];\r\n      }\r\n      return parsed;\r\n    };\r\n\r\n    // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\r\n    SDPUtils.writeFmtp = function (codec) {\r\n      let line = '';\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      if (codec.parameters && Object.keys(codec.parameters).length) {\r\n        const params = [];\r\n        Object.keys(codec.parameters).forEach(param => {\r\n          if (codec.parameters[param] !== undefined) {\r\n            params.push(param + '=' + codec.parameters[param]);\r\n          } else {\r\n            params.push(param);\r\n          }\r\n        });\r\n        line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\r\n      }\r\n      return line;\r\n    };\r\n\r\n    // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\r\n    // a=rtcp-fb:98 nack rpsi\r\n    SDPUtils.parseRtcpFb = function (line) {\r\n      const parts = line.substring(line.indexOf(' ') + 1).split(' ');\r\n      return {\r\n        type: parts.shift(),\r\n        parameter: parts.join(' ')\r\n      };\r\n    };\r\n\r\n    // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\r\n    SDPUtils.writeRtcpFb = function (codec) {\r\n      let lines = '';\r\n      let pt = codec.payloadType;\r\n      if (codec.preferredPayloadType !== undefined) {\r\n        pt = codec.preferredPayloadType;\r\n      }\r\n      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\r\n        // FIXME: special handling for trr-int?\r\n        codec.rtcpFeedback.forEach(fb => {\r\n          lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\r\n        });\r\n      }\r\n      return lines;\r\n    };\r\n\r\n    // Parses a RFC 5576 ssrc media attribute. Sample input:\r\n    // a=ssrc:3735928559 cname:something\r\n    SDPUtils.parseSsrcMedia = function (line) {\r\n      const sp = line.indexOf(' ');\r\n      const parts = {\r\n        ssrc: parseInt(line.substring(7, sp), 10)\r\n      };\r\n      const colon = line.indexOf(':', sp);\r\n      if (colon > -1) {\r\n        parts.attribute = line.substring(sp + 1, colon);\r\n        parts.value = line.substring(colon + 1);\r\n      } else {\r\n        parts.attribute = line.substring(sp + 1);\r\n      }\r\n      return parts;\r\n    };\r\n\r\n    // Parse a ssrc-group line (see RFC 5576). Sample input:\r\n    // a=ssrc-group:semantics 12 34\r\n    SDPUtils.parseSsrcGroup = function (line) {\r\n      const parts = line.substring(13).split(' ');\r\n      return {\r\n        semantics: parts.shift(),\r\n        ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\r\n      };\r\n    };\r\n\r\n    // Extracts the MID (RFC 5888) from a media section.\r\n    // Returns the MID or undefined if no mid line was found.\r\n    SDPUtils.getMid = function (mediaSection) {\r\n      const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\r\n      if (mid) {\r\n        return mid.substring(6);\r\n      }\r\n    };\r\n\r\n    // Parses a fingerprint line for DTLS-SRTP.\r\n    SDPUtils.parseFingerprint = function (line) {\r\n      const parts = line.substring(14).split(' ');\r\n      return {\r\n        algorithm: parts[0].toLowerCase(),\r\n        // algorithm is case-sensitive in Edge.\r\n        value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\r\n      };\r\n    };\r\n\r\n    // Extracts DTLS parameters from SDP media section or sessionpart.\r\n    // FIXME: for consistency with other functions this should only\r\n    //   get the fingerprint line as input. See also getIceParameters.\r\n    SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\r\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\r\n      // Note: a=setup line is ignored since we use the 'auto' role in Edge.\r\n      return {\r\n        role: 'auto',\r\n        fingerprints: lines.map(SDPUtils.parseFingerprint)\r\n      };\r\n    };\r\n\r\n    // Serializes DTLS parameters to SDP.\r\n    SDPUtils.writeDtlsParameters = function (params, setupType) {\r\n      let sdp = 'a=setup:' + setupType + '\\r\\n';\r\n      params.fingerprints.forEach(fp => {\r\n        sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\r\n      });\r\n      return sdp;\r\n    };\r\n\r\n    // Parses a=crypto lines into\r\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\r\n    SDPUtils.parseCryptoLine = function (line) {\r\n      const parts = line.substring(9).split(' ');\r\n      return {\r\n        tag: parseInt(parts[0], 10),\r\n        cryptoSuite: parts[1],\r\n        keyParams: parts[2],\r\n        sessionParams: parts.slice(3)\r\n      };\r\n    };\r\n    SDPUtils.writeCryptoLine = function (parameters) {\r\n      return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\r\n    };\r\n\r\n    // Parses the crypto key parameters into\r\n    //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\r\n    SDPUtils.parseCryptoKeyParams = function (keyParams) {\r\n      if (keyParams.indexOf('inline:') !== 0) {\r\n        return null;\r\n      }\r\n      const parts = keyParams.substring(7).split('|');\r\n      return {\r\n        keyMethod: 'inline',\r\n        keySalt: parts[0],\r\n        lifeTime: parts[1],\r\n        mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\r\n        mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\r\n      };\r\n    };\r\n    SDPUtils.writeCryptoKeyParams = function (keyParams) {\r\n      return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\r\n    };\r\n\r\n    // Extracts all SDES parameters.\r\n    SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\r\n      const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\r\n      return lines.map(SDPUtils.parseCryptoLine);\r\n    };\r\n\r\n    // Parses ICE information from SDP media section or sessionpart.\r\n    // FIXME: for consistency with other functions this should only\r\n    //   get the ice-ufrag and ice-pwd lines as input.\r\n    SDPUtils.getIceParameters = function (mediaSection, sessionpart) {\r\n      const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\r\n      const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\r\n      if (!(ufrag && pwd)) {\r\n        return null;\r\n      }\r\n      return {\r\n        usernameFragment: ufrag.substring(12),\r\n        password: pwd.substring(10)\r\n      };\r\n    };\r\n\r\n    // Serializes ICE parameters to SDP.\r\n    SDPUtils.writeIceParameters = function (params) {\r\n      let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\r\n      if (params.iceLite) {\r\n        sdp += 'a=ice-lite\\r\\n';\r\n      }\r\n      return sdp;\r\n    };\r\n\r\n    // Parses the SDP media section and returns RTCRtpParameters.\r\n    SDPUtils.parseRtpParameters = function (mediaSection) {\r\n      const description = {\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        fecMechanisms: [],\r\n        rtcp: []\r\n      };\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const mline = lines[0].split(' ');\r\n      description.profile = mline[2];\r\n      for (let i = 3; i < mline.length; i++) {\r\n        // find all codecs from mline[3..]\r\n        const pt = mline[i];\r\n        const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\r\n        if (rtpmapline) {\r\n          const codec = SDPUtils.parseRtpMap(rtpmapline);\r\n          const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\r\n          // Only the first a=fmtp:<pt> is considered.\r\n          codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\r\n          codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\r\n          description.codecs.push(codec);\r\n          // parse FEC mechanisms from rtpmap lines.\r\n          switch (codec.name.toUpperCase()) {\r\n            case 'RED':\r\n            case 'ULPFEC':\r\n              description.fecMechanisms.push(codec.name.toUpperCase());\r\n              break;\r\n          }\r\n        }\r\n      }\r\n      SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\r\n        description.headerExtensions.push(SDPUtils.parseExtmap(line));\r\n      });\r\n      const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\r\n      description.codecs.forEach(codec => {\r\n        wildcardRtcpFb.forEach(fb => {\r\n          const duplicate = codec.rtcpFeedback.find(existingFeedback => {\r\n            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\r\n          });\r\n          if (!duplicate) {\r\n            codec.rtcpFeedback.push(fb);\r\n          }\r\n        });\r\n      });\r\n      // FIXME: parse rtcp.\r\n      return description;\r\n    };\r\n\r\n    // Generates parts of the SDP media section describing the capabilities /\r\n    // parameters.\r\n    SDPUtils.writeRtpDescription = function (kind, caps) {\r\n      let sdp = '';\r\n\r\n      // Build the mline.\r\n      sdp += 'm=' + kind + ' ';\r\n      sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\r\n      sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\r\n      sdp += caps.codecs.map(codec => {\r\n        if (codec.preferredPayloadType !== undefined) {\r\n          return codec.preferredPayloadType;\r\n        }\r\n        return codec.payloadType;\r\n      }).join(' ') + '\\r\\n';\r\n      sdp += 'c=IN IP4 0.0.0.0\\r\\n';\r\n      sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\r\n\r\n      // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\r\n      caps.codecs.forEach(codec => {\r\n        sdp += SDPUtils.writeRtpMap(codec);\r\n        sdp += SDPUtils.writeFmtp(codec);\r\n        sdp += SDPUtils.writeRtcpFb(codec);\r\n      });\r\n      let maxptime = 0;\r\n      caps.codecs.forEach(codec => {\r\n        if (codec.maxptime > maxptime) {\r\n          maxptime = codec.maxptime;\r\n        }\r\n      });\r\n      if (maxptime > 0) {\r\n        sdp += 'a=maxptime:' + maxptime + '\\r\\n';\r\n      }\r\n      if (caps.headerExtensions) {\r\n        caps.headerExtensions.forEach(extension => {\r\n          sdp += SDPUtils.writeExtmap(extension);\r\n        });\r\n      }\r\n      // FIXME: write fecMechanisms.\r\n      return sdp;\r\n    };\r\n\r\n    // Parses the SDP media section and returns an array of\r\n    // RTCRtpEncodingParameters.\r\n    SDPUtils.parseRtpEncodingParameters = function (mediaSection) {\r\n      const encodingParameters = [];\r\n      const description = SDPUtils.parseRtpParameters(mediaSection);\r\n      const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\r\n      const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\r\n\r\n      // filter a=ssrc:... cname:, ignore PlanB-msid\r\n      const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\r\n      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\r\n      let secondarySsrc;\r\n      const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\r\n        const parts = line.substring(17).split(' ');\r\n        return parts.map(part => parseInt(part, 10));\r\n      });\r\n      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\r\n        secondarySsrc = flows[0][1];\r\n      }\r\n      description.codecs.forEach(codec => {\r\n        if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\r\n          let encParam = {\r\n            ssrc: primarySsrc,\r\n            codecPayloadType: parseInt(codec.parameters.apt, 10)\r\n          };\r\n          if (primarySsrc && secondarySsrc) {\r\n            encParam.rtx = {\r\n              ssrc: secondarySsrc\r\n            };\r\n          }\r\n          encodingParameters.push(encParam);\r\n          if (hasRed) {\r\n            encParam = JSON.parse(JSON.stringify(encParam));\r\n            encParam.fec = {\r\n              ssrc: primarySsrc,\r\n              mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\r\n            };\r\n            encodingParameters.push(encParam);\r\n          }\r\n        }\r\n      });\r\n      if (encodingParameters.length === 0 && primarySsrc) {\r\n        encodingParameters.push({\r\n          ssrc: primarySsrc\r\n        });\r\n      }\r\n\r\n      // we support both b=AS and b=TIAS but interpret AS as TIAS.\r\n      let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\r\n      if (bandwidth.length) {\r\n        if (bandwidth[0].indexOf('b=TIAS:') === 0) {\r\n          bandwidth = parseInt(bandwidth[0].substring(7), 10);\r\n        } else if (bandwidth[0].indexOf('b=AS:') === 0) {\r\n          // use formula from JSEP to convert b=AS to TIAS value.\r\n          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\r\n        } else {\r\n          bandwidth = undefined;\r\n        }\r\n        encodingParameters.forEach(params => {\r\n          params.maxBitrate = bandwidth;\r\n        });\r\n      }\r\n      return encodingParameters;\r\n    };\r\n\r\n    // parses http://draft.ortc.org/#rtcrtcpparameters*\r\n    SDPUtils.parseRtcpParameters = function (mediaSection) {\r\n      const rtcpParameters = {};\r\n\r\n      // Gets the first SSRC. Note that with RTX there might be multiple\r\n      // SSRCs.\r\n      const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\r\n      if (remoteSsrc) {\r\n        rtcpParameters.cname = remoteSsrc.value;\r\n        rtcpParameters.ssrc = remoteSsrc.ssrc;\r\n      }\r\n\r\n      // Edge uses the compound attribute instead of reducedSize\r\n      // compound is !reducedSize\r\n      const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\r\n      rtcpParameters.reducedSize = rsize.length > 0;\r\n      rtcpParameters.compound = rsize.length === 0;\r\n\r\n      // parses the rtcp-mux attrіbute.\r\n      // Note that Edge does not support unmuxed RTCP.\r\n      const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\r\n      rtcpParameters.mux = mux.length > 0;\r\n      return rtcpParameters;\r\n    };\r\n    SDPUtils.writeRtcpParameters = function (rtcpParameters) {\r\n      let sdp = '';\r\n      if (rtcpParameters.reducedSize) {\r\n        sdp += 'a=rtcp-rsize\\r\\n';\r\n      }\r\n      if (rtcpParameters.mux) {\r\n        sdp += 'a=rtcp-mux\\r\\n';\r\n      }\r\n      if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\r\n        sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\r\n      }\r\n      return sdp;\r\n    };\r\n\r\n    // parses either a=msid: or a=ssrc:... msid lines and returns\r\n    // the id of the MediaStream and MediaStreamTrack.\r\n    SDPUtils.parseMsid = function (mediaSection) {\r\n      let parts;\r\n      const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\r\n      if (spec.length === 1) {\r\n        parts = spec[0].substring(7).split(' ');\r\n        return {\r\n          stream: parts[0],\r\n          track: parts[1]\r\n        };\r\n      }\r\n      const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\r\n      if (planB.length > 0) {\r\n        parts = planB[0].value.split(' ');\r\n        return {\r\n          stream: parts[0],\r\n          track: parts[1]\r\n        };\r\n      }\r\n    };\r\n\r\n    // SCTP\r\n    // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\r\n    // to draft-ietf-mmusic-sctp-sdp-05\r\n    SDPUtils.parseSctpDescription = function (mediaSection) {\r\n      const mline = SDPUtils.parseMLine(mediaSection);\r\n      const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\r\n      let maxMessageSize;\r\n      if (maxSizeLine.length > 0) {\r\n        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\r\n      }\r\n      if (isNaN(maxMessageSize)) {\r\n        maxMessageSize = 65536;\r\n      }\r\n      const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\r\n      if (sctpPort.length > 0) {\r\n        return {\r\n          port: parseInt(sctpPort[0].substring(12), 10),\r\n          protocol: mline.fmt,\r\n          maxMessageSize\r\n        };\r\n      }\r\n      const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\r\n      if (sctpMapLines.length > 0) {\r\n        const parts = sctpMapLines[0].substring(10).split(' ');\r\n        return {\r\n          port: parseInt(parts[0], 10),\r\n          protocol: parts[1],\r\n          maxMessageSize\r\n        };\r\n      }\r\n    };\r\n\r\n    // SCTP\r\n    // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\r\n    // support by now receiving in this format, unless we originally parsed\r\n    // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\r\n    // protocol of DTLS/SCTP -- without UDP/ or TCP/)\r\n    SDPUtils.writeSctpDescription = function (media, sctp) {\r\n      let output = [];\r\n      if (media.protocol !== 'DTLS/SCTP') {\r\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\r\n      } else {\r\n        output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\r\n      }\r\n      if (sctp.maxMessageSize !== undefined) {\r\n        output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\r\n      }\r\n      return output.join('');\r\n    };\r\n\r\n    // Generate a session ID for SDP.\r\n    // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\r\n    // recommends using a cryptographically random +ve 64-bit value\r\n    // but right now this should be acceptable and within the right range\r\n    SDPUtils.generateSessionId = function () {\r\n      return Math.random().toString().substr(2, 22);\r\n    };\r\n\r\n    // Write boiler plate for start of SDP\r\n    // sessId argument is optional - if not supplied it will\r\n    // be generated randomly\r\n    // sessVersion is optional and defaults to 2\r\n    // sessUser is optional and defaults to 'thisisadapterortc'\r\n    SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\r\n      let sessionId;\r\n      const version = sessVer !== undefined ? sessVer : 2;\r\n      if (sessId) {\r\n        sessionId = sessId;\r\n      } else {\r\n        sessionId = SDPUtils.generateSessionId();\r\n      }\r\n      const user = sessUser || 'thisisadapterortc';\r\n      // FIXME: sess-id should be an NTP timestamp.\r\n      return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\r\n    };\r\n\r\n    // Gets the direction from the mediaSection or the sessionpart.\r\n    SDPUtils.getDirection = function (mediaSection, sessionpart) {\r\n      // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      for (let i = 0; i < lines.length; i++) {\r\n        switch (lines[i]) {\r\n          case 'a=sendrecv':\r\n          case 'a=sendonly':\r\n          case 'a=recvonly':\r\n          case 'a=inactive':\r\n            return lines[i].substring(2);\r\n          // FIXME: What should happen here?\r\n        }\r\n      }\r\n      if (sessionpart) {\r\n        return SDPUtils.getDirection(sessionpart);\r\n      }\r\n      return 'sendrecv';\r\n    };\r\n    SDPUtils.getKind = function (mediaSection) {\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const mline = lines[0].split(' ');\r\n      return mline[0].substring(2);\r\n    };\r\n    SDPUtils.isRejected = function (mediaSection) {\r\n      return mediaSection.split(' ', 2)[1] === '0';\r\n    };\r\n    SDPUtils.parseMLine = function (mediaSection) {\r\n      const lines = SDPUtils.splitLines(mediaSection);\r\n      const parts = lines[0].substring(2).split(' ');\r\n      return {\r\n        kind: parts[0],\r\n        port: parseInt(parts[1], 10),\r\n        protocol: parts[2],\r\n        fmt: parts.slice(3).join(' ')\r\n      };\r\n    };\r\n    SDPUtils.parseOLine = function (mediaSection) {\r\n      const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\r\n      const parts = line.substring(2).split(' ');\r\n      return {\r\n        username: parts[0],\r\n        sessionId: parts[1],\r\n        sessionVersion: parseInt(parts[2], 10),\r\n        netType: parts[3],\r\n        addressType: parts[4],\r\n        address: parts[5]\r\n      };\r\n    };\r\n\r\n    // a very naive interpretation of a valid SDP.\r\n    SDPUtils.isValidSDP = function (blob) {\r\n      if (typeof blob !== 'string' || blob.length === 0) {\r\n        return false;\r\n      }\r\n      const lines = SDPUtils.splitLines(blob);\r\n      for (let i = 0; i < lines.length; i++) {\r\n        if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\r\n          return false;\r\n        }\r\n        // TODO: check the modifier a bit more.\r\n      }\r\n      return true;\r\n    };\r\n\r\n    // Expose public methods.\r\n    {\r\n      module.exports = SDPUtils;\r\n    }\r\n  })(sdp$1);\r\n  return sdp$1.exports;\r\n}\r\n\r\nvar sdpExports = requireSdp();\r\nvar SDPUtils = /*@__PURE__*/getDefaultExportFromCjs(sdpExports);\r\n\r\nvar sdp = /*#__PURE__*/_mergeNamespaces({\r\n  __proto__: null,\r\n  default: SDPUtils\r\n}, [sdpExports]);\r\n\r\n/*\r\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\nfunction shimRTCIceCandidate(window) {\r\n  // foundation is arbitrarily chosen as an indicator for full support for\r\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\r\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\r\n    return;\r\n  }\r\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\r\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\r\n    // Remove the a= which shouldn't be part of the candidate string.\r\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\r\n      args = JSON.parse(JSON.stringify(args));\r\n      args.candidate = args.candidate.substring(2);\r\n    }\r\n    if (args.candidate && args.candidate.length) {\r\n      // Augment the native candidate with the parsed fields.\r\n      const nativeCandidate = new NativeRTCIceCandidate(args);\r\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\r\n      for (const key in parsedCandidate) {\r\n        if (!(key in nativeCandidate)) {\r\n          Object.defineProperty(nativeCandidate, key, {\r\n            value: parsedCandidate[key]\r\n          });\r\n        }\r\n      }\r\n\r\n      // Override serializer to not serialize the extra attributes.\r\n      nativeCandidate.toJSON = function toJSON() {\r\n        return {\r\n          candidate: nativeCandidate.candidate,\r\n          sdpMid: nativeCandidate.sdpMid,\r\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\r\n          usernameFragment: nativeCandidate.usernameFragment\r\n        };\r\n      };\r\n      return nativeCandidate;\r\n    }\r\n    return new NativeRTCIceCandidate(args);\r\n  };\r\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\r\n\r\n  // Hook up the augmented candidate in onicecandidate and\r\n  // addEventListener('icecandidate', ...)\r\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\r\n    if (e.candidate) {\r\n      Object.defineProperty(e, 'candidate', {\r\n        value: new window.RTCIceCandidate(e.candidate),\r\n        writable: 'false'\r\n      });\r\n    }\r\n    return e;\r\n  });\r\n}\r\nfunction shimRTCIceCandidateRelayProtocol(window) {\r\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype) {\r\n    return;\r\n  }\r\n\r\n  // Hook up the augmented candidate in onicecandidate and\r\n  // addEventListener('icecandidate', ...)\r\n  wrapPeerConnectionEvent(window, 'icecandidate', e => {\r\n    if (e.candidate) {\r\n      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\r\n      if (parsedCandidate.type === 'relay') {\r\n        // This is a libwebrtc-specific mapping of local type preference\r\n        // to relayProtocol.\r\n        e.candidate.relayProtocol = {\r\n          0: 'tls',\r\n          1: 'tcp',\r\n          2: 'udp'\r\n        }[parsedCandidate.priority >> 24];\r\n      }\r\n    }\r\n    return e;\r\n  });\r\n}\r\nfunction shimMaxMessageSize(window, browserDetails) {\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\r\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\r\n      get() {\r\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\r\n      }\r\n    });\r\n  }\r\n  const sctpInDescription = function (description) {\r\n    if (!description || !description.sdp) {\r\n      return false;\r\n    }\r\n    const sections = SDPUtils.splitSections(description.sdp);\r\n    sections.shift();\r\n    return sections.some(mediaSection => {\r\n      const mLine = SDPUtils.parseMLine(mediaSection);\r\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\r\n    });\r\n  };\r\n  const getRemoteFirefoxVersion = function (description) {\r\n    // TODO: Is there a better solution for detecting Firefox?\r\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\r\n    if (match === null || match.length < 2) {\r\n      return -1;\r\n    }\r\n    const version = parseInt(match[1], 10);\r\n    // Test for NaN (yes, this is ugly)\r\n    return version !== version ? -1 : version;\r\n  };\r\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\r\n    // Every implementation we know can send at least 64 KiB.\r\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\r\n    //       data does not reach the other peer reliably.\r\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\r\n    let canSendMaxMessageSize = 65536;\r\n    if (browserDetails.browser === 'firefox') {\r\n      if (browserDetails.version < 57) {\r\n        if (remoteIsFirefox === -1) {\r\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\r\n          // fragmentation.\r\n          canSendMaxMessageSize = 16384;\r\n        } else {\r\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\r\n          // messages. Thus, supporting ~2 GiB when sending.\r\n          canSendMaxMessageSize = 2147483637;\r\n        }\r\n      } else if (browserDetails.version < 60) {\r\n        // Currently, all FF >= 57 will reset the remote maximum message size\r\n        // to the default value when a data channel is created at a later\r\n        // stage. :(\r\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\r\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\r\n      } else {\r\n        // FF >= 60 supports sending ~2 GiB\r\n        canSendMaxMessageSize = 2147483637;\r\n      }\r\n    }\r\n    return canSendMaxMessageSize;\r\n  };\r\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\r\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\r\n    //       every implementation we know supports receiving 65536 bytes.\r\n    let maxMessageSize = 65536;\r\n\r\n    // FF 57 has a slightly incorrect default remote max message size, so\r\n    // we need to adjust it here to avoid a failure when sending.\r\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\r\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\r\n      maxMessageSize = 65535;\r\n    }\r\n    const match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\r\n    if (match.length > 0) {\r\n      maxMessageSize = parseInt(match[0].substring(19), 10);\r\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\r\n      // If the maximum message size is not present in the remote SDP and\r\n      // both local and remote are Firefox, the remote peer can receive\r\n      // ~2 GiB.\r\n      maxMessageSize = 2147483637;\r\n    }\r\n    return maxMessageSize;\r\n  };\r\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\r\n    this._sctp = null;\r\n    // Chrome decided to not expose .sctp in plan-b mode.\r\n    // As usual, adapter.js has to do an 'ugly worakaround'\r\n    // to cover up the mess.\r\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\r\n      const {\r\n        sdpSemantics\r\n      } = this.getConfiguration();\r\n      if (sdpSemantics === 'plan-b') {\r\n        Object.defineProperty(this, 'sctp', {\r\n          get() {\r\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\r\n          },\r\n          enumerable: true,\r\n          configurable: true\r\n        });\r\n      }\r\n    }\r\n    if (sctpInDescription(arguments[0])) {\r\n      // Check if the remote is FF.\r\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\r\n\r\n      // Get the maximum message size the local peer is capable of sending\r\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\r\n\r\n      // Get the maximum message size of the remote peer.\r\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\r\n\r\n      // Determine final maximum message size\r\n      let maxMessageSize;\r\n      if (canSendMMS === 0 && remoteMMS === 0) {\r\n        maxMessageSize = Number.POSITIVE_INFINITY;\r\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\r\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\r\n      } else {\r\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\r\n      }\r\n\r\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\r\n      // attribute.\r\n      const sctp = {};\r\n      Object.defineProperty(sctp, 'maxMessageSize', {\r\n        get() {\r\n          return maxMessageSize;\r\n        }\r\n      });\r\n      this._sctp = sctp;\r\n    }\r\n    return origSetRemoteDescription.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimSendThrowTypeError(window) {\r\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n\r\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\r\n  //       message size can be reset for all data channels at a later stage.\r\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\r\n\r\n  function wrapDcSend(dc, pc) {\r\n    const origDataChannelSend = dc.send;\r\n    dc.send = function send() {\r\n      const data = arguments[0];\r\n      const length = data.length || data.size || data.byteLength;\r\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\r\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\r\n      }\r\n      return origDataChannelSend.apply(dc, arguments);\r\n    };\r\n  }\r\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\r\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\r\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\r\n    wrapDcSend(dataChannel, this);\r\n    return dataChannel;\r\n  };\r\n  wrapPeerConnectionEvent(window, 'datachannel', e => {\r\n    wrapDcSend(e.channel, e.target);\r\n    return e;\r\n  });\r\n}\r\n\r\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\r\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\r\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\r\n * since DTLS failures would be hidden. See\r\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\r\n * for the Firefox tracking bug.\r\n */\r\nfunction shimConnectionState(window) {\r\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\r\n    return;\r\n  }\r\n  const proto = window.RTCPeerConnection.prototype;\r\n  Object.defineProperty(proto, 'connectionState', {\r\n    get() {\r\n      return {\r\n        completed: 'connected',\r\n        checking: 'connecting'\r\n      }[this.iceConnectionState] || this.iceConnectionState;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n  Object.defineProperty(proto, 'onconnectionstatechange', {\r\n    get() {\r\n      return this._onconnectionstatechange || null;\r\n    },\r\n    set(cb) {\r\n      if (this._onconnectionstatechange) {\r\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\r\n        delete this._onconnectionstatechange;\r\n      }\r\n      if (cb) {\r\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\r\n      }\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  });\r\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\r\n    const origMethod = proto[method];\r\n    proto[method] = function () {\r\n      if (!this._connectionstatechangepoly) {\r\n        this._connectionstatechangepoly = e => {\r\n          const pc = e.target;\r\n          if (pc._lastConnectionState !== pc.connectionState) {\r\n            pc._lastConnectionState = pc.connectionState;\r\n            const newEvent = new Event('connectionstatechange', e);\r\n            pc.dispatchEvent(newEvent);\r\n          }\r\n          return e;\r\n        };\r\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\r\n      }\r\n      return origMethod.apply(this, arguments);\r\n    };\r\n  });\r\n}\r\nfunction removeExtmapAllowMixed(window, browserDetails) {\r\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\r\n  if (!window.RTCPeerConnection) {\r\n    return;\r\n  }\r\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\r\n    return;\r\n  }\r\n  if (browserDetails.browser === 'safari' && browserDetails._safariVersion >= 13.1) {\r\n    return;\r\n  }\r\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\r\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\r\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\r\n      const sdp = desc.sdp.split('\\n').filter(line => {\r\n        return line.trim() !== 'a=extmap-allow-mixed';\r\n      }).join('\\n');\r\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\r\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\r\n        arguments[0] = new window.RTCSessionDescription({\r\n          type: desc.type,\r\n          sdp\r\n        });\r\n      } else {\r\n        desc.sdp = sdp;\r\n      }\r\n    }\r\n    return nativeSRD.apply(this, arguments);\r\n  };\r\n}\r\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\r\n  // Support for addIceCandidate(null or undefined)\r\n  // as well as addIceCandidate({candidate: \"\", ...})\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\r\n  // Note: must be called before other polyfills which change the signature.\r\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\r\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\r\n    if (!arguments[0]) {\r\n      if (arguments[1]) {\r\n        arguments[1].apply(null);\r\n      }\r\n      return Promise.resolve();\r\n    }\r\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\r\n    // in older versions.\r\n    // Native support for ignoring exists for Chrome M77+.\r\n    // Safari ignores as well, exact version unknown but works in the same\r\n    // version that also ignores addIceCandidate(null).\r\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\r\n      return Promise.resolve();\r\n    }\r\n    return nativeAddIceCandidate.apply(this, arguments);\r\n  };\r\n}\r\n\r\n// Note: Make sure to call this ahead of APIs that modify\r\n// setLocalDescription.length\r\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\r\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\r\n    return;\r\n  }\r\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\r\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\r\n    return;\r\n  }\r\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\r\n    let desc = arguments[0] || {};\r\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\r\n      return nativeSetLocalDescription.apply(this, arguments);\r\n    }\r\n    // The remaining steps should technically happen when SLD comes off the\r\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\r\n    // this is too difficult to shim. Instead, this shim only covers the\r\n    // common case where the operations chain is empty. This is imperfect, but\r\n    // should cover many cases. Rationale: Even if we can't reduce the glare\r\n    // window to zero on imperfect implementations, there's value in tapping\r\n    // into the perfect negotiation pattern that several browsers support.\r\n    desc = {\r\n      type: desc.type,\r\n      sdp: desc.sdp\r\n    };\r\n    if (!desc.type) {\r\n      switch (this.signalingState) {\r\n        case 'stable':\r\n        case 'have-local-offer':\r\n        case 'have-remote-pranswer':\r\n          desc.type = 'offer';\r\n          break;\r\n        default:\r\n          desc.type = 'answer';\r\n          break;\r\n      }\r\n    }\r\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\r\n      return nativeSetLocalDescription.apply(this, [desc]);\r\n    }\r\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\r\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\r\n  };\r\n}\r\n\r\nvar commonShim = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  removeExtmapAllowMixed: removeExtmapAllowMixed,\r\n  shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\r\n  shimConnectionState: shimConnectionState,\r\n  shimMaxMessageSize: shimMaxMessageSize,\r\n  shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\r\n  shimRTCIceCandidate: shimRTCIceCandidate,\r\n  shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\r\n  shimSendThrowTypeError: shimSendThrowTypeError\r\n});\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n\r\n// Shimming starts here.\r\nfunction adapterFactory() {\r\n  let {\r\n    window\r\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\r\n    shimChrome: true,\r\n    shimFirefox: true,\r\n    shimSafari: true\r\n  };\r\n  // Utils.\r\n  const logging = log;\r\n  const browserDetails = detectBrowser(window);\r\n  const adapter = {\r\n    browserDetails,\r\n    commonShim,\r\n    extractVersion: extractVersion,\r\n    disableLog: disableLog,\r\n    disableWarnings: disableWarnings,\r\n    // Expose sdp as a convenience. For production apps include directly.\r\n    sdp\r\n  };\r\n\r\n  // Shim browser if found.\r\n  switch (browserDetails.browser) {\r\n    case 'chrome':\r\n      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\r\n        logging('Chrome shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      if (browserDetails.version === null) {\r\n        logging('Chrome shim can not determine version, not shimming.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming chrome.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = chromeShim;\r\n\r\n      // Must be called before shimPeerConnection.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimGetUserMedia$2(window, browserDetails);\r\n      shimMediaStream(window);\r\n      shimPeerConnection$1(window, browserDetails);\r\n      shimOnTrack$1(window);\r\n      shimAddTrackRemoveTrack(window, browserDetails);\r\n      shimGetSendersWithDtmf(window);\r\n      shimSenderReceiverGetStats(window);\r\n      fixNegotiationNeeded(window, browserDetails);\r\n      shimRTCIceCandidate(window);\r\n      shimRTCIceCandidateRelayProtocol(window);\r\n      shimConnectionState(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      removeExtmapAllowMixed(window, browserDetails);\r\n      break;\r\n    case 'firefox':\r\n      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\r\n        logging('Firefox shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming firefox.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = firefoxShim;\r\n\r\n      // Must be called before shimPeerConnection.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimGetUserMedia$1(window, browserDetails);\r\n      shimPeerConnection(window, browserDetails);\r\n      shimOnTrack(window);\r\n      shimRemoveStream(window);\r\n      shimSenderGetStats(window);\r\n      shimReceiverGetStats(window);\r\n      shimRTCDataChannel(window);\r\n      shimAddTransceiver(window);\r\n      shimGetParameters(window);\r\n      shimCreateOffer(window);\r\n      shimCreateAnswer(window);\r\n      shimRTCIceCandidate(window);\r\n      shimConnectionState(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      break;\r\n    case 'safari':\r\n      if (!safariShim || !options.shimSafari) {\r\n        logging('Safari shim is not included in this adapter release.');\r\n        return adapter;\r\n      }\r\n      logging('adapter.js shimming safari.');\r\n      // Export to the adapter global object visible in the browser.\r\n      adapter.browserShim = safariShim;\r\n\r\n      // Must be called before shimCallbackAPI.\r\n      shimAddIceCandidateNullOrEmpty(window, browserDetails);\r\n      shimParameterlessSetLocalDescription(window);\r\n      shimRTCIceServerUrls(window);\r\n      shimCreateOfferLegacy(window);\r\n      shimCallbacksAPI(window);\r\n      shimLocalStreamsAPI(window);\r\n      shimRemoteStreamsAPI(window);\r\n      shimTrackEventTransceiver(window);\r\n      shimGetUserMedia(window);\r\n      shimAudioContext(window);\r\n      shimRTCIceCandidate(window);\r\n      shimRTCIceCandidateRelayProtocol(window);\r\n      shimMaxMessageSize(window, browserDetails);\r\n      shimSendThrowTypeError(window);\r\n      removeExtmapAllowMixed(window, browserDetails);\r\n      break;\r\n    default:\r\n      logging('Unsupported browser!');\r\n      break;\r\n  }\r\n  return adapter;\r\n}\r\n\r\n/*\r\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\r\n *\r\n *  Use of this source code is governed by a BSD-style license\r\n *  that can be found in the LICENSE file in the root of the source\r\n *  tree.\r\n */\r\n/* eslint-env node */\r\n\r\nadapterFactory({\r\n  window: typeof window === 'undefined' ? undefined : window\r\n});\r\n\r\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\r\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\r\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\r\n// flag set to indicate that e2ee has been setup for sender/receiver;\r\nconst E2EE_FLAG = 'lk_e2ee';\r\nconst SALT = 'LKFrameEncryptionKey';\r\nconst KEY_PROVIDER_DEFAULTS = {\r\n  sharedKey: false,\r\n  ratchetSalt: SALT,\r\n  ratchetWindowSize: 8,\r\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\r\n  keyringSize: 16\r\n};\r\n\r\nvar KeyProviderEvent;\r\n(function (KeyProviderEvent) {\r\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\r\n  /** Event for requesting to ratchet the key used to encrypt the stream */\r\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\r\n  /** Emitted when a key is ratcheted. Could be after auto-ratcheting on decryption failure or\r\n   *  following a `RatchetRequest`, will contain the ratcheted key material */\r\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\r\n})(KeyProviderEvent || (KeyProviderEvent = {}));\r\nvar KeyHandlerEvent;\r\n(function (KeyHandlerEvent) {\r\n  /** Emitted when a key has been ratcheted. Is emitted when any key has been ratcheted\r\n   * i.e. when the FrameCryptor tried to ratchet when decryption is failing  */\r\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\r\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\r\nvar EncryptionEvent;\r\n(function (EncryptionEvent) {\r\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\r\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\r\n})(EncryptionEvent || (EncryptionEvent = {}));\r\nvar CryptorEvent;\r\n(function (CryptorEvent) {\r\n  CryptorEvent[\"Error\"] = \"cryptorError\";\r\n})(CryptorEvent || (CryptorEvent = {}));\r\n\r\nfunction isE2EESupported() {\r\n  return isInsertableStreamSupported() || isScriptTransformSupported();\r\n}\r\nfunction isScriptTransformSupported() {\r\n  // @ts-ignore\r\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\r\n}\r\nfunction isInsertableStreamSupported() {\r\n  return typeof window.RTCRtpSender !== 'undefined' &&\r\n  // @ts-ignore\r\n  typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';\r\n}\r\nfunction isVideoFrame(frame) {\r\n  return 'type' in frame;\r\n}\r\nfunction importKey(keyBytes_1) {\r\n  return __awaiter(this, arguments, void 0, function (keyBytes) {\r\n    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\r\n      name: ENCRYPTION_ALGORITHM\r\n    };\r\n    let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\r\n    return function* () {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\r\n      return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\r\n    }();\r\n  });\r\n}\r\nfunction createKeyMaterialFromString(password) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    let enc = new TextEncoder();\r\n    const keyMaterial = yield crypto.subtle.importKey('raw', enc.encode(password), {\r\n      name: 'PBKDF2'\r\n    }, false, ['deriveBits', 'deriveKey']);\r\n    return keyMaterial;\r\n  });\r\n}\r\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const keyMaterial = yield crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, ['deriveBits', 'deriveKey']);\r\n    return keyMaterial;\r\n  });\r\n}\r\nfunction getAlgoOptions(algorithmName, salt) {\r\n  const textEncoder = new TextEncoder();\r\n  const encodedSalt = textEncoder.encode(salt);\r\n  switch (algorithmName) {\r\n    case 'HKDF':\r\n      return {\r\n        name: 'HKDF',\r\n        salt: encodedSalt,\r\n        hash: 'SHA-256',\r\n        info: new ArrayBuffer(128)\r\n      };\r\n    case 'PBKDF2':\r\n      {\r\n        return {\r\n          name: 'PBKDF2',\r\n          salt: encodedSalt,\r\n          hash: 'SHA-256',\r\n          iterations: 100000\r\n        };\r\n      }\r\n    default:\r\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\r\n  }\r\n}\r\n/**\r\n * Derives a set of keys from the master key.\r\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\r\n */\r\nfunction deriveKeys(material, salt) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\r\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\r\n      name: ENCRYPTION_ALGORITHM,\r\n      length: 128\r\n    }, false, ['encrypt', 'decrypt']);\r\n    return {\r\n      material,\r\n      encryptionKey\r\n    };\r\n  });\r\n}\r\nfunction createE2EEKey() {\r\n  return window.crypto.getRandomValues(new Uint8Array(32));\r\n}\r\n/**\r\n * Ratchets a key. See\r\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\r\n */\r\nfunction ratchet(material, salt) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\r\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\r\n  });\r\n}\r\nfunction needsRbspUnescaping(frameData) {\r\n  for (var i = 0; i < frameData.length - 3; i++) {\r\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\r\n  }\r\n  return false;\r\n}\r\nfunction parseRbsp(stream) {\r\n  const dataOut = [];\r\n  var length = stream.length;\r\n  for (var i = 0; i < stream.length;) {\r\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\r\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\r\n    // above, and that expression will produce the number of bytes left in\r\n    // the stream including the byte at i.\r\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\r\n      // Two rbsp bytes.\r\n      dataOut.push(stream[i++]);\r\n      dataOut.push(stream[i++]);\r\n      // Skip the emulation byte.\r\n      i++;\r\n    } else {\r\n      // Single rbsp byte.\r\n      dataOut.push(stream[i++]);\r\n    }\r\n  }\r\n  return new Uint8Array(dataOut);\r\n}\r\nconst kZerosInStartSequence = 2;\r\nconst kEmulationByte = 3;\r\nfunction writeRbsp(data_in) {\r\n  const dataOut = [];\r\n  var numConsecutiveZeros = 0;\r\n  for (var i = 0; i < data_in.length; ++i) {\r\n    var byte = data_in[i];\r\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\r\n      // Need to escape.\r\n      dataOut.push(kEmulationByte);\r\n      numConsecutiveZeros = 0;\r\n    }\r\n    dataOut.push(byte);\r\n    if (byte == 0) {\r\n      ++numConsecutiveZeros;\r\n    } else {\r\n      numConsecutiveZeros = 0;\r\n    }\r\n  }\r\n  return new Uint8Array(dataOut);\r\n}\r\n\r\n/**\r\n * @experimental\r\n */\r\nclass BaseKeyProvider extends eventsExports.EventEmitter {\r\n  constructor() {\r\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    super();\r\n    /**\r\n     * Callback being invoked after a key has been ratcheted.\r\n     * Can happen when:\r\n     * - A decryption failure occurs and the key is auto-ratcheted\r\n     * - A ratchet request is sent (see {@link ratchetKey()})\r\n     * @param ratchetResult Contains the ratcheted chain key (exportable to other participants) and the derived new key material.\r\n     * @param participantId\r\n     * @param keyIndex\r\n     */\r\n    this.onKeyRatcheted = (ratchetResult, participantId, keyIndex) => {\r\n      livekitLogger.debug('key ratcheted event received', {\r\n        ratchetResult,\r\n        participantId,\r\n        keyIndex\r\n      });\r\n    };\r\n    this.keyInfoMap = new Map();\r\n    this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\r\n    this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\r\n  }\r\n  /**\r\n   * callback to invoke once a key has been set for a participant\r\n   * @param key\r\n   * @param participantIdentity\r\n   * @param keyIndex\r\n   */\r\n  onSetEncryptionKey(key, participantIdentity, keyIndex) {\r\n    const keyInfo = {\r\n      key,\r\n      participantIdentity,\r\n      keyIndex\r\n    };\r\n    if (!this.options.sharedKey && !participantIdentity) {\r\n      throw new Error('participant identity needs to be passed for encryption key if sharedKey option is false');\r\n    }\r\n    this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\r\n    this.emit(KeyProviderEvent.SetKey, keyInfo);\r\n  }\r\n  getKeys() {\r\n    return Array.from(this.keyInfoMap.values());\r\n  }\r\n  getOptions() {\r\n    return this.options;\r\n  }\r\n  ratchetKey(participantIdentity, keyIndex) {\r\n    this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\r\n  }\r\n}\r\n/**\r\n * A basic KeyProvider implementation intended for a single shared\r\n * passphrase between all participants\r\n * @experimental\r\n */\r\nclass ExternalE2EEKeyProvider extends BaseKeyProvider {\r\n  constructor() {\r\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n    const opts = Object.assign(Object.assign({}, options), {\r\n      sharedKey: true,\r\n      // for a shared key provider failing to decrypt for a specific participant\r\n      // should not mark the key as invalid, so we accept wrong keys forever\r\n      // and won't try to auto-ratchet\r\n      ratchetWindowSize: 0,\r\n      failureTolerance: -1\r\n    });\r\n    super(opts);\r\n  }\r\n  /**\r\n   * Accepts a passphrase that's used to create the crypto keys.\r\n   * When passing in a string, PBKDF2 is used.\r\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\r\n   * @param key\r\n   */\r\n  setKey(key) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const derivedKey = typeof key === 'string' ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\r\n      this.onSetEncryptionKey(derivedKey);\r\n    });\r\n  }\r\n}\r\n\r\nclass LivekitError extends Error {\r\n  constructor(code, message) {\r\n    super(message || 'an error has occured');\r\n    this.name = 'LiveKitError';\r\n    this.code = code;\r\n  }\r\n}\r\nvar ConnectionErrorReason;\r\n(function (ConnectionErrorReason) {\r\n  ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\r\n  ConnectionErrorReason[ConnectionErrorReason[\"Timeout\"] = 5] = \"Timeout\";\r\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\r\nclass ConnectionError extends LivekitError {\r\n  constructor(message, reason, status, context) {\r\n    super(1, message);\r\n    this.name = 'ConnectionError';\r\n    this.status = status;\r\n    this.reason = reason;\r\n    this.context = context;\r\n    this.reasonName = ConnectionErrorReason[reason];\r\n  }\r\n}\r\nclass DeviceUnsupportedError extends LivekitError {\r\n  constructor(message) {\r\n    super(21, message !== null && message !== void 0 ? message : 'device is unsupported');\r\n    this.name = 'DeviceUnsupportedError';\r\n  }\r\n}\r\nclass TrackInvalidError extends LivekitError {\r\n  constructor(message) {\r\n    super(20, message !== null && message !== void 0 ? message : 'track is invalid');\r\n    this.name = 'TrackInvalidError';\r\n  }\r\n}\r\nclass UnsupportedServer extends LivekitError {\r\n  constructor(message) {\r\n    super(10, message !== null && message !== void 0 ? message : 'unsupported server');\r\n    this.name = 'UnsupportedServer';\r\n  }\r\n}\r\nclass UnexpectedConnectionState extends LivekitError {\r\n  constructor(message) {\r\n    super(12, message !== null && message !== void 0 ? message : 'unexpected connection state');\r\n    this.name = 'UnexpectedConnectionState';\r\n  }\r\n}\r\nclass NegotiationError extends LivekitError {\r\n  constructor(message) {\r\n    super(13, message !== null && message !== void 0 ? message : 'unable to negotiate');\r\n    this.name = 'NegotiationError';\r\n  }\r\n}\r\nclass PublishDataError extends LivekitError {\r\n  constructor(message) {\r\n    super(14, message !== null && message !== void 0 ? message : 'unable to publish data');\r\n    this.name = 'PublishDataError';\r\n  }\r\n}\r\nclass PublishTrackError extends LivekitError {\r\n  constructor(message, status) {\r\n    super(15, message);\r\n    this.name = 'PublishTrackError';\r\n    this.status = status;\r\n  }\r\n}\r\nclass SignalRequestError extends LivekitError {\r\n  constructor(message, reason) {\r\n    super(15, message);\r\n    this.reason = reason;\r\n    this.reasonName = typeof reason === 'string' ? reason : RequestResponse_Reason[reason];\r\n  }\r\n}\r\nvar MediaDeviceFailure;\r\n(function (MediaDeviceFailure) {\r\n  // user rejected permissions\r\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\r\n  // device is not available\r\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\r\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\r\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\r\n  MediaDeviceFailure[\"Other\"] = \"Other\";\r\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\r\n(function (MediaDeviceFailure) {\r\n  function getFailure(error) {\r\n    if (error && 'name' in error) {\r\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\r\n        return MediaDeviceFailure.NotFound;\r\n      }\r\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\r\n        return MediaDeviceFailure.PermissionDenied;\r\n      }\r\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\r\n        return MediaDeviceFailure.DeviceInUse;\r\n      }\r\n      return MediaDeviceFailure.Other;\r\n    }\r\n  }\r\n  MediaDeviceFailure.getFailure = getFailure;\r\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\r\n\r\nvar CryptorErrorReason;\r\n(function (CryptorErrorReason) {\r\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\r\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\r\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\r\n})(CryptorErrorReason || (CryptorErrorReason = {}));\r\nclass CryptorError extends LivekitError {\r\n  constructor(message) {\r\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\r\n    let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\r\n    super(40, message);\r\n    this.reason = reason;\r\n    this.participantIdentity = participantIdentity;\r\n  }\r\n}\r\n\r\n/**\r\n * Events are the primary way LiveKit notifies your application of changes.\r\n *\r\n * The following are events emitted by [[Room]], listen to room events like\r\n *\r\n * ```typescript\r\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\r\n * ```\r\n */\r\nvar RoomEvent;\r\n(function (RoomEvent) {\r\n  /**\r\n   * When the connection to the server has been established\r\n   */\r\n  RoomEvent[\"Connected\"] = \"connected\";\r\n  /**\r\n   * When the connection to the server has been interrupted and it's attempting\r\n   * to reconnect.\r\n   */\r\n  RoomEvent[\"Reconnecting\"] = \"reconnecting\";\r\n  /**\r\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\r\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\r\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\r\n   */\r\n  RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\r\n  /**\r\n   * Fires when a reconnection has been successful.\r\n   */\r\n  RoomEvent[\"Reconnected\"] = \"reconnected\";\r\n  /**\r\n   * When disconnected from room. This fires when room.disconnect() is called or\r\n   * when an unrecoverable connection issue had occured.\r\n   *\r\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\r\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\r\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\r\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\r\n   *\r\n   * args: ([[DisconnectReason]])\r\n   */\r\n  RoomEvent[\"Disconnected\"] = \"disconnected\";\r\n  /**\r\n   * Whenever the connection state of the room changes\r\n   *\r\n   * args: ([[ConnectionState]])\r\n   */\r\n  RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\r\n  /**\r\n   * When participant has been moved to a different room by the service request.\r\n   * The behavior looks like the participant has been disconnected and reconnected to a different room\r\n   * seamlessly without connection state transition.\r\n   * A new token will be provided for reconnecting to the new room if needed.\r\n   *\r\n   * args: ([[room: string, token: string]])\r\n   */\r\n  RoomEvent[\"Moved\"] = \"moved\";\r\n  /**\r\n   * When input or output devices on the machine have changed.\r\n   */\r\n  RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\r\n  /**\r\n   * When a [[RemoteParticipant]] joins *after* the local\r\n   * participant. It will not emit events for participants that are already\r\n   * in the room\r\n   *\r\n   * args: ([[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\r\n  /**\r\n   * When a [[RemoteParticipant]] leaves *after* the local\r\n   * participant has joined.\r\n   *\r\n   * args: ([[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\r\n  /**\r\n   * When a new track is published to room *after* the local\r\n   * participant has joined. It will not fire for tracks that are already published.\r\n   *\r\n   * A track published doesn't mean the participant has subscribed to it. It's\r\n   * simply reflecting the state of the room.\r\n   *\r\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackPublished\"] = \"trackPublished\";\r\n  /**\r\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\r\n   * fire as long as new tracks are ready for use.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\r\n  /**\r\n   * Could not subscribe to a track\r\n   *\r\n   * args: (track sid, [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\r\n  /**\r\n   * A [[RemoteParticipant]] has unpublished a track\r\n   *\r\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\r\n  /**\r\n   * A subscribed track is no longer available. Clients should listen to this\r\n   * event and ensure they detach tracks.\r\n   *\r\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\r\n  /**\r\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]], [[Participant]])\r\n   */\r\n  RoomEvent[\"TrackMuted\"] = \"trackMuted\";\r\n  /**\r\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]], [[Participant]])\r\n   */\r\n  RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\r\n  /**\r\n   * A local track was published successfully. This event is helpful to know\r\n   * when to update your local UI with the newly published track.\r\n   *\r\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\r\n   */\r\n  RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\r\n  /**\r\n   * A local track was unpublished. This event is helpful to know when to remove\r\n   * the local track from your UI.\r\n   *\r\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\r\n   * this event will also fire.\r\n   *\r\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\r\n   */\r\n  RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  /**\r\n   * When a local audio track is published the SDK checks whether there is complete silence\r\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\r\n   * This allows for applications to show UI informing users that they might have to\r\n   * reset their audio hardware or check for proper device connectivity.\r\n   */\r\n  RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\r\n  /**\r\n   * Active speakers changed. List of speakers are ordered by their audio level.\r\n   * loudest speakers first. This will include the LocalParticipant too.\r\n   *\r\n   * Speaker updates are sent only to the publishing participant and their subscribers.\r\n   *\r\n   * args: (Array<[[Participant]]>)\r\n   */\r\n  RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\r\n  /**\r\n   * Participant metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\r\n   * state, *all*  participants in the room will fire this event.\r\n   *\r\n   * args: (prevMetadata: string, [[Participant]])\r\n   *\r\n   */\r\n  RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\r\n  /**\r\n   * Participant's display name changed\r\n   *\r\n   * args: (name: string, [[Participant]])\r\n   *\r\n   */\r\n  RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\r\n  /**\r\n   * Participant attributes is an app-specific key value state to be pushed to\r\n   * all users.\r\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\r\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\r\n  /**\r\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\r\n   *\r\n   * args: (participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantActive\"] = \"participantActive\";\r\n  /**\r\n   * Room metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\r\n   * *all*  participants in the room will fire this event.\r\n   *\r\n   * args: (string)\r\n   */\r\n  RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\r\n  /**\r\n   * Data received from another participant.\r\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\r\n   * All participants in the room will receive the messages sent to the room.\r\n   *\r\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\r\n   */\r\n  RoomEvent[\"DataReceived\"] = \"dataReceived\";\r\n  /**\r\n   * SIP DTMF tones received from another participant.\r\n   *\r\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\r\n   */\r\n  RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\r\n  /**\r\n   * Transcription received from a participant's track.\r\n   * @beta\r\n   */\r\n  RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * Connection quality was changed for a Participant. It'll receive updates\r\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\r\n   * subscribed to.\r\n   *\r\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\r\n  /**\r\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\r\n   * (typically this happens because of subscriber's bandwidth constraints)\r\n   *\r\n   * When bandwidth conditions allow, the track will be resumed automatically.\r\n   * TrackStreamStateChanged will also be emitted when that happens.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its permissions for the current\r\n   * participant. If permission was revoked, then the track will no longer\r\n   * be subscribed. If permission was granted, a TrackSubscribed event will\r\n   * be emitted.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.PermissionStatus]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its status for the current\r\n   * participant.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.SubscriptionStatus]],\r\n   *        participant: [[RemoteParticipant]])\r\n   */\r\n  RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\r\n  /**\r\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\r\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\r\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\r\n   */\r\n  RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\r\n  /**\r\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\r\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\r\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\r\n   */\r\n  RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\r\n  /**\r\n   * When we have encountered an error while attempting to create a track.\r\n   * The errors take place in getUserMedia().\r\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\r\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\r\n   * will indicate if it had an error while creating the audio or video track respectively.\r\n   *\r\n   * args: (error: Error)\r\n   */\r\n  RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\r\n  /**\r\n   * A participant's permission has changed.\r\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\r\n   */\r\n  RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\r\n  /**\r\n   * Signal connected, can publish tracks.\r\n   */\r\n  RoomEvent[\"SignalConnected\"] = \"signalConnected\";\r\n  /**\r\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\r\n   * args: (isRecording: boolean)\r\n   */\r\n  RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\r\n  RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\r\n  RoomEvent[\"EncryptionError\"] = \"encryptionError\";\r\n  /**\r\n   * Emits whenever the current buffer status of a data channel changes\r\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\r\n   */\r\n  RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\r\n  /**\r\n   * Triggered by a call to room.switchActiveDevice\r\n   * args: (kind: MediaDeviceKind, deviceId: string)\r\n   */\r\n  RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\r\n  RoomEvent[\"ChatMessage\"] = \"chatMessage\";\r\n  /**\r\n   * fired when the first remote participant has subscribed to the localParticipant's track\r\n   */\r\n  RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  /**\r\n   * fired when the client receives connection metrics from other participants\r\n   */\r\n  RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\r\n})(RoomEvent || (RoomEvent = {}));\r\nvar ParticipantEvent;\r\n(function (ParticipantEvent) {\r\n  /**\r\n   * When a new track is published to room *after* the local\r\n   * participant has joined. It will not fire for tracks that are already published.\r\n   *\r\n   * A track published doesn't mean the participant has subscribed to it. It's\r\n   * simply reflecting the state of the room.\r\n   *\r\n   * args: ([[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\r\n  /**\r\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\r\n   * This event will **always** fire as long as new tracks are ready for use.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\r\n  /**\r\n   * Could not subscribe to a track\r\n   *\r\n   * args: (track sid)\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\r\n  /**\r\n   * A [[RemoteParticipant]] has unpublished a track\r\n   *\r\n   * args: ([[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\r\n  /**\r\n   * A subscribed track is no longer available. Clients should listen to this\r\n   * event and ensure they detach tracks.\r\n   *\r\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\r\n  /**\r\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\r\n  /**\r\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\r\n   *\r\n   * args: ([[TrackPublication]])\r\n   */\r\n  ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\r\n  /**\r\n   * A local track was published successfully. This event is helpful to know\r\n   * when to update your local UI with the newly published track.\r\n   *\r\n   * args: ([[LocalTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\r\n  /**\r\n   * A local track was unpublished. This event is helpful to know when to remove\r\n   * the local track from your UI.\r\n   *\r\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\r\n   * this event will also fire.\r\n   *\r\n   * args: ([[LocalTrackPublication]])\r\n   */\r\n  ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  /**\r\n   * Participant metadata is a simple way for app-specific state to be pushed to\r\n   * all users.\r\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\r\n   * state, *all*  participants in the room will fire this event.\r\n   * To access the current metadata, see [[Participant.metadata]].\r\n   *\r\n   * args: (prevMetadata: string)\r\n   *\r\n   */\r\n  ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\r\n  /**\r\n   * Participant's display name changed\r\n   *\r\n   * args: (name: string, [[Participant]])\r\n   *\r\n   */\r\n  ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\r\n  /**\r\n   * Data received from this participant as sender.\r\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\r\n   * All participants in the room will receive the messages sent to the room.\r\n   *\r\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\r\n   */\r\n  ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\r\n  /**\r\n   * SIP DTMF tones received from this participant as sender.\r\n   *\r\n   * args: (dtmf: [[DataPacket_Kind]])\r\n   */\r\n  ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\r\n  /**\r\n   * Transcription received from this participant as data source.\r\n   * @beta\r\n   */\r\n  ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * Has speaking status changed for the current participant\r\n   *\r\n   * args: (speaking: boolean)\r\n   */\r\n  ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\r\n  /**\r\n   * Connection quality was changed for a Participant. It'll receive updates\r\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\r\n   * subscribed to.\r\n   *\r\n   * args: (connectionQuality: [[ConnectionQuality]])\r\n   */\r\n  ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\r\n  /**\r\n   * StreamState indicates if a subscribed track has been paused by the SFU\r\n   * (typically this happens because of subscriber's bandwidth constraints)\r\n   *\r\n   * When bandwidth conditions allow, the track will be resumed automatically.\r\n   * TrackStreamStateChanged will also be emitted when that happens.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\r\n   */\r\n  ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\r\n  /**\r\n   * One of subscribed tracks have changed its permissions for the current\r\n   * participant. If permission was revoked, then the track will no longer\r\n   * be subscribed. If permission was granted, a TrackSubscribed event will\r\n   * be emitted.\r\n   *\r\n   * args: (pub: [[RemoteTrackPublication]],\r\n   *        status: [[TrackPublication.SubscriptionStatus]])\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\r\n  /**\r\n   * One of the remote participants publications has changed its subscription status.\r\n   *\r\n   */\r\n  ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\r\n  // fired only on LocalParticipant\r\n  /** @internal */\r\n  ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\r\n  // fired only on LocalParticipant\r\n  /** @internal */\r\n  ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\r\n  /**\r\n   * A participant's permission has changed.\r\n   * args: (prevPermissions: [[ParticipantPermission]])\r\n   */\r\n  ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\r\n  /** @internal */\r\n  ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\r\n  /**\r\n   * Participant attributes is an app-specific key value state to be pushed to\r\n   * all users.\r\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\r\n   * args: (changedAttributes: [[Record<string, string]])\r\n   */\r\n  ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\r\n  /**\r\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\r\n   */\r\n  ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  /** only emitted on local participant */\r\n  ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\r\n  /**\r\n   * Emitted when the participant's state changes to ACTIVE and is ready to send/receive data messages\r\n   */\r\n  ParticipantEvent[\"Active\"] = \"active\";\r\n})(ParticipantEvent || (ParticipantEvent = {}));\r\n/** @internal */\r\nvar EngineEvent;\r\n(function (EngineEvent) {\r\n  EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\r\n  EngineEvent[\"Connected\"] = \"connected\";\r\n  EngineEvent[\"Disconnected\"] = \"disconnected\";\r\n  EngineEvent[\"Resuming\"] = \"resuming\";\r\n  EngineEvent[\"Resumed\"] = \"resumed\";\r\n  EngineEvent[\"Restarting\"] = \"restarting\";\r\n  EngineEvent[\"Restarted\"] = \"restarted\";\r\n  EngineEvent[\"SignalResumed\"] = \"signalResumed\";\r\n  EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\r\n  EngineEvent[\"Closing\"] = \"closing\";\r\n  EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\r\n  EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\r\n  EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\r\n  EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\r\n  EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\r\n  EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\r\n  EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\r\n  EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\r\n  EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\r\n  EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\r\n  EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\r\n  EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\r\n  EngineEvent[\"RemoteMute\"] = \"remoteMute\";\r\n  EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\r\n  EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\r\n  EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\r\n  EngineEvent[\"Offline\"] = \"offline\";\r\n  EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\r\n  EngineEvent[\"SignalConnected\"] = \"signalConnected\";\r\n  EngineEvent[\"RoomMoved\"] = \"roomMoved\";\r\n})(EngineEvent || (EngineEvent = {}));\r\nvar TrackEvent;\r\n(function (TrackEvent) {\r\n  TrackEvent[\"Message\"] = \"message\";\r\n  TrackEvent[\"Muted\"] = \"muted\";\r\n  TrackEvent[\"Unmuted\"] = \"unmuted\";\r\n  /**\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"Restarted\"] = \"restarted\";\r\n  TrackEvent[\"Ended\"] = \"ended\";\r\n  TrackEvent[\"Subscribed\"] = \"subscribed\";\r\n  TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\r\n  /** @internal */\r\n  TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\r\n  /** @internal */\r\n  TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\r\n  /** @internal */\r\n  TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\r\n  /** @internal */\r\n  TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalAudioTrack instances\r\n   */\r\n  TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\r\n  /** @internal */\r\n  TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\r\n  /** @internal */\r\n  TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\r\n  /** @internal */\r\n  TrackEvent[\"ElementAttached\"] = \"elementAttached\";\r\n  /** @internal */\r\n  TrackEvent[\"ElementDetached\"] = \"elementDetached\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\r\n  /**\r\n   * @internal\r\n   * Only fires on LocalTracks\r\n   */\r\n  TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\r\n  /**\r\n   * @internal\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\r\n  /**\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\r\n  /**\r\n   * Fires on RemoteTrackPublication\r\n   */\r\n  TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\r\n  /**\r\n   * @beta\r\n   */\r\n  TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\r\n  /**\r\n   * @experimental\r\n   */\r\n  TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\r\n  /**\r\n   * @internal\r\n   */\r\n  TrackEvent[\"PreConnectBufferFlushed\"] = \"preConnectBufferFlushed\";\r\n})(TrackEvent || (TrackEvent = {}));\r\n\r\nfunction cloneDeep(value) {\r\n  if (typeof value === 'undefined') {\r\n    return value;\r\n  }\r\n  if (typeof structuredClone === 'function') {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // ensure that the value is not a proxy by spreading it\r\n      return structuredClone(Object.assign({}, value));\r\n    }\r\n    return structuredClone(value);\r\n  } else {\r\n    return JSON.parse(JSON.stringify(value));\r\n  }\r\n}\r\n\r\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\r\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\r\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\r\nlet browserDetails;\r\n/**\r\n * @internal\r\n */\r\nfunction getBrowser(userAgent) {\r\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n  if (typeof userAgent === 'undefined' && typeof navigator === 'undefined') {\r\n    return;\r\n  }\r\n  const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\r\n  if (browserDetails === undefined || force) {\r\n    const browser = browsersList.find(_ref => {\r\n      let {\r\n        test\r\n      } = _ref;\r\n      return test.test(ua);\r\n    });\r\n    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\r\n  }\r\n  return browserDetails;\r\n}\r\nconst browsersList = [{\r\n  test: /firefox|iceweasel|fxios/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Firefox',\r\n      version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\r\n      os: ua.toLowerCase().includes('fxios') ? 'iOS' : undefined,\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}, {\r\n  test: /chrom|crios|crmo/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Chrome',\r\n      version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\r\n      os: ua.toLowerCase().includes('crios') ? 'iOS' : undefined,\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}, /* Safari */\r\n{\r\n  test: /safari|applewebkit/i,\r\n  describe(ua) {\r\n    const browser = {\r\n      name: 'Safari',\r\n      version: getMatch(commonVersionIdentifier, ua),\r\n      os: ua.includes('mobile/') ? 'iOS' : 'macOS',\r\n      osVersion: getOSVersion(ua)\r\n    };\r\n    return browser;\r\n  }\r\n}];\r\nfunction getMatch(exp, ua) {\r\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\r\n  const match = ua.match(exp);\r\n  return match && match.length >= id && match[id] || '';\r\n}\r\nfunction getOSVersion(ua) {\r\n  return ua.includes('mac os') ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, '.') : undefined;\r\n}\r\n\r\nvar version$1 = \"2.13.5\";\r\n\r\nconst version = version$1;\r\nconst protocolVersion = 16;\r\n\r\n/**\r\n * Timers that can be overridden with platform specific implementations\r\n * that ensure that they are fired. These should be used when it is critical\r\n * that the timer fires on time.\r\n */\r\nclass CriticalTimers {}\r\nCriticalTimers.setTimeout = function () {\r\n  return setTimeout(...arguments);\r\n};\r\nCriticalTimers.setInterval =\r\n// eslint-disable-next-line @typescript-eslint/no-implied-eval\r\nfunction () {\r\n  return setInterval(...arguments);\r\n};\r\nCriticalTimers.clearTimeout = function () {\r\n  return clearTimeout(...arguments);\r\n};\r\nCriticalTimers.clearInterval = function () {\r\n  return clearInterval(...arguments);\r\n};\r\n\r\nconst BACKGROUND_REACTION_DELAY = 5000;\r\n// keep old audio elements when detached, we would re-use them since on iOS\r\n// Safari tracks which audio elements have been \"blessed\" by the user.\r\nconst recycledElements = [];\r\nvar VideoQuality;\r\n(function (VideoQuality) {\r\n  VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\r\n  VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\r\n  VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\r\n})(VideoQuality || (VideoQuality = {}));\r\nclass Track extends eventsExports.EventEmitter {\r\n  constructor(mediaTrack, kind) {\r\n    let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var _a;\r\n    super();\r\n    this.attachedElements = [];\r\n    this.isMuted = false;\r\n    /**\r\n     * indicates current state of stream, it'll indicate `paused` if the track\r\n     * has been paused by congestion controller\r\n     */\r\n    this.streamState = Track.StreamState.Active;\r\n    this.isInBackground = false;\r\n    this._currentBitrate = 0;\r\n    this.log = livekitLogger;\r\n    this.appVisibilityChangedListener = () => {\r\n      if (this.backgroundTimeout) {\r\n        clearTimeout(this.backgroundTimeout);\r\n      }\r\n      // delay app visibility update if it goes to hidden\r\n      // update immediately if it comes back to focus\r\n      if (document.visibilityState === 'hidden') {\r\n        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\r\n      } else {\r\n        this.handleAppVisibilityChanged();\r\n      }\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\r\n    this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    this.setMaxListeners(100);\r\n    this.kind = kind;\r\n    this._mediaStreamTrack = mediaTrack;\r\n    this._mediaStreamID = mediaTrack.id;\r\n    this.source = Track.Source.Unknown;\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\r\n  }\r\n  /** current receive bits per second */\r\n  get currentBitrate() {\r\n    return this._currentBitrate;\r\n  }\r\n  get mediaStreamTrack() {\r\n    return this._mediaStreamTrack;\r\n  }\r\n  /**\r\n   * @internal\r\n   * used for keep mediaStream's first id, since it's id might change\r\n   * if we disable/enable a track\r\n   */\r\n  get mediaStreamID() {\r\n    return this._mediaStreamID;\r\n  }\r\n  attach(element) {\r\n    let elementType = 'audio';\r\n    if (this.kind === Track.Kind.Video) {\r\n      elementType = 'video';\r\n    }\r\n    if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\r\n      this.addAppVisibilityListener();\r\n    }\r\n    if (!element) {\r\n      if (elementType === 'audio') {\r\n        recycledElements.forEach(e => {\r\n          if (e.parentElement === null && !element) {\r\n            element = e;\r\n          }\r\n        });\r\n        if (element) {\r\n          // remove it from pool\r\n          recycledElements.splice(recycledElements.indexOf(element), 1);\r\n        }\r\n      }\r\n      if (!element) {\r\n        element = document.createElement(elementType);\r\n      }\r\n    }\r\n    if (!this.attachedElements.includes(element)) {\r\n      this.attachedElements.push(element);\r\n    }\r\n    // even if we believe it's already attached to the element, it's possible\r\n    // the element's srcObject was set to something else out of band.\r\n    // we'll want to re-attach it in that case\r\n    attachToElement(this.mediaStreamTrack, element);\r\n    // handle auto playback failures\r\n    const allMediaStreamTracks = element.srcObject.getTracks();\r\n    const hasAudio = allMediaStreamTracks.some(tr => tr.kind === 'audio');\r\n    // manually play media to detect auto playback status\r\n    element.play().then(() => {\r\n      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\r\n    }).catch(e => {\r\n      if (e.name === 'NotAllowedError') {\r\n        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\r\n      } else if (e.name === 'AbortError') {\r\n        // commonly triggered by another `play` request, only log for debugging purposes\r\n        livekitLogger.debug(\"\".concat(hasAudio ? 'audio' : 'video', \" playback aborted, likely due to new play request\"));\r\n      } else {\r\n        livekitLogger.warn(\"could not playback \".concat(hasAudio ? 'audio' : 'video'), e);\r\n      }\r\n      // If audio playback isn't allowed make sure we still play back the video\r\n      if (hasAudio && element && allMediaStreamTracks.some(tr => tr.kind === 'video') && e.name === 'NotAllowedError') {\r\n        element.muted = true;\r\n        element.play().catch(() => {\r\n          // catch for Safari, exceeded options at this point to automatically play the media element\r\n        });\r\n      }\r\n    });\r\n    this.emit(TrackEvent.ElementAttached, element);\r\n    return element;\r\n  }\r\n  detach(element) {\r\n    try {\r\n      // detach from a single element\r\n      if (element) {\r\n        detachTrack(this.mediaStreamTrack, element);\r\n        const idx = this.attachedElements.indexOf(element);\r\n        if (idx >= 0) {\r\n          this.attachedElements.splice(idx, 1);\r\n          this.recycleElement(element);\r\n          this.emit(TrackEvent.ElementDetached, element);\r\n        }\r\n        return element;\r\n      }\r\n      const detached = [];\r\n      this.attachedElements.forEach(elm => {\r\n        detachTrack(this.mediaStreamTrack, elm);\r\n        detached.push(elm);\r\n        this.recycleElement(elm);\r\n        this.emit(TrackEvent.ElementDetached, elm);\r\n      });\r\n      // remove all tracks\r\n      this.attachedElements = [];\r\n      return detached;\r\n    } finally {\r\n      if (this.attachedElements.length === 0) {\r\n        this.removeAppVisibilityListener();\r\n      }\r\n    }\r\n  }\r\n  stop() {\r\n    this.stopMonitor();\r\n    this._mediaStreamTrack.stop();\r\n  }\r\n  enable() {\r\n    this._mediaStreamTrack.enabled = true;\r\n  }\r\n  disable() {\r\n    this._mediaStreamTrack.enabled = false;\r\n  }\r\n  /* @internal */\r\n  stopMonitor() {\r\n    if (this.monitorInterval) {\r\n      clearInterval(this.monitorInterval);\r\n    }\r\n    if (this.timeSyncHandle) {\r\n      cancelAnimationFrame(this.timeSyncHandle);\r\n    }\r\n  }\r\n  /** @internal */\r\n  updateLoggerOptions(loggerOptions) {\r\n    if (loggerOptions.loggerName) {\r\n      this.log = getLogger(loggerOptions.loggerName);\r\n    }\r\n    if (loggerOptions.loggerContextCb) {\r\n      this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    }\r\n  }\r\n  recycleElement(element) {\r\n    if (element instanceof HTMLAudioElement) {\r\n      // we only need to re-use a single element\r\n      let shouldCache = true;\r\n      element.pause();\r\n      recycledElements.forEach(e => {\r\n        if (!e.parentElement) {\r\n          shouldCache = false;\r\n        }\r\n      });\r\n      if (shouldCache) {\r\n        recycledElements.push(element);\r\n      }\r\n    }\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.isInBackground = document.visibilityState === 'hidden';\r\n      if (!this.isInBackground && this.kind === Track.Kind.Video) {\r\n        setTimeout(() => this.attachedElements.forEach(el => el.play().catch(() => {\r\n          /** catch clause necessary for Safari */\r\n        })), 0);\r\n      }\r\n    });\r\n  }\r\n  addAppVisibilityListener() {\r\n    if (isWeb()) {\r\n      this.isInBackground = document.visibilityState === 'hidden';\r\n      document.addEventListener('visibilitychange', this.appVisibilityChangedListener);\r\n    } else {\r\n      this.isInBackground = false;\r\n    }\r\n  }\r\n  removeAppVisibilityListener() {\r\n    if (isWeb()) {\r\n      document.removeEventListener('visibilitychange', this.appVisibilityChangedListener);\r\n    }\r\n  }\r\n}\r\nfunction attachToElement(track, element) {\r\n  let mediaStream;\r\n  if (element.srcObject instanceof MediaStream) {\r\n    mediaStream = element.srcObject;\r\n  } else {\r\n    mediaStream = new MediaStream();\r\n  }\r\n  // check if track matches existing track\r\n  let existingTracks;\r\n  if (track.kind === 'audio') {\r\n    existingTracks = mediaStream.getAudioTracks();\r\n  } else {\r\n    existingTracks = mediaStream.getVideoTracks();\r\n  }\r\n  if (!existingTracks.includes(track)) {\r\n    existingTracks.forEach(et => {\r\n      mediaStream.removeTrack(et);\r\n    });\r\n    mediaStream.addTrack(track);\r\n  }\r\n  if (!isSafari() || !(element instanceof HTMLVideoElement)) {\r\n    // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\r\n    // when a video starts that has the `autoplay` attribute is set.\r\n    // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\r\n    element.autoplay = true;\r\n  }\r\n  // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\r\n  element.muted = mediaStream.getAudioTracks().length === 0;\r\n  if (element instanceof HTMLVideoElement) {\r\n    element.playsInline = true;\r\n  }\r\n  // avoid flicker\r\n  if (element.srcObject !== mediaStream) {\r\n    element.srcObject = mediaStream;\r\n    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\r\n      // Firefox also has a timing issue where video doesn't actually get attached unless\r\n      // performed out-of-band\r\n      // Safari 15 has a bug where in certain layouts, video element renders\r\n      // black until the page is resized or other changes take place.\r\n      // Resetting the src triggers it to render.\r\n      // https://developer.apple.com/forums/thread/690523\r\n      setTimeout(() => {\r\n        element.srcObject = mediaStream;\r\n        // Safari 15 sometimes fails to start a video\r\n        // when the window is backgrounded before the first frame is drawn\r\n        // manually calling play here seems to fix that\r\n        element.play().catch(() => {\r\n          /** do nothing */\r\n        });\r\n      }, 0);\r\n    }\r\n  }\r\n}\r\n/** @internal */\r\nfunction detachTrack(track, element) {\r\n  if (element.srcObject instanceof MediaStream) {\r\n    const mediaStream = element.srcObject;\r\n    mediaStream.removeTrack(track);\r\n    if (mediaStream.getTracks().length > 0) {\r\n      element.srcObject = mediaStream;\r\n    } else {\r\n      element.srcObject = null;\r\n    }\r\n  }\r\n}\r\n(function (Track) {\r\n  let Kind;\r\n  (function (Kind) {\r\n    Kind[\"Audio\"] = \"audio\";\r\n    Kind[\"Video\"] = \"video\";\r\n    Kind[\"Unknown\"] = \"unknown\";\r\n  })(Kind = Track.Kind || (Track.Kind = {}));\r\n  let Source;\r\n  (function (Source) {\r\n    Source[\"Camera\"] = \"camera\";\r\n    Source[\"Microphone\"] = \"microphone\";\r\n    Source[\"ScreenShare\"] = \"screen_share\";\r\n    Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\r\n    Source[\"Unknown\"] = \"unknown\";\r\n  })(Source = Track.Source || (Track.Source = {}));\r\n  let StreamState$1;\r\n  (function (StreamState) {\r\n    StreamState[\"Active\"] = \"active\";\r\n    StreamState[\"Paused\"] = \"paused\";\r\n    StreamState[\"Unknown\"] = \"unknown\";\r\n  })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\r\n  /** @internal */\r\n  function kindToProto(k) {\r\n    switch (k) {\r\n      case Kind.Audio:\r\n        return TrackType.AUDIO;\r\n      case Kind.Video:\r\n        return TrackType.VIDEO;\r\n      default:\r\n        // FIXME this was UNRECOGNIZED before\r\n        return TrackType.DATA;\r\n    }\r\n  }\r\n  Track.kindToProto = kindToProto;\r\n  /** @internal */\r\n  function kindFromProto(t) {\r\n    switch (t) {\r\n      case TrackType.AUDIO:\r\n        return Kind.Audio;\r\n      case TrackType.VIDEO:\r\n        return Kind.Video;\r\n      default:\r\n        return Kind.Unknown;\r\n    }\r\n  }\r\n  Track.kindFromProto = kindFromProto;\r\n  /** @internal */\r\n  function sourceToProto(s) {\r\n    switch (s) {\r\n      case Source.Camera:\r\n        return TrackSource.CAMERA;\r\n      case Source.Microphone:\r\n        return TrackSource.MICROPHONE;\r\n      case Source.ScreenShare:\r\n        return TrackSource.SCREEN_SHARE;\r\n      case Source.ScreenShareAudio:\r\n        return TrackSource.SCREEN_SHARE_AUDIO;\r\n      default:\r\n        return TrackSource.UNKNOWN;\r\n    }\r\n  }\r\n  Track.sourceToProto = sourceToProto;\r\n  /** @internal */\r\n  function sourceFromProto(s) {\r\n    switch (s) {\r\n      case TrackSource.CAMERA:\r\n        return Source.Camera;\r\n      case TrackSource.MICROPHONE:\r\n        return Source.Microphone;\r\n      case TrackSource.SCREEN_SHARE:\r\n        return Source.ScreenShare;\r\n      case TrackSource.SCREEN_SHARE_AUDIO:\r\n        return Source.ScreenShareAudio;\r\n      default:\r\n        return Source.Unknown;\r\n    }\r\n  }\r\n  Track.sourceFromProto = sourceFromProto;\r\n  /** @internal */\r\n  function streamStateFromProto(s) {\r\n    switch (s) {\r\n      case StreamState.ACTIVE:\r\n        return StreamState$1.Active;\r\n      case StreamState.PAUSED:\r\n        return StreamState$1.Paused;\r\n      default:\r\n        return StreamState$1.Unknown;\r\n    }\r\n  }\r\n  Track.streamStateFromProto = streamStateFromProto;\r\n})(Track || (Track = {}));\r\n\r\nclass VideoPreset {\r\n  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {\r\n    if (typeof widthOrOptions === 'object') {\r\n      this.width = widthOrOptions.width;\r\n      this.height = widthOrOptions.height;\r\n      this.aspectRatio = widthOrOptions.aspectRatio;\r\n      this.encoding = {\r\n        maxBitrate: widthOrOptions.maxBitrate,\r\n        maxFramerate: widthOrOptions.maxFramerate,\r\n        priority: widthOrOptions.priority\r\n      };\r\n    } else if (height !== undefined && maxBitrate !== undefined) {\r\n      this.width = widthOrOptions;\r\n      this.height = height;\r\n      this.aspectRatio = widthOrOptions / height;\r\n      this.encoding = {\r\n        maxBitrate,\r\n        maxFramerate,\r\n        priority\r\n      };\r\n    } else {\r\n      throw new TypeError('Unsupported options: provide at least width, height and maxBitrate');\r\n    }\r\n  }\r\n  get resolution() {\r\n    return {\r\n      width: this.width,\r\n      height: this.height,\r\n      frameRate: this.encoding.maxFramerate,\r\n      aspectRatio: this.aspectRatio\r\n    };\r\n  }\r\n}\r\nconst backupCodecs = ['vp8', 'h264'];\r\nconst videoCodecs = ['vp8', 'h264', 'vp9', 'av1'];\r\nfunction isBackupCodec(codec) {\r\n  return !!backupCodecs.find(backup => backup === codec);\r\n}\r\nvar BackupCodecPolicy;\r\n(function (BackupCodecPolicy) {\r\n  // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\r\n  BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\r\n  // multi-codec simulcast, publish both primary and backup codec at the same time\r\n  BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\r\n  // always use backup codec only\r\n  BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\r\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\r\nvar AudioPresets;\r\n(function (AudioPresets) {\r\n  AudioPresets.telephone = {\r\n    maxBitrate: 12000\r\n  };\r\n  AudioPresets.speech = {\r\n    maxBitrate: 24000\r\n  };\r\n  AudioPresets.music = {\r\n    maxBitrate: 48000\r\n  };\r\n  AudioPresets.musicStereo = {\r\n    maxBitrate: 64000\r\n  };\r\n  AudioPresets.musicHighQuality = {\r\n    maxBitrate: 96000\r\n  };\r\n  AudioPresets.musicHighQualityStereo = {\r\n    maxBitrate: 128000\r\n  };\r\n})(AudioPresets || (AudioPresets = {}));\r\n/**\r\n * Sane presets for video resolution/encoding\r\n */\r\nconst VideoPresets = {\r\n  h90: new VideoPreset(160, 90, 90000, 20),\r\n  h180: new VideoPreset(320, 180, 160000, 20),\r\n  h216: new VideoPreset(384, 216, 180000, 20),\r\n  h360: new VideoPreset(640, 360, 450000, 20),\r\n  h540: new VideoPreset(960, 540, 800000, 25),\r\n  h720: new VideoPreset(1280, 720, 1700000, 30),\r\n  h1080: new VideoPreset(1920, 1080, 3000000, 30),\r\n  h1440: new VideoPreset(2560, 1440, 5000000, 30),\r\n  h2160: new VideoPreset(3840, 2160, 8000000, 30)\r\n};\r\n/**\r\n * Four by three presets\r\n */\r\nconst VideoPresets43 = {\r\n  h120: new VideoPreset(160, 120, 70000, 20),\r\n  h180: new VideoPreset(240, 180, 125000, 20),\r\n  h240: new VideoPreset(320, 240, 140000, 20),\r\n  h360: new VideoPreset(480, 360, 330000, 20),\r\n  h480: new VideoPreset(640, 480, 500000, 20),\r\n  h540: new VideoPreset(720, 540, 600000, 25),\r\n  h720: new VideoPreset(960, 720, 1300000, 30),\r\n  h1080: new VideoPreset(1440, 1080, 2300000, 30),\r\n  h1440: new VideoPreset(1920, 1440, 3800000, 30)\r\n};\r\nconst ScreenSharePresets = {\r\n  h360fps3: new VideoPreset(640, 360, 200000, 3, 'medium'),\r\n  h360fps15: new VideoPreset(640, 360, 400000, 15, 'medium'),\r\n  h720fps5: new VideoPreset(1280, 720, 800000, 5, 'medium'),\r\n  h720fps15: new VideoPreset(1280, 720, 1500000, 15, 'medium'),\r\n  h720fps30: new VideoPreset(1280, 720, 2000000, 30, 'medium'),\r\n  h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, 'medium'),\r\n  h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, 'medium'),\r\n  // original resolution, without resizing\r\n  original: new VideoPreset(0, 0, 7000000, 30, 'medium')\r\n};\r\n\r\nconst separator = '|';\r\nconst ddExtensionURI = 'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension';\r\nfunction unpackStreamId(packed) {\r\n  const parts = packed.split(separator);\r\n  if (parts.length > 1) {\r\n    return [parts[0], packed.substr(parts[0].length + 1)];\r\n  }\r\n  return [packed, ''];\r\n}\r\nfunction sleep(duration) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    return new Promise(resolve => CriticalTimers.setTimeout(resolve, duration));\r\n  });\r\n}\r\n/** @internal */\r\nfunction supportsTransceiver() {\r\n  return 'addTransceiver' in RTCPeerConnection.prototype;\r\n}\r\n/** @internal */\r\nfunction supportsAddTrack() {\r\n  return 'addTrack' in RTCPeerConnection.prototype;\r\n}\r\nfunction supportsAdaptiveStream() {\r\n  return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\r\n}\r\nfunction supportsDynacast() {\r\n  return supportsTransceiver();\r\n}\r\nfunction supportsAV1() {\r\n  if (!('getCapabilities' in RTCRtpSender)) {\r\n    return false;\r\n  }\r\n  if (isSafari()) {\r\n    // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\r\n    return false;\r\n  }\r\n  const capabilities = RTCRtpSender.getCapabilities('video');\r\n  let hasAV1 = false;\r\n  if (capabilities) {\r\n    for (const codec of capabilities.codecs) {\r\n      if (codec.mimeType === 'video/AV1') {\r\n        hasAV1 = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return hasAV1;\r\n}\r\nfunction supportsVP9() {\r\n  if (!('getCapabilities' in RTCRtpSender)) {\r\n    return false;\r\n  }\r\n  if (isFireFox()) {\r\n    // technically speaking FireFox supports VP9, but SVC publishing is broken\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\r\n    return false;\r\n  }\r\n  if (isSafari()) {\r\n    const browser = getBrowser();\r\n    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, '16') < 0) {\r\n      // Safari 16 and below does not support VP9\r\n      return false;\r\n    }\r\n  }\r\n  const capabilities = RTCRtpSender.getCapabilities('video');\r\n  let hasVP9 = false;\r\n  if (capabilities) {\r\n    for (const codec of capabilities.codecs) {\r\n      if (codec.mimeType === 'video/VP9') {\r\n        hasVP9 = true;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return hasVP9;\r\n}\r\nfunction isSVCCodec(codec) {\r\n  return codec === 'av1' || codec === 'vp9';\r\n}\r\nfunction supportsSetSinkId(elm) {\r\n  if (!document) {\r\n    return false;\r\n  }\r\n  if (!elm) {\r\n    elm = document.createElement('audio');\r\n  }\r\n  return 'setSinkId' in elm;\r\n}\r\nfunction isBrowserSupported() {\r\n  if (typeof RTCPeerConnection === 'undefined') {\r\n    return false;\r\n  }\r\n  return supportsTransceiver() || supportsAddTrack();\r\n}\r\nfunction isFireFox() {\r\n  var _a;\r\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Firefox';\r\n}\r\nfunction isSafari() {\r\n  var _a;\r\n  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === 'Safari';\r\n}\r\nfunction isSafariBased() {\r\n  const b = getBrowser();\r\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' || (b === null || b === void 0 ? void 0 : b.os) === 'iOS';\r\n}\r\nfunction isSafari17() {\r\n  const b = getBrowser();\r\n  return (b === null || b === void 0 ? void 0 : b.name) === 'Safari' && b.version.startsWith('17.');\r\n}\r\nfunction isSafariSvcApi(browser) {\r\n  if (!browser) {\r\n    browser = getBrowser();\r\n  }\r\n  // Safari 18.4 requires legacy svc api and scaleResolutionDown to be set\r\n  return (browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '18.3') > 0;\r\n}\r\nfunction isMobile() {\r\n  var _a, _b;\r\n  if (!isWeb()) return false;\r\n  return (\r\n    // @ts-expect-error `userAgentData` is not yet part of typescript\r\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)\r\n  );\r\n}\r\nfunction isE2EESimulcastSupported() {\r\n  const browser = getBrowser();\r\n  const supportedSafariVersion = '17.2'; // see https://bugs.webkit.org/show_bug.cgi?id=257803\r\n  if (browser) {\r\n    if (browser.name !== 'Safari' && browser.os !== 'iOS') {\r\n      return true;\r\n    } else if (browser.os === 'iOS' && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {\r\n      return true;\r\n    } else if (browser.name === 'Safari' && compareVersions(supportedSafariVersion, browser.version) >= 0) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n}\r\nfunction isWeb() {\r\n  return typeof document !== 'undefined';\r\n}\r\nfunction isReactNative() {\r\n  // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\r\n  return navigator.product == 'ReactNative';\r\n}\r\nfunction isCloud(serverUrl) {\r\n  return serverUrl.hostname.endsWith('.livekit.cloud') || serverUrl.hostname.endsWith('.livekit.run');\r\n}\r\nfunction getLKReactNativeInfo() {\r\n  // global defined only for ReactNative.\r\n  // @ts-ignore\r\n  if (global && global.LiveKitReactNativeGlobal) {\r\n    // @ts-ignore\r\n    return global.LiveKitReactNativeGlobal;\r\n  }\r\n  return undefined;\r\n}\r\nfunction getReactNativeOs() {\r\n  if (!isReactNative()) {\r\n    return undefined;\r\n  }\r\n  let info = getLKReactNativeInfo();\r\n  if (info) {\r\n    return info.platform;\r\n  }\r\n  return undefined;\r\n}\r\nfunction getDevicePixelRatio() {\r\n  if (isWeb()) {\r\n    return window.devicePixelRatio;\r\n  }\r\n  if (isReactNative()) {\r\n    let info = getLKReactNativeInfo();\r\n    if (info) {\r\n      return info.devicePixelRatio;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\nfunction compareVersions(v1, v2) {\r\n  const parts1 = v1.split('.');\r\n  const parts2 = v2.split('.');\r\n  const k = Math.min(parts1.length, parts2.length);\r\n  for (let i = 0; i < k; ++i) {\r\n    const p1 = parseInt(parts1[i], 10);\r\n    const p2 = parseInt(parts2[i], 10);\r\n    if (p1 > p2) return 1;\r\n    if (p1 < p2) return -1;\r\n    if (i === k - 1 && p1 === p2) return 0;\r\n  }\r\n  if (v1 === '' && v2 !== '') {\r\n    return -1;\r\n  } else if (v2 === '') {\r\n    return 1;\r\n  }\r\n  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\r\n}\r\nfunction roDispatchCallback(entries) {\r\n  for (const entry of entries) {\r\n    entry.target.handleResize(entry);\r\n  }\r\n}\r\nfunction ioDispatchCallback(entries) {\r\n  for (const entry of entries) {\r\n    entry.target.handleVisibilityChanged(entry);\r\n  }\r\n}\r\nlet resizeObserver = null;\r\nconst getResizeObserver = () => {\r\n  if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\r\n  return resizeObserver;\r\n};\r\nlet intersectionObserver = null;\r\nconst getIntersectionObserver = () => {\r\n  if (!intersectionObserver) {\r\n    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\r\n      root: null,\r\n      rootMargin: '0px'\r\n    });\r\n  }\r\n  return intersectionObserver;\r\n};\r\nfunction getClientInfo() {\r\n  var _a;\r\n  const info = new ClientInfo({\r\n    sdk: ClientInfo_SDK.JS,\r\n    protocol: protocolVersion,\r\n    version\r\n  });\r\n  if (isReactNative()) {\r\n    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : '';\r\n  }\r\n  return info;\r\n}\r\nlet emptyVideoStreamTrack;\r\nfunction getEmptyVideoStreamTrack() {\r\n  if (!emptyVideoStreamTrack) {\r\n    emptyVideoStreamTrack = createDummyVideoStreamTrack();\r\n  }\r\n  return emptyVideoStreamTrack.clone();\r\n}\r\nfunction createDummyVideoStreamTrack() {\r\n  let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\r\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\r\n  let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n  const canvas = document.createElement('canvas');\r\n  // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  const ctx = canvas.getContext('2d');\r\n  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  if (paintContent && ctx) {\r\n    ctx.beginPath();\r\n    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\r\n    ctx.closePath();\r\n    ctx.fillStyle = 'grey';\r\n    ctx.fill();\r\n  }\r\n  // @ts-ignore\r\n  const dummyStream = canvas.captureStream();\r\n  const [dummyTrack] = dummyStream.getTracks();\r\n  if (!dummyTrack) {\r\n    throw Error('Could not get empty media stream video track');\r\n  }\r\n  dummyTrack.enabled = enabled;\r\n  return dummyTrack;\r\n}\r\nlet emptyAudioStreamTrack;\r\nfunction getEmptyAudioStreamTrack() {\r\n  if (!emptyAudioStreamTrack) {\r\n    // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\r\n    const ctx = new AudioContext();\r\n    const oscillator = ctx.createOscillator();\r\n    const gain = ctx.createGain();\r\n    gain.gain.setValueAtTime(0, 0);\r\n    const dst = ctx.createMediaStreamDestination();\r\n    oscillator.connect(gain);\r\n    gain.connect(dst);\r\n    oscillator.start();\r\n    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\r\n    if (!emptyAudioStreamTrack) {\r\n      throw Error('Could not get empty media stream audio track');\r\n    }\r\n    emptyAudioStreamTrack.enabled = false;\r\n  }\r\n  return emptyAudioStreamTrack.clone();\r\n}\r\nclass Future {\r\n  constructor(futureBase, onFinally) {\r\n    this.onFinally = onFinally;\r\n    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      this.resolve = resolve;\r\n      this.reject = reject;\r\n      if (futureBase) {\r\n        yield futureBase(resolve, reject);\r\n      }\r\n    })).finally(() => {\r\n      var _a;\r\n      return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    });\r\n  }\r\n}\r\n/**\r\n * Creates and returns an analyser web audio node that is attached to the provided track.\r\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\r\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\r\n */\r\nfunction createAudioAnalyser(track, options) {\r\n  const opts = Object.assign({\r\n    cloneTrack: false,\r\n    fftSize: 2048,\r\n    smoothingTimeConstant: 0.8,\r\n    minDecibels: -100,\r\n    maxDecibels: -80\r\n  }, options);\r\n  const audioContext = getNewAudioContext();\r\n  if (!audioContext) {\r\n    throw new Error('Audio Context not supported on this browser');\r\n  }\r\n  const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\r\n  const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));\r\n  const analyser = audioContext.createAnalyser();\r\n  analyser.minDecibels = opts.minDecibels;\r\n  analyser.maxDecibels = opts.maxDecibels;\r\n  analyser.fftSize = opts.fftSize;\r\n  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\r\n  mediaStreamSource.connect(analyser);\r\n  const dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n  /**\r\n   * Calculates the current volume of the track in the range from 0 to 1\r\n   */\r\n  const calculateVolume = () => {\r\n    analyser.getByteFrequencyData(dataArray);\r\n    let sum = 0;\r\n    for (const amplitude of dataArray) {\r\n      sum += Math.pow(amplitude / 255, 2);\r\n    }\r\n    const volume = Math.sqrt(sum / dataArray.length);\r\n    return volume;\r\n  };\r\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\r\n    yield audioContext.close();\r\n    if (opts.cloneTrack) {\r\n      streamTrack.stop();\r\n    }\r\n  });\r\n  return {\r\n    calculateVolume,\r\n    analyser,\r\n    cleanup\r\n  };\r\n}\r\nfunction isVideoCodec(maybeCodec) {\r\n  return videoCodecs.includes(maybeCodec);\r\n}\r\nfunction unwrapConstraint(constraint) {\r\n  if (typeof constraint === 'string' || typeof constraint === 'number') {\r\n    return constraint;\r\n  }\r\n  if (Array.isArray(constraint)) {\r\n    return constraint[0];\r\n  }\r\n  if (constraint.exact) {\r\n    if (Array.isArray(constraint.exact)) {\r\n      return constraint.exact[0];\r\n    }\r\n    return constraint.exact;\r\n  }\r\n  if (constraint.ideal) {\r\n    if (Array.isArray(constraint.ideal)) {\r\n      return constraint.ideal[0];\r\n    }\r\n    return constraint.ideal;\r\n  }\r\n  throw Error('could not unwrap constraint');\r\n}\r\nfunction toWebsocketUrl(url) {\r\n  if (url.startsWith('http')) {\r\n    return url.replace(/^(http)/, 'ws');\r\n  }\r\n  return url;\r\n}\r\nfunction toHttpUrl(url) {\r\n  if (url.startsWith('ws')) {\r\n    return url.replace(/^(ws)/, 'http');\r\n  }\r\n  return url;\r\n}\r\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\r\n  return transcription.segments.map(_ref => {\r\n    let {\r\n      id,\r\n      text,\r\n      language,\r\n      startTime,\r\n      endTime,\r\n      final\r\n    } = _ref;\r\n    var _a;\r\n    const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\r\n    const lastReceivedTime = Date.now();\r\n    if (final) {\r\n      firstReceivedTimesMap.delete(id);\r\n    } else {\r\n      firstReceivedTimesMap.set(id, firstReceivedTime);\r\n    }\r\n    return {\r\n      id,\r\n      text,\r\n      startTime: Number.parseInt(startTime.toString()),\r\n      endTime: Number.parseInt(endTime.toString()),\r\n      final,\r\n      language,\r\n      firstReceivedTime,\r\n      lastReceivedTime\r\n    };\r\n  });\r\n}\r\nfunction extractChatMessage(msg) {\r\n  const {\r\n    id,\r\n    timestamp,\r\n    message,\r\n    editTimestamp\r\n  } = msg;\r\n  return {\r\n    id,\r\n    timestamp: Number.parseInt(timestamp.toString()),\r\n    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\r\n    message\r\n  };\r\n}\r\nfunction getDisconnectReasonFromConnectionError(e) {\r\n  switch (e.reason) {\r\n    case ConnectionErrorReason.LeaveRequest:\r\n      return e.context;\r\n    case ConnectionErrorReason.Cancelled:\r\n      return DisconnectReason.CLIENT_INITIATED;\r\n    case ConnectionErrorReason.NotAllowed:\r\n      return DisconnectReason.USER_REJECTED;\r\n    case ConnectionErrorReason.ServerUnreachable:\r\n      return DisconnectReason.JOIN_FAILURE;\r\n    default:\r\n      return DisconnectReason.UNKNOWN_REASON;\r\n  }\r\n}\r\n/** convert bigints to numbers preserving undefined values */\r\nfunction bigIntToNumber(value) {\r\n  return value !== undefined ? Number(value) : undefined;\r\n}\r\n/** convert numbers to bigints preserving undefined values */\r\nfunction numberToBigInt(value) {\r\n  return value !== undefined ? BigInt(value) : undefined;\r\n}\r\nfunction isLocalTrack(track) {\r\n  return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\r\n}\r\nfunction isAudioTrack(track) {\r\n  return !!track && track.kind == Track.Kind.Audio;\r\n}\r\nfunction isVideoTrack(track) {\r\n  return !!track && track.kind == Track.Kind.Video;\r\n}\r\nfunction isLocalVideoTrack(track) {\r\n  return isLocalTrack(track) && isVideoTrack(track);\r\n}\r\nfunction isLocalAudioTrack(track) {\r\n  return isLocalTrack(track) && isAudioTrack(track);\r\n}\r\nfunction isRemoteTrack(track) {\r\n  return !!track && !track.isLocal;\r\n}\r\nfunction isRemotePub(pub) {\r\n  return !!pub && !pub.isLocal;\r\n}\r\nfunction isRemoteVideoTrack(track) {\r\n  return isRemoteTrack(track) && isVideoTrack(track);\r\n}\r\nfunction isLocalParticipant(p) {\r\n  return p.isLocal;\r\n}\r\nfunction isRemoteParticipant(p) {\r\n  return !p.isLocal;\r\n}\r\nfunction splitUtf8(s, n) {\r\n  // adapted from https://stackoverflow.com/a/6043797\r\n  const result = [];\r\n  let encoded = new TextEncoder().encode(s);\r\n  while (encoded.length > n) {\r\n    let k = n;\r\n    while (k > 0) {\r\n      const byte = encoded[k];\r\n      if (byte !== undefined && (byte & 0xc0) !== 0x80) {\r\n        break;\r\n      }\r\n      k--;\r\n    }\r\n    result.push(encoded.slice(0, k));\r\n    encoded = encoded.slice(k);\r\n  }\r\n  if (encoded.length > 0) {\r\n    result.push(encoded);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\r\n  var _a, _b;\r\n  var _c, _d;\r\n  const {\r\n    optionsWithoutProcessor,\r\n    audioProcessor,\r\n    videoProcessor\r\n  } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\r\n  const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\r\n  const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\r\n  const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\r\n  if (clonedOptions.audio === true) clonedOptions.audio = {};\r\n  if (clonedOptions.video === true) clonedOptions.video = {};\r\n  // use defaults\r\n  if (clonedOptions.audio) {\r\n    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\r\n    (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\r\n      ideal: 'default'\r\n    };\r\n    if (audioProcessor || defaultAudioProcessor) {\r\n      clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\r\n    }\r\n  }\r\n  if (clonedOptions.video) {\r\n    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\r\n    (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\r\n      ideal: 'default'\r\n    };\r\n    if (videoProcessor || defaultVideoProcessor) {\r\n      clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\r\n    }\r\n  }\r\n  return clonedOptions;\r\n}\r\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\r\n  Object.keys(objectToMerge).forEach(key => {\r\n    if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\r\n  });\r\n  return mainObject;\r\n}\r\nfunction constraintsForOptions(options) {\r\n  var _a, _b;\r\n  var _c, _d;\r\n  const constraints = {};\r\n  if (options.video) {\r\n    // default video options\r\n    if (typeof options.video === 'object') {\r\n      const videoOptions = {};\r\n      const target = videoOptions;\r\n      const source = options.video;\r\n      Object.keys(source).forEach(key => {\r\n        switch (key) {\r\n          case 'resolution':\r\n            // flatten VideoResolution fields\r\n            mergeObjectWithoutOverwriting(target, source.resolution);\r\n            break;\r\n          default:\r\n            target[key] = source[key];\r\n        }\r\n      });\r\n      constraints.video = videoOptions;\r\n      (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\r\n        ideal: 'default'\r\n      };\r\n    } else {\r\n      constraints.video = options.video ? {\r\n        deviceId: {\r\n          ideal: 'default'\r\n        }\r\n      } : false;\r\n    }\r\n  } else {\r\n    constraints.video = false;\r\n  }\r\n  if (options.audio) {\r\n    if (typeof options.audio === 'object') {\r\n      constraints.audio = options.audio;\r\n      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\r\n        ideal: 'default'\r\n      };\r\n    } else {\r\n      constraints.audio = {\r\n        deviceId: {\r\n          ideal: 'default'\r\n        }\r\n      };\r\n    }\r\n  } else {\r\n    constraints.audio = false;\r\n  }\r\n  return constraints;\r\n}\r\n/**\r\n * This function detects silence on a given [[Track]] instance.\r\n * Returns true if the track seems to be entirely silent.\r\n */\r\nfunction detectSilence(track_1) {\r\n  return __awaiter(this, arguments, void 0, function (track) {\r\n    let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\r\n    return function* () {\r\n      const ctx = getNewAudioContext();\r\n      if (ctx) {\r\n        const analyser = ctx.createAnalyser();\r\n        analyser.fftSize = 2048;\r\n        const bufferLength = analyser.frequencyBinCount;\r\n        const dataArray = new Uint8Array(bufferLength);\r\n        const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));\r\n        source.connect(analyser);\r\n        yield sleep(timeOffset);\r\n        analyser.getByteTimeDomainData(dataArray);\r\n        const someNoise = dataArray.some(sample => sample !== 128 && sample !== 0);\r\n        ctx.close();\r\n        return !someNoise;\r\n      }\r\n      return false;\r\n    }();\r\n  });\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction getNewAudioContext() {\r\n  var _a;\r\n  const AudioContext =\r\n  // @ts-ignore\r\n  typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\r\n  if (AudioContext) {\r\n    const audioContext = new AudioContext({\r\n      latencyHint: 'interactive'\r\n    });\r\n    // If the audio context is suspended, we need to resume it when the user clicks on the page\r\n    if (audioContext.state === 'suspended' && typeof window !== 'undefined' && ((_a = window.document) === null || _a === void 0 ? void 0 : _a.body)) {\r\n      const handleResume = () => __awaiter(this, void 0, void 0, function* () {\r\n        var _a;\r\n        try {\r\n          if (audioContext.state === 'suspended') {\r\n            yield audioContext.resume();\r\n          }\r\n        } catch (e) {\r\n          console.warn('Error trying to auto-resume audio context', e);\r\n        }\r\n        (_a = window.document.body) === null || _a === void 0 ? void 0 : _a.removeEventListener('click', handleResume);\r\n      });\r\n      window.document.body.addEventListener('click', handleResume);\r\n    }\r\n    return audioContext;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction kindToSource(kind) {\r\n  if (kind === 'audioinput') {\r\n    return Track.Source.Microphone;\r\n  } else if (kind === 'videoinput') {\r\n    return Track.Source.Camera;\r\n  } else {\r\n    return Track.Source.Unknown;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction sourceToKind(source) {\r\n  if (source === Track.Source.Microphone) {\r\n    return 'audioinput';\r\n  } else if (source === Track.Source.Camera) {\r\n    return 'videoinput';\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction screenCaptureToDisplayMediaStreamOptions(options) {\r\n  var _a, _b;\r\n  let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\r\n  // treat 0 as uncapped\r\n  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\r\n    videoConstraints = typeof videoConstraints === 'boolean' ? {} : videoConstraints;\r\n    if (isSafari()) {\r\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\r\n        width: {\r\n          max: options.resolution.width\r\n        },\r\n        height: {\r\n          max: options.resolution.height\r\n        },\r\n        frameRate: options.resolution.frameRate\r\n      });\r\n    } else {\r\n      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\r\n        width: {\r\n          ideal: options.resolution.width\r\n        },\r\n        height: {\r\n          ideal: options.resolution.height\r\n        },\r\n        frameRate: options.resolution.frameRate\r\n      });\r\n    }\r\n  }\r\n  return {\r\n    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\r\n    video: videoConstraints,\r\n    // @ts-expect-error support for experimental display media features\r\n    controller: options.controller,\r\n    selfBrowserSurface: options.selfBrowserSurface,\r\n    surfaceSwitching: options.surfaceSwitching,\r\n    systemAudio: options.systemAudio,\r\n    preferCurrentTab: options.preferCurrentTab\r\n  };\r\n}\r\nfunction mimeTypeToVideoCodecString(mimeType) {\r\n  return mimeType.split('/')[1].toLowerCase();\r\n}\r\nfunction getTrackPublicationInfo(tracks) {\r\n  const infos = [];\r\n  tracks.forEach(track => {\r\n    if (track.track !== undefined) {\r\n      infos.push(new TrackPublishedResponse({\r\n        cid: track.track.mediaStreamID,\r\n        track: track.trackInfo\r\n      }));\r\n    }\r\n  });\r\n  return infos;\r\n}\r\nfunction getLogContextFromTrack(track) {\r\n  if ('mediaStreamTrack' in track) {\r\n    return {\r\n      trackID: track.sid,\r\n      source: track.source,\r\n      muted: track.isMuted,\r\n      enabled: track.mediaStreamTrack.enabled,\r\n      kind: track.kind,\r\n      streamID: track.mediaStreamID,\r\n      streamTrackID: track.mediaStreamTrack.id\r\n    };\r\n  } else {\r\n    return {\r\n      trackID: track.trackSid,\r\n      enabled: track.isEnabled,\r\n      muted: track.isMuted,\r\n      trackInfo: Object.assign({\r\n        mimeType: track.mimeType,\r\n        name: track.trackName,\r\n        encrypted: track.isEncrypted,\r\n        kind: track.kind,\r\n        source: track.source\r\n      }, track.track ? getLogContextFromTrack(track.track) : {})\r\n    };\r\n  }\r\n}\r\nfunction supportsSynchronizationSources() {\r\n  return typeof RTCRtpReceiver !== 'undefined' && 'getSynchronizationSources' in RTCRtpReceiver;\r\n}\r\nfunction diffAttributes(oldValues, newValues) {\r\n  var _a;\r\n  if (oldValues === undefined) {\r\n    oldValues = {};\r\n  }\r\n  if (newValues === undefined) {\r\n    newValues = {};\r\n  }\r\n  const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];\r\n  const diff = {};\r\n  for (const key of allKeys) {\r\n    if (oldValues[key] !== newValues[key]) {\r\n      diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n  }\r\n  return diff;\r\n}\r\n/** @internal */\r\nfunction extractProcessorsFromOptions(options) {\r\n  const newOptions = Object.assign({}, options);\r\n  let audioProcessor;\r\n  let videoProcessor;\r\n  if (typeof newOptions.audio === 'object' && newOptions.audio.processor) {\r\n    audioProcessor = newOptions.audio.processor;\r\n    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\r\n      processor: undefined\r\n    });\r\n  }\r\n  if (typeof newOptions.video === 'object' && newOptions.video.processor) {\r\n    videoProcessor = newOptions.video.processor;\r\n    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\r\n      processor: undefined\r\n    });\r\n  }\r\n  return {\r\n    audioProcessor,\r\n    videoProcessor,\r\n    optionsWithoutProcessor: cloneDeep(newOptions)\r\n  };\r\n}\r\nfunction getTrackSourceFromProto(source) {\r\n  switch (source) {\r\n    case TrackSource.CAMERA:\r\n      return Track.Source.Camera;\r\n    case TrackSource.MICROPHONE:\r\n      return Track.Source.Microphone;\r\n    case TrackSource.SCREEN_SHARE:\r\n      return Track.Source.ScreenShare;\r\n    case TrackSource.SCREEN_SHARE_AUDIO:\r\n      return Track.Source.ScreenShareAudio;\r\n    default:\r\n      return Track.Source.Unknown;\r\n  }\r\n}\r\n\r\n/**\r\n * @experimental\r\n */\r\nclass E2EEManager extends eventsExports.EventEmitter {\r\n  constructor(options) {\r\n    super();\r\n    this.onWorkerMessage = ev => {\r\n      var _a, _b;\r\n      const {\r\n        kind,\r\n        data\r\n      } = ev.data;\r\n      switch (kind) {\r\n        case 'error':\r\n          livekitLogger.error(data.error.message);\r\n          this.emit(EncryptionEvent.EncryptionError, data.error);\r\n          break;\r\n        case 'initAck':\r\n          if (data.enabled) {\r\n            this.keyProvider.getKeys().forEach(keyInfo => {\r\n              this.postKey(keyInfo);\r\n            });\r\n          }\r\n          break;\r\n        case 'enable':\r\n          if (data.enabled) {\r\n            this.keyProvider.getKeys().forEach(keyInfo => {\r\n              this.postKey(keyInfo);\r\n            });\r\n          }\r\n          if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\r\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\r\n            this.encryptionEnabled = data.enabled;\r\n          } else if (data.participantIdentity) {\r\n            const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\r\n            if (!participant) {\r\n              throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\r\n            }\r\n            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\r\n          }\r\n          break;\r\n        case 'ratchetKey':\r\n          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.ratchetResult, data.participantIdentity, data.keyIndex);\r\n          break;\r\n      }\r\n    };\r\n    this.onWorkerError = ev => {\r\n      livekitLogger.error('e2ee worker encountered an error:', {\r\n        error: ev.error\r\n      });\r\n      this.emit(EncryptionEvent.EncryptionError, ev.error);\r\n    };\r\n    this.keyProvider = options.keyProvider;\r\n    this.worker = options.worker;\r\n    this.encryptionEnabled = false;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setup(room) {\r\n    if (!isE2EESupported()) {\r\n      throw new DeviceUnsupportedError('tried to setup end-to-end encryption on an unsupported browser');\r\n    }\r\n    livekitLogger.info('setting up e2ee');\r\n    if (room !== this.room) {\r\n      this.room = room;\r\n      this.setupEventListeners(room, this.keyProvider);\r\n      // this.worker = new Worker('');\r\n      const msg = {\r\n        kind: 'init',\r\n        data: {\r\n          keyProviderOptions: this.keyProvider.getOptions(),\r\n          loglevel: workerLogger.getLevel()\r\n        }\r\n      };\r\n      if (this.worker) {\r\n        livekitLogger.info(\"initializing worker\", {\r\n          worker: this.worker\r\n        });\r\n        this.worker.onmessage = this.onWorkerMessage;\r\n        this.worker.onerror = this.onWorkerError;\r\n        this.worker.postMessage(msg);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setParticipantCryptorEnabled(enabled, participantIdentity) {\r\n    livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\r\n    this.postEnable(enabled, participantIdentity);\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setSifTrailer(trailer) {\r\n    if (!trailer || trailer.length === 0) {\r\n      livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\r\n    } else {\r\n      this.postSifTrailer(trailer);\r\n    }\r\n  }\r\n  setupEngine(engine) {\r\n    engine.on(EngineEvent.RTPVideoMapUpdate, rtpMap => {\r\n      this.postRTPMap(rtpMap);\r\n    });\r\n  }\r\n  setupEventListeners(room, keyProvider) {\r\n    room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\r\n    room.on(RoomEvent.ConnectionStateChanged, state => {\r\n      if (state === ConnectionState.Connected) {\r\n        room.remoteParticipants.forEach(participant => {\r\n          participant.trackPublications.forEach(pub => {\r\n            this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\r\n          });\r\n        });\r\n      }\r\n    }).on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {\r\n      var _a;\r\n      const msg = {\r\n        kind: 'removeTransform',\r\n        data: {\r\n          participantIdentity: participant.identity,\r\n          trackId: track.mediaStreamID\r\n        }\r\n      };\r\n      (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\r\n    }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {\r\n      this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\r\n    }).on(RoomEvent.SignalConnected, () => {\r\n      if (!this.room) {\r\n        throw new TypeError(\"expected room to be present on signal connect\");\r\n      }\r\n      keyProvider.getKeys().forEach(keyInfo => {\r\n        this.postKey(keyInfo);\r\n      });\r\n      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\r\n    });\r\n    room.localParticipant.on(ParticipantEvent.LocalTrackPublished, publication => __awaiter(this, void 0, void 0, function* () {\r\n      this.setupE2EESender(publication.track, publication.track.sender);\r\n    }));\r\n    keyProvider.on(KeyProviderEvent.SetKey, keyInfo => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));\r\n  }\r\n  postRatchetRequest(participantIdentity, keyIndex) {\r\n    if (!this.worker) {\r\n      throw Error('could not ratchet key, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'ratchetRequest',\r\n      data: {\r\n        participantIdentity: participantIdentity,\r\n        keyIndex\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postKey(_ref) {\r\n    let {\r\n      key,\r\n      participantIdentity,\r\n      keyIndex\r\n    } = _ref;\r\n    var _a;\r\n    if (!this.worker) {\r\n      throw Error('could not set key, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setKey',\r\n      data: {\r\n        participantIdentity: participantIdentity,\r\n        isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\r\n        key,\r\n        keyIndex\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postEnable(enabled, participantIdentity) {\r\n    if (this.worker) {\r\n      const enableMsg = {\r\n        kind: 'enable',\r\n        data: {\r\n          enabled,\r\n          participantIdentity\r\n        }\r\n      };\r\n      this.worker.postMessage(enableMsg);\r\n    } else {\r\n      throw new ReferenceError('failed to enable e2ee, worker is not ready');\r\n    }\r\n  }\r\n  postRTPMap(map) {\r\n    var _a;\r\n    if (!this.worker) {\r\n      throw TypeError('could not post rtp map, worker is missing');\r\n    }\r\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\r\n      throw TypeError('could not post rtp map, local participant identity is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setRTPMap',\r\n      data: {\r\n        map,\r\n        participantIdentity: this.room.localParticipant.identity\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  postSifTrailer(trailer) {\r\n    if (!this.worker) {\r\n      throw Error('could not post SIF trailer, worker is missing');\r\n    }\r\n    const msg = {\r\n      kind: 'setSifTrailer',\r\n      data: {\r\n        trailer\r\n      }\r\n    };\r\n    this.worker.postMessage(msg);\r\n  }\r\n  setupE2EEReceiver(track, remoteId, trackInfo) {\r\n    if (!track.receiver) {\r\n      return;\r\n    }\r\n    if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === '') {\r\n      throw new TypeError('MimeType missing from trackInfo, cannot set up E2EE cryptor');\r\n    }\r\n    this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === 'video' ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\r\n  }\r\n  setupE2EESender(track, sender) {\r\n    if (!isLocalTrack(track) || !sender) {\r\n      if (!sender) livekitLogger.warn('early return because sender is not ready');\r\n      return;\r\n    }\r\n    this.handleSender(sender, track.mediaStreamID, undefined);\r\n  }\r\n  /**\r\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\r\n   * a frame decoder.\r\n   *\r\n   */\r\n  handleReceiver(receiver, trackId, participantIdentity, codec) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.worker) {\r\n        return;\r\n      }\r\n      if (isScriptTransformSupported()) {\r\n        const options = {\r\n          kind: 'decode',\r\n          participantIdentity,\r\n          trackId,\r\n          codec\r\n        };\r\n        // @ts-ignore\r\n        receiver.transform = new RTCRtpScriptTransform(this.worker, options);\r\n      } else {\r\n        if (E2EE_FLAG in receiver && codec) {\r\n          // only update codec\r\n          const msg = {\r\n            kind: 'updateCodec',\r\n            data: {\r\n              trackId,\r\n              codec,\r\n              participantIdentity: participantIdentity\r\n            }\r\n          };\r\n          this.worker.postMessage(msg);\r\n          return;\r\n        }\r\n        // @ts-ignore\r\n        let writable = receiver.writableStream;\r\n        // @ts-ignore\r\n        let readable = receiver.readableStream;\r\n        if (!writable || !readable) {\r\n          // @ts-ignore\r\n          const receiverStreams = receiver.createEncodedStreams();\r\n          // @ts-ignore\r\n          receiver.writableStream = receiverStreams.writable;\r\n          writable = receiverStreams.writable;\r\n          // @ts-ignore\r\n          receiver.readableStream = receiverStreams.readable;\r\n          readable = receiverStreams.readable;\r\n        }\r\n        const msg = {\r\n          kind: 'decode',\r\n          data: {\r\n            readableStream: readable,\r\n            writableStream: writable,\r\n            trackId: trackId,\r\n            codec,\r\n            participantIdentity: participantIdentity\r\n          }\r\n        };\r\n        this.worker.postMessage(msg, [readable, writable]);\r\n      }\r\n      // @ts-ignore\r\n      receiver[E2EE_FLAG] = true;\r\n    });\r\n  }\r\n  /**\r\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\r\n   * a frame encoder.\r\n   *\r\n   */\r\n  handleSender(sender, trackId, codec) {\r\n    var _a;\r\n    if (E2EE_FLAG in sender || !this.worker) {\r\n      return;\r\n    }\r\n    if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === '') {\r\n      throw TypeError('local identity needs to be known in order to set up encrypted sender');\r\n    }\r\n    if (isScriptTransformSupported()) {\r\n      livekitLogger.info('initialize script transform');\r\n      const options = {\r\n        kind: 'encode',\r\n        participantIdentity: this.room.localParticipant.identity,\r\n        trackId,\r\n        codec\r\n      };\r\n      // @ts-ignore\r\n      sender.transform = new RTCRtpScriptTransform(this.worker, options);\r\n    } else {\r\n      livekitLogger.info('initialize encoded streams');\r\n      // @ts-ignore\r\n      const senderStreams = sender.createEncodedStreams();\r\n      const msg = {\r\n        kind: 'encode',\r\n        data: {\r\n          readableStream: senderStreams.readable,\r\n          writableStream: senderStreams.writable,\r\n          codec,\r\n          trackId,\r\n          participantIdentity: this.room.localParticipant.identity\r\n        }\r\n      };\r\n      this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);\r\n    }\r\n    // @ts-ignore\r\n    sender[E2EE_FLAG] = true;\r\n  }\r\n}\r\n\r\nconst defaultId = 'default';\r\nclass DeviceManager {\r\n  constructor() {\r\n    this._previousDevices = [];\r\n  }\r\n  static getInstance() {\r\n    if (this.instance === undefined) {\r\n      this.instance = new DeviceManager();\r\n    }\r\n    return this.instance;\r\n  }\r\n  get previousDevices() {\r\n    return this._previousDevices;\r\n  }\r\n  getDevices(kind_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind) {\r\n      var _this = this;\r\n      let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a;\r\n        if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\r\n          livekitLogger.debug('awaiting getUserMedia promise');\r\n          try {\r\n            if (kind) {\r\n              yield DeviceManager.userMediaPromiseMap.get(kind);\r\n            } else {\r\n              yield Promise.all(DeviceManager.userMediaPromiseMap.values());\r\n            }\r\n          } catch (e) {\r\n            livekitLogger.warn('error waiting for media permissons');\r\n          }\r\n        }\r\n        let devices = yield navigator.mediaDevices.enumerateDevices();\r\n        if (requestPermissions &&\r\n        // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\r\n        !(isSafari() && _this.hasDeviceInUse(kind))) {\r\n          const isDummyDeviceOrEmpty = devices.filter(d => d.kind === kind).length === 0 || devices.some(device => {\r\n            const noLabel = device.label === '';\r\n            const isRelevant = kind ? device.kind === kind : true;\r\n            return noLabel && isRelevant;\r\n          });\r\n          if (isDummyDeviceOrEmpty) {\r\n            const permissionsToAcquire = {\r\n              video: kind !== 'audioinput' && kind !== 'audiooutput',\r\n              audio: kind !== 'videoinput' && {\r\n                deviceId: {\r\n                  ideal: 'default'\r\n                }\r\n              }\r\n            };\r\n            const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\r\n            devices = yield navigator.mediaDevices.enumerateDevices();\r\n            stream.getTracks().forEach(track => {\r\n              track.stop();\r\n            });\r\n          }\r\n        }\r\n        _this._previousDevices = devices;\r\n        if (kind) {\r\n          devices = devices.filter(device => device.kind === kind);\r\n        }\r\n        return devices;\r\n      }();\r\n    });\r\n  }\r\n  normalizeDeviceId(kind, deviceId, groupId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (deviceId !== defaultId) {\r\n        return deviceId;\r\n      }\r\n      // resolve actual device id if it's 'default': Chrome returns it when no\r\n      // device has been chosen\r\n      const devices = yield this.getDevices(kind);\r\n      const defaultDevice = devices.find(d => d.deviceId === defaultId);\r\n      if (!defaultDevice) {\r\n        livekitLogger.warn('could not reliably determine default device');\r\n        return undefined;\r\n      }\r\n      const device = devices.find(d => d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\r\n      if (!device) {\r\n        livekitLogger.warn('could not reliably determine default device');\r\n        return undefined;\r\n      }\r\n      return device === null || device === void 0 ? void 0 : device.deviceId;\r\n    });\r\n  }\r\n  hasDeviceInUse(kind) {\r\n    return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\r\n  }\r\n}\r\nDeviceManager.mediaDeviceKinds = ['audioinput', 'audiooutput', 'videoinput'];\r\nDeviceManager.userMediaPromiseMap = new Map();\r\n\r\nvar QueueTaskStatus;\r\n(function (QueueTaskStatus) {\r\n  QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\r\n  QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\r\n  QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\r\n})(QueueTaskStatus || (QueueTaskStatus = {}));\r\nclass AsyncQueue {\r\n  constructor() {\r\n    this.pendingTasks = new Map();\r\n    this.taskMutex = new _();\r\n    this.nextTaskIndex = 0;\r\n  }\r\n  run(task) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const taskInfo = {\r\n        id: this.nextTaskIndex++,\r\n        enqueuedAt: Date.now(),\r\n        status: QueueTaskStatus.WAITING\r\n      };\r\n      this.pendingTasks.set(taskInfo.id, taskInfo);\r\n      const unlock = yield this.taskMutex.lock();\r\n      try {\r\n        taskInfo.executedAt = Date.now();\r\n        taskInfo.status = QueueTaskStatus.RUNNING;\r\n        return yield task();\r\n      } finally {\r\n        taskInfo.status = QueueTaskStatus.COMPLETED;\r\n        this.pendingTasks.delete(taskInfo.id);\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  flush() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.run(() => __awaiter(this, void 0, void 0, function* () {}));\r\n    });\r\n  }\r\n  snapshot() {\r\n    return Array.from(this.pendingTasks.values());\r\n  }\r\n}\r\n\r\nfunction createRtcUrl(url, searchParams) {\r\n  const urlObj = new URL(toWebsocketUrl(url));\r\n  searchParams.forEach((value, key) => {\r\n    urlObj.searchParams.set(key, value);\r\n  });\r\n  return appendUrlPath(urlObj, 'rtc');\r\n}\r\nfunction createValidateUrl(rtcWsUrl) {\r\n  const urlObj = new URL(toHttpUrl(rtcWsUrl));\r\n  return appendUrlPath(urlObj, 'validate');\r\n}\r\nfunction ensureTrailingSlash(path) {\r\n  return path.endsWith('/') ? path : \"\".concat(path, \"/\");\r\n}\r\nfunction appendUrlPath(urlObj, path) {\r\n  urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\r\n  return urlObj.toString();\r\n}\r\n\r\nconst passThroughQueueSignals = ['syncState', 'trickle', 'offer', 'answer', 'simulate', 'leave'];\r\nfunction canPassThroughQueue(req) {\r\n  const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\r\n  livekitLogger.trace('request allowed to bypass queue:', {\r\n    canPass,\r\n    req\r\n  });\r\n  return canPass;\r\n}\r\nvar SignalConnectionState;\r\n(function (SignalConnectionState) {\r\n  SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\r\n  SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\r\n  SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\r\n})(SignalConnectionState || (SignalConnectionState = {}));\r\n/** @internal */\r\nclass SignalClient {\r\n  get currentState() {\r\n    return this.state;\r\n  }\r\n  get isDisconnected() {\r\n    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\r\n  }\r\n  get isEstablishingConnection() {\r\n    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\r\n  }\r\n  getNextRequestId() {\r\n    this._requestId += 1;\r\n    return this._requestId;\r\n  }\r\n  constructor() {\r\n    let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var _a;\r\n    /** signal rtt in milliseconds */\r\n    this.rtt = 0;\r\n    this.state = SignalConnectionState.DISCONNECTED;\r\n    this.log = livekitLogger;\r\n    this._requestId = 0;\r\n    /** @internal */\r\n    this.resetCallbacks = () => {\r\n      this.onAnswer = undefined;\r\n      this.onLeave = undefined;\r\n      this.onLocalTrackPublished = undefined;\r\n      this.onLocalTrackUnpublished = undefined;\r\n      this.onNegotiateRequested = undefined;\r\n      this.onOffer = undefined;\r\n      this.onRemoteMuteChanged = undefined;\r\n      this.onSubscribedQualityUpdate = undefined;\r\n      this.onTokenRefresh = undefined;\r\n      this.onTrickle = undefined;\r\n      this.onClose = undefined;\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\r\n    this.loggerContextCb = loggerOptions.loggerContextCb;\r\n    this.useJSON = useJSON;\r\n    this.requestQueue = new AsyncQueue();\r\n    this.queuedRequests = [];\r\n    this.closingLock = new _();\r\n    this.connectionLock = new _();\r\n    this.state = SignalConnectionState.DISCONNECTED;\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\r\n  }\r\n  join(url, token, opts, abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // during a full reconnect, we'd want to start the sequence even if currently\r\n      // connected\r\n      this.state = SignalConnectionState.CONNECTING;\r\n      this.options = opts;\r\n      const res = yield this.connect(url, token, opts, abortSignal);\r\n      return res;\r\n    });\r\n  }\r\n  reconnect(url, token, sid, reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.options) {\r\n        this.log.warn('attempted to reconnect without signal options being set, ignoring', this.logContext);\r\n        return;\r\n      }\r\n      this.state = SignalConnectionState.RECONNECTING;\r\n      // clear ping interval and restart it once reconnected\r\n      this.clearPingInterval();\r\n      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\r\n        reconnect: true,\r\n        sid,\r\n        reconnectReason: reason\r\n      }));\r\n      if (res instanceof ReconnectResponse) {\r\n        return res;\r\n      }\r\n      return;\r\n    });\r\n  }\r\n  connect(url, token, opts, abortSignal) {\r\n    this.connectOptions = opts;\r\n    const clientInfo = getClientInfo();\r\n    const params = createConnectionParams(token, clientInfo, opts);\r\n    const rtcUrl = createRtcUrl(url, params);\r\n    const validateUrl = createValidateUrl(rtcUrl);\r\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.connectionLock.lock();\r\n      try {\r\n        const abortHandler = () => __awaiter(this, void 0, void 0, function* () {\r\n          this.close();\r\n          clearTimeout(wsTimeout);\r\n          reject(new ConnectionError('room connection has been cancelled (signal)', ConnectionErrorReason.Cancelled));\r\n        });\r\n        const wsTimeout = setTimeout(() => {\r\n          this.close();\r\n          reject(new ConnectionError('room connection has timed out (signal)', ConnectionErrorReason.ServerUnreachable));\r\n        }, opts.websocketTimeout);\r\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\r\n          abortHandler();\r\n        }\r\n        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener('abort', abortHandler);\r\n        const redactedUrl = new URL(rtcUrl);\r\n        if (redactedUrl.searchParams.has('access_token')) {\r\n          redactedUrl.searchParams.set('access_token', '<redacted>');\r\n        }\r\n        this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\r\n          reconnect: opts.reconnect,\r\n          reconnectReason: opts.reconnectReason\r\n        }, this.logContext));\r\n        if (this.ws) {\r\n          yield this.close(false);\r\n        }\r\n        this.ws = new WebSocket(rtcUrl);\r\n        this.ws.binaryType = 'arraybuffer';\r\n        this.ws.onopen = () => {\r\n          clearTimeout(wsTimeout);\r\n        };\r\n        this.ws.onerror = ev => __awaiter(this, void 0, void 0, function* () {\r\n          if (this.state !== SignalConnectionState.CONNECTED) {\r\n            this.state = SignalConnectionState.DISCONNECTED;\r\n            clearTimeout(wsTimeout);\r\n            try {\r\n              const resp = yield fetch(validateUrl);\r\n              if (resp.status.toFixed(0).startsWith('4')) {\r\n                const msg = yield resp.text();\r\n                reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));\r\n              } else {\r\n                reject(new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));\r\n              }\r\n            } catch (e) {\r\n              reject(new ConnectionError(e instanceof Error ? e.message : 'server was not reachable', ConnectionErrorReason.ServerUnreachable));\r\n            }\r\n            return;\r\n          }\r\n          // other errors, handle\r\n          this.handleWSError(ev);\r\n        });\r\n        this.ws.onmessage = ev => __awaiter(this, void 0, void 0, function* () {\r\n          var _a, _b, _c;\r\n          // not considered connected until JoinResponse is received\r\n          let resp;\r\n          if (typeof ev.data === 'string') {\r\n            const json = JSON.parse(ev.data);\r\n            resp = SignalResponse.fromJson(json, {\r\n              ignoreUnknownFields: true\r\n            });\r\n          } else if (ev.data instanceof ArrayBuffer) {\r\n            resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\r\n          } else {\r\n            this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\r\n            return;\r\n          }\r\n          if (this.state !== SignalConnectionState.CONNECTED) {\r\n            let shouldProcessMessage = false;\r\n            // handle join message only\r\n            if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === 'join') {\r\n              this.state = SignalConnectionState.CONNECTED;\r\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\r\n              this.pingTimeoutDuration = resp.message.value.pingTimeout;\r\n              this.pingIntervalDuration = resp.message.value.pingInterval;\r\n              if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\r\n                this.log.debug('ping config', Object.assign(Object.assign({}, this.logContext), {\r\n                  timeout: this.pingTimeoutDuration,\r\n                  interval: this.pingIntervalDuration\r\n                }));\r\n                this.startPingInterval();\r\n              }\r\n              resolve(resp.message.value);\r\n            } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== 'leave') {\r\n              // in reconnecting, any message received means signal reconnected\r\n              this.state = SignalConnectionState.CONNECTED;\r\n              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener('abort', abortHandler);\r\n              this.startPingInterval();\r\n              if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === 'reconnect') {\r\n                resolve(resp.message.value);\r\n              } else {\r\n                this.log.debug('declaring signal reconnected without reconnect response received', this.logContext);\r\n                resolve(undefined);\r\n                shouldProcessMessage = true;\r\n              }\r\n            } else if (this.isEstablishingConnection && resp.message.case === 'leave') {\r\n              reject(new ConnectionError('Received leave request while trying to (re)connect', ConnectionErrorReason.LeaveRequest, undefined, resp.message.value.reason));\r\n            } else if (!opts.reconnect) {\r\n              // non-reconnect case, should receive join response first\r\n              reject(new ConnectionError(\"did not receive join response, got \".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, \" instead\"), ConnectionErrorReason.InternalError));\r\n            }\r\n            if (!shouldProcessMessage) {\r\n              return;\r\n            }\r\n          }\r\n          if (this.signalLatency) {\r\n            yield sleep(this.signalLatency);\r\n          }\r\n          this.handleSignalResponse(resp);\r\n        });\r\n        this.ws.onclose = ev => {\r\n          if (this.isEstablishingConnection) {\r\n            reject(new ConnectionError('Websocket got closed during a (re)connection attempt', ConnectionErrorReason.InternalError));\r\n          }\r\n          this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\r\n            reason: ev.reason,\r\n            code: ev.code,\r\n            wasClean: ev.wasClean,\r\n            state: this.state\r\n          }));\r\n          this.handleOnClose(ev.reason);\r\n        };\r\n      } finally {\r\n        unlock();\r\n      }\r\n    }));\r\n  }\r\n  close() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this = this;\r\n      let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        const unlock = yield _this.closingLock.lock();\r\n        try {\r\n          _this.clearPingInterval();\r\n          if (updateState) {\r\n            _this.state = SignalConnectionState.DISCONNECTING;\r\n          }\r\n          if (_this.ws) {\r\n            _this.ws.onmessage = null;\r\n            _this.ws.onopen = null;\r\n            _this.ws.onclose = null;\r\n            // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\r\n            const closePromise = new Promise(resolve => {\r\n              if (_this.ws) {\r\n                _this.ws.onclose = () => {\r\n                  resolve();\r\n                };\r\n              } else {\r\n                resolve();\r\n              }\r\n            });\r\n            if (_this.ws.readyState < _this.ws.CLOSING) {\r\n              _this.ws.close();\r\n              // 250ms grace period for ws to close gracefully\r\n              yield Promise.race([closePromise, sleep(250)]);\r\n            }\r\n            _this.ws = undefined;\r\n          }\r\n        } finally {\r\n          if (updateState) {\r\n            _this.state = SignalConnectionState.DISCONNECTED;\r\n          }\r\n          unlock();\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  // initial offer after joining\r\n  sendOffer(offer) {\r\n    this.log.debug('sending offer', Object.assign(Object.assign({}, this.logContext), {\r\n      offerSdp: offer.sdp\r\n    }));\r\n    this.sendRequest({\r\n      case: 'offer',\r\n      value: toProtoSessionDescription(offer)\r\n    });\r\n  }\r\n  // answer a server-initiated offer\r\n  sendAnswer(answer) {\r\n    this.log.debug('sending answer', Object.assign(Object.assign({}, this.logContext), {\r\n      answerSdp: answer.sdp\r\n    }));\r\n    return this.sendRequest({\r\n      case: 'answer',\r\n      value: toProtoSessionDescription(answer)\r\n    });\r\n  }\r\n  sendIceCandidate(candidate, target) {\r\n    this.log.debug('sending ice candidate', Object.assign(Object.assign({}, this.logContext), {\r\n      candidate\r\n    }));\r\n    return this.sendRequest({\r\n      case: 'trickle',\r\n      value: new TrickleRequest({\r\n        candidateInit: JSON.stringify(candidate),\r\n        target\r\n      })\r\n    });\r\n  }\r\n  sendMuteTrack(trackSid, muted) {\r\n    return this.sendRequest({\r\n      case: 'mute',\r\n      value: new MuteTrackRequest({\r\n        sid: trackSid,\r\n        muted\r\n      })\r\n    });\r\n  }\r\n  sendAddTrack(req) {\r\n    return this.sendRequest({\r\n      case: 'addTrack',\r\n      value: req\r\n    });\r\n  }\r\n  sendUpdateLocalMetadata(metadata_1, name_1) {\r\n    return __awaiter(this, arguments, void 0, function (metadata, name) {\r\n      var _this2 = this;\r\n      let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n      return function* () {\r\n        const requestId = _this2.getNextRequestId();\r\n        yield _this2.sendRequest({\r\n          case: 'updateMetadata',\r\n          value: new UpdateParticipantMetadata({\r\n            requestId,\r\n            metadata,\r\n            name,\r\n            attributes\r\n          })\r\n        });\r\n        return requestId;\r\n      }();\r\n    });\r\n  }\r\n  sendUpdateTrackSettings(settings) {\r\n    this.sendRequest({\r\n      case: 'trackSetting',\r\n      value: settings\r\n    });\r\n  }\r\n  sendUpdateSubscription(sub) {\r\n    return this.sendRequest({\r\n      case: 'subscription',\r\n      value: sub\r\n    });\r\n  }\r\n  sendSyncState(sync) {\r\n    return this.sendRequest({\r\n      case: 'syncState',\r\n      value: sync\r\n    });\r\n  }\r\n  sendUpdateVideoLayers(trackSid, layers) {\r\n    return this.sendRequest({\r\n      case: 'updateLayers',\r\n      value: new UpdateVideoLayers({\r\n        trackSid,\r\n        layers\r\n      })\r\n    });\r\n  }\r\n  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\r\n    return this.sendRequest({\r\n      case: 'subscriptionPermission',\r\n      value: new SubscriptionPermission({\r\n        allParticipants,\r\n        trackPermissions\r\n      })\r\n    });\r\n  }\r\n  sendSimulateScenario(scenario) {\r\n    return this.sendRequest({\r\n      case: 'simulate',\r\n      value: scenario\r\n    });\r\n  }\r\n  sendPing() {\r\n    /** send both of ping and pingReq for compatibility to old and new server */\r\n    return Promise.all([this.sendRequest({\r\n      case: 'ping',\r\n      value: protoInt64.parse(Date.now())\r\n    }), this.sendRequest({\r\n      case: 'pingReq',\r\n      value: new Ping({\r\n        timestamp: protoInt64.parse(Date.now()),\r\n        rtt: protoInt64.parse(this.rtt)\r\n      })\r\n    })]);\r\n  }\r\n  sendUpdateLocalAudioTrack(trackSid, features) {\r\n    return this.sendRequest({\r\n      case: 'updateAudioTrack',\r\n      value: new UpdateLocalAudioTrack({\r\n        trackSid,\r\n        features\r\n      })\r\n    });\r\n  }\r\n  sendLeave() {\r\n    return this.sendRequest({\r\n      case: 'leave',\r\n      value: new LeaveRequest({\r\n        reason: DisconnectReason.CLIENT_INITIATED,\r\n        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\r\n        action: LeaveRequest_Action.DISCONNECT\r\n      })\r\n    });\r\n  }\r\n  sendRequest(message_1) {\r\n    return __awaiter(this, arguments, void 0, function (message) {\r\n      var _this3 = this;\r\n      let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      return function* () {\r\n        // capture all requests while reconnecting and put them in a queue\r\n        // unless the request originates from the queue, then don't enqueue again\r\n        const canQueue = !fromQueue && !canPassThroughQueue(message);\r\n        if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\r\n          _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {\r\n            yield this.sendRequest(message, true);\r\n          }));\r\n          return;\r\n        }\r\n        // make sure previously queued requests are being sent first\r\n        if (!fromQueue) {\r\n          yield _this3.requestQueue.flush();\r\n        }\r\n        if (_this3.signalLatency) {\r\n          yield sleep(_this3.signalLatency);\r\n        }\r\n        if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {\r\n          _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\r\n          return;\r\n        }\r\n        const req = new SignalRequest({\r\n          message\r\n        });\r\n        try {\r\n          if (_this3.useJSON) {\r\n            _this3.ws.send(req.toJsonString());\r\n          } else {\r\n            _this3.ws.send(req.toBinary());\r\n          }\r\n        } catch (e) {\r\n          _this3.log.error('error sending signal message', Object.assign(Object.assign({}, _this3.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  handleSignalResponse(res) {\r\n    var _a, _b;\r\n    const msg = res.message;\r\n    if (msg == undefined) {\r\n      this.log.debug('received unsupported message', this.logContext);\r\n      return;\r\n    }\r\n    let pingHandled = false;\r\n    if (msg.case === 'answer') {\r\n      const sd = fromProtoSessionDescription(msg.value);\r\n      if (this.onAnswer) {\r\n        this.onAnswer(sd);\r\n      }\r\n    } else if (msg.case === 'offer') {\r\n      const sd = fromProtoSessionDescription(msg.value);\r\n      if (this.onOffer) {\r\n        this.onOffer(sd);\r\n      }\r\n    } else if (msg.case === 'trickle') {\r\n      const candidate = JSON.parse(msg.value.candidateInit);\r\n      if (this.onTrickle) {\r\n        this.onTrickle(candidate, msg.value.target);\r\n      }\r\n    } else if (msg.case === 'update') {\r\n      if (this.onParticipantUpdate) {\r\n        this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\r\n      }\r\n    } else if (msg.case === 'trackPublished') {\r\n      if (this.onLocalTrackPublished) {\r\n        this.onLocalTrackPublished(msg.value);\r\n      }\r\n    } else if (msg.case === 'speakersChanged') {\r\n      if (this.onSpeakersChanged) {\r\n        this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\r\n      }\r\n    } else if (msg.case === 'leave') {\r\n      if (this.onLeave) {\r\n        this.onLeave(msg.value);\r\n      }\r\n    } else if (msg.case === 'mute') {\r\n      if (this.onRemoteMuteChanged) {\r\n        this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\r\n      }\r\n    } else if (msg.case === 'roomUpdate') {\r\n      if (this.onRoomUpdate && msg.value.room) {\r\n        this.onRoomUpdate(msg.value.room);\r\n      }\r\n    } else if (msg.case === 'connectionQuality') {\r\n      if (this.onConnectionQuality) {\r\n        this.onConnectionQuality(msg.value);\r\n      }\r\n    } else if (msg.case === 'streamStateUpdate') {\r\n      if (this.onStreamStateUpdate) {\r\n        this.onStreamStateUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscribedQualityUpdate') {\r\n      if (this.onSubscribedQualityUpdate) {\r\n        this.onSubscribedQualityUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscriptionPermissionUpdate') {\r\n      if (this.onSubscriptionPermissionUpdate) {\r\n        this.onSubscriptionPermissionUpdate(msg.value);\r\n      }\r\n    } else if (msg.case === 'refreshToken') {\r\n      if (this.onTokenRefresh) {\r\n        this.onTokenRefresh(msg.value);\r\n      }\r\n    } else if (msg.case === 'trackUnpublished') {\r\n      if (this.onLocalTrackUnpublished) {\r\n        this.onLocalTrackUnpublished(msg.value);\r\n      }\r\n    } else if (msg.case === 'subscriptionResponse') {\r\n      if (this.onSubscriptionError) {\r\n        this.onSubscriptionError(msg.value);\r\n      }\r\n    } else if (msg.case === 'pong') ; else if (msg.case === 'pongResp') {\r\n      this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\r\n      this.resetPingTimeout();\r\n      pingHandled = true;\r\n    } else if (msg.case === 'requestResponse') {\r\n      if (this.onRequestResponse) {\r\n        this.onRequestResponse(msg.value);\r\n      }\r\n    } else if (msg.case === 'trackSubscribed') {\r\n      if (this.onLocalTrackSubscribed) {\r\n        this.onLocalTrackSubscribed(msg.value.trackSid);\r\n      }\r\n    } else if (msg.case === 'roomMoved') {\r\n      if (this.onTokenRefresh) {\r\n        this.onTokenRefresh(msg.value.token);\r\n      }\r\n      if (this.onRoomMoved) {\r\n        this.onRoomMoved(msg.value);\r\n      }\r\n    } else {\r\n      this.log.debug('unsupported message', Object.assign(Object.assign({}, this.logContext), {\r\n        msgCase: msg.case\r\n      }));\r\n    }\r\n    if (!pingHandled) {\r\n      this.resetPingTimeout();\r\n    }\r\n  }\r\n  setReconnected() {\r\n    while (this.queuedRequests.length > 0) {\r\n      const req = this.queuedRequests.shift();\r\n      if (req) {\r\n        this.requestQueue.run(req);\r\n      }\r\n    }\r\n  }\r\n  handleOnClose(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state === SignalConnectionState.DISCONNECTED) return;\r\n      const onCloseCallback = this.onClose;\r\n      yield this.close();\r\n      this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\r\n        reason\r\n      }));\r\n      if (onCloseCallback) {\r\n        onCloseCallback(reason);\r\n      }\r\n    });\r\n  }\r\n  handleWSError(ev) {\r\n    this.log.error('websocket error', Object.assign(Object.assign({}, this.logContext), {\r\n      error: ev\r\n    }));\r\n  }\r\n  /**\r\n   * Resets the ping timeout and starts a new timeout.\r\n   * Call this after receiving a pong message\r\n   */\r\n  resetPingTimeout() {\r\n    this.clearPingTimeout();\r\n    if (!this.pingTimeoutDuration) {\r\n      this.log.warn('ping timeout duration not set', this.logContext);\r\n      return;\r\n    }\r\n    this.pingTimeout = CriticalTimers.setTimeout(() => {\r\n      this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\r\n      this.handleOnClose('ping timeout');\r\n    }, this.pingTimeoutDuration * 1000);\r\n  }\r\n  /**\r\n   * Clears ping timeout (does not start a new timeout)\r\n   */\r\n  clearPingTimeout() {\r\n    if (this.pingTimeout) {\r\n      CriticalTimers.clearTimeout(this.pingTimeout);\r\n    }\r\n  }\r\n  startPingInterval() {\r\n    this.clearPingInterval();\r\n    this.resetPingTimeout();\r\n    if (!this.pingIntervalDuration) {\r\n      this.log.warn('ping interval duration not set', this.logContext);\r\n      return;\r\n    }\r\n    this.log.debug('start ping interval', this.logContext);\r\n    this.pingInterval = CriticalTimers.setInterval(() => {\r\n      this.sendPing();\r\n    }, this.pingIntervalDuration * 1000);\r\n  }\r\n  clearPingInterval() {\r\n    this.log.debug('clearing ping interval', this.logContext);\r\n    this.clearPingTimeout();\r\n    if (this.pingInterval) {\r\n      CriticalTimers.clearInterval(this.pingInterval);\r\n    }\r\n  }\r\n}\r\nfunction fromProtoSessionDescription(sd) {\r\n  const rsd = {\r\n    type: 'offer',\r\n    sdp: sd.sdp\r\n  };\r\n  switch (sd.type) {\r\n    case 'answer':\r\n    case 'offer':\r\n    case 'pranswer':\r\n    case 'rollback':\r\n      rsd.type = sd.type;\r\n      break;\r\n  }\r\n  return rsd;\r\n}\r\nfunction toProtoSessionDescription(rsd) {\r\n  const sd = new SessionDescription({\r\n    sdp: rsd.sdp,\r\n    type: rsd.type\r\n  });\r\n  return sd;\r\n}\r\nfunction createConnectionParams(token, info, opts) {\r\n  var _a;\r\n  const params = new URLSearchParams();\r\n  params.set('access_token', token);\r\n  // opts\r\n  if (opts.reconnect) {\r\n    params.set('reconnect', '1');\r\n    if (opts.sid) {\r\n      params.set('sid', opts.sid);\r\n    }\r\n  }\r\n  params.set('auto_subscribe', opts.autoSubscribe ? '1' : '0');\r\n  // ClientInfo\r\n  params.set('sdk', isReactNative() ? 'reactnative' : 'js');\r\n  params.set('version', info.version);\r\n  params.set('protocol', info.protocol.toString());\r\n  if (info.deviceModel) {\r\n    params.set('device_model', info.deviceModel);\r\n  }\r\n  if (info.os) {\r\n    params.set('os', info.os);\r\n  }\r\n  if (info.osVersion) {\r\n    params.set('os_version', info.osVersion);\r\n  }\r\n  if (info.browser) {\r\n    params.set('browser', info.browser);\r\n  }\r\n  if (info.browserVersion) {\r\n    params.set('browser_version', info.browserVersion);\r\n  }\r\n  if (opts.adaptiveStream) {\r\n    params.set('adaptive_stream', '1');\r\n  }\r\n  if (opts.reconnectReason) {\r\n    params.set('reconnect_reason', opts.reconnectReason.toString());\r\n  }\r\n  // @ts-ignore\r\n  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\r\n    // @ts-ignore\r\n    params.set('network', navigator.connection.type);\r\n  }\r\n  return params;\r\n}\r\n\r\nclass DataPacketBuffer {\r\n  constructor() {\r\n    this.buffer = [];\r\n    this._totalSize = 0;\r\n  }\r\n  push(item) {\r\n    this.buffer.push(item);\r\n    this._totalSize += item.data.byteLength;\r\n  }\r\n  pop() {\r\n    const item = this.buffer.shift();\r\n    if (item) {\r\n      this._totalSize -= item.data.byteLength;\r\n    }\r\n    return item;\r\n  }\r\n  getAll() {\r\n    return this.buffer.slice();\r\n  }\r\n  popToSequence(sequence) {\r\n    while (this.buffer.length > 0) {\r\n      const first = this.buffer[0];\r\n      if (first.sequence <= sequence) {\r\n        this.pop();\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  alignBufferedAmount(bufferedAmount) {\r\n    while (this.buffer.length > 0) {\r\n      const first = this.buffer[0];\r\n      if (this._totalSize - first.data.byteLength <= bufferedAmount) {\r\n        break;\r\n      }\r\n      this.pop();\r\n    }\r\n  }\r\n  get length() {\r\n    return this.buffer.length;\r\n  }\r\n}\r\n\r\nclass TTLMap {\r\n  /**\r\n   * @param ttl ttl of the key (ms)\r\n   */\r\n  constructor(ttl) {\r\n    this._map = new Map();\r\n    this._lastCleanup = 0;\r\n    this.ttl = ttl;\r\n  }\r\n  set(key, value) {\r\n    const now = Date.now();\r\n    if (now - this._lastCleanup > this.ttl / 2) {\r\n      this.cleanup();\r\n    }\r\n    const expiresAt = now + this.ttl;\r\n    this._map.set(key, {\r\n      value,\r\n      expiresAt\r\n    });\r\n    return this;\r\n  }\r\n  get(key) {\r\n    const entry = this._map.get(key);\r\n    if (!entry) return undefined;\r\n    if (entry.expiresAt < Date.now()) {\r\n      this._map.delete(key);\r\n      return undefined;\r\n    }\r\n    return entry.value;\r\n  }\r\n  has(key) {\r\n    const entry = this._map.get(key);\r\n    if (!entry) return false;\r\n    if (entry.expiresAt < Date.now()) {\r\n      this._map.delete(key);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  delete(key) {\r\n    return this._map.delete(key);\r\n  }\r\n  clear() {\r\n    this._map.clear();\r\n  }\r\n  cleanup() {\r\n    const now = Date.now();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt < now) {\r\n        this._map.delete(key);\r\n      }\r\n    }\r\n    this._lastCleanup = now;\r\n  }\r\n  get size() {\r\n    this.cleanup();\r\n    return this._map.size;\r\n  }\r\n  forEach(callback) {\r\n    this.cleanup();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt >= Date.now()) {\r\n        callback(entry.value, key, this.asValueMap());\r\n      }\r\n    }\r\n  }\r\n  map(callback) {\r\n    this.cleanup();\r\n    const result = [];\r\n    const valueMap = this.asValueMap();\r\n    for (const [key, value] of valueMap.entries()) {\r\n      result.push(callback(value, key, valueMap));\r\n    }\r\n    return result;\r\n  }\r\n  asValueMap() {\r\n    const result = new Map();\r\n    for (const [key, entry] of this._map.entries()) {\r\n      if (entry.expiresAt >= Date.now()) {\r\n        result.set(key, entry.value);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nvar lib = {};\r\n\r\nvar parser = {};\r\n\r\nvar grammar = {exports: {}};\r\n\r\nvar hasRequiredGrammar;\r\nfunction requireGrammar() {\r\n  if (hasRequiredGrammar) return grammar.exports;\r\n  hasRequiredGrammar = 1;\r\n  var grammar$1 = grammar.exports = {\r\n    v: [{\r\n      name: 'version',\r\n      reg: /^(\\d*)$/\r\n    }],\r\n    o: [{\r\n      // o=- 20518 0 IN IP4 203.0.113.1\r\n      // NB: sessionId will be a String in most cases because it is huge\r\n      name: 'origin',\r\n      reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\r\n      names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\r\n      format: '%s %s %d %s IP%d %s'\r\n    }],\r\n    // default parsing of these only (though some of these feel outdated)\r\n    s: [{\r\n      name: 'name'\r\n    }],\r\n    i: [{\r\n      name: 'description'\r\n    }],\r\n    u: [{\r\n      name: 'uri'\r\n    }],\r\n    e: [{\r\n      name: 'email'\r\n    }],\r\n    p: [{\r\n      name: 'phone'\r\n    }],\r\n    z: [{\r\n      name: 'timezones'\r\n    }],\r\n    // TODO: this one can actually be parsed properly...\r\n    r: [{\r\n      name: 'repeats'\r\n    }],\r\n    // TODO: this one can also be parsed properly\r\n    // k: [{}], // outdated thing ignored\r\n    t: [{\r\n      // t=0 0\r\n      name: 'timing',\r\n      reg: /^(\\d*) (\\d*)/,\r\n      names: ['start', 'stop'],\r\n      format: '%d %d'\r\n    }],\r\n    c: [{\r\n      // c=IN IP4 10.47.197.26\r\n      name: 'connection',\r\n      reg: /^IN IP(\\d) (\\S*)/,\r\n      names: ['version', 'ip'],\r\n      format: 'IN IP%d %s'\r\n    }],\r\n    b: [{\r\n      // b=AS:4000\r\n      push: 'bandwidth',\r\n      reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\r\n      names: ['type', 'limit'],\r\n      format: '%s:%s'\r\n    }],\r\n    m: [{\r\n      // m=video 51744 RTP/AVP 126 97 98 34 31\r\n      // NB: special - pushes to session\r\n      // TODO: rtp/fmtp should be filtered by the payloads found here?\r\n      reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\r\n      names: ['type', 'port', 'protocol', 'payloads'],\r\n      format: '%s %d %s %s'\r\n    }],\r\n    a: [{\r\n      // a=rtpmap:110 opus/48000/2\r\n      push: 'rtp',\r\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\r\n      names: ['payload', 'codec', 'rate', 'encoding'],\r\n      format: function (o) {\r\n        return o.encoding ? 'rtpmap:%d %s/%s/%s' : o.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s';\r\n      }\r\n    }, {\r\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\r\n      // a=fmtp:111 minptime=10; useinbandfec=1\r\n      push: 'fmtp',\r\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\r\n      names: ['payload', 'config'],\r\n      format: 'fmtp:%d %s'\r\n    }, {\r\n      // a=control:streamid=0\r\n      name: 'control',\r\n      reg: /^control:(.*)/,\r\n      format: 'control:%s'\r\n    }, {\r\n      // a=rtcp:65179 IN IP4 193.84.77.194\r\n      name: 'rtcp',\r\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\r\n      names: ['port', 'netType', 'ipVer', 'address'],\r\n      format: function (o) {\r\n        return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';\r\n      }\r\n    }, {\r\n      // a=rtcp-fb:98 trr-int 100\r\n      push: 'rtcpFbTrrInt',\r\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\r\n      names: ['payload', 'value'],\r\n      format: 'rtcp-fb:%s trr-int %d'\r\n    }, {\r\n      // a=rtcp-fb:98 nack rpsi\r\n      push: 'rtcpFb',\r\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\r\n      names: ['payload', 'type', 'subtype'],\r\n      format: function (o) {\r\n        return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';\r\n      }\r\n    }, {\r\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\r\n      // a=extmap:1/recvonly URI-gps-string\r\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\r\n      push: 'ext',\r\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\r\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\r\n      format: function (o) {\r\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + (o['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (o.config ? ' %s' : '');\r\n      }\r\n    }, {\r\n      // a=extmap-allow-mixed\r\n      name: 'extmapAllowMixed',\r\n      reg: /^(extmap-allow-mixed)/\r\n    }, {\r\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\r\n      push: 'crypto',\r\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\r\n      names: ['id', 'suite', 'config', 'sessionConfig'],\r\n      format: function (o) {\r\n        return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';\r\n      }\r\n    }, {\r\n      // a=setup:actpass\r\n      name: 'setup',\r\n      reg: /^setup:(\\w*)/,\r\n      format: 'setup:%s'\r\n    }, {\r\n      // a=connection:new\r\n      name: 'connectionType',\r\n      reg: /^connection:(new|existing)/,\r\n      format: 'connection:%s'\r\n    }, {\r\n      // a=mid:1\r\n      name: 'mid',\r\n      reg: /^mid:([^\\s]*)/,\r\n      format: 'mid:%s'\r\n    }, {\r\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\r\n      name: 'msid',\r\n      reg: /^msid:(.*)/,\r\n      format: 'msid:%s'\r\n    }, {\r\n      // a=ptime:20\r\n      name: 'ptime',\r\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\r\n      format: 'ptime:%d'\r\n    }, {\r\n      // a=maxptime:60\r\n      name: 'maxptime',\r\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\r\n      format: 'maxptime:%d'\r\n    }, {\r\n      // a=sendrecv\r\n      name: 'direction',\r\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\r\n    }, {\r\n      // a=ice-lite\r\n      name: 'icelite',\r\n      reg: /^(ice-lite)/\r\n    }, {\r\n      // a=ice-ufrag:F7gI\r\n      name: 'iceUfrag',\r\n      reg: /^ice-ufrag:(\\S*)/,\r\n      format: 'ice-ufrag:%s'\r\n    }, {\r\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\r\n      name: 'icePwd',\r\n      reg: /^ice-pwd:(\\S*)/,\r\n      format: 'ice-pwd:%s'\r\n    }, {\r\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\r\n      name: 'fingerprint',\r\n      reg: /^fingerprint:(\\S*) (\\S*)/,\r\n      names: ['type', 'hash'],\r\n      format: 'fingerprint:%s %s'\r\n    }, {\r\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\r\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\r\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\r\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\r\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\r\n      push: 'candidates',\r\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\r\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\r\n      format: function (o) {\r\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\r\n        str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';\r\n\r\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\r\n        str += o.tcptype != null ? ' tcptype %s' : '%v';\r\n        if (o.generation != null) {\r\n          str += ' generation %d';\r\n        }\r\n        str += o['network-id'] != null ? ' network-id %d' : '%v';\r\n        str += o['network-cost'] != null ? ' network-cost %d' : '%v';\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=end-of-candidates (keep after the candidates line for readability)\r\n      name: 'endOfCandidates',\r\n      reg: /^(end-of-candidates)/\r\n    }, {\r\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\r\n      name: 'remoteCandidates',\r\n      reg: /^remote-candidates:(.*)/,\r\n      format: 'remote-candidates:%s'\r\n    }, {\r\n      // a=ice-options:google-ice\r\n      name: 'iceOptions',\r\n      reg: /^ice-options:(\\S*)/,\r\n      format: 'ice-options:%s'\r\n    }, {\r\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\r\n      push: 'ssrcs',\r\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\r\n      names: ['id', 'attribute', 'value'],\r\n      format: function (o) {\r\n        var str = 'ssrc:%d';\r\n        if (o.attribute != null) {\r\n          str += ' %s';\r\n          if (o.value != null) {\r\n            str += ':%s';\r\n          }\r\n        }\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=ssrc-group:FEC 1 2\r\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\r\n      push: 'ssrcGroups',\r\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\r\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\r\n      names: ['semantics', 'ssrcs'],\r\n      format: 'ssrc-group:%s %s'\r\n    }, {\r\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\r\n      name: 'msidSemantic',\r\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\r\n      names: ['semantic', 'token'],\r\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\r\n    }, {\r\n      // a=group:BUNDLE audio video\r\n      push: 'groups',\r\n      reg: /^group:(\\w*) (.*)/,\r\n      names: ['type', 'mids'],\r\n      format: 'group:%s %s'\r\n    }, {\r\n      // a=rtcp-mux\r\n      name: 'rtcpMux',\r\n      reg: /^(rtcp-mux)/\r\n    }, {\r\n      // a=rtcp-rsize\r\n      name: 'rtcpRsize',\r\n      reg: /^(rtcp-rsize)/\r\n    }, {\r\n      // a=sctpmap:5000 webrtc-datachannel 1024\r\n      name: 'sctpmap',\r\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\r\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\r\n      format: function (o) {\r\n        return o.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s';\r\n      }\r\n    }, {\r\n      // a=x-google-flag:conference\r\n      name: 'xGoogleFlag',\r\n      reg: /^x-google-flag:([^\\s]*)/,\r\n      format: 'x-google-flag:%s'\r\n    }, {\r\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\r\n      push: 'rids',\r\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\r\n      names: ['id', 'direction', 'params'],\r\n      format: function (o) {\r\n        return o.params ? 'rid:%s %s %s' : 'rid:%s %s';\r\n      }\r\n    }, {\r\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\r\n      // a=imageattr:* send [x=800,y=640] recv *\r\n      // a=imageattr:100 recv [x=320,y=240]\r\n      push: 'imageattrs',\r\n      reg: new RegExp(\r\n      // a=imageattr:97\r\n      '^imageattr:(\\\\d+|\\\\*)' +\r\n      // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\r\n      '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\r\n      // recv [x=330,y=250]\r\n      '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'),\r\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\r\n      format: function (o) {\r\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\r\n      }\r\n    }, {\r\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\r\n      // a=simulcast:recv 1;4,5 send 6;7\r\n      name: 'simulcast',\r\n      reg: new RegExp(\r\n      // a=simulcast:\r\n      '^simulcast:' +\r\n      // send 1,2,3;~4,~5\r\n      '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\r\n      // space + recv 6;~7,~8\r\n      '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\r\n      // end\r\n      '$'),\r\n      names: ['dir1', 'list1', 'dir2', 'list2'],\r\n      format: function (o) {\r\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\r\n      }\r\n    }, {\r\n      // old simulcast draft 03 (implemented by Firefox)\r\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\r\n      // a=simulcast: recv pt=97;98 send pt=97\r\n      // a=simulcast: send rid=5;6;7 paused=6,7\r\n      name: 'simulcast_03',\r\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\r\n      names: ['value'],\r\n      format: 'simulcast: %s'\r\n    }, {\r\n      // a=framerate:25\r\n      // a=framerate:29.97\r\n      name: 'framerate',\r\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\r\n      format: 'framerate:%s'\r\n    }, {\r\n      // RFC4570\r\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\r\n      name: 'sourceFilter',\r\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\r\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\r\n      format: 'source-filter: %s %s %s %s %s'\r\n    }, {\r\n      // a=bundle-only\r\n      name: 'bundleOnly',\r\n      reg: /^(bundle-only)/\r\n    }, {\r\n      // a=label:1\r\n      name: 'label',\r\n      reg: /^label:(.+)/,\r\n      format: 'label:%s'\r\n    }, {\r\n      // RFC version 26 for SCTP over DTLS\r\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\r\n      name: 'sctpPort',\r\n      reg: /^sctp-port:(\\d+)$/,\r\n      format: 'sctp-port:%s'\r\n    }, {\r\n      // RFC version 26 for SCTP over DTLS\r\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\r\n      name: 'maxMessageSize',\r\n      reg: /^max-message-size:(\\d+)$/,\r\n      format: 'max-message-size:%s'\r\n    }, {\r\n      // RFC7273\r\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\r\n      push: 'tsRefClocks',\r\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\r\n      names: ['clksrc', 'clksrcExt'],\r\n      format: function (o) {\r\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\r\n      }\r\n    }, {\r\n      // RFC7273\r\n      // a=mediaclk:direct=963214424\r\n      name: 'mediaClk',\r\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\r\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\r\n      format: function (o) {\r\n        var str = 'mediaclk:';\r\n        str += o.id != null ? 'id=%s %s' : '%v%s';\r\n        str += o.mediaClockValue != null ? '=%s' : '';\r\n        str += o.rateNumerator != null ? ' rate=%s' : '';\r\n        str += o.rateDenominator != null ? '/%s' : '';\r\n        return str;\r\n      }\r\n    }, {\r\n      // a=keywds:keywords\r\n      name: 'keywords',\r\n      reg: /^keywds:(.+)$/,\r\n      format: 'keywds:%s'\r\n    }, {\r\n      // a=content:main\r\n      name: 'content',\r\n      reg: /^content:(.+)/,\r\n      format: 'content:%s'\r\n    },\r\n    // BFCP https://tools.ietf.org/html/rfc4583\r\n    {\r\n      // a=floorctrl:c-s\r\n      name: 'bfcpFloorCtrl',\r\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\r\n      format: 'floorctrl:%s'\r\n    }, {\r\n      // a=confid:1\r\n      name: 'bfcpConfId',\r\n      reg: /^confid:(\\d+)/,\r\n      format: 'confid:%s'\r\n    }, {\r\n      // a=userid:1\r\n      name: 'bfcpUserId',\r\n      reg: /^userid:(\\d+)/,\r\n      format: 'userid:%s'\r\n    }, {\r\n      // a=floorid:1\r\n      name: 'bfcpFloorId',\r\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\r\n      names: ['id', 'mStream'],\r\n      format: 'floorid:%s mstrm:%s'\r\n    }, {\r\n      // any a= that we don't understand is kept verbatim on media.invalid\r\n      push: 'invalid',\r\n      names: ['value']\r\n    }]\r\n  };\r\n\r\n  // set sensible defaults to avoid polluting the grammar with boring details\r\n  Object.keys(grammar$1).forEach(function (key) {\r\n    var objs = grammar$1[key];\r\n    objs.forEach(function (obj) {\r\n      if (!obj.reg) {\r\n        obj.reg = /(.*)/;\r\n      }\r\n      if (!obj.format) {\r\n        obj.format = '%s';\r\n      }\r\n    });\r\n  });\r\n  return grammar.exports;\r\n}\r\n\r\nvar hasRequiredParser;\r\nfunction requireParser() {\r\n  if (hasRequiredParser) return parser;\r\n  hasRequiredParser = 1;\r\n  (function (exports) {\r\n    var toIntIfInt = function (v) {\r\n      return String(Number(v)) === v ? Number(v) : v;\r\n    };\r\n    var attachProperties = function (match, location, names, rawName) {\r\n      if (rawName && !names) {\r\n        location[rawName] = toIntIfInt(match[1]);\r\n      } else {\r\n        for (var i = 0; i < names.length; i += 1) {\r\n          if (match[i + 1] != null) {\r\n            location[names[i]] = toIntIfInt(match[i + 1]);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    var parseReg = function (obj, location, content) {\r\n      var needsBlank = obj.name && obj.names;\r\n      if (obj.push && !location[obj.push]) {\r\n        location[obj.push] = [];\r\n      } else if (needsBlank && !location[obj.name]) {\r\n        location[obj.name] = {};\r\n      }\r\n      var keyLocation = obj.push ? {} :\r\n      // blank object that will be pushed\r\n      needsBlank ? location[obj.name] : location; // otherwise, named location or root\r\n\r\n      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\r\n      if (obj.push) {\r\n        location[obj.push].push(keyLocation);\r\n      }\r\n    };\r\n    var grammar = requireGrammar();\r\n    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\r\n    exports.parse = function (sdp) {\r\n      var session = {},\r\n        media = [],\r\n        location = session; // points at where properties go under (one of the above)\r\n\r\n      // parse lines we understand\r\n      sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\r\n        var type = l[0];\r\n        var content = l.slice(2);\r\n        if (type === 'm') {\r\n          media.push({\r\n            rtp: [],\r\n            fmtp: []\r\n          });\r\n          location = media[media.length - 1]; // point at latest media line\r\n        }\r\n        for (var j = 0; j < (grammar[type] || []).length; j += 1) {\r\n          var obj = grammar[type][j];\r\n          if (obj.reg.test(content)) {\r\n            return parseReg(obj, location, content);\r\n          }\r\n        }\r\n      });\r\n      session.media = media; // link it up\r\n      return session;\r\n    };\r\n    var paramReducer = function (acc, expr) {\r\n      var s = expr.split(/=(.+)/, 2);\r\n      if (s.length === 2) {\r\n        acc[s[0]] = toIntIfInt(s[1]);\r\n      } else if (s.length === 1 && expr.length > 1) {\r\n        acc[s[0]] = undefined;\r\n      }\r\n      return acc;\r\n    };\r\n    exports.parseParams = function (str) {\r\n      return str.split(/;\\s?/).reduce(paramReducer, {});\r\n    };\r\n\r\n    // For backward compatibility - alias will be removed in 3.0.0\r\n    exports.parseFmtpConfig = exports.parseParams;\r\n    exports.parsePayloads = function (str) {\r\n      return str.toString().split(' ').map(Number);\r\n    };\r\n    exports.parseRemoteCandidates = function (str) {\r\n      var candidates = [];\r\n      var parts = str.split(' ').map(toIntIfInt);\r\n      for (var i = 0; i < parts.length; i += 3) {\r\n        candidates.push({\r\n          component: parts[i],\r\n          ip: parts[i + 1],\r\n          port: parts[i + 2]\r\n        });\r\n      }\r\n      return candidates;\r\n    };\r\n    exports.parseImageAttributes = function (str) {\r\n      return str.split(' ').map(function (item) {\r\n        return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});\r\n      });\r\n    };\r\n    exports.parseSimulcastStreamList = function (str) {\r\n      return str.split(';').map(function (stream) {\r\n        return stream.split(',').map(function (format) {\r\n          var scid,\r\n            paused = false;\r\n          if (format[0] !== '~') {\r\n            scid = toIntIfInt(format);\r\n          } else {\r\n            scid = toIntIfInt(format.substring(1, format.length));\r\n            paused = true;\r\n          }\r\n          return {\r\n            scid: scid,\r\n            paused: paused\r\n          };\r\n        });\r\n      });\r\n    };\r\n  })(parser);\r\n  return parser;\r\n}\r\n\r\nvar writer;\r\nvar hasRequiredWriter;\r\nfunction requireWriter() {\r\n  if (hasRequiredWriter) return writer;\r\n  hasRequiredWriter = 1;\r\n  var grammar = requireGrammar();\r\n\r\n  // customized util.format - discards excess arguments and can void middle ones\r\n  var formatRegExp = /%[sdv%]/g;\r\n  var format = function (formatStr) {\r\n    var i = 1;\r\n    var args = arguments;\r\n    var len = args.length;\r\n    return formatStr.replace(formatRegExp, function (x) {\r\n      if (i >= len) {\r\n        return x; // missing argument\r\n      }\r\n      var arg = args[i];\r\n      i += 1;\r\n      switch (x) {\r\n        case '%%':\r\n          return '%';\r\n        case '%s':\r\n          return String(arg);\r\n        case '%d':\r\n          return Number(arg);\r\n        case '%v':\r\n          return '';\r\n      }\r\n    });\r\n    // NB: we discard excess arguments - they are typically undefined from makeLine\r\n  };\r\n  var makeLine = function (type, obj, location) {\r\n    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\r\n    var args = [type + '=' + str];\r\n    if (obj.names) {\r\n      for (var i = 0; i < obj.names.length; i += 1) {\r\n        var n = obj.names[i];\r\n        if (obj.name) {\r\n          args.push(location[obj.name][n]);\r\n        } else {\r\n          // for mLine and push attributes\r\n          args.push(location[obj.names[i]]);\r\n        }\r\n      }\r\n    } else {\r\n      args.push(location[obj.name]);\r\n    }\r\n    return format.apply(null, args);\r\n  };\r\n\r\n  // RFC specified order\r\n  // TODO: extend this with all the rest\r\n  var defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\r\n  var defaultInnerOrder = ['i', 'c', 'b', 'a'];\r\n  writer = function (session, opts) {\r\n    opts = opts || {};\r\n    // ensure certain properties exist\r\n    if (session.version == null) {\r\n      session.version = 0; // 'v=0' must be there (only defined version atm)\r\n    }\r\n    if (session.name == null) {\r\n      session.name = ' '; // 's= ' must be there if no meaningful name set\r\n    }\r\n    session.media.forEach(function (mLine) {\r\n      if (mLine.payloads == null) {\r\n        mLine.payloads = '';\r\n      }\r\n    });\r\n    var outerOrder = opts.outerOrder || defaultOuterOrder;\r\n    var innerOrder = opts.innerOrder || defaultInnerOrder;\r\n    var sdp = [];\r\n\r\n    // loop through outerOrder for matching properties on session\r\n    outerOrder.forEach(function (type) {\r\n      grammar[type].forEach(function (obj) {\r\n        if (obj.name in session && session[obj.name] != null) {\r\n          sdp.push(makeLine(type, obj, session));\r\n        } else if (obj.push in session && session[obj.push] != null) {\r\n          session[obj.push].forEach(function (el) {\r\n            sdp.push(makeLine(type, obj, el));\r\n          });\r\n        }\r\n      });\r\n    });\r\n\r\n    // then for each media line, follow the innerOrder\r\n    session.media.forEach(function (mLine) {\r\n      sdp.push(makeLine('m', grammar.m[0], mLine));\r\n      innerOrder.forEach(function (type) {\r\n        grammar[type].forEach(function (obj) {\r\n          if (obj.name in mLine && mLine[obj.name] != null) {\r\n            sdp.push(makeLine(type, obj, mLine));\r\n          } else if (obj.push in mLine && mLine[obj.push] != null) {\r\n            mLine[obj.push].forEach(function (el) {\r\n              sdp.push(makeLine(type, obj, el));\r\n            });\r\n          }\r\n        });\r\n      });\r\n    });\r\n    return sdp.join('\\r\\n') + '\\r\\n';\r\n  };\r\n  return writer;\r\n}\r\n\r\nvar hasRequiredLib;\r\nfunction requireLib() {\r\n  if (hasRequiredLib) return lib;\r\n  hasRequiredLib = 1;\r\n  var parser = requireParser();\r\n  var writer = requireWriter();\r\n  var grammar = requireGrammar();\r\n  lib.grammar = grammar;\r\n  lib.write = writer;\r\n  lib.parse = parser.parse;\r\n  lib.parseParams = parser.parseParams;\r\n  lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\r\n  lib.parsePayloads = parser.parsePayloads;\r\n  lib.parseRemoteCandidates = parser.parseRemoteCandidates;\r\n  lib.parseImageAttributes = parser.parseImageAttributes;\r\n  lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\r\n  return lib;\r\n}\r\n\r\nvar libExports = requireLib();\r\n\r\nfunction r(r, e, n) {\r\n  var i, t, o;\r\n  void 0 === e && (e = 50), void 0 === n && (n = {});\r\n  var a = null != (i = n.isImmediate) && i,\r\n    u = null != (t = n.callback) && t,\r\n    c = n.maxWait,\r\n    v = Date.now(),\r\n    l = [];\r\n  function f() {\r\n    if (void 0 !== c) {\r\n      var r = Date.now() - v;\r\n      if (r + e >= c) return c - r;\r\n    }\r\n    return e;\r\n  }\r\n  var d = function () {\r\n    var e = [].slice.call(arguments),\r\n      n = this;\r\n    return new Promise(function (i, t) {\r\n      var c = a && void 0 === o;\r\n      if (void 0 !== o && clearTimeout(o), o = setTimeout(function () {\r\n        if (o = void 0, v = Date.now(), !a) {\r\n          var i = r.apply(n, e);\r\n          u && u(i), l.forEach(function (r) {\r\n            return (0, r.resolve)(i);\r\n          }), l = [];\r\n        }\r\n      }, f()), c) {\r\n        var d = r.apply(n, e);\r\n        return u && u(d), i(d);\r\n      }\r\n      l.push({\r\n        resolve: i,\r\n        reject: t\r\n      });\r\n    });\r\n  };\r\n  return d.cancel = function (r) {\r\n    void 0 !== o && clearTimeout(o), l.forEach(function (e) {\r\n      return (0, e.reject)(r);\r\n    }), l = [];\r\n  }, d;\r\n}\r\n\r\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\r\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\r\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\r\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\r\neliminate this issue.\r\n*/\r\nconst startBitrateForSVC = 0.7;\r\nconst debounceInterval = 20;\r\nconst PCEvents = {\r\n  NegotiationStarted: 'negotiationStarted',\r\n  NegotiationComplete: 'negotiationComplete',\r\n  RTPVideoPayloadTypes: 'rtpVideoPayloadTypes'\r\n};\r\n/** @internal */\r\nclass PCTransport extends eventsExports.EventEmitter {\r\n  get pc() {\r\n    if (!this._pc) {\r\n      this._pc = this.createPC();\r\n    }\r\n    return this._pc;\r\n  }\r\n  constructor(config) {\r\n    let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var _a;\r\n    super();\r\n    this.log = livekitLogger;\r\n    this.ddExtID = 0;\r\n    this.pendingCandidates = [];\r\n    this.restartingIce = false;\r\n    this.renegotiate = false;\r\n    this.trackBitrates = [];\r\n    this.remoteStereoMids = [];\r\n    this.remoteNackMids = [];\r\n    // debounced negotiate interface\r\n    this.negotiate = r(onError => __awaiter(this, void 0, void 0, function* () {\r\n      this.emit(PCEvents.NegotiationStarted);\r\n      try {\r\n        yield this.createAndSendOffer();\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n    }), debounceInterval);\r\n    this.close = () => {\r\n      if (!this._pc) {\r\n        return;\r\n      }\r\n      this._pc.close();\r\n      this._pc.onconnectionstatechange = null;\r\n      this._pc.oniceconnectionstatechange = null;\r\n      this._pc.onicegatheringstatechange = null;\r\n      this._pc.ondatachannel = null;\r\n      this._pc.onnegotiationneeded = null;\r\n      this._pc.onsignalingstatechange = null;\r\n      this._pc.onicecandidate = null;\r\n      this._pc.ondatachannel = null;\r\n      this._pc.ontrack = null;\r\n      this._pc.onconnectionstatechange = null;\r\n      this._pc.oniceconnectionstatechange = null;\r\n      this._pc = null;\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\r\n    this.loggerOptions = loggerOptions;\r\n    this.config = config;\r\n    this._pc = this.createPC();\r\n  }\r\n  createPC() {\r\n    const pc = new RTCPeerConnection(this.config);\r\n    pc.onicecandidate = ev => {\r\n      var _a;\r\n      if (!ev.candidate) return;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\r\n    };\r\n    pc.onicecandidateerror = ev => {\r\n      var _a;\r\n      (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    pc.oniceconnectionstatechange = () => {\r\n      var _a;\r\n      (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\r\n    };\r\n    pc.onsignalingstatechange = () => {\r\n      var _a;\r\n      (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\r\n    };\r\n    pc.onconnectionstatechange = () => {\r\n      var _a;\r\n      (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\r\n    };\r\n    pc.ondatachannel = ev => {\r\n      var _a;\r\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    pc.ontrack = ev => {\r\n      var _a;\r\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    return pc;\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  get isICEConnected() {\r\n    return this._pc !== null && (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed');\r\n  }\r\n  addIceCandidate(candidate) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.pc.remoteDescription && !this.restartingIce) {\r\n        return this.pc.addIceCandidate(candidate);\r\n      }\r\n      this.pendingCandidates.push(candidate);\r\n    });\r\n  }\r\n  setRemoteDescription(sd) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      let mungedSDP = undefined;\r\n      if (sd.type === 'offer') {\r\n        let {\r\n          stereoMids,\r\n          nackMids\r\n        } = extractStereoAndNackAudioFromOffer(sd);\r\n        this.remoteStereoMids = stereoMids;\r\n        this.remoteNackMids = nackMids;\r\n      } else if (sd.type === 'answer') {\r\n        const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : '');\r\n        sdpParsed.media.forEach(media => {\r\n          if (media.type === 'audio') {\r\n            // mung sdp for opus bitrate settings\r\n            this.trackBitrates.some(trackbr => {\r\n              if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\r\n                return false;\r\n              }\r\n              let codecPayload = 0;\r\n              media.rtp.some(rtp => {\r\n                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\r\n                  codecPayload = rtp.payload;\r\n                  return true;\r\n                }\r\n                return false;\r\n              });\r\n              if (codecPayload === 0) {\r\n                return true;\r\n              }\r\n              let fmtpFound = false;\r\n              for (const fmtp of media.fmtp) {\r\n                if (fmtp.payload === codecPayload) {\r\n                  fmtp.config = fmtp.config.split(';').filter(attr => !attr.includes('maxaveragebitrate')).join(';');\r\n                  if (trackbr.maxbr > 0) {\r\n                    fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\r\n                  }\r\n                  fmtpFound = true;\r\n                  break;\r\n                }\r\n              }\r\n              if (!fmtpFound) {\r\n                if (trackbr.maxbr > 0) {\r\n                  media.fmtp.push({\r\n                    payload: codecPayload,\r\n                    config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\r\n                  });\r\n                }\r\n              }\r\n              return true;\r\n            });\r\n          }\r\n        });\r\n        mungedSDP = libExports.write(sdpParsed);\r\n      }\r\n      yield this.setMungedSDP(sd, mungedSDP, true);\r\n      this.pendingCandidates.forEach(candidate => {\r\n        this.pc.addIceCandidate(candidate);\r\n      });\r\n      this.pendingCandidates = [];\r\n      this.restartingIce = false;\r\n      if (this.renegotiate) {\r\n        this.renegotiate = false;\r\n        yield this.createAndSendOffer();\r\n      } else if (sd.type === 'answer') {\r\n        this.emit(PCEvents.NegotiationComplete);\r\n        if (sd.sdp) {\r\n          const sdpParsed = libExports.parse(sd.sdp);\r\n          sdpParsed.media.forEach(media => {\r\n            if (media.type === 'video') {\r\n              this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n  createAndSendOffer(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (this.onOffer === undefined) {\r\n        return;\r\n      }\r\n      if (options === null || options === void 0 ? void 0 : options.iceRestart) {\r\n        this.log.debug('restarting ICE', this.logContext);\r\n        this.restartingIce = true;\r\n      }\r\n      if (this._pc && this._pc.signalingState === 'have-local-offer') {\r\n        // we're waiting for the peer to accept our offer, so we'll just wait\r\n        // the only exception to this is when ICE restart is needed\r\n        const currentSD = this._pc.remoteDescription;\r\n        if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\r\n          // TODO: handle when ICE restart is needed but we don't have a remote description\r\n          // the best thing to do is to recreate the peerconnection\r\n          yield this._pc.setRemoteDescription(currentSD);\r\n        } else {\r\n          this.renegotiate = true;\r\n          return;\r\n        }\r\n      } else if (!this._pc || this._pc.signalingState === 'closed') {\r\n        this.log.warn('could not createOffer with closed peer connection', this.logContext);\r\n        return;\r\n      }\r\n      // actually negotiate\r\n      this.log.debug('starting to negotiate', this.logContext);\r\n      const offer = yield this.pc.createOffer(options);\r\n      this.log.debug('original offer', Object.assign({\r\n        sdp: offer.sdp\r\n      }, this.logContext));\r\n      const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\r\n      sdpParsed.media.forEach(media => {\r\n        ensureIPAddrMatchVersion(media);\r\n        if (media.type === 'audio') {\r\n          ensureAudioNackAndStereo(media, [], []);\r\n        } else if (media.type === 'video') {\r\n          this.trackBitrates.some(trackbr => {\r\n            if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\r\n              return false;\r\n            }\r\n            let codecPayload = 0;\r\n            media.rtp.some(rtp => {\r\n              if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\r\n                codecPayload = rtp.payload;\r\n                return true;\r\n              }\r\n              return false;\r\n            });\r\n            if (codecPayload === 0) {\r\n              return true;\r\n            }\r\n            if (isSVCCodec(trackbr.codec)) {\r\n              this.ensureVideoDDExtensionForSVC(media, sdpParsed);\r\n            }\r\n            // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions\r\n            // mung sdp for av1 bitrate setting that can't apply by sendEncoding\r\n            if (trackbr.codec !== 'av1') {\r\n              return true;\r\n            }\r\n            const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\r\n            for (const fmtp of media.fmtp) {\r\n              if (fmtp.payload === codecPayload) {\r\n                // if another track's fmtp already is set, we cannot override the bitrate\r\n                // this has the unfortunate consequence of being forced to use the\r\n                // initial track's bitrate for all tracks\r\n                if (!fmtp.config.includes('x-google-start-bitrate')) {\r\n                  fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\r\n                }\r\n                break;\r\n              }\r\n            }\r\n            return true;\r\n          });\r\n        }\r\n      });\r\n      yield this.setMungedSDP(offer, libExports.write(sdpParsed));\r\n      this.onOffer(offer);\r\n    });\r\n  }\r\n  createAndSetAnswer() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const answer = yield this.pc.createAnswer();\r\n      const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : '');\r\n      sdpParsed.media.forEach(media => {\r\n        ensureIPAddrMatchVersion(media);\r\n        if (media.type === 'audio') {\r\n          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\r\n        }\r\n      });\r\n      yield this.setMungedSDP(answer, libExports.write(sdpParsed));\r\n      return answer;\r\n    });\r\n  }\r\n  createDataChannel(label, dataChannelDict) {\r\n    return this.pc.createDataChannel(label, dataChannelDict);\r\n  }\r\n  addTransceiver(mediaStreamTrack, transceiverInit) {\r\n    return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\r\n  }\r\n  addTrack(track) {\r\n    if (!this._pc) {\r\n      throw new UnexpectedConnectionState('PC closed, cannot add track');\r\n    }\r\n    return this._pc.addTrack(track);\r\n  }\r\n  setTrackCodecBitrate(info) {\r\n    this.trackBitrates.push(info);\r\n  }\r\n  setConfiguration(rtcConfig) {\r\n    var _a;\r\n    if (!this._pc) {\r\n      throw new UnexpectedConnectionState('PC closed, cannot configure');\r\n    }\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\r\n  }\r\n  canRemoveTrack() {\r\n    var _a;\r\n    return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\r\n  }\r\n  removeTrack(sender) {\r\n    var _a;\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\r\n  }\r\n  getConnectionState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getICEConnectionState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getSignallingState() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : 'closed';\r\n  }\r\n  getTransceivers() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\r\n  }\r\n  getSenders() {\r\n    var _a, _b;\r\n    return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\r\n  }\r\n  getLocalDescription() {\r\n    var _a;\r\n    return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\r\n  }\r\n  getRemoteDescription() {\r\n    var _a;\r\n    return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\r\n  }\r\n  getStats() {\r\n    return this.pc.getStats();\r\n  }\r\n  getConnectedAddress() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!this._pc) {\r\n        return;\r\n      }\r\n      let selectedCandidatePairId = '';\r\n      const candidatePairs = new Map();\r\n      // id -> candidate ip\r\n      const candidates = new Map();\r\n      const stats = yield this._pc.getStats();\r\n      stats.forEach(v => {\r\n        switch (v.type) {\r\n          case 'transport':\r\n            selectedCandidatePairId = v.selectedCandidatePairId;\r\n            break;\r\n          case 'candidate-pair':\r\n            if (selectedCandidatePairId === '' && v.selected) {\r\n              selectedCandidatePairId = v.id;\r\n            }\r\n            candidatePairs.set(v.id, v);\r\n            break;\r\n          case 'remote-candidate':\r\n            candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\r\n            break;\r\n        }\r\n      });\r\n      if (selectedCandidatePairId === '') {\r\n        return undefined;\r\n      }\r\n      const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\r\n      if (selectedID === undefined) {\r\n        return undefined;\r\n      }\r\n      return candidates.get(selectedID);\r\n    });\r\n  }\r\n  setMungedSDP(sd, munged, remote) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (munged) {\r\n        const originalSdp = sd.sdp;\r\n        sd.sdp = munged;\r\n        try {\r\n          this.log.debug(\"setting munged \".concat(remote ? 'remote' : 'local', \" description\"), this.logContext);\r\n          if (remote) {\r\n            yield this.pc.setRemoteDescription(sd);\r\n          } else {\r\n            yield this.pc.setLocalDescription(sd);\r\n          }\r\n          return;\r\n        } catch (e) {\r\n          this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\r\n            error: e,\r\n            sdp: munged\r\n          }));\r\n          sd.sdp = originalSdp;\r\n        }\r\n      }\r\n      try {\r\n        if (remote) {\r\n          yield this.pc.setRemoteDescription(sd);\r\n        } else {\r\n          yield this.pc.setLocalDescription(sd);\r\n        }\r\n      } catch (e) {\r\n        let msg = 'unknown error';\r\n        if (e instanceof Error) {\r\n          msg = e.message;\r\n        } else if (typeof e === 'string') {\r\n          msg = e;\r\n        }\r\n        const fields = {\r\n          error: msg,\r\n          sdp: sd.sdp\r\n        };\r\n        if (!remote && this.pc.remoteDescription) {\r\n          fields.remoteSdp = this.pc.remoteDescription;\r\n        }\r\n        this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\r\n          fields\r\n        }));\r\n        throw new NegotiationError(msg);\r\n      }\r\n    });\r\n  }\r\n  ensureVideoDDExtensionForSVC(media, sdp) {\r\n    var _a, _b;\r\n    const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some(ext => {\r\n      if (ext.uri === ddExtensionURI) {\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n    if (!ddFound) {\r\n      if (this.ddExtID === 0) {\r\n        let maxID = 0;\r\n        sdp.media.forEach(m => {\r\n          var _a;\r\n          if (m.type !== 'video') {\r\n            return;\r\n          }\r\n          (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach(ext => {\r\n            if (ext.value > maxID) {\r\n              maxID = ext.value;\r\n            }\r\n          });\r\n        });\r\n        this.ddExtID = maxID + 1;\r\n      }\r\n      (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\r\n        value: this.ddExtID,\r\n        uri: ddExtensionURI\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\r\n  // found opus codec to add nack fb\r\n  let opusPayload = 0;\r\n  media.rtp.some(rtp => {\r\n    if (rtp.codec === 'opus') {\r\n      opusPayload = rtp.payload;\r\n      return true;\r\n    }\r\n    return false;\r\n  });\r\n  // add nack rtcpfb if not exist\r\n  if (opusPayload > 0) {\r\n    if (!media.rtcpFb) {\r\n      media.rtcpFb = [];\r\n    }\r\n    if (nackMids.includes(media.mid) && !media.rtcpFb.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\r\n      media.rtcpFb.push({\r\n        payload: opusPayload,\r\n        type: 'nack'\r\n      });\r\n    }\r\n    if (stereoMids.includes(media.mid)) {\r\n      media.fmtp.some(fmtp => {\r\n        if (fmtp.payload === opusPayload) {\r\n          if (!fmtp.config.includes('stereo=1')) {\r\n            fmtp.config += ';stereo=1';\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n    }\r\n  }\r\n}\r\nfunction extractStereoAndNackAudioFromOffer(offer) {\r\n  var _a;\r\n  const stereoMids = [];\r\n  const nackMids = [];\r\n  const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : '');\r\n  let opusPayload = 0;\r\n  sdpParsed.media.forEach(media => {\r\n    var _a;\r\n    if (media.type === 'audio') {\r\n      media.rtp.some(rtp => {\r\n        if (rtp.codec === 'opus') {\r\n          opusPayload = rtp.payload;\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n      if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some(fb => fb.payload === opusPayload && fb.type === 'nack')) {\r\n        nackMids.push(media.mid);\r\n      }\r\n      media.fmtp.some(fmtp => {\r\n        if (fmtp.payload === opusPayload) {\r\n          if (fmtp.config.includes('sprop-stereo=1')) {\r\n            stereoMids.push(media.mid);\r\n          }\r\n          return true;\r\n        }\r\n        return false;\r\n      });\r\n    }\r\n  });\r\n  return {\r\n    stereoMids,\r\n    nackMids\r\n  };\r\n}\r\nfunction ensureIPAddrMatchVersion(media) {\r\n  // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\r\n  // in edge case and return error when set sdp.This is not a\r\n  // sdk error but correct it if the issue detected.\r\n  if (media.connection) {\r\n    const isV6 = media.connection.ip.indexOf(':') >= 0;\r\n    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\r\n      // fallback to dummy address\r\n      media.connection.ip = '0.0.0.0';\r\n      media.connection.version = 4;\r\n    }\r\n  }\r\n}\r\n\r\nconst defaultVideoCodec = 'vp8';\r\nconst publishDefaults = {\r\n  audioPreset: AudioPresets.music,\r\n  dtx: true,\r\n  red: true,\r\n  forceStereo: false,\r\n  simulcast: true,\r\n  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\r\n  stopMicTrackOnMute: false,\r\n  videoCodec: defaultVideoCodec,\r\n  backupCodec: true,\r\n  preConnectBuffer: false\r\n};\r\nconst audioDefaults = {\r\n  deviceId: {\r\n    ideal: 'default'\r\n  },\r\n  autoGainControl: true,\r\n  echoCancellation: true,\r\n  noiseSuppression: true,\r\n  voiceIsolation: true\r\n};\r\nconst videoDefaults = {\r\n  deviceId: {\r\n    ideal: 'default'\r\n  },\r\n  resolution: VideoPresets.h720.resolution\r\n};\r\nconst roomOptionDefaults = {\r\n  adaptiveStream: false,\r\n  dynacast: false,\r\n  stopLocalTrackOnUnpublish: true,\r\n  reconnectPolicy: new DefaultReconnectPolicy(),\r\n  disconnectOnPageLeave: true,\r\n  webAudioMix: false\r\n};\r\nconst roomConnectOptionDefaults = {\r\n  autoSubscribe: true,\r\n  maxRetries: 1,\r\n  peerConnectionTimeout: 15000,\r\n  websocketTimeout: 15000\r\n};\r\n\r\nvar PCTransportState;\r\n(function (PCTransportState) {\r\n  PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\r\n  PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\r\n  PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\r\n  PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\r\n  PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\r\n  PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\r\n})(PCTransportState || (PCTransportState = {}));\r\nclass PCTransportManager {\r\n  get needsPublisher() {\r\n    return this.isPublisherConnectionRequired;\r\n  }\r\n  get needsSubscriber() {\r\n    return this.isSubscriberConnectionRequired;\r\n  }\r\n  get currentState() {\r\n    return this.state;\r\n  }\r\n  constructor(rtcConfig, subscriberPrimary, loggerOptions) {\r\n    var _a;\r\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\r\n    this.log = livekitLogger;\r\n    this.updateState = () => {\r\n      var _a;\r\n      const previousState = this.state;\r\n      const connectionStates = this.requiredTransports.map(tr => tr.getConnectionState());\r\n      if (connectionStates.every(st => st === 'connected')) {\r\n        this.state = PCTransportState.CONNECTED;\r\n      } else if (connectionStates.some(st => st === 'failed')) {\r\n        this.state = PCTransportState.FAILED;\r\n      } else if (connectionStates.some(st => st === 'connecting')) {\r\n        this.state = PCTransportState.CONNECTING;\r\n      } else if (connectionStates.every(st => st === 'closed')) {\r\n        this.state = PCTransportState.CLOSED;\r\n      } else if (connectionStates.some(st => st === 'closed')) {\r\n        this.state = PCTransportState.CLOSING;\r\n      } else if (connectionStates.every(st => st === 'new')) {\r\n        this.state = PCTransportState.NEW;\r\n      }\r\n      if (previousState !== this.state) {\r\n        this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\r\n        (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\r\n      }\r\n    };\r\n    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\r\n    this.loggerOptions = loggerOptions;\r\n    this.isPublisherConnectionRequired = !subscriberPrimary;\r\n    this.isSubscriberConnectionRequired = subscriberPrimary;\r\n    this.publisher = new PCTransport(rtcConfig, loggerOptions);\r\n    this.subscriber = new PCTransport(rtcConfig, loggerOptions);\r\n    this.publisher.onConnectionStateChange = this.updateState;\r\n    this.subscriber.onConnectionStateChange = this.updateState;\r\n    this.publisher.onIceConnectionStateChange = this.updateState;\r\n    this.subscriber.onIceConnectionStateChange = this.updateState;\r\n    this.publisher.onSignalingStatechange = this.updateState;\r\n    this.subscriber.onSignalingStatechange = this.updateState;\r\n    this.publisher.onIceCandidate = candidate => {\r\n      var _a;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\r\n    };\r\n    this.subscriber.onIceCandidate = candidate => {\r\n      var _a;\r\n      (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\r\n    };\r\n    // in subscriber primary mode, server side opens sub data channels.\r\n    this.subscriber.onDataChannel = ev => {\r\n      var _a;\r\n      (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    this.subscriber.onTrack = ev => {\r\n      var _a;\r\n      (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\r\n    };\r\n    this.publisher.onOffer = offer => {\r\n      var _a;\r\n      (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\r\n    };\r\n    this.state = PCTransportState.NEW;\r\n    this.connectionLock = new _();\r\n    this.remoteOfferLock = new _();\r\n  }\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  requirePublisher() {\r\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    this.isPublisherConnectionRequired = require;\r\n    this.updateState();\r\n  }\r\n  requireSubscriber() {\r\n    let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    this.isSubscriberConnectionRequired = require;\r\n    this.updateState();\r\n  }\r\n  createAndSendPublisherOffer(options) {\r\n    return this.publisher.createAndSendOffer(options);\r\n  }\r\n  setPublisherAnswer(sd) {\r\n    return this.publisher.setRemoteDescription(sd);\r\n  }\r\n  removeTrack(sender) {\r\n    return this.publisher.removeTrack(sender);\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.publisher && this.publisher.getSignallingState() !== 'closed') {\r\n        const publisher = this.publisher;\r\n        for (const sender of publisher.getSenders()) {\r\n          try {\r\n            // TODO: react-native-webrtc doesn't have removeTrack yet.\r\n            if (publisher.canRemoveTrack()) {\r\n              publisher.removeTrack(sender);\r\n            }\r\n          } catch (e) {\r\n            this.log.warn('could not removeTrack', Object.assign(Object.assign({}, this.logContext), {\r\n              error: e\r\n            }));\r\n          }\r\n        }\r\n      }\r\n      yield Promise.all([this.publisher.close(), this.subscriber.close()]);\r\n      this.updateState();\r\n    });\r\n  }\r\n  triggerIceRestart() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.subscriber.restartingIce = true;\r\n      // only restart publisher if it's needed\r\n      if (this.needsPublisher) {\r\n        yield this.createAndSendPublisherOffer({\r\n          iceRestart: true\r\n        });\r\n      }\r\n    });\r\n  }\r\n  addIceCandidate(candidate, target) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (target === SignalTarget.PUBLISHER) {\r\n        yield this.publisher.addIceCandidate(candidate);\r\n      } else {\r\n        yield this.subscriber.addIceCandidate(candidate);\r\n      }\r\n    });\r\n  }\r\n  createSubscriberAnswerFromOffer(sd) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug('received server offer', Object.assign(Object.assign({}, this.logContext), {\r\n        RTCSdpType: sd.type,\r\n        sdp: sd.sdp,\r\n        signalingState: this.subscriber.getSignallingState().toString()\r\n      }));\r\n      const unlock = yield this.remoteOfferLock.lock();\r\n      try {\r\n        yield this.subscriber.setRemoteDescription(sd);\r\n        // answer the offer\r\n        const answer = yield this.subscriber.createAndSetAnswer();\r\n        return answer;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  updateConfiguration(config, iceRestart) {\r\n    this.publisher.setConfiguration(config);\r\n    this.subscriber.setConfiguration(config);\r\n    if (iceRestart) {\r\n      this.triggerIceRestart();\r\n    }\r\n  }\r\n  ensurePCTransportConnection(abortController, timeout) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.connectionLock.lock();\r\n      try {\r\n        if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== 'connected' && this.publisher.getConnectionState() !== 'connecting') {\r\n          this.log.debug('negotiation required, start negotiating', this.logContext);\r\n          this.publisher.negotiate();\r\n        }\r\n        yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map(transport => this.ensureTransportConnected(transport, abortController, timeout)));\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  negotiate(abortController) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        const negotiationTimeout = setTimeout(() => {\r\n          reject('negotiation timed out');\r\n        }, this.peerConnectionTimeout);\r\n        const abortHandler = () => {\r\n          clearTimeout(negotiationTimeout);\r\n          reject('negotiation aborted');\r\n        };\r\n        abortController.signal.addEventListener('abort', abortHandler);\r\n        this.publisher.once(PCEvents.NegotiationStarted, () => {\r\n          if (abortController.signal.aborted) {\r\n            return;\r\n          }\r\n          this.publisher.once(PCEvents.NegotiationComplete, () => {\r\n            clearTimeout(negotiationTimeout);\r\n            resolve();\r\n          });\r\n        });\r\n        yield this.publisher.negotiate(e => {\r\n          clearTimeout(negotiationTimeout);\r\n          reject(e);\r\n        });\r\n      }));\r\n    });\r\n  }\r\n  addPublisherTransceiver(track, transceiverInit) {\r\n    return this.publisher.addTransceiver(track, transceiverInit);\r\n  }\r\n  addPublisherTrack(track) {\r\n    return this.publisher.addTrack(track);\r\n  }\r\n  createPublisherDataChannel(label, dataChannelDict) {\r\n    return this.publisher.createDataChannel(label, dataChannelDict);\r\n  }\r\n  /**\r\n   * Returns the first required transport's address if no explicit target is specified\r\n   */\r\n  getConnectedAddress(target) {\r\n    if (target === SignalTarget.PUBLISHER) {\r\n      return this.publisher.getConnectedAddress();\r\n    } else if (target === SignalTarget.SUBSCRIBER) {\r\n      return this.publisher.getConnectedAddress();\r\n    }\r\n    return this.requiredTransports[0].getConnectedAddress();\r\n  }\r\n  get requiredTransports() {\r\n    const transports = [];\r\n    if (this.isPublisherConnectionRequired) {\r\n      transports.push(this.publisher);\r\n    }\r\n    if (this.isSubscriberConnectionRequired) {\r\n      transports.push(this.subscriber);\r\n    }\r\n    return transports;\r\n  }\r\n  ensureTransportConnected(pcTransport_1, abortController_1) {\r\n    return __awaiter(this, arguments, void 0, function (pcTransport, abortController) {\r\n      var _this = this;\r\n      let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\r\n      return function* () {\r\n        const connectionState = pcTransport.getConnectionState();\r\n        if (connectionState === 'connected') {\r\n          return;\r\n        }\r\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\r\n          const abortHandler = () => {\r\n            this.log.warn('abort transport connection', this.logContext);\r\n            CriticalTimers.clearTimeout(connectTimeout);\r\n            reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\r\n          };\r\n          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\r\n            abortHandler();\r\n          }\r\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener('abort', abortHandler);\r\n          const connectTimeout = CriticalTimers.setTimeout(() => {\r\n            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\r\n            reject(new ConnectionError('could not establish pc connection', ConnectionErrorReason.InternalError));\r\n          }, timeout);\r\n          while (this.state !== PCTransportState.CONNECTED) {\r\n            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\r\n            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\r\n              reject(new ConnectionError('room connection has been cancelled', ConnectionErrorReason.Cancelled));\r\n              return;\r\n            }\r\n          }\r\n          CriticalTimers.clearTimeout(connectTimeout);\r\n          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener('abort', abortHandler);\r\n          resolve();\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n}\r\n\r\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\r\n//\r\n// SPDX-License-Identifier: Apache-2.0\r\n/**\r\n * Specialized error handling for RPC methods.\r\n *\r\n * Instances of this type, when thrown in a method handler, will have their `message`\r\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\r\n *\r\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\r\n */\r\nclass RpcError extends Error {\r\n  /**\r\n   * Creates an error object with the given code and message, plus an optional data payload.\r\n   *\r\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\r\n   *\r\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\r\n   */\r\n  constructor(code, message, data) {\r\n    super(message);\r\n    this.code = code;\r\n    this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\r\n    this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  static fromProto(proto) {\r\n    return new RpcError(proto.code, proto.message, proto.data);\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  toProto() {\r\n    return new RpcError$1({\r\n      code: this.code,\r\n      message: this.message,\r\n      data: this.data\r\n    });\r\n  }\r\n  /**\r\n   * Creates an error object from the code, with an auto-populated message.\r\n   *\r\n   * @internal\r\n   */\r\n  static builtIn(key, data) {\r\n    return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\r\n  }\r\n}\r\nRpcError.MAX_MESSAGE_BYTES = 256;\r\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\r\nRpcError.ErrorCode = {\r\n  APPLICATION_ERROR: 1500,\r\n  CONNECTION_TIMEOUT: 1501,\r\n  RESPONSE_TIMEOUT: 1502,\r\n  RECIPIENT_DISCONNECTED: 1503,\r\n  RESPONSE_PAYLOAD_TOO_LARGE: 1504,\r\n  SEND_FAILED: 1505,\r\n  UNSUPPORTED_METHOD: 1400,\r\n  RECIPIENT_NOT_FOUND: 1401,\r\n  REQUEST_PAYLOAD_TOO_LARGE: 1402,\r\n  UNSUPPORTED_SERVER: 1403,\r\n  UNSUPPORTED_VERSION: 1404\r\n};\r\n/**\r\n * @internal\r\n */\r\nRpcError.ErrorMessage = {\r\n  APPLICATION_ERROR: 'Application error in method handler',\r\n  CONNECTION_TIMEOUT: 'Connection timeout',\r\n  RESPONSE_TIMEOUT: 'Response timeout',\r\n  RECIPIENT_DISCONNECTED: 'Recipient disconnected',\r\n  RESPONSE_PAYLOAD_TOO_LARGE: 'Response payload too large',\r\n  SEND_FAILED: 'Failed to send',\r\n  UNSUPPORTED_METHOD: 'Method not supported at destination',\r\n  RECIPIENT_NOT_FOUND: 'Recipient not found',\r\n  REQUEST_PAYLOAD_TOO_LARGE: 'Request payload too large',\r\n  UNSUPPORTED_SERVER: 'RPC not supported by server',\r\n  UNSUPPORTED_VERSION: 'Unsupported RPC version'\r\n};\r\n/*\r\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\r\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\r\n */\r\nconst MAX_PAYLOAD_BYTES = 15360; // 15 KB\r\n/**\r\n * @internal\r\n */\r\nfunction byteLength(str) {\r\n  const encoder = new TextEncoder();\r\n  return encoder.encode(str).length;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction truncateBytes(str, maxBytes) {\r\n  if (byteLength(str) <= maxBytes) {\r\n    return str;\r\n  }\r\n  let low = 0;\r\n  let high = str.length;\r\n  const encoder = new TextEncoder();\r\n  while (low < high) {\r\n    const mid = Math.floor((low + high + 1) / 2);\r\n    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\r\n      low = mid;\r\n    } else {\r\n      high = mid - 1;\r\n    }\r\n  }\r\n  return str.slice(0, low);\r\n}\r\n\r\nconst monitorFrequency = 2000;\r\nfunction computeBitrate(currentStats, prevStats) {\r\n  if (!prevStats) {\r\n    return 0;\r\n  }\r\n  let bytesNow;\r\n  let bytesPrev;\r\n  if ('bytesReceived' in currentStats) {\r\n    bytesNow = currentStats.bytesReceived;\r\n    bytesPrev = prevStats.bytesReceived;\r\n  } else if ('bytesSent' in currentStats) {\r\n    bytesNow = currentStats.bytesSent;\r\n    bytesPrev = prevStats.bytesSent;\r\n  }\r\n  if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\r\n    return 0;\r\n  }\r\n  return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\r\n}\r\n\r\n// Check if MediaRecorder is available\r\nconst isMediaRecorderAvailable = typeof MediaRecorder !== 'undefined';\r\n// Fallback class for environments without MediaRecorder\r\nclass FallbackRecorder {\r\n  constructor() {\r\n    throw new Error('MediaRecorder is not available in this environment');\r\n  }\r\n}\r\n// Use conditional inheritance to avoid parse-time errors\r\nconst RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;\r\nclass LocalTrackRecorder extends RecorderBase {\r\n  constructor(track, options) {\r\n    if (!isMediaRecorderAvailable) {\r\n      throw new Error('MediaRecorder is not available in this environment');\r\n    }\r\n    super(new MediaStream([track.mediaStreamTrack]), options);\r\n    let dataListener;\r\n    let streamController;\r\n    const isClosed = () => streamController === undefined;\r\n    const onStop = () => {\r\n      this.removeEventListener('dataavailable', dataListener);\r\n      this.removeEventListener('stop', onStop);\r\n      this.removeEventListener('error', onError);\r\n      streamController === null || streamController === void 0 ? void 0 : streamController.close();\r\n      streamController = undefined;\r\n    };\r\n    const onError = event => {\r\n      streamController === null || streamController === void 0 ? void 0 : streamController.error(event);\r\n      this.removeEventListener('dataavailable', dataListener);\r\n      this.removeEventListener('stop', onStop);\r\n      this.removeEventListener('error', onError);\r\n      streamController = undefined;\r\n    };\r\n    this.byteStream = new ReadableStream({\r\n      start: controller => {\r\n        streamController = controller;\r\n        dataListener = event => __awaiter(this, void 0, void 0, function* () {\r\n          const arrayBuffer = yield event.data.arrayBuffer();\r\n          if (isClosed()) {\r\n            return;\r\n          }\r\n          controller.enqueue(new Uint8Array(arrayBuffer));\r\n        });\r\n        this.addEventListener('dataavailable', dataListener);\r\n      },\r\n      cancel: () => {\r\n        onStop();\r\n      }\r\n    });\r\n    this.addEventListener('stop', onStop);\r\n    this.addEventListener('error', onError);\r\n  }\r\n}\r\n// Helper function to check if recording is supported\r\nfunction isRecordingSupported() {\r\n  return isMediaRecorderAvailable;\r\n}\r\n\r\nconst DEFAULT_DIMENSIONS_TIMEOUT = 1000;\r\nconst PRE_CONNECT_BUFFER_TIMEOUT = 10000;\r\nclass LocalTrack extends Track {\r\n  /** @internal */\r\n  get sender() {\r\n    return this._sender;\r\n  }\r\n  /** @internal */\r\n  set sender(sender) {\r\n    this._sender = sender;\r\n  }\r\n  get constraints() {\r\n    return this._constraints;\r\n  }\r\n  get hasPreConnectBuffer() {\r\n    return !!this.localTrackRecorder;\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param kind\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, kind, constraints) {\r\n    let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n    super(mediaTrack, kind, loggerOptions);\r\n    this.manuallyStopped = false;\r\n    this._isUpstreamPaused = false;\r\n    this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug('track mute bounce got cancelled by an unmute event', this.logContext));\r\n    this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {\r\n      yield this.pauseUpstream();\r\n    }), 5000);\r\n    this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {\r\n      this.debouncedTrackMuteHandler.cancel('unmute');\r\n      yield this.resumeUpstream();\r\n    });\r\n    this.handleEnded = () => {\r\n      if (this.isInBackground) {\r\n        this.reacquireTrack = true;\r\n      }\r\n      this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n      this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n      this.emit(TrackEvent.Ended, this);\r\n    };\r\n    this.reacquireTrack = false;\r\n    this.providedByUser = userProvidedTrack;\r\n    this.muteLock = new _();\r\n    this.pauseUpstreamLock = new _();\r\n    this.processorLock = new _();\r\n    this.restartLock = new _();\r\n    this.setMediaStreamTrack(mediaTrack, true);\r\n    // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\r\n    this._constraints = mediaTrack.getConstraints();\r\n    if (constraints) {\r\n      this._constraints = constraints;\r\n    }\r\n  }\r\n  get id() {\r\n    return this._mediaStreamTrack.id;\r\n  }\r\n  get dimensions() {\r\n    if (this.kind !== Track.Kind.Video) {\r\n      return undefined;\r\n    }\r\n    const {\r\n      width,\r\n      height\r\n    } = this._mediaStreamTrack.getSettings();\r\n    if (width && height) {\r\n      return {\r\n        width,\r\n        height\r\n      };\r\n    }\r\n    return undefined;\r\n  }\r\n  get isUpstreamPaused() {\r\n    return this._isUpstreamPaused;\r\n  }\r\n  get isUserProvided() {\r\n    return this.providedByUser;\r\n  }\r\n  get mediaStreamTrack() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /**\r\n   * @internal\r\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\r\n   */\r\n  getSourceTrackSettings() {\r\n    return this._mediaStreamTrack.getSettings();\r\n  }\r\n  setMediaStreamTrack(newTrack, force) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (newTrack === this._mediaStreamTrack && !force) {\r\n        return;\r\n      }\r\n      if (this._mediaStreamTrack) {\r\n        // detach\r\n        this.attachedElements.forEach(el => {\r\n          detachTrack(this._mediaStreamTrack, el);\r\n        });\r\n        this.debouncedTrackMuteHandler.cancel('new-track');\r\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n        this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n        this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n      }\r\n      this.mediaStream = new MediaStream([newTrack]);\r\n      if (newTrack) {\r\n        newTrack.addEventListener('ended', this.handleEnded);\r\n        // when underlying track emits mute, it indicates that the device is unable\r\n        // to produce media. In this case we'll need to signal with remote that\r\n        // the track is \"muted\"\r\n        // note this is different from LocalTrack.mute because we do not want to\r\n        // touch MediaStreamTrack.enabled\r\n        newTrack.addEventListener('mute', this.handleTrackMuteEvent);\r\n        newTrack.addEventListener('unmute', this.handleTrackUnmuteEvent);\r\n        this._constraints = newTrack.getConstraints();\r\n      }\r\n      let processedTrack;\r\n      if (this.processor && newTrack) {\r\n        const unlock = yield this.processorLock.lock();\r\n        try {\r\n          this.log.debug('restarting processor', this.logContext);\r\n          if (this.kind === 'unknown') {\r\n            throw TypeError('cannot set processor on track of unknown kind');\r\n          }\r\n          if (this.processorElement) {\r\n            attachToElement(newTrack, this.processorElement);\r\n            // ensure the processorElement itself stays muted\r\n            this.processorElement.muted = true;\r\n          }\r\n          yield this.processor.restart({\r\n            track: newTrack,\r\n            kind: this.kind,\r\n            element: this.processorElement\r\n          });\r\n          processedTrack = this.processor.processedTrack;\r\n        } finally {\r\n          unlock();\r\n        }\r\n      }\r\n      if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n        yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\r\n      }\r\n      // if `newTrack` is different from the existing track, stop the\r\n      // older track just before replacing it\r\n      if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\r\n        this._mediaStreamTrack.stop();\r\n      }\r\n      this._mediaStreamTrack = newTrack;\r\n      if (newTrack) {\r\n        // sync muted state with the enabled state of the newly provided track\r\n        this._mediaStreamTrack.enabled = !this.isMuted;\r\n        // when a valid track is replace, we'd want to start producing\r\n        yield this.resumeUpstream();\r\n        this.attachedElements.forEach(el => {\r\n          attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\r\n        });\r\n      }\r\n    });\r\n  }\r\n  waitForDimensions() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this = this;\r\n      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_DIMENSIONS_TIMEOUT;\r\n      return function* () {\r\n        var _a;\r\n        if (_this.kind === Track.Kind.Audio) {\r\n          throw new Error('cannot get dimensions for audio tracks');\r\n        }\r\n        if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === 'iOS') {\r\n          // browsers report wrong initial resolution on iOS.\r\n          // when slightly delaying the call to .getSettings(), the correct resolution is being reported\r\n          yield sleep(10);\r\n        }\r\n        const started = Date.now();\r\n        while (Date.now() - started < timeout) {\r\n          const dims = _this.dimensions;\r\n          if (dims) {\r\n            return dims;\r\n          }\r\n          yield sleep(50);\r\n        }\r\n        throw new TrackInvalidError('unable to get track dimensions after timeout');\r\n      }();\r\n    });\r\n  }\r\n  setDeviceId(deviceId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\r\n        return true;\r\n      }\r\n      this._constraints.deviceId = deviceId;\r\n      // when track is muted, underlying media stream track is stopped and\r\n      // will be restarted later\r\n      if (this.isMuted) {\r\n        return true;\r\n      }\r\n      yield this.restartTrack();\r\n      return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\r\n    });\r\n  }\r\n  /**\r\n   * @returns DeviceID of the device that is currently being used for this track\r\n   */\r\n  getDeviceId() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this2 = this;\r\n      let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        // screen share doesn't have a usable device id\r\n        if (_this2.source === Track.Source.ScreenShare) {\r\n          return;\r\n        }\r\n        const {\r\n          deviceId,\r\n          groupId\r\n        } = _this2._mediaStreamTrack.getSettings();\r\n        const kind = _this2.kind === Track.Kind.Audio ? 'audioinput' : 'videoinput';\r\n        return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\r\n      }();\r\n    });\r\n  }\r\n  mute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.setTrackMuted(true);\r\n      return this;\r\n    });\r\n  }\r\n  unmute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.setTrackMuted(false);\r\n      return this;\r\n    });\r\n  }\r\n  replaceTrack(track, userProvidedOrOptions) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        throw new TrackInvalidError('unable to replace an unpublished track');\r\n      }\r\n      let userProvidedTrack;\r\n      let stopProcessor;\r\n      if (typeof userProvidedOrOptions === 'boolean') {\r\n        userProvidedTrack = userProvidedOrOptions;\r\n      } else if (userProvidedOrOptions !== undefined) {\r\n        userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\r\n        stopProcessor = userProvidedOrOptions.stopProcessor;\r\n      }\r\n      this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\r\n      this.log.debug('replace MediaStreamTrack', this.logContext);\r\n      yield this.setMediaStreamTrack(track);\r\n      // this must be synced *after* setting mediaStreamTrack above, since it relies\r\n      // on the previous state in order to cleanup\r\n      if (stopProcessor && this.processor) {\r\n        yield this.stopProcessor();\r\n      }\r\n      return this;\r\n    });\r\n  }\r\n  restart(constraints) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.manuallyStopped = false;\r\n      const unlock = yield this.restartLock.lock();\r\n      try {\r\n        if (!constraints) {\r\n          constraints = this._constraints;\r\n        }\r\n        const {\r\n            deviceId,\r\n            facingMode\r\n          } = constraints,\r\n          otherConstraints = __rest(constraints, [\"deviceId\", \"facingMode\"]);\r\n        this.log.debug('restarting track with constraints', Object.assign(Object.assign({}, this.logContext), {\r\n          constraints\r\n        }));\r\n        const streamConstraints = {\r\n          audio: false,\r\n          video: false\r\n        };\r\n        if (this.kind === Track.Kind.Video) {\r\n          streamConstraints.video = deviceId || facingMode ? {\r\n            deviceId,\r\n            facingMode\r\n          } : true;\r\n        } else {\r\n          streamConstraints.audio = deviceId ? {\r\n            deviceId\r\n          } : true;\r\n        }\r\n        // these steps are duplicated from setMediaStreamTrack because we must stop\r\n        // the previous tracks before new tracks can be acquired\r\n        this.attachedElements.forEach(el => {\r\n          detachTrack(this.mediaStreamTrack, el);\r\n        });\r\n        this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n        // on Safari, the old audio track must be stopped before attempting to acquire\r\n        // the new track, otherwise the new track will stop with\r\n        // 'A MediaStreamTrack ended due to a capture failure`\r\n        this._mediaStreamTrack.stop();\r\n        // create new track and attach\r\n        const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\r\n        const newTrack = mediaStream.getTracks()[0];\r\n        yield newTrack.applyConstraints(otherConstraints);\r\n        newTrack.addEventListener('ended', this.handleEnded);\r\n        this.log.debug('re-acquired MediaStreamTrack', this.logContext);\r\n        yield this.setMediaStreamTrack(newTrack);\r\n        this._constraints = constraints;\r\n        this.emit(TrackEvent.Restarted, this);\r\n        if (this.manuallyStopped) {\r\n          this.log.warn('track was stopped during a restart, stopping restarted track', this.logContext);\r\n          this.stop();\r\n        }\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  setTrackMuted(muted) {\r\n    this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? 'muted' : 'unmuted'), this.logContext);\r\n    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\r\n      return;\r\n    }\r\n    this.isMuted = muted;\r\n    this._mediaStreamTrack.enabled = !muted;\r\n    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\r\n  }\r\n  get needsReAcquisition() {\r\n    return this._mediaStreamTrack.readyState !== 'live' || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!isMobile()) return;\r\n      this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\r\n      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\r\n        this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\r\n        yield this.restart();\r\n        this.reacquireTrack = false;\r\n      }\r\n    });\r\n  }\r\n  stop() {\r\n    var _a;\r\n    this.manuallyStopped = true;\r\n    super.stop();\r\n    this._mediaStreamTrack.removeEventListener('ended', this.handleEnded);\r\n    this._mediaStreamTrack.removeEventListener('mute', this.handleTrackMuteEvent);\r\n    this._mediaStreamTrack.removeEventListener('unmute', this.handleTrackUnmuteEvent);\r\n    (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\r\n    this.processor = undefined;\r\n  }\r\n  /**\r\n   * pauses publishing to the server without disabling the local MediaStreamTrack\r\n   * this is used to display a user's own video locally while pausing publishing to\r\n   * the server.\r\n   * this API is unsupported on Safari < 12 due to a bug\r\n   **/\r\n  pauseUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.pauseUpstreamLock.lock();\r\n      try {\r\n        if (this._isUpstreamPaused === true) {\r\n          return;\r\n        }\r\n        if (!this.sender) {\r\n          this.log.warn('unable to pause upstream for an unpublished track', this.logContext);\r\n          return;\r\n        }\r\n        this._isUpstreamPaused = true;\r\n        this.emit(TrackEvent.UpstreamPaused, this);\r\n        const browser = getBrowser();\r\n        if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Safari' && compareVersions(browser.version, '12.0') < 0) {\r\n          // https://bugs.webkit.org/show_bug.cgi?id=184911\r\n          throw new DeviceUnsupportedError('pauseUpstream is not supported on Safari < 12.');\r\n        }\r\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n          yield this.sender.replaceTrack(null);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  resumeUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.pauseUpstreamLock.lock();\r\n      try {\r\n        if (this._isUpstreamPaused === false) {\r\n          return;\r\n        }\r\n        if (!this.sender) {\r\n          this.log.warn('unable to resume upstream for an unpublished track', this.logContext);\r\n          return;\r\n        }\r\n        this._isUpstreamPaused = false;\r\n        this.emit(TrackEvent.UpstreamResumed, this);\r\n        if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== 'closed') {\r\n          // this operation is noop if mediastreamtrack is already being sent\r\n          yield this.sender.replaceTrack(this.mediaStreamTrack);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\r\n   *\r\n   * @returns Promise<RTCStatsReport> | undefined\r\n   */\r\n  getRTCStatsReport() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return;\r\n      }\r\n      const statsReport = yield this.sender.getStats();\r\n      return statsReport;\r\n    });\r\n  }\r\n  /**\r\n   * Sets a processor on this track.\r\n   * See https://github.com/livekit/track-processors-js for example usage\r\n   *\r\n   * @experimental\r\n   *\r\n   * @param processor\r\n   * @param showProcessedStreamLocally\r\n   * @returns\r\n   */\r\n  setProcessor(processor_1) {\r\n    return __awaiter(this, arguments, void 0, function (processor) {\r\n      var _this3 = this;\r\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a;\r\n        const unlock = yield _this3.processorLock.lock();\r\n        try {\r\n          _this3.log.debug('setting up processor', _this3.logContext);\r\n          const processorElement = document.createElement(_this3.kind);\r\n          const processorOptions = {\r\n            kind: _this3.kind,\r\n            track: _this3._mediaStreamTrack,\r\n            element: processorElement,\r\n            audioContext: _this3.audioContext\r\n          };\r\n          yield processor.init(processorOptions);\r\n          _this3.log.debug('processor initialized', _this3.logContext);\r\n          if (_this3.processor) {\r\n            yield _this3.stopProcessor();\r\n          }\r\n          if (_this3.kind === 'unknown') {\r\n            throw TypeError('cannot set processor on track of unknown kind');\r\n          }\r\n          attachToElement(_this3._mediaStreamTrack, processorElement);\r\n          processorElement.muted = true;\r\n          processorElement.play().catch(error => _this3.log.error('failed to play processor element', Object.assign(Object.assign({}, _this3.logContext), {\r\n            error\r\n          })));\r\n          _this3.processor = processor;\r\n          _this3.processorElement = processorElement;\r\n          if (_this3.processor.processedTrack) {\r\n            for (const el of _this3.attachedElements) {\r\n              if (el !== _this3.processorElement && showProcessedStreamLocally) {\r\n                detachTrack(_this3._mediaStreamTrack, el);\r\n                attachToElement(_this3.processor.processedTrack, el);\r\n              }\r\n            }\r\n            yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\r\n          }\r\n          _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\r\n        } finally {\r\n          unlock();\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  getProcessor() {\r\n    return this.processor;\r\n  }\r\n  /**\r\n   * Stops the track processor\r\n   * See https://github.com/livekit/track-processors-js for example usage\r\n   *\r\n   * @experimental\r\n   * @returns\r\n   */\r\n  stopProcessor() {\r\n    return __awaiter(this, arguments, void 0, function () {\r\n      var _this4 = this;\r\n      let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n      return function* () {\r\n        var _a, _b;\r\n        if (!_this4.processor) return;\r\n        _this4.log.debug('stopping processor', _this4.logContext);\r\n        (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\r\n        yield _this4.processor.destroy();\r\n        _this4.processor = undefined;\r\n        if (!keepElement) {\r\n          (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\r\n          _this4.processorElement = undefined;\r\n        }\r\n        // apply original track constraints in case the processor changed them\r\n        yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);\r\n        // force re-setting of the mediaStreamTrack on the sender\r\n        yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);\r\n        _this4.emit(TrackEvent.TrackProcessorUpdate);\r\n      }();\r\n    });\r\n  }\r\n  /** @internal */\r\n  startPreConnectBuffer() {\r\n    let timeslice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\r\n    if (!isRecordingSupported()) {\r\n      this.log.warn('MediaRecorder is not available, cannot start preconnect buffer', this.logContext);\r\n      return;\r\n    }\r\n    if (!this.localTrackRecorder) {\r\n      this.localTrackRecorder = new LocalTrackRecorder(this, {\r\n        mimeType: 'audio/webm;codecs=opus'\r\n      });\r\n    } else {\r\n      this.log.warn('preconnect buffer already started');\r\n      return;\r\n    }\r\n    this.localTrackRecorder.start(timeslice);\r\n    this.autoStopPreConnectBuffer = setTimeout(() => {\r\n      this.log.warn('preconnect buffer timed out, stopping recording automatically', this.logContext);\r\n      this.stopPreConnectBuffer();\r\n    }, PRE_CONNECT_BUFFER_TIMEOUT);\r\n  }\r\n  /** @internal */\r\n  stopPreConnectBuffer() {\r\n    clearTimeout(this.autoStopPreConnectBuffer);\r\n    if (this.localTrackRecorder) {\r\n      this.localTrackRecorder.stop();\r\n      this.localTrackRecorder = undefined;\r\n    }\r\n  }\r\n  /** @internal */\r\n  getPreConnectBuffer() {\r\n    var _a;\r\n    return (_a = this.localTrackRecorder) === null || _a === void 0 ? void 0 : _a.byteStream;\r\n  }\r\n}\r\n\r\nclass LocalAudioTrack extends LocalTrack {\r\n  /**\r\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\r\n   */\r\n  get enhancedNoiseCancellation() {\r\n    return this.isKrispNoiseFilterEnabled;\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, constraints) {\r\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n    let audioContext = arguments.length > 3 ? arguments[3] : undefined;\r\n    let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\r\n    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\r\n    /** @internal */\r\n    this.stopOnMute = false;\r\n    this.isKrispNoiseFilterEnabled = false;\r\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      let stats;\r\n      try {\r\n        stats = yield this.getSenderStats();\r\n      } catch (e) {\r\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n        return;\r\n      }\r\n      if (stats && this.prevStats) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.handleKrispNoiseFilterEnable = () => {\r\n      this.isKrispNoiseFilterEnabled = true;\r\n      this.log.debug(\"Krisp noise filter enabled\", this.logContext);\r\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\r\n    };\r\n    this.handleKrispNoiseFilterDisable = () => {\r\n      this.isKrispNoiseFilterEnabled = false;\r\n      this.log.debug(\"Krisp noise filter disabled\", this.logContext);\r\n      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\r\n    };\r\n    this.audioContext = audioContext;\r\n    this.checkForSilence();\r\n  }\r\n  mute() {\r\n    const _super = Object.create(null, {\r\n      mute: {\r\n        get: () => super.mute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (this.isMuted) {\r\n          this.log.debug('Track already muted', this.logContext);\r\n          return this;\r\n        }\r\n        // disabled special handling as it will cause BT headsets to switch communication modes\r\n        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\r\n          this.log.debug('stopping mic track', this.logContext);\r\n          // also stop the track, so that microphone indicator is turned off\r\n          this._mediaStreamTrack.stop();\r\n        }\r\n        yield _super.mute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  unmute() {\r\n    const _super = Object.create(null, {\r\n      unmute: {\r\n        get: () => super.unmute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (!this.isMuted) {\r\n          this.log.debug('Track already unmuted', this.logContext);\r\n          return this;\r\n        }\r\n        const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\r\n        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === 'ended' || deviceHasChanged) && !this.isUserProvided) {\r\n          this.log.debug('reacquiring mic track', this.logContext);\r\n          yield this.restartTrack();\r\n        }\r\n        yield _super.unmute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  restartTrack(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let constraints;\r\n      if (options) {\r\n        const streamConstraints = constraintsForOptions({\r\n          audio: options\r\n        });\r\n        if (typeof streamConstraints.audio !== 'boolean') {\r\n          constraints = streamConstraints.audio;\r\n        }\r\n      }\r\n      yield this.restart(constraints);\r\n    });\r\n  }\r\n  restart(constraints) {\r\n    const _super = Object.create(null, {\r\n      restart: {\r\n        get: () => super.restart\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const track = yield _super.restart.call(this, constraints);\r\n      this.checkForSilence();\r\n      return track;\r\n    });\r\n  }\r\n  /* @internal */\r\n  startMonitor() {\r\n    if (!isWeb()) {\r\n      return;\r\n    }\r\n    if (this.monitorInterval) {\r\n      return;\r\n    }\r\n    this.monitorInterval = setInterval(() => {\r\n      this.monitorSender();\r\n    }, monitorFrequency);\r\n  }\r\n  setProcessor(processor) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const unlock = yield this.processorLock.lock();\r\n      try {\r\n        if (!isReactNative() && !this.audioContext) {\r\n          throw Error('Audio context needs to be set on LocalAudioTrack in order to enable processors');\r\n        }\r\n        if (this.processor) {\r\n          yield this.stopProcessor();\r\n        }\r\n        const processorOptions = {\r\n          kind: this.kind,\r\n          track: this._mediaStreamTrack,\r\n          // RN won't have or use AudioContext\r\n          audioContext: this.audioContext\r\n        };\r\n        this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\r\n        yield processor.init(processorOptions);\r\n        this.processor = processor;\r\n        if (this.processor.processedTrack) {\r\n          yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\r\n          this.processor.processedTrack.addEventListener('enable-lk-krisp-noise-filter', this.handleKrispNoiseFilterEnable);\r\n          this.processor.processedTrack.addEventListener('disable-lk-krisp-noise-filter', this.handleKrispNoiseFilterDisable);\r\n        }\r\n        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   */\r\n  setAudioContext(audioContext) {\r\n    this.audioContext = audioContext;\r\n  }\r\n  getSenderStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return undefined;\r\n      }\r\n      const stats = yield this.sender.getStats();\r\n      let audioStats;\r\n      stats.forEach(v => {\r\n        if (v.type === 'outbound-rtp') {\r\n          audioStats = {\r\n            type: 'audio',\r\n            streamId: v.id,\r\n            packetsSent: v.packetsSent,\r\n            packetsLost: v.packetsLost,\r\n            bytesSent: v.bytesSent,\r\n            timestamp: v.timestamp,\r\n            roundTripTime: v.roundTripTime,\r\n            jitter: v.jitter\r\n          };\r\n        }\r\n      });\r\n      return audioStats;\r\n    });\r\n  }\r\n  checkForSilence() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const trackIsSilent = yield detectSilence(this);\r\n      if (trackIsSilent) {\r\n        if (!this.isMuted) {\r\n          this.log.warn('silence detected on local audio track', this.logContext);\r\n        }\r\n        this.emit(TrackEvent.AudioSilenceDetected);\r\n      }\r\n      return trackIsSilent;\r\n    });\r\n  }\r\n}\r\n\r\n/** @internal */\r\nfunction mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\r\n  switch (mediaStreamTrack.kind) {\r\n    case 'audio':\r\n      return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\r\n    case 'video':\r\n      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\r\n    default:\r\n      throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\r\n  }\r\n}\r\n/* @internal */\r\nconst presets169 = Object.values(VideoPresets);\r\n/* @internal */\r\nconst presets43 = Object.values(VideoPresets43);\r\n/* @internal */\r\nconst presetsScreenShare = Object.values(ScreenSharePresets);\r\n/* @internal */\r\nconst defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];\r\n/* @internal */\r\nconst defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];\r\n/* @internal */\r\nconst computeDefaultScreenShareSimulcastPresets = fromPreset => {\r\n  const layers = [{\r\n    scaleResolutionDownBy: 2,\r\n    fps: fromPreset.encoding.maxFramerate\r\n  }];\r\n  return layers.map(t => {\r\n    var _a, _b;\r\n    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\r\n  });\r\n};\r\n// /**\r\n//  *\r\n//  * @internal\r\n//  * @experimental\r\n//  */\r\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\r\n//   // use vp8 as a default\r\n//   const vp8 = determineAppropriateEncoding(false, width, height);\r\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\r\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\r\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\r\n//   return {\r\n//     vp8,\r\n//     vp9,\r\n//     h264,\r\n//     av1,\r\n//   };\r\n// };\r\nconst videoRids = ['q', 'h', 'f'];\r\n/* @internal */\r\nfunction computeVideoEncodings(isScreenShare, width, height, options) {\r\n  var _a, _b;\r\n  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\r\n  if (isScreenShare) {\r\n    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\r\n  }\r\n  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\r\n  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\r\n  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\r\n  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\r\n    // when we aren't simulcasting or svc, will need to return a single encoding without\r\n    // capping bandwidth. we always require a encoding for dynacast\r\n    return [{}];\r\n  }\r\n  if (!videoEncoding) {\r\n    // find the right encoding based on width/height\r\n    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\r\n    livekitLogger.debug('using video encoding', videoEncoding);\r\n  }\r\n  const sourceFramerate = videoEncoding.maxFramerate;\r\n  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\r\n  if (scalabilityMode && isSVCCodec(videoCodec)) {\r\n    const sm = new ScalabilityMode(scalabilityMode);\r\n    const encodings = [];\r\n    if (sm.spatial > 3) {\r\n      throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\r\n    }\r\n    // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\r\n    // that SVC mode should be used. Safari still works this way.\r\n    // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\r\n    // before M113.\r\n    // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\r\n    const browser = getBrowser();\r\n    if (isSafari() ||\r\n    // Even tho RN runs M114, it does not produce SVC layers when a single encoding\r\n    // is provided. So we'll use the legacy SVC specification for now.\r\n    // TODO: when we upstream libwebrtc, this will need additional verification\r\n    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '113') < 0) {\r\n      const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\r\n      // safari 18.4 uses a different svc API that requires scaleResolutionDownBy to be set.\r\n      const requireScale = isSafariSvcApi(browser);\r\n      for (let i = 0; i < sm.spatial; i += 1) {\r\n        // in legacy SVC, scaleResolutionDownBy cannot be set\r\n        encodings.push({\r\n          rid: videoRids[2 - i],\r\n          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\r\n          maxFramerate: original.encoding.maxFramerate,\r\n          scaleResolutionDownBy: requireScale ? Math.pow(2, i) : undefined\r\n        });\r\n      }\r\n      // legacy SVC, scalabilityMode is set only on the first encoding\r\n      /* @ts-ignore */\r\n      encodings[0].scalabilityMode = scalabilityMode;\r\n    } else {\r\n      encodings.push({\r\n        maxBitrate: videoEncoding.maxBitrate,\r\n        maxFramerate: original.encoding.maxFramerate,\r\n        /* @ts-ignore */\r\n        scalabilityMode: scalabilityMode\r\n      });\r\n    }\r\n    if (original.encoding.priority) {\r\n      encodings[0].priority = original.encoding.priority;\r\n      encodings[0].networkPriority = original.encoding.priority;\r\n    }\r\n    livekitLogger.debug(\"using svc encoding\", {\r\n      encodings\r\n    });\r\n    return encodings;\r\n  }\r\n  if (!useSimulcast) {\r\n    return [videoEncoding];\r\n  }\r\n  let presets = [];\r\n  if (isScreenShare) {\r\n    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\r\n  } else {\r\n    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\r\n  }\r\n  let midPreset;\r\n  if (presets.length > 0) {\r\n    const lowPreset = presets[0];\r\n    if (presets.length > 1) {\r\n      [, midPreset] = presets;\r\n    }\r\n    // NOTE:\r\n    //   1. Ordering of these encodings is important. Chrome seems\r\n    //      to use the index into encodings to decide which layer\r\n    //      to disable when CPU constrained.\r\n    //      So encodings should be ordered in increasing spatial\r\n    //      resolution order.\r\n    //   2. livekit-server translates rids into layers. So, all encodings\r\n    //      should have the base layer `q` and then more added\r\n    //      based on other conditions.\r\n    const size = Math.max(width, height);\r\n    if (size >= 960 && midPreset) {\r\n      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);\r\n    }\r\n    if (size >= 480) {\r\n      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);\r\n    }\r\n  }\r\n  return encodingsFromPresets(width, height, [original]);\r\n}\r\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\r\n  var _a, _b, _c, _d;\r\n  // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\r\n  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\r\n    // backup codec publishing is disabled\r\n    return;\r\n  }\r\n  if (videoCodec !== opts.backupCodec.codec) {\r\n    livekitLogger.warn('requested a different codec than specified as backup', {\r\n      serverRequested: videoCodec,\r\n      backup: opts.backupCodec.codec\r\n    });\r\n  }\r\n  opts.videoCodec = videoCodec;\r\n  // use backup encoding setting as videoEncoding for backup codec publishing\r\n  opts.videoEncoding = opts.backupCodec.encoding;\r\n  const settings = track.mediaStreamTrack.getSettings();\r\n  const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\r\n  const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\r\n  // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\r\n  if (track.source === Track.Source.ScreenShare && opts.simulcast) {\r\n    opts.simulcast = false;\r\n  }\r\n  const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\r\n  return encodings;\r\n}\r\n/* @internal */\r\nfunction determineAppropriateEncoding(isScreenShare, width, height, codec) {\r\n  const presets = presetsForResolution(isScreenShare, width, height);\r\n  let {\r\n    encoding\r\n  } = presets[0];\r\n  // handle portrait by swapping dimensions\r\n  const size = Math.max(width, height);\r\n  for (let i = 0; i < presets.length; i += 1) {\r\n    const preset = presets[i];\r\n    encoding = preset.encoding;\r\n    if (preset.width >= size) {\r\n      break;\r\n    }\r\n  }\r\n  // presets are based on the assumption of vp8 as a codec\r\n  // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\r\n  // users should override these with ones that are optimized for their use case\r\n  // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\r\n  // bitrate for non-SVC codecs does not include other simulcast layers.\r\n  if (codec) {\r\n    switch (codec) {\r\n      case 'av1':\r\n        encoding = Object.assign({}, encoding);\r\n        encoding.maxBitrate = encoding.maxBitrate * 0.7;\r\n        break;\r\n      case 'vp9':\r\n        encoding = Object.assign({}, encoding);\r\n        encoding.maxBitrate = encoding.maxBitrate * 0.85;\r\n        break;\r\n    }\r\n  }\r\n  return encoding;\r\n}\r\n/* @internal */\r\nfunction presetsForResolution(isScreenShare, width, height) {\r\n  if (isScreenShare) {\r\n    return presetsScreenShare;\r\n  }\r\n  const aspect = width > height ? width / height : height / width;\r\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\r\n    return presets169;\r\n  }\r\n  return presets43;\r\n}\r\n/* @internal */\r\nfunction defaultSimulcastLayers(isScreenShare, original) {\r\n  if (isScreenShare) {\r\n    return computeDefaultScreenShareSimulcastPresets(original);\r\n  }\r\n  const {\r\n    width,\r\n    height\r\n  } = original;\r\n  const aspect = width > height ? width / height : height / width;\r\n  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\r\n    return defaultSimulcastPresets169;\r\n  }\r\n  return defaultSimulcastPresets43;\r\n}\r\n// presets should be ordered by low, medium, high\r\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\r\n  const encodings = [];\r\n  presets.forEach((preset, idx) => {\r\n    if (idx >= videoRids.length) {\r\n      return;\r\n    }\r\n    const size = Math.min(width, height);\r\n    const rid = videoRids[idx];\r\n    const encoding = {\r\n      rid,\r\n      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\r\n      maxBitrate: preset.encoding.maxBitrate\r\n    };\r\n    // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\r\n    // original encoding doesn't get bumped unintentionally by any of the other layers\r\n    const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\r\n    if (maxFramerate) {\r\n      encoding.maxFramerate = maxFramerate;\r\n    }\r\n    const canSetPriority = isFireFox() || idx === 0;\r\n    if (preset.encoding.priority && canSetPriority) {\r\n      encoding.priority = preset.encoding.priority;\r\n      encoding.networkPriority = preset.encoding.priority;\r\n    }\r\n    encodings.push(encoding);\r\n  });\r\n  // RN ios simulcast requires all same framerates.\r\n  if (isReactNative() && getReactNativeOs() === 'ios') {\r\n    let topFramerate = undefined;\r\n    encodings.forEach(encoding => {\r\n      if (!topFramerate) {\r\n        topFramerate = encoding.maxFramerate;\r\n      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\r\n        topFramerate = encoding.maxFramerate;\r\n      }\r\n    });\r\n    let notifyOnce = true;\r\n    encodings.forEach(encoding => {\r\n      var _a;\r\n      if (encoding.maxFramerate != topFramerate) {\r\n        if (notifyOnce) {\r\n          notifyOnce = false;\r\n          livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\r\n        }\r\n        livekitLogger.info(\"Setting framerate of encoding \\\"\".concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : '', \"\\\" to \").concat(topFramerate));\r\n        encoding.maxFramerate = topFramerate;\r\n      }\r\n    });\r\n  }\r\n  return encodings;\r\n}\r\n/** @internal */\r\nfunction sortPresets(presets) {\r\n  if (!presets) return;\r\n  return presets.sort((a, b) => {\r\n    const {\r\n      encoding: aEnc\r\n    } = a;\r\n    const {\r\n      encoding: bEnc\r\n    } = b;\r\n    if (aEnc.maxBitrate > bEnc.maxBitrate) {\r\n      return 1;\r\n    }\r\n    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\r\n    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\r\n      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n/** @internal */\r\nclass ScalabilityMode {\r\n  constructor(scalabilityMode) {\r\n    const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\r\n    if (!results) {\r\n      throw new Error('invalid scalability mode');\r\n    }\r\n    this.spatial = parseInt(results[1]);\r\n    this.temporal = parseInt(results[2]);\r\n    if (results.length > 3) {\r\n      switch (results[3]) {\r\n        case 'h':\r\n        case '_KEY':\r\n        case '_KEY_SHIFT':\r\n          this.suffix = results[3];\r\n      }\r\n    }\r\n  }\r\n  toString() {\r\n    var _a;\r\n    return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : '');\r\n  }\r\n}\r\nfunction getDefaultDegradationPreference(track) {\r\n  // a few of reasons we have different default paths:\r\n  // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\r\n  // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\r\n  if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\r\n    return 'maintain-resolution';\r\n  } else {\r\n    return 'balanced';\r\n  }\r\n}\r\n\r\nconst refreshSubscribedCodecAfterNewCodec = 5000;\r\nclass LocalVideoTrack extends LocalTrack {\r\n  get sender() {\r\n    return this._sender;\r\n  }\r\n  set sender(sender) {\r\n    this._sender = sender;\r\n    if (this.degradationPreference) {\r\n      this.setDegradationPreference(this.degradationPreference);\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * @param mediaTrack\r\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\r\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\r\n   */\r\n  constructor(mediaTrack, constraints) {\r\n    let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n    let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\r\n    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\r\n    /* @internal */\r\n    this.simulcastCodecs = new Map();\r\n    this.degradationPreference = 'balanced';\r\n    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.sender) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      let stats;\r\n      try {\r\n        stats = yield this.getSenderStats();\r\n      } catch (e) {\r\n        this.log.error('could not get audio sender stats', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n        return;\r\n      }\r\n      const statsMap = new Map(stats.map(s => [s.rid, s]));\r\n      if (this.prevStats) {\r\n        let totalBitrate = 0;\r\n        statsMap.forEach((s, key) => {\r\n          var _a;\r\n          const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\r\n          totalBitrate += computeBitrate(s, prev);\r\n        });\r\n        this._currentBitrate = totalBitrate;\r\n      }\r\n      this.prevStats = statsMap;\r\n    });\r\n    this.senderLock = new _();\r\n  }\r\n  get isSimulcast() {\r\n    if (this.sender && this.sender.getParameters().encodings.length > 1) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /* @internal */\r\n  startMonitor(signalClient) {\r\n    var _a;\r\n    this.signalClient = signalClient;\r\n    if (!isWeb()) {\r\n      return;\r\n    }\r\n    // save original encodings\r\n    // TODO : merge simulcast tracks stats\r\n    const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\r\n    if (params) {\r\n      this.encodings = params.encodings;\r\n    }\r\n    if (this.monitorInterval) {\r\n      return;\r\n    }\r\n    this.monitorInterval = setInterval(() => {\r\n      this.monitorSender();\r\n    }, monitorFrequency);\r\n  }\r\n  stop() {\r\n    this._mediaStreamTrack.getConstraints();\r\n    this.simulcastCodecs.forEach(trackInfo => {\r\n      trackInfo.mediaStreamTrack.stop();\r\n    });\r\n    super.stop();\r\n  }\r\n  pauseUpstream() {\r\n    const _super = Object.create(null, {\r\n      pauseUpstream: {\r\n        get: () => super.pauseUpstream\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      var _d;\r\n      yield _super.pauseUpstream.call(this);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  resumeUpstream() {\r\n    const _super = Object.create(null, {\r\n      resumeUpstream: {\r\n        get: () => super.resumeUpstream\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_2, _b, _c;\r\n      var _d;\r\n      yield _super.resumeUpstream.call(this);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\r\n        }\r\n      } catch (e_2_1) {\r\n        e_2 = {\r\n          error: e_2_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_2) throw e_2.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  mute() {\r\n    const _super = Object.create(null, {\r\n      mute: {\r\n        get: () => super.mute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (this.isMuted) {\r\n          this.log.debug('Track already muted', this.logContext);\r\n          return this;\r\n        }\r\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\r\n          this.log.debug('stopping camera track', this.logContext);\r\n          // also stop the track, so that camera indicator is turned off\r\n          this._mediaStreamTrack.stop();\r\n        }\r\n        yield _super.mute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  unmute() {\r\n    const _super = Object.create(null, {\r\n      unmute: {\r\n        get: () => super.unmute\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.muteLock.lock();\r\n      try {\r\n        if (!this.isMuted) {\r\n          this.log.debug('Track already unmuted', this.logContext);\r\n          return this;\r\n        }\r\n        if (this.source === Track.Source.Camera && !this.isUserProvided) {\r\n          this.log.debug('reacquiring camera track', this.logContext);\r\n          yield this.restartTrack();\r\n        }\r\n        yield _super.unmute.call(this);\r\n        return this;\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  setTrackMuted(muted) {\r\n    super.setTrackMuted(muted);\r\n    for (const sc of this.simulcastCodecs.values()) {\r\n      sc.mediaStreamTrack.enabled = !muted;\r\n    }\r\n  }\r\n  getSenderStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return [];\r\n      }\r\n      const items = [];\r\n      const stats = yield this.sender.getStats();\r\n      stats.forEach(v => {\r\n        var _a;\r\n        if (v.type === 'outbound-rtp') {\r\n          const vs = {\r\n            type: 'video',\r\n            streamId: v.id,\r\n            frameHeight: v.frameHeight,\r\n            frameWidth: v.frameWidth,\r\n            framesPerSecond: v.framesPerSecond,\r\n            framesSent: v.framesSent,\r\n            firCount: v.firCount,\r\n            pliCount: v.pliCount,\r\n            nackCount: v.nackCount,\r\n            packetsSent: v.packetsSent,\r\n            bytesSent: v.bytesSent,\r\n            qualityLimitationReason: v.qualityLimitationReason,\r\n            qualityLimitationDurations: v.qualityLimitationDurations,\r\n            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\r\n            rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\r\n            retransmittedPacketsSent: v.retransmittedPacketsSent,\r\n            targetBitrate: v.targetBitrate,\r\n            timestamp: v.timestamp\r\n          };\r\n          // locate the appropriate remote-inbound-rtp item\r\n          const r = stats.get(v.remoteId);\r\n          if (r) {\r\n            vs.jitter = r.jitter;\r\n            vs.packetsLost = r.packetsLost;\r\n            vs.roundTripTime = r.roundTripTime;\r\n          }\r\n          items.push(vs);\r\n        }\r\n      });\r\n      // make sure highest res layer is always first\r\n      items.sort((a, b) => {\r\n        var _a, _b;\r\n        return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\r\n      });\r\n      return items;\r\n    });\r\n  }\r\n  setPublishingQuality(maxQuality) {\r\n    const qualities = [];\r\n    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {\r\n      qualities.push(new SubscribedQuality({\r\n        quality: q,\r\n        enabled: q <= maxQuality\r\n      }));\r\n    }\r\n    this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\r\n    this.setPublishingLayers(isSVCCodec(this.codec), qualities);\r\n  }\r\n  restartTrack(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_3, _b, _c;\r\n      var _d;\r\n      let constraints;\r\n      if (options) {\r\n        const streamConstraints = constraintsForOptions({\r\n          video: options\r\n        });\r\n        if (typeof streamConstraints.video !== 'boolean') {\r\n          constraints = streamConstraints.video;\r\n        }\r\n      }\r\n      yield this.restart(constraints);\r\n      try {\r\n        for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {\r\n          _c = _g.value;\r\n          _e = false;\r\n          const sc = _c;\r\n          if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== 'closed') {\r\n            sc.mediaStreamTrack = this.mediaStreamTrack.clone();\r\n            yield sc.sender.replaceTrack(sc.mediaStreamTrack);\r\n          }\r\n        }\r\n      } catch (e_3_1) {\r\n        e_3 = {\r\n          error: e_3_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\r\n        } finally {\r\n          if (e_3) throw e_3.error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  setProcessor(processor_1) {\r\n    const _super = Object.create(null, {\r\n      setProcessor: {\r\n        get: () => super.setProcessor\r\n      }\r\n    });\r\n    return __awaiter(this, arguments, void 0, function (processor) {\r\n      var _this = this;\r\n      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        var _a, e_4, _b, _c;\r\n        var _d, _e;\r\n        yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\r\n        if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\r\n          try {\r\n            for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {\r\n              _c = _h.value;\r\n              _f = false;\r\n              const sc = _c;\r\n              yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\r\n            }\r\n          } catch (e_4_1) {\r\n            e_4 = {\r\n              error: e_4_1\r\n            };\r\n          } finally {\r\n            try {\r\n              if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\r\n            } finally {\r\n              if (e_4) throw e_4.error;\r\n            }\r\n          }\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  setDegradationPreference(preference) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.degradationPreference = preference;\r\n      if (this.sender) {\r\n        try {\r\n          this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\r\n          const params = this.sender.getParameters();\r\n          params.degradationPreference = preference;\r\n          this.sender.setParameters(params);\r\n        } catch (e) {\r\n          this.log.warn(\"failed to set degradationPreference\", Object.assign({\r\n            error: e\r\n          }, this.logContext));\r\n        }\r\n      }\r\n    });\r\n  }\r\n  addSimulcastTrack(codec, encodings) {\r\n    if (this.simulcastCodecs.has(codec)) {\r\n      this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\r\n      return;\r\n    }\r\n    const simulcastCodecInfo = {\r\n      codec,\r\n      mediaStreamTrack: this.mediaStreamTrack.clone(),\r\n      sender: undefined,\r\n      encodings\r\n    };\r\n    this.simulcastCodecs.set(codec, simulcastCodecInfo);\r\n    return simulcastCodecInfo;\r\n  }\r\n  setSimulcastTrackSender(codec, sender) {\r\n    const simulcastCodecInfo = this.simulcastCodecs.get(codec);\r\n    if (!simulcastCodecInfo) {\r\n      return;\r\n    }\r\n    simulcastCodecInfo.sender = sender;\r\n    // browser will reenable disabled codec/layers after new codec has been published,\r\n    // so refresh subscribedCodecs after publish a new codec\r\n    setTimeout(() => {\r\n      if (this.subscribedCodecs) {\r\n        this.setPublishingCodecs(this.subscribedCodecs);\r\n      }\r\n    }, refreshSubscribedCodecAfterNewCodec);\r\n  }\r\n  /**\r\n   * @internal\r\n   * Sets codecs that should be publishing, returns new codecs that have not yet\r\n   * been published\r\n   */\r\n  setPublishingCodecs(codecs) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, codecs_1, codecs_1_1;\r\n      var _b, e_5, _c, _d;\r\n      this.log.debug('setting publishing codecs', Object.assign(Object.assign({}, this.logContext), {\r\n        codecs,\r\n        currentCodec: this.codec\r\n      }));\r\n      // only enable simulcast codec for preference codec setted\r\n      if (!this.codec && codecs.length > 0) {\r\n        yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);\r\n        return [];\r\n      }\r\n      this.subscribedCodecs = codecs;\r\n      const newCodecs = [];\r\n      try {\r\n        for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {\r\n          _d = codecs_1_1.value;\r\n          _a = false;\r\n          const codec = _d;\r\n          if (!this.codec || this.codec === codec.codec) {\r\n            yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);\r\n          } else {\r\n            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\r\n            this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\r\n              simulcastCodecInfo\r\n            }));\r\n            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\r\n              for (const q of codec.qualities) {\r\n                if (q.enabled) {\r\n                  newCodecs.push(codec.codec);\r\n                  break;\r\n                }\r\n              }\r\n            } else if (simulcastCodecInfo.encodings) {\r\n              this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\r\n              yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, isSVCCodec(codec.codec), this.log, this.logContext);\r\n            }\r\n          }\r\n        }\r\n      } catch (e_5_1) {\r\n        e_5 = {\r\n          error: e_5_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\r\n        } finally {\r\n          if (e_5) throw e_5.error;\r\n        }\r\n      }\r\n      return newCodecs;\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * Sets layers that should be publishing\r\n   */\r\n  setPublishingLayers(isSvc, qualities) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug('setting publishing layers', Object.assign(Object.assign({}, this.logContext), {\r\n        qualities\r\n      }));\r\n      if (!this.sender || !this.encodings) {\r\n        return;\r\n      }\r\n      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, isSvc, this.log, this.logContext);\r\n    });\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!isMobile()) return;\r\n      if (this.isInBackground && this.source === Track.Source.Camera) {\r\n        this._mediaStreamTrack.enabled = false;\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, isSVC, log, logContext) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const unlock = yield senderLock.lock();\r\n    log.debug('setPublishingLayersForSender', Object.assign(Object.assign({}, logContext), {\r\n      sender,\r\n      qualities,\r\n      senderEncodings\r\n    }));\r\n    try {\r\n      const params = sender.getParameters();\r\n      const {\r\n        encodings\r\n      } = params;\r\n      if (!encodings) {\r\n        return;\r\n      }\r\n      if (encodings.length !== senderEncodings.length) {\r\n        log.warn('cannot set publishing layers, encodings mismatch', Object.assign(Object.assign({}, logContext), {\r\n          encodings,\r\n          senderEncodings\r\n        }));\r\n        return;\r\n      }\r\n      let hasChanged = false;\r\n      const browser = getBrowser();\r\n      const closableSpatial = (browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, '133') > 0;\r\n      /* @ts-ignore */\r\n      if (closableSpatial && encodings[0].scalabilityMode) {\r\n        // svc dynacast encodings\r\n        const encoding = encodings[0];\r\n        /* @ts-ignore */\r\n        const mode = new ScalabilityMode(encoding.scalabilityMode);\r\n        let maxQuality = VideoQuality$1.OFF;\r\n        qualities.forEach(q => {\r\n          if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {\r\n            maxQuality = q.quality;\r\n          }\r\n        });\r\n        if (maxQuality === VideoQuality$1.OFF) {\r\n          if (encoding.active) {\r\n            encoding.active = false;\r\n            hasChanged = true;\r\n          }\r\n        } else if (!encoding.active || mode.spatial !== maxQuality + 1) {\r\n          hasChanged = true;\r\n          encoding.active = true;\r\n          /* @ts-ignore */\r\n          const originalMode = new ScalabilityMode(senderEncodings[0].scalabilityMode);\r\n          mode.spatial = maxQuality + 1;\r\n          mode.suffix = originalMode.suffix;\r\n          if (mode.spatial === 1) {\r\n            // no suffix for L1Tx\r\n            mode.suffix = undefined;\r\n          }\r\n          /* @ts-ignore */\r\n          encoding.scalabilityMode = mode.toString();\r\n          encoding.scaleResolutionDownBy = Math.pow(2, 2 - maxQuality);\r\n          if (senderEncodings[0].maxBitrate) {\r\n            encoding.maxBitrate = senderEncodings[0].maxBitrate / (encoding.scaleResolutionDownBy * encoding.scaleResolutionDownBy);\r\n          }\r\n        }\r\n      } else {\r\n        if (isSVC) {\r\n          const hasEnabledEncoding = qualities.some(q => q.enabled);\r\n          if (hasEnabledEncoding) {\r\n            qualities.forEach(q => q.enabled = true);\r\n          }\r\n        }\r\n        // simulcast dynacast encodings\r\n        encodings.forEach((encoding, idx) => {\r\n          var _a;\r\n          let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : '';\r\n          if (rid === '') {\r\n            rid = 'q';\r\n          }\r\n          const quality = videoQualityForRid(rid);\r\n          const subscribedQuality = qualities.find(q => q.quality === quality);\r\n          if (!subscribedQuality) {\r\n            return;\r\n          }\r\n          if (encoding.active !== subscribedQuality.enabled) {\r\n            hasChanged = true;\r\n            encoding.active = subscribedQuality.enabled;\r\n            log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? 'enabled' : 'disabled'), logContext);\r\n            // FireFox does not support setting encoding.active to false, so we\r\n            // have a workaround of lowering its bitrate and resolution to the min.\r\n            if (isFireFox()) {\r\n              if (subscribedQuality.enabled) {\r\n                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\r\n                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\r\n                /* @ts-ignore */\r\n                encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\r\n              } else {\r\n                encoding.scaleResolutionDownBy = 4;\r\n                encoding.maxBitrate = 10;\r\n                /* @ts-ignore */\r\n                encoding.maxFrameRate = 2;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (hasChanged) {\r\n        params.encodings = encodings;\r\n        log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\r\n          encodings: params.encodings\r\n        }));\r\n        yield sender.setParameters(params);\r\n      }\r\n    } finally {\r\n      unlock();\r\n    }\r\n  });\r\n}\r\nfunction videoQualityForRid(rid) {\r\n  switch (rid) {\r\n    case 'f':\r\n      return VideoQuality.HIGH;\r\n    case 'h':\r\n      return VideoQuality.MEDIUM;\r\n    case 'q':\r\n      return VideoQuality.LOW;\r\n    default:\r\n      return VideoQuality.HIGH;\r\n  }\r\n}\r\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\r\n  // default to a single layer, HQ\r\n  if (!encodings) {\r\n    return [new VideoLayer({\r\n      quality: VideoQuality.HIGH,\r\n      width,\r\n      height,\r\n      bitrate: 0,\r\n      ssrc: 0\r\n    })];\r\n  }\r\n  if (svc) {\r\n    // svc layers\r\n    /* @ts-ignore */\r\n    const encodingSM = encodings[0].scalabilityMode;\r\n    const sm = new ScalabilityMode(encodingSM);\r\n    const layers = [];\r\n    const resRatio = sm.suffix == 'h' ? 1.5 : 2;\r\n    const bitratesRatio = sm.suffix == 'h' ? 2 : 3;\r\n    for (let i = 0; i < sm.spatial; i += 1) {\r\n      layers.push(new VideoLayer({\r\n        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\r\n        width: Math.ceil(width / Math.pow(resRatio, i)),\r\n        height: Math.ceil(height / Math.pow(resRatio, i)),\r\n        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\r\n        ssrc: 0\r\n      }));\r\n    }\r\n    return layers;\r\n  }\r\n  return encodings.map(encoding => {\r\n    var _a, _b, _c;\r\n    const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\r\n    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : '');\r\n    return new VideoLayer({\r\n      quality,\r\n      width: Math.ceil(width / scale),\r\n      height: Math.ceil(height / scale),\r\n      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\r\n      ssrc: 0\r\n    });\r\n  });\r\n}\r\n\r\nconst lossyDataChannel = '_lossy';\r\nconst reliableDataChannel = '_reliable';\r\nconst minReconnectWait = 2 * 1000;\r\nconst leaveReconnect = 'leave-reconnect';\r\nconst reliabeReceiveStateTTL = 30000;\r\nvar PCState;\r\n(function (PCState) {\r\n  PCState[PCState[\"New\"] = 0] = \"New\";\r\n  PCState[PCState[\"Connected\"] = 1] = \"Connected\";\r\n  PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\r\n  PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\r\n  PCState[PCState[\"Closed\"] = 4] = \"Closed\";\r\n})(PCState || (PCState = {}));\r\n/** @internal */\r\nclass RTCEngine extends eventsExports.EventEmitter {\r\n  get isClosed() {\r\n    return this._isClosed;\r\n  }\r\n  get pendingReconnect() {\r\n    return !!this.reconnectTimeout;\r\n  }\r\n  constructor(options) {\r\n    var _a;\r\n    super();\r\n    this.options = options;\r\n    this.rtcConfig = {};\r\n    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\r\n    this.fullReconnectOnNext = false;\r\n    this.subscriberPrimary = false;\r\n    this.pcState = PCState.New;\r\n    this._isClosed = true;\r\n    this.pendingTrackResolvers = {};\r\n    this.reconnectAttempts = 0;\r\n    this.reconnectStart = 0;\r\n    this.attemptingReconnect = false;\r\n    /** keeps track of how often an initial join connection has been tried */\r\n    this.joinAttempts = 0;\r\n    /** specifies how often an initial join connection is allowed to retry */\r\n    this.maxJoinAttempts = 1;\r\n    this.shouldFailNext = false;\r\n    this.log = livekitLogger;\r\n    this.reliableDataSequence = 1;\r\n    this.reliableMessageBuffer = new DataPacketBuffer();\r\n    this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);\r\n    this.handleDataChannel = _a => __awaiter(this, [_a], void 0, function (_ref) {\r\n      var _this = this;\r\n      let {\r\n        channel\r\n      } = _ref;\r\n      return function* () {\r\n        if (!channel) {\r\n          return;\r\n        }\r\n        if (channel.label === reliableDataChannel) {\r\n          _this.reliableDCSub = channel;\r\n        } else if (channel.label === lossyDataChannel) {\r\n          _this.lossyDCSub = channel;\r\n        } else {\r\n          return;\r\n        }\r\n        _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\r\n        channel.onmessage = _this.handleDataMessage;\r\n      }();\r\n    });\r\n    this.handleDataMessage = message => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      // make sure to respect incoming data message order by processing message events one after the other\r\n      const unlock = yield this.dataProcessLock.lock();\r\n      try {\r\n        // decode\r\n        let buffer;\r\n        if (message.data instanceof ArrayBuffer) {\r\n          buffer = message.data;\r\n        } else if (message.data instanceof Blob) {\r\n          buffer = yield message.data.arrayBuffer();\r\n        } else {\r\n          this.log.error('unsupported data type', Object.assign(Object.assign({}, this.logContext), {\r\n            data: message.data\r\n          }));\r\n          return;\r\n        }\r\n        const dp = DataPacket.fromBinary(new Uint8Array(buffer));\r\n        if (dp.sequence > 0 && dp.participantSid !== '') {\r\n          const lastSeq = this.reliableReceivedState.get(dp.participantSid);\r\n          if (lastSeq && dp.sequence <= lastSeq) {\r\n            // ignore duplicate or out-of-order packets in reliable channel\r\n            return;\r\n          }\r\n          this.reliableReceivedState.set(dp.participantSid, dp.sequence);\r\n        }\r\n        if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === 'speaker') {\r\n          // dispatch speaker updates\r\n          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\r\n        } else {\r\n          if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === 'user') {\r\n            // compatibility\r\n            applyUserDataCompat(dp, dp.value.value);\r\n          }\r\n          this.emit(EngineEvent.DataPacketReceived, dp);\r\n        }\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n    this.handleDataError = event => {\r\n      const channel = event.currentTarget;\r\n      const channelKind = channel.maxRetransmits === 0 ? 'lossy' : 'reliable';\r\n      if (event instanceof ErrorEvent && event.error) {\r\n        const {\r\n          error\r\n        } = event.error;\r\n        this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\r\n          error\r\n        }));\r\n      } else {\r\n        this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\r\n          event\r\n        }));\r\n      }\r\n    };\r\n    this.handleBufferedAmountLow = event => {\r\n      const channel = event.currentTarget;\r\n      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\r\n      this.updateAndEmitDCBufferStatus(channelKind);\r\n    };\r\n    // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\r\n    // continues to work, we can reconnect to websocket to continue the session\r\n    // after a number of retries, we'll close and give up permanently\r\n    this.handleDisconnect = (connection, disconnectReason) => {\r\n      if (this._isClosed) {\r\n        return;\r\n      }\r\n      this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\r\n      if (this.reconnectAttempts === 0) {\r\n        // only reset start time on the first try\r\n        this.reconnectStart = Date.now();\r\n      }\r\n      const disconnect = duration => {\r\n        this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\r\n        this.emit(EngineEvent.Disconnected);\r\n        this.close();\r\n      };\r\n      const duration = Date.now() - this.reconnectStart;\r\n      let delay = this.getNextRetryDelay({\r\n        elapsedMs: duration,\r\n        retryCount: this.reconnectAttempts\r\n      });\r\n      if (delay === null) {\r\n        disconnect(duration);\r\n        return;\r\n      }\r\n      if (connection === leaveReconnect) {\r\n        delay = 0;\r\n      }\r\n      this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\r\n      this.clearReconnectTimeout();\r\n      if (this.token && this.regionUrlProvider) {\r\n        // token may have been refreshed, we do not want to recreate the regionUrlProvider\r\n        // since the current engine may have inherited a regional url\r\n        this.regionUrlProvider.updateToken(this.token);\r\n      }\r\n      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = undefined), delay);\r\n    };\r\n    this.waitForRestarted = () => {\r\n      return new Promise((resolve, reject) => {\r\n        if (this.pcState === PCState.Connected) {\r\n          resolve();\r\n        }\r\n        const onRestarted = () => {\r\n          this.off(EngineEvent.Disconnected, onDisconnected);\r\n          resolve();\r\n        };\r\n        const onDisconnected = () => {\r\n          this.off(EngineEvent.Restarted, onRestarted);\r\n          reject();\r\n        };\r\n        this.once(EngineEvent.Restarted, onRestarted);\r\n        this.once(EngineEvent.Disconnected, onDisconnected);\r\n      });\r\n    };\r\n    this.updateAndEmitDCBufferStatus = kind => {\r\n      const status = this.isBufferStatusLow(kind);\r\n      if (typeof status !== 'undefined' && status !== this.dcBufferStatus.get(kind)) {\r\n        this.dcBufferStatus.set(kind, status);\r\n        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\r\n      }\r\n    };\r\n    this.isBufferStatusLow = kind => {\r\n      const dc = this.dataChannelForKind(kind);\r\n      if (dc) {\r\n        if (kind === DataPacket_Kind.RELIABLE) {\r\n          this.reliableMessageBuffer.alignBufferedAmount(dc.bufferedAmount);\r\n        }\r\n        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\r\n      }\r\n    };\r\n    this.handleBrowserOnLine = () => {\r\n      // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\r\n      if (this.client.currentState === SignalConnectionState.RECONNECTING) {\r\n        this.clearReconnectTimeout();\r\n        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\r\n      }\r\n    };\r\n    this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\r\n    this.loggerOptions = {\r\n      loggerName: options.loggerName,\r\n      loggerContextCb: () => this.logContext\r\n    };\r\n    this.client = new SignalClient(undefined, this.loggerOptions);\r\n    this.client.signalLatency = this.options.expSignalLatency;\r\n    this.reconnectPolicy = this.options.reconnectPolicy;\r\n    this.registerOnLineListener();\r\n    this.closingLock = new _();\r\n    this.dataProcessLock = new _();\r\n    this.dcBufferStatus = new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);\r\n    this.client.onParticipantUpdate = updates => this.emit(EngineEvent.ParticipantUpdate, updates);\r\n    this.client.onConnectionQuality = update => this.emit(EngineEvent.ConnectionQualityUpdate, update);\r\n    this.client.onRoomUpdate = update => this.emit(EngineEvent.RoomUpdate, update);\r\n    this.client.onSubscriptionError = resp => this.emit(EngineEvent.SubscriptionError, resp);\r\n    this.client.onSubscriptionPermissionUpdate = update => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\r\n    this.client.onSpeakersChanged = update => this.emit(EngineEvent.SpeakersChanged, update);\r\n    this.client.onStreamStateUpdate = update => this.emit(EngineEvent.StreamStateChanged, update);\r\n    this.client.onRequestResponse = response => this.emit(EngineEvent.SignalRequestResponse, response);\r\n  }\r\n  /** @internal */\r\n  get logContext() {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    return {\r\n      room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\r\n      roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\r\n      participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\r\n      pID: this.participantSid\r\n    };\r\n  }\r\n  join(url, token, opts, abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.url = url;\r\n      this.token = token;\r\n      this.signalOpts = opts;\r\n      this.maxJoinAttempts = opts.maxRetries;\r\n      try {\r\n        this.joinAttempts += 1;\r\n        this.setupSignalClientCallbacks();\r\n        const joinResponse = yield this.client.join(url, token, opts, abortSignal);\r\n        this._isClosed = false;\r\n        this.latestJoinResponse = joinResponse;\r\n        this.subscriberPrimary = joinResponse.subscriberPrimary;\r\n        if (!this.pcManager) {\r\n          yield this.configure(joinResponse);\r\n        }\r\n        // create offer\r\n        if (!this.subscriberPrimary || joinResponse.fastPublish) {\r\n          this.negotiate();\r\n        }\r\n        this.clientConfiguration = joinResponse.clientConfiguration;\r\n        this.emit(EngineEvent.SignalConnected, joinResponse);\r\n        return joinResponse;\r\n      } catch (e) {\r\n        if (e instanceof ConnectionError) {\r\n          if (e.reason === ConnectionErrorReason.ServerUnreachable) {\r\n            this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\r\n            if (this.joinAttempts < this.maxJoinAttempts) {\r\n              return this.join(url, token, opts, abortSignal);\r\n            }\r\n          }\r\n        }\r\n        throw e;\r\n      }\r\n    });\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const unlock = yield this.closingLock.lock();\r\n      if (this.isClosed) {\r\n        unlock();\r\n        return;\r\n      }\r\n      try {\r\n        this._isClosed = true;\r\n        this.joinAttempts = 0;\r\n        this.emit(EngineEvent.Closing);\r\n        this.removeAllListeners();\r\n        this.deregisterOnLineListener();\r\n        this.clearPendingReconnect();\r\n        yield this.cleanupPeerConnections();\r\n        yield this.cleanupClient();\r\n      } finally {\r\n        unlock();\r\n      }\r\n    });\r\n  }\r\n  cleanupPeerConnections() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\r\n      this.pcManager = undefined;\r\n      const dcCleanup = dc => {\r\n        if (!dc) return;\r\n        dc.close();\r\n        dc.onbufferedamountlow = null;\r\n        dc.onclose = null;\r\n        dc.onclosing = null;\r\n        dc.onerror = null;\r\n        dc.onmessage = null;\r\n        dc.onopen = null;\r\n      };\r\n      dcCleanup(this.lossyDC);\r\n      dcCleanup(this.lossyDCSub);\r\n      dcCleanup(this.reliableDC);\r\n      dcCleanup(this.reliableDCSub);\r\n      this.lossyDC = undefined;\r\n      this.lossyDCSub = undefined;\r\n      this.reliableDC = undefined;\r\n      this.reliableDCSub = undefined;\r\n      this.reliableMessageBuffer = new DataPacketBuffer();\r\n      this.reliableDataSequence = 1;\r\n      this.reliableReceivedState.clear();\r\n    });\r\n  }\r\n  cleanupClient() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.client.close();\r\n      this.client.resetCallbacks();\r\n    });\r\n  }\r\n  addTrack(req) {\r\n    if (this.pendingTrackResolvers[req.cid]) {\r\n      throw new TrackInvalidError('a track with the same ID has already been published');\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      const publicationTimeout = setTimeout(() => {\r\n        delete this.pendingTrackResolvers[req.cid];\r\n        reject(new ConnectionError('publication of local track timed out, no response from server', ConnectionErrorReason.Timeout));\r\n      }, 10000);\r\n      this.pendingTrackResolvers[req.cid] = {\r\n        resolve: info => {\r\n          clearTimeout(publicationTimeout);\r\n          resolve(info);\r\n        },\r\n        reject: () => {\r\n          clearTimeout(publicationTimeout);\r\n          reject(new Error('Cancelled publication by calling unpublish'));\r\n        }\r\n      };\r\n      this.client.sendAddTrack(req);\r\n    });\r\n  }\r\n  /**\r\n   * Removes sender from PeerConnection, returning true if it was removed successfully\r\n   * and a negotiation is necessary\r\n   * @param sender\r\n   * @returns\r\n   */\r\n  removeTrack(sender) {\r\n    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\r\n      const {\r\n        reject\r\n      } = this.pendingTrackResolvers[sender.track.id];\r\n      if (reject) {\r\n        reject();\r\n      }\r\n      delete this.pendingTrackResolvers[sender.track.id];\r\n    }\r\n    try {\r\n      this.pcManager.removeTrack(sender);\r\n      return true;\r\n    } catch (e) {\r\n      this.log.warn('failed to remove track', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n    }\r\n    return false;\r\n  }\r\n  updateMuteStatus(trackSid, muted) {\r\n    this.client.sendMuteTrack(trackSid, muted);\r\n  }\r\n  get dataSubscriberReadyState() {\r\n    var _a;\r\n    return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\r\n  }\r\n  getConnectedServerAddress() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\r\n    });\r\n  }\r\n  /* @internal */\r\n  setRegionUrlProvider(provider) {\r\n    this.regionUrlProvider = provider;\r\n  }\r\n  configure(joinResponse) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      // already configured\r\n      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\r\n        return;\r\n      }\r\n      this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\r\n      const rtcConfig = this.makeRTCConfiguration(joinResponse);\r\n      this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\r\n      this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\r\n      this.pcManager.onIceCandidate = (candidate, target) => {\r\n        this.client.sendIceCandidate(candidate, target);\r\n      };\r\n      this.pcManager.onPublisherOffer = offer => {\r\n        this.client.sendOffer(offer);\r\n      };\r\n      this.pcManager.onDataChannel = this.handleDataChannel;\r\n      this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {\r\n        this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\r\n        if (['closed', 'disconnected', 'failed'].includes(publisherState)) {\r\n          // reset publisher connection promise\r\n          this.publisherConnectionPromise = undefined;\r\n        }\r\n        if (connectionState === PCTransportState.CONNECTED) {\r\n          const shouldEmit = this.pcState === PCState.New;\r\n          this.pcState = PCState.Connected;\r\n          if (shouldEmit) {\r\n            this.emit(EngineEvent.Connected, joinResponse);\r\n          }\r\n        } else if (connectionState === PCTransportState.FAILED) {\r\n          // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\r\n          if (this.pcState === PCState.Connected) {\r\n            this.pcState = PCState.Disconnected;\r\n            this.handleDisconnect('peerconnection failed', subscriberState === 'failed' ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\r\n          }\r\n        }\r\n        // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\r\n        const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\r\n        const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);\r\n        if (isSignalSevered && isPCSevered && !this._isClosed) {\r\n          this.emit(EngineEvent.Offline);\r\n        }\r\n      });\r\n      this.pcManager.onTrack = ev => {\r\n        this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\r\n      };\r\n      if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\r\n        this.createDataChannels();\r\n      }\r\n    });\r\n  }\r\n  setupSignalClientCallbacks() {\r\n    // configure signaling client\r\n    this.client.onAnswer = sd => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      this.log.debug('received server answer', Object.assign(Object.assign({}, this.logContext), {\r\n        RTCSdpType: sd.type\r\n      }));\r\n      yield this.pcManager.setPublisherAnswer(sd);\r\n    });\r\n    // add candidate on trickle\r\n    this.client.onTrickle = (candidate, target) => {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      this.log.debug('got ICE candidate from peer', Object.assign(Object.assign({}, this.logContext), {\r\n        candidate,\r\n        target\r\n      }));\r\n      this.pcManager.addIceCandidate(candidate, target);\r\n    };\r\n    // when server creates an offer for the client\r\n    this.client.onOffer = sd => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        return;\r\n      }\r\n      const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\r\n      this.client.sendAnswer(answer);\r\n    });\r\n    this.client.onLocalTrackPublished = res => {\r\n      var _a;\r\n      this.log.debug('received trackPublishedResponse', Object.assign(Object.assign({}, this.logContext), {\r\n        cid: res.cid,\r\n        track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\r\n      }));\r\n      if (!this.pendingTrackResolvers[res.cid]) {\r\n        this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\r\n          cid: res.cid\r\n        }));\r\n        return;\r\n      }\r\n      const {\r\n        resolve\r\n      } = this.pendingTrackResolvers[res.cid];\r\n      delete this.pendingTrackResolvers[res.cid];\r\n      resolve(res.track);\r\n    };\r\n    this.client.onLocalTrackUnpublished = response => {\r\n      this.emit(EngineEvent.LocalTrackUnpublished, response);\r\n    };\r\n    this.client.onLocalTrackSubscribed = trackSid => {\r\n      this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\r\n    };\r\n    this.client.onTokenRefresh = token => {\r\n      this.token = token;\r\n    };\r\n    this.client.onRemoteMuteChanged = (trackSid, muted) => {\r\n      this.emit(EngineEvent.RemoteMute, trackSid, muted);\r\n    };\r\n    this.client.onSubscribedQualityUpdate = update => {\r\n      this.emit(EngineEvent.SubscribedQualityUpdate, update);\r\n    };\r\n    this.client.onRoomMoved = res => {\r\n      var _a;\r\n      this.participantSid = (_a = res.participant) === null || _a === void 0 ? void 0 : _a.sid;\r\n      if (this.latestJoinResponse) {\r\n        this.latestJoinResponse.room = res.room;\r\n      }\r\n      this.emit(EngineEvent.RoomMoved, res);\r\n    };\r\n    this.client.onClose = () => {\r\n      this.handleDisconnect('signal', ReconnectReason.RR_SIGNAL_DISCONNECTED);\r\n    };\r\n    this.client.onLeave = leave => {\r\n      this.log.debug('client leave request', Object.assign(Object.assign({}, this.logContext), {\r\n        reason: leave === null || leave === void 0 ? void 0 : leave.reason\r\n      }));\r\n      if (leave.regions && this.regionUrlProvider) {\r\n        this.log.debug('updating regions', this.logContext);\r\n        this.regionUrlProvider.setServerReportedRegions(leave.regions);\r\n      }\r\n      switch (leave.action) {\r\n        case LeaveRequest_Action.DISCONNECT:\r\n          this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\r\n          this.close();\r\n          break;\r\n        case LeaveRequest_Action.RECONNECT:\r\n          this.fullReconnectOnNext = true;\r\n          // reconnect immediately instead of waiting for next attempt\r\n          this.handleDisconnect(leaveReconnect);\r\n          break;\r\n        case LeaveRequest_Action.RESUME:\r\n          // reconnect immediately instead of waiting for next attempt\r\n          this.handleDisconnect(leaveReconnect);\r\n      }\r\n    };\r\n  }\r\n  makeRTCConfiguration(serverResponse) {\r\n    var _a;\r\n    const rtcConfig = Object.assign({}, this.rtcConfig);\r\n    if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\r\n      this.log.debug('E2EE - setting up transports with insertable streams', this.logContext);\r\n      //  this makes sure that no data is sent before the transforms are ready\r\n      // @ts-ignore\r\n      rtcConfig.encodedInsertableStreams = true;\r\n    }\r\n    // update ICE servers before creating PeerConnection\r\n    if (serverResponse.iceServers && !rtcConfig.iceServers) {\r\n      const rtcIceServers = [];\r\n      serverResponse.iceServers.forEach(iceServer => {\r\n        const rtcIceServer = {\r\n          urls: iceServer.urls\r\n        };\r\n        if (iceServer.username) rtcIceServer.username = iceServer.username;\r\n        if (iceServer.credential) {\r\n          rtcIceServer.credential = iceServer.credential;\r\n        }\r\n        rtcIceServers.push(rtcIceServer);\r\n      });\r\n      rtcConfig.iceServers = rtcIceServers;\r\n    }\r\n    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\r\n      rtcConfig.iceTransportPolicy = 'relay';\r\n    }\r\n    // @ts-ignore\r\n    rtcConfig.sdpSemantics = 'unified-plan';\r\n    // @ts-ignore\r\n    rtcConfig.continualGatheringPolicy = 'gather_continually';\r\n    return rtcConfig;\r\n  }\r\n  createDataChannels() {\r\n    if (!this.pcManager) {\r\n      return;\r\n    }\r\n    // clear old data channel callbacks if recreate\r\n    if (this.lossyDC) {\r\n      this.lossyDC.onmessage = null;\r\n      this.lossyDC.onerror = null;\r\n    }\r\n    if (this.reliableDC) {\r\n      this.reliableDC.onmessage = null;\r\n      this.reliableDC.onerror = null;\r\n    }\r\n    // create data channels\r\n    this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\r\n      ordered: false,\r\n      maxRetransmits: 0\r\n    });\r\n    this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\r\n      ordered: true\r\n    });\r\n    // also handle messages over the pub channel, for backwards compatibility\r\n    this.lossyDC.onmessage = this.handleDataMessage;\r\n    this.reliableDC.onmessage = this.handleDataMessage;\r\n    // handle datachannel errors\r\n    this.lossyDC.onerror = this.handleDataError;\r\n    this.reliableDC.onerror = this.handleDataError;\r\n    // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\r\n    this.lossyDC.bufferedAmountLowThreshold = 65535;\r\n    this.reliableDC.bufferedAmountLowThreshold = 65535;\r\n    // handle buffer amount low events\r\n    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\r\n    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\r\n  }\r\n  createSender(track, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (supportsTransceiver()) {\r\n        const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\r\n        return sender;\r\n      }\r\n      if (supportsAddTrack()) {\r\n        this.log.warn('using add-track fallback', this.logContext);\r\n        const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\r\n        return sender;\r\n      }\r\n      throw new UnexpectedConnectionState('Required webRTC APIs not supported on this device');\r\n    });\r\n  }\r\n  createSimulcastSender(track, simulcastTrack, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // store RTCRtpSender\r\n      if (supportsTransceiver()) {\r\n        return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\r\n      }\r\n      if (supportsAddTrack()) {\r\n        this.log.debug('using add-track fallback', this.logContext);\r\n        return this.createRTCRtpSender(track.mediaStreamTrack);\r\n      }\r\n      throw new UnexpectedConnectionState('Cannot stream on this device');\r\n    });\r\n  }\r\n  createTransceiverRTCRtpSender(track, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      const streams = [];\r\n      if (track.mediaStream) {\r\n        streams.push(track.mediaStream);\r\n      }\r\n      if (isVideoTrack(track)) {\r\n        track.codec = opts.videoCodec;\r\n      }\r\n      const transceiverInit = {\r\n        direction: 'sendonly',\r\n        streams\r\n      };\r\n      if (encodings) {\r\n        transceiverInit.sendEncodings = encodings;\r\n      }\r\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\r\n      const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\r\n      return transceiver.sender;\r\n    });\r\n  }\r\n  createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      const transceiverInit = {\r\n        direction: 'sendonly'\r\n      };\r\n      if (encodings) {\r\n        transceiverInit.sendEncodings = encodings;\r\n      }\r\n      // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\r\n      const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\r\n      if (!opts.videoCodec) {\r\n        return;\r\n      }\r\n      track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\r\n      return transceiver.sender;\r\n    });\r\n  }\r\n  createRTCRtpSender(track) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher is closed');\r\n      }\r\n      return this.pcManager.addPublisherTrack(track);\r\n    });\r\n  }\r\n  attemptReconnect(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      if (this._isClosed) {\r\n        return;\r\n      }\r\n      // guard for attempting reconnection multiple times while one attempt is still not finished\r\n      if (this.attemptingReconnect) {\r\n        livekitLogger.warn('already attempting reconnect, returning early', this.logContext);\r\n        return;\r\n      }\r\n      if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED ||\r\n      // signaling state could change to closed due to hardware sleep\r\n      // those connections cannot be resumed\r\n      ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\r\n        this.fullReconnectOnNext = true;\r\n      }\r\n      try {\r\n        this.attemptingReconnect = true;\r\n        if (this.fullReconnectOnNext) {\r\n          yield this.restartConnection();\r\n        } else {\r\n          yield this.resumeConnection(reason);\r\n        }\r\n        this.clearPendingReconnect();\r\n        this.fullReconnectOnNext = false;\r\n      } catch (e) {\r\n        this.reconnectAttempts += 1;\r\n        let recoverable = true;\r\n        if (e instanceof UnexpectedConnectionState) {\r\n          this.log.debug('received unrecoverable error', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n          // unrecoverable\r\n          recoverable = false;\r\n        } else if (!(e instanceof SignalReconnectError)) {\r\n          // cannot resume\r\n          this.fullReconnectOnNext = true;\r\n        }\r\n        if (recoverable) {\r\n          this.handleDisconnect('reconnect', ReconnectReason.RR_UNKNOWN);\r\n        } else {\r\n          this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\r\n          this.emit(EngineEvent.Disconnected);\r\n          yield this.close();\r\n        }\r\n      } finally {\r\n        this.attemptingReconnect = false;\r\n      }\r\n    });\r\n  }\r\n  getNextRetryDelay(context) {\r\n    try {\r\n      return this.reconnectPolicy.nextRetryDelayInMs(context);\r\n    } catch (e) {\r\n      this.log.warn('encountered error in reconnect policy', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n    }\r\n    // error in user code with provided reconnect policy, stop reconnecting\r\n    return null;\r\n  }\r\n  restartConnection(regionUrl) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      try {\r\n        if (!this.url || !this.token) {\r\n          // permanent failure, don't attempt reconnection\r\n          throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\r\n        }\r\n        this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\r\n        this.emit(EngineEvent.Restarting);\r\n        if (!this.client.isDisconnected) {\r\n          yield this.client.sendLeave();\r\n        }\r\n        yield this.cleanupPeerConnections();\r\n        yield this.cleanupClient();\r\n        let joinResponse;\r\n        try {\r\n          if (!this.signalOpts) {\r\n            this.log.warn('attempted connection restart, without signal options present', this.logContext);\r\n            throw new SignalReconnectError();\r\n          }\r\n          // in case a regionUrl is passed, the region URL takes precedence\r\n          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\r\n        } catch (e) {\r\n          if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\r\n            throw new UnexpectedConnectionState('could not reconnect, token might be expired');\r\n          }\r\n          throw new SignalReconnectError();\r\n        }\r\n        if (this.shouldFailNext) {\r\n          this.shouldFailNext = false;\r\n          throw new Error('simulated failure');\r\n        }\r\n        this.client.setReconnected();\r\n        this.emit(EngineEvent.SignalRestarted, joinResponse);\r\n        yield this.waitForPCReconnected();\r\n        // re-check signal connection state before setting engine as resumed\r\n        if (this.client.currentState !== SignalConnectionState.CONNECTED) {\r\n          throw new SignalReconnectError('Signal connection got severed during reconnect');\r\n        }\r\n        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\r\n        // reconnect success\r\n        this.emit(EngineEvent.Restarted);\r\n      } catch (error) {\r\n        const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\r\n        if (nextRegionUrl) {\r\n          yield this.restartConnection(nextRegionUrl);\r\n          return;\r\n        } else {\r\n          // no more regions to try (or we're not on cloud)\r\n          (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\r\n          throw error;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  resumeConnection(reason) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!this.url || !this.token) {\r\n        // permanent failure, don't attempt reconnection\r\n        throw new UnexpectedConnectionState('could not reconnect, url or token not saved');\r\n      }\r\n      // trigger publisher reconnect\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('publisher and subscriber connections unset');\r\n      }\r\n      this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\r\n      this.emit(EngineEvent.Resuming);\r\n      let res;\r\n      try {\r\n        this.setupSignalClientCallbacks();\r\n        res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\r\n      } catch (error) {\r\n        let message = '';\r\n        if (error instanceof Error) {\r\n          message = error.message;\r\n          this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\r\n            error\r\n          }));\r\n        }\r\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\r\n          throw new UnexpectedConnectionState('could not reconnect, token might be expired');\r\n        }\r\n        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\r\n          throw error;\r\n        }\r\n        throw new SignalReconnectError(message);\r\n      }\r\n      this.emit(EngineEvent.SignalResumed);\r\n      if (res) {\r\n        const rtcConfig = this.makeRTCConfiguration(res);\r\n        this.pcManager.updateConfiguration(rtcConfig);\r\n        if (this.latestJoinResponse) {\r\n          this.latestJoinResponse.serverInfo = res.serverInfo;\r\n        }\r\n      } else {\r\n        this.log.warn('Did not receive reconnect response', this.logContext);\r\n      }\r\n      if (this.shouldFailNext) {\r\n        this.shouldFailNext = false;\r\n        throw new Error('simulated failure');\r\n      }\r\n      yield this.pcManager.triggerIceRestart();\r\n      yield this.waitForPCReconnected();\r\n      // re-check signal connection state before setting engine as resumed\r\n      if (this.client.currentState !== SignalConnectionState.CONNECTED) {\r\n        throw new SignalReconnectError('Signal connection got severed during reconnect');\r\n      }\r\n      this.client.setReconnected();\r\n      // recreate publish datachannel if it's id is null\r\n      // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\r\n      if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === 'open' && this.reliableDC.id === null) {\r\n        this.createDataChannels();\r\n      }\r\n      if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {\r\n        this.resendReliableMessagesForResume(res.lastMessageSeq);\r\n      }\r\n      // resume success\r\n      this.emit(EngineEvent.Resumed);\r\n    });\r\n  }\r\n  waitForPCInitialConnection(timeout, abortController) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.pcManager) {\r\n        throw new UnexpectedConnectionState('PC manager is closed');\r\n      }\r\n      yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\r\n    });\r\n  }\r\n  waitForPCReconnected() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.pcState = PCState.Reconnecting;\r\n      this.log.debug('waiting for peer connection to reconnect', this.logContext);\r\n      try {\r\n        yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\r\n        if (!this.pcManager) {\r\n          throw new UnexpectedConnectionState('PC manager is closed');\r\n        }\r\n        yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\r\n        this.pcState = PCState.Connected;\r\n      } catch (e) {\r\n        // TODO do we need a `failed` state here for the PC?\r\n        this.pcState = PCState.Disconnected;\r\n        throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\r\n      }\r\n    });\r\n  }\r\n  /** @internal */\r\n  publishRpcResponse(destinationIdentity, requestId, payload, error) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcResponse',\r\n          value: new RpcResponse({\r\n            requestId,\r\n            value: error ? {\r\n              case: 'error',\r\n              value: error.toProto()\r\n            } : {\r\n              case: 'payload',\r\n              value: payload !== null && payload !== void 0 ? payload : ''\r\n            }\r\n          })\r\n        }\r\n      });\r\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /** @internal */\r\n  publishRpcAck(destinationIdentity, requestId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcAck',\r\n          value: new RpcAck({\r\n            requestId\r\n          })\r\n        }\r\n      });\r\n      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /* @internal */\r\n  sendDataPacket(packet, kind) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // make sure we do have a data connection\r\n      yield this.ensurePublisherConnected(kind);\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        packet.sequence = this.reliableDataSequence;\r\n        this.reliableDataSequence += 1;\r\n      }\r\n      const msg = packet.toBinary();\r\n      const dc = this.dataChannelForKind(kind);\r\n      if (dc) {\r\n        if (kind === DataPacket_Kind.RELIABLE) {\r\n          this.reliableMessageBuffer.push({\r\n            data: msg,\r\n            sequence: packet.sequence\r\n          });\r\n        }\r\n        if (this.attemptingReconnect) {\r\n          return;\r\n        }\r\n        dc.send(msg);\r\n      }\r\n      this.updateAndEmitDCBufferStatus(kind);\r\n    });\r\n  }\r\n  resendReliableMessagesForResume(lastMessageSeq) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);\r\n      const dc = this.dataChannelForKind(DataPacket_Kind.RELIABLE);\r\n      if (dc) {\r\n        this.reliableMessageBuffer.popToSequence(lastMessageSeq);\r\n        this.reliableMessageBuffer.getAll().forEach(msg => {\r\n          dc.send(msg.data);\r\n        });\r\n      }\r\n      this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  waitForBufferStatusLow(kind) {\r\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n      if (this.isBufferStatusLow(kind)) {\r\n        resolve();\r\n      } else {\r\n        const onClosing = () => reject('Engine closed');\r\n        this.once(EngineEvent.Closing, onClosing);\r\n        while (!this.dcBufferStatus.get(kind)) {\r\n          yield sleep(10);\r\n        }\r\n        this.off(EngineEvent.Closing, onClosing);\r\n        resolve();\r\n      }\r\n    }));\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  ensureDataTransportConnected(kind_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind) {\r\n      var _this2 = this;\r\n      let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\r\n      return function* () {\r\n        var _a;\r\n        if (!_this2.pcManager) {\r\n          throw new UnexpectedConnectionState('PC manager is closed');\r\n        }\r\n        const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\r\n        const transportName = subscriber ? 'Subscriber' : 'Publisher';\r\n        if (!transport) {\r\n          throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\r\n        }\r\n        let needNegotiation = false;\r\n        if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\r\n          _this2.createDataChannels();\r\n          needNegotiation = true;\r\n        }\r\n        if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== 'checking') {\r\n          needNegotiation = true;\r\n        }\r\n        if (needNegotiation) {\r\n          // start negotiation\r\n          _this2.negotiate();\r\n        }\r\n        const targetChannel = _this2.dataChannelForKind(kind, subscriber);\r\n        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === 'open') {\r\n          return;\r\n        }\r\n        // wait until ICE connected\r\n        const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\r\n        while (new Date().getTime() < endTime) {\r\n          if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === 'open') {\r\n            return;\r\n          }\r\n          yield sleep(50);\r\n        }\r\n        throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\r\n      }();\r\n    });\r\n  }\r\n  ensurePublisherConnected(kind) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.publisherConnectionPromise) {\r\n        this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\r\n      }\r\n      yield this.publisherConnectionPromise;\r\n    });\r\n  }\r\n  /* @internal */\r\n  verifyTransport() {\r\n    if (!this.pcManager) {\r\n      return false;\r\n    }\r\n    // primary connection\r\n    if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\r\n      return false;\r\n    }\r\n    // ensure signal is connected\r\n    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  negotiate() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      // observe signal state\r\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        if (!this.pcManager) {\r\n          reject(new NegotiationError('PC manager is closed'));\r\n          return;\r\n        }\r\n        this.pcManager.requirePublisher();\r\n        // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\r\n        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\r\n          this.createDataChannels();\r\n        }\r\n        const abortController = new AbortController();\r\n        const handleClosed = () => {\r\n          abortController.abort();\r\n          this.log.debug('engine disconnected while negotiation was ongoing', this.logContext);\r\n          resolve();\r\n          return;\r\n        };\r\n        if (this.isClosed) {\r\n          reject('cannot negotiate on closed engine');\r\n        }\r\n        this.on(EngineEvent.Closing, handleClosed);\r\n        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, rtpTypes => {\r\n          const rtpMap = new Map();\r\n          rtpTypes.forEach(rtp => {\r\n            const codec = rtp.codec.toLowerCase();\r\n            if (isVideoCodec(codec)) {\r\n              rtpMap.set(rtp.payload, codec);\r\n            }\r\n          });\r\n          this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\r\n        });\r\n        try {\r\n          yield this.pcManager.negotiate(abortController);\r\n          resolve();\r\n        } catch (e) {\r\n          if (e instanceof NegotiationError) {\r\n            this.fullReconnectOnNext = true;\r\n          }\r\n          this.handleDisconnect('negotiation', ReconnectReason.RR_UNKNOWN);\r\n          reject(e);\r\n        } finally {\r\n          this.off(EngineEvent.Closing, handleClosed);\r\n        }\r\n      }));\r\n    });\r\n  }\r\n  dataChannelForKind(kind, sub) {\r\n    if (!sub) {\r\n      if (kind === DataPacket_Kind.LOSSY) {\r\n        return this.lossyDC;\r\n      }\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        return this.reliableDC;\r\n      }\r\n    } else {\r\n      if (kind === DataPacket_Kind.LOSSY) {\r\n        return this.lossyDCSub;\r\n      }\r\n      if (kind === DataPacket_Kind.RELIABLE) {\r\n        return this.reliableDCSub;\r\n      }\r\n    }\r\n  }\r\n  /** @internal */\r\n  sendSyncState(remoteTracks, localTracks) {\r\n    var _a, _b;\r\n    if (!this.pcManager) {\r\n      this.log.warn('sync state cannot be sent without peer connection setup', this.logContext);\r\n      return;\r\n    }\r\n    const previousAnswer = this.pcManager.subscriber.getLocalDescription();\r\n    const previousOffer = this.pcManager.subscriber.getRemoteDescription();\r\n    /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\r\n          in this case, we send unsub tracks, so server add all tracks to this\r\n          subscribe pc and unsub special tracks from it.\r\n       2. autosubscribe off, we send subscribed tracks.\r\n    */\r\n    const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\r\n    const trackSids = new Array();\r\n    const trackSidsDisabled = new Array();\r\n    remoteTracks.forEach(track => {\r\n      if (track.isDesired !== autoSubscribe) {\r\n        trackSids.push(track.trackSid);\r\n      }\r\n      if (!track.isEnabled) {\r\n        trackSidsDisabled.push(track.trackSid);\r\n      }\r\n    });\r\n    this.client.sendSyncState(new SyncState({\r\n      answer: previousAnswer ? toProtoSessionDescription({\r\n        sdp: previousAnswer.sdp,\r\n        type: previousAnswer.type\r\n      }) : undefined,\r\n      offer: previousOffer ? toProtoSessionDescription({\r\n        sdp: previousOffer.sdp,\r\n        type: previousOffer.type\r\n      }) : undefined,\r\n      subscription: new UpdateSubscription({\r\n        trackSids,\r\n        subscribe: !autoSubscribe,\r\n        participantTracks: []\r\n      }),\r\n      publishTracks: getTrackPublicationInfo(localTracks),\r\n      dataChannels: this.dataChannelsInfo(),\r\n      trackSidsDisabled,\r\n      datachannelReceiveStates: this.reliableReceivedState.map((seq, sid) => {\r\n        return new DataChannelReceiveState({\r\n          publisherSid: sid,\r\n          lastSeq: seq\r\n        });\r\n      })\r\n    }));\r\n  }\r\n  /* @internal */\r\n  failNext() {\r\n    // debugging method to fail the next reconnect/resume attempt\r\n    this.shouldFailNext = true;\r\n  }\r\n  dataChannelsInfo() {\r\n    const infos = [];\r\n    const getInfo = (dc, target) => {\r\n      if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\r\n        infos.push(new DataChannelInfo({\r\n          label: dc.label,\r\n          id: dc.id,\r\n          target\r\n        }));\r\n      }\r\n    };\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\r\n    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\r\n    return infos;\r\n  }\r\n  clearReconnectTimeout() {\r\n    if (this.reconnectTimeout) {\r\n      CriticalTimers.clearTimeout(this.reconnectTimeout);\r\n    }\r\n  }\r\n  clearPendingReconnect() {\r\n    this.clearReconnectTimeout();\r\n    this.reconnectAttempts = 0;\r\n  }\r\n  registerOnLineListener() {\r\n    if (isWeb()) {\r\n      window.addEventListener('online', this.handleBrowserOnLine);\r\n    }\r\n  }\r\n  deregisterOnLineListener() {\r\n    if (isWeb()) {\r\n      window.removeEventListener('online', this.handleBrowserOnLine);\r\n    }\r\n  }\r\n}\r\nclass SignalReconnectError extends Error {}\r\nfunction supportOptionalDatachannel(protocol) {\r\n  return protocol !== undefined && protocol > 13;\r\n}\r\nfunction applyUserDataCompat(newObj, oldObj) {\r\n  const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\r\n  newObj.participantIdentity = participantIdentity;\r\n  oldObj.participantIdentity = participantIdentity;\r\n  const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\r\n  newObj.destinationIdentities = destinationIdentities;\r\n  oldObj.destinationIdentities = destinationIdentities;\r\n}\r\n\r\nclass RegionUrlProvider {\r\n  constructor(url, token) {\r\n    this.lastUpdateAt = 0;\r\n    this.settingsCacheTime = 3000;\r\n    this.attemptedRegions = [];\r\n    this.serverUrl = new URL(url);\r\n    this.token = token;\r\n  }\r\n  updateToken(token) {\r\n    this.token = token;\r\n  }\r\n  isCloud() {\r\n    return isCloud(this.serverUrl);\r\n  }\r\n  getServerUrl() {\r\n    return this.serverUrl;\r\n  }\r\n  getNextBestRegionUrl(abortSignal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.isCloud()) {\r\n        throw Error('region availability is only supported for LiveKit Cloud domains');\r\n      }\r\n      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\r\n        this.regionSettings = yield this.fetchRegionSettings(abortSignal);\r\n      }\r\n      const regionsLeft = this.regionSettings.regions.filter(region => !this.attemptedRegions.find(attempted => attempted.url === region.url));\r\n      if (regionsLeft.length > 0) {\r\n        const nextRegion = regionsLeft[0];\r\n        this.attemptedRegions.push(nextRegion);\r\n        livekitLogger.debug(\"next region: \".concat(nextRegion.region));\r\n        return nextRegion.url;\r\n      } else {\r\n        return null;\r\n      }\r\n    });\r\n  }\r\n  resetAttempts() {\r\n    this.attemptedRegions = [];\r\n  }\r\n  /* @internal */\r\n  fetchRegionSettings(signal) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\r\n        headers: {\r\n          authorization: \"Bearer \".concat(this.token)\r\n        },\r\n        signal\r\n      });\r\n      if (regionSettingsResponse.ok) {\r\n        const regionSettings = yield regionSettingsResponse.json();\r\n        this.lastUpdateAt = Date.now();\r\n        return regionSettings;\r\n      } else {\r\n        throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\r\n      }\r\n    });\r\n  }\r\n  setServerReportedRegions(regions) {\r\n    this.regionSettings = regions;\r\n    this.lastUpdateAt = Date.now();\r\n  }\r\n}\r\nfunction getCloudConfigUrl(serverUrl) {\r\n  return \"\".concat(serverUrl.protocol.replace('ws', 'http'), \"//\").concat(serverUrl.host, \"/settings\");\r\n}\r\n\r\nclass BaseStreamReader {\r\n  get info() {\r\n    return this._info;\r\n  }\r\n  constructor(info, stream, totalByteSize) {\r\n    this.reader = stream;\r\n    this.totalByteSize = totalByteSize;\r\n    this._info = info;\r\n    this.bytesReceived = 0;\r\n  }\r\n}\r\nclass ByteStreamReader extends BaseStreamReader {\r\n  handleChunkReceived(chunk) {\r\n    var _a;\r\n    this.bytesReceived += chunk.content.byteLength;\r\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\r\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\r\n  }\r\n  [Symbol.asyncIterator]() {\r\n    const reader = this.reader.getReader();\r\n    return {\r\n      next: () => __awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n          const {\r\n            done,\r\n            value\r\n          } = yield reader.read();\r\n          if (done) {\r\n            return {\r\n              done: true,\r\n              value: undefined\r\n            };\r\n          } else {\r\n            this.handleChunkReceived(value);\r\n            return {\r\n              done: false,\r\n              value: value.content\r\n            };\r\n          }\r\n        } catch (error) {\r\n          // TODO handle errors\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        }\r\n      }),\r\n      return() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n          reader.releaseLock();\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        });\r\n      }\r\n    };\r\n  }\r\n  readAll() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      let chunks = new Set();\r\n      try {\r\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\r\n          _c = _f.value;\r\n          _d = false;\r\n          const chunk = _c;\r\n          chunks.add(chunk);\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n      return Array.from(chunks);\r\n    });\r\n  }\r\n}\r\n/**\r\n * A class to read chunks from a ReadableStream and provide them in a structured format.\r\n */\r\nclass TextStreamReader extends BaseStreamReader {\r\n  /**\r\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\r\n   * that has been received up to the current point in time.\r\n   */\r\n  constructor(info, stream, totalChunkCount) {\r\n    super(info, stream, totalChunkCount);\r\n    this.receivedChunks = new Map();\r\n  }\r\n  handleChunkReceived(chunk) {\r\n    var _a;\r\n    const index = bigIntToNumber(chunk.chunkIndex);\r\n    const previousChunkAtIndex = this.receivedChunks.get(index);\r\n    if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\r\n      // we have a newer version already, dropping the old one\r\n      return;\r\n    }\r\n    this.receivedChunks.set(index, chunk);\r\n    this.bytesReceived += chunk.content.byteLength;\r\n    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\r\n    (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\r\n  }\r\n  /**\r\n   * Async iterator implementation to allow usage of `for await...of` syntax.\r\n   * Yields structured chunks from the stream.\r\n   *\r\n   */\r\n  [Symbol.asyncIterator]() {\r\n    const reader = this.reader.getReader();\r\n    const decoder = new TextDecoder();\r\n    return {\r\n      next: () => __awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n          const {\r\n            done,\r\n            value\r\n          } = yield reader.read();\r\n          if (done) {\r\n            return {\r\n              done: true,\r\n              value: undefined\r\n            };\r\n          } else {\r\n            this.handleChunkReceived(value);\r\n            return {\r\n              done: false,\r\n              value: decoder.decode(value.content)\r\n            };\r\n          }\r\n        } catch (error) {\r\n          // TODO handle errors\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        }\r\n      }),\r\n      return() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n          reader.releaseLock();\r\n          return {\r\n            done: true,\r\n            value: undefined\r\n          };\r\n        });\r\n      }\r\n    };\r\n  }\r\n  readAll() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_2, _b, _c;\r\n      let finalString = '';\r\n      try {\r\n        for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\r\n          _c = _f.value;\r\n          _d = false;\r\n          const chunk = _c;\r\n          finalString += chunk;\r\n        }\r\n      } catch (e_2_1) {\r\n        e_2 = {\r\n          error: e_2_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\r\n        } finally {\r\n          if (e_2) throw e_2.error;\r\n        }\r\n      }\r\n      return finalString;\r\n    });\r\n  }\r\n}\r\n\r\nclass BaseStreamWriter {\r\n  constructor(writableStream, info, onClose) {\r\n    this.writableStream = writableStream;\r\n    this.defaultWriter = writableStream.getWriter();\r\n    this.onClose = onClose;\r\n    this.info = info;\r\n  }\r\n  write(chunk) {\r\n    return this.defaultWriter.write(chunk);\r\n  }\r\n  close() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield this.defaultWriter.close();\r\n      this.defaultWriter.releaseLock();\r\n      (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    });\r\n  }\r\n}\r\nclass TextStreamWriter extends BaseStreamWriter {}\r\nclass ByteStreamWriter extends BaseStreamWriter {}\r\n\r\nclass RemoteTrack extends Track {\r\n  constructor(mediaTrack, sid, kind, receiver, loggerOptions) {\r\n    super(mediaTrack, kind, loggerOptions);\r\n    this.sid = sid;\r\n    this.receiver = receiver;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /** @internal */\r\n  setMuted(muted) {\r\n    if (this.isMuted !== muted) {\r\n      this.isMuted = muted;\r\n      this._mediaStreamTrack.enabled = !muted;\r\n      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\r\n    }\r\n  }\r\n  /** @internal */\r\n  setMediaStream(stream) {\r\n    // this is needed to determine when the track is finished\r\n    this.mediaStream = stream;\r\n    const onRemoveTrack = event => {\r\n      if (event.track === this._mediaStreamTrack) {\r\n        stream.removeEventListener('removetrack', onRemoveTrack);\r\n        if (this.receiver && 'playoutDelayHint' in this.receiver) {\r\n          this.receiver.playoutDelayHint = undefined;\r\n        }\r\n        this.receiver = undefined;\r\n        this._currentBitrate = 0;\r\n        this.emit(TrackEvent.Ended, this);\r\n      }\r\n    };\r\n    stream.addEventListener('removetrack', onRemoveTrack);\r\n  }\r\n  start() {\r\n    this.startMonitor();\r\n    // use `enabled` of track to enable re-use of transceiver\r\n    super.enable();\r\n  }\r\n  stop() {\r\n    this.stopMonitor();\r\n    // use `enabled` of track to enable re-use of transceiver\r\n    super.disable();\r\n  }\r\n  /**\r\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\r\n   *\r\n   * @returns Promise<RTCStatsReport> | undefined\r\n   */\r\n  getRTCStatsReport() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\r\n        return;\r\n      }\r\n      const statsReport = yield this.receiver.getStats();\r\n      return statsReport;\r\n    });\r\n  }\r\n  /**\r\n   * Allows to set a playout delay (in seconds) for this track.\r\n   * A higher value allows for more buffering of the track in the browser\r\n   * and will result in a delay of media being played back of `delayInSeconds`\r\n   */\r\n  setPlayoutDelay(delayInSeconds) {\r\n    if (this.receiver) {\r\n      if ('playoutDelayHint' in this.receiver) {\r\n        this.receiver.playoutDelayHint = delayInSeconds;\r\n      } else {\r\n        this.log.warn('Playout delay not supported in this browser');\r\n      }\r\n    } else {\r\n      this.log.warn('Cannot set playout delay, track already ended');\r\n    }\r\n  }\r\n  /**\r\n   * Returns the current playout delay (in seconds) of this track.\r\n   */\r\n  getPlayoutDelay() {\r\n    if (this.receiver) {\r\n      if ('playoutDelayHint' in this.receiver) {\r\n        return this.receiver.playoutDelayHint;\r\n      } else {\r\n        this.log.warn('Playout delay not supported in this browser');\r\n      }\r\n    } else {\r\n      this.log.warn('Cannot get playout delay, track already ended');\r\n    }\r\n    return 0;\r\n  }\r\n  /* @internal */\r\n  startMonitor() {\r\n    if (!this.monitorInterval) {\r\n      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);\r\n    }\r\n    if (supportsSynchronizationSources()) {\r\n      this.registerTimeSyncUpdate();\r\n    }\r\n  }\r\n  registerTimeSyncUpdate() {\r\n    const loop = () => {\r\n      var _a;\r\n      this.timeSyncHandle = requestAnimationFrame(() => loop());\r\n      const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\r\n      if (sources) {\r\n        const {\r\n          timestamp,\r\n          rtpTimestamp\r\n        } = sources;\r\n        if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\r\n          this.emit(TrackEvent.TimeSyncUpdate, {\r\n            timestamp,\r\n            rtpTimestamp\r\n          });\r\n          this.rtpTimestamp = rtpTimestamp;\r\n        }\r\n      }\r\n    };\r\n    loop();\r\n  }\r\n}\r\n\r\nclass RemoteAudioTrack extends RemoteTrack {\r\n  constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {\r\n    super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\r\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      const stats = yield this.getReceiverStats();\r\n      if (stats && this.prevStats && this.receiver) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.audioContext = audioContext;\r\n    this.webAudioPluginNodes = [];\r\n    if (audioOutput) {\r\n      this.sinkId = audioOutput.deviceId;\r\n    }\r\n  }\r\n  /**\r\n   * sets the volume for all attached audio elements\r\n   */\r\n  setVolume(volume) {\r\n    var _a;\r\n    for (const el of this.attachedElements) {\r\n      if (this.audioContext) {\r\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\r\n      } else {\r\n        el.volume = volume;\r\n      }\r\n    }\r\n    if (isReactNative()) {\r\n      // @ts-ignore\r\n      this._mediaStreamTrack._setVolume(volume);\r\n    }\r\n    this.elementVolume = volume;\r\n  }\r\n  /**\r\n   * gets the volume of attached audio elements (loudest)\r\n   */\r\n  getVolume() {\r\n    if (this.elementVolume) {\r\n      return this.elementVolume;\r\n    }\r\n    if (isReactNative()) {\r\n      // RN volume value defaults to 1.0 if hasn't been changed.\r\n      return 1.0;\r\n    }\r\n    let highestVolume = 0;\r\n    this.attachedElements.forEach(element => {\r\n      if (element.volume > highestVolume) {\r\n        highestVolume = element.volume;\r\n      }\r\n    });\r\n    return highestVolume;\r\n  }\r\n  /**\r\n   * calls setSinkId on all attached elements, if supported\r\n   * @param deviceId audio output device\r\n   */\r\n  setSinkId(deviceId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.sinkId = deviceId;\r\n      yield Promise.all(this.attachedElements.map(elm => {\r\n        if (!supportsSetSinkId(elm)) {\r\n          return;\r\n        }\r\n        /* @ts-ignore */\r\n        return elm.setSinkId(deviceId);\r\n      }));\r\n    });\r\n  }\r\n  attach(element) {\r\n    const needsNewWebAudioConnection = this.attachedElements.length === 0;\r\n    if (!element) {\r\n      element = super.attach();\r\n    } else {\r\n      super.attach(element);\r\n    }\r\n    if (this.sinkId && supportsSetSinkId(element)) {\r\n      element.setSinkId(this.sinkId).catch(e => {\r\n        this.log.error('Failed to set sink id on remote audio track', e, this.logContext);\r\n      });\r\n    }\r\n    if (this.audioContext && needsNewWebAudioConnection) {\r\n      this.log.debug('using audio context mapping', this.logContext);\r\n      this.connectWebAudio(this.audioContext, element);\r\n      element.volume = 0;\r\n      element.muted = true;\r\n    }\r\n    if (this.elementVolume) {\r\n      // make sure volume setting is being applied to the newly attached element\r\n      this.setVolume(this.elementVolume);\r\n    }\r\n    return element;\r\n  }\r\n  detach(element) {\r\n    let detached;\r\n    if (!element) {\r\n      detached = super.detach();\r\n      this.disconnectWebAudio();\r\n    } else {\r\n      detached = super.detach(element);\r\n      // if there are still any attached elements after detaching, connect webaudio to the first element that's left\r\n      // disconnect webaudio otherwise\r\n      if (this.audioContext) {\r\n        if (this.attachedElements.length > 0) {\r\n          this.connectWebAudio(this.audioContext, this.attachedElements[0]);\r\n        } else {\r\n          this.disconnectWebAudio();\r\n        }\r\n      }\r\n    }\r\n    return detached;\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   */\r\n  setAudioContext(audioContext) {\r\n    this.audioContext = audioContext;\r\n    if (audioContext && this.attachedElements.length > 0) {\r\n      this.connectWebAudio(audioContext, this.attachedElements[0]);\r\n    } else if (!audioContext) {\r\n      this.disconnectWebAudio();\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental\r\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\r\n   */\r\n  setWebAudioPlugins(nodes) {\r\n    this.webAudioPluginNodes = nodes;\r\n    if (this.attachedElements.length > 0 && this.audioContext) {\r\n      this.connectWebAudio(this.audioContext, this.attachedElements[0]);\r\n    }\r\n  }\r\n  connectWebAudio(context, element) {\r\n    this.disconnectWebAudio();\r\n    // @ts-ignore attached elements always have a srcObject set\r\n    this.sourceNode = context.createMediaStreamSource(element.srcObject);\r\n    let lastNode = this.sourceNode;\r\n    this.webAudioPluginNodes.forEach(node => {\r\n      lastNode.connect(node);\r\n      lastNode = node;\r\n    });\r\n    this.gainNode = context.createGain();\r\n    lastNode.connect(this.gainNode);\r\n    this.gainNode.connect(context.destination);\r\n    if (this.elementVolume) {\r\n      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\r\n    }\r\n    // try to resume the context if it isn't running already\r\n    if (context.state !== 'running') {\r\n      context.resume().then(() => {\r\n        if (context.state !== 'running') {\r\n          this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\r\n        }\r\n      }).catch(e => {\r\n        this.emit(TrackEvent.AudioPlaybackFailed, e);\r\n      });\r\n    }\r\n  }\r\n  disconnectWebAudio() {\r\n    var _a, _b;\r\n    (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\r\n    this.gainNode = undefined;\r\n    this.sourceNode = undefined;\r\n  }\r\n  getReceiverStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver || !this.receiver.getStats) {\r\n        return;\r\n      }\r\n      const stats = yield this.receiver.getStats();\r\n      let receiverStats;\r\n      stats.forEach(v => {\r\n        if (v.type === 'inbound-rtp') {\r\n          receiverStats = {\r\n            type: 'audio',\r\n            streamId: v.id,\r\n            timestamp: v.timestamp,\r\n            jitter: v.jitter,\r\n            bytesReceived: v.bytesReceived,\r\n            concealedSamples: v.concealedSamples,\r\n            concealmentEvents: v.concealmentEvents,\r\n            silentConcealedSamples: v.silentConcealedSamples,\r\n            silentConcealmentEvents: v.silentConcealmentEvents,\r\n            totalAudioEnergy: v.totalAudioEnergy,\r\n            totalSamplesDuration: v.totalSamplesDuration\r\n          };\r\n        }\r\n      });\r\n      return receiverStats;\r\n    });\r\n  }\r\n}\r\n\r\nconst REACTION_DELAY = 100;\r\nclass RemoteVideoTrack extends RemoteTrack {\r\n  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {\r\n    super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\r\n    this.elementInfos = [];\r\n    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver) {\r\n        this._currentBitrate = 0;\r\n        return;\r\n      }\r\n      const stats = yield this.getReceiverStats();\r\n      if (stats && this.prevStats && this.receiver) {\r\n        this._currentBitrate = computeBitrate(stats, this.prevStats);\r\n      }\r\n      this.prevStats = stats;\r\n    });\r\n    this.debouncedHandleResize = r(() => {\r\n      this.updateDimensions();\r\n    }, REACTION_DELAY);\r\n    this.adaptiveStreamSettings = adaptiveStreamSettings;\r\n  }\r\n  get isAdaptiveStream() {\r\n    return this.adaptiveStreamSettings !== undefined;\r\n  }\r\n  /**\r\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\r\n   */\r\n  get mediaStreamTrack() {\r\n    return this._mediaStreamTrack;\r\n  }\r\n  /** @internal */\r\n  setMuted(muted) {\r\n    super.setMuted(muted);\r\n    this.attachedElements.forEach(element => {\r\n      // detach or attach\r\n      if (muted) {\r\n        detachTrack(this._mediaStreamTrack, element);\r\n      } else {\r\n        attachToElement(this._mediaStreamTrack, element);\r\n      }\r\n    });\r\n  }\r\n  attach(element) {\r\n    if (!element) {\r\n      element = super.attach();\r\n    } else {\r\n      super.attach(element);\r\n    }\r\n    // It's possible attach is called multiple times on an element. When that's\r\n    // the case, we'd want to avoid adding duplicate elementInfos\r\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info.element === element) === undefined) {\r\n      const elementInfo = new HTMLElementInfo(element);\r\n      this.observeElementInfo(elementInfo);\r\n    }\r\n    return element;\r\n  }\r\n  /**\r\n   * Observe an ElementInfo for changes when adaptive streaming.\r\n   * @param elementInfo\r\n   * @internal\r\n   */\r\n  observeElementInfo(elementInfo) {\r\n    if (this.adaptiveStreamSettings && this.elementInfos.find(info => info === elementInfo) === undefined) {\r\n      elementInfo.handleResize = () => {\r\n        this.debouncedHandleResize();\r\n      };\r\n      elementInfo.handleVisibilityChanged = () => {\r\n        this.updateVisibility();\r\n      };\r\n      this.elementInfos.push(elementInfo);\r\n      elementInfo.observe();\r\n      // trigger the first resize update cycle\r\n      // if the tab is backgrounded, the initial resize event does not fire until\r\n      // the tab comes into focus for the first time.\r\n      this.debouncedHandleResize();\r\n      this.updateVisibility();\r\n    } else {\r\n      this.log.warn('visibility resize observer not triggered', this.logContext);\r\n    }\r\n  }\r\n  /**\r\n   * Stop observing an ElementInfo for changes.\r\n   * @param elementInfo\r\n   * @internal\r\n   */\r\n  stopObservingElementInfo(elementInfo) {\r\n    if (!this.isAdaptiveStream) {\r\n      this.log.warn('stopObservingElementInfo ignored', this.logContext);\r\n      return;\r\n    }\r\n    const stopElementInfos = this.elementInfos.filter(info => info === elementInfo);\r\n    for (const info of stopElementInfos) {\r\n      info.stopObserving();\r\n    }\r\n    this.elementInfos = this.elementInfos.filter(info => info !== elementInfo);\r\n    this.updateVisibility();\r\n    this.debouncedHandleResize();\r\n  }\r\n  detach(element) {\r\n    let detachedElements = [];\r\n    if (element) {\r\n      this.stopObservingElement(element);\r\n      return super.detach(element);\r\n    }\r\n    detachedElements = super.detach();\r\n    for (const e of detachedElements) {\r\n      this.stopObservingElement(e);\r\n    }\r\n    return detachedElements;\r\n  }\r\n  /** @internal */\r\n  getDecoderImplementation() {\r\n    var _a;\r\n    return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\r\n  }\r\n  getReceiverStats() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (!this.receiver || !this.receiver.getStats) {\r\n        return;\r\n      }\r\n      const stats = yield this.receiver.getStats();\r\n      let receiverStats;\r\n      let codecID = '';\r\n      let codecs = new Map();\r\n      stats.forEach(v => {\r\n        if (v.type === 'inbound-rtp') {\r\n          codecID = v.codecId;\r\n          receiverStats = {\r\n            type: 'video',\r\n            streamId: v.id,\r\n            framesDecoded: v.framesDecoded,\r\n            framesDropped: v.framesDropped,\r\n            framesReceived: v.framesReceived,\r\n            packetsReceived: v.packetsReceived,\r\n            packetsLost: v.packetsLost,\r\n            frameWidth: v.frameWidth,\r\n            frameHeight: v.frameHeight,\r\n            pliCount: v.pliCount,\r\n            firCount: v.firCount,\r\n            nackCount: v.nackCount,\r\n            jitter: v.jitter,\r\n            timestamp: v.timestamp,\r\n            bytesReceived: v.bytesReceived,\r\n            decoderImplementation: v.decoderImplementation\r\n          };\r\n        } else if (v.type === 'codec') {\r\n          codecs.set(v.id, v);\r\n        }\r\n      });\r\n      if (receiverStats && codecID !== '' && codecs.get(codecID)) {\r\n        receiverStats.mimeType = codecs.get(codecID).mimeType;\r\n      }\r\n      return receiverStats;\r\n    });\r\n  }\r\n  stopObservingElement(element) {\r\n    const stopElementInfos = this.elementInfos.filter(info => info.element === element);\r\n    for (const info of stopElementInfos) {\r\n      this.stopObservingElementInfo(info);\r\n    }\r\n  }\r\n  handleAppVisibilityChanged() {\r\n    const _super = Object.create(null, {\r\n      handleAppVisibilityChanged: {\r\n        get: () => super.handleAppVisibilityChanged\r\n      }\r\n    });\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield _super.handleAppVisibilityChanged.call(this);\r\n      if (!this.isAdaptiveStream) return;\r\n      this.updateVisibility();\r\n    });\r\n  }\r\n  updateVisibility() {\r\n    var _a, _b;\r\n    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);\r\n    const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\r\n    ) ? this.isInBackground : false;\r\n    const isPiPMode = this.elementInfos.some(info => info.pictureInPicture);\r\n    const isVisible = this.elementInfos.some(info => info.visible) && !backgroundPause || isPiPMode;\r\n    if (this.lastVisible === isVisible) {\r\n      return;\r\n    }\r\n    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\r\n      // delay hidden events\r\n      CriticalTimers.setTimeout(() => {\r\n        this.updateVisibility();\r\n      }, REACTION_DELAY);\r\n      return;\r\n    }\r\n    this.lastVisible = isVisible;\r\n    this.emit(TrackEvent.VisibilityChanged, isVisible, this);\r\n  }\r\n  updateDimensions() {\r\n    var _a, _b;\r\n    let maxWidth = 0;\r\n    let maxHeight = 0;\r\n    const pixelDensity = this.getPixelDensity();\r\n    for (const info of this.elementInfos) {\r\n      const currentElementWidth = info.width() * pixelDensity;\r\n      const currentElementHeight = info.height() * pixelDensity;\r\n      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\r\n        maxWidth = currentElementWidth;\r\n        maxHeight = currentElementHeight;\r\n      }\r\n    }\r\n    if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\r\n      return;\r\n    }\r\n    this.lastDimensions = {\r\n      width: maxWidth,\r\n      height: maxHeight\r\n    };\r\n    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\r\n  }\r\n  getPixelDensity() {\r\n    var _a;\r\n    const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\r\n    if (pixelDensity === 'screen') {\r\n      return getDevicePixelRatio();\r\n    } else if (!pixelDensity) {\r\n      // when unset, we'll pick a sane default here.\r\n      // for higher pixel density devices (mobile phones, etc), we'll use 2\r\n      // otherwise it defaults to 1\r\n      const devicePixelRatio = getDevicePixelRatio();\r\n      if (devicePixelRatio > 2) {\r\n        return 2;\r\n      } else {\r\n        return 1;\r\n      }\r\n    }\r\n    return pixelDensity;\r\n  }\r\n}\r\nclass HTMLElementInfo {\r\n  get visible() {\r\n    return this.isPiP || this.isIntersecting;\r\n  }\r\n  get pictureInPicture() {\r\n    return this.isPiP;\r\n  }\r\n  constructor(element, visible) {\r\n    this.onVisibilityChanged = entry => {\r\n      var _a;\r\n      const {\r\n        target,\r\n        isIntersecting\r\n      } = entry;\r\n      if (target === this.element) {\r\n        this.isIntersecting = isIntersecting;\r\n        this.isPiP = isElementInPiP(this.element);\r\n        this.visibilityChangedAt = Date.now();\r\n        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\r\n      }\r\n    };\r\n    this.onEnterPiP = () => {\r\n      var _a, _b, _c;\r\n      (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener('pagehide', this.onLeavePiP);\r\n      this.isPiP = isElementInPiP(this.element);\r\n      (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\r\n    };\r\n    this.onLeavePiP = () => {\r\n      var _a;\r\n      this.isPiP = isElementInPiP(this.element);\r\n      (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    };\r\n    this.element = element;\r\n    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\r\n    this.isPiP = isWeb() && isElementInPiP(element);\r\n    this.visibilityChangedAt = 0;\r\n  }\r\n  width() {\r\n    return this.element.clientWidth;\r\n  }\r\n  height() {\r\n    return this.element.clientHeight;\r\n  }\r\n  observe() {\r\n    var _a, _b, _c;\r\n    // make sure we update the current visible state once we start to observe\r\n    this.isIntersecting = isElementInViewport(this.element);\r\n    this.isPiP = isElementInPiP(this.element);\r\n    this.element.handleResize = () => {\r\n      var _a;\r\n      (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    };\r\n    this.element.handleVisibilityChanged = this.onVisibilityChanged;\r\n    getIntersectionObserver().observe(this.element);\r\n    getResizeObserver().observe(this.element);\r\n    this.element.addEventListener('enterpictureinpicture', this.onEnterPiP);\r\n    this.element.addEventListener('leavepictureinpicture', this.onLeavePiP);\r\n    (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener('enter', this.onEnterPiP);\r\n    (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener('pagehide', this.onLeavePiP);\r\n  }\r\n  stopObserving() {\r\n    var _a, _b, _c, _d, _e;\r\n    (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\r\n    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\r\n    this.element.removeEventListener('enterpictureinpicture', this.onEnterPiP);\r\n    this.element.removeEventListener('leavepictureinpicture', this.onLeavePiP);\r\n    (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener('enter', this.onEnterPiP);\r\n    (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener('pagehide', this.onLeavePiP);\r\n  }\r\n}\r\nfunction isElementInPiP(el) {\r\n  var _a, _b;\r\n  // Simple video PiP\r\n  if (document.pictureInPictureElement === el) return true;\r\n  // Document PiP\r\n  if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\r\n  return false;\r\n}\r\n// does not account for occlusion by other elements or opacity property\r\nfunction isElementInViewport(el, win) {\r\n  const viewportWindow = win || window;\r\n  let top = el.offsetTop;\r\n  let left = el.offsetLeft;\r\n  const width = el.offsetWidth;\r\n  const height = el.offsetHeight;\r\n  const {\r\n    hidden\r\n  } = el;\r\n  const {\r\n    display\r\n  } = getComputedStyle(el);\r\n  while (el.offsetParent) {\r\n    el = el.offsetParent;\r\n    top += el.offsetTop;\r\n    left += el.offsetLeft;\r\n  }\r\n  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== 'none';\r\n}\r\n\r\nclass TrackPublication extends eventsExports.EventEmitter {\r\n  constructor(kind, id, name, loggerOptions) {\r\n    var _a;\r\n    super();\r\n    this.metadataMuted = false;\r\n    this.encryption = Encryption_Type.NONE;\r\n    this.log = livekitLogger;\r\n    this.handleMuted = () => {\r\n      this.emit(TrackEvent.Muted);\r\n    };\r\n    this.handleUnmuted = () => {\r\n      this.emit(TrackEvent.Unmuted);\r\n    };\r\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\r\n    this.loggerContextCb = this.loggerContextCb;\r\n    this.setMaxListeners(100);\r\n    this.kind = kind;\r\n    this.trackSid = id;\r\n    this.trackName = name;\r\n    this.source = Track.Source.Unknown;\r\n  }\r\n  /** @internal */\r\n  setTrack(track) {\r\n    if (this.track) {\r\n      this.track.off(TrackEvent.Muted, this.handleMuted);\r\n      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\r\n    }\r\n    this.track = track;\r\n    if (track) {\r\n      // forward events\r\n      track.on(TrackEvent.Muted, this.handleMuted);\r\n      track.on(TrackEvent.Unmuted, this.handleUnmuted);\r\n    }\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\r\n  }\r\n  get isMuted() {\r\n    return this.metadataMuted;\r\n  }\r\n  get isEnabled() {\r\n    return true;\r\n  }\r\n  get isSubscribed() {\r\n    return this.track !== undefined;\r\n  }\r\n  get isEncrypted() {\r\n    return this.encryption !== Encryption_Type.NONE;\r\n  }\r\n  /**\r\n   * an [AudioTrack] if this publication holds an audio track\r\n   */\r\n  get audioTrack() {\r\n    if (isAudioTrack(this.track)) {\r\n      return this.track;\r\n    }\r\n  }\r\n  /**\r\n   * an [VideoTrack] if this publication holds a video track\r\n   */\r\n  get videoTrack() {\r\n    if (isVideoTrack(this.track)) {\r\n      return this.track;\r\n    }\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    this.trackSid = info.sid;\r\n    this.trackName = info.name;\r\n    this.source = Track.sourceFromProto(info.source);\r\n    this.mimeType = info.mimeType;\r\n    if (this.kind === Track.Kind.Video && info.width > 0) {\r\n      this.dimensions = {\r\n        width: info.width,\r\n        height: info.height\r\n      };\r\n      this.simulcasted = info.simulcast;\r\n    }\r\n    this.encryption = info.encryption;\r\n    this.trackInfo = info;\r\n    this.log.debug('update publication info', Object.assign(Object.assign({}, this.logContext), {\r\n      info\r\n    }));\r\n  }\r\n}\r\n(function (TrackPublication) {\r\n  (function (SubscriptionStatus) {\r\n    SubscriptionStatus[\"Desired\"] = \"desired\";\r\n    SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\r\n    SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\r\n  })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\r\n  (function (PermissionStatus) {\r\n    PermissionStatus[\"Allowed\"] = \"allowed\";\r\n    PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\r\n  })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\r\n})(TrackPublication || (TrackPublication = {}));\r\n\r\nclass LocalTrackPublication extends TrackPublication {\r\n  get isUpstreamPaused() {\r\n    var _a;\r\n    return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\r\n  }\r\n  constructor(kind, ti, track, loggerOptions) {\r\n    super(kind, ti.sid, ti.name, loggerOptions);\r\n    this.track = undefined;\r\n    this.handleTrackEnded = () => {\r\n      this.emit(TrackEvent.Ended);\r\n    };\r\n    this.updateInfo(ti);\r\n    this.setTrack(track);\r\n  }\r\n  setTrack(track) {\r\n    if (this.track) {\r\n      this.track.off(TrackEvent.Ended, this.handleTrackEnded);\r\n    }\r\n    super.setTrack(track);\r\n    if (track) {\r\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\r\n    }\r\n  }\r\n  get isMuted() {\r\n    if (this.track) {\r\n      return this.track.isMuted;\r\n    }\r\n    return super.isMuted;\r\n  }\r\n  get audioTrack() {\r\n    return super.audioTrack;\r\n  }\r\n  get videoTrack() {\r\n    return super.videoTrack;\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /**\r\n   * Mute the track associated with this publication\r\n   */\r\n  mute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\r\n    });\r\n  }\r\n  /**\r\n   * Unmute track associated with this publication\r\n   */\r\n  unmute() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\r\n    });\r\n  }\r\n  /**\r\n   * Pauses the media stream track associated with this publication from being sent to the server\r\n   * and signals \"muted\" event to other participants\r\n   * Useful if you want to pause the stream without pausing the local media stream track\r\n   */\r\n  pauseUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\r\n    });\r\n  }\r\n  /**\r\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\r\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\r\n   */\r\n  resumeUpstream() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\r\n    });\r\n  }\r\n  getTrackFeatures() {\r\n    var _a;\r\n    if (isAudioTrack(this.track)) {\r\n      const settings = this.track.getSourceTrackSettings();\r\n      const features = new Set();\r\n      if (settings.autoGainControl) {\r\n        features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\r\n      }\r\n      if (settings.echoCancellation) {\r\n        features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\r\n      }\r\n      if (settings.noiseSuppression) {\r\n        features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\r\n      }\r\n      if (settings.channelCount && settings.channelCount > 1) {\r\n        features.add(AudioTrackFeature.TF_STEREO);\r\n      }\r\n      if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\r\n        features.add(AudioTrackFeature.TF_NO_DTX);\r\n      }\r\n      if (this.track.enhancedNoiseCancellation) {\r\n        features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\r\n      }\r\n      return Array.from(features.values());\r\n    } else return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a local video and audio track at the same time. When acquiring both\r\n * audio and video tracks together, it'll display a single permission prompt to\r\n * the user instead of two separate ones.\r\n * @param options\r\n */\r\nfunction createLocalTracks(options, loggerOptions) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    options !== null && options !== void 0 ? options : options = {};\r\n    let attemptExactMatch = false;\r\n    const {\r\n      audioProcessor,\r\n      videoProcessor,\r\n      optionsWithoutProcessor: internalOptions\r\n    } = extractProcessorsFromOptions(options);\r\n    let retryAudioOptions = internalOptions.audio;\r\n    let retryVideoOptions = internalOptions.video;\r\n    if (audioProcessor && typeof internalOptions.audio === 'object') {\r\n      internalOptions.audio.processor = audioProcessor;\r\n    }\r\n    if (videoProcessor && typeof internalOptions.video === 'object') {\r\n      internalOptions.video.processor = videoProcessor;\r\n    }\r\n    // if the user passes a device id as a string, we default to exact match\r\n    if (options.audio && typeof internalOptions.audio === 'object' && typeof internalOptions.audio.deviceId === 'string') {\r\n      const deviceId = internalOptions.audio.deviceId;\r\n      internalOptions.audio.deviceId = {\r\n        exact: deviceId\r\n      };\r\n      attemptExactMatch = true;\r\n      retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\r\n        deviceId: {\r\n          ideal: deviceId\r\n        }\r\n      });\r\n    }\r\n    if (internalOptions.video && typeof internalOptions.video === 'object' && typeof internalOptions.video.deviceId === 'string') {\r\n      const deviceId = internalOptions.video.deviceId;\r\n      internalOptions.video.deviceId = {\r\n        exact: deviceId\r\n      };\r\n      attemptExactMatch = true;\r\n      retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\r\n        deviceId: {\r\n          ideal: deviceId\r\n        }\r\n      });\r\n    }\r\n    if (internalOptions.audio === true || typeof internalOptions.audio === 'object' && !internalOptions.audio.deviceId) {\r\n      internalOptions.audio = {\r\n        deviceId: 'default'\r\n      };\r\n    }\r\n    if (internalOptions.video === true) {\r\n      internalOptions.video = {\r\n        deviceId: 'default'\r\n      };\r\n    } else if (typeof internalOptions.video === 'object' && !internalOptions.video.deviceId) {\r\n      internalOptions.video.deviceId = 'default';\r\n    }\r\n    const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\r\n    const constraints = constraintsForOptions(opts);\r\n    // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\r\n    // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\r\n    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\r\n    if (internalOptions.audio) {\r\n      DeviceManager.userMediaPromiseMap.set('audioinput', mediaPromise);\r\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('audioinput'));\r\n    }\r\n    if (internalOptions.video) {\r\n      DeviceManager.userMediaPromiseMap.set('videoinput', mediaPromise);\r\n      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete('videoinput'));\r\n    }\r\n    try {\r\n      const stream = yield mediaPromise;\r\n      return yield Promise.all(stream.getTracks().map(mediaStreamTrack => __awaiter(this, void 0, void 0, function* () {\r\n        const isAudio = mediaStreamTrack.kind === 'audio';\r\n        let trackOptions = isAudio ? opts.audio : opts.video;\r\n        if (typeof trackOptions === 'boolean' || !trackOptions) {\r\n          trackOptions = {};\r\n        }\r\n        let trackConstraints;\r\n        const conOrBool = isAudio ? constraints.audio : constraints.video;\r\n        if (typeof conOrBool !== 'boolean') {\r\n          trackConstraints = conOrBool;\r\n        }\r\n        // update the constraints with the device id the user gave permissions to in the permission prompt\r\n        // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\r\n        const newDeviceId = mediaStreamTrack.getSettings().deviceId;\r\n        if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\r\n          trackConstraints.deviceId = newDeviceId;\r\n        } else if (!trackConstraints) {\r\n          trackConstraints = {\r\n            deviceId: newDeviceId\r\n          };\r\n        }\r\n        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\r\n        if (track.kind === Track.Kind.Video) {\r\n          track.source = Track.Source.Camera;\r\n        } else if (track.kind === Track.Kind.Audio) {\r\n          track.source = Track.Source.Microphone;\r\n        }\r\n        track.mediaStream = stream;\r\n        if (isAudioTrack(track) && audioProcessor) {\r\n          yield track.setProcessor(audioProcessor);\r\n        } else if (isVideoTrack(track) && videoProcessor) {\r\n          yield track.setProcessor(videoProcessor);\r\n        }\r\n        return track;\r\n      })));\r\n    } catch (e) {\r\n      if (!attemptExactMatch) {\r\n        throw e;\r\n      }\r\n      return createLocalTracks(Object.assign(Object.assign({}, options), {\r\n        audio: retryAudioOptions,\r\n        video: retryVideoOptions\r\n      }), loggerOptions);\r\n    }\r\n  });\r\n}\r\n/**\r\n * Creates a [[LocalVideoTrack]] with getUserMedia()\r\n * @param options\r\n */\r\nfunction createLocalVideoTrack(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const tracks = yield createLocalTracks({\r\n      audio: false,\r\n      video: options !== null && options !== void 0 ? options : true\r\n    });\r\n    return tracks[0];\r\n  });\r\n}\r\nfunction createLocalAudioTrack(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    const tracks = yield createLocalTracks({\r\n      audio: options !== null && options !== void 0 ? options : true,\r\n      video: false\r\n    });\r\n    return tracks[0];\r\n  });\r\n}\r\n/**\r\n * Creates a screen capture tracks with getDisplayMedia().\r\n * A LocalVideoTrack is always created and returned.\r\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\r\n */\r\nfunction createLocalScreenTracks(options) {\r\n  return __awaiter(this, void 0, void 0, function* () {\r\n    if (options === undefined) {\r\n      options = {};\r\n    }\r\n    if (options.resolution === undefined && !isSafari17()) {\r\n      options.resolution = ScreenSharePresets.h1080fps30.resolution;\r\n    }\r\n    if (navigator.mediaDevices.getDisplayMedia === undefined) {\r\n      throw new DeviceUnsupportedError('getDisplayMedia not supported');\r\n    }\r\n    const constraints = screenCaptureToDisplayMediaStreamOptions(options);\r\n    const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\r\n    const tracks = stream.getVideoTracks();\r\n    if (tracks.length === 0) {\r\n      throw new TrackInvalidError('no video track found');\r\n    }\r\n    const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\r\n    screenVideo.source = Track.Source.ScreenShare;\r\n    const localTracks = [screenVideo];\r\n    if (stream.getAudioTracks().length > 0) {\r\n      const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\r\n      screenAudio.source = Track.Source.ScreenShareAudio;\r\n      localTracks.push(screenAudio);\r\n    }\r\n    return localTracks;\r\n  });\r\n}\r\n\r\nvar ConnectionQuality;\r\n(function (ConnectionQuality) {\r\n  ConnectionQuality[\"Excellent\"] = \"excellent\";\r\n  ConnectionQuality[\"Good\"] = \"good\";\r\n  ConnectionQuality[\"Poor\"] = \"poor\";\r\n  /**\r\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\r\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\r\n   */\r\n  ConnectionQuality[\"Lost\"] = \"lost\";\r\n  ConnectionQuality[\"Unknown\"] = \"unknown\";\r\n})(ConnectionQuality || (ConnectionQuality = {}));\r\nfunction qualityFromProto(q) {\r\n  switch (q) {\r\n    case ConnectionQuality$1.EXCELLENT:\r\n      return ConnectionQuality.Excellent;\r\n    case ConnectionQuality$1.GOOD:\r\n      return ConnectionQuality.Good;\r\n    case ConnectionQuality$1.POOR:\r\n      return ConnectionQuality.Poor;\r\n    case ConnectionQuality$1.LOST:\r\n      return ConnectionQuality.Lost;\r\n    default:\r\n      return ConnectionQuality.Unknown;\r\n  }\r\n}\r\nclass Participant extends eventsExports.EventEmitter {\r\n  get logContext() {\r\n    var _a, _b;\r\n    return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\r\n  }\r\n  get isEncrypted() {\r\n    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every(tr => tr.isEncrypted);\r\n  }\r\n  get isAgent() {\r\n    var _a;\r\n    return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\r\n  }\r\n  get isActive() {\r\n    var _a;\r\n    return ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) === ParticipantInfo_State.ACTIVE;\r\n  }\r\n  get kind() {\r\n    return this._kind;\r\n  }\r\n  /** participant attributes, similar to metadata, but as a key/value map */\r\n  get attributes() {\r\n    return Object.freeze(Object.assign({}, this._attributes));\r\n  }\r\n  /** @internal */\r\n  constructor(sid, identity, name, metadata, attributes, loggerOptions) {\r\n    let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\r\n    var _a;\r\n    super();\r\n    /** audio level between 0-1.0, 1 being loudest, 0 being softest */\r\n    this.audioLevel = 0;\r\n    /** if participant is currently speaking */\r\n    this.isSpeaking = false;\r\n    this._connectionQuality = ConnectionQuality.Unknown;\r\n    this.log = livekitLogger;\r\n    this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\r\n    this.loggerOptions = loggerOptions;\r\n    this.setMaxListeners(100);\r\n    this.sid = sid;\r\n    this.identity = identity;\r\n    this.name = name;\r\n    this.metadata = metadata;\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.trackPublications = new Map();\r\n    this._kind = kind;\r\n    this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\r\n  }\r\n  getTrackPublications() {\r\n    return Array.from(this.trackPublications.values());\r\n  }\r\n  /**\r\n   * Finds the first track that matches the source filter, for example, getting\r\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\r\n   */\r\n  getTrackPublication(source) {\r\n    for (const [, pub] of this.trackPublications) {\r\n      if (pub.source === source) {\r\n        return pub;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Finds the first track that matches the track's name.\r\n   */\r\n  getTrackPublicationByName(name) {\r\n    for (const [, pub] of this.trackPublications) {\r\n      if (pub.trackName === name) {\r\n        return pub;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Waits until the participant is active and ready to receive data messages\r\n   * @returns a promise that resolves when the participant is active\r\n   */\r\n  waitUntilActive() {\r\n    if (this.isActive) {\r\n      return Promise.resolve();\r\n    }\r\n    if (this.activeFuture) {\r\n      return this.activeFuture.promise;\r\n    }\r\n    this.activeFuture = new Future();\r\n    this.once(ParticipantEvent.Active, () => {\r\n      var _a, _b;\r\n      (_b = (_a = this.activeFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n      this.activeFuture = undefined;\r\n    });\r\n    return this.activeFuture.promise;\r\n  }\r\n  get connectionQuality() {\r\n    return this._connectionQuality;\r\n  }\r\n  get isCameraEnabled() {\r\n    var _a;\r\n    const track = this.getTrackPublication(Track.Source.Camera);\r\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\r\n  }\r\n  get isMicrophoneEnabled() {\r\n    var _a;\r\n    const track = this.getTrackPublication(Track.Source.Microphone);\r\n    return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\r\n  }\r\n  get isScreenShareEnabled() {\r\n    const track = this.getTrackPublication(Track.Source.ScreenShare);\r\n    return !!track;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /** when participant joined the room */\r\n  get joinedAt() {\r\n    if (this.participantInfo) {\r\n      return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\r\n    }\r\n    return new Date();\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    var _a;\r\n    // it's possible the update could be applied out of order due to await\r\n    // during reconnect sequences. when that happens, it's possible for server\r\n    // to have sent more recent version of participant info while JS is waiting\r\n    // to process the existing payload.\r\n    // when the participant sid remains the same, and we already have a later version\r\n    // of the payload, they can be safely skipped\r\n    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\r\n      return false;\r\n    }\r\n    this.identity = info.identity;\r\n    this.sid = info.sid;\r\n    this._setName(info.name);\r\n    this._setMetadata(info.metadata);\r\n    this._setAttributes(info.attributes);\r\n    if (info.state === ParticipantInfo_State.ACTIVE && ((_a = this.participantInfo) === null || _a === void 0 ? void 0 : _a.state) !== ParticipantInfo_State.ACTIVE) {\r\n      this.emit(ParticipantEvent.Active);\r\n    }\r\n    if (info.permission) {\r\n      this.setPermissions(info.permission);\r\n    }\r\n    // set this last so setMetadata can detect changes\r\n    this.participantInfo = info;\r\n    return true;\r\n  }\r\n  /**\r\n   * Updates metadata from server\r\n   **/\r\n  _setMetadata(md) {\r\n    const changed = this.metadata !== md;\r\n    const prevMetadata = this.metadata;\r\n    this.metadata = md;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\r\n    }\r\n  }\r\n  _setName(name) {\r\n    const changed = this.name !== name;\r\n    this.name = name;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantNameChanged, name);\r\n    }\r\n  }\r\n  /**\r\n   * Updates metadata from server\r\n   **/\r\n  _setAttributes(attributes) {\r\n    const diff = diffAttributes(this.attributes, attributes);\r\n    this._attributes = attributes;\r\n    if (Object.keys(diff).length > 0) {\r\n      this.emit(ParticipantEvent.AttributesChanged, diff);\r\n    }\r\n  }\r\n  /** @internal */\r\n  setPermissions(permissions) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const prevPermissions = this.permissions;\r\n    const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {\r\n      var _a;\r\n      return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\r\n    }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\r\n    this.permissions = permissions;\r\n    if (changed) {\r\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\r\n    }\r\n    return changed;\r\n  }\r\n  /** @internal */\r\n  setIsSpeaking(speaking) {\r\n    if (speaking === this.isSpeaking) {\r\n      return;\r\n    }\r\n    this.isSpeaking = speaking;\r\n    if (speaking) {\r\n      this.lastSpokeAt = new Date();\r\n    }\r\n    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\r\n  }\r\n  /** @internal */\r\n  setConnectionQuality(q) {\r\n    const prevQuality = this._connectionQuality;\r\n    this._connectionQuality = qualityFromProto(q);\r\n    if (prevQuality !== this._connectionQuality) {\r\n      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setDisconnected() {\r\n    var _a, _b;\r\n    if (this.activeFuture) {\r\n      (_b = (_a = this.activeFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a, new Error('Participant disconnected'));\r\n      this.activeFuture = undefined;\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setAudioContext(ctx) {\r\n    this.audioContext = ctx;\r\n    this.audioTrackPublications.forEach(track => isAudioTrack(track.track) && track.track.setAudioContext(ctx));\r\n  }\r\n  addTrackPublication(publication) {\r\n    // forward publication driven events\r\n    publication.on(TrackEvent.Muted, () => {\r\n      this.emit(ParticipantEvent.TrackMuted, publication);\r\n    });\r\n    publication.on(TrackEvent.Unmuted, () => {\r\n      this.emit(ParticipantEvent.TrackUnmuted, publication);\r\n    });\r\n    const pub = publication;\r\n    if (pub.track) {\r\n      pub.track.sid = publication.trackSid;\r\n    }\r\n    this.trackPublications.set(publication.trackSid, publication);\r\n    switch (publication.kind) {\r\n      case Track.Kind.Audio:\r\n        this.audioTrackPublications.set(publication.trackSid, publication);\r\n        break;\r\n      case Track.Kind.Video:\r\n        this.videoTrackPublications.set(publication.trackSid, publication);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nfunction trackPermissionToProto(perms) {\r\n  var _a, _b, _c;\r\n  if (!perms.participantSid && !perms.participantIdentity) {\r\n    throw new Error('Invalid track permission, must provide at least one of participantIdentity and participantSid');\r\n  }\r\n  return new TrackPermission({\r\n    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : '',\r\n    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : '',\r\n    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\r\n    trackSids: perms.allowedTrackSids || []\r\n  });\r\n}\r\n\r\nconst STREAM_CHUNK_SIZE = 15000;\r\nclass LocalParticipant extends Participant {\r\n  /** @internal */\r\n  constructor(sid, identity, engine, options, roomRpcHandlers) {\r\n    super(sid, identity, undefined, undefined, undefined, {\r\n      loggerName: options.loggerName,\r\n      loggerContextCb: () => this.engine.logContext\r\n    });\r\n    this.pendingPublishing = new Set();\r\n    this.pendingPublishPromises = new Map();\r\n    this.participantTrackPermissions = [];\r\n    this.allParticipantsAllowedToSubscribe = true;\r\n    this.encryptionType = Encryption_Type.NONE;\r\n    this.enabledPublishVideoCodecs = [];\r\n    this.pendingAcks = new Map();\r\n    this.pendingResponses = new Map();\r\n    this.handleReconnecting = () => {\r\n      if (!this.reconnectFuture) {\r\n        this.reconnectFuture = new Future();\r\n      }\r\n    };\r\n    this.handleReconnected = () => {\r\n      var _a, _b;\r\n      (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n      this.reconnectFuture = undefined;\r\n      this.updateTrackSubscriptionPermissions();\r\n    };\r\n    this.handleDisconnected = () => {\r\n      var _a, _b, _c, _d, _e, _f;\r\n      if (this.reconnectFuture) {\r\n        this.reconnectFuture.promise.catch(e => this.log.warn(e.message, this.logContext));\r\n        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, 'Got disconnected during reconnection attempt');\r\n        this.reconnectFuture = undefined;\r\n      }\r\n      if (this.signalConnectedFuture) {\r\n        (_d = (_c = this.signalConnectedFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c, 'Got disconnected without signal connected');\r\n        this.signalConnectedFuture = undefined;\r\n      }\r\n      (_f = (_e = this.activeAgentFuture) === null || _e === void 0 ? void 0 : _e.reject) === null || _f === void 0 ? void 0 : _f.call(_e, 'Got disconnected without active agent present');\r\n      this.activeAgentFuture = undefined;\r\n      this.firstActiveAgent = undefined;\r\n    };\r\n    this.handleSignalConnected = joinResponse => {\r\n      var _a, _b;\r\n      if (joinResponse.participant) {\r\n        this.updateInfo(joinResponse.participant);\r\n      }\r\n      if (!this.signalConnectedFuture) {\r\n        this.signalConnectedFuture = new Future();\r\n      }\r\n      (_b = (_a = this.signalConnectedFuture).resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    };\r\n    this.handleSignalRequestResponse = response => {\r\n      const {\r\n        requestId,\r\n        reason,\r\n        message\r\n      } = response;\r\n      const targetRequest = this.pendingSignalRequests.get(requestId);\r\n      if (targetRequest) {\r\n        if (reason !== RequestResponse_Reason.OK) {\r\n          targetRequest.reject(new SignalRequestError(message, reason));\r\n        }\r\n        this.pendingSignalRequests.delete(requestId);\r\n      }\r\n    };\r\n    this.handleDataPacket = packet => {\r\n      switch (packet.value.case) {\r\n        case 'rpcResponse':\r\n          let rpcResponse = packet.value.value;\r\n          let payload = null;\r\n          let error = null;\r\n          if (rpcResponse.value.case === 'payload') {\r\n            payload = rpcResponse.value.value;\r\n          } else if (rpcResponse.value.case === 'error') {\r\n            error = RpcError.fromProto(rpcResponse.value.value);\r\n          }\r\n          this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\r\n          break;\r\n        case 'rpcAck':\r\n          let rpcAck = packet.value.value;\r\n          this.handleIncomingRpcAck(rpcAck.requestId);\r\n          break;\r\n      }\r\n    };\r\n    this.updateTrackSubscriptionPermissions = () => {\r\n      this.log.debug('updating track subscription permissions', Object.assign(Object.assign({}, this.logContext), {\r\n        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\r\n        participantTrackPermissions: this.participantTrackPermissions\r\n      }));\r\n      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map(p => trackPermissionToProto(p)));\r\n    };\r\n    /** @internal */\r\n    this.onTrackUnmuted = track => {\r\n      this.onTrackMuted(track, track.isUpstreamPaused);\r\n    };\r\n    // when the local track changes in mute status, we'll notify server as such\r\n    /** @internal */\r\n    this.onTrackMuted = (track, muted) => {\r\n      if (muted === undefined) {\r\n        muted = true;\r\n      }\r\n      if (!track.sid) {\r\n        this.log.error('could not update mute status for unpublished track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        return;\r\n      }\r\n      this.engine.updateMuteStatus(track.sid, muted);\r\n    };\r\n    this.onTrackUpstreamPaused = track => {\r\n      this.log.debug('upstream paused', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      this.onTrackMuted(track, true);\r\n    };\r\n    this.onTrackUpstreamResumed = track => {\r\n      this.log.debug('upstream resumed', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      this.onTrackMuted(track, track.isMuted);\r\n    };\r\n    this.onTrackFeatureUpdate = track => {\r\n      const pub = this.audioTrackPublications.get(track.sid);\r\n      if (!pub) {\r\n        this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\r\n        return;\r\n      }\r\n      this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\r\n    };\r\n    this.handleSubscribedQualityUpdate = update => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, e_1, _b, _c;\r\n      var _d;\r\n      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\r\n        return;\r\n      }\r\n      const pub = this.videoTrackPublications.get(update.trackSid);\r\n      if (!pub) {\r\n        this.log.warn('received subscribed quality update for unknown track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: update.trackSid\r\n        }));\r\n        return;\r\n      }\r\n      if (!pub.videoTrack) {\r\n        return;\r\n      }\r\n      const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\r\n      try {\r\n        for (var _e = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _e = true) {\r\n          _c = newCodecs_1_1.value;\r\n          _e = false;\r\n          const codec = _c;\r\n          if (isBackupCodec(codec)) {\r\n            this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\r\n            yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\r\n          }\r\n        }\r\n      } catch (e_1_1) {\r\n        e_1 = {\r\n          error: e_1_1\r\n        };\r\n      } finally {\r\n        try {\r\n          if (!_e && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\r\n        } finally {\r\n          if (e_1) throw e_1.error;\r\n        }\r\n      }\r\n    });\r\n    this.handleLocalTrackUnpublished = unpublished => {\r\n      const track = this.trackPublications.get(unpublished.trackSid);\r\n      if (!track) {\r\n        this.log.warn('received unpublished event for unknown track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: unpublished.trackSid\r\n        }));\r\n        return;\r\n      }\r\n      this.unpublishTrack(track.track);\r\n    };\r\n    this.handleTrackEnded = track => __awaiter(this, void 0, void 0, function* () {\r\n      if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\r\n        this.log.debug('unpublishing local track due to TrackEnded', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        this.unpublishTrack(track);\r\n      } else if (track.isUserProvided) {\r\n        yield track.mute();\r\n      } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\r\n        try {\r\n          if (isWeb()) {\r\n            try {\r\n              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\r\n                // the permission query for camera and microphone currently not supported in Safari and Firefox\r\n                // @ts-ignore\r\n                name: track.source === Track.Source.Camera ? 'camera' : 'microphone'\r\n              });\r\n              if (currentPermissions && currentPermissions.state === 'denied') {\r\n                this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n                // detect granted change after permissions were denied to try and resume then\r\n                currentPermissions.onchange = () => {\r\n                  if (currentPermissions.state !== 'denied') {\r\n                    if (!track.isMuted) {\r\n                      track.restartTrack();\r\n                    }\r\n                    currentPermissions.onchange = null;\r\n                  }\r\n                };\r\n                throw new Error('GetUserMedia Permission denied');\r\n              }\r\n            } catch (e) {\r\n              // permissions query fails for firefox, we continue and try to restart the track\r\n            }\r\n          }\r\n          if (!track.isMuted) {\r\n            this.log.debug('track ended, attempting to use a different device', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n            if (isLocalAudioTrack(track)) {\r\n              // fall back to default device if available\r\n              yield track.restartTrack({\r\n                deviceId: 'default'\r\n              });\r\n            } else {\r\n              yield track.restartTrack();\r\n            }\r\n          }\r\n        } catch (e) {\r\n          this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          yield track.mute();\r\n        }\r\n      }\r\n    });\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.trackPublications = new Map();\r\n    this.engine = engine;\r\n    this.roomOptions = options;\r\n    this.setupEngine(engine);\r\n    this.activeDeviceMap = new Map([['audioinput', 'default'], ['videoinput', 'default'], ['audiooutput', 'default']]);\r\n    this.pendingSignalRequests = new Map();\r\n    this.rpcHandlers = roomRpcHandlers;\r\n  }\r\n  get lastCameraError() {\r\n    return this.cameraError;\r\n  }\r\n  get lastMicrophoneError() {\r\n    return this.microphoneError;\r\n  }\r\n  get isE2EEEnabled() {\r\n    return this.encryptionType !== Encryption_Type.NONE;\r\n  }\r\n  getTrackPublication(source) {\r\n    const track = super.getTrackPublication(source);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  getTrackPublicationByName(name) {\r\n    const track = super.getTrackPublicationByName(name);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setupEngine(engine) {\r\n    this.engine = engine;\r\n    this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {\r\n      const pub = this.trackPublications.get(trackSid);\r\n      if (!pub || !pub.track) {\r\n        return;\r\n      }\r\n      if (muted) {\r\n        pub.mute();\r\n      } else {\r\n        pub.unmute();\r\n      }\r\n    });\r\n    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalConnected, this.handleSignalConnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\r\n    this.signalConnectedFuture = undefined;\r\n  }\r\n  /**\r\n   * Sets and updates the metadata of the local participant.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * method will throw if the user doesn't have the required permissions\r\n   * @param metadata\r\n   */\r\n  setMetadata(metadata) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        metadata\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Sets and updates the name of the local participant.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * method will throw if the user doesn't have the required permissions\r\n   * @param metadata\r\n   */\r\n  setName(name) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        name\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Set or update participant attributes. It will make updates only to keys that\r\n   * are present in `attributes`, and will not override others.\r\n   * Note: this requires `canUpdateOwnMetadata` permission.\r\n   * @param attributes attributes to update\r\n   */\r\n  setAttributes(attributes) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.requestMetadataUpdate({\r\n        attributes\r\n      });\r\n    });\r\n  }\r\n  requestMetadataUpdate(_a) {\r\n    return __awaiter(this, arguments, void 0, function (_ref) {\r\n      var _this = this;\r\n      let {\r\n        metadata,\r\n        name,\r\n        attributes\r\n      } = _ref;\r\n      return function* () {\r\n        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {\r\n          var _a, _b;\r\n          try {\r\n            let isRejected = false;\r\n            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : '', (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : '', attributes);\r\n            const startTime = performance.now();\r\n            this.pendingSignalRequests.set(requestId, {\r\n              resolve,\r\n              reject: error => {\r\n                reject(error);\r\n                isRejected = true;\r\n              },\r\n              values: {\r\n                name,\r\n                metadata,\r\n                attributes\r\n              }\r\n            });\r\n            while (performance.now() - startTime < 5000 && !isRejected) {\r\n              if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every(_ref2 => {\r\n                let [key, value] = _ref2;\r\n                return this.attributes[key] === value || value === '' && !this.attributes[key];\r\n              }))) {\r\n                this.pendingSignalRequests.delete(requestId);\r\n                resolve();\r\n                return;\r\n              }\r\n              yield sleep(50);\r\n            }\r\n            reject(new SignalRequestError('Request to update local metadata timed out', 'TimeoutError'));\r\n          } catch (e) {\r\n            if (e instanceof Error) reject(e);\r\n          }\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Enable or disable a participant's camera track.\r\n   *\r\n   * If a track has already published, it'll mute or unmute the track.\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setCameraEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\r\n  }\r\n  /**\r\n   * Enable or disable a participant's microphone track.\r\n   *\r\n   * If a track has already published, it'll mute or unmute the track.\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setMicrophoneEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\r\n  }\r\n  /**\r\n   * Start or stop sharing a participant's screen\r\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\r\n   */\r\n  setScreenShareEnabled(enabled, options, publishOptions) {\r\n    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\r\n  }\r\n  /** @internal */\r\n  setPermissions(permissions) {\r\n    const prevPermissions = this.permissions;\r\n    const changed = super.setPermissions(permissions);\r\n    if (changed && prevPermissions) {\r\n      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\r\n    }\r\n    return changed;\r\n  }\r\n  /** @internal */\r\n  setE2EEEnabled(enabled) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\r\n      yield this.republishAllTracks(undefined, false);\r\n    });\r\n  }\r\n  setTrackEnabled(source, enabled, options, publishOptions) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      this.log.debug('setTrackEnabled', Object.assign(Object.assign({}, this.logContext), {\r\n        source,\r\n        enabled\r\n      }));\r\n      if (this.republishPromise) {\r\n        yield this.republishPromise;\r\n      }\r\n      let track = this.getTrackPublication(source);\r\n      if (enabled) {\r\n        if (track) {\r\n          yield track.unmute();\r\n        } else {\r\n          let localTracks;\r\n          if (this.pendingPublishing.has(source)) {\r\n            const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\r\n            if (!pendingTrack) {\r\n              this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\r\n                source\r\n              }));\r\n            }\r\n            yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\r\n            return pendingTrack;\r\n          }\r\n          this.pendingPublishing.add(source);\r\n          try {\r\n            switch (source) {\r\n              case Track.Source.Camera:\r\n                localTracks = yield this.createTracks({\r\n                  video: (_a = options) !== null && _a !== void 0 ? _a : true\r\n                });\r\n                break;\r\n              case Track.Source.Microphone:\r\n                localTracks = yield this.createTracks({\r\n                  audio: (_b = options) !== null && _b !== void 0 ? _b : true\r\n                });\r\n                break;\r\n              case Track.Source.ScreenShare:\r\n                localTracks = yield this.createScreenTracks(Object.assign({}, options));\r\n                break;\r\n              default:\r\n                throw new TrackInvalidError(source);\r\n            }\r\n          } catch (e) {\r\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\r\n              tr.stop();\r\n            });\r\n            if (e instanceof Error) {\r\n              this.emit(ParticipantEvent.MediaDevicesError, e, sourceToKind(source));\r\n            }\r\n            this.pendingPublishing.delete(source);\r\n            throw e;\r\n          }\r\n          for (const localTrack of localTracks) {\r\n            if (source === Track.Source.Microphone && isAudioTrack(localTrack) && (publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.preConnectBuffer)) {\r\n              this.log.info('starting preconnect buffer for microphone', Object.assign({}, this.logContext));\r\n              localTrack.startPreConnectBuffer();\r\n            }\r\n          }\r\n          try {\r\n            const publishPromises = [];\r\n            for (const localTrack of localTracks) {\r\n              this.log.info('publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\r\n              publishPromises.push(this.publishTrack(localTrack, publishOptions));\r\n            }\r\n            const publishedTracks = yield Promise.all(publishPromises);\r\n            // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\r\n            // revisit if we want to return an array of tracks instead for v2\r\n            [track] = publishedTracks;\r\n          } catch (e) {\r\n            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(tr => {\r\n              tr.stop();\r\n            });\r\n            throw e;\r\n          } finally {\r\n            this.pendingPublishing.delete(source);\r\n          }\r\n        }\r\n      } else {\r\n        if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\r\n          // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\r\n          track = yield this.waitForPendingPublicationOfSource(source);\r\n          if (!track) {\r\n            this.log.info('waiting for pending publication promise timed out', Object.assign(Object.assign({}, this.logContext), {\r\n              source\r\n            }));\r\n          }\r\n        }\r\n        if (track && track.track) {\r\n          // screenshare cannot be muted, unpublish instead\r\n          if (source === Track.Source.ScreenShare) {\r\n            track = yield this.unpublishTrack(track.track);\r\n            const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\r\n            if (screenAudioTrack && screenAudioTrack.track) {\r\n              this.unpublishTrack(screenAudioTrack.track);\r\n            }\r\n          } else {\r\n            yield track.mute();\r\n          }\r\n        }\r\n      }\r\n      return track;\r\n    });\r\n  }\r\n  /**\r\n   * Publish both camera and microphone at the same time. This is useful for\r\n   * displaying a single Permission Dialog box to the end user.\r\n   */\r\n  enableCameraAndMicrophone() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\r\n        // no-op it's already been requested\r\n        return;\r\n      }\r\n      this.pendingPublishing.add(Track.Source.Camera);\r\n      this.pendingPublishing.add(Track.Source.Microphone);\r\n      try {\r\n        const tracks = yield this.createTracks({\r\n          audio: true,\r\n          video: true\r\n        });\r\n        yield Promise.all(tracks.map(track => this.publishTrack(track)));\r\n      } finally {\r\n        this.pendingPublishing.delete(Track.Source.Camera);\r\n        this.pendingPublishing.delete(Track.Source.Microphone);\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Create local camera and/or microphone tracks\r\n   * @param options\r\n   * @returns\r\n   */\r\n  createTracks(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      options !== null && options !== void 0 ? options : options = {};\r\n      const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\r\n      try {\r\n        const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\r\n          loggerName: this.roomOptions.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        const localTracks = tracks.map(track => {\r\n          if (isAudioTrack(track)) {\r\n            this.microphoneError = undefined;\r\n            track.setAudioContext(this.audioContext);\r\n            track.source = Track.Source.Microphone;\r\n            this.emit(ParticipantEvent.AudioStreamAcquired);\r\n          }\r\n          if (isVideoTrack(track)) {\r\n            this.cameraError = undefined;\r\n            track.source = Track.Source.Camera;\r\n          }\r\n          return track;\r\n        });\r\n        return localTracks;\r\n      } catch (err) {\r\n        if (err instanceof Error) {\r\n          if (options.audio) {\r\n            this.microphoneError = err;\r\n          }\r\n          if (options.video) {\r\n            this.cameraError = err;\r\n          }\r\n        }\r\n        throw err;\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Creates a screen capture tracks with getDisplayMedia().\r\n   * A LocalVideoTrack is always created and returned.\r\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\r\n   */\r\n  createScreenTracks(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (options === undefined) {\r\n        options = {};\r\n      }\r\n      if (navigator.mediaDevices.getDisplayMedia === undefined) {\r\n        throw new DeviceUnsupportedError('getDisplayMedia not supported');\r\n      }\r\n      if (options.resolution === undefined && !isSafari17()) {\r\n        // we need to constrain the dimensions, otherwise it could lead to low bitrate\r\n        // due to encoding a huge video. Encoding such large surfaces is really expensive\r\n        // unfortunately Safari 17 has a but and cannot be constrained by default\r\n        options.resolution = ScreenSharePresets.h1080fps30.resolution;\r\n      }\r\n      const constraints = screenCaptureToDisplayMediaStreamOptions(options);\r\n      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\r\n      const tracks = stream.getVideoTracks();\r\n      if (tracks.length === 0) {\r\n        throw new TrackInvalidError('no video track found');\r\n      }\r\n      const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\r\n        loggerName: this.roomOptions.loggerName,\r\n        loggerContextCb: () => this.logContext\r\n      });\r\n      screenVideo.source = Track.Source.ScreenShare;\r\n      if (options.contentHint) {\r\n        screenVideo.mediaStreamTrack.contentHint = options.contentHint;\r\n      }\r\n      const localTracks = [screenVideo];\r\n      if (stream.getAudioTracks().length > 0) {\r\n        this.emit(ParticipantEvent.AudioStreamAcquired);\r\n        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\r\n          loggerName: this.roomOptions.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        screenAudio.source = Track.Source.ScreenShareAudio;\r\n        localTracks.push(screenAudio);\r\n      }\r\n      return localTracks;\r\n    });\r\n  }\r\n  /**\r\n   * Publish a new track to the room\r\n   * @param track\r\n   * @param options\r\n   */\r\n  publishTrack(track, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.publishOrRepublishTrack(track, options);\r\n    });\r\n  }\r\n  publishOrRepublishTrack(track_1, options_1) {\r\n    return __awaiter(this, arguments, void 0, function (track, options) {\r\n      var _this2 = this;\r\n      let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      return function* () {\r\n        var _a, _b, _c, _d;\r\n        if (isLocalAudioTrack(track)) {\r\n          track.setAudioContext(_this2.audioContext);\r\n        }\r\n        yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\r\n        if (_this2.republishPromise && !isRepublish) {\r\n          yield _this2.republishPromise;\r\n        }\r\n        if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\r\n          yield _this2.pendingPublishPromises.get(track);\r\n        }\r\n        let defaultConstraints;\r\n        if (track instanceof MediaStreamTrack) {\r\n          defaultConstraints = track.getConstraints();\r\n        } else {\r\n          // we want to access constraints directly as `track.mediaStreamTrack`\r\n          // might be pointing to a non-device track (e.g. processed track) already\r\n          defaultConstraints = track.constraints;\r\n          let deviceKind = undefined;\r\n          switch (track.source) {\r\n            case Track.Source.Microphone:\r\n              deviceKind = 'audioinput';\r\n              break;\r\n            case Track.Source.Camera:\r\n              deviceKind = 'videoinput';\r\n          }\r\n          if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\r\n            defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\r\n              deviceId: _this2.activeDeviceMap.get(deviceKind)\r\n            });\r\n          }\r\n        }\r\n        // convert raw media track into audio or video track\r\n        if (track instanceof MediaStreamTrack) {\r\n          switch (track.kind) {\r\n            case 'audio':\r\n              track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\r\n                loggerName: _this2.roomOptions.loggerName,\r\n                loggerContextCb: () => _this2.logContext\r\n              });\r\n              break;\r\n            case 'video':\r\n              track = new LocalVideoTrack(track, defaultConstraints, true, {\r\n                loggerName: _this2.roomOptions.loggerName,\r\n                loggerContextCb: () => _this2.logContext\r\n              });\r\n              break;\r\n            default:\r\n              throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\r\n          }\r\n        } else {\r\n          track.updateLoggerOptions({\r\n            loggerName: _this2.roomOptions.loggerName,\r\n            loggerContextCb: () => _this2.logContext\r\n          });\r\n        }\r\n        // is it already published? if so skip\r\n        let existingPublication;\r\n        _this2.trackPublications.forEach(publication => {\r\n          if (!publication.track) {\r\n            return;\r\n          }\r\n          if (publication.track === track) {\r\n            existingPublication = publication;\r\n          }\r\n        });\r\n        if (existingPublication) {\r\n          _this2.log.warn('track has already been published, skipping', Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\r\n          return existingPublication;\r\n        }\r\n        const isStereoInput = 'channelCount' in track.mediaStreamTrack.getSettings() &&\r\n        // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\r\n        track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\r\n        const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\r\n        // disable dtx for stereo track if not enabled explicitly\r\n        if (isStereo) {\r\n          if (!options) {\r\n            options = {};\r\n          }\r\n          if (options.dtx === undefined) {\r\n            _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\r\n          }\r\n          if (options.red === undefined) {\r\n            _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\r\n          }\r\n          (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\r\n          (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\r\n        }\r\n        const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\r\n        if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\r\n          _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\r\n          opts.simulcast = false;\r\n        }\r\n        if (opts.source) {\r\n          track.source = opts.source;\r\n        }\r\n        const publishPromise = new Promise((resolve, reject) => __awaiter(_this2, void 0, void 0, function* () {\r\n          try {\r\n            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\r\n              this.log.debug('deferring track publication until signal is connected', Object.assign(Object.assign({}, this.logContext), {\r\n                track: getLogContextFromTrack(track)\r\n              }));\r\n              const timeout = setTimeout(() => {\r\n                reject(new PublishTrackError('publishing rejected as engine not connected within timeout', 408));\r\n              }, 15000);\r\n              yield this.waitUntilEngineConnected();\r\n              clearTimeout(timeout);\r\n              const publication = yield this.publish(track, opts, isStereo);\r\n              resolve(publication);\r\n            } else {\r\n              try {\r\n                const publication = yield this.publish(track, opts, isStereo);\r\n                resolve(publication);\r\n              } catch (e) {\r\n                reject(e);\r\n              }\r\n            }\r\n          } catch (e) {\r\n            reject(e);\r\n          }\r\n        }));\r\n        _this2.pendingPublishPromises.set(track, publishPromise);\r\n        try {\r\n          const publication = yield publishPromise;\r\n          return publication;\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          _this2.pendingPublishPromises.delete(track);\r\n        }\r\n      }();\r\n    });\r\n  }\r\n  waitUntilEngineConnected() {\r\n    if (!this.signalConnectedFuture) {\r\n      this.signalConnectedFuture = new Future();\r\n    }\r\n    return this.signalConnectedFuture.promise;\r\n  }\r\n  hasPermissionsToPublish(track) {\r\n    if (!this.permissions) {\r\n      this.log.warn('no permissions present for publishing track', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      return false;\r\n    }\r\n    const {\r\n      canPublish,\r\n      canPublishSources\r\n    } = this.permissions;\r\n    if (canPublish && (canPublishSources.length === 0 || canPublishSources.map(source => getTrackSourceFromProto(source)).includes(track.source))) {\r\n      return true;\r\n    }\r\n    this.log.warn('insufficient permissions to publish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n    return false;\r\n  }\r\n  publish(track, opts, isStereo) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n      if (!this.hasPermissionsToPublish(track)) {\r\n        throw new PublishTrackError('failed to publish track, insufficient permissions', 403);\r\n      }\r\n      const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => isLocalTrack(track) && publishedTrack.source === track.source);\r\n      if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\r\n        this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n      }\r\n      if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\r\n        track.stopOnMute = true;\r\n      }\r\n      if (track.source === Track.Source.ScreenShare && isFireFox()) {\r\n        // Firefox does not work well with simulcasted screen share\r\n        // we frequently get no data on layer 0 when enabled\r\n        opts.simulcast = false;\r\n      }\r\n      // require full AV1/VP9 SVC support prior to using it\r\n      if (opts.videoCodec === 'av1' && !supportsAV1()) {\r\n        opts.videoCodec = undefined;\r\n      }\r\n      if (opts.videoCodec === 'vp9' && !supportsVP9()) {\r\n        opts.videoCodec = undefined;\r\n      }\r\n      if (opts.videoCodec === undefined) {\r\n        opts.videoCodec = defaultVideoCodec;\r\n      }\r\n      if (this.enabledPublishVideoCodecs.length > 0) {\r\n        // fallback to a supported codec if it is not supported\r\n        if (!this.enabledPublishVideoCodecs.some(c => opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\r\n          opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\r\n        }\r\n      }\r\n      const videoCodec = opts.videoCodec;\r\n      // handle track actions\r\n      track.on(TrackEvent.Muted, this.onTrackMuted);\r\n      track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\r\n      track.on(TrackEvent.Ended, this.handleTrackEnded);\r\n      track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\r\n      track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\r\n      track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\r\n      const audioFeatures = [];\r\n      const disableDtx = !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true);\r\n      const settings = track.getSourceTrackSettings();\r\n      if (settings.autoGainControl) {\r\n        audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\r\n      }\r\n      if (settings.echoCancellation) {\r\n        audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);\r\n      }\r\n      if (settings.noiseSuppression) {\r\n        audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);\r\n      }\r\n      if (settings.channelCount && settings.channelCount > 1) {\r\n        audioFeatures.push(AudioTrackFeature.TF_STEREO);\r\n      }\r\n      if (disableDtx) {\r\n        audioFeatures.push(AudioTrackFeature.TF_NO_DTX);\r\n      }\r\n      if (isLocalAudioTrack(track) && track.hasPreConnectBuffer) {\r\n        audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);\r\n      }\r\n      // create track publication from track\r\n      const req = new AddTrackRequest({\r\n        // get local track id for use during publishing\r\n        cid: track.mediaStreamTrack.id,\r\n        name: opts.name,\r\n        type: Track.kindToProto(track.kind),\r\n        muted: track.isMuted,\r\n        source: Track.sourceToProto(track.source),\r\n        disableDtx,\r\n        encryption: this.encryptionType,\r\n        stereo: isStereo,\r\n        disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\r\n        stream: opts === null || opts === void 0 ? void 0 : opts.stream,\r\n        backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,\r\n        audioFeatures\r\n      });\r\n      // compute encodings and layers for video\r\n      let encodings;\r\n      if (track.kind === Track.Kind.Video) {\r\n        let dims = {\r\n          width: 0,\r\n          height: 0\r\n        };\r\n        try {\r\n          dims = yield track.waitForDimensions();\r\n        } catch (e) {\r\n          // use defaults, it's quite painful for congestion control without simulcast\r\n          // so using default dims according to publish settings\r\n          const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\r\n          dims = {\r\n            width: defaultRes.width,\r\n            height: defaultRes.height\r\n          };\r\n          // log failure\r\n          this.log.error('could not determine track dimensions, using defaults', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n            dims\r\n          }));\r\n        }\r\n        // width and height should be defined for video\r\n        req.width = dims.width;\r\n        req.height = dims.height;\r\n        // for svc codecs, disable simulcast and use vp8 for backup codec\r\n        if (isLocalVideoTrack(track)) {\r\n          if (isSVCCodec(videoCodec)) {\r\n            if (track.source === Track.Source.ScreenShare) {\r\n              // vp9 svc with screenshare cannot encode multiple spatial layers\r\n              // doing so reduces publish resolution to minimal resolution\r\n              opts.scalabilityMode = 'L1T3';\r\n              // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\r\n              // It has a different path for screenshare handling and it seems to be untested/buggy\r\n              // As a workaround, we are setting contentHint to force it to go through the same\r\n              // path as regular camera video. While this is not optimal, it delivers the performance\r\n              // that we need\r\n              if ('contentHint' in track.mediaStreamTrack) {\r\n                track.mediaStreamTrack.contentHint = 'motion';\r\n                this.log.info('forcing contentHint to motion for screenshare with SVC codecs', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              }\r\n            }\r\n            // set scalabilityMode to 'L3T3_KEY' by default\r\n            opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : 'L3T3_KEY';\r\n          }\r\n          req.simulcastCodecs = [new SimulcastCodec({\r\n            codec: videoCodec,\r\n            cid: track.mediaStreamTrack.id\r\n          })];\r\n          // set up backup\r\n          if (opts.backupCodec === true) {\r\n            opts.backupCodec = {\r\n              codec: defaultVideoCodec\r\n            };\r\n          }\r\n          if (opts.backupCodec && videoCodec !== opts.backupCodec.codec &&\r\n          // TODO remove this once e2ee is supported for backup codecs\r\n          req.encryption === Encryption_Type.NONE) {\r\n            // multi-codec simulcast requires dynacast\r\n            if (!this.roomOptions.dynacast) {\r\n              this.roomOptions.dynacast = true;\r\n            }\r\n            req.simulcastCodecs.push(new SimulcastCodec({\r\n              codec: opts.backupCodec.codec,\r\n              cid: ''\r\n            }));\r\n          }\r\n        }\r\n        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\r\n        req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\r\n      } else if (track.kind === Track.Kind.Audio) {\r\n        encodings = [{\r\n          maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\r\n          priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : 'high',\r\n          networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : 'high'\r\n        }];\r\n      }\r\n      if (!this.engine || this.engine.isClosed) {\r\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\r\n      }\r\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\r\n        var _a, _b, _c;\r\n        if (!this.engine.pcManager) {\r\n          throw new UnexpectedConnectionState('pcManager is not ready');\r\n        }\r\n        track.sender = yield this.engine.createSender(track, opts, encodings);\r\n        if (isLocalVideoTrack(track)) {\r\n          (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\r\n          track.setDegradationPreference(opts.degradationPreference);\r\n        }\r\n        if (encodings) {\r\n          if (isFireFox() && track.kind === Track.Kind.Audio) {\r\n            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\r\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\r\n               publish high quality audio track. But firefox always uses this value as the actual\r\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\r\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\r\n               fix the issue.\r\n             */\r\n            let trackTransceiver = undefined;\r\n            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\r\n              if (transceiver.sender === track.sender) {\r\n                trackTransceiver = transceiver;\r\n                break;\r\n              }\r\n            }\r\n            if (trackTransceiver) {\r\n              this.engine.pcManager.publisher.setTrackCodecBitrate({\r\n                transceiver: trackTransceiver,\r\n                codec: 'opus',\r\n                maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\r\n              });\r\n            }\r\n          } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\r\n            this.engine.pcManager.publisher.setTrackCodecBitrate({\r\n              cid: req.cid,\r\n              codec: track.codec,\r\n              maxbr: encodings[0].maxBitrate / 1000\r\n            });\r\n          }\r\n        }\r\n        yield this.engine.negotiate();\r\n      });\r\n      let ti;\r\n      const addTrackPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n        var _a;\r\n        try {\r\n          ti = yield this.engine.addTrack(req);\r\n          resolve(ti);\r\n        } catch (err) {\r\n          if (track.sender && ((_a = this.engine.pcManager) === null || _a === void 0 ? void 0 : _a.publisher)) {\r\n            this.engine.pcManager.publisher.removeTrack(track.sender);\r\n            yield this.engine.negotiate().catch(negotiateErr => {\r\n              this.log.error('failed to negotiate after removing track due to failed add track request', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n                error: negotiateErr\r\n              }));\r\n            });\r\n          }\r\n          reject(err);\r\n        }\r\n      }));\r\n      if (this.enabledPublishVideoCodecs.length > 0) {\r\n        const rets = yield Promise.all([addTrackPromise, negotiate()]);\r\n        ti = rets[0];\r\n      } else {\r\n        ti = yield addTrackPromise;\r\n        // server might not support the codec the client has requested, in that case, fallback\r\n        // to a supported codec\r\n        let primaryCodecMime;\r\n        ti.codecs.forEach(codec => {\r\n          if (primaryCodecMime === undefined) {\r\n            primaryCodecMime = codec.mimeType;\r\n          }\r\n        });\r\n        if (primaryCodecMime && track.kind === Track.Kind.Video) {\r\n          const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\r\n          if (updatedCodec !== videoCodec) {\r\n            this.log.debug('falling back to server selected codec', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n              codec: updatedCodec\r\n            }));\r\n            opts.videoCodec = updatedCodec;\r\n            // recompute encodings since bitrates/etc could have changed\r\n            encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\r\n          }\r\n        }\r\n        yield negotiate();\r\n      }\r\n      const publication = new LocalTrackPublication(track.kind, ti, track, {\r\n        loggerName: this.roomOptions.loggerName,\r\n        loggerContextCb: () => this.logContext\r\n      });\r\n      // save options for when it needs to be republished again\r\n      publication.options = opts;\r\n      track.sid = ti.sid;\r\n      this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\r\n        encodings,\r\n        trackInfo: ti\r\n      }));\r\n      if (isLocalVideoTrack(track)) {\r\n        track.startMonitor(this.engine.client);\r\n      } else if (isLocalAudioTrack(track)) {\r\n        track.startMonitor();\r\n      }\r\n      this.addTrackPublication(publication);\r\n      // send event for publication\r\n      this.emit(ParticipantEvent.LocalTrackPublished, publication);\r\n      if (isLocalAudioTrack(track) && ti.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)) {\r\n        const stream = track.getPreConnectBuffer();\r\n        // TODO: we're registering the listener after negotiation, so there might be a race\r\n        this.on(ParticipantEvent.LocalTrackSubscribed, pub => {\r\n          if (pub.trackSid === ti.sid) {\r\n            if (!track.hasPreConnectBuffer) {\r\n              this.log.warn('subscribe event came to late, buffer already closed', this.logContext);\r\n              return;\r\n            }\r\n            this.log.debug('finished recording preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n            track.stopPreConnectBuffer();\r\n          }\r\n        });\r\n        if (stream) {\r\n          const bufferStreamPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n            var _a, e_2, _b, _c;\r\n            var _d, _e;\r\n            try {\r\n              this.log.debug('waiting for agent', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              const agentActiveTimeout = setTimeout(() => {\r\n                reject(new Error('agent not active within 10 seconds'));\r\n              }, 10000);\r\n              const agent = yield this.waitUntilActiveAgentPresent();\r\n              clearTimeout(agentActiveTimeout);\r\n              this.log.debug('sending preconnect buffer', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n              const writer = yield this.streamBytes({\r\n                name: 'preconnect-buffer',\r\n                mimeType: 'audio/opus',\r\n                topic: 'lk.agent.pre-connect-audio-buffer',\r\n                destinationIdentities: [agent.identity],\r\n                attributes: {\r\n                  trackId: publication.trackSid,\r\n                  sampleRate: String((_d = settings.sampleRate) !== null && _d !== void 0 ? _d : '48000'),\r\n                  channels: String((_e = settings.channelCount) !== null && _e !== void 0 ? _e : '1')\r\n                }\r\n              });\r\n              try {\r\n                for (var _f = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a = stream_1_1.done, !_a; _f = true) {\r\n                  _c = stream_1_1.value;\r\n                  _f = false;\r\n                  const chunk = _c;\r\n                  yield writer.write(chunk);\r\n                }\r\n              } catch (e_2_1) {\r\n                e_2 = {\r\n                  error: e_2_1\r\n                };\r\n              } finally {\r\n                try {\r\n                  if (!_f && !_a && (_b = stream_1.return)) yield _b.call(stream_1);\r\n                } finally {\r\n                  if (e_2) throw e_2.error;\r\n                }\r\n              }\r\n              yield writer.close();\r\n              resolve();\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          }));\r\n          bufferStreamPromise.then(() => {\r\n            this.log.debug('preconnect buffer sent successfully', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          }).catch(e => {\r\n            this.log.error('error sending preconnect buffer', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\r\n              error: e\r\n            }));\r\n          });\r\n        }\r\n      }\r\n      return publication;\r\n    });\r\n  }\r\n  get isLocal() {\r\n    return true;\r\n  }\r\n  /** @internal\r\n   * publish additional codec to existing track\r\n   */\r\n  publishAdditionalCodecForTrack(track, videoCodec, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      // TODO remove once e2ee is supported for backup tracks\r\n      if (this.encryptionType !== Encryption_Type.NONE) {\r\n        return;\r\n      }\r\n      // is it not published? if so skip\r\n      let existingPublication;\r\n      this.trackPublications.forEach(publication => {\r\n        if (!publication.track) {\r\n          return;\r\n        }\r\n        if (publication.track === track) {\r\n          existingPublication = publication;\r\n        }\r\n      });\r\n      if (!existingPublication) {\r\n        throw new TrackInvalidError('track is not published');\r\n      }\r\n      if (!isLocalVideoTrack(track)) {\r\n        throw new TrackInvalidError('track is not a video track');\r\n      }\r\n      const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\r\n      const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\r\n      if (!encodings) {\r\n        this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n        return;\r\n      }\r\n      const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\r\n      if (!simulcastTrack) {\r\n        return;\r\n      }\r\n      const req = new AddTrackRequest({\r\n        cid: simulcastTrack.mediaStreamTrack.id,\r\n        type: Track.kindToProto(track.kind),\r\n        muted: track.isMuted,\r\n        source: Track.sourceToProto(track.source),\r\n        sid: track.sid,\r\n        simulcastCodecs: [{\r\n          codec: opts.videoCodec,\r\n          cid: simulcastTrack.mediaStreamTrack.id\r\n        }]\r\n      });\r\n      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\r\n      if (!this.engine || this.engine.isClosed) {\r\n        throw new UnexpectedConnectionState('cannot publish track when not connected');\r\n      }\r\n      const negotiate = () => __awaiter(this, void 0, void 0, function* () {\r\n        yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\r\n        yield this.engine.negotiate();\r\n      });\r\n      const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);\r\n      const ti = rets[0];\r\n      this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\r\n        encodings,\r\n        trackInfo: ti\r\n      }));\r\n    });\r\n  }\r\n  unpublishTrack(track, stopOnUnpublish) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (isLocalTrack(track)) {\r\n        const publishPromise = this.pendingPublishPromises.get(track);\r\n        if (publishPromise) {\r\n          this.log.info('awaiting publish promise before attempting to unpublish', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\r\n          yield publishPromise;\r\n        }\r\n      }\r\n      // look through all published tracks to find the right ones\r\n      const publication = this.getPublicationForTrack(track);\r\n      const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\r\n      this.log.debug('unpublishing track', Object.assign(Object.assign({}, this.logContext), pubLogContext));\r\n      if (!publication || !publication.track) {\r\n        this.log.warn('track was not unpublished because no publication was found', Object.assign(Object.assign({}, this.logContext), pubLogContext));\r\n        return undefined;\r\n      }\r\n      track = publication.track;\r\n      track.off(TrackEvent.Muted, this.onTrackMuted);\r\n      track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\r\n      track.off(TrackEvent.Ended, this.handleTrackEnded);\r\n      track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\r\n      track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\r\n      track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\r\n      if (stopOnUnpublish === undefined) {\r\n        stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\r\n      }\r\n      if (stopOnUnpublish) {\r\n        track.stop();\r\n      } else {\r\n        track.stopMonitor();\r\n      }\r\n      let negotiationNeeded = false;\r\n      const trackSender = track.sender;\r\n      track.sender = undefined;\r\n      if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\r\n        try {\r\n          for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {\r\n            // if sender is not currently sending (after replaceTrack(null))\r\n            // removeTrack would have no effect.\r\n            // to ensure we end up successfully removing the track, manually set\r\n            // the transceiver to inactive\r\n            if (transceiver.sender === trackSender) {\r\n              transceiver.direction = 'inactive';\r\n              negotiationNeeded = true;\r\n            }\r\n          }\r\n          if (this.engine.removeTrack(trackSender)) {\r\n            negotiationNeeded = true;\r\n          }\r\n          if (isLocalVideoTrack(track)) {\r\n            for (const [, trackInfo] of track.simulcastCodecs) {\r\n              if (trackInfo.sender) {\r\n                if (this.engine.removeTrack(trackInfo.sender)) {\r\n                  negotiationNeeded = true;\r\n                }\r\n                trackInfo.sender = undefined;\r\n              }\r\n            }\r\n            track.simulcastCodecs.clear();\r\n          }\r\n        } catch (e) {\r\n          this.log.warn('failed to unpublish track', Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      // remove from our maps\r\n      this.trackPublications.delete(publication.trackSid);\r\n      switch (publication.kind) {\r\n        case Track.Kind.Audio:\r\n          this.audioTrackPublications.delete(publication.trackSid);\r\n          break;\r\n        case Track.Kind.Video:\r\n          this.videoTrackPublications.delete(publication.trackSid);\r\n          break;\r\n      }\r\n      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\r\n      publication.setTrack(undefined);\r\n      if (negotiationNeeded) {\r\n        yield this.engine.negotiate();\r\n      }\r\n      return publication;\r\n    });\r\n  }\r\n  unpublishTracks(tracks) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const results = yield Promise.all(tracks.map(track => this.unpublishTrack(track)));\r\n      return results.filter(track => !!track);\r\n    });\r\n  }\r\n  republishAllTracks(options_1) {\r\n    return __awaiter(this, arguments, void 0, function (options) {\r\n      var _this3 = this;\r\n      let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n      return function* () {\r\n        if (_this3.republishPromise) {\r\n          yield _this3.republishPromise;\r\n        }\r\n        _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {\r\n          try {\r\n            const localPubs = [];\r\n            this.trackPublications.forEach(pub => {\r\n              if (pub.track) {\r\n                if (options) {\r\n                  pub.options = Object.assign(Object.assign({}, pub.options), options);\r\n                }\r\n                localPubs.push(pub);\r\n              }\r\n            });\r\n            yield Promise.all(localPubs.map(pub => __awaiter(this, void 0, void 0, function* () {\r\n              const track = pub.track;\r\n              yield this.unpublishTrack(track, false);\r\n              if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\r\n                // generally we need to restart the track before publishing, often a full reconnect\r\n                // is necessary because computer had gone to sleep.\r\n                this.log.debug('restarting existing track', Object.assign(Object.assign({}, this.logContext), {\r\n                  track: pub.trackSid\r\n                }));\r\n                yield track.restartTrack();\r\n              }\r\n              yield this.publishOrRepublishTrack(track, pub.options, true);\r\n            })));\r\n            resolve();\r\n          } catch (error) {\r\n            reject(error);\r\n          } finally {\r\n            this.republishPromise = undefined;\r\n          }\r\n        }));\r\n        yield _this3.republishPromise;\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Publish a new data payload to the room. Data will be forwarded to each\r\n   * participant in the room if the destination field in publishOptions is empty\r\n   *\r\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\r\n   * @param options optionally specify a `reliable`, `topic` and `destination`\r\n   */\r\n  publishData(data_1) {\r\n    return __awaiter(this, arguments, void 0, function (data) {\r\n      var _this4 = this;\r\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n      return function* () {\r\n        const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\r\n        const destinationIdentities = options.destinationIdentities;\r\n        const topic = options.topic;\r\n        const packet = new DataPacket({\r\n          kind: kind,\r\n          value: {\r\n            case: 'user',\r\n            value: new UserPacket({\r\n              participantIdentity: _this4.identity,\r\n              payload: data,\r\n              destinationIdentities,\r\n              topic\r\n            })\r\n          }\r\n        });\r\n        yield _this4.engine.sendDataPacket(packet, kind);\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * Publish SIP DTMF message to the room.\r\n   *\r\n   * @param code DTMF code\r\n   * @param digit DTMF digit\r\n   */\r\n  publishDtmf(code, digit) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'sipDtmf',\r\n          value: new SipDTMF({\r\n            code: code,\r\n            digit: digit\r\n          })\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  sendChatMessage(text, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const msg = {\r\n        id: crypto.randomUUID(),\r\n        message: text,\r\n        timestamp: Date.now(),\r\n        attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\r\n      };\r\n      const packet = new DataPacket({\r\n        value: {\r\n          case: 'chatMessage',\r\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\r\n            timestamp: protoInt64.parse(msg.timestamp)\r\n          }))\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      this.emit(ParticipantEvent.ChatMessage, msg);\r\n      return msg;\r\n    });\r\n  }\r\n  editChatMessage(editText, originalMessage) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const msg = Object.assign(Object.assign({}, originalMessage), {\r\n        message: editText,\r\n        editTimestamp: Date.now()\r\n      });\r\n      const packet = new DataPacket({\r\n        value: {\r\n          case: 'chatMessage',\r\n          value: new ChatMessage(Object.assign(Object.assign({}, msg), {\r\n            timestamp: protoInt64.parse(msg.timestamp),\r\n            editTimestamp: protoInt64.parse(msg.editTimestamp)\r\n          }))\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      this.emit(ParticipantEvent.ChatMessage, msg);\r\n      return msg;\r\n    });\r\n  }\r\n  sendText(text, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const streamId = crypto.randomUUID();\r\n      const textInBytes = new TextEncoder().encode(text);\r\n      const totalTextLength = textInBytes.byteLength;\r\n      const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(() => crypto.randomUUID());\r\n      const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\r\n      const handleProgress = (progress, idx) => {\r\n        var _a;\r\n        progresses[idx] = progress;\r\n        const totalProgress = progresses.reduce((acc, val) => acc + val, 0);\r\n        (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\r\n      };\r\n      const writer = yield this.streamText({\r\n        streamId,\r\n        totalSize: totalTextLength,\r\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\r\n        topic: options === null || options === void 0 ? void 0 : options.topic,\r\n        attachedStreamIds: fileIds,\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\r\n      });\r\n      yield writer.write(text);\r\n      // set text part of progress to 1\r\n      handleProgress(1, 0);\r\n      yield writer.close();\r\n      if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\r\n        yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {\r\n          return this._sendFile(fileIds[idx], file, {\r\n            topic: options.topic,\r\n            mimeType: file.type,\r\n            onProgress: progress => {\r\n              handleProgress(progress, idx + 1);\r\n            }\r\n          });\r\n        })));\r\n      }\r\n      return writer.info;\r\n    });\r\n  }\r\n  /**\r\n   * @internal\r\n   * @experimental CAUTION, might get removed in a minor release\r\n   */\r\n  streamText(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\r\n      const info = {\r\n        id: streamId,\r\n        mimeType: 'text/plain',\r\n        timestamp: Date.now(),\r\n        topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : '',\r\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes\r\n      };\r\n      const header = new DataStream_Header({\r\n        streamId,\r\n        mimeType: info.mimeType,\r\n        topic: info.topic,\r\n        timestamp: numberToBigInt(info.timestamp),\r\n        totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\r\n        attributes: info.attributes,\r\n        contentHeader: {\r\n          case: 'textHeader',\r\n          value: new DataStream_TextHeader({\r\n            version: options === null || options === void 0 ? void 0 : options.version,\r\n            attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\r\n            replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\r\n            operationType: (options === null || options === void 0 ? void 0 : options.type) === 'update' ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\r\n          })\r\n        }\r\n      });\r\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\r\n      const packet = new DataPacket({\r\n        destinationIdentities,\r\n        value: {\r\n          case: 'streamHeader',\r\n          value: header\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      let chunkId = 0;\r\n      const localP = this;\r\n      const writableStream = new WritableStream({\r\n        // Implement the sink\r\n        write(text) {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {\r\n              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\r\n              const chunk = new DataStream_Chunk({\r\n                content: textByteChunk,\r\n                streamId,\r\n                chunkIndex: numberToBigInt(chunkId)\r\n              });\r\n              const chunkPacket = new DataPacket({\r\n                destinationIdentities,\r\n                value: {\r\n                  case: 'streamChunk',\r\n                  value: chunk\r\n                }\r\n              });\r\n              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\r\n              chunkId += 1;\r\n            }\r\n          });\r\n        },\r\n        close() {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const trailer = new DataStream_Trailer({\r\n              streamId\r\n            });\r\n            const trailerPacket = new DataPacket({\r\n              destinationIdentities,\r\n              value: {\r\n                case: 'streamTrailer',\r\n                value: trailer\r\n              }\r\n            });\r\n            yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\r\n          });\r\n        },\r\n        abort(err) {\r\n          console.log('Sink error:', err);\r\n          // TODO handle aborts to signal something to receiver side\r\n        }\r\n      });\r\n      let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {\r\n        yield writer.close();\r\n      });\r\n      localP.engine.once(EngineEvent.Closing, onEngineClose);\r\n      const writer = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));\r\n      return writer;\r\n    });\r\n  }\r\n  sendFile(file, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const streamId = crypto.randomUUID();\r\n      yield this._sendFile(streamId, file, options);\r\n      return {\r\n        id: streamId\r\n      };\r\n    });\r\n  }\r\n  _sendFile(streamId, file, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const writer = yield this.streamBytes({\r\n        streamId,\r\n        totalSize: file.size,\r\n        name: file.name,\r\n        mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\r\n        topic: options === null || options === void 0 ? void 0 : options.topic,\r\n        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\r\n      });\r\n      const reader = file.stream().getReader();\r\n      while (true) {\r\n        const {\r\n          done,\r\n          value\r\n        } = yield reader.read();\r\n        if (done) {\r\n          break;\r\n        }\r\n        yield writer.write(value);\r\n      }\r\n      yield writer.close();\r\n      return writer.info;\r\n    });\r\n  }\r\n  streamBytes(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e;\r\n      const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\r\n      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\r\n      const info = {\r\n        id: streamId,\r\n        mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : 'application/octet-stream',\r\n        topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : '',\r\n        timestamp: Date.now(),\r\n        attributes: options === null || options === void 0 ? void 0 : options.attributes,\r\n        size: options === null || options === void 0 ? void 0 : options.totalSize,\r\n        name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : 'unknown'\r\n      };\r\n      const header = new DataStream_Header({\r\n        totalLength: numberToBigInt((_e = info.size) !== null && _e !== void 0 ? _e : 0),\r\n        mimeType: info.mimeType,\r\n        streamId,\r\n        topic: info.topic,\r\n        timestamp: numberToBigInt(Date.now()),\r\n        attributes: info.attributes,\r\n        contentHeader: {\r\n          case: 'byteHeader',\r\n          value: new DataStream_ByteHeader({\r\n            name: info.name\r\n          })\r\n        }\r\n      });\r\n      const packet = new DataPacket({\r\n        destinationIdentities,\r\n        value: {\r\n          case: 'streamHeader',\r\n          value: header\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n      let chunkId = 0;\r\n      const writeMutex = new _();\r\n      const engine = this.engine;\r\n      const log = this.log;\r\n      const writableStream = new WritableStream({\r\n        write(chunk) {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const unlock = yield writeMutex.lock();\r\n            let byteOffset = 0;\r\n            try {\r\n              while (byteOffset < chunk.byteLength) {\r\n                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\r\n                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\r\n                const chunkPacket = new DataPacket({\r\n                  destinationIdentities,\r\n                  value: {\r\n                    case: 'streamChunk',\r\n                    value: new DataStream_Chunk({\r\n                      content: subChunk,\r\n                      streamId,\r\n                      chunkIndex: numberToBigInt(chunkId)\r\n                    })\r\n                  }\r\n                });\r\n                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\r\n                chunkId += 1;\r\n                byteOffset += subChunk.byteLength;\r\n              }\r\n            } finally {\r\n              unlock();\r\n            }\r\n          });\r\n        },\r\n        close() {\r\n          return __awaiter(this, void 0, void 0, function* () {\r\n            const trailer = new DataStream_Trailer({\r\n              streamId\r\n            });\r\n            const trailerPacket = new DataPacket({\r\n              destinationIdentities,\r\n              value: {\r\n                case: 'streamTrailer',\r\n                value: trailer\r\n              }\r\n            });\r\n            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\r\n          });\r\n        },\r\n        abort(err) {\r\n          log.error('Sink error:', err);\r\n        }\r\n      });\r\n      const byteWriter = new ByteStreamWriter(writableStream, info);\r\n      return byteWriter;\r\n    });\r\n  }\r\n  /**\r\n   * Initiate an RPC call to a remote participant\r\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\r\n   * @returns A promise that resolves with the response payload or rejects with an error.\r\n   * @throws Error on failure. Details in `message`.\r\n   */\r\n  performRpc(_a) {\r\n    return __awaiter(this, arguments, void 0, function (_ref3) {\r\n      var _this5 = this;\r\n      let {\r\n        destinationIdentity,\r\n        method,\r\n        payload,\r\n        responseTimeout = 10000\r\n      } = _ref3;\r\n      return function* () {\r\n        const maxRoundTripLatency = 2000;\r\n        return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {\r\n          var _a, _b, _c, _d;\r\n          if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\r\n            reject(RpcError.builtIn('REQUEST_PAYLOAD_TOO_LARGE'));\r\n            return;\r\n          }\r\n          if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, '1.8.0') < 0) {\r\n            reject(RpcError.builtIn('UNSUPPORTED_SERVER'));\r\n            return;\r\n          }\r\n          const id = crypto.randomUUID();\r\n          yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);\r\n          const ackTimeoutId = setTimeout(() => {\r\n            this.pendingAcks.delete(id);\r\n            reject(RpcError.builtIn('CONNECTION_TIMEOUT'));\r\n            this.pendingResponses.delete(id);\r\n            clearTimeout(responseTimeoutId);\r\n          }, maxRoundTripLatency);\r\n          this.pendingAcks.set(id, {\r\n            resolve: () => {\r\n              clearTimeout(ackTimeoutId);\r\n            },\r\n            participantIdentity: destinationIdentity\r\n          });\r\n          const responseTimeoutId = setTimeout(() => {\r\n            this.pendingResponses.delete(id);\r\n            reject(RpcError.builtIn('RESPONSE_TIMEOUT'));\r\n          }, responseTimeout);\r\n          this.pendingResponses.set(id, {\r\n            resolve: (responsePayload, responseError) => {\r\n              clearTimeout(responseTimeoutId);\r\n              if (this.pendingAcks.has(id)) {\r\n                console.warn('RPC response received before ack', id);\r\n                this.pendingAcks.delete(id);\r\n                clearTimeout(ackTimeoutId);\r\n              }\r\n              if (responseError) {\r\n                reject(responseError);\r\n              } else {\r\n                resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : '');\r\n              }\r\n            },\r\n            participantIdentity: destinationIdentity\r\n          });\r\n        }));\r\n      }();\r\n    });\r\n  }\r\n  /**\r\n   * @deprecated use `room.registerRpcMethod` instead\r\n   */\r\n  registerRpcMethod(method, handler) {\r\n    if (this.rpcHandlers.has(method)) {\r\n      this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\r\n    }\r\n    this.rpcHandlers.set(method, handler);\r\n  }\r\n  /**\r\n   * @deprecated use `room.unregisterRpcMethod` instead\r\n   */\r\n  unregisterRpcMethod(method) {\r\n    this.rpcHandlers.delete(method);\r\n  }\r\n  /**\r\n   * Control who can subscribe to LocalParticipant's published tracks.\r\n   *\r\n   * By default, all participants can subscribe. This allows fine-grained control over\r\n   * who is able to subscribe at a participant and track level.\r\n   *\r\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\r\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\r\n   * will not grant permissions to any participants and will require a subsequent\r\n   * permissions update to allow subscription.\r\n   *\r\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\r\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\r\n   *  By default this is set to true.\r\n   * @param participantTrackPermissions Full list of individual permissions per\r\n   *  participant/track. Any omitted participants will not receive any permissions.\r\n   */\r\n  setTrackSubscriptionPermissions(allParticipantsAllowed) {\r\n    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\r\n    this.participantTrackPermissions = participantTrackPermissions;\r\n    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\r\n    if (!this.engine.client.isDisconnected) {\r\n      this.updateTrackSubscriptionPermissions();\r\n    }\r\n  }\r\n  handleIncomingRpcAck(requestId) {\r\n    const handler = this.pendingAcks.get(requestId);\r\n    if (handler) {\r\n      handler.resolve();\r\n      this.pendingAcks.delete(requestId);\r\n    } else {\r\n      console.error('Ack received for unexpected RPC request', requestId);\r\n    }\r\n  }\r\n  handleIncomingRpcResponse(requestId, payload, error) {\r\n    const handler = this.pendingResponses.get(requestId);\r\n    if (handler) {\r\n      handler.resolve(payload, error);\r\n      this.pendingResponses.delete(requestId);\r\n    } else {\r\n      console.error('Response received for unexpected RPC request', requestId);\r\n    }\r\n  }\r\n  /** @internal */\r\n  publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const packet = new DataPacket({\r\n        destinationIdentities: [destinationIdentity],\r\n        kind: DataPacket_Kind.RELIABLE,\r\n        value: {\r\n          case: 'rpcRequest',\r\n          value: new RpcRequest({\r\n            id: requestId,\r\n            method,\r\n            payload,\r\n            responseTimeoutMs: responseTimeout,\r\n            version: 1\r\n          })\r\n        }\r\n      });\r\n      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\r\n    });\r\n  }\r\n  /** @internal */\r\n  handleParticipantDisconnected(participantIdentity) {\r\n    for (const [id, {\r\n      participantIdentity: pendingIdentity\r\n    }] of this.pendingAcks) {\r\n      if (pendingIdentity === participantIdentity) {\r\n        this.pendingAcks.delete(id);\r\n      }\r\n    }\r\n    for (const [id, {\r\n      participantIdentity: pendingIdentity,\r\n      resolve\r\n    }] of this.pendingResponses) {\r\n      if (pendingIdentity === participantIdentity) {\r\n        resolve(null, RpcError.builtIn('RECIPIENT_DISCONNECTED'));\r\n        this.pendingResponses.delete(id);\r\n      }\r\n    }\r\n  }\r\n  /** @internal */\r\n  setEnabledPublishCodecs(codecs) {\r\n    this.enabledPublishVideoCodecs = codecs.filter(c => c.mime.split('/')[0].toLowerCase() === 'video');\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    if (!super.updateInfo(info)) {\r\n      return false;\r\n    }\r\n    // reconcile track mute status.\r\n    // if server's track mute status doesn't match actual, we'll have to update\r\n    // the server's copy\r\n    info.tracks.forEach(ti => {\r\n      var _a, _b;\r\n      const pub = this.trackPublications.get(ti.sid);\r\n      if (pub) {\r\n        const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\r\n        if (mutedOnServer !== ti.muted) {\r\n          this.log.debug('updating server mute state after reconcile', Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\r\n            mutedOnServer\r\n          }));\r\n          this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\r\n        }\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  setActiveAgent(agent) {\r\n    var _a, _b, _c, _d;\r\n    this.firstActiveAgent = agent;\r\n    if (agent && !this.firstActiveAgent) {\r\n      this.firstActiveAgent = agent;\r\n    }\r\n    if (agent) {\r\n      (_b = (_a = this.activeAgentFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a, agent);\r\n    } else {\r\n      (_d = (_c = this.activeAgentFuture) === null || _c === void 0 ? void 0 : _c.reject) === null || _d === void 0 ? void 0 : _d.call(_c, 'Agent disconnected');\r\n    }\r\n    this.activeAgentFuture = undefined;\r\n  }\r\n  waitUntilActiveAgentPresent() {\r\n    if (this.firstActiveAgent) {\r\n      return Promise.resolve(this.firstActiveAgent);\r\n    }\r\n    if (!this.activeAgentFuture) {\r\n      this.activeAgentFuture = new Future();\r\n    }\r\n    return this.activeAgentFuture.promise;\r\n  }\r\n  getPublicationForTrack(track) {\r\n    let publication;\r\n    this.trackPublications.forEach(pub => {\r\n      const localTrack = pub.track;\r\n      if (!localTrack) {\r\n        return;\r\n      }\r\n      // this looks overly complicated due to this object tree\r\n      if (track instanceof MediaStreamTrack) {\r\n        if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\r\n          if (localTrack.mediaStreamTrack === track) {\r\n            publication = pub;\r\n          }\r\n        }\r\n      } else if (track === localTrack) {\r\n        publication = pub;\r\n      }\r\n    });\r\n    return publication;\r\n  }\r\n  waitForPendingPublicationOfSource(source) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const waitForPendingTimeout = 10000;\r\n      const startTime = Date.now();\r\n      while (Date.now() < startTime + waitForPendingTimeout) {\r\n        const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(_ref4 => {\r\n          let [pendingTrack] = _ref4;\r\n          return pendingTrack.source === source;\r\n        });\r\n        if (publishPromiseEntry) {\r\n          return publishPromiseEntry[1];\r\n        }\r\n        yield sleep(20);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass RemoteTrackPublication extends TrackPublication {\r\n  constructor(kind, ti, autoSubscribe, loggerOptions) {\r\n    super(kind, ti.sid, ti.name, loggerOptions);\r\n    this.track = undefined;\r\n    /** @internal */\r\n    this.allowed = true;\r\n    this.disabled = false;\r\n    this.currentVideoQuality = VideoQuality.HIGH;\r\n    this.handleEnded = track => {\r\n      this.setTrack(undefined);\r\n      this.emit(TrackEvent.Ended, track);\r\n    };\r\n    this.handleVisibilityChange = visible => {\r\n      this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\r\n      this.disabled = !visible;\r\n      this.emitTrackUpdate();\r\n    };\r\n    this.handleVideoDimensionsChange = dimensions => {\r\n      this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\r\n      this.videoDimensions = dimensions;\r\n      this.emitTrackUpdate();\r\n    };\r\n    this.subscribed = autoSubscribe;\r\n    this.updateInfo(ti);\r\n  }\r\n  /**\r\n   * Subscribe or unsubscribe to this remote track\r\n   * @param subscribed true to subscribe to a track, false to unsubscribe\r\n   */\r\n  setSubscribed(subscribed) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    this.subscribed = subscribed;\r\n    // reset allowed status when desired subscription state changes\r\n    // server will notify client via signal message if it's not allowed\r\n    if (subscribed) {\r\n      this.allowed = true;\r\n    }\r\n    const sub = new UpdateSubscription({\r\n      trackSids: [this.trackSid],\r\n      subscribe: this.subscribed,\r\n      participantTracks: [new ParticipantTracks({\r\n        // sending an empty participant id since TrackPublication doesn't keep it\r\n        // this is filled in by the participant that receives this message\r\n        participantSid: '',\r\n        trackSids: [this.trackSid]\r\n      })]\r\n    });\r\n    this.emit(TrackEvent.UpdateSubscription, sub);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n  }\r\n  get subscriptionStatus() {\r\n    if (this.subscribed === false) {\r\n      return TrackPublication.SubscriptionStatus.Unsubscribed;\r\n    }\r\n    if (!super.isSubscribed) {\r\n      return TrackPublication.SubscriptionStatus.Desired;\r\n    }\r\n    return TrackPublication.SubscriptionStatus.Subscribed;\r\n  }\r\n  get permissionStatus() {\r\n    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\r\n  }\r\n  /**\r\n   * Returns true if track is subscribed, and ready for playback\r\n   */\r\n  get isSubscribed() {\r\n    if (this.subscribed === false) {\r\n      return false;\r\n    }\r\n    return super.isSubscribed;\r\n  }\r\n  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\r\n  get isDesired() {\r\n    return this.subscribed !== false;\r\n  }\r\n  get isEnabled() {\r\n    return !this.disabled;\r\n  }\r\n  get isLocal() {\r\n    return false;\r\n  }\r\n  /**\r\n   * disable server from sending down data for this track. this is useful when\r\n   * the participant is off screen, you may disable streaming down their video\r\n   * to reduce bandwidth requirements\r\n   * @param enabled\r\n   */\r\n  setEnabled(enabled) {\r\n    if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\r\n      return;\r\n    }\r\n    this.disabled = !enabled;\r\n    this.emitTrackUpdate();\r\n  }\r\n  /**\r\n   * for tracks that support simulcasting, adjust subscribed quality\r\n   *\r\n   * This indicates the highest quality the client can accept. if network\r\n   * bandwidth does not allow, server will automatically reduce quality to\r\n   * optimize for uninterrupted video\r\n   */\r\n  setVideoQuality(quality) {\r\n    if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\r\n      return;\r\n    }\r\n    this.currentVideoQuality = quality;\r\n    this.videoDimensions = undefined;\r\n    this.emitTrackUpdate();\r\n  }\r\n  setVideoDimensions(dimensions) {\r\n    var _a, _b;\r\n    if (!this.isManualOperationAllowed()) {\r\n      return;\r\n    }\r\n    if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\r\n      return;\r\n    }\r\n    if (isRemoteVideoTrack(this.track)) {\r\n      this.videoDimensions = dimensions;\r\n    }\r\n    this.currentVideoQuality = undefined;\r\n    this.emitTrackUpdate();\r\n  }\r\n  setVideoFPS(fps) {\r\n    if (!this.isManualOperationAllowed()) {\r\n      return;\r\n    }\r\n    if (!isRemoteVideoTrack(this.track)) {\r\n      return;\r\n    }\r\n    if (this.fps === fps) {\r\n      return;\r\n    }\r\n    this.fps = fps;\r\n    this.emitTrackUpdate();\r\n  }\r\n  get videoQuality() {\r\n    return this.currentVideoQuality;\r\n  }\r\n  /** @internal */\r\n  setTrack(track) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    const prevTrack = this.track;\r\n    if (prevTrack === track) {\r\n      return;\r\n    }\r\n    if (prevTrack) {\r\n      // unregister listener\r\n      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\r\n      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\r\n      prevTrack.off(TrackEvent.Ended, this.handleEnded);\r\n      prevTrack.detach();\r\n      prevTrack.stopMonitor();\r\n      this.emit(TrackEvent.Unsubscribed, prevTrack);\r\n    }\r\n    super.setTrack(track);\r\n    if (track) {\r\n      track.sid = this.trackSid;\r\n      track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\r\n      track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\r\n      track.on(TrackEvent.Ended, this.handleEnded);\r\n      this.emit(TrackEvent.Subscribed, track);\r\n    }\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n  }\r\n  /** @internal */\r\n  setAllowed(allowed) {\r\n    const prevStatus = this.subscriptionStatus;\r\n    const prevPermission = this.permissionStatus;\r\n    this.allowed = allowed;\r\n    this.emitPermissionUpdateIfChanged(prevPermission);\r\n    this.emitSubscriptionUpdateIfChanged(prevStatus);\r\n  }\r\n  /** @internal */\r\n  setSubscriptionError(error) {\r\n    this.emit(TrackEvent.SubscriptionFailed, error);\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    super.updateInfo(info);\r\n    const prevMetadataMuted = this.metadataMuted;\r\n    this.metadataMuted = info.muted;\r\n    if (this.track) {\r\n      this.track.setMuted(info.muted);\r\n    } else if (prevMetadataMuted !== info.muted) {\r\n      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\r\n    }\r\n  }\r\n  emitSubscriptionUpdateIfChanged(previousStatus) {\r\n    const currentStatus = this.subscriptionStatus;\r\n    if (previousStatus === currentStatus) {\r\n      return;\r\n    }\r\n    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\r\n  }\r\n  emitPermissionUpdateIfChanged(previousPermissionStatus) {\r\n    const currentPermissionStatus = this.permissionStatus;\r\n    if (currentPermissionStatus !== previousPermissionStatus) {\r\n      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\r\n    }\r\n  }\r\n  isManualOperationAllowed() {\r\n    if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\r\n      this.log.warn('adaptive stream is enabled, cannot change video track settings', this.logContext);\r\n      return false;\r\n    }\r\n    if (!this.isDesired) {\r\n      this.log.warn('cannot update track settings when not subscribed', this.logContext);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  get isAdaptiveStream() {\r\n    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\r\n  }\r\n  /* @internal */\r\n  emitTrackUpdate() {\r\n    const settings = new UpdateTrackSettings({\r\n      trackSids: [this.trackSid],\r\n      disabled: this.disabled,\r\n      fps: this.fps\r\n    });\r\n    if (this.videoDimensions) {\r\n      settings.width = Math.ceil(this.videoDimensions.width);\r\n      settings.height = Math.ceil(this.videoDimensions.height);\r\n    } else if (this.currentVideoQuality !== undefined) {\r\n      settings.quality = this.currentVideoQuality;\r\n    } else {\r\n      // defaults to high quality\r\n      settings.quality = VideoQuality.HIGH;\r\n    }\r\n    this.emit(TrackEvent.UpdateSettings, settings);\r\n  }\r\n}\r\n\r\nclass RemoteParticipant extends Participant {\r\n  /** @internal */\r\n  static fromParticipantInfo(signalClient, pi, loggerOptions) {\r\n    return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\r\n  }\r\n  get logContext() {\r\n    return Object.assign(Object.assign({}, super.logContext), {\r\n      rpID: this.sid,\r\n      remoteParticipant: this.identity\r\n    });\r\n  }\r\n  /** @internal */\r\n  constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {\r\n    let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\r\n    super(sid, identity || '', name, metadata, attributes, loggerOptions, kind);\r\n    this.signalClient = signalClient;\r\n    this.trackPublications = new Map();\r\n    this.audioTrackPublications = new Map();\r\n    this.videoTrackPublications = new Map();\r\n    this.volumeMap = new Map();\r\n  }\r\n  addTrackPublication(publication) {\r\n    super.addTrackPublication(publication);\r\n    // register action events\r\n    publication.on(TrackEvent.UpdateSettings, settings => {\r\n      this.log.debug('send update settings', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n      this.signalClient.sendUpdateTrackSettings(settings);\r\n    });\r\n    publication.on(TrackEvent.UpdateSubscription, sub => {\r\n      sub.participantTracks.forEach(pt => {\r\n        pt.participantSid = this.sid;\r\n      });\r\n      this.signalClient.sendUpdateSubscription(sub);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionPermissionChanged, status => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionStatusChanged, status => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\r\n    });\r\n    publication.on(TrackEvent.Subscribed, track => {\r\n      this.emit(ParticipantEvent.TrackSubscribed, track, publication);\r\n    });\r\n    publication.on(TrackEvent.Unsubscribed, previousTrack => {\r\n      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\r\n    });\r\n    publication.on(TrackEvent.SubscriptionFailed, error => {\r\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\r\n    });\r\n  }\r\n  getTrackPublication(source) {\r\n    const track = super.getTrackPublication(source);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  getTrackPublicationByName(name) {\r\n    const track = super.getTrackPublicationByName(name);\r\n    if (track) {\r\n      return track;\r\n    }\r\n  }\r\n  /**\r\n   * sets the volume on the participant's audio track\r\n   * by default, this affects the microphone publication\r\n   * a different source can be passed in as a second argument\r\n   * if no track exists the volume will be applied when the microphone track is added\r\n   */\r\n  setVolume(volume) {\r\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\r\n    this.volumeMap.set(source, volume);\r\n    const audioPublication = this.getTrackPublication(source);\r\n    if (audioPublication && audioPublication.track) {\r\n      audioPublication.track.setVolume(volume);\r\n    }\r\n  }\r\n  /**\r\n   * gets the volume on the participant's microphone track\r\n   */\r\n  getVolume() {\r\n    let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\r\n    const audioPublication = this.getTrackPublication(source);\r\n    if (audioPublication && audioPublication.track) {\r\n      return audioPublication.track.getVolume();\r\n    }\r\n    return this.volumeMap.get(source);\r\n  }\r\n  /** @internal */\r\n  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\r\n    // find the track publication\r\n    // it's possible for the media track to arrive before participant info\r\n    let publication = this.getTrackPublicationBySid(sid);\r\n    // it's also possible that the browser didn't honor our original track id\r\n    // FireFox would use its own local uuid instead of server track id\r\n    if (!publication) {\r\n      if (!sid.startsWith('TR')) {\r\n        // find the first track that matches type\r\n        this.trackPublications.forEach(p => {\r\n          if (!publication && mediaTrack.kind === p.kind.toString()) {\r\n            publication = p;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    // when we couldn't locate the track, it's possible that the metadata hasn't\r\n    // yet arrived. Wait a bit longer for it to arrive, or fire an error\r\n    if (!publication) {\r\n      if (triesLeft === 0) {\r\n        this.log.error('could not find published track', Object.assign(Object.assign({}, this.logContext), {\r\n          trackSid: sid\r\n        }));\r\n        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\r\n        return;\r\n      }\r\n      if (triesLeft === undefined) triesLeft = 20;\r\n      setTimeout(() => {\r\n        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\r\n      }, 150);\r\n      return;\r\n    }\r\n    if (mediaTrack.readyState === 'ended') {\r\n      this.log.error('unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\r\n      return;\r\n    }\r\n    const isVideo = mediaTrack.kind === 'video';\r\n    let track;\r\n    if (isVideo) {\r\n      track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\r\n    } else {\r\n      track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\r\n    }\r\n    // set track info\r\n    track.source = publication.source;\r\n    // keep publication's muted status\r\n    track.isMuted = publication.isMuted;\r\n    track.setMediaStream(mediaStream);\r\n    track.start();\r\n    publication.setTrack(track);\r\n    // set participant volumes on new audio tracks\r\n    if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\r\n      track.setVolume(this.volumeMap.get(publication.source));\r\n    }\r\n    return publication;\r\n  }\r\n  /** @internal */\r\n  get hasMetadata() {\r\n    return !!this.participantInfo;\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  getTrackPublicationBySid(sid) {\r\n    return this.trackPublications.get(sid);\r\n  }\r\n  /** @internal */\r\n  updateInfo(info) {\r\n    if (!super.updateInfo(info)) {\r\n      return false;\r\n    }\r\n    // we are getting a list of all available tracks, reconcile in here\r\n    // and send out events for changes\r\n    // reconcile track publications, publish events only if metadata is already there\r\n    // i.e. changes since the local participant has joined\r\n    const validTracks = new Map();\r\n    const newTracks = new Map();\r\n    info.tracks.forEach(ti => {\r\n      var _a, _b;\r\n      let publication = this.getTrackPublicationBySid(ti.sid);\r\n      if (!publication) {\r\n        // new publication\r\n        const kind = Track.kindFromProto(ti.type);\r\n        if (!kind) {\r\n          return;\r\n        }\r\n        publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\r\n          loggerContextCb: () => this.logContext,\r\n          loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\r\n        });\r\n        publication.updateInfo(ti);\r\n        newTracks.set(ti.sid, publication);\r\n        const existingTrackOfSource = Array.from(this.trackPublications.values()).find(publishedTrack => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\r\n        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\r\n          this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\r\n            oldTrack: getLogContextFromTrack(existingTrackOfSource),\r\n            newTrack: getLogContextFromTrack(publication)\r\n          }));\r\n        }\r\n        this.addTrackPublication(publication);\r\n      } else {\r\n        publication.updateInfo(ti);\r\n      }\r\n      validTracks.set(ti.sid, publication);\r\n    });\r\n    // detect removed tracks\r\n    this.trackPublications.forEach(publication => {\r\n      if (!validTracks.has(publication.trackSid)) {\r\n        this.log.trace('detected removed track on remote participant, unpublishing', Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\r\n        this.unpublishTrack(publication.trackSid, true);\r\n      }\r\n    });\r\n    // always emit events for new publications, Room will not forward them unless it's ready\r\n    newTracks.forEach(publication => {\r\n      this.emit(ParticipantEvent.TrackPublished, publication);\r\n    });\r\n    return true;\r\n  }\r\n  /** @internal */\r\n  unpublishTrack(sid, sendUnpublish) {\r\n    const publication = this.trackPublications.get(sid);\r\n    if (!publication) {\r\n      return;\r\n    }\r\n    // also send unsubscribe, if track is actively subscribed\r\n    const {\r\n      track\r\n    } = publication;\r\n    if (track) {\r\n      track.stop();\r\n      publication.setTrack(undefined);\r\n    }\r\n    // remove track from maps only after unsubscribed has been fired\r\n    this.trackPublications.delete(sid);\r\n    // remove from the right type map\r\n    switch (publication.kind) {\r\n      case Track.Kind.Audio:\r\n        this.audioTrackPublications.delete(sid);\r\n        break;\r\n      case Track.Kind.Video:\r\n        this.videoTrackPublications.delete(sid);\r\n        break;\r\n    }\r\n    if (sendUnpublish) {\r\n      this.emit(ParticipantEvent.TrackUnpublished, publication);\r\n    }\r\n  }\r\n  /**\r\n   * @internal\r\n   */\r\n  setAudioOutput(output) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      this.audioOutput = output;\r\n      const promises = [];\r\n      this.audioTrackPublications.forEach(pub => {\r\n        var _a;\r\n        if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\r\n          promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : 'default'));\r\n        }\r\n      });\r\n      yield Promise.all(promises);\r\n    });\r\n  }\r\n  /** @internal */\r\n  emit(event) {\r\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n      args[_key - 1] = arguments[_key];\r\n    }\r\n    this.log.trace('participant event', Object.assign(Object.assign({}, this.logContext), {\r\n      event,\r\n      args\r\n    }));\r\n    return super.emit(event, ...args);\r\n  }\r\n}\r\n\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n  ConnectionState[\"Disconnected\"] = \"disconnected\";\r\n  ConnectionState[\"Connecting\"] = \"connecting\";\r\n  ConnectionState[\"Connected\"] = \"connected\";\r\n  ConnectionState[\"Reconnecting\"] = \"reconnecting\";\r\n  ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nconst connectionReconcileFrequency = 4 * 1000;\r\n/**\r\n * In LiveKit, a room is the logical grouping for a list of participants.\r\n * Participants in a room can publish tracks, and subscribe to others' tracks.\r\n *\r\n * a Room fires [[RoomEvent | RoomEvents]].\r\n *\r\n * @noInheritDoc\r\n */\r\nclass Room extends eventsExports.EventEmitter {\r\n  /**\r\n   * Creates a new Room, the primary construct for a LiveKit session.\r\n   * @param options\r\n   */\r\n  constructor(options) {\r\n    var _this;\r\n    var _a, _b, _c;\r\n    super();\r\n    _this = this;\r\n    this.state = ConnectionState.Disconnected;\r\n    /**\r\n     * list of participants that are actively speaking. when this changes\r\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\r\n     */\r\n    this.activeSpeakers = [];\r\n    /** reflects the sender encryption status of the local participant */\r\n    this.isE2EEEnabled = false;\r\n    this.audioEnabled = true;\r\n    this.isVideoPlaybackBlocked = false;\r\n    this.log = livekitLogger;\r\n    this.bufferedEvents = [];\r\n    this.isResuming = false;\r\n    this.byteStreamControllers = new Map();\r\n    this.textStreamControllers = new Map();\r\n    this.byteStreamHandlers = new Map();\r\n    this.textStreamHandlers = new Map();\r\n    this.rpcHandlers = new Map();\r\n    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (!isBrowserSupported()) {\r\n        if (isReactNative()) {\r\n          throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\r\n        } else {\r\n          throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\r\n        }\r\n      }\r\n      // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\r\n      const unlockDisconnect = yield this.disconnectLock.lock();\r\n      if (this.state === ConnectionState.Connected) {\r\n        // when the state is reconnecting or connected, this function returns immediately\r\n        this.log.info(\"already connected to room \".concat(this.name), this.logContext);\r\n        unlockDisconnect();\r\n        return Promise.resolve();\r\n      }\r\n      if (this.connectFuture) {\r\n        unlockDisconnect();\r\n        return this.connectFuture.promise;\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connecting);\r\n      if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\r\n        this.regionUrl = undefined;\r\n        this.regionUrlProvider = undefined;\r\n      }\r\n      if (isCloud(new URL(url))) {\r\n        if (this.regionUrlProvider === undefined) {\r\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\r\n        } else {\r\n          this.regionUrlProvider.updateToken(token);\r\n        }\r\n        // trigger the first fetch without waiting for a response\r\n        // if initial connection fails, this will speed up picking regional url\r\n        // on subsequent runs\r\n        this.regionUrlProvider.fetchRegionSettings().then(settings => {\r\n          var _a;\r\n          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\r\n        }).catch(e => {\r\n          this.log.warn('could not fetch region settings', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        });\r\n      }\r\n      const connectFn = (resolve, reject, regionUrl) => __awaiter(this, void 0, void 0, function* () {\r\n        var _a, _b;\r\n        if (this.abortController) {\r\n          this.abortController.abort();\r\n        }\r\n        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\r\n        const abortController = new AbortController();\r\n        this.abortController = abortController;\r\n        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\r\n        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\r\n        try {\r\n          yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\r\n          this.abortController = undefined;\r\n          resolve();\r\n        } catch (e) {\r\n          if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {\r\n            let nextUrl = null;\r\n            try {\r\n              nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\r\n            } catch (error) {\r\n              if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {\r\n                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\r\n                reject(error);\r\n                return;\r\n              }\r\n            }\r\n            if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\r\n              this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\r\n              this.recreateEngine();\r\n              yield connectFn(resolve, reject, nextUrl);\r\n            } else {\r\n              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));\r\n              reject(e);\r\n            }\r\n          } else {\r\n            let disconnectReason = DisconnectReason.UNKNOWN_REASON;\r\n            if (e instanceof ConnectionError) {\r\n              disconnectReason = getDisconnectReasonFromConnectionError(e);\r\n            }\r\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\r\n            reject(e);\r\n          }\r\n        }\r\n      });\r\n      const regionUrl = this.regionUrl;\r\n      this.regionUrl = undefined;\r\n      this.connectFuture = new Future((resolve, reject) => {\r\n        connectFn(resolve, reject, regionUrl);\r\n      }, () => {\r\n        this.clearConnectionFutures();\r\n      });\r\n      return this.connectFuture.promise;\r\n    });\r\n    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      const joinResponse = yield engine.join(url, token, {\r\n        autoSubscribe: connectOptions.autoSubscribe,\r\n        adaptiveStream: typeof roomOptions.adaptiveStream === 'object' ? true : roomOptions.adaptiveStream,\r\n        maxRetries: connectOptions.maxRetries,\r\n        e2eeEnabled: !!this.e2eeManager,\r\n        websocketTimeout: connectOptions.websocketTimeout\r\n      }, abortController.signal);\r\n      let serverInfo = joinResponse.serverInfo;\r\n      if (!serverInfo) {\r\n        serverInfo = {\r\n          version: joinResponse.serverVersion,\r\n          region: joinResponse.serverRegion\r\n        };\r\n      }\r\n      this.serverInfo = serverInfo;\r\n      this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map(_ref => {\r\n        let [key, value] = _ref;\r\n        return \"\".concat(key, \": \").concat(value);\r\n      }).join(', ')), {\r\n        room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\r\n        roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\r\n        identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\r\n      });\r\n      if (!serverInfo.version) {\r\n        throw new UnsupportedServer('unknown server version');\r\n      }\r\n      if (serverInfo.version === '0.15.1' && this.options.dynacast) {\r\n        this.log.debug('disabling dynacast due to server version', this.logContext);\r\n        // dynacast has a bug in 0.15.1, so we cannot use it then\r\n        roomOptions.dynacast = false;\r\n      }\r\n      return joinResponse;\r\n    });\r\n    this.applyJoinResponse = joinResponse => {\r\n      const pi = joinResponse.participant;\r\n      this.localParticipant.sid = pi.sid;\r\n      this.localParticipant.identity = pi.identity;\r\n      this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\r\n      if (this.options.e2ee && this.e2eeManager) {\r\n        try {\r\n          this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\r\n        } catch (e) {\r\n          this.log.error(e instanceof Error ? e.message : 'Could not set SifTrailer', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      // populate remote participants, these should not trigger new events\r\n      this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);\r\n      if (joinResponse.room) {\r\n        this.handleRoomUpdate(joinResponse.room);\r\n      }\r\n    };\r\n    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\r\n        this.log.info('Reconnection attempt replaced by new connection attempt', this.logContext);\r\n        // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\r\n        this.recreateEngine();\r\n      } else {\r\n        // create engine if previously disconnected\r\n        this.maybeCreateEngine();\r\n      }\r\n      if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\r\n        this.engine.setRegionUrlProvider(this.regionUrlProvider);\r\n      }\r\n      this.acquireAudioContext();\r\n      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\r\n      if (this.connOptions.rtcConfig) {\r\n        this.engine.rtcConfig = this.connOptions.rtcConfig;\r\n      }\r\n      if (this.connOptions.peerConnectionTimeout) {\r\n        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\r\n      }\r\n      try {\r\n        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\r\n        this.applyJoinResponse(joinResponse);\r\n        // forward metadata changed for the local participant\r\n        this.setupLocalParticipantEvents();\r\n        this.emit(RoomEvent.SignalConnected);\r\n      } catch (err) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        const resultingError = new ConnectionError(\"could not establish signal connection\", ConnectionErrorReason.ServerUnreachable);\r\n        if (err instanceof Error) {\r\n          resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\r\n        }\r\n        if (err instanceof ConnectionError) {\r\n          resultingError.reason = err.reason;\r\n          resultingError.status = err.status;\r\n        }\r\n        this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\r\n          error: err\r\n        }));\r\n        throw resultingError;\r\n      }\r\n      if (abortController.signal.aborted) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\r\n      }\r\n      try {\r\n        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\r\n      } catch (e) {\r\n        yield this.engine.close();\r\n        this.recreateEngine();\r\n        throw e;\r\n      }\r\n      // also hook unload event\r\n      if (isWeb() && this.options.disconnectOnPageLeave) {\r\n        // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\r\n        window.addEventListener('pagehide', this.onPageLeave);\r\n        window.addEventListener('beforeunload', this.onPageLeave);\r\n      }\r\n      if (isWeb()) {\r\n        document.addEventListener('freeze', this.onPageLeave);\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      this.emit(RoomEvent.Connected);\r\n      this.registerConnectionReconcile();\r\n    });\r\n    /**\r\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\r\n     */\r\n    this.disconnect = function () {\r\n      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {\r\n        args_1[_key] = arguments[_key];\r\n      }\r\n      return __awaiter(_this, [...args_1], void 0, function () {\r\n        var _this2 = this;\r\n        let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n        return function* () {\r\n          var _a, _b, _c, _d;\r\n          const unlock = yield _this2.disconnectLock.lock();\r\n          try {\r\n            if (_this2.state === ConnectionState.Disconnected) {\r\n              _this2.log.debug('already disconnected', _this2.logContext);\r\n              return;\r\n            }\r\n            _this2.log.info('disconnect from room', Object.assign({}, _this2.logContext));\r\n            if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\r\n              // try aborting pending connection attempt\r\n              _this2.log.warn('abort connection attempt', _this2.logContext);\r\n              (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();\r\n              // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\r\n              (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError('Client initiated disconnect', ConnectionErrorReason.Cancelled));\r\n              _this2.connectFuture = undefined;\r\n            }\r\n            // send leave\r\n            if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {\r\n              yield _this2.engine.client.sendLeave();\r\n            }\r\n            // close engine (also closes client)\r\n            if (_this2.engine) {\r\n              yield _this2.engine.close();\r\n            }\r\n            _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\r\n            /* @ts-ignore */\r\n            _this2.engine = undefined;\r\n          } finally {\r\n            unlock();\r\n          }\r\n        }();\r\n      });\r\n    };\r\n    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {\r\n      this.log.info('Page leave detected, disconnecting', this.logContext);\r\n      yield this.disconnect();\r\n    });\r\n    /**\r\n     * Browsers have different policies regarding audio playback. Most requiring\r\n     * some form of user interaction (click/tap/etc).\r\n     * In those cases, audio will be silent until a click/tap triggering one of the following\r\n     * - `startAudio`\r\n     * - `getUserMedia`\r\n     */\r\n    this.startAudio = () => __awaiter(this, void 0, void 0, function* () {\r\n      const elements = [];\r\n      const browser = getBrowser();\r\n      if (browser && browser.os === 'iOS') {\r\n        /**\r\n         * iOS blocks audio element playback if\r\n         * - user is not publishing audio themselves and\r\n         * - no other audio source is playing\r\n         *\r\n         * as a workaround, we create an audio element with an empty track, so that\r\n         * silent audio is always playing\r\n         */\r\n        const audioId = 'livekit-dummy-audio-el';\r\n        let dummyAudioEl = document.getElementById(audioId);\r\n        if (!dummyAudioEl) {\r\n          dummyAudioEl = document.createElement('audio');\r\n          dummyAudioEl.id = audioId;\r\n          dummyAudioEl.autoplay = true;\r\n          dummyAudioEl.hidden = true;\r\n          const track = getEmptyAudioStreamTrack();\r\n          track.enabled = true;\r\n          const stream = new MediaStream([track]);\r\n          dummyAudioEl.srcObject = stream;\r\n          document.addEventListener('visibilitychange', () => {\r\n            if (!dummyAudioEl) {\r\n              return;\r\n            }\r\n            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\r\n            dummyAudioEl.srcObject = document.hidden ? null : stream;\r\n            if (!document.hidden) {\r\n              this.log.debug('page visible again, triggering startAudio to resume playback and update playback status', this.logContext);\r\n              this.startAudio();\r\n            }\r\n          });\r\n          document.body.append(dummyAudioEl);\r\n          this.once(RoomEvent.Disconnected, () => {\r\n            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\r\n            dummyAudioEl = null;\r\n          });\r\n        }\r\n        elements.push(dummyAudioEl);\r\n      }\r\n      this.remoteParticipants.forEach(p => {\r\n        p.audioTrackPublications.forEach(t => {\r\n          if (t.track) {\r\n            t.track.attachedElements.forEach(e => {\r\n              elements.push(e);\r\n            });\r\n          }\r\n        });\r\n      });\r\n      try {\r\n        yield Promise.all([this.acquireAudioContext(), ...elements.map(e => {\r\n          e.muted = false;\r\n          return e.play();\r\n        })]);\r\n        this.handleAudioPlaybackStarted();\r\n      } catch (err) {\r\n        this.handleAudioPlaybackFailed(err);\r\n        throw err;\r\n      }\r\n    });\r\n    this.startVideo = () => __awaiter(this, void 0, void 0, function* () {\r\n      const elements = [];\r\n      for (const p of this.remoteParticipants.values()) {\r\n        p.videoTrackPublications.forEach(tr => {\r\n          var _a;\r\n          (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach(el => {\r\n            if (!elements.includes(el)) {\r\n              elements.push(el);\r\n            }\r\n          });\r\n        });\r\n      }\r\n      yield Promise.all(elements.map(el => el.play())).then(() => {\r\n        this.handleVideoPlaybackStarted();\r\n      }).catch(e => {\r\n        if (e.name === 'NotAllowedError') {\r\n          this.handleVideoPlaybackFailed();\r\n        } else {\r\n          this.log.warn('Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler', this.logContext);\r\n        }\r\n      });\r\n    });\r\n    this.handleRestarting = () => {\r\n      this.clearConnectionReconcile();\r\n      // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\r\n      this.isResuming = false;\r\n      // also unwind existing participants & existing subscriptions\r\n      for (const p of this.remoteParticipants.values()) {\r\n        this.handleParticipantDisconnected(p.identity, p);\r\n      }\r\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\r\n        this.emit(RoomEvent.Reconnecting);\r\n      }\r\n    };\r\n    this.handleSignalRestarted = joinResponse => __awaiter(this, void 0, void 0, function* () {\r\n      this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\r\n        region: joinResponse.serverRegion\r\n      }));\r\n      this.bufferedEvents = [];\r\n      this.applyJoinResponse(joinResponse);\r\n      try {\r\n        // unpublish & republish tracks\r\n        yield this.localParticipant.republishAllTracks(undefined, true);\r\n      } catch (error) {\r\n        this.log.error('error trying to re-publish tracks after reconnection', Object.assign(Object.assign({}, this.logContext), {\r\n          error\r\n        }));\r\n      }\r\n      try {\r\n        yield this.engine.waitForRestarted();\r\n        this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\r\n          region: joinResponse.serverRegion\r\n        }));\r\n      } catch (_a) {\r\n        // reconnection failed, handleDisconnect is being invoked already, just return here\r\n        return;\r\n      }\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      this.emit(RoomEvent.Reconnected);\r\n      this.registerConnectionReconcile();\r\n      this.emitBufferedEvents();\r\n    });\r\n    this.handleParticipantUpdates = participantInfos => {\r\n      // handle changes to participant state, and send events\r\n      participantInfos.forEach(info => {\r\n        var _a;\r\n        if (info.identity === this.localParticipant.identity) {\r\n          this.localParticipant.updateInfo(info);\r\n          return;\r\n        }\r\n        // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\r\n        // so we try to map an empty identity to an already known sID manually\r\n        if (info.identity === '') {\r\n          info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : '';\r\n        }\r\n        let remoteParticipant = this.remoteParticipants.get(info.identity);\r\n        // when it's disconnected, send updates\r\n        if (info.state === ParticipantInfo_State.DISCONNECTED) {\r\n          this.handleParticipantDisconnected(info.identity, remoteParticipant);\r\n        } else {\r\n          // create participant if doesn't exist\r\n          remoteParticipant = this.getOrCreateParticipant(info.identity, info);\r\n        }\r\n      });\r\n    };\r\n    // updates are sent only when there's a change to speaker ordering\r\n    this.handleActiveSpeakersUpdate = speakers => {\r\n      const activeSpeakers = [];\r\n      const seenSids = {};\r\n      speakers.forEach(speaker => {\r\n        seenSids[speaker.sid] = true;\r\n        if (speaker.sid === this.localParticipant.sid) {\r\n          this.localParticipant.audioLevel = speaker.level;\r\n          this.localParticipant.setIsSpeaking(true);\r\n          activeSpeakers.push(this.localParticipant);\r\n        } else {\r\n          const p = this.getRemoteParticipantBySid(speaker.sid);\r\n          if (p) {\r\n            p.audioLevel = speaker.level;\r\n            p.setIsSpeaking(true);\r\n            activeSpeakers.push(p);\r\n          }\r\n        }\r\n      });\r\n      if (!seenSids[this.localParticipant.sid]) {\r\n        this.localParticipant.audioLevel = 0;\r\n        this.localParticipant.setIsSpeaking(false);\r\n      }\r\n      this.remoteParticipants.forEach(p => {\r\n        if (!seenSids[p.sid]) {\r\n          p.audioLevel = 0;\r\n          p.setIsSpeaking(false);\r\n        }\r\n      });\r\n      this.activeSpeakers = activeSpeakers;\r\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\r\n    };\r\n    // process list of changed speakers\r\n    this.handleSpeakersChanged = speakerUpdates => {\r\n      const lastSpeakers = new Map();\r\n      this.activeSpeakers.forEach(p => {\r\n        const remoteParticipant = this.remoteParticipants.get(p.identity);\r\n        if (remoteParticipant && remoteParticipant.sid !== p.sid) {\r\n          return;\r\n        }\r\n        lastSpeakers.set(p.sid, p);\r\n      });\r\n      speakerUpdates.forEach(speaker => {\r\n        let p = this.getRemoteParticipantBySid(speaker.sid);\r\n        if (speaker.sid === this.localParticipant.sid) {\r\n          p = this.localParticipant;\r\n        }\r\n        if (!p) {\r\n          return;\r\n        }\r\n        p.audioLevel = speaker.level;\r\n        p.setIsSpeaking(speaker.active);\r\n        if (speaker.active) {\r\n          lastSpeakers.set(speaker.sid, p);\r\n        } else {\r\n          lastSpeakers.delete(speaker.sid);\r\n        }\r\n      });\r\n      const activeSpeakers = Array.from(lastSpeakers.values());\r\n      activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);\r\n      this.activeSpeakers = activeSpeakers;\r\n      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\r\n    };\r\n    this.handleStreamStateUpdate = streamStateUpdate => {\r\n      streamStateUpdate.streamStates.forEach(streamState => {\r\n        const participant = this.getRemoteParticipantBySid(streamState.participantSid);\r\n        if (!participant) {\r\n          return;\r\n        }\r\n        const pub = participant.getTrackPublicationBySid(streamState.trackSid);\r\n        if (!pub || !pub.track) {\r\n          return;\r\n        }\r\n        const newStreamState = Track.streamStateFromProto(streamState.state);\r\n        if (newStreamState !== pub.track.streamState) {\r\n          pub.track.streamState = newStreamState;\r\n          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\r\n          this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\r\n        }\r\n      });\r\n    };\r\n    this.handleSubscriptionPermissionUpdate = update => {\r\n      const participant = this.getRemoteParticipantBySid(update.participantSid);\r\n      if (!participant) {\r\n        return;\r\n      }\r\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\r\n      if (!pub) {\r\n        return;\r\n      }\r\n      pub.setAllowed(update.allowed);\r\n    };\r\n    this.handleSubscriptionError = update => {\r\n      const participant = Array.from(this.remoteParticipants.values()).find(p => p.trackPublications.has(update.trackSid));\r\n      if (!participant) {\r\n        return;\r\n      }\r\n      const pub = participant.getTrackPublicationBySid(update.trackSid);\r\n      if (!pub) {\r\n        return;\r\n      }\r\n      pub.setSubscriptionError(update.err);\r\n    };\r\n    this.handleDataPacket = packet => {\r\n      // find the participant\r\n      const participant = this.remoteParticipants.get(packet.participantIdentity);\r\n      if (packet.value.case === 'user') {\r\n        this.handleUserPacket(participant, packet.value.value, packet.kind);\r\n      } else if (packet.value.case === 'transcription') {\r\n        this.handleTranscription(participant, packet.value.value);\r\n      } else if (packet.value.case === 'sipDtmf') {\r\n        this.handleSipDtmf(participant, packet.value.value);\r\n      } else if (packet.value.case === 'chatMessage') {\r\n        this.handleChatMessage(participant, packet.value.value);\r\n      } else if (packet.value.case === 'metrics') {\r\n        this.handleMetrics(packet.value.value, participant);\r\n      } else if (packet.value.case === 'streamHeader') {\r\n        this.handleStreamHeader(packet.value.value, packet.participantIdentity);\r\n      } else if (packet.value.case === 'streamChunk') {\r\n        this.handleStreamChunk(packet.value.value);\r\n      } else if (packet.value.case === 'streamTrailer') {\r\n        this.handleStreamTrailer(packet.value.value);\r\n      } else if (packet.value.case === 'rpcRequest') {\r\n        const rpc = packet.value.value;\r\n        this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\r\n      }\r\n    };\r\n    this.handleUserPacket = (participant, userPacket, kind) => {\r\n      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\r\n      // also emit on the participant\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\r\n    };\r\n    this.handleSipDtmf = (participant, dtmf) => {\r\n      this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\r\n      // also emit on the participant\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\r\n    };\r\n    this.bufferedSegments = new Map();\r\n    this.handleTranscription = (_remoteParticipant, transcription) => {\r\n      // find the participant\r\n      const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\r\n      const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\r\n      const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\r\n      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\r\n      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\r\n      this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\r\n    };\r\n    this.handleChatMessage = (participant, chatMessage) => {\r\n      const msg = extractChatMessage(chatMessage);\r\n      this.emit(RoomEvent.ChatMessage, msg, participant);\r\n    };\r\n    this.handleMetrics = (metrics, participant) => {\r\n      this.emit(RoomEvent.MetricsReceived, metrics, participant);\r\n    };\r\n    this.handleAudioPlaybackStarted = () => {\r\n      if (this.canPlaybackAudio) {\r\n        return;\r\n      }\r\n      this.audioEnabled = true;\r\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\r\n    };\r\n    this.handleAudioPlaybackFailed = e => {\r\n      this.log.warn('could not playback audio', Object.assign(Object.assign({}, this.logContext), {\r\n        error: e\r\n      }));\r\n      if (!this.canPlaybackAudio) {\r\n        return;\r\n      }\r\n      this.audioEnabled = false;\r\n      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\r\n    };\r\n    this.handleVideoPlaybackStarted = () => {\r\n      if (this.isVideoPlaybackBlocked) {\r\n        this.isVideoPlaybackBlocked = false;\r\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\r\n      }\r\n    };\r\n    this.handleVideoPlaybackFailed = () => {\r\n      if (!this.isVideoPlaybackBlocked) {\r\n        this.isVideoPlaybackBlocked = true;\r\n        this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\r\n      }\r\n    };\r\n    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) !== 'iOS') {\r\n        // default devices are non deterministic on iOS, so we don't attempt to select them here\r\n        yield this.selectDefaultDevices();\r\n      }\r\n      this.emit(RoomEvent.MediaDevicesChanged);\r\n    });\r\n    this.handleRoomUpdate = room => {\r\n      const oldRoom = this.roomInfo;\r\n      this.roomInfo = room;\r\n      if (oldRoom && oldRoom.metadata !== room.metadata) {\r\n        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\r\n      }\r\n      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\r\n        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\r\n      }\r\n    };\r\n    this.handleConnectionQualityUpdate = update => {\r\n      update.updates.forEach(info => {\r\n        if (info.participantSid === this.localParticipant.sid) {\r\n          this.localParticipant.setConnectionQuality(info.quality);\r\n          return;\r\n        }\r\n        const participant = this.getRemoteParticipantBySid(info.participantSid);\r\n        if (participant) {\r\n          participant.setConnectionQuality(info.quality);\r\n        }\r\n      });\r\n    };\r\n    this.onLocalParticipantMetadataChanged = metadata => {\r\n      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\r\n    };\r\n    this.onLocalParticipantNameChanged = name => {\r\n      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\r\n    };\r\n    this.onLocalAttributesChanged = changedAttributes => {\r\n      this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\r\n    };\r\n    this.onLocalTrackMuted = pub => {\r\n      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\r\n    };\r\n    this.onLocalTrackUnmuted = pub => {\r\n      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\r\n    };\r\n    this.onTrackProcessorUpdate = processor => {\r\n      var _a;\r\n      (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\r\n    };\r\n    this.onLocalTrackPublished = pub => __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c, _d, _e, _f;\r\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\r\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\r\n      (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\r\n      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\r\n      if (isLocalAudioTrack(pub.track)) {\r\n        const trackIsSilent = yield pub.track.checkForSilence();\r\n        if (trackIsSilent) {\r\n          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\r\n        }\r\n      }\r\n      const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\r\n      const deviceKind = sourceToKind(pub.source);\r\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\r\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\r\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\r\n      }\r\n    });\r\n    this.onLocalTrackUnpublished = pub => {\r\n      var _a, _b;\r\n      (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\r\n      (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\r\n      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\r\n    };\r\n    this.onLocalTrackRestarted = track => __awaiter(this, void 0, void 0, function* () {\r\n      const deviceId = yield track.getDeviceId(false);\r\n      const deviceKind = sourceToKind(track.source);\r\n      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\r\n        this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\r\n        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\r\n        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\r\n      }\r\n    });\r\n    this.onLocalConnectionQualityChanged = quality => {\r\n      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\r\n    };\r\n    this.onMediaDevicesError = (e, kind) => {\r\n      this.emit(RoomEvent.MediaDevicesError, e, kind);\r\n    };\r\n    this.onLocalParticipantPermissionsChanged = prevPermissions => {\r\n      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\r\n    };\r\n    this.onLocalChatMessageSent = msg => {\r\n      this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\r\n    };\r\n    this.setMaxListeners(100);\r\n    this.remoteParticipants = new Map();\r\n    this.sidToIdentity = new Map();\r\n    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\r\n    this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\r\n    this.transcriptionReceivedTimes = new Map();\r\n    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\r\n    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\r\n    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\r\n    this.maybeCreateEngine();\r\n    this.disconnectLock = new _();\r\n    this.localParticipant = new LocalParticipant('', '', this.engine, this.options, this.rpcHandlers);\r\n    if (this.options.videoCaptureDefaults.deviceId) {\r\n      this.localParticipant.activeDeviceMap.set('videoinput', unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\r\n    }\r\n    if (this.options.audioCaptureDefaults.deviceId) {\r\n      this.localParticipant.activeDeviceMap.set('audioinput', unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\r\n    }\r\n    if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\r\n      this.switchActiveDevice('audiooutput', unwrapConstraint(this.options.audioOutput.deviceId)).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\r\n    }\r\n    if (this.options.e2ee) {\r\n      this.setupE2EE();\r\n    }\r\n    if (isWeb()) {\r\n      const abortController = new AbortController();\r\n      // in order to catch device changes prior to room connection we need to register the event in the constructor\r\n      (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener('devicechange', this.handleDeviceChange, {\r\n        signal: abortController.signal\r\n      });\r\n      if (Room.cleanupRegistry) {\r\n        Room.cleanupRegistry.register(this, () => {\r\n          abortController.abort();\r\n        });\r\n      }\r\n    }\r\n  }\r\n  registerTextStreamHandler(topic, callback) {\r\n    if (this.textStreamHandlers.has(topic)) {\r\n      throw new TypeError(\"A text stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\r\n    }\r\n    this.textStreamHandlers.set(topic, callback);\r\n  }\r\n  unregisterTextStreamHandler(topic) {\r\n    this.textStreamHandlers.delete(topic);\r\n  }\r\n  registerByteStreamHandler(topic, callback) {\r\n    if (this.byteStreamHandlers.has(topic)) {\r\n      throw new TypeError(\"A byte stream handler for topic \\\"\".concat(topic, \"\\\" has already been set.\"));\r\n    }\r\n    this.byteStreamHandlers.set(topic, callback);\r\n  }\r\n  unregisterByteStreamHandler(topic) {\r\n    this.byteStreamHandlers.delete(topic);\r\n  }\r\n  /**\r\n   * Establishes the participant as a receiver for calls of the specified RPC method.\r\n   *\r\n   * @param method - The name of the indicated RPC method\r\n   * @param handler - Will be invoked when an RPC request for this method is received\r\n   * @returns A promise that resolves when the method is successfully registered\r\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * room.localParticipant?.registerRpcMethod(\r\n   *   'greet',\r\n   *   async (data: RpcInvocationData) => {\r\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\r\n   *     return `Hello, ${data.callerIdentity}!`;\r\n   *   }\r\n   * );\r\n   * ```\r\n   *\r\n   * The handler should return a Promise that resolves to a string.\r\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\r\n   *\r\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\r\n   * and they will be received on the caller's side with the message intact.\r\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\r\n   */\r\n  registerRpcMethod(method, handler) {\r\n    if (this.rpcHandlers.has(method)) {\r\n      throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\r\n    }\r\n    this.rpcHandlers.set(method, handler);\r\n  }\r\n  /**\r\n   * Unregisters a previously registered RPC method.\r\n   *\r\n   * @param method - The name of the RPC method to unregister\r\n   */\r\n  unregisterRpcMethod(method) {\r\n    this.rpcHandlers.delete(method);\r\n  }\r\n  handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.engine.publishRpcAck(callerIdentity, requestId);\r\n      if (version !== 1) {\r\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_VERSION'));\r\n        return;\r\n      }\r\n      const handler = this.rpcHandlers.get(method);\r\n      if (!handler) {\r\n        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn('UNSUPPORTED_METHOD'));\r\n        return;\r\n      }\r\n      let responseError = null;\r\n      let responsePayload = null;\r\n      try {\r\n        const response = yield handler({\r\n          requestId,\r\n          callerIdentity,\r\n          payload,\r\n          responseTimeout\r\n        });\r\n        if (byteLength(response) > MAX_PAYLOAD_BYTES) {\r\n          responseError = RpcError.builtIn('RESPONSE_PAYLOAD_TOO_LARGE');\r\n          console.warn(\"RPC Response payload too large for \".concat(method));\r\n        } else {\r\n          responsePayload = response;\r\n        }\r\n      } catch (error) {\r\n        if (error instanceof RpcError) {\r\n          responseError = error;\r\n        } else {\r\n          console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\r\n          responseError = RpcError.builtIn('APPLICATION_ERROR');\r\n        }\r\n      }\r\n      yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\r\n    });\r\n  }\r\n  /**\r\n   * @experimental\r\n   */\r\n  setE2EEEnabled(enabled) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.e2eeManager) {\r\n        yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);\r\n        if (this.localParticipant.identity !== '') {\r\n          this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\r\n        }\r\n      } else {\r\n        throw Error('e2ee not configured, please set e2ee settings within the room options');\r\n      }\r\n    });\r\n  }\r\n  setupE2EE() {\r\n    var _a;\r\n    if (this.options.e2ee) {\r\n      if ('e2eeManager' in this.options.e2ee) {\r\n        this.e2eeManager = this.options.e2ee.e2eeManager;\r\n      } else {\r\n        this.e2eeManager = new E2EEManager(this.options.e2ee);\r\n      }\r\n      this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {\r\n        if (isLocalParticipant(participant)) {\r\n          this.isE2EEEnabled = enabled;\r\n        }\r\n        this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\r\n      });\r\n      this.e2eeManager.on(EncryptionEvent.EncryptionError, error => this.emit(RoomEvent.EncryptionError, error));\r\n      (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\r\n    }\r\n  }\r\n  get logContext() {\r\n    var _a;\r\n    return {\r\n      room: this.name,\r\n      roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\r\n      participant: this.localParticipant.identity,\r\n      pID: this.localParticipant.sid\r\n    };\r\n  }\r\n  /**\r\n   * if the current room has a participant with `recorder: true` in its JWT grant\r\n   **/\r\n  get isRecording() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\r\n  }\r\n  /**\r\n   * server assigned unique room id.\r\n   * returns once a sid has been issued by the server.\r\n   */\r\n  getSid() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state === ConnectionState.Disconnected) {\r\n        return '';\r\n      }\r\n      if (this.roomInfo && this.roomInfo.sid !== '') {\r\n        return this.roomInfo.sid;\r\n      }\r\n      return new Promise((resolve, reject) => {\r\n        const handleRoomUpdate = roomInfo => {\r\n          if (roomInfo.sid !== '') {\r\n            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n            resolve(roomInfo.sid);\r\n          }\r\n        };\r\n        this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n        this.once(RoomEvent.Disconnected, () => {\r\n          this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\r\n          reject('Room disconnected before room server id was available');\r\n        });\r\n      });\r\n    });\r\n  }\r\n  /** user assigned name, derived from JWT token */\r\n  get name() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\r\n  }\r\n  /** room metadata */\r\n  get metadata() {\r\n    var _a;\r\n    return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\r\n  }\r\n  get numParticipants() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\r\n  }\r\n  get numPublishers() {\r\n    var _a, _b;\r\n    return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\r\n  }\r\n  maybeCreateEngine() {\r\n    if (this.engine && !this.engine.isClosed) {\r\n      return;\r\n    }\r\n    this.engine = new RTCEngine(this.options);\r\n    this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {\r\n      this.onTrackAdded(mediaTrack, stream, receiver);\r\n    }).on(EngineEvent.Disconnected, reason => {\r\n      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\r\n    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {\r\n      this.clearConnectionReconcile();\r\n      this.isResuming = true;\r\n      this.log.info('Resuming signal connection', this.logContext);\r\n      if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\r\n        this.emit(RoomEvent.SignalReconnecting);\r\n      }\r\n    }).on(EngineEvent.Resumed, () => {\r\n      this.registerConnectionReconcile();\r\n      this.isResuming = false;\r\n      this.log.info('Resumed signal connection', this.logContext);\r\n      this.updateSubscriptions();\r\n      this.emitBufferedEvents();\r\n      if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\r\n        this.emit(RoomEvent.Reconnected);\r\n      }\r\n    }).on(EngineEvent.SignalResumed, () => {\r\n      this.bufferedEvents = [];\r\n      if (this.state === ConnectionState.Reconnecting || this.isResuming) {\r\n        this.sendSyncState();\r\n      }\r\n    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {\r\n      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\r\n        this.emit(RoomEvent.Reconnecting);\r\n      }\r\n    }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {\r\n      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\r\n    }).on(EngineEvent.LocalTrackSubscribed, subscribedSid => {\r\n      const trackPublication = this.localParticipant.getTrackPublications().find(_ref2 => {\r\n        let {\r\n          trackSid\r\n        } = _ref2;\r\n        return trackSid === subscribedSid;\r\n      });\r\n      if (!trackPublication) {\r\n        this.log.warn('could not find local track subscription for subscribed event', this.logContext);\r\n        return;\r\n      }\r\n      this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\r\n      this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\r\n    }).on(EngineEvent.RoomMoved, roomMoved => {\r\n      this.log.debug('room moved', roomMoved);\r\n      if (roomMoved.room) {\r\n        this.handleRoomUpdate(roomMoved.room);\r\n      }\r\n      this.remoteParticipants.forEach((participant, identity) => {\r\n        this.handleParticipantDisconnected(identity, participant);\r\n      });\r\n      this.emit(RoomEvent.Moved, roomMoved.room.name);\r\n      if (roomMoved.participant) {\r\n        this.handleParticipantUpdates([roomMoved.participant, ...roomMoved.otherParticipants]);\r\n      } else {\r\n        this.handleParticipantUpdates(roomMoved.otherParticipants);\r\n      }\r\n    });\r\n    if (this.localParticipant) {\r\n      this.localParticipant.setupEngine(this.engine);\r\n    }\r\n    if (this.e2eeManager) {\r\n      this.e2eeManager.setupEngine(this.engine);\r\n    }\r\n  }\r\n  /**\r\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\r\n   * In particular, it requests device permissions by default if needed\r\n   * and makes sure the returned device does not consist of dummy devices\r\n   * @param kind\r\n   * @returns a list of available local devices\r\n   */\r\n  static getLocalDevices(kind) {\r\n    let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\r\n    return DeviceManager.getInstance().getDevices(kind, requestPermissions);\r\n  }\r\n  /**\r\n   * prepareConnection should be called as soon as the page is loaded, in order\r\n   * to speed up the connection attempt. This function will\r\n   * - perform DNS resolution and pre-warm the DNS cache\r\n   * - establish TLS connection and cache TLS keys\r\n   *\r\n   * With LiveKit Cloud, it will also determine the best edge data center for\r\n   * the current client to connect to if a token is provided.\r\n   */\r\n  prepareConnection(url, token) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.state !== ConnectionState.Disconnected) {\r\n        return;\r\n      }\r\n      this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\r\n      try {\r\n        if (isCloud(new URL(url)) && token) {\r\n          this.regionUrlProvider = new RegionUrlProvider(url, token);\r\n          const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\r\n          // we will not replace the regionUrl if an attempt had already started\r\n          // to avoid overriding regionUrl after a new connection attempt had started\r\n          if (regionUrl && this.state === ConnectionState.Disconnected) {\r\n            this.regionUrl = regionUrl;\r\n            yield fetch(toHttpUrl(regionUrl), {\r\n              method: 'HEAD'\r\n            });\r\n            this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\r\n          }\r\n        } else {\r\n          yield fetch(toHttpUrl(url), {\r\n            method: 'HEAD'\r\n          });\r\n        }\r\n      } catch (e) {\r\n        this.log.warn('could not prepare connection', Object.assign(Object.assign({}, this.logContext), {\r\n          error: e\r\n        }));\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * retrieves a participant by identity\r\n   * @param identity\r\n   * @returns\r\n   */\r\n  getParticipantByIdentity(identity) {\r\n    if (this.localParticipant.identity === identity) {\r\n      return this.localParticipant;\r\n    }\r\n    return this.remoteParticipants.get(identity);\r\n  }\r\n  clearConnectionFutures() {\r\n    this.connectFuture = undefined;\r\n  }\r\n  /**\r\n   * @internal for testing\r\n   */\r\n  simulateScenario(scenario, arg) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let postAction = () => {};\r\n      let req;\r\n      switch (scenario) {\r\n        case 'signal-reconnect':\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate disconnect');\r\n          break;\r\n        case 'speaker':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'speakerUpdate',\r\n              value: 3\r\n            }\r\n          });\r\n          break;\r\n        case 'node-failure':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'nodeFailure',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'server-leave':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'serverLeave',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'migration':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'migration',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'resume-reconnect':\r\n          this.engine.failNext();\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          break;\r\n        case 'disconnect-signal-on-resume':\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            // @ts-expect-error function is private\r\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          });\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'disconnectSignalOnResume',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'disconnect-signal-on-resume-no-messages':\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            // @ts-expect-error function is private\r\n            yield this.engine.client.handleOnClose('simulate resume-disconnect');\r\n          });\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'disconnectSignalOnResumeNoMessages',\r\n              value: true\r\n            }\r\n          });\r\n          break;\r\n        case 'full-reconnect':\r\n          this.engine.fullReconnectOnNext = true;\r\n          // @ts-expect-error function is private\r\n          yield this.engine.client.handleOnClose('simulate full-reconnect');\r\n          break;\r\n        case 'force-tcp':\r\n        case 'force-tls':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'switchCandidateProtocol',\r\n              value: scenario === 'force-tls' ? 2 : 1\r\n            }\r\n          });\r\n          postAction = () => __awaiter(this, void 0, void 0, function* () {\r\n            const onLeave = this.engine.client.onLeave;\r\n            if (onLeave) {\r\n              onLeave(new LeaveRequest({\r\n                reason: DisconnectReason.CLIENT_INITIATED,\r\n                action: LeaveRequest_Action.RECONNECT\r\n              }));\r\n            }\r\n          });\r\n          break;\r\n        case 'subscriber-bandwidth':\r\n          if (arg === undefined || typeof arg !== 'number') {\r\n            throw new Error('subscriber-bandwidth requires a number as argument');\r\n          }\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'subscriberBandwidth',\r\n              value: numberToBigInt(arg)\r\n            }\r\n          });\r\n          break;\r\n        case 'leave-full-reconnect':\r\n          req = new SimulateScenario({\r\n            scenario: {\r\n              case: 'leaveRequestFullReconnect',\r\n              value: true\r\n            }\r\n          });\r\n      }\r\n      if (req) {\r\n        yield this.engine.client.sendSimulateScenario(req);\r\n        yield postAction();\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Returns true if audio playback is enabled\r\n   */\r\n  get canPlaybackAudio() {\r\n    return this.audioEnabled;\r\n  }\r\n  /**\r\n   * Returns true if video playback is enabled\r\n   */\r\n  get canPlaybackVideo() {\r\n    return !this.isVideoPlaybackBlocked;\r\n  }\r\n  getActiveDevice(kind) {\r\n    return this.localParticipant.activeDeviceMap.get(kind);\r\n  }\r\n  /**\r\n   * Switches all active devices used in this room to the given device.\r\n   *\r\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\r\n   *\r\n   * @param kind use `videoinput` for camera track,\r\n   *  `audioinput` for microphone track,\r\n   *  `audiooutput` to set speaker for all incoming audio tracks\r\n   * @param deviceId\r\n   */\r\n  switchActiveDevice(kind_1, deviceId_1) {\r\n    return __awaiter(this, arguments, void 0, function (kind, deviceId) {\r\n      var _this3 = this;\r\n      let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      return function* () {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        var _h;\r\n        let success = true;\r\n        let needsUpdateWithoutTracks = false;\r\n        const deviceConstraint = exact ? {\r\n          exact: deviceId\r\n        } : deviceId;\r\n        if (kind === 'audioinput') {\r\n          needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;\r\n          const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\r\n          _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\r\n          const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter(track => track.source === Track.Source.Microphone);\r\n          try {\r\n            success = (yield Promise.all(tracks.map(t => {\r\n              var _a;\r\n              return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\r\n            }))).every(val => val === true);\r\n          } catch (e) {\r\n            _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        } else if (kind === 'videoinput') {\r\n          needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;\r\n          const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\r\n          _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\r\n          const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter(track => track.source === Track.Source.Camera);\r\n          try {\r\n            success = (yield Promise.all(tracks.map(t => {\r\n              var _a;\r\n              return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\r\n            }))).every(val => val === true);\r\n          } catch (e) {\r\n            _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        } else if (kind === 'audiooutput') {\r\n          if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !('setSinkId' in _this3.audioContext)) {\r\n            throw new Error('cannot switch audio output, setSinkId not supported');\r\n          }\r\n          if (_this3.options.webAudioMix) {\r\n            // setting `default` for web audio output doesn't work, so we need to normalize the id before\r\n            deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId('audiooutput', deviceId)) !== null && _c !== void 0 ? _c : '';\r\n          }\r\n          (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};\r\n          const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\r\n          _this3.options.audioOutput.deviceId = deviceId;\r\n          try {\r\n            if (_this3.options.webAudioMix) {\r\n              // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\r\n              (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\r\n            }\r\n            // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\r\n            // see https://issues.chromium.org/issues/40252911#comment7\r\n            yield Promise.all(Array.from(_this3.remoteParticipants.values()).map(p => p.setAudioOutput({\r\n              deviceId\r\n            })));\r\n          } catch (e) {\r\n            _this3.options.audioOutput.deviceId = prevDeviceId;\r\n            throw e;\r\n          }\r\n        }\r\n        if (needsUpdateWithoutTracks || kind === 'audiooutput') {\r\n          // if there are not active tracks yet or we're switching audiooutput, we need to manually update the active device map here as changing audio output won't result in a track restart\r\n          _this3.localParticipant.activeDeviceMap.set(kind, kind === 'audiooutput' && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);\r\n          _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\r\n        }\r\n        return success;\r\n      }();\r\n    });\r\n  }\r\n  setupLocalParticipantEvents() {\r\n    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\r\n  }\r\n  recreateEngine() {\r\n    var _a;\r\n    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\r\n    /* @ts-ignore */\r\n    this.engine = undefined;\r\n    this.isResuming = false;\r\n    // clear out existing remote participants, since they may have attached\r\n    // the old engine\r\n    this.remoteParticipants.clear();\r\n    this.sidToIdentity.clear();\r\n    this.bufferedEvents = [];\r\n    this.maybeCreateEngine();\r\n  }\r\n  onTrackAdded(mediaTrack, stream, receiver) {\r\n    // don't fire onSubscribed when connecting\r\n    // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\r\n    // at that time, ICE connectivity has not been established so the track is not\r\n    // technically subscribed.\r\n    // We'll defer these events until when the room is connected or eventually disconnected.\r\n    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\r\n      const reconnectedHandler = () => {\r\n        this.onTrackAdded(mediaTrack, stream, receiver);\r\n        cleanup();\r\n      };\r\n      const cleanup = () => {\r\n        this.off(RoomEvent.Reconnected, reconnectedHandler);\r\n        this.off(RoomEvent.Connected, reconnectedHandler);\r\n        this.off(RoomEvent.Disconnected, cleanup);\r\n      };\r\n      this.once(RoomEvent.Reconnected, reconnectedHandler);\r\n      this.once(RoomEvent.Connected, reconnectedHandler);\r\n      this.once(RoomEvent.Disconnected, cleanup);\r\n      return;\r\n    }\r\n    if (this.state === ConnectionState.Disconnected) {\r\n      this.log.warn('skipping incoming track after Room disconnected', this.logContext);\r\n      return;\r\n    }\r\n    if (mediaTrack.readyState === 'ended') {\r\n      this.log.info('skipping incoming track as it already ended', this.logContext);\r\n      return;\r\n    }\r\n    const parts = unpackStreamId(stream.id);\r\n    const participantSid = parts[0];\r\n    let streamId = parts[1];\r\n    let trackId = mediaTrack.id;\r\n    // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\r\n    // and generates its own track id instead of infer from sdp track id.\r\n    if (streamId && streamId.startsWith('TR')) trackId = streamId;\r\n    if (participantSid === this.localParticipant.sid) {\r\n      this.log.warn('tried to create RemoteParticipant for local participant', this.logContext);\r\n      return;\r\n    }\r\n    const participant = Array.from(this.remoteParticipants.values()).find(p => p.sid === participantSid);\r\n    if (!participant) {\r\n      this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\r\n      return;\r\n    }\r\n    let adaptiveStreamSettings;\r\n    if (this.options.adaptiveStream) {\r\n      if (typeof this.options.adaptiveStream === 'object') {\r\n        adaptiveStreamSettings = this.options.adaptiveStream;\r\n      } else {\r\n        adaptiveStreamSettings = {};\r\n      }\r\n    }\r\n    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\r\n  }\r\n  handleDisconnect() {\r\n    let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\r\n    let reason = arguments.length > 1 ? arguments[1] : undefined;\r\n    var _a;\r\n    this.clearConnectionReconcile();\r\n    this.isResuming = false;\r\n    this.bufferedEvents = [];\r\n    this.transcriptionReceivedTimes.clear();\r\n    if (this.state === ConnectionState.Disconnected) {\r\n      return;\r\n    }\r\n    this.regionUrl = undefined;\r\n    try {\r\n      this.remoteParticipants.forEach(p => {\r\n        p.trackPublications.forEach(pub => {\r\n          p.unpublishTrack(pub.trackSid);\r\n        });\r\n      });\r\n      this.localParticipant.trackPublications.forEach(pub => {\r\n        var _a, _b, _c;\r\n        if (pub.track) {\r\n          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\r\n        }\r\n        if (shouldStopTracks) {\r\n          (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\r\n          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\r\n        } else {\r\n          (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\r\n        }\r\n      });\r\n      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\r\n      this.localParticipant.trackPublications.clear();\r\n      this.localParticipant.videoTrackPublications.clear();\r\n      this.localParticipant.audioTrackPublications.clear();\r\n      this.remoteParticipants.clear();\r\n      this.sidToIdentity.clear();\r\n      this.activeSpeakers = [];\r\n      if (this.audioContext && typeof this.options.webAudioMix === 'boolean') {\r\n        this.audioContext.close();\r\n        this.audioContext = undefined;\r\n      }\r\n      if (isWeb()) {\r\n        window.removeEventListener('beforeunload', this.onPageLeave);\r\n        window.removeEventListener('pagehide', this.onPageLeave);\r\n        window.removeEventListener('freeze', this.onPageLeave);\r\n        (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener('devicechange', this.handleDeviceChange);\r\n      }\r\n    } finally {\r\n      this.setAndEmitConnectionState(ConnectionState.Disconnected);\r\n      this.emit(RoomEvent.Disconnected, reason);\r\n    }\r\n  }\r\n  handleParticipantDisconnected(identity, participant) {\r\n    var _a;\r\n    // remove and send event\r\n    this.remoteParticipants.delete(identity);\r\n    if (!participant) {\r\n      return;\r\n    }\r\n    participant.trackPublications.forEach(publication => {\r\n      participant.unpublishTrack(publication.trackSid, true);\r\n    });\r\n    this.emit(RoomEvent.ParticipantDisconnected, participant);\r\n    participant.setDisconnected();\r\n    (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\r\n  }\r\n  handleStreamHeader(streamHeader, participantIdentity) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      if (streamHeader.contentHeader.case === 'byteHeader') {\r\n        const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\r\n        if (!streamHandlerCallback) {\r\n          this.log.debug('ignoring incoming byte stream due to no handler for topic', streamHeader.topic);\r\n          return;\r\n        }\r\n        let streamController;\r\n        const info = {\r\n          id: streamHeader.streamId,\r\n          name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : 'unknown',\r\n          mimeType: streamHeader.mimeType,\r\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\r\n          topic: streamHeader.topic,\r\n          timestamp: bigIntToNumber(streamHeader.timestamp),\r\n          attributes: streamHeader.attributes\r\n        };\r\n        const stream = new ReadableStream({\r\n          start: controller => {\r\n            streamController = controller;\r\n            this.byteStreamControllers.set(streamHeader.streamId, {\r\n              info,\r\n              controller: streamController,\r\n              startTime: Date.now()\r\n            });\r\n          }\r\n        });\r\n        streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\r\n          identity: participantIdentity\r\n        });\r\n      } else if (streamHeader.contentHeader.case === 'textHeader') {\r\n        const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\r\n        if (!streamHandlerCallback) {\r\n          this.log.debug('ignoring incoming text stream due to no handler for topic', streamHeader.topic);\r\n          return;\r\n        }\r\n        let streamController;\r\n        const info = {\r\n          id: streamHeader.streamId,\r\n          mimeType: streamHeader.mimeType,\r\n          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\r\n          topic: streamHeader.topic,\r\n          timestamp: Number(streamHeader.timestamp),\r\n          attributes: streamHeader.attributes\r\n        };\r\n        const stream = new ReadableStream({\r\n          start: controller => {\r\n            streamController = controller;\r\n            this.textStreamControllers.set(streamHeader.streamId, {\r\n              info,\r\n              controller: streamController,\r\n              startTime: Date.now()\r\n            });\r\n          }\r\n        });\r\n        streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\r\n          identity: participantIdentity\r\n        });\r\n      }\r\n    });\r\n  }\r\n  handleStreamChunk(chunk) {\r\n    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\r\n    if (fileBuffer) {\r\n      if (chunk.content.length > 0) {\r\n        fileBuffer.controller.enqueue(chunk);\r\n      }\r\n    }\r\n    const textBuffer = this.textStreamControllers.get(chunk.streamId);\r\n    if (textBuffer) {\r\n      if (chunk.content.length > 0) {\r\n        textBuffer.controller.enqueue(chunk);\r\n      }\r\n    }\r\n  }\r\n  handleStreamTrailer(trailer) {\r\n    const textBuffer = this.textStreamControllers.get(trailer.streamId);\r\n    if (textBuffer) {\r\n      textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\r\n      textBuffer.controller.close();\r\n      this.textStreamControllers.delete(trailer.streamId);\r\n    }\r\n    const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\r\n    if (fileBuffer) {\r\n      {\r\n        fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\r\n        fileBuffer.controller.close();\r\n        this.byteStreamControllers.delete(trailer.streamId);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * attempt to select the default devices if the previously selected devices are no longer available after a device change event\r\n   */\r\n  selectDefaultDevices() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      const previousDevices = DeviceManager.getInstance().previousDevices;\r\n      // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\r\n      const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\r\n      const browser = getBrowser();\r\n      if ((browser === null || browser === void 0 ? void 0 : browser.name) === 'Chrome' && browser.os !== 'iOS') {\r\n        for (let availableDevice of availableDevices) {\r\n          const previousDevice = previousDevices.find(info => info.deviceId === availableDevice.deviceId);\r\n          if (previousDevice && previousDevice.label !== '' && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\r\n            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\r\n            if (this.getActiveDevice(availableDevice.kind) === 'default') {\r\n              // emit an active device change event only if the selected output device is actually on `default`\r\n              this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      const kinds = ['audiooutput', 'audioinput', 'videoinput'];\r\n      for (let kind of kinds) {\r\n        const targetSource = kindToSource(kind);\r\n        const targetPublication = this.localParticipant.getTrackPublication(targetSource);\r\n        if (targetPublication && ((_a = targetPublication.track) === null || _a === void 0 ? void 0 : _a.isUserProvided)) {\r\n          // if the track is user provided, we don't want to switch devices on behalf of the user\r\n          continue;\r\n        }\r\n        const devicesOfKind = availableDevices.filter(d => d.kind === kind);\r\n        const activeDevice = this.getActiveDevice(kind);\r\n        if (activeDevice === ((_b = previousDevices.filter(info => info.kind === kind)[0]) === null || _b === void 0 ? void 0 : _b.deviceId)) {\r\n          // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\r\n          // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\r\n          if (devicesOfKind.length > 0 && ((_c = devicesOfKind[0]) === null || _c === void 0 ? void 0 : _c.deviceId) !== activeDevice) {\r\n            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\r\n            continue;\r\n          }\r\n        }\r\n        if (kind === 'audioinput' && !isSafariBased() || kind === 'videoinput') {\r\n          // airpods on Safari need special handling for audioinput as the track doesn't end as soon as you take them out\r\n          continue;\r\n        }\r\n        // switch to first available device if previously active device is not available any more\r\n        if (devicesOfKind.length > 0 && !devicesOfKind.find(deviceInfo => deviceInfo.deviceId === this.getActiveDevice(kind)) && (\r\n        // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback\r\n        kind !== 'audiooutput' || !isSafariBased())) {\r\n          yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  acquireAudioContext() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      if (typeof this.options.webAudioMix !== 'boolean' && this.options.webAudioMix.audioContext) {\r\n        // override audio context with custom audio context if supplied by user\r\n        this.audioContext = this.options.webAudioMix.audioContext;\r\n      } else if (!this.audioContext || this.audioContext.state === 'closed') {\r\n        // by using an AudioContext, it reduces lag on audio elements\r\n        // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\r\n        this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\r\n      }\r\n      if (this.options.webAudioMix) {\r\n        this.remoteParticipants.forEach(participant => participant.setAudioContext(this.audioContext));\r\n      }\r\n      this.localParticipant.setAudioContext(this.audioContext);\r\n      if (this.audioContext && this.audioContext.state === 'suspended') {\r\n        // for iOS a newly created AudioContext is always in `suspended` state.\r\n        // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\r\n        try {\r\n          yield Promise.race([this.audioContext.resume(), sleep(200)]);\r\n        } catch (e) {\r\n          this.log.warn('Could not resume audio context', Object.assign(Object.assign({}, this.logContext), {\r\n            error: e\r\n          }));\r\n        }\r\n      }\r\n      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === 'running';\r\n      if (newContextIsRunning !== this.canPlaybackAudio) {\r\n        this.audioEnabled = newContextIsRunning;\r\n        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\r\n      }\r\n    });\r\n  }\r\n  createParticipant(identity, info) {\r\n    var _a;\r\n    let participant;\r\n    if (info) {\r\n      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\r\n        loggerContextCb: () => this.logContext,\r\n        loggerName: this.options.loggerName\r\n      });\r\n    } else {\r\n      participant = new RemoteParticipant(this.engine.client, '', identity, undefined, undefined, undefined, {\r\n        loggerContextCb: () => this.logContext,\r\n        loggerName: this.options.loggerName\r\n      });\r\n    }\r\n    if (this.options.webAudioMix) {\r\n      participant.setAudioContext(this.audioContext);\r\n    }\r\n    if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\r\n      participant.setAudioOutput(this.options.audioOutput).catch(e => this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\r\n    }\r\n    return participant;\r\n  }\r\n  getOrCreateParticipant(identity, info) {\r\n    if (this.remoteParticipants.has(identity)) {\r\n      const existingParticipant = this.remoteParticipants.get(identity);\r\n      if (info) {\r\n        const wasUpdated = existingParticipant.updateInfo(info);\r\n        if (wasUpdated) {\r\n          this.sidToIdentity.set(info.sid, info.identity);\r\n        }\r\n      }\r\n      return existingParticipant;\r\n    }\r\n    const participant = this.createParticipant(identity, info);\r\n    this.remoteParticipants.set(identity, participant);\r\n    this.sidToIdentity.set(info.sid, info.identity);\r\n    // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\r\n    // firing here to make sure that `ParticipantConnected` fires before the initial track events\r\n    this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\r\n    // also forward events\r\n    // trackPublished is only fired for tracks added after both local participant\r\n    // and remote participant joined the room\r\n    participant.on(ParticipantEvent.TrackPublished, trackPublication => {\r\n      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\r\n    }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {\r\n      // monitor playback status\r\n      if (track.kind === Track.Kind.Audio) {\r\n        track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\r\n        track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\r\n      } else if (track.kind === Track.Kind.Video) {\r\n        track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\r\n        track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\r\n      }\r\n      this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\r\n    }).on(ParticipantEvent.TrackUnpublished, publication => {\r\n      this.emit(RoomEvent.TrackUnpublished, publication, participant);\r\n    }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {\r\n      this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\r\n    }).on(ParticipantEvent.TrackMuted, pub => {\r\n      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\r\n    }).on(ParticipantEvent.TrackUnmuted, pub => {\r\n      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\r\n    }).on(ParticipantEvent.ParticipantMetadataChanged, metadata => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\r\n    }).on(ParticipantEvent.ParticipantNameChanged, name => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\r\n    }).on(ParticipantEvent.AttributesChanged, changedAttributes => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\r\n    }).on(ParticipantEvent.ConnectionQualityChanged, quality => {\r\n      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\r\n    }).on(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\r\n    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {\r\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\r\n    }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {\r\n      this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\r\n    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {\r\n      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\r\n    }).on(ParticipantEvent.Active, () => {\r\n      this.emitWhenConnected(RoomEvent.ParticipantActive, participant);\r\n      if (participant.kind === ParticipantInfo_Kind.AGENT) {\r\n        this.localParticipant.setActiveAgent(participant);\r\n      }\r\n    });\r\n    // update info at the end after callbacks have been set up\r\n    if (info) {\r\n      participant.updateInfo(info);\r\n    }\r\n    return participant;\r\n  }\r\n  sendSyncState() {\r\n    const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {\r\n      acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\r\n      return acc;\r\n    }, []);\r\n    const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\r\n    this.engine.sendSyncState(remoteTracks, localTracks);\r\n  }\r\n  /**\r\n   * After resuming, we'll need to notify the server of the current\r\n   * subscription settings.\r\n   */\r\n  updateSubscriptions() {\r\n    for (const p of this.remoteParticipants.values()) {\r\n      for (const pub of p.videoTrackPublications.values()) {\r\n        if (pub.isSubscribed && isRemotePub(pub)) {\r\n          pub.emitTrackUpdate();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  getRemoteParticipantBySid(sid) {\r\n    const identity = this.sidToIdentity.get(sid);\r\n    if (identity) {\r\n      return this.remoteParticipants.get(identity);\r\n    }\r\n  }\r\n  registerConnectionReconcile() {\r\n    this.clearConnectionReconcile();\r\n    let consecutiveFailures = 0;\r\n    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {\r\n      if (\r\n      // ensure we didn't tear it down\r\n      !this.engine ||\r\n      // engine detected close, but Room missed it\r\n      this.engine.isClosed ||\r\n      // transports failed without notifying engine\r\n      !this.engine.verifyTransport()) {\r\n        consecutiveFailures++;\r\n        this.log.warn('detected connection state mismatch', Object.assign(Object.assign({}, this.logContext), {\r\n          numFailures: consecutiveFailures,\r\n          engine: this.engine ? {\r\n            closed: this.engine.isClosed,\r\n            transportsConnected: this.engine.verifyTransport()\r\n          } : undefined\r\n        }));\r\n        if (consecutiveFailures >= 3) {\r\n          this.recreateEngine();\r\n          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\r\n        }\r\n      } else {\r\n        consecutiveFailures = 0;\r\n      }\r\n    }, connectionReconcileFrequency);\r\n  }\r\n  clearConnectionReconcile() {\r\n    if (this.connectionReconcileInterval) {\r\n      CriticalTimers.clearInterval(this.connectionReconcileInterval);\r\n    }\r\n  }\r\n  setAndEmitConnectionState(state) {\r\n    if (state === this.state) {\r\n      // unchanged\r\n      return false;\r\n    }\r\n    this.state = state;\r\n    this.emit(RoomEvent.ConnectionStateChanged, this.state);\r\n    return true;\r\n  }\r\n  emitBufferedEvents() {\r\n    this.bufferedEvents.forEach(_ref3 => {\r\n      let [ev, args] = _ref3;\r\n      this.emit(ev, ...args);\r\n    });\r\n    this.bufferedEvents = [];\r\n  }\r\n  emitWhenConnected(event) {\r\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n      args[_key2 - 1] = arguments[_key2];\r\n    }\r\n    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\r\n      // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\r\n      this.bufferedEvents.push([event, args]);\r\n    } else if (this.state === ConnectionState.Connected) {\r\n      return this.emit(event, ...args);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Allows to populate a room with simulated participants.\r\n   * No actual connection to a server will be established, all state is\r\n   * @experimental\r\n   */\r\n  simulateParticipants(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const publishOptions = Object.assign({\r\n        audio: true,\r\n        video: true,\r\n        useRealTracks: false\r\n      }, options.publish);\r\n      const participantOptions = Object.assign({\r\n        count: 9,\r\n        audio: false,\r\n        video: true,\r\n        aspectRatios: [1.66, 1.7, 1.3]\r\n      }, options.participants);\r\n      this.handleDisconnect();\r\n      this.roomInfo = new Room$1({\r\n        sid: 'RM_SIMULATED',\r\n        name: 'simulated-room',\r\n        emptyTimeout: 0,\r\n        maxParticipants: 0,\r\n        creationTime: protoInt64.parse(new Date().getTime()),\r\n        metadata: '',\r\n        numParticipants: 1,\r\n        numPublishers: 1,\r\n        turnPassword: '',\r\n        enabledCodecs: [],\r\n        activeRecording: false\r\n      });\r\n      this.localParticipant.updateInfo(new ParticipantInfo({\r\n        identity: 'simulated-local',\r\n        name: 'local-name'\r\n      }));\r\n      this.setupLocalParticipantEvents();\r\n      this.emit(RoomEvent.SignalConnected);\r\n      this.emit(RoomEvent.Connected);\r\n      this.setAndEmitConnectionState(ConnectionState.Connected);\r\n      if (publishOptions.video) {\r\n        const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\r\n          source: TrackSource.CAMERA,\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          type: TrackType.AUDIO,\r\n          name: 'video-dummy'\r\n        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\r\n          video: true\r\n        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        }), {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        // @ts-ignore\r\n        this.localParticipant.addTrackPublication(camPub);\r\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\r\n      }\r\n      if (publishOptions.audio) {\r\n        const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\r\n          source: TrackSource.MICROPHONE,\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          type: TrackType.AUDIO\r\n        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\r\n          audio: true\r\n        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        }), {\r\n          loggerName: this.options.loggerName,\r\n          loggerContextCb: () => this.logContext\r\n        });\r\n        // @ts-ignore\r\n        this.localParticipant.addTrackPublication(audioPub);\r\n        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\r\n      }\r\n      for (let i = 0; i < participantOptions.count - 1; i += 1) {\r\n        let info = new ParticipantInfo({\r\n          sid: Math.floor(Math.random() * 10000).toString(),\r\n          identity: \"simulated-\".concat(i),\r\n          state: ParticipantInfo_State.ACTIVE,\r\n          tracks: [],\r\n          joinedAt: protoInt64.parse(Date.now())\r\n        });\r\n        const p = this.getOrCreateParticipant(info.identity, info);\r\n        if (participantOptions.video) {\r\n          const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\r\n          const videoTrack = new TrackInfo({\r\n            source: TrackSource.CAMERA,\r\n            sid: Math.floor(Math.random() * 10000).toString(),\r\n            type: TrackType.AUDIO\r\n          });\r\n          p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());\r\n          info.tracks = [...info.tracks, videoTrack];\r\n        }\r\n        if (participantOptions.audio) {\r\n          const dummyTrack = getEmptyAudioStreamTrack();\r\n          const audioTrack = new TrackInfo({\r\n            source: TrackSource.MICROPHONE,\r\n            sid: Math.floor(Math.random() * 10000).toString(),\r\n            type: TrackType.AUDIO\r\n          });\r\n          p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());\r\n          info.tracks = [...info.tracks, audioTrack];\r\n        }\r\n        p.updateInfo(info);\r\n      }\r\n    });\r\n  }\r\n  // /** @internal */\r\n  emit(event) {\r\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\r\n      args[_key3 - 1] = arguments[_key3];\r\n    }\r\n    // active speaker updates are too spammy\r\n    if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\r\n      // only extract logContext from arguments in order to avoid logging the whole object tree\r\n      const minimizedArgs = mapArgs(args).filter(arg => arg !== undefined);\r\n      this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\r\n        event,\r\n        args: minimizedArgs\r\n      }));\r\n    }\r\n    return super.emit(event, ...args);\r\n  }\r\n}\r\nRoom.cleanupRegistry = typeof FinalizationRegistry !== 'undefined' && new FinalizationRegistry(cleanup => {\r\n  cleanup();\r\n});\r\nfunction mapArgs(args) {\r\n  return args.map(arg => {\r\n    if (!arg) {\r\n      return;\r\n    }\r\n    if (Array.isArray(arg)) {\r\n      return mapArgs(arg);\r\n    }\r\n    if (typeof arg === 'object') {\r\n      return 'logContext' in arg ? arg.logContext : undefined;\r\n    }\r\n    return arg;\r\n  });\r\n}\r\n\r\n// This file was generated from JSON Schema using quicktype, do not modify it directly.\r\n// The code generation lives at https://github.com/livekit/attribute-definitions\r\n//\r\n// To parse this data:\r\n//\r\n//   import { Convert, AgentAttributes, TranscriptionAttributes } from \"./file\";\r\n//\r\n//   const agentAttributes = Convert.toAgentAttributes(json);\r\n//   const transcriptionAttributes = Convert.toTranscriptionAttributes(json);\r\n// Converts JSON strings to/from your types\r\nclass Convert {\r\n  static toAgentAttributes(json) {\r\n    return JSON.parse(json);\r\n  }\r\n  static agentAttributesToJson(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n  static toTranscriptionAttributes(json) {\r\n    return JSON.parse(json);\r\n  }\r\n  static transcriptionAttributesToJson(value) {\r\n    return JSON.stringify(value);\r\n  }\r\n}\r\n\r\nvar attributeTypings = /*#__PURE__*/Object.freeze({\r\n  __proto__: null,\r\n  Convert: Convert\r\n});\r\n\r\nvar CheckStatus;\r\n(function (CheckStatus) {\r\n  CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\r\n  CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\r\n  CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\r\n  CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\r\n  CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\r\n})(CheckStatus || (CheckStatus = {}));\r\nclass Checker extends eventsExports.EventEmitter {\r\n  constructor(url, token) {\r\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    super();\r\n    this.status = CheckStatus.IDLE;\r\n    this.logs = [];\r\n    this.options = {};\r\n    this.url = url;\r\n    this.token = token;\r\n    this.name = this.constructor.name;\r\n    this.room = new Room(options.roomOptions);\r\n    this.connectOptions = options.connectOptions;\r\n    this.options = options;\r\n  }\r\n  run(onComplete) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.status !== CheckStatus.IDLE) {\r\n        throw Error('check is running already');\r\n      }\r\n      this.setStatus(CheckStatus.RUNNING);\r\n      try {\r\n        yield this.perform();\r\n      } catch (err) {\r\n        if (err instanceof Error) {\r\n          if (this.options.errorsAsWarnings) {\r\n            this.appendWarning(err.message);\r\n          } else {\r\n            this.appendError(err.message);\r\n          }\r\n        }\r\n      }\r\n      yield this.disconnect();\r\n      // sleep for a bit to ensure disconnect\r\n      yield new Promise(resolve => setTimeout(resolve, 500));\r\n      // @ts-ignore\r\n      if (this.status !== CheckStatus.SKIPPED) {\r\n        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\r\n      }\r\n      if (onComplete) {\r\n        onComplete();\r\n      }\r\n      return this.getInfo();\r\n    });\r\n  }\r\n  isSuccess() {\r\n    return !this.logs.some(l => l.level === 'error');\r\n  }\r\n  connect(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.room.state === ConnectionState.Connected) {\r\n        return this.room;\r\n      }\r\n      if (!url) {\r\n        url = this.url;\r\n      }\r\n      yield this.room.connect(url, this.token, this.connectOptions);\r\n      return this.room;\r\n    });\r\n  }\r\n  disconnect() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      if (this.room && this.room.state !== ConnectionState.Disconnected) {\r\n        yield this.room.disconnect();\r\n        // wait for it to go through\r\n        yield new Promise(resolve => setTimeout(resolve, 500));\r\n      }\r\n    });\r\n  }\r\n  skip() {\r\n    this.setStatus(CheckStatus.SKIPPED);\r\n  }\r\n  switchProtocol(protocol) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let hasReconnecting = false;\r\n      let hasReconnected = false;\r\n      this.room.on(RoomEvent.Reconnecting, () => {\r\n        hasReconnecting = true;\r\n      });\r\n      this.room.once(RoomEvent.Reconnected, () => {\r\n        hasReconnected = true;\r\n      });\r\n      this.room.simulateScenario(\"force-\".concat(protocol));\r\n      yield new Promise(resolve => setTimeout(resolve, 1000));\r\n      if (!hasReconnecting) {\r\n        // no need to wait for reconnection\r\n        return;\r\n      }\r\n      // wait for 10 seconds for reconnection\r\n      const timeout = Date.now() + 10000;\r\n      while (Date.now() < timeout) {\r\n        if (hasReconnected) {\r\n          return;\r\n        }\r\n        yield sleep(100);\r\n      }\r\n      throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\r\n    });\r\n  }\r\n  appendMessage(message) {\r\n    this.logs.push({\r\n      level: 'info',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  appendWarning(message) {\r\n    this.logs.push({\r\n      level: 'warning',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  appendError(message) {\r\n    this.logs.push({\r\n      level: 'error',\r\n      message\r\n    });\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  setStatus(status) {\r\n    this.status = status;\r\n    this.emit('update', this.getInfo());\r\n  }\r\n  get engine() {\r\n    var _a;\r\n    return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\r\n  }\r\n  getInfo() {\r\n    return {\r\n      logs: this.logs,\r\n      name: this.name,\r\n      status: this.status,\r\n      description: this.description\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Checks for connections quality to closests Cloud regions and determining the best quality\r\n */\r\nclass CloudRegionCheck extends Checker {\r\n  get description() {\r\n    return 'Cloud regions';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const regionProvider = new RegionUrlProvider(this.url, this.token);\r\n      if (!regionProvider.isCloud()) {\r\n        this.skip();\r\n        return;\r\n      }\r\n      const regionStats = [];\r\n      const seenUrls = new Set();\r\n      for (let i = 0; i < 3; i++) {\r\n        const regionUrl = yield regionProvider.getNextBestRegionUrl();\r\n        if (!regionUrl) {\r\n          break;\r\n        }\r\n        if (seenUrls.has(regionUrl)) {\r\n          continue;\r\n        }\r\n        seenUrls.add(regionUrl);\r\n        const stats = yield this.checkCloudRegion(regionUrl);\r\n        this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\r\n        regionStats.push(stats);\r\n      }\r\n      regionStats.sort((a, b) => {\r\n        return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\r\n      });\r\n      const bestRegion = regionStats[0];\r\n      this.bestStats = bestRegion;\r\n      this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\r\n    });\r\n  }\r\n  getInfo() {\r\n    const info = super.getInfo();\r\n    info.data = this.bestStats;\r\n    return info;\r\n  }\r\n  checkCloudRegion(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      yield this.connect(url);\r\n      if (this.options.protocol === 'tcp') {\r\n        yield this.switchProtocol('tcp');\r\n      }\r\n      const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\r\n      if (!region) {\r\n        throw new Error('Region not found');\r\n      }\r\n      const writer = yield this.room.localParticipant.streamText({\r\n        topic: 'test'\r\n      });\r\n      const chunkSize = 1000; // each chunk is about 1000 bytes\r\n      const totalSize = 1000000; // approximately 1MB of data\r\n      const numChunks = totalSize / chunkSize; // will yield 1000 chunks\r\n      const chunkData = 'A'.repeat(chunkSize); // create a string of 1000 'A' characters\r\n      const startTime = Date.now();\r\n      for (let i = 0; i < numChunks; i++) {\r\n        yield writer.write(chunkData);\r\n      }\r\n      yield writer.close();\r\n      const endTime = Date.now();\r\n      const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\r\n      const regionStats = {\r\n        region: region,\r\n        rtt: 10000,\r\n        duration: endTime - startTime\r\n      };\r\n      stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\r\n        if (stat.type === 'candidate-pair' && stat.nominated) {\r\n          regionStats.rtt = stat.currentRoundTripTime * 1000;\r\n        }\r\n      });\r\n      yield this.disconnect();\r\n      return regionStats;\r\n    });\r\n  }\r\n}\r\n\r\nconst TEST_DURATION = 10000;\r\nclass ConnectionProtocolCheck extends Checker {\r\n  get description() {\r\n    return 'Connection via UDP vs TCP';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const udpStats = yield this.checkConnectionProtocol('udp');\r\n      const tcpStats = yield this.checkConnectionProtocol('tcp');\r\n      this.bestStats = udpStats;\r\n      // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\r\n      // 1. the bandwidth limitation is worse on UDP by 500ms\r\n      // 2. the packet loss is higher on UDP by 1%\r\n      if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\r\n        this.appendMessage('best connection quality via tcp');\r\n        this.bestStats = tcpStats;\r\n      } else {\r\n        this.appendMessage('best connection quality via udp');\r\n      }\r\n      const stats = this.bestStats;\r\n      this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\r\n      this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\r\n      this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\r\n      if (stats.packetsLost > 0) {\r\n        this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\r\n      }\r\n      if (stats.qualityLimitationDurations.bandwidth > 1) {\r\n        this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\r\n      }\r\n      if (stats.qualityLimitationDurations.cpu > 0) {\r\n        this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\r\n      }\r\n    });\r\n  }\r\n  getInfo() {\r\n    const info = super.getInfo();\r\n    info.data = this.bestStats;\r\n    return info;\r\n  }\r\n  checkConnectionProtocol(protocol) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      yield this.connect();\r\n      if (protocol === 'tcp') {\r\n        yield this.switchProtocol('tcp');\r\n      } else {\r\n        yield this.switchProtocol('udp');\r\n      }\r\n      // create a canvas with animated content\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = 1280;\r\n      canvas.height = 720;\r\n      const ctx = canvas.getContext('2d');\r\n      if (!ctx) {\r\n        throw new Error('Could not get canvas context');\r\n      }\r\n      let hue = 0;\r\n      const animate = () => {\r\n        hue = (hue + 1) % 360;\r\n        ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        requestAnimationFrame(animate);\r\n      };\r\n      animate();\r\n      // create video track from canvas\r\n      const stream = canvas.captureStream(30); // 30fps\r\n      const videoTrack = stream.getVideoTracks()[0];\r\n      // publish to room\r\n      const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\r\n        simulcast: false,\r\n        degradationPreference: 'maintain-resolution',\r\n        videoEncoding: {\r\n          maxBitrate: 2000000\r\n        }\r\n      });\r\n      const track = pub.track;\r\n      const protocolStats = {\r\n        protocol,\r\n        packetsLost: 0,\r\n        packetsSent: 0,\r\n        qualityLimitationDurations: {},\r\n        rttTotal: 0,\r\n        jitterTotal: 0,\r\n        bitrateTotal: 0,\r\n        count: 0\r\n      };\r\n      // gather stats once a second\r\n      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n        const stats = yield track.getRTCStatsReport();\r\n        stats === null || stats === void 0 ? void 0 : stats.forEach(stat => {\r\n          if (stat.type === 'outbound-rtp') {\r\n            protocolStats.packetsSent = stat.packetsSent;\r\n            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\r\n            protocolStats.bitrateTotal += stat.targetBitrate;\r\n            protocolStats.count++;\r\n          } else if (stat.type === 'remote-inbound-rtp') {\r\n            protocolStats.packetsLost = stat.packetsLost;\r\n            protocolStats.rttTotal += stat.roundTripTime;\r\n            protocolStats.jitterTotal += stat.jitter;\r\n          }\r\n        });\r\n      }), 1000);\r\n      // wait a bit to gather stats\r\n      yield new Promise(resolve => setTimeout(resolve, TEST_DURATION));\r\n      clearInterval(interval);\r\n      videoTrack.stop();\r\n      canvas.remove();\r\n      yield this.disconnect();\r\n      return protocolStats;\r\n    });\r\n  }\r\n}\r\n\r\nclass PublishAudioCheck extends Checker {\r\n  get description() {\r\n    return 'Can publish audio';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      const track = yield createLocalAudioTrack();\r\n      const trackIsSilent = yield detectSilence(track, 1000);\r\n      if (trackIsSilent) {\r\n        throw new Error('unable to detect audio from microphone');\r\n      }\r\n      this.appendMessage('detected audio from microphone');\r\n      room.localParticipant.publishTrack(track);\r\n      // wait for a few seconds to publish\r\n      yield new Promise(resolve => setTimeout(resolve, 3000));\r\n      // verify RTC stats that it's publishing\r\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\r\n      if (!stats) {\r\n        throw new Error('Could not get RTCStats');\r\n      }\r\n      let numPackets = 0;\r\n      stats.forEach(stat => {\r\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'audio' || !stat.kind && stat.mediaType === 'audio')) {\r\n          numPackets = stat.packetsSent;\r\n        }\r\n      });\r\n      if (numPackets === 0) {\r\n        throw new Error('Could not determine packets are sent');\r\n      }\r\n      this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\r\n    });\r\n  }\r\n}\r\n\r\nclass PublishVideoCheck extends Checker {\r\n  get description() {\r\n    return 'Can publish video';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      const track = yield createLocalVideoTrack();\r\n      // check if we have video from camera\r\n      yield this.checkForVideo(track.mediaStreamTrack);\r\n      room.localParticipant.publishTrack(track);\r\n      // wait for a few seconds to publish\r\n      yield new Promise(resolve => setTimeout(resolve, 5000));\r\n      // verify RTC stats that it's publishing\r\n      const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\r\n      if (!stats) {\r\n        throw new Error('Could not get RTCStats');\r\n      }\r\n      let numPackets = 0;\r\n      stats.forEach(stat => {\r\n        if (stat.type === 'outbound-rtp' && (stat.kind === 'video' || !stat.kind && stat.mediaType === 'video')) {\r\n          numPackets += stat.packetsSent;\r\n        }\r\n      });\r\n      if (numPackets === 0) {\r\n        throw new Error('Could not determine packets are sent');\r\n      }\r\n      this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\r\n    });\r\n  }\r\n  checkForVideo(track) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const stream = new MediaStream();\r\n      stream.addTrack(track.clone());\r\n      // Create video element to check frames\r\n      const video = document.createElement('video');\r\n      video.srcObject = stream;\r\n      video.muted = true;\r\n      yield new Promise(resolve => {\r\n        video.onplay = () => {\r\n          setTimeout(() => {\r\n            var _a, _b, _c, _d;\r\n            const canvas = document.createElement('canvas');\r\n            const settings = track.getSettings();\r\n            const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\r\n            const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            const ctx = canvas.getContext('2d');\r\n            // Draw video frame to canvas\r\n            ctx.drawImage(video, 0, 0);\r\n            // Get image data and check if all pixels are black\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n            const data = imageData.data;\r\n            let isAllBlack = true;\r\n            for (let i = 0; i < data.length; i += 4) {\r\n              if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\r\n                isAllBlack = false;\r\n                break;\r\n              }\r\n            }\r\n            if (isAllBlack) {\r\n              this.appendError('camera appears to be producing only black frames');\r\n            } else {\r\n              this.appendMessage('received video frames');\r\n            }\r\n            resolve();\r\n          }, 1000);\r\n        };\r\n        video.play();\r\n      });\r\n      video.remove();\r\n    });\r\n  }\r\n}\r\n\r\nclass ReconnectCheck extends Checker {\r\n  get description() {\r\n    return 'Resuming connection after interruption';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a;\r\n      const room = yield this.connect();\r\n      let reconnectingTriggered = false;\r\n      let reconnected = false;\r\n      let reconnectResolver;\r\n      const reconnectTimeout = new Promise(resolve => {\r\n        setTimeout(resolve, 5000);\r\n        reconnectResolver = resolve;\r\n      });\r\n      const handleReconnecting = () => {\r\n        reconnectingTriggered = true;\r\n      };\r\n      room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {\r\n        reconnected = true;\r\n        reconnectResolver(true);\r\n      });\r\n      (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\r\n      const onClose = room.engine.client.onClose;\r\n      if (onClose) {\r\n        onClose('');\r\n      }\r\n      yield reconnectTimeout;\r\n      if (!reconnectingTriggered) {\r\n        throw new Error('Did not attempt to reconnect');\r\n      } else if (!reconnected || room.state !== ConnectionState.Connected) {\r\n        this.appendWarning('reconnection is only possible in Redis-based configurations');\r\n        throw new Error('Not able to reconnect');\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass TURNCheck extends Checker {\r\n  get description() {\r\n    return 'Can connect via TURN';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b;\r\n      const signalClient = new SignalClient();\r\n      const joinRes = yield signalClient.join(this.url, this.token, {\r\n        autoSubscribe: true,\r\n        maxRetries: 0,\r\n        e2eeEnabled: false,\r\n        websocketTimeout: 15000\r\n      });\r\n      let hasTLS = false;\r\n      let hasTURN = false;\r\n      let hasSTUN = false;\r\n      for (let iceServer of joinRes.iceServers) {\r\n        for (let url of iceServer.urls) {\r\n          if (url.startsWith('turn:')) {\r\n            hasTURN = true;\r\n            hasSTUN = true;\r\n          } else if (url.startsWith('turns:')) {\r\n            hasTURN = true;\r\n            hasSTUN = true;\r\n            hasTLS = true;\r\n          }\r\n          if (url.startsWith('stun:')) {\r\n            hasSTUN = true;\r\n          }\r\n        }\r\n      }\r\n      if (!hasSTUN) {\r\n        this.appendWarning('No STUN servers configured on server side.');\r\n      } else if (hasTURN && !hasTLS) {\r\n        this.appendWarning('TURN is configured server side, but TURN/TLS is unavailable.');\r\n      }\r\n      yield signalClient.close();\r\n      if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\r\n        yield this.room.connect(this.url, this.token, {\r\n          rtcConfig: {\r\n            iceTransportPolicy: 'relay'\r\n          }\r\n        });\r\n      } else {\r\n        this.appendWarning('No TURN servers configured.');\r\n        this.skip();\r\n        yield new Promise(resolve => setTimeout(resolve, 0));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nclass WebRTCCheck extends Checker {\r\n  get description() {\r\n    return 'Establishing WebRTC connection';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      let hasTcp = false;\r\n      let hasIpv4Udp = false;\r\n      this.room.on(RoomEvent.SignalConnected, () => {\r\n        const prevTrickle = this.room.engine.client.onTrickle;\r\n        this.room.engine.client.onTrickle = (sd, target) => {\r\n          if (sd.candidate) {\r\n            const candidate = new RTCIceCandidate(sd);\r\n            let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\r\n            if (candidate.address) {\r\n              if (isIPPrivate(candidate.address)) {\r\n                str += ' (private)';\r\n              } else {\r\n                if (candidate.protocol === 'tcp' && candidate.tcpType === 'passive') {\r\n                  hasTcp = true;\r\n                  str += ' (passive)';\r\n                } else if (candidate.protocol === 'udp') {\r\n                  hasIpv4Udp = true;\r\n                }\r\n              }\r\n            }\r\n            this.appendMessage(str);\r\n          }\r\n          if (prevTrickle) {\r\n            prevTrickle(sd, target);\r\n          }\r\n        };\r\n        if (this.room.engine.pcManager) {\r\n          this.room.engine.pcManager.subscriber.onIceCandidateError = ev => {\r\n            if (ev instanceof RTCPeerConnectionIceErrorEvent) {\r\n              this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\r\n            }\r\n          };\r\n        }\r\n      });\r\n      try {\r\n        yield this.connect();\r\n        livekitLogger.info('now the room is connected');\r\n      } catch (err) {\r\n        this.appendWarning('ports need to be open on firewall in order to connect.');\r\n        throw err;\r\n      }\r\n      if (!hasTcp) {\r\n        this.appendWarning('Server is not configured for ICE/TCP');\r\n      }\r\n      if (!hasIpv4Udp) {\r\n        this.appendWarning('No public IPv4 UDP candidates were found. Your server is likely not configured correctly');\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction isIPPrivate(address) {\r\n  const parts = address.split('.');\r\n  if (parts.length === 4) {\r\n    if (parts[0] === '10') {\r\n      return true;\r\n    } else if (parts[0] === '192' && parts[1] === '168') {\r\n      return true;\r\n    } else if (parts[0] === '172') {\r\n      const second = parseInt(parts[1], 10);\r\n      if (second >= 16 && second <= 31) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nclass WebSocketCheck extends Checker {\r\n  get description() {\r\n    return 'Connecting to signal connection via WebSocket';\r\n  }\r\n  perform() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      var _a, _b, _c;\r\n      if (this.url.startsWith('ws:') || this.url.startsWith('http:')) {\r\n        this.appendWarning('Server is insecure, clients may block connections to it');\r\n      }\r\n      let signalClient = new SignalClient();\r\n      const joinRes = yield signalClient.join(this.url, this.token, {\r\n        autoSubscribe: true,\r\n        maxRetries: 0,\r\n        e2eeEnabled: false,\r\n        websocketTimeout: 15000\r\n      });\r\n      this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\r\n      if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\r\n        this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\r\n      }\r\n      yield signalClient.close();\r\n    });\r\n  }\r\n}\r\n\r\nclass ConnectionCheck extends eventsExports.EventEmitter {\r\n  constructor(url, token) {\r\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    super();\r\n    this.options = {};\r\n    this.checkResults = new Map();\r\n    this.url = url;\r\n    this.token = token;\r\n    this.options = options;\r\n  }\r\n  getNextCheckId() {\r\n    const nextId = this.checkResults.size;\r\n    this.checkResults.set(nextId, {\r\n      logs: [],\r\n      status: CheckStatus.IDLE,\r\n      name: '',\r\n      description: ''\r\n    });\r\n    return nextId;\r\n  }\r\n  updateCheck(checkId, info) {\r\n    this.checkResults.set(checkId, info);\r\n    this.emit('checkUpdate', checkId, info);\r\n  }\r\n  isSuccess() {\r\n    return Array.from(this.checkResults.values()).every(r => r.status !== CheckStatus.FAILED);\r\n  }\r\n  getResults() {\r\n    return Array.from(this.checkResults.values());\r\n  }\r\n  createAndRunCheck(check) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const checkId = this.getNextCheckId();\r\n      const test = new check(this.url, this.token, this.options);\r\n      const handleUpdate = info => {\r\n        this.updateCheck(checkId, info);\r\n      };\r\n      test.on('update', handleUpdate);\r\n      const result = yield test.run();\r\n      test.off('update', handleUpdate);\r\n      return result;\r\n    });\r\n  }\r\n  checkWebsocket() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(WebSocketCheck);\r\n    });\r\n  }\r\n  checkWebRTC() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(WebRTCCheck);\r\n    });\r\n  }\r\n  checkTURN() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(TURNCheck);\r\n    });\r\n  }\r\n  checkReconnect() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(ReconnectCheck);\r\n    });\r\n  }\r\n  checkPublishAudio() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(PublishAudioCheck);\r\n    });\r\n  }\r\n  checkPublishVideo() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(PublishVideoCheck);\r\n    });\r\n  }\r\n  checkConnectionProtocol() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\r\n      if (info.data && 'protocol' in info.data) {\r\n        const stats = info.data;\r\n        this.options.protocol = stats.protocol;\r\n      }\r\n      return info;\r\n    });\r\n  }\r\n  checkCloudRegion() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n      return this.createAndRunCheck(CloudRegionCheck);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Try to analyze the local track to determine the facing mode of a track.\r\n *\r\n * @remarks\r\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\r\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\r\n * If both methods fail, the default facing mode will be used.\r\n *\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\r\n * @experimental\r\n */\r\nfunction facingModeFromLocalTrack(localTrack) {\r\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  var _a;\r\n  const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\r\n  const trackSettings = track.getSettings();\r\n  let result = {\r\n    facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : 'user',\r\n    confidence: 'low'\r\n  };\r\n  // 1. Try to get facingMode from track settings.\r\n  if ('facingMode' in trackSettings) {\r\n    const rawFacingMode = trackSettings.facingMode;\r\n    livekitLogger.trace('rawFacingMode', {\r\n      rawFacingMode\r\n    });\r\n    if (rawFacingMode && typeof rawFacingMode === 'string' && isFacingModeValue(rawFacingMode)) {\r\n      result = {\r\n        facingMode: rawFacingMode,\r\n        confidence: 'high'\r\n      };\r\n    }\r\n  }\r\n  // 2. If we don't have a high confidence we try to get the facing mode from the device label.\r\n  if (['low', 'medium'].includes(result.confidence)) {\r\n    livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\r\n    const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\r\n    if (labelAnalysisResult !== undefined) {\r\n      result = labelAnalysisResult;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nconst knownDeviceLabels = new Map([['obs virtual camera', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}]]);\r\nconst knownDeviceLabelSections = new Map([['iphone', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}], ['ipad', {\r\n  facingMode: 'environment',\r\n  confidence: 'medium'\r\n}]]);\r\n/**\r\n * Attempt to analyze the device label to determine the facing mode.\r\n *\r\n * @experimental\r\n */\r\nfunction facingModeFromDeviceLabel(deviceLabel) {\r\n  var _a;\r\n  const label = deviceLabel.trim().toLowerCase();\r\n  // Empty string is a valid device label but we can't infer anything from it.\r\n  if (label === '') {\r\n    return undefined;\r\n  }\r\n  // Can we match against widely known device labels.\r\n  if (knownDeviceLabels.has(label)) {\r\n    return knownDeviceLabels.get(label);\r\n  }\r\n  // Can we match against sections of the device label.\r\n  return (_a = Array.from(knownDeviceLabelSections.entries()).find(_ref => {\r\n    let [section] = _ref;\r\n    return label.includes(section);\r\n  })) === null || _a === void 0 ? void 0 : _a[1];\r\n}\r\nfunction isFacingModeValue(item) {\r\n  const allowedValues = ['user', 'environment', 'left', 'right'];\r\n  return item === undefined || allowedValues.includes(item);\r\n}\r\n\r\n\r\n//# sourceMappingURL=livekit-client.esm.mjs.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQ0FBb0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxTQUFTO0FBQ2pFLFVBQVUsTUFBTSw2Q0FBNkMsTUFBTSxHQUFHLElBQUk7QUFDMUUsSUFBSSxLQUFLLEdBQUcsSUFBSSxPQUFPLEtBQUs7QUFDNUI7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsZUFBZSxJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1Q0FBdUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDZDQUE2QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4REFBOEQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9GQUFvRjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3REFBd0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQixlQUFlLHVCQUF1QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0IsZUFBZSx1QkFBdUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUZBQXlGO0FBQ3pGO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0NBQWdDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwRUFBMEU7QUFDMUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsVUFBVTtBQUNsRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLGVBQWUsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxhQUFhO0FBQzdDLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQyxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDhDQUE4QztBQUM5QztBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLE9BQU87QUFDUDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw4REFBOEQ7QUFDbEg7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGlGQUFpRjtBQUNqRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JO0FBQ3BJO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUZBQXlGO0FBQ3pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5RkFBeUY7QUFDekY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRix5Q0FBeUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYseUNBQXlDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHlDQUF5QztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHlDQUF5QztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrREFBK0Q7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLDRHQUE0RztBQUM1RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4SEFBOEg7QUFDOUg7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLDBHQUEwRztBQUMxRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRFQUE0RTtBQUM1RTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9HQUFvRztBQUNwRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJGQUEyRjtBQUMzRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQseUNBQXlDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5Q0FBeUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0ZBQWtGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEVBQThFO0FBQ2pGLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdFQUF3RTtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SkFBNko7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSw0S0FBNEs7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSDtBQUNwSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxSkFBcUo7QUFDcko7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0g7QUFDaEg7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxrRkFBa0YsK0RBQStEO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0dBQWdHO0FBQ2hHLFdBQVc7QUFDWCwwR0FBMEc7QUFDMUc7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFIQUFxSDtBQUNySDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpR0FBaUc7QUFDakc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpSkFBaUo7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0tBQStLO0FBQy9LO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlGQUF5RjtBQUN6RjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0hBQW9IO0FBQ3BIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThIO0FBQzlIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkdBQTZHO0FBQzdHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQixJQUFJLGFBQWE7QUFDcEYsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1Isb0ZBQW9GO0FBQ3BGO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdGQUF3RjtBQUN4RjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEtBQUs7QUFDTCxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLCtDQUErQztBQUMvQywrQ0FBK0M7QUFDL0M7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQysxRDtBQUMvMUQiLCJzb3VyY2VzIjpbIkQ6XFxQeXRob25cXHRyYXZlbC1kZXRhaWwtZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcbGl2ZWtpdC1jbGllbnRcXGRpc3RcXGxpdmVraXQtY2xpZW50LmVzbS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XHJcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICBlICYmIHR5cGVvZiBlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShlKSAmJiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XHJcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XHJcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xyXG59XHJcblxyXG52YXIgZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIGggPSAoaSwgcywgdCkgPT4gcyBpbiBpID8gZShpLCBzLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgd3JpdGFibGU6IHRydWUsXHJcbiAgdmFsdWU6IHRcclxufSkgOiBpW3NdID0gdDtcclxudmFyIG8gPSAoaSwgcywgdCkgPT4gaChpLCB0eXBlb2YgcyAhPSBcInN5bWJvbFwiID8gcyArIFwiXCIgOiBzLCB0KTtcclxuY2xhc3MgXyB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBvKHRoaXMsIFwiX2xvY2tpbmdcIik7XHJcbiAgICBvKHRoaXMsIFwiX2xvY2tzXCIpO1xyXG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpLCB0aGlzLl9sb2NrcyA9IDA7XHJcbiAgfVxyXG4gIGlzTG9ja2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvY2tzID4gMDtcclxuICB9XHJcbiAgbG9jaygpIHtcclxuICAgIHRoaXMuX2xvY2tzICs9IDE7XHJcbiAgICBsZXQgcztcclxuICAgIGNvbnN0IHQgPSBuZXcgUHJvbWlzZShsID0+IHMgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fbG9ja3MgLT0gMSwgbCgpO1xyXG4gICAgICB9KSxcclxuICAgICAgYyA9IHRoaXMuX2xvY2tpbmcudGhlbigoKSA9PiBzKTtcclxuICAgIHJldHVybiB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHQpLCBjO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIEFzc2VydCB0aGF0IGNvbmRpdGlvbiBpcyB0cnV0aHkgb3IgdGhyb3cgZXJyb3IgKHdpdGggbWVzc2FnZSlcclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBib29sZWFuXHJcbiAgaWYgKCFjb25kaXRpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gIH1cclxufVxyXG5jb25zdCBGTE9BVDMyX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUzOCxcclxuICBGTE9BVDMyX01JTiA9IC0zNDAyODIzNDY2Mzg1Mjg4NmUyMixcclxuICBVSU5UMzJfTUFYID0gMHhmZmZmZmZmZixcclxuICBJTlQzMl9NQVggPSAweDdmZmZmZmZmLFxyXG4gIElOVDMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xyXG4vKipcclxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XHJcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xyXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcclxufVxyXG4vKipcclxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XHJcbiAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcclxuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXHJcbn1cclxuLyoqXHJcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcclxuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcclxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKSByZXR1cm47XHJcbiAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuY29uc3QgZW51bVR5cGVTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvZW51bS10eXBlXCIpO1xyXG4vKipcclxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxyXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGdlbmVyYXRlZFxyXG4gKiBlbnVtLCBpdCByYWlzZXMgYW4gZXJyb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbnVtVHlwZShlbnVtT2JqZWN0KSB7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gIGNvbnN0IHQgPSBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXTtcclxuICBhc3NlcnQodCwgXCJtaXNzaW5nIGVudW0gdHlwZSBvbiBlbnVtIG9iamVjdFwiKTtcclxuICByZXR1cm4gdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gb24gYSBnZW5lcmF0ZWQgZW51bS5cclxuICovXHJcbmZ1bmN0aW9uIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICBlbnVtT2JqZWN0W2VudW1UeXBlU3ltYm9sXSA9IG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLm1hcCh2ID0+ICh7XHJcbiAgICBubzogdi5ubyxcclxuICAgIG5hbWU6IHYubmFtZSxcclxuICAgIGxvY2FsTmFtZTogZW51bU9iamVjdFt2Lm5vXVxyXG4gIH0pKSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBFbnVtVHlwZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlRW51bVR5cGUodHlwZU5hbWUsIHZhbHVlcyxcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG5fb3B0KSB7XHJcbiAgY29uc3QgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGNvbnN0IG51bWJlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGNvbnN0IG5vcm1hbFZhbHVlcyA9IFtdO1xyXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XHJcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxyXG4gICAgLy8gY29uc3QgdmFsdWU6IEVudW1WYWx1ZUluZm8gPSB7Li4udiwgb3B0aW9uczogdi5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3R9O1xyXG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XHJcbiAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcclxuICAgIG5hbWVzW3ZhbHVlLm5hbWVdID0gbjtcclxuICAgIG51bWJlcnNbdmFsdWUubm9dID0gbjtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGVOYW1lLFxyXG4gICAgdmFsdWVzOiBub3JtYWxWYWx1ZXMsXHJcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxyXG4gICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICBmaW5kTmFtZShuYW1lKSB7XHJcbiAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcclxuICAgIH0sXHJcbiAgICBmaW5kTnVtYmVyKG5vKSB7XHJcbiAgICAgIHJldHVybiBudW1iZXJzW25vXTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgZW51bSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxyXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcclxuICBjb25zdCBlbnVtT2JqZWN0ID0ge307XHJcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcclxuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xyXG4gICAgZW51bU9iamVjdFtuLmxvY2FsTmFtZV0gPSBuLm5vO1xyXG4gICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xyXG4gIH1cclxuICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzKTtcclxuICByZXR1cm4gZW51bU9iamVjdDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpIHtcclxuICBpZiAoXCJsb2NhbE5hbWVcIiBpbiB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHtcclxuICAgIGxvY2FsTmFtZTogdmFsdWUubmFtZVxyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogTWVzc2FnZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBldmVyeSBtZXNzYWdlLCBnZW5lcmF0ZWQsIG9yIGNyZWF0ZWQgYXRcclxuICogcnVudGltZS5cclxuICpcclxuICogSXQgaXMgX25vdF8gc2FmZSB0byBleHRlbmQgdGhpcyBjbGFzcy4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbWVzc2FnZSBhdFxyXG4gKiBydW4gdGltZSwgdXNlIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoKS5cclxuICovXHJcbmNsYXNzIE1lc3NhZ2Uge1xyXG4gIC8qKlxyXG4gICAqIENvbXBhcmUgd2l0aCBhIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgdHlwZS5cclxuICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkaXNyZWdhcmRzIGV4dGVuc2lvbnMgYW5kIHVua25vd24gZmllbGRzLlxyXG4gICAqL1xyXG4gIGVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5lcXVhbHModGhpcy5nZXRUeXBlKCksIHRoaXMsIG90aGVyKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgZGVlcCBjb3B5LlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5jbG9uZSh0aGlzKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUGFyc2UgZnJvbSBiaW5hcnkgZGF0YSwgbWVyZ2luZyBmaWVsZHMuXHJcbiAgICpcclxuICAgKiBSZXBlYXRlZCBmaWVsZHMgYXJlIGFwcGVuZGVkLiBNYXAgZW50cmllcyBhcmUgYWRkZWQsIG92ZXJ3cml0aW5nXHJcbiAgICogZXhpc3Rpbmcga2V5cy5cclxuICAgKlxyXG4gICAqIElmIGEgbWVzc2FnZSBmaWVsZCBpcyBhbHJlYWR5IHByZXNlbnQsIGl0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXHJcbiAgICogbmV3IGRhdGEuXHJcbiAgICovXHJcbiAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xyXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxyXG4gICAgICBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuYmluLFxyXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHRoaXMsIG9wdC5yZWFkZXJGYWN0b3J5KGJ5dGVzKSwgYnl0ZXMuYnl0ZUxlbmd0aCwgb3B0KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gdmFsdWUuXHJcbiAgICovXHJcbiAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXHJcbiAgICAgIGZvcm1hdCA9IHR5cGUucnVudGltZS5qc29uLFxyXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQYXJzZSBhIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcclxuICAgIGxldCBqc29uO1xyXG4gICAgdHJ5IHtcclxuICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgXCIuY29uY2F0KHRoaXMuZ2V0VHlwZSgpLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxyXG4gICAqL1xyXG4gIHRvQmluYXJ5KG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcclxuICAgICAgYmluID0gdHlwZS5ydW50aW1lLmJpbixcclxuICAgICAgb3B0ID0gYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyksXHJcbiAgICAgIHdyaXRlciA9IG9wdC53cml0ZXJGYWN0b3J5KCk7XHJcbiAgICBiaW4ud3JpdGVNZXNzYWdlKHRoaXMsIHdyaXRlciwgb3B0KTtcclxuICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxyXG4gICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxyXG4gICAqL1xyXG4gIHRvSnNvbihvcHRpb25zKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCksXHJcbiAgICAgIGpzb24gPSB0eXBlLnJ1bnRpbWUuanNvbixcclxuICAgICAgb3B0ID0ganNvbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGpzb24ud3JpdGVNZXNzYWdlKHRoaXMsIG9wdCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gc3RyaW5nLlxyXG4gICAqL1xyXG4gIHRvSnNvblN0cmluZyhvcHRpb25zKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9Kc29uKG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldHR5U3BhY2VzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgZm9yIHNlcmlhbGl6YXRpb24gYmVoYXZpb3IuIFRoaXMgd2lsbCBiZSBpbnZva2VkIHdoZW4gY2FsbGluZ1xyXG4gICAqIEpTT04uc3RyaW5naWZ5IG9uIHRoaXMgbWVzc2FnZSAoaS5lLiBKU09OLnN0cmluZ2lmeShtc2cpKS5cclxuICAgKlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHNlcmlhbGl6ZSBnb29nbGUucHJvdG9idWYuQW55IHdpdGggYSBwYWNrZWRcclxuICAgKiBtZXNzYWdlIGJlY2F1c2UgdGhlIHByb3RvYnVmIEpTT04gZm9ybWF0IHNwZWNpZmllcyB0aGF0IGl0IG5lZWRzIHRvIGJlXHJcbiAgICogdW5wYWNrZWQsIGFuZCB0aGlzIGlzIG9ubHkgcG9zc2libGUgd2l0aCBhIHR5cGUgcmVnaXN0cnkgdG8gbG9vayB1cCB0aGVcclxuICAgKiBtZXNzYWdlIHR5cGUuICBBcyBhIHJlc3VsdCwgYXR0ZW1wdGluZyB0byBzZXJpYWxpemUgYSBtZXNzYWdlIHdpdGggdGhpc1xyXG4gICAqIHR5cGUgd2lsbCB0aHJvdyBhbiBFcnJvci5cclxuICAgKlxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIHByb3RlY3RlZCBiZWNhdXNlIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gaW52b2tlIGl0XHJcbiAgICogZGlyZWN0bHkgLS0gaW5zdGVhZCB1c2UgSlNPTi5zdHJpbmdpZnkgb3IgdG9Kc29uU3RyaW5nIGZvclxyXG4gICAqIHN0cmluZ2lmaWVkIEpTT04uICBBbHRlcm5hdGl2ZWx5LCBpZiBhY3R1YWwgSlNPTiBpcyBkZXNpcmVkLCB5b3Ugc2hvdWxkXHJcbiAgICogdXNlIHRvSnNvbi5cclxuICAgKi9cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b0pzb24oe1xyXG4gICAgICBlbWl0RGVmYXVsdFZhbHVlczogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIHRoZSBNZXNzYWdlVHlwZSBvZiB0aGlzIG1lc3NhZ2UgLSBhIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHNcclxuICAgKiB0aGUgcHJvdG9idWYgbWVzc2FnZSBkZWNsYXJhdGlvbiBhbmQgcHJvdmlkZXMgbWV0YWRhdGEgZm9yIHJlZmxlY3Rpb24tXHJcbiAgICogYmFzZWQgb3BlcmF0aW9ucy5cclxuICAgKi9cclxuICBnZXRUeXBlKCkge1xyXG4gICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXHJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBNZXNzYWdlVHlwZS5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cclxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgdHlwZSB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNZXNzYWdlVHlwZShydW50aW1lLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcclxuICB2YXIgX2E7XHJcbiAgY29uc3QgbG9jYWxOYW1lID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZU5hbWUuc3Vic3RyaW5nKHR5cGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xyXG4gIGNvbnN0IHR5cGUgPSB7XHJcbiAgICBbbG9jYWxOYW1lXTogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgcnVudGltZS51dGlsLmluaXRGaWVsZHModGhpcyk7XHJcbiAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcclxuICAgIH1cclxuICB9W2xvY2FsTmFtZV07XHJcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcclxuICBPYmplY3QuYXNzaWduKHR5cGUsIHtcclxuICAgIHJ1bnRpbWUsXHJcbiAgICB0eXBlTmFtZSxcclxuICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxyXG4gICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcclxuICAgIH0sXHJcbiAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcclxuICAgIH0sXHJcbiAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xyXG4gICAgfSxcclxuICAgIGVxdWFscyhhLCBiKSB7XHJcbiAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB0eXBlO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuLy9cclxuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcclxuLy8gbWV0OlxyXG4vL1xyXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXHJcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxyXG4vLyBkaXN0cmlidXRpb24uXHJcbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xyXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxyXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4vL1xyXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXHJcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxyXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXHJcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxyXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcclxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcclxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuLy9cclxuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIFByb3RvY29sIEJ1ZmZlciBjb21waWxlciBpcyBvd25lZCBieSB0aGUgb3duZXJcclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XHJcbi8vIHN0YW5kYWxvbmUgYW5kIHJlcXVpcmVzIGEgc3VwcG9ydCBsaWJyYXJ5IHRvIGJlIGxpbmtlZCB3aXRoIGl0LiAgVGhpc1xyXG4vLyBzdXBwb3J0IGxpYnJhcnkgaXMgaXRzZWxmIGNvdmVyZWQgYnkgdGhlIGFib3ZlIGxpY2Vuc2UuXHJcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xyXG4vKipcclxuICogUmVhZCBhIDY0IGJpdCB2YXJpbnQgYXMgdHdvIEpTIG51bWJlcnMuXHJcbiAqXHJcbiAqIFJldHVybnMgdHVwbGU6XHJcbiAqIFswXTogbG93IGJpdHNcclxuICogWzFdOiBoaWdoIGJpdHNcclxuICpcclxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvYnVmZmVyX2RlY29kZXIuanMjTDE3NVxyXG4gKi9cclxuZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xyXG4gIGxldCBsb3dCaXRzID0gMDtcclxuICBsZXQgaGlnaEJpdHMgPSAwO1xyXG4gIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xyXG4gICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcclxuICAgIGxvd0JpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcclxuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcclxuICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxldCBtaWRkbGVCeXRlID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcclxuICBsb3dCaXRzIHw9IChtaWRkbGVCeXRlICYgMHgwZikgPDwgMjg7XHJcbiAgLy8gMyB1cHBlciBiaXRzIGFyZSBwYXJ0IG9mIHRoZSBuZXh0IDMyIGJpdCBudW1iZXJcclxuICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcclxuICBpZiAoKG1pZGRsZUJ5dGUgJiAweDgwKSA9PSAwKSB7XHJcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xyXG4gICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XHJcbiAgfVxyXG4gIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcclxuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgICBoaWdoQml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xyXG4gICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xyXG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xyXG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcclxuICAgIH1cclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlIGEgNjQgYml0IHZhcmludCwgZ2l2ZW4gYXMgdHdvIEpTIG51bWJlcnMsIHRvIHRoZSBnaXZlbiBieXRlcyBhcnJheS5cclxuICpcclxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvOGE3MTkyN2Q3NGE0Y2UzNGVmZTJkODc2OWZkYTE5OGY1MmQyMGQxMi9qcy9leHBlcmltZW50YWwvcnVudGltZS9rZXJuZWwvd3JpdGVyLmpzI0wzNDRcclxuICovXHJcbmZ1bmN0aW9uIHZhcmludDY0d3JpdGUobG8sIGhpLCBieXRlcykge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjg7IGkgPSBpICsgNykge1xyXG4gICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcclxuICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XHJcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xyXG4gICAgYnl0ZXMucHVzaChieXRlKTtcclxuICAgIGlmICghaGFzTmV4dCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IHNwbGl0Qml0cyA9IGxvID4+PiAyOCAmIDB4MGYgfCAoaGkgJiAweDA3KSA8PCA0O1xyXG4gIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xyXG4gIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcclxuICBpZiAoIWhhc01vcmVCaXRzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgMzE7IGkgPSBpICsgNykge1xyXG4gICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcclxuICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xyXG4gICAgY29uc3QgYnl0ZSA9IChoYXNOZXh0ID8gc2hpZnQgfCAweDgwIDogc2hpZnQpICYgMHhmZjtcclxuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XHJcbiAgICBpZiAoIWhhc05leHQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBieXRlcy5wdXNoKGhpID4+PiAzMSAmIDB4MDEpO1xyXG59XHJcbi8vIGNvbnN0YW50cyBmb3IgYmluYXJ5IG1hdGhcclxuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSAweDEwMDAwMDAwMDtcclxuLyoqXHJcbiAqIFBhcnNlIGRlY2ltYWwgc3RyaW5nIG9mIDY0IGJpdCBpbnRlZ2VyIHZhbHVlIGFzIHR3byBKUyBudW1iZXJzLlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnQ2NEZyb21TdHJpbmcoZGVjKSB7XHJcbiAgLy8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24uXHJcbiAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xyXG4gIGlmIChtaW51cykge1xyXG4gICAgZGVjID0gZGVjLnNsaWNlKDEpO1xyXG4gIH1cclxuICAvLyBXb3JrIDYgZGVjaW1hbCBkaWdpdHMgYXQgYSB0aW1lLCBhY3RpbmcgbGlrZSB3ZSdyZSBjb252ZXJ0aW5nIGJhc2UgMWU2XHJcbiAgLy8gZGlnaXRzIHRvIGJpbmFyeS4gVGhpcyBpcyBzYWZlIHRvIGRvIHdpdGggZmxvYXRpbmcgcG9pbnQgbWF0aCBiZWNhdXNlXHJcbiAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXHJcbiAgY29uc3QgYmFzZSA9IDFlNjtcclxuICBsZXQgbG93Qml0cyA9IDA7XHJcbiAgbGV0IGhpZ2hCaXRzID0gMDtcclxuICBmdW5jdGlvbiBhZGQxZTZkaWdpdChiZWdpbiwgZW5kKSB7XHJcbiAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXHJcbiAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xyXG4gICAgaGlnaEJpdHMgKj0gYmFzZTtcclxuICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xyXG4gICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cclxuICAgIGlmIChsb3dCaXRzID49IFRXT19QV1JfMzJfREJMKSB7XHJcbiAgICAgIGhpZ2hCaXRzID0gaGlnaEJpdHMgKyAobG93Qml0cyAvIFRXT19QV1JfMzJfREJMIHwgMCk7XHJcbiAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcclxuICBhZGQxZTZkaWdpdCgtMTgsIC0xMik7XHJcbiAgYWRkMWU2ZGlnaXQoLTEyLCAtNik7XHJcbiAgYWRkMWU2ZGlnaXQoLTYpO1xyXG4gIHJldHVybiBtaW51cyA/IG5lZ2F0ZShsb3dCaXRzLCBoaWdoQml0cykgOiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcclxufVxyXG4vKipcclxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxyXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcclxuICovXHJcbmZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XHJcbiAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XHJcbiAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xyXG4gIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cclxuICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xyXG4gIGlmIChuZWdhdGl2ZSkge1xyXG4gICAgYml0cyA9IG5lZ2F0ZShiaXRzLmxvLCBiaXRzLmhpKTtcclxuICB9XHJcbiAgY29uc3QgcmVzdWx0ID0gdUludDY0VG9TdHJpbmcoYml0cy5sbywgYml0cy5oaSk7XHJcbiAgcmV0dXJuIG5lZ2F0aXZlID8gXCItXCIgKyByZXN1bHQgOiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiAzMjozMiBzcGxpdCByZXByZXNlbnRhdGlvblxyXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcclxuICovXHJcbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xyXG4gICh7XHJcbiAgICBsbyxcclxuICAgIGhpXHJcbiAgfSA9IHRvVW5zaWduZWQobG8sIGhpKSk7XHJcbiAgLy8gU2tpcCB0aGUgZXhwZW5zaXZlIGNvbnZlcnNpb24gaWYgdGhlIG51bWJlciBpcyBzbWFsbCBlbm91Z2ggdG8gdXNlIHRoZVxyXG4gIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxyXG4gIC8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gMHgwMDFGRkZGRiBGRkZGRkZGRiwgdGh1cyBhbnkgbnVtYmVyIHdpdGhcclxuICAvLyBoaWdoQml0cyA8PSAweDFGRkZGRiBjYW4gYmUgc2FmZWx5IGV4cHJlc3NlZCB3aXRoIGEgZG91YmxlIGFuZCByZXRhaW5cclxuICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cclxuICAvLyBQcm92ZW4gYnk6IE51bWJlci5pc1NhZmVJbnRlZ2VyKDB4MUZGRkZGICogMioqMzIgKyAweEZGRkZGRkZGKSA9PSB0cnVlLlxyXG4gIGlmIChoaSA8PSAweDFGRkZGRikge1xyXG4gICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xyXG4gIH1cclxuICAvLyBXaGF0IHRoaXMgY29kZSBpcyBkb2luZyBpcyBlc3NlbnRpYWxseSBjb252ZXJ0aW5nIHRoZSBpbnB1dCBudW1iZXIgZnJvbVxyXG4gIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcclxuICAvLyBvbmx5IDMgKHZlcnkgbGFyZ2UpIGRpZ2l0cy4gVGhvc2UgZGlnaXRzIGFyZSB0aGVuIHRyaXZpYWwgdG8gY29udmVydCB0b1xyXG4gIC8vIGEgYmFzZS0xMCBzdHJpbmcuXHJcbiAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXHJcbiAgLy8gMl4yNCA9IDE2Nzc3MjE2ID0gKDEsNjc3NzIxNikgaW4gYmFzZS0xZTcuXHJcbiAgLy8gMl40OCA9IDI4MTQ3NDk3NjcxMDY1NiA9ICgyLDgxNDc0OTcsNjcxMDY1NikgaW4gYmFzZS0xZTcuXHJcbiAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcclxuICAvLyBpbnRlcm1lZGlhdGUgZGlnaXRzIGRvbid0IG92ZXJmbG93LlxyXG4gIGNvbnN0IGxvdyA9IGxvICYgMHhGRkZGRkY7XHJcbiAgY29uc3QgbWlkID0gKGxvID4+PiAyNCB8IGhpIDw8IDgpICYgMHhGRkZGRkY7XHJcbiAgY29uc3QgaGlnaCA9IGhpID4+IDE2ICYgMHhGRkZGO1xyXG4gIC8vIEFzc2VtYmxlIG91ciB0aHJlZSBiYXNlLTFlNyBkaWdpdHMsIGlnbm9yaW5nIGNhcnJpZXMuIFRoZSBtYXhpbXVtXHJcbiAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxyXG4gIC8vIGNhbiBiZSBzdG9yZWQgaW4gYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxyXG4gIGxldCBkaWdpdEEgPSBsb3cgKyBtaWQgKiA2Nzc3MjE2ICsgaGlnaCAqIDY3MTA2NTY7XHJcbiAgbGV0IGRpZ2l0QiA9IG1pZCArIGhpZ2ggKiA4MTQ3NDk3O1xyXG4gIGxldCBkaWdpdEMgPSBoaWdoICogMjtcclxuICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cclxuICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XHJcbiAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XHJcbiAgICBkaWdpdEIgKz0gTWF0aC5mbG9vcihkaWdpdEEgLyBiYXNlKTtcclxuICAgIGRpZ2l0QSAlPSBiYXNlO1xyXG4gIH1cclxuICBpZiAoZGlnaXRCID49IGJhc2UpIHtcclxuICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xyXG4gICAgZGlnaXRCICU9IGJhc2U7XHJcbiAgfVxyXG4gIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxyXG4gIC8vIGF0IHRoZSB0b3AgZm9yIG5vbi1zYWZlIGludGVnZXJzLiBHaXZlbiB0aGlzLCB3ZSBjYW4gYXNzdW1lIGJvdGggZGlnaXRCXHJcbiAgLy8gYW5kIGRpZ2l0QSBuZWVkIGxlYWRpbmcgemVyb3MuXHJcbiAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcclxufVxyXG5mdW5jdGlvbiB0b1Vuc2lnbmVkKGxvLCBoaSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBsbzogbG8gPj4+IDAsXHJcbiAgICBoaTogaGkgPj4+IDBcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5ld0JpdHMobG8sIGhpKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGxvOiBsbyB8IDAsXHJcbiAgICBoaTogaGkgfCAwXHJcbiAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9ycyNTaWduZWRfMzItYml0X2ludGVnZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcclxuICBoaWdoQml0cyA9IH5oaWdoQml0cztcclxuICBpZiAobG93Qml0cykge1xyXG4gICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gSWYgbG93Qml0cyBpcyAwLCB0aGVuIGJpdHdpc2Utbm90IGlzIDB4RkZGRkZGRkYsXHJcbiAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcclxuICAgIC8vIHRoZSBsb3cgYml0cyAweDAgYW5kIHNpbXBseSBhZGRzIG9uZSB0byB0aGUgaGlnaCBiaXRzLlxyXG4gICAgaGlnaEJpdHMgKz0gMTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld0JpdHMobG93Qml0cywgaGlnaEJpdHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgZGlnaXQxZTcgd2l0aCBsZWFkaW5nIHplcm9zLlxyXG4gKi9cclxuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gZGlnaXQxZTcgPT4ge1xyXG4gIGNvbnN0IHBhcnRpYWwgPSBTdHJpbmcoZGlnaXQxZTcpO1xyXG4gIHJldHVybiBcIjAwMDAwMDBcIi5zbGljZShwYXJ0aWFsLmxlbmd0aCkgKyBwYXJ0aWFsO1xyXG59O1xyXG4vKipcclxuICogV3JpdGUgYSAzMiBiaXQgdmFyaW50LCBzaWduZWQgb3IgdW5zaWduZWQuIFNhbWUgYXMgYHZhcmludDY0d3JpdGUoMCwgdmFsdWUsIGJ5dGVzKWBcclxuICpcclxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XHJcbiAqL1xyXG5mdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xyXG4gIGlmICh2YWx1ZSA+PSAwKSB7XHJcbiAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzJcclxuICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcclxuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcclxuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcclxuICAgIH1cclxuICAgIGJ5dGVzLnB1c2godmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xyXG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMTI3IHwgMTI4KTtcclxuICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA3O1xyXG4gICAgfVxyXG4gICAgYnl0ZXMucHVzaCgxKTtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXHJcbiAqL1xyXG5mdW5jdGlvbiB2YXJpbnQzMnJlYWQoKSB7XHJcbiAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcclxuICBsZXQgcmVzdWx0ID0gYiAmIDB4N2Y7XHJcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xyXG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcclxuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCA3O1xyXG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcclxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMTQ7XHJcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xyXG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcclxuICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCAyMTtcclxuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XHJcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXHJcbiAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xyXG4gIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xyXG4gIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKSBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XHJcbiAgaWYgKChiICYgMHg4MCkgIT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XHJcbiAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxyXG4gIHJldHVybiByZXN1bHQgPj4+IDA7XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbmZ1bmN0aW9uIG1ha2VJbnQ2NFN1cHBvcnQoKSB7XHJcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcclxuICAvLyBub3RlIHRoYXQgU2FmYXJpIDE0IGltcGxlbWVudHMgQmlnSW50LCBidXQgbm90IHRoZSBEYXRhVmlldyBtZXRob2RzXHJcbiAgY29uc3Qgb2sgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LmdldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdJbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkdi5zZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIHByb2Nlc3MgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fCBwcm9jZXNzLmVudi5CVUZfQklHSU5UX0RJU0FCTEUgIT09IFwiMVwiKTtcclxuICBpZiAob2spIHtcclxuICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLFxyXG4gICAgICBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLFxyXG4gICAgICBVTUlOID0gQmlnSW50KFwiMFwiKSxcclxuICAgICAgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgemVybzogQmlnSW50KDApLFxyXG4gICAgICBzdXBwb3J0ZWQ6IHRydWUsXHJcbiAgICAgIHBhcnNlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcclxuICAgICAgICBpZiAoYmkgPiBNQVggfHwgYmkgPCBNSU4pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVQYXJzZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGJpID0gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZSA6IEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKGJpID4gVU1BWCB8fCBiaSA8IFVNSU4pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpO1xyXG4gICAgICB9LFxyXG4gICAgICBlbmModmFsdWUpIHtcclxuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcclxuICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHVFbmModmFsdWUpIHtcclxuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnVQYXJzZSh2YWx1ZSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXHJcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcclxuICAgICAgICB9O1xyXG4gICAgICB9LFxyXG4gICAgICBkZWMobG8sIGhpKSB7XHJcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xyXG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVEZWMobG8sIGhpKSB7XHJcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xyXG4gICAgICAgIGR2LnNldEludDMyKDQsIGhpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnVWludDY0KDAsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBjb25zdCBhc3NlcnRJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XHJcbiAgY29uc3QgYXNzZXJ0VUludDY0U3RyaW5nID0gdmFsdWUgPT4gYXNzZXJ0KC9eWzAtOV0rJC8udGVzdCh2YWx1ZSksIFwidWludDY0IGludmFsaWQ6IFwiLmNvbmNhdCh2YWx1ZSkpO1xyXG4gIHJldHVybiB7XHJcbiAgICB6ZXJvOiBcIjBcIixcclxuICAgIHN1cHBvcnRlZDogZmFsc2UsXHJcbiAgICBwYXJzZSh2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgIH1cclxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgdVBhcnNlKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICBhc3NlcnRVSW50NjRTdHJpbmcodmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgZW5jKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIHVFbmModmFsdWUpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICB9XHJcbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGRlYyhsbywgaGkpIHtcclxuICAgICAgcmV0dXJuIGludDY0VG9TdHJpbmcobG8sIGhpKTtcclxuICAgIH0sXHJcbiAgICB1RGVjKGxvLCBoaSkge1xyXG4gICAgICByZXR1cm4gdUludDY0VG9TdHJpbmcobG8sIGhpKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmNvbnN0IHByb3RvSW50NjQgPSBtYWtlSW50NjRTdXBwb3J0KCk7XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXHJcbiAqIGVudW0gZ29vZ2xlLnByb3RvYnVmLkZpZWxkRGVzY3JpcHRvclByb3RvLlR5cGUgVGhlIHR5cGVzIEdST1VQIGFuZCBNRVNTQUdFXHJcbiAqIGFyZSBvbWl0dGVkLCBidXQgdGhlIG51bWVyaWNhbCB2YWx1ZXMgYXJlIGlkZW50aWNhbC5cclxuICovXHJcbnZhciBTY2FsYXJUeXBlO1xyXG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcclxuICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXHJcbiAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcclxuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcclxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcclxuICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcclxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcclxuICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cclxuICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcclxuICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxyXG4gIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cclxuICAvLyBUWVBFX0dST1VQID0gMTAsXHJcbiAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cclxuICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xyXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XHJcbiAgLy8gVFlQRV9FTlVNID0gMTQsXHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XHJcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcclxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xyXG59KShTY2FsYXJUeXBlIHx8IChTY2FsYXJUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxyXG4gKiBzaW50NjQsIGZpeGVkNjQsIHNmaXhlZDY0KS5cclxuICpcclxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXHJcbiAqIEpTX1NUUklORywgYW5kIEpTX05VTUJFUi4gUHJvdG9idWYtRVMgdXNlcyBCaWdJbnQgYnkgZGVmYXVsdCwgYnV0IHdpbGwgdXNlXHJcbiAqIFN0cmluZyBpZiBgW2pzdHlwZSA9IEpTX1NUUklOR11gIGlzIHNwZWNpZmllZC5cclxuICpcclxuICogYGBgcHJvdG9idWZcclxuICogdWludDY0IGZpZWxkX2EgPSAxOyAvLyBCaWdJbnRcclxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcclxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OVU1CRVJdOyAvLyBCaWdJbnRcclxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19TVFJJTkddOyAvLyBTdHJpbmdcclxuICogYGBgXHJcbiAqL1xyXG52YXIgTG9uZ1R5cGU7XHJcbihmdW5jdGlvbiAoTG9uZ1R5cGUpIHtcclxuICAvKipcclxuICAgKiBVc2UgSmF2YVNjcmlwdCBCaWdJbnQuXHJcbiAgICovXHJcbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJCSUdJTlRcIl0gPSAwXSA9IFwiQklHSU5UXCI7XHJcbiAgLyoqXHJcbiAgICogVXNlIEphdmFTY3JpcHQgU3RyaW5nLlxyXG4gICAqXHJcbiAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfU1RSSU5HXWAuXHJcbiAgICovXHJcbiAgTG9uZ1R5cGVbTG9uZ1R5cGVbXCJTVFJJTkdcIl0gPSAxXSA9IFwiU1RSSU5HXCI7XHJcbn0pKExvbmdUeXBlIHx8IChMb25nVHlwZSA9IHt9KSk7XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggc2NhbGFyIHZhbHVlcyBhcmUgZXF1YWwuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xyXG4gIGlmIChhID09PSBiKSB7XHJcbiAgICAvLyBUaGlzIGNvcnJlY3RseSBtYXRjaGVzIGVxdWFsIHZhbHVlcyBleGNlcHQgQllURVMgYW5kIChwb3NzaWJseSkgNjQtYml0IGludGVnZXJzLlxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8vIFNwZWNpYWwgY2FzZSBCWVRFUyAtIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGJ5dGUgaW5kaXZpZHVhbGx5XHJcbiAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xyXG4gICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLy8gU3BlY2lhbCBjYXNlIDY0LWJpdCBpbnRlZ2VycyAtIHdlIHN1cHBvcnQgbnVtYmVyLCBzdHJpbmcgYW5kIGJpZ2ludCByZXByZXNlbnRhdGlvbi5cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xyXG4gIHN3aXRjaCAodHlwZSkge1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcclxuICAgICAgLy8gTG9vc2UgY29tcGFyaXNvbiB3aWxsIG1hdGNoIGJldHdlZW4gMG4sIDAgYW5kIFwiMFwiLlxyXG4gICAgICByZXR1cm4gYSA9PSBiO1xyXG4gIH1cclxuICAvLyBBbnl0aGluZyB0aGF0IGhhc24ndCBiZWVuIGNhdWdodCBieSBzdHJpY3QgY29tcGFyaXNvbiBvciBzcGVjaWFsIGNhc2VkXHJcbiAgLy8gQllURVMgYW5kIDY0LWJpdCBpbnRlZ2VycyBpcyBub3QgZXF1YWwuXHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB6ZXJvIHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzY2FsYXJaZXJvVmFsdWUodHlwZSwgbG9uZ1R5cGUpIHtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcclxuICAgICAgcmV0dXJuIGxvbmdUeXBlID09IDAgPyBwcm90b0ludDY0Lnplcm8gOiBcIjBcIjtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XHJcbiAgICAgIHJldHVybiAwLjA7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XHJcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XHJcbiAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgLy8gSGFuZGxlcyBJTlQzMiwgVUlOVDMyLCBTSU5UMzIsIEZJWEVEMzIsIFNGSVhFRDMyLlxyXG4gICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXHJcbiAgICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGZvciBhIHplcm8tdmFsdWUuIEZvciBleGFtcGxlLCBhbiBpbnRlZ2VyIGhhcyB0aGUgemVyby12YWx1ZSBgMGAsXHJcbiAqIGEgYm9vbGVhbiBpcyBgZmFsc2VgLCBhIHN0cmluZyBpcyBgXCJcImAsIGFuZCBieXRlcyBpcyBhbiBlbXB0eSBVaW50OEFycmF5LlxyXG4gKlxyXG4gKiBJbiBwcm90bzMsIHplcm8tdmFsdWVzIGFyZSBub3Qgd3JpdHRlbiB0byB0aGUgd2lyZSwgdW5sZXNzIHRoZSBmaWVsZCBpc1xyXG4gKiBvcHRpb25hbCBvciByZXBlYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJcIjtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcclxuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiAhdmFsdWUuYnl0ZUxlbmd0aDtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PSAwO1xyXG4gICAgLy8gTG9vc2UgY29tcGFyaXNvbiBtYXRjaGVzIDBuLCAwIGFuZCBcIjBcIlxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXHJcbi8qKlxyXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXHJcbiAqXHJcbiAqIEEgd2lyZSB0eXBlIHByb3ZpZGVzIGp1c3QgZW5vdWdoIGluZm9ybWF0aW9uIHRvIGZpbmQgdGhlIGxlbmd0aCBvZiB0aGVcclxuICogZm9sbG93aW5nIHZhbHVlLlxyXG4gKlxyXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL2VuY29kaW5nI3N0cnVjdHVyZVxyXG4gKi9cclxudmFyIFdpcmVUeXBlO1xyXG4oZnVuY3Rpb24gKFdpcmVUeXBlKSB7XHJcbiAgLyoqXHJcbiAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cclxuICAgKi9cclxuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcclxuICAvKipcclxuICAgKiBVc2VkIGZvciBmaXhlZDY0LCBzZml4ZWQ2NCwgZG91YmxlLlxyXG4gICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAqL1xyXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0NjRcIl0gPSAxXSA9IFwiQml0NjRcIjtcclxuICAvKipcclxuICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xyXG4gICAqXHJcbiAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxyXG4gICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxyXG4gICAqIHBhY2tlZCBieSBkZWZhdWx0LlxyXG4gICAqL1xyXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUsIHN1Y2ggYXMgYSBwcm90bzIgZ3JvdXAsIG9yIGEgbWVzc2FnZVxyXG4gICAqIGluIGVkaXRpb25zIHdpdGggbWVzc2FnZV9lbmNvZGluZyA9IERFTElNSVRFRC5cclxuICAgKi9cclxuICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xyXG4gIC8qKlxyXG4gICAqIEVuZCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxyXG4gICAqL1xyXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiRW5kR3JvdXBcIl0gPSA0XSA9IFwiRW5kR3JvdXBcIjtcclxuICAvKipcclxuICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXHJcbiAgICogQWx3YXlzIDQgYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAgICovXHJcbiAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xyXG59KShXaXJlVHlwZSB8fCAoV2lyZVR5cGUgPSB7fSkpO1xyXG5jbGFzcyBCaW5hcnlXcml0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XHJcbiAgICAvKipcclxuICAgICAqIFByZXZpb3VzIGZvcmsgc3RhdGVzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICB0aGlzLnRleHRFbmNvZGVyID0gdGV4dEVuY29kZXIgIT09IG51bGwgJiYgdGV4dEVuY29kZXIgIT09IHZvaWQgMCA/IHRleHRFbmNvZGVyIDogbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICB0aGlzLmNodW5rcyA9IFtdO1xyXG4gICAgdGhpcy5idWYgPSBbXTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCBieXRlcyB3cml0dGVuIGFuZCByZXNldCB0aGlzIHdyaXRlci5cclxuICAgKi9cclxuICBmaW5pc2goKSB7XHJcbiAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7IC8vIGZsdXNoIHRoZSBidWZmZXJcclxuICAgIGxldCBsZW4gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcclxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgYnl0ZXMuc2V0KHRoaXMuY2h1bmtzW2ldLCBvZmZzZXQpO1xyXG4gICAgICBvZmZzZXQgKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcclxuICAgIHJldHVybiBieXRlcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSBuZXcgZm9yayBmb3IgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGxpa2UgYSBtZXNzYWdlXHJcbiAgICogb3IgYSBwYWNrZWQgcmVwZWF0ZWQgZmllbGQuXHJcbiAgICpcclxuICAgKiBNdXN0IGJlIGpvaW5lZCBsYXRlciB3aXRoIGBqb2luKClgLlxyXG4gICAqL1xyXG4gIGZvcmsoKSB7XHJcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xyXG4gICAgICBjaHVua3M6IHRoaXMuY2h1bmtzLFxyXG4gICAgICBidWY6IHRoaXMuYnVmXHJcbiAgICB9KTtcclxuICAgIHRoaXMuY2h1bmtzID0gW107XHJcbiAgICB0aGlzLmJ1ZiA9IFtdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cclxuICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxyXG4gICAqL1xyXG4gIGpvaW4oKSB7XHJcbiAgICAvLyBnZXQgY2h1bmsgb2YgZm9ya1xyXG4gICAgbGV0IGNodW5rID0gdGhpcy5maW5pc2goKTtcclxuICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcclxuICAgIGxldCBwcmV2ID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgIGlmICghcHJldikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzdGF0ZSwgZm9yayBzdGFjayBlbXB0eVwiKTtcclxuICAgIHRoaXMuY2h1bmtzID0gcHJldi5jaHVua3M7XHJcbiAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xyXG4gICAgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxyXG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7XHJcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cclxuICAgKlxyXG4gICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxyXG4gICAqXHJcbiAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXHJcbiAgICovXHJcbiAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDApO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGNodW5rIG9mIHJhdyBieXRlcy5cclxuICAgKi9cclxuICByYXcoY2h1bmspIHtcclxuICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpO1xyXG4gICAgICB0aGlzLmJ1ZiA9IFtdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgdWludDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cclxuICAgKi9cclxuICB1aW50MzIodmFsdWUpIHtcclxuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XHJcbiAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXHJcbiAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XHJcbiAgICAgIHRoaXMuYnVmLnB1c2godmFsdWUgJiAweDdmIHwgMHg4MCk7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XHJcbiAgICB9XHJcbiAgICB0aGlzLmJ1Zi5wdXNoKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgaW50MzIodmFsdWUpIHtcclxuICAgIGFzc2VydEludDMyKHZhbHVlKTtcclxuICAgIHZhcmludDMyd3JpdGUodmFsdWUsIHRoaXMuYnVmKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxyXG4gICAqL1xyXG4gIGJvb2wodmFsdWUpIHtcclxuICAgIHRoaXMuYnVmLnB1c2godmFsdWUgPyAxIDogMCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgYnl0ZXNgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxyXG4gICAqL1xyXG4gIGJ5dGVzKHZhbHVlKSB7XHJcbiAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxyXG4gICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgc3RyaW5nYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBkYXRhIGNvbnZlcnRlZCB0byBVVEYtOCB0ZXh0LlxyXG4gICAqL1xyXG4gIHN0cmluZyh2YWx1ZSkge1xyXG4gICAgbGV0IGNodW5rID0gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUodmFsdWUpO1xyXG4gICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcclxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGZsb2F0YCB2YWx1ZSwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cclxuICAgKi9cclxuICBmbG9hdCh2YWx1ZSkge1xyXG4gICAgYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XHJcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0MzIoMCwgdmFsdWUsIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgZG91YmxlYCB2YWx1ZSwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxyXG4gICAqL1xyXG4gIGRvdWJsZSh2YWx1ZSkge1xyXG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XHJcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRGbG9hdDY0KDAsIHZhbHVlLCB0cnVlKTtcclxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGZpeGVkMzJgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIGZpeGVkMzIodmFsdWUpIHtcclxuICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XHJcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldFVpbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXHJcbiAgICovXHJcbiAgc2ZpeGVkMzIodmFsdWUpIHtcclxuICAgIGFzc2VydEludDMyKHZhbHVlKTtcclxuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgc2ludDMyYCB2YWx1ZSwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgc2ludDMyKHZhbHVlKSB7XHJcbiAgICBhc3NlcnRJbnQzMih2YWx1ZSk7XHJcbiAgICAvLyB6aWd6YWcgZW5jb2RlXHJcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwO1xyXG4gICAgdmFyaW50MzJ3cml0ZSh2YWx1ZSwgdGhpcy5idWYpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIHNmaXhlZDY0KHZhbHVlKSB7XHJcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcclxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxyXG4gICAgICB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcclxuICAgIHZpZXcuc2V0SW50MzIoMCwgdGMubG8sIHRydWUpO1xyXG4gICAgdmlldy5zZXRJbnQzMig0LCB0Yy5oaSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cclxuICAgKi9cclxuICBmaXhlZDY0KHZhbHVlKSB7XHJcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcclxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxyXG4gICAgICB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XHJcbiAgICB2aWV3LnNldEludDMyKDAsIHRjLmxvLCB0cnVlKTtcclxuICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgaW50NjRgIHZhbHVlLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIGludDY0KHZhbHVlKSB7XHJcbiAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSk7XHJcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyaXRlIGEgYHNpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cclxuICAgKi9cclxuICBzaW50NjQodmFsdWUpIHtcclxuICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKSxcclxuICAgICAgLy8gemlnemFnIGVuY29kZVxyXG4gICAgICBzaWduID0gdGMuaGkgPj4gMzEsXHJcbiAgICAgIGxvID0gdGMubG8gPDwgMSBeIHNpZ24sXHJcbiAgICAgIGhpID0gKHRjLmhpIDw8IDEgfCB0Yy5sbyA+Pj4gMzEpIF4gc2lnbjtcclxuICAgIHZhcmludDY0d3JpdGUobG8sIGhpLCB0aGlzLmJ1Zik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cclxuICAgKi9cclxuICB1aW50NjQodmFsdWUpIHtcclxuICAgIGxldCB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XHJcbiAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59XHJcbmNsYXNzIEJpbmFyeVJlYWRlciB7XHJcbiAgY29uc3RydWN0b3IoYnVmLCB0ZXh0RGVjb2Rlcikge1xyXG4gICAgdGhpcy52YXJpbnQ2NCA9IHZhcmludDY0cmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYSBgdWludDMyYCBmaWVsZCwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cclxuICAgICAqL1xyXG4gICAgdGhpcy51aW50MzIgPSB2YXJpbnQzMnJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYCBhbmQgYWNjZXNzIHRvIHByb3RlY3RlZCBgYnVmYFxyXG4gICAgdGhpcy5idWYgPSBidWY7XHJcbiAgICB0aGlzLmxlbiA9IGJ1Zi5sZW5ndGg7XHJcbiAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcclxuICAgIHRoaXMudGV4dERlY29kZXIgPSB0ZXh0RGVjb2RlciAhPT0gbnVsbCAmJiB0ZXh0RGVjb2RlciAhPT0gdm9pZCAwID8gdGV4dERlY29kZXIgOiBuZXcgVGV4dERlY29kZXIoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZHMgYSB0YWcgLSBmaWVsZCBudW1iZXIgYW5kIHdpcmUgdHlwZS5cclxuICAgKi9cclxuICB0YWcoKSB7XHJcbiAgICBsZXQgdGFnID0gdGhpcy51aW50MzIoKSxcclxuICAgICAgZmllbGRObyA9IHRhZyA+Pj4gMyxcclxuICAgICAgd2lyZVR5cGUgPSB0YWcgJiA3O1xyXG4gICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHRhZzogZmllbGQgbm8gXCIgKyBmaWVsZE5vICsgXCIgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xyXG4gICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNraXAgb25lIGVsZW1lbnQgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxyXG4gICAqXHJcbiAgICogV2hlbiBza2lwcGluZyBTdGFydEdyb3VwLCBwcm92aWRlIHRoZSB0YWdzIGZpZWxkIG51bWJlciB0byBjaGVjayBmb3JcclxuICAgKiBtYXRjaGluZyBmaWVsZCBudW1iZXIgaW4gdGhlIEVuZEdyb3VwIHRhZy5cclxuICAgKi9cclxuICBza2lwKHdpcmVUeXBlLCBmaWVsZE5vKSB7XHJcbiAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcclxuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgY2FzZSBXaXJlVHlwZS5WYXJpbnQ6XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMHg4MCkge1xyXG4gICAgICAgICAgLy8gaWdub3JlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXHJcbiAgICAgIGNhc2UgV2lyZVR5cGUuQml0NjQ6XHJcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxyXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDMyOlxyXG4gICAgICAgIHRoaXMucG9zICs9IDQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkOlxyXG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpO1xyXG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxyXG4gICAgICAgIGZvciAoOzspIHtcclxuICAgICAgICAgIGNvbnN0IFtmbiwgd3RdID0gdGhpcy50YWcoKTtcclxuICAgICAgICAgIGlmICh3dCA9PT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkTm8gIT09IHVuZGVmaW5lZCAmJiBmbiAhPT0gZmllbGRObykge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW5kIGdyb3VwIHRhZ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuc2tpcCh3dCwgZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcclxuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXHJcbiAgICovXHJcbiAgYXNzZXJ0Qm91bmRzKCkge1xyXG4gICAgaWYgKHRoaXMucG9zID4gdGhpcy5sZW4pIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgaW50MzIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgc2ludDMyYCBmaWVsZCwgYSBzaWduZWQsIHppZ3phZy1lbmNvZGVkIDMyLWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgc2ludDMyKCkge1xyXG4gICAgbGV0IHp6ZSA9IHRoaXMudWludDMyKCk7XHJcbiAgICAvLyBkZWNvZGUgemlnemFnXHJcbiAgICByZXR1cm4genplID4+PiAxIF4gLSh6emUgJiAxKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBpbnQ2NGAgZmllbGQsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgaW50NjQoKSB7XHJcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxyXG4gICAqL1xyXG4gIHVpbnQ2NCgpIHtcclxuICAgIHJldHVybiBwcm90b0ludDY0LnVEZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBzaW50NjRgIGZpZWxkLCBhIHNpZ25lZCwgemlnLXphZy1lbmNvZGVkIDY0LWJpdCB2YXJpbnQuXHJcbiAgICovXHJcbiAgc2ludDY0KCkge1xyXG4gICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xyXG4gICAgLy8gZGVjb2RlIHppZyB6YWdcclxuICAgIGxldCBzID0gLShsbyAmIDEpO1xyXG4gICAgbG8gPSAobG8gPj4+IDEgfCAoaGkgJiAxKSA8PCAzMSkgXiBzO1xyXG4gICAgaGkgPSBoaSA+Pj4gMSBeIHM7XHJcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMobG8sIGhpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBib29sYCBmaWVsZCwgYSB2YXJpYW50LlxyXG4gICAqL1xyXG4gIGJvb2woKSB7XHJcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XHJcbiAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXHJcbiAgICovXHJcbiAgZml4ZWQzMigpIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0VWludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYHNmaXhlZDMyYCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cclxuICAgKi9cclxuICBzZml4ZWQzMigpIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgZml4ZWQ2NGAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggNjQgYml0IGludGVnZXIuXHJcbiAgICovXHJcbiAgZml4ZWQ2NCgpIHtcclxuICAgIHJldHVybiBwcm90b0ludDY0LnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxyXG4gICAqL1xyXG4gIHNmaXhlZDY0KCkge1xyXG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBmbG9hdGAgZmllbGQsIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIuXHJcbiAgICovXHJcbiAgZmxvYXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJlYWQgYSBgZG91YmxlYCBmaWVsZCwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxyXG4gICAqL1xyXG4gIGRvdWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXHJcbiAgICovXHJcbiAgYnl0ZXMoKSB7XHJcbiAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKSxcclxuICAgICAgc3RhcnQgPSB0aGlzLnBvcztcclxuICAgIHRoaXMucG9zICs9IGxlbjtcclxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XHJcbiAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVhZCBhIGBzdHJpbmdgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXHJcbiAgICovXHJcbiAgc3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnl0ZXMoKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VFeHRlbnNpb24ocnVudGltZSwgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCkge1xyXG4gIGxldCBmaTtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZU5hbWUsXHJcbiAgICBleHRlbmRlZSxcclxuICAgIGdldCBmaWVsZCgpIHtcclxuICAgICAgaWYgKCFmaSkge1xyXG4gICAgICAgIGNvbnN0IGkgPSB0eXBlb2YgZmllbGQgPT0gXCJmdW5jdGlvblwiID8gZmllbGQoKSA6IGZpZWxkO1xyXG4gICAgICAgIGkubmFtZSA9IHR5cGVOYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcclxuICAgICAgICBpLmpzb25OYW1lID0gXCJbXCIuY29uY2F0KHR5cGVOYW1lLCBcIl1cIik7XHJcbiAgICAgICAgZmkgPSBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KFtpXSkubGlzdCgpWzBdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaTtcclxuICAgIH0sXHJcbiAgICBydW50aW1lXHJcbiAgfTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgY29udGFpbmVyIHRoYXQgYWxsb3dzIHVzIHRvIHJlYWQgZXh0ZW5zaW9uIGZpZWxkcyBpbnRvIGl0IHdpdGggdGhlXHJcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKSB7XHJcbiAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcclxuICBjb25zdCBjb250YWluZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIGNvbnRhaW5lcltsb2NhbE5hbWVdID0gaW5pdEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbik7XHJcbiAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcclxufVxyXG5mdW5jdGlvbiBpbml0RXh0ZW5zaW9uRmllbGQoZXh0KSB7XHJcbiAgY29uc3QgZmllbGQgPSBleHQuZmllbGQ7XHJcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGlmIChmaWVsZC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBmaWVsZC5kZWZhdWx0O1xyXG4gIH1cclxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgcmV0dXJuIHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKTtcclxuICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xyXG4gICAgICBjb25zdCBUID0gZmllbGQuVCxcclxuICAgICAgICB2YWx1ZSA9IG5ldyBUKCk7XHJcbiAgICAgIHJldHVybiBULmZpZWxkV3JhcHBlciA/IFQuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBmaWx0ZXIgdW5rbm93biBmaWVsZHMsIG9wdGltaXplZCBiYXNlZCBvbiBmaWVsZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xyXG4gIGlmICghZmllbGQucmVwZWF0ZWQgJiYgKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHwgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSkge1xyXG4gICAgLy8gc2luZ3VsYXIgc2NhbGFyIGZpZWxkcyBkbyBub3QgbWVyZ2UsIHdlIHBpY2sgdGhlIGxhc3RcclxuICAgIGZvciAobGV0IGkgPSB1bmtub3duRmllbGRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgIGlmICh1bmtub3duRmllbGRzW2ldLm5vID09IGZpZWxkLm5vKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1bmtub3duRmllbGRzW2ldXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICByZXR1cm4gdW5rbm93bkZpZWxkcy5maWx0ZXIodWYgPT4gdWYubm8gPT09IGZpZWxkLm5vKTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uLCBwcmVmZXItY29uc3QgKi9cclxuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXHJcbmxldCBlbmNUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLnNwbGl0KFwiXCIpO1xyXG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyICpjb2RlKiB0byBieXRlIGJlY2F1c2UgbG9va3VwIGJ5IG51bWJlciBpcyBmYXN0XHJcbmxldCBkZWNUYWJsZSA9IFtdO1xyXG5mb3IgKGxldCBpID0gMDsgaSA8IGVuY1RhYmxlLmxlbmd0aDsgaSsrKSBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XHJcbi8vIHN1cHBvcnQgYmFzZTY0dXJsIHZhcmlhbnRzXHJcbmRlY1RhYmxlW1wiLVwiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIitcIik7XHJcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XHJcbmNvbnN0IHByb3RvQmFzZTY0ID0ge1xyXG4gIC8qKlxyXG4gICAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cclxuICAgKlxyXG4gICAqIC0gaWdub3JlcyB3aGl0ZS1zcGFjZSwgaW5jbHVkaW5nIGxpbmUgYnJlYWtzIGFuZCB0YWJzXHJcbiAgICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXHJcbiAgICogLSBkb2VzIG5vdCByZXF1aXJlIHBhZGRpbmdcclxuICAgKiAtIHVuZGVyc3RhbmRzIGJhc2U2NHVybCBlbmNvZGluZzpcclxuICAgKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXHJcbiAgICogICBcIl9cIiBpbnN0ZWFkIG9mIFwiL1wiLFxyXG4gICAqICAgbm8gcGFkZGluZ1xyXG4gICAqL1xyXG4gIGRlYyhiYXNlNjRTdHIpIHtcclxuICAgIC8vIGVzdGltYXRlIGJ5dGUgc2l6ZSwgbm90IGFjY291bnRpbmcgZm9yIGlubmVyIHBhZGRpbmcgYW5kIHdoaXRlc3BhY2VcclxuICAgIGxldCBlcyA9IGJhc2U2NFN0ci5sZW5ndGggKiAzIC8gNDtcclxuICAgIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDJdID09IFwiPVwiKSBlcyAtPSAyO2Vsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpIGVzIC09IDE7XHJcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksXHJcbiAgICAgIGJ5dGVQb3MgPSAwLFxyXG4gICAgICAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XHJcbiAgICAgIGdyb3VwUG9zID0gMCxcclxuICAgICAgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXHJcbiAgICAgIGIsXHJcbiAgICAgIC8vIGN1cnJlbnQgYnl0ZVxyXG4gICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRTdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcclxuICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN3aXRjaCAoYmFzZTY0U3RyW2ldKSB7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcclxuICAgICAgICAgIGNhc2UgXCI9XCI6XHJcbiAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcclxuICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIHdoZW4gcGFkZGluZyBmb3VuZFxyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXHJcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XHJcbiAgICAgICAgICBjYXNlIFwiXFxyXCI6XHJcbiAgICAgICAgICBjYXNlIFwiXFx0XCI6XHJcbiAgICAgICAgICBjYXNlIFwiIFwiOlxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoZ3JvdXBQb3MpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICBwID0gYjtcclxuICAgICAgICAgIGdyb3VwUG9zID0gMTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSBwIDw8IDIgfCAoYiAmIDQ4KSA+PiA0O1xyXG4gICAgICAgICAgcCA9IGI7XHJcbiAgICAgICAgICBncm91cFBvcyA9IDI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgJiAxNSkgPDwgNCB8IChiICYgNjApID4+IDI7XHJcbiAgICAgICAgICBwID0gYjtcclxuICAgICAgICAgIGdyb3VwUG9zID0gMztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDMpIDw8IDYgfCBiO1xyXG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChncm91cFBvcyA9PSAxKSB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XHJcbiAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XHJcbiAgfSxcclxuICAvKipcclxuICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cclxuICAgKi9cclxuICBlbmMoYnl0ZXMpIHtcclxuICAgIGxldCBiYXNlNjQgPSBcIlwiLFxyXG4gICAgICBncm91cFBvcyA9IDAsXHJcbiAgICAgIC8vIHBvc2l0aW9uIGluIGJhc2U2NCBncm91cFxyXG4gICAgICBiLFxyXG4gICAgICAvLyBjdXJyZW50IGJ5dGVcclxuICAgICAgcCA9IDA7IC8vIGNhcnJ5IG92ZXIgZnJvbSBwcmV2aW91cyBieXRlXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGIgPSBieXRlc1tpXTtcclxuICAgICAgc3dpdGNoIChncm91cFBvcykge1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtiID4+IDJdO1xyXG4gICAgICAgICAgcCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgIGdyb3VwUG9zID0gMTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA0XTtcclxuICAgICAgICAgIHAgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3AgfCBiID4+IDZdO1xyXG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XHJcbiAgICAgICAgICBncm91cFBvcyA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXHJcbiAgICBpZiAoZ3JvdXBQb3MpIHtcclxuICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xyXG4gICAgICBiYXNlNjQgKz0gXCI9XCI7XHJcbiAgICAgIGlmIChncm91cFBvcyA9PSAxKSBiYXNlNjQgKz0gXCI9XCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmFzZTY0O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSBhbiBleHRlbnNpb24gdmFsdWUgZnJvbSBhIG1lc3NhZ2UuXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gVXNlIGhhc0V4dGVuc2lvbigpIHRvIGNoZWNrIHdoZXRoZXIgYW5cclxuICogZXh0ZW5zaW9uIGlzIHNldC4gSWYgdGhlIGV4dGVuc2lvbiBpcyBub3Qgc2V0LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlXHJcbiAqIGRlZmF1bHQgdmFsdWUgKGlmIG9uZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBwcm90b2J1ZiBzb3VyY2UpLCBvciB0aGUgemVybyB2YWx1ZVxyXG4gKiAoZm9yIGV4YW1wbGUgYDBgIGZvciBudW1lcmljIHR5cGVzLCBgW11gIGZvciByZXBlYXRlZCBleHRlbnNpb24gZmllbGRzLCBhbmRcclxuICogYW4gZW1wdHkgbWVzc2FnZSBpbnN0YW5jZSBmb3IgbWVzc2FnZSBmaWVsZHMpLlxyXG4gKlxyXG4gKiBFeHRlbnNpb25zIGFyZSBzdG9yZWQgYXMgdW5rbm93biBmaWVsZHMgb24gYSBtZXNzYWdlLiBUbyBtdXRhdGUgYW4gZXh0ZW5zaW9uXHJcbiAqIHZhbHVlLCBtYWtlIHN1cmUgdG8gc3RvcmUgdGhlIG5ldyB2YWx1ZSB3aXRoIHNldEV4dGVuc2lvbigpIGFmdGVyIG11dGF0aW5nLlxyXG4gKlxyXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgb3B0aW9ucykge1xyXG4gIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XHJcbiAgY29uc3Qgb3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcclxuICBjb25zdCB1ZnMgPSBmaWx0ZXJVbmtub3duRmllbGRzKG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLCBleHRlbnNpb24uZmllbGQpO1xyXG4gIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKTtcclxuICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xyXG4gICAgZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLnJlYWRGaWVsZChjb250YWluZXIsIG9wdC5yZWFkZXJGYWN0b3J5KHVmLmRhdGEpLCBleHRlbnNpb24uZmllbGQsIHVmLndpcmVUeXBlLCBvcHQpO1xyXG4gIH1cclxuICByZXR1cm4gZ2V0KCk7XHJcbn1cclxuLyoqXHJcbiAqIFNldCBhbiBleHRlbnNpb24gdmFsdWUgb24gYSBtZXNzYWdlLiBJZiB0aGUgbWVzc2FnZSBhbHJlYWR5IGhhcyBhIHZhbHVlIGZvclxyXG4gKiB0aGlzIGV4dGVuc2lvbiwgdGhlIHZhbHVlIGlzIHJlcGxhY2VkLlxyXG4gKlxyXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpO1xyXG4gIGNvbnN0IHJlYWRPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xyXG4gIGNvbnN0IHdyaXRlT3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgaWYgKGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pKSB7XHJcbiAgICBjb25zdCB1ZnMgPSBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKS5maWx0ZXIodWYgPT4gdWYubm8gIT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcclxuICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmRpc2NhcmRVbmtub3duRmllbGRzKG1lc3NhZ2UpO1xyXG4gICAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcclxuICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQobWVzc2FnZSwgdWYubm8sIHVmLndpcmVUeXBlLCB1Zi5kYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3Qgd3JpdGVyID0gd3JpdGVPcHQud3JpdGVyRmFjdG9yeSgpO1xyXG4gIGxldCBmID0gZXh0ZW5zaW9uLmZpZWxkO1xyXG4gIC8vIEltcGxpY2l0IHByZXNlbmNlIGRvZXMgbm90IGFwcGx5IHRvIGV4dGVuc2lvbnMsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2lzc3Vlcy84MjM0XHJcbiAgLy8gV2UgcGF0Y2ggdGhlIGZpZWxkIGluZm8gdG8gdXNlIGV4cGxpY2l0IHByZXNlbmNlOlxyXG4gIGlmICghZi5vcHQgJiYgIWYucmVwZWF0ZWQgJiYgKGYua2luZCA9PSBcImVudW1cIiB8fCBmLmtpbmQgPT0gXCJzY2FsYXJcIikpIHtcclxuICAgIGYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbi5maWVsZCksIHtcclxuICAgICAgb3B0OiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLndyaXRlRmllbGQoZiwgdmFsdWUsIHdyaXRlciwgd3JpdGVPcHQpO1xyXG4gIGNvbnN0IHJlYWRlciA9IHJlYWRPcHQucmVhZGVyRmFjdG9yeSh3cml0ZXIuZmluaXNoKCkpO1xyXG4gIHdoaWxlIChyZWFkZXIucG9zIDwgcmVhZGVyLmxlbikge1xyXG4gICAgY29uc3QgW25vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XHJcbiAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIG5vKTtcclxuICAgIG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGFuIGV4dGVuc2lvbiBpcyBzZXQgb24gYSBtZXNzYWdlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xyXG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XHJcbiAgcmV0dXJuIGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSA9PT0gbWVzc2FnZVR5cGUudHlwZU5hbWUgJiYgISFtZXNzYWdlVHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKS5maW5kKHVmID0+IHVmLm5vID09IGV4dGVuc2lvbi5maWVsZC5ubyk7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKSB7XHJcbiAgYXNzZXJ0KGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSA9PSBtZXNzYWdlLmdldFR5cGUoKS50eXBlTmFtZSwgXCJleHRlbnNpb24gXCIuY29uY2F0KGV4dGVuc2lvbi50eXBlTmFtZSwgXCIgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBtZXNzYWdlIFwiKS5jb25jYXQoZXh0ZW5zaW9uLmV4dGVuZGVlLnR5cGVOYW1lKSk7XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpZWxkIGlzIHNldC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xyXG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcclxuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcclxuICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXS5sZW5ndGggPiAwO1xyXG4gIH1cclxuICBpZiAoZmllbGQub25lb2YpIHtcclxuICAgIHJldHVybiB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXS5jYXNlID09PSBsb2NhbE5hbWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXHJcbiAgfVxyXG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgY2FzZSBcImVudW1cIjpcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcclxuICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGltcGxpY2l0IHByZXNlbmNlXHJcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwiZW51bVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSBmaWVsZC5ULnZhbHVlc1swXS5ubztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gIWlzU2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIHRhcmdldFtsb2NhbE5hbWVdKTtcclxuICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0W2xvY2FsTmFtZV0pLmxlbmd0aCA+IDA7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlc2V0cyB0aGUgZmllbGQsIHNvIHRoYXQgaXNGaWVsZFNldCgpIHdpbGwgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KSB7XHJcbiAgY29uc3QgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xyXG4gIGNvbnN0IGltcGxpY2l0UHJlc2VuY2UgPSAhZmllbGQub3B0ICYmICFmaWVsZC5yZXE7XHJcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XHJcbiAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IFtdO1xyXG4gIH0gZWxzZSBpZiAoZmllbGQub25lb2YpIHtcclxuICAgIHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xyXG4gICAgICBjYXNlOiB1bmRlZmluZWRcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgICBjYXNlIFwibWFwXCI6XHJcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSB7fTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gaW1wbGljaXRQcmVzZW5jZSA/IHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxyXG4vL1xyXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4vL1xyXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYW55IHN1YnR5cGUgb2YgTWVzc2FnZSBvciBpcyBhIHNwZWNpZmljXHJcbiAqIE1lc3NhZ2UgYnkgcGFzc2luZyB0aGUgdHlwZS5cclxuICpcclxuICogSnVzdCBsaWtlIGBpbnN0YW5jZW9mYCwgYGlzTWVzc2FnZWAgbmFycm93cyB0aGUgdHlwZS4gVGhlIGFkdmFudGFnZSBvZlxyXG4gKiBgaXNNZXNzYWdlYCBpcyB0aGF0IGl0IGNvbXBhcmVzIGlkZW50aXR5IGJ5IHRoZSBtZXNzYWdlIHR5cGUgbmFtZSwgbm90IGJ5XHJcbiAqIGNsYXNzIGlkZW50aXR5LiBUaGlzIG1ha2VzIGl0IHJvYnVzdCBhZ2FpbnN0IHRoZSBkdWFsIHBhY2thZ2UgaGF6YXJkIGFuZFxyXG4gKiBzaW1pbGFyIHNpdHVhdGlvbnMsIHdoZXJlIHRoZSBzYW1lIG1lc3NhZ2UgaXMgZHVwbGljYXRlZC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBfbW9zdGx5XyBlcXVpdmFsZW50IHRvIHRoZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IuIEZvclxyXG4gKiBleGFtcGxlLCBgaXNNZXNzYWdlKGZvbywgTXlNZXNzYWdlKWAgaXMgdGhlIHNhbWUgYXMgYGZvbyBpbnN0YW5jZW9mIE15TWVzc2FnZWAsXHJcbiAqIGFuZCBgaXNNZXNzYWdlKGZvbylgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNZXNzYWdlYC4gSW4gbW9zdCBjYXNlcyxcclxuICogYGlzTWVzc2FnZWAgc2hvdWxkIGJlIHByZWZlcnJlZCBvdmVyIGBpbnN0YW5jZW9mYC5cclxuICpcclxuICogSG93ZXZlciwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgYGlzTWVzc2FnZWAgZG9lcyBub3QgdXNlIGNsYXNzIGlkZW50aXR5LCB0aGVyZVxyXG4gKiBhcmUgc3VidGxlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBmdW5jdGlvbiBhbmQgYGluc3RhbmNlb2ZgLiBOb3RhYmx5LFxyXG4gKiBjYWxsaW5nIGBpc01lc3NhZ2VgIG9uIGFuIGV4cGxpY2l0IHR5cGUgb2YgTWVzc2FnZSB3aWxsIHJldHVybiBmYWxzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzTWVzc2FnZShhcmcsIHR5cGUpIHtcclxuICBpZiAoYXJnID09PSBudWxsIHx8IHR5cGVvZiBhcmcgIT0gXCJvYmplY3RcIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1lc3NhZ2UucHJvdG90eXBlKS5ldmVyeShtID0+IG0gaW4gYXJnICYmIHR5cGVvZiBhcmdbbV0gPT0gXCJmdW5jdGlvblwiKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCBhY3R1YWxUeXBlID0gYXJnLmdldFR5cGUoKTtcclxuICBpZiAoYWN0dWFsVHlwZSA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsVHlwZSAhPSBcImZ1bmN0aW9uXCIgfHwgIShcInR5cGVOYW1lXCIgaW4gYWN0dWFsVHlwZSkgfHwgdHlwZW9mIGFjdHVhbFR5cGUudHlwZU5hbWUgIT0gXCJzdHJpbmdcIikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdHlwZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFjdHVhbFR5cGUudHlwZU5hbWUgPT0gdHlwZS50eXBlTmFtZTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIFdyYXAgYSBwcmltaXRpdmUgbWVzc2FnZSBmaWVsZCB2YWx1ZSBpbiBpdHMgY29ycmVzcG9uZGluZyB3cmFwcGVyXHJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cclxuICovXHJcbmZ1bmN0aW9uIHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSkge1xyXG4gIGlmIChpc01lc3NhZ2UodmFsdWUpIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gdHlwZS5maWVsZFdyYXBwZXIud3JhcEZpZWxkKHZhbHVlKTtcclxufVxyXG4oe1xyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlXCI6IFNjYWxhclR5cGUuRE9VQkxFLFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjogU2NhbGFyVHlwZS5GTE9BVCxcclxuICBcImdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlXCI6IFNjYWxhclR5cGUuSU5UNjQsXHJcbiAgXCJnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UNjQsXHJcbiAgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDMyLFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuVUlOVDMyLFxyXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZVwiOiBTY2FsYXJUeXBlLkJPT0wsXHJcbiAgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjogU2NhbGFyVHlwZS5TVFJJTkcsXHJcbiAgXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiOiBTY2FsYXJUeXBlLkJZVEVTXHJcbn0pO1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xyXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgSlNPTi5cclxuY29uc3QganNvblJlYWREZWZhdWx0cyA9IHtcclxuICBpZ25vcmVVbmtub3duRmllbGRzOiBmYWxzZVxyXG59O1xyXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIHRvIEpTT04uXHJcbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xyXG4gIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcclxuICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcclxuICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXHJcbiAgcHJldHR5U3BhY2VzOiAwXHJcbn07XHJcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyQxKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvblJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDoganNvblJlYWREZWZhdWx0cztcclxufVxyXG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zJDEob3B0aW9ucykge1xyXG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uV3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDoganNvbldyaXRlRGVmYXVsdHM7XHJcbn1cclxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XHJcbmNvbnN0IHRva2VuSWdub3JlZFVua25vd25FbnVtID0gU3ltYm9sKCk7XHJcbmZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0KCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBtYWtlUmVhZE9wdGlvbnM6IG1ha2VSZWFkT3B0aW9ucyQxLFxyXG4gICAgbWFrZVdyaXRlT3B0aW9uczogbWFrZVdyaXRlT3B0aW9ucyQxLFxyXG4gICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xyXG4gICAgICBpZiAoanNvbiA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoanNvbikgfHwgdHlwZW9mIGpzb24gIT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XHJcbiAgICAgIH1cclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IG5ldyB0eXBlKCk7XHJcbiAgICAgIGNvbnN0IG9uZW9mU2VlbiA9IG5ldyBNYXAoKTtcclxuICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcclxuICAgICAgZm9yIChjb25zdCBbanNvbktleSwganNvblZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uKSkge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZEpzb25OYW1lKGpzb25LZXkpO1xyXG4gICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XHJcbiAgICAgICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiYgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XHJcbiAgICAgICAgICAgICAgLy8gc2VlIGNvbmZvcm1hbmNlIHRlc3QgUmVxdWlyZWQuUHJvdG8zLkpzb25JbnB1dC5PbmVvZkZpZWxkTnVsbHtGaXJzdCxTZWNvbmR9XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xyXG4gICAgICAgICAgICBpZiAoc2VlbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IG11bHRpcGxlIGtleXMgZm9yIG9uZW9mIFxcXCJcIikuY29uY2F0KGZpZWxkLm9uZW9mLm5hbWUsIFwiXFxcIiBwcmVzZW50OiBcXFwiXCIpLmNvbmNhdChzZWVuLCBcIlxcXCIsIFxcXCJcIikuY29uY2F0KGpzb25LZXksIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb25lb2ZTZWVuLnNldChmaWVsZC5vbmVvZiwganNvbktleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZWFkRmllbGQkMShtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJiBqc29uS2V5LnN0YXJ0c1dpdGgoXCJbXCIpICYmIGpzb25LZXkuZW5kc1dpdGgoXCJdXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb24oanNvbktleS5zdWJzdHJpbmcoMSwganNvbktleS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIGlmIChleHQgJiYgZXh0LmV4dGVuZGVlLnR5cGVOYW1lID09IHR5cGUudHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgY29uc3QgW2NvbnRhaW5lciwgZ2V0XSA9IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHQpO1xyXG4gICAgICAgICAgICAgIHJlYWRGaWVsZCQxKGNvbnRhaW5lciwganNvblZhbHVlLCBleHQuZmllbGQsIG9wdGlvbnMsIGV4dCk7XHJcbiAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucy9CaW5hcnlXcml0ZU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgLy8gc28gdGhhdCB1c2VycyBjYW4gYnJpbmcgdGhlaXIgb3duIGJpbmFyeSByZWFkZXIgYW5kIHdyaXRlciBmYWN0b3JpZXNcclxuICAgICAgICAgICAgICAvLyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgc2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgZ2V0KCksIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IGtleSBcXFwiXCIpLmNvbmNhdChqc29uS2V5LCBcIlxcXCIgaXMgdW5rbm93blwiKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfSxcclxuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcclxuICAgICAgY29uc3QganNvbiA9IHt9O1xyXG4gICAgICBsZXQgZmllbGQ7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XHJcbiAgICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xyXG4gICAgICAgICAgICAgIHRocm93IFwicmVxdWlyZWQgZmllbGQgbm90IHNldFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlKGZpZWxkKSkge1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLm9uZW9mID8gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdLnZhbHVlIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xyXG4gICAgICAgICAgY29uc3QganNvblZhbHVlID0gd3JpdGVGaWVsZCQxKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICBpZiAoanNvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcclxuICAgICAgICBpZiAocmVnaXN0cnkgPT09IG51bGwgfHwgcmVnaXN0cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb25Gb3IpIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKHR5cGUudHlwZU5hbWUsIHVmLm5vKTtcclxuICAgICAgICAgICAgaWYgKGV4dCAmJiBoYXNFeHRlbnNpb24obWVzc2FnZSwgZXh0KSkge1xyXG4gICAgICAgICAgICAgIC8vIFdlIHBhc3Mgb24gdGhlIG9wdGlvbnMgYXMgQmluYXJ5UmVhZE9wdGlvbnMsIHNvIHRoYXQgdXNlcnMgY2FuIGJyaW5nIHRoZWlyIG93blxyXG4gICAgICAgICAgICAgIC8vIGJpbmFyeSByZWFkZXIgZmFjdG9yeSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkJDEoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBqc29uW2V4dC5maWVsZC5qc29uTmFtZV0gPSBqc29uVmFsdWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IGZpZWxkID8gXCJjYW5ub3QgZW5jb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIHRvIEpTT05cIikgOiBcImNhbm5vdCBlbmNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgdG8gSlNPTlwiKTtcclxuICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IFwiOiBcIi5jb25jYXQocikgOiBcIlwiKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGpzb247XHJcbiAgICB9LFxyXG4gICAgcmVhZFNjYWxhcih0eXBlLCBqc29uLCBsb25nVHlwZSkge1xyXG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZC4gRm9yIGJhY2t3YXJkcy1cclxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgIC8vIHRocm91Z2ggdGhlIGludGVyZmFjZSBKc29uRm9ybWF0LlxyXG4gICAgICByZXR1cm4gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XHJcbiAgICB9LFxyXG4gICAgd3JpdGVTY2FsYXIodHlwZSwgdmFsdWUsIGVtaXREZWZhdWx0VmFsdWVzKSB7XHJcbiAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxyXG4gICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcclxuICAgICAgLy8gdGhyb3VnaCB0aGUgaW50ZXJmYWNlIEpzb25Gb3JtYXQuXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZW1pdERlZmF1bHRWYWx1ZXMgfHwgaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG4gICAgZGVidWc6IGRlYnVnSnNvblZhbHVlXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWJ1Z0pzb25WYWx1ZShqc29uKSB7XHJcbiAgaWYgKGpzb24gPT09IG51bGwpIHtcclxuICAgIHJldHVybiBcIm51bGxcIjtcclxuICB9XHJcbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xyXG4gICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShqc29uKSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCI7XHJcbiAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgIHJldHVybiBqc29uLmxlbmd0aCA+IDEwMCA/IFwic3RyaW5nXCIgOiBcIlxcXCJcIi5jb25jYXQoanNvbi5zcGxpdCgnXCInKS5qb2luKCdcXFxcXCInKSwgXCJcXFwiXCIpO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIFN0cmluZyhqc29uKTtcclxuICB9XHJcbn1cclxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXHJcbi8vIFRoZSBcInBhcmVudFR5cGVcIiBhcmd1bWVudCBpcyBvbmx5IHVzZWQgdG8gcHJvdmlkZSBjb250ZXh0IGluIGVycm9ycy5cclxuZnVuY3Rpb24gcmVhZEZpZWxkJDEodGFyZ2V0LCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCBwYXJlbnRUeXBlKSB7XHJcbiAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcclxuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcclxuICAgIGFzc2VydChmaWVsZC5raW5kICE9IFwibWFwXCIpO1xyXG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xyXG4gICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcclxuICAgICAgaWYgKGpzb25JdGVtID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pKSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XHJcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgIHRhcmdldEFycmF5LnB1c2goZmllbGQuVC5mcm9tSnNvbihqc29uSXRlbSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xyXG4gICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdG9rZW5JZ25vcmVkVW5rbm93bkVudW0pIHtcclxuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChyZWFkU2NhbGFyJDEoZmllbGQuVCwganNvbkl0ZW0sIGZpZWxkLkwsIHRydWUpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25JdGVtKSk7XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XHJcbiAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YganNvblZhbHVlICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhcmdldE1hcCA9IHRhcmdldFtsb2NhbE5hbWVdO1xyXG4gICAgZm9yIChjb25zdCBbanNvbk1hcEtleSwganNvbk1hcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uVmFsdWUpKSB7XHJcbiAgICAgIGlmIChqc29uTWFwVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogbWFwIHZhbHVlIG51bGxcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBrZXk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtID0gXCJjYW5ub3QgZGVjb2RlIG1hcCBrZXkgZm9yIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XHJcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gZmllbGQuVi5ULmZyb21Kc29uKGpzb25NYXBWYWx1ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcywgdHJ1ZSk7XHJcbiAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xyXG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGVudW1WYWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gcmVhZFNjYWxhciQxKGZpZWxkLlYuVCwganNvbk1hcFZhbHVlLCBMb25nVHlwZS5CSUdJTlQsIHRydWUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChmaWVsZC5vbmVvZikge1xyXG4gICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHtcclxuICAgICAgICBjYXNlOiBsb2NhbE5hbWVcclxuICAgICAgfTtcclxuICAgICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XHJcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xyXG4gICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwgJiYgbWVzc2FnZVR5cGUudHlwZU5hbWUgIT0gXCJnb29nbGUucHJvdG9idWYuVmFsdWVcIikge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGFyZ2V0W2xvY2FsTmFtZV07XHJcbiAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICBjdXJyZW50VmFsdWUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlciAmJiAhZmllbGQub25lb2YpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQoY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVCwganNvblZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIGZhbHNlKTtcclxuICAgICAgICBzd2l0Y2ggKGVudW1WYWx1ZSkge1xyXG4gICAgICAgICAgY2FzZSB0b2tlbk51bGw6XHJcbiAgICAgICAgICAgIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSB0b2tlbklnbm9yZWRVbmtub3duRW51bTpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHNjYWxhclZhbHVlID0gcmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25WYWx1ZSwgZmllbGQuTCwgZmFsc2UpO1xyXG4gICAgICAgICAgc3dpdGNoIChzY2FsYXJWYWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIHRva2VuTnVsbDpcclxuICAgICAgICAgICAgICBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpO1xyXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlYWRNYXBLZXkodHlwZSwganNvbikge1xyXG4gIGlmICh0eXBlID09PSBTY2FsYXJUeXBlLkJPT0wpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXHJcbiAgICBzd2l0Y2ggKGpzb24pIHtcclxuICAgICAgY2FzZSBcInRydWVcIjpcclxuICAgICAgICBqc29uID0gdHJ1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImZhbHNlXCI6XHJcbiAgICAgICAganNvbiA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVhZFNjYWxhciQxKHR5cGUsIGpzb24sIExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSkudG9TdHJpbmcoKTtcclxufVxyXG5mdW5jdGlvbiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgbG9uZ1R5cGUsIG51bGxBc1plcm9WYWx1ZSkge1xyXG4gIGlmIChqc29uID09PSBudWxsKSB7XHJcbiAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBzY2FsYXJaZXJvVmFsdWUodHlwZSwgbG9uZ1R5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRva2VuTnVsbDtcclxuICB9XHJcbiAgLy8gZXZlcnkgdmFsaWQgY2FzZSBpbiB0aGUgc3dpdGNoIGJlbG93IHJldHVybnMsIGFuZCBldmVyeSBmYWxsXHJcbiAgLy8gdGhyb3VnaCBpcyByZWdhcmRlZCBhcyBhIGZhaWx1cmUuXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAvLyBmbG9hdCwgZG91YmxlOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBudW1iZXIgb3Igb25lIG9mIHRoZSBzcGVjaWFsIHN0cmluZyB2YWx1ZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiLCBhbmQgXCItSW5maW5pdHlcIi5cclxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcclxuICAgICAgaWYgKGpzb24gPT09IFwiTmFOXCIpIHJldHVybiBOdW1iZXIuTmFOO1xyXG4gICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICBpZiAoanNvbiA9PT0gXCItSW5maW5pdHlcIikgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgaWYgKGpzb24gPT09IFwiXCIpIHtcclxuICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IGEgbnVtYmVyXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi50cmltKCkubGVuZ3RoICE9PSBqc29uLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIGV4dHJhIHdoaXRlc3BhY2VcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZmxvYXQgPSBOdW1iZXIoanNvbik7XHJcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XHJcbiAgICAgICAgLy8gbm90IGEgbnVtYmVyXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XHJcbiAgICAgICAgLy8gaW5maW5pdHkgYW5kIC1pbmZpbml0eSBhcmUgaGFuZGxlZCBieSBzdHJpbmcgcmVwcmVzZW50YXRpb24gYWJvdmUsIHNvIHRoaXMgaXMgYW4gZXJyb3JcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLkZMT0FUKSBhc3NlcnRGbG9hdDMyKGZsb2F0KTtcclxuICAgICAgcmV0dXJuIGZsb2F0O1xyXG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcclxuICAgICAgbGV0IGludDMyO1xyXG4gICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJudW1iZXJcIikgaW50MzIgPSBqc29uO2Vsc2UgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaWYgKGpzb24udHJpbSgpLmxlbmd0aCA9PT0ganNvbi5sZW5ndGgpIGludDMyID0gTnVtYmVyKGpzb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKSBicmVhaztcclxuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpIGFzc2VydFVJbnQzMihpbnQzMik7ZWxzZSBhc3NlcnRJbnQzMihpbnQzMik7XHJcbiAgICAgIHJldHVybiBpbnQzMjtcclxuICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XHJcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpIGJyZWFrO1xyXG4gICAgICBjb25zdCBsb25nID0gcHJvdG9JbnQ2NC5wYXJzZShqc29uKTtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xyXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKSBicmVhaztcclxuICAgICAgY29uc3QgdUxvbmcgPSBwcm90b0ludDY0LnVQYXJzZShqc29uKTtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xyXG4gICAgICByZXR1cm4gbG9uZ1R5cGUgPyB1TG9uZy50b1N0cmluZygpIDogdUxvbmc7XHJcbiAgICAvLyBib29sOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XHJcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpIGJyZWFrO1xyXG4gICAgICByZXR1cm4ganNvbjtcclxuICAgIC8vIHN0cmluZzpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XHJcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEEgc3RyaW5nIG11c3QgYWx3YXlzIGNvbnRhaW4gVVRGLTggZW5jb2RlZCBvciA3LWJpdCBBU0NJSS5cclxuICAgICAgLy8gV2UgdmFsaWRhdGUgd2l0aCBlbmNvZGVVUklDb21wb25lbnQsIHdoaWNoIGFwcGVhcnMgdG8gYmUgdGhlIGZhc3Rlc3Qgd2lkZWx5IGF2YWlsYWJsZSBvcHRpb24uXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBVVEY4XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBqc29uO1xyXG4gICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxyXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxyXG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xyXG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIGJyZWFrO1xyXG4gICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZGVjKGpzb24pO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoKTtcclxufVxyXG5mdW5jdGlvbiByZWFkRW51bSh0eXBlLCBqc29uLCBpZ25vcmVVbmtub3duRmllbGRzLCBudWxsQXNaZXJvVmFsdWUpIHtcclxuICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcclxuICAgICAgcmV0dXJuIDA7IC8vIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUuTlVMTF9WQUxVRSA9IDBcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsQXNaZXJvVmFsdWUgPyB0eXBlLnZhbHVlc1swXS5ubyA6IHRva2VuTnVsbDtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcclxuICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XHJcbiAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGpzb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIGpzb247XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gdHlwZS5maW5kTmFtZShqc29uKTtcclxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubm87XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlnbm9yZVVua25vd25GaWVsZHMpIHtcclxuICAgICAgICByZXR1cm4gdG9rZW5JZ25vcmVkVW5rbm93bkVudW07XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZW51bSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb24pKSk7XHJcbn1cclxuLy8gRGVjaWRlIHdoZXRoZXIgYW4gdW5zZXQgZmllbGQgc2hvdWxkIGJlIGVtaXR0ZWQgd2l0aCBKU09OIHdyaXRlIG9wdGlvbiBgZW1pdERlZmF1bHRWYWx1ZXNgXHJcbmZ1bmN0aW9uIGNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZShmaWVsZCkge1xyXG4gIGlmIChmaWVsZC5yZXBlYXRlZCB8fCBmaWVsZC5raW5kID09IFwibWFwXCIpIHtcclxuICAgIC8vIG1hcHMgYXJlIHt9LCByZXBlYXRlZCBmaWVsZHMgYXJlIFtdXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKGZpZWxkLm9uZW9mKSB7XHJcbiAgICAvLyBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIGVtaXR0ZWRcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcclxuICAgIC8vIHNpbmd1bGFyIG1lc3NhZ2UgZmllbGQgYXJlIGFsbG93ZWQgdG8gZW1pdCBKU09OIG51bGwsIGJ1dCB3ZSBkbyBub3RcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xyXG4gIGlmIChmaWVsZC5vcHQgfHwgZmllbGQucmVxKSB7XHJcbiAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlRmllbGQkMShmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XHJcbiAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCk7XHJcbiAgICBjb25zdCBqc29uT2JqID0ge307XHJcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcclxuICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gd3JpdGVTY2FsYXIkMShmaWVsZC5WLlQsIGVudHJ5VmFsdWUpOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XHJcbiAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gZW50cnlWYWx1ZS50b0pzb24ob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgIGNvbnN0IGVudW1UeXBlID0gZmllbGQuVi5UO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XHJcbiAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gd3JpdGVFbnVtKGVudW1UeXBlLCBlbnRyeVZhbHVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGVudHJpZXMubGVuZ3RoID4gMCA/IGpzb25PYmogOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGlmIChmaWVsZC5yZXBlYXRlZCkge1xyXG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcclxuICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcclxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyJDEoZmllbGQuVCwgdmFsdWVbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZVtpXSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGpzb25BcnIucHVzaCh2YWx1ZVtpXS50b0pzb24ob3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMCA/IGpzb25BcnIgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHN3aXRjaCAoZmllbGQua2luZCkge1xyXG4gICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICByZXR1cm4gd3JpdGVTY2FsYXIkMShmaWVsZC5ULCB2YWx1ZSk7XHJcbiAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICByZXR1cm4gd3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xyXG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgcmV0dXJuIHdyYXBGaWVsZChmaWVsZC5ULCB2YWx1ZSkudG9Kc29uKG9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZUVudW0odHlwZSwgdmFsdWUsIGVudW1Bc0ludGVnZXIpIHtcclxuICB2YXIgX2E7XHJcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcclxuICBpZiAodHlwZS50eXBlTmFtZSA9PSBcImdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVcIikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChlbnVtQXNJbnRlZ2VyKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGNvbnN0IHZhbCA9IHR5cGUuZmluZE51bWJlcih2YWx1ZSk7XHJcbiAgcmV0dXJuIChfYSA9IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZTsgLy8gaWYgd2UgZG9uJ3Qga25vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxyXG59XHJcbmZ1bmN0aW9uIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpIHtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIC8vIGludDMyLCBmaXhlZDMyLCB1aW50MzI6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgbnVtYmVyLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XHJcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxyXG4gICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XHJcbiAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcclxuICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHJldHVybiBcIk5hTlwiO1xyXG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgcmV0dXJuIFwiSW5maW5pdHlcIjtcclxuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIi1JbmZpbml0eVwiO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAvLyBzdHJpbmc6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAvLyBib29sOlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XHJcbiAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXHJcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxyXG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xyXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cclxuICAgIC8vIEVpdGhlciBzdGFuZGFyZCBvciBVUkwtc2FmZSBiYXNlNjQgZW5jb2Rpbmcgd2l0aC93aXRob3V0IHBhZGRpbmdzIGFyZSBhY2NlcHRlZC5cclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcclxuICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XHJcbiAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5lbmModmFsdWUpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAqL1xyXG5jb25zdCB1bmtub3duRmllbGRzU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL3Vua25vd24tZmllbGRzXCIpO1xyXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXHJcbmNvbnN0IHJlYWREZWZhdWx0cyA9IHtcclxuICByZWFkVW5rbm93bkZpZWxkczogdHJ1ZSxcclxuICByZWFkZXJGYWN0b3J5OiBieXRlcyA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKVxyXG59O1xyXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxyXG5jb25zdCB3cml0ZURlZmF1bHRzID0ge1xyXG4gIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcclxuICB3cml0ZXJGYWN0b3J5OiAoKSA9PiBuZXcgQmluYXJ5V3JpdGVyKClcclxufTtcclxuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcclxuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVhZERlZmF1bHRzKSwgb3B0aW9ucykgOiByZWFkRGVmYXVsdHM7XHJcbn1cclxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IHdyaXRlRGVmYXVsdHM7XHJcbn1cclxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdCgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgbWFrZVJlYWRPcHRpb25zLFxyXG4gICAgbWFrZVdyaXRlT3B0aW9ucyxcclxuICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICB9LFxyXG4gICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xyXG4gICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcclxuICAgIH0sXHJcbiAgICB3cml0ZVVua25vd25GaWVsZHMobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xyXG4gICAgICBjb25zdCBjID0gbVt1bmtub3duRmllbGRzU3ltYm9sXTtcclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xyXG4gICAgICAgICAgd3JpdGVyLnRhZyhmLm5vLCBmLndpcmVUeXBlKS5yYXcoZi5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcclxuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XHJcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtW3Vua25vd25GaWVsZHNTeW1ib2xdKSkge1xyXG4gICAgICAgIG1bdW5rbm93bkZpZWxkc1N5bWJvbF0gPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBtW3Vua25vd25GaWVsZHNTeW1ib2xdLnB1c2goe1xyXG4gICAgICAgIG5vLFxyXG4gICAgICAgIHdpcmVUeXBlLFxyXG4gICAgICAgIGRhdGFcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBsZW5ndGhPckVuZFRhZ0ZpZWxkTm8sIG9wdGlvbnMsIGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZykge1xyXG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICAgICAgY29uc3QgZW5kID0gZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGhPckVuZFRhZ0ZpZWxkTm87XHJcbiAgICAgIGxldCBmaWVsZE5vLCB3aXJlVHlwZTtcclxuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xyXG4gICAgICAgIGlmIChkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcgPT09IHRydWUgJiYgd2lyZVR5cGUgPT0gV2lyZVR5cGUuRW5kR3JvdXApIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmQoZmllbGRObyk7XHJcbiAgICAgICAgaWYgKCFmaWVsZCkge1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlLCBmaWVsZE5vKTtcclxuICAgICAgICAgIGlmIChvcHRpb25zLnJlYWRVbmtub3duRmllbGRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRGaWVsZChtZXNzYWdlLCByZWFkZXIsIGZpZWxkLCB3aXJlVHlwZSwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAoXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXHJcbiAgICAgIHdpcmVUeXBlICE9IFdpcmVUeXBlLkVuZEdyb3VwIHx8IGZpZWxkTm8gIT09IGxlbmd0aE9yRW5kVGFnRmllbGRObykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWFkRmllbGQsXHJcbiAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcclxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XHJcbiAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xyXG4gICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIHRvIGJpbmFyeTogcmVxdWlyZWQgZmllbGQgbm90IHNldFwiKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZiA/IG1lc3NhZ2VbZmllbGQub25lb2YubG9jYWxOYW1lXS52YWx1ZSA6IG1lc3NhZ2VbZmllbGQubG9jYWxOYW1lXTtcclxuICAgICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy53cml0ZVVua25vd25GaWVsZHMpIHtcclxuICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICB9LFxyXG4gICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xyXG4gICAgICAvLyBUaGUgYmVoYXZpb3Igb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLCBpdCBkb2VzIG5vIGxvbmdlclxyXG4gICAgICAvLyBhY2NlcHQgYHVuZGVmaW5lZGAgdmFsdWVzIGZvciBzaW5ndWxhciBzY2FsYXIgYW5kIG1hcC5cclxuICAgICAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2ZcclxuICAgICAgLy8gdGhlIHB1YmxpYyBBUEkgdGhyb3VnaCB0aGUgaW50ZXJmYWNlIEJpbmFyeUZvcm1hdC5cclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcmVhZEZpZWxkKHRhcmdldCxcclxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGBhbnlgIGlzIHRoZSBiZXN0IGNob2ljZSBmb3IgZHluYW1pYyBhY2Nlc3NcclxucmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpIHtcclxuICBsZXQge1xyXG4gICAgcmVwZWF0ZWQsXHJcbiAgICBsb2NhbE5hbWVcclxuICB9ID0gZmllbGQ7XHJcbiAgaWYgKGZpZWxkLm9uZW9mKSB7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXTtcclxuICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcclxuICAgICAgZGVsZXRlIHRhcmdldC52YWx1ZTtcclxuICAgIH1cclxuICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xyXG4gICAgbG9jYWxOYW1lID0gXCJ2YWx1ZVwiO1xyXG4gIH1cclxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XHJcbiAgICAgIGxldCByZWFkID0gcmVhZFNjYWxhcjtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXHJcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuTCA+IDApIHtcclxuICAgICAgICByZWFkID0gcmVhZFNjYWxhckxUU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXBlYXRlZCkge1xyXG4gICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xyXG4gICAgICAgIGNvbnN0IGlzUGFja2VkID0gd2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTO1xyXG4gICAgICAgIGlmIChpc1BhY2tlZCkge1xyXG4gICAgICAgICAgbGV0IGUgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xyXG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZChyZWFkZXIsIHNjYWxhclR5cGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xyXG4gICAgICBpZiAocmVwZWF0ZWQpIHtcclxuICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXHJcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0ucHVzaChyZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IG1lc3NhZ2VUeXBlKCksIG9wdGlvbnMsIGZpZWxkKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzTWVzc2FnZSh0YXJnZXRbbG9jYWxOYW1lXSkpIHtcclxuICAgICAgICAgIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCB0YXJnZXRbbG9jYWxOYW1lXSwgb3B0aW9ucywgZmllbGQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xyXG4gICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlciAmJiAhZmllbGQub25lb2YgJiYgIWZpZWxkLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwibWFwXCI6XHJcbiAgICAgIGxldCBbbWFwS2V5LCBtYXBWYWxdID0gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpO1xyXG4gICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcclxuICAgICAgdGFyZ2V0W2xvY2FsTmFtZV1bbWFwS2V5XSA9IG1hcFZhbDtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxyXG4vLyBCaW5hcnlSZWFkT3B0aW9ucyBhbmQgdGhlIElCaW5hcnlSZWFkZXIuXHJcbmZ1bmN0aW9uIHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBtZXNzYWdlLCBvcHRpb25zLCBmaWVsZCkge1xyXG4gIGNvbnN0IGZvcm1hdCA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xyXG4gIGNvbnN0IGRlbGltaXRlZCA9IGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5kZWxpbWl0ZWQ7XHJcbiAgZm9ybWF0LnJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgZGVsaW1pdGVkID8gZmllbGQubm8gOiByZWFkZXIudWludDMyKCksXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICBvcHRpb25zLCBkZWxpbWl0ZWQpO1xyXG4gIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcclxuZnVuY3Rpb24gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcclxuICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksXHJcbiAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xyXG4gIGxldCBrZXksIHZhbDtcclxuICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgY29uc3QgW2ZpZWxkTm9dID0gcmVhZGVyLnRhZygpO1xyXG4gICAgc3dpdGNoIChmaWVsZE5vKSB7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBrZXkgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuSyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xyXG4gICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxyXG4gICAgICAgICAgICB2YWwgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuVi5UKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICB2YWwgPSByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbmV3IGZpZWxkLlYuVCgpLCBvcHRpb25zLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAga2V5ID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XHJcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcclxuICB9XHJcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xyXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgdmFsID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlYuVCwgTG9uZ1R5cGUuQklHSU5UKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICB2YWwgPSBmaWVsZC5WLlQudmFsdWVzWzBdLm5vO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgIHZhbCA9IG5ldyBmaWVsZC5WLlQoKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFtrZXksIHZhbF07XHJcbn1cclxuLy8gUmVhZCBhIHNjYWxhciB2YWx1ZSwgYnV0IHJldHVybiA2NCBiaXQgaW50ZWdyYWwgdHlwZXMgKGludDY0LCB1aW50NjQsXHJcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cclxuZnVuY3Rpb24gcmVhZFNjYWxhckxUU3RyaW5nKHJlYWRlciwgdHlwZSkge1xyXG4gIGNvbnN0IHYgPSByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSk7XHJcbiAgcmV0dXJuIHR5cGVvZiB2ID09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2O1xyXG59XHJcbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbmZ1bmN0aW9uIHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKSB7XHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XHJcbiAgICAgIHJldHVybiByZWFkZXIuYm9vbCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcclxuICAgICAgcmV0dXJuIHJlYWRlci5kb3VibGUoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcclxuICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLmludDMyKCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XHJcbiAgICAgIHJldHVybiByZWFkZXIuaW50NjQoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XHJcbiAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcclxuICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDY0KCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XHJcbiAgICAgIHJldHVybiByZWFkZXIuYnl0ZXMoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxyXG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcclxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQzMigpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxyXG4gICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDY0KCk7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxyXG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xyXG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcclxuICAgICAgcmV0dXJuIHJlYWRlci51aW50MzIoKTtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XHJcbiAgICAgIHJldHVybiByZWFkZXIuc2ludDMyKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcclxuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgY29uc3QgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZDtcclxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgIGxldCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xyXG4gICAgICBpZiAocmVwZWF0ZWQpIHtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xyXG4gICAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcclxuICAgICAgICAgIHdyaXRlUGFja2VkKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIGl0ZW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICBpZiAocmVwZWF0ZWQpIHtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJtYXBcIjpcclxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xyXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XHJcbiAgICAgICAgd3JpdGVNYXBFbnRyeSh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCBrZXksIHZhbCk7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xyXG4gIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCk7XHJcbiAgd3JpdGVyLmZvcmsoKTtcclxuICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgLy8gd2UgY29udmVydCBmcm9tIG91ciByZXByZXNlbnRhdGlvbiB0byB0aGUgcHJvdG9idWYgdHlwZVxyXG4gIGxldCBrZXlWYWx1ZSA9IGtleTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSB3ZSBkZWxpYmVyYXRlbHkgaGFuZGxlIGp1c3QgdGhlIHNwZWNpYWwgY2FzZXMgZm9yIG1hcCBrZXlzXHJcbiAgc3dpdGNoIChmaWVsZC5LKSB7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxyXG4gICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxyXG4gICAgICBhc3NlcnQoa2V5ID09IFwidHJ1ZVwiIHx8IGtleSA9PSBcImZhbHNlXCIpO1xyXG4gICAgICBrZXlWYWx1ZSA9IGtleSA9PSBcInRydWVcIjtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXHJcbiAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSk7XHJcbiAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXHJcbiAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcclxuICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIFNjYWxhclR5cGUuSU5UMzIsIDIsIHZhbHVlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyh2YWx1ZS50b0JpbmFyeShvcHRpb25zKSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICB3cml0ZXIuam9pbigpO1xyXG59XHJcbi8vIFZhbHVlIG11c3Qgbm90IGJlIHVuZGVmaW5lZFxyXG5mdW5jdGlvbiB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSkge1xyXG4gIGNvbnN0IG1lc3NhZ2UgPSB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpO1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcclxuICBpZiAoZmllbGQuZGVsaW1pdGVkKSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5TdGFydEdyb3VwKS5yYXcobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSkudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5FbmRHcm91cCk7ZWxzZSB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKG1lc3NhZ2UudG9CaW5hcnkob3B0aW9ucykpO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcclxuICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kXSA9IHNjYWxhclR5cGVJbmZvKHR5cGUpO1xyXG4gIHdyaXRlci50YWcoZmllbGRObywgd2lyZVR5cGUpW21ldGhvZF0odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcclxuICBpZiAoIXZhbHVlLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3cml0ZXIudGFnKGZpZWxkTm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xyXG4gIGxldCBbLCBtZXRob2RdID0gc2NhbGFyVHlwZUluZm8odHlwZSk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgd3JpdGVyW21ldGhvZF0odmFsdWVbaV0pO1xyXG4gIH1cclxuICB3cml0ZXIuam9pbigpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIFJldHVybnMgdHVwbGU6XHJcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcclxuICogWzFdOiBuYW1lIG9mIHRoZSBhcHByb3ByaWF0ZSBtZXRob2Qgb2YgSUJpbmFyeVdyaXRlclxyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xyXG4gKlxyXG4gKiBJZiBhcmd1bWVudCBgdmFsdWVgIGlzIG9taXR0ZWQsIFsyXSBpcyBhbHdheXMgZmFsc2UuXHJcbiAqL1xyXG4vLyBUT0RPIHJlcGxhY2UgY2FsbC1zaXRlcyB3cml0ZVNjYWxhcigpIGFuZCB3cml0ZVBhY2tlZCgpLCB0aGVuIHJlbW92ZVxyXG5mdW5jdGlvbiBzY2FsYXJUeXBlSW5mbyh0eXBlKSB7XHJcbiAgbGV0IHdpcmVUeXBlID0gV2lyZVR5cGUuVmFyaW50O1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIElOVDMyLCBVSU5UMzIsIFNJTlQzMiBhcmUgY292ZXJlZCBieSB0aGUgZGVmYXVsdHNcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XHJcbiAgICAgIHdpcmVUeXBlID0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcclxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcclxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcclxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQzMjtcclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcclxuICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2RdO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4sQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xyXG5mdW5jdGlvbiBtYWtlVXRpbENvbW1vbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgc2V0RW51bVR5cGUsXHJcbiAgICBpbml0UGFydGlhbChzb3VyY2UsIHRhcmdldCkge1xyXG4gICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdHlwZSA9IHRhcmdldC5nZXRUeXBlKCk7XHJcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcclxuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLFxyXG4gICAgICAgICAgdCA9IHRhcmdldCxcclxuICAgICAgICAgIHMgPSBzb3VyY2U7XHJcbiAgICAgICAgaWYgKHNbbG9jYWxOYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAvLyBUT0RPIGlmIHNvdXJjZSBpcyBhIE1lc3NhZ2UgaW5zdGFuY2UsIHdlIHNob3VsZCB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XHJcbiAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcclxuICAgICAgICAgICAgY29uc3Qgc2sgPSBzW2xvY2FsTmFtZV0uY2FzZTtcclxuICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlRmllbGQgJiYgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJiAhaXNNZXNzYWdlKHZhbCwgc291cmNlRmllbGQuVCkpIHtcclxuICAgICAgICAgICAgICB2YWwgPSBuZXcgc291cmNlRmllbGQuVCh2YWwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZUZpZWxkICYmIHNvdXJjZUZpZWxkLmtpbmQgPT09IFwic2NhbGFyXCIgJiYgc291cmNlRmllbGQuVCA9PT0gU2NhbGFyVHlwZS5CWVRFUykge1xyXG4gICAgICAgICAgICAgIHZhbCA9IHRvVThBcnIodmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgY2FzZTogc2ssXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAobWVtYmVyLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcclxuICAgICAgICAgICAgICBjb3B5ID0gbWVtYmVyLnJlcGVhdGVkID8gY29weS5tYXAodG9VOEFycikgOiB0b1U4QXJyKGNvcHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcIm1hcFwiOlxyXG4gICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5WLmtpbmQpIHtcclxuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNbbG9jYWxOYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB0b1U4QXJyKHYpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRbbG9jYWxOYW1lXSwgc1tsb2NhbE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lbWJlci5WLlQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoc1tsb2NhbE5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdW2tdO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSBwYXJ0aWFsIGlucHV0IGZvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYSB3cmFwcGVyIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICBjb25zdCBtdCA9IG1lbWJlci5UO1xyXG4gICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gc1tsb2NhbE5hbWVdLm1hcCh2YWwgPT4gaXNNZXNzYWdlKHZhbCwgbXQpID8gdmFsIDogbmV3IG10KHZhbCkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHNbbG9jYWxOYW1lXTtcclxuICAgICAgICAgICAgICBpZiAobXQuZmllbGRXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgQnl0ZXNWYWx1ZS50eXBlTmFtZSBhcyB0aGF0IHdpbGwgY3JlYXRlIGEgY2lyY3VsYXIgaW1wb3J0XHJcbiAgICAgICAgICAgICAgICBtdC50eXBlTmFtZSA9PT0gXCJnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHRvVThBcnIodmFsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gaXNNZXNzYWdlKHZhbCwgbXQpID8gdmFsIDogbmV3IG10KHZhbCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXHJcbiAgICBlcXVhbHModHlwZSwgYSwgYikge1xyXG4gICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYSB8fCAhYikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHlwZS5maWVsZHMuYnlNZW1iZXIoKS5ldmVyeShtID0+IHtcclxuICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xyXG4gICAgICAgIGNvbnN0IHZiID0gYlttLmxvY2FsTmFtZV07XHJcbiAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgIGlmICh2YS5sZW5ndGggIT09IHZiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSByZXBlYXRlZCBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcclxuICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBtLlQuZXF1YWxzKGEsIHZiW2ldKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IHNjYWxhckVxdWFscyhtLlQsIGEsIHZiW2ldKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgYSwgdmJbaV0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlcGVhdGVkIGNhbm5vdCBjb250YWluIFwiLmNvbmNhdChtLmtpbmQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoIChtLmtpbmQpIHtcclxuICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XHJcbiAgICAgICAgICAgIGxldCBhID0gdmE7XHJcbiAgICAgICAgICAgIGxldCBiID0gdmI7XHJcbiAgICAgICAgICAgIGlmIChtLlQuZmllbGRXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCAmJiAhaXNNZXNzYWdlKGEpKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gbS5ULmZpZWxkV3JhcHBlci53cmFwRmllbGQoYSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChiICE9PSB1bmRlZmluZWQgJiYgIWlzTWVzc2FnZShiKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IG0uVC5maWVsZFdyYXBwZXIud3JhcEZpZWxkKGIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbS5ULmVxdWFscyhhLCBiKTtcclxuICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEsIHZiKTtcclxuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcclxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XHJcbiAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcclxuICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcyA9IG0uZmluZEZpZWxkKHZhLmNhc2UpO1xyXG4gICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gb25lb2YgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXHJcbiAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLlQuZXF1YWxzKHZhLnZhbHVlLCB2Yi52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEudmFsdWUsIHZiLnZhbHVlKTtcclxuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKHMuVCwgdmEudmFsdWUsIHZiLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbmVvZiBjYW5ub3QgY29udGFpbiBcIi5jb25jYXQocy5raW5kKSk7XHJcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobS5WLmtpbmQpIHtcclxuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGsgPT4gbWVzc2FnZVR5cGUuZXF1YWxzKHZhW2tdLCB2YltrXSkpO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhTY2FsYXJUeXBlLklOVDMyLCB2YVtrXSwgdmJba10pKTtcclxuICAgICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gbS5WLlQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShrID0+IHNjYWxhckVxdWFscyhzY2FsYXJUeXBlLCB2YVtrXSwgdmJba10pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXHJcbiAgICBjbG9uZShtZXNzYWdlKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSxcclxuICAgICAgICB0YXJnZXQgPSBuZXcgdHlwZSgpLFxyXG4gICAgICAgIGFueSA9IHRhcmdldDtcclxuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XHJcbiAgICAgICAgbGV0IGNvcHk7XHJcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgY29weSA9IHNvdXJjZS5tYXAoY2xvbmVTaW5ndWxhckZpZWxkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwibWFwXCIpIHtcclxuICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJvbmVvZlwiKSB7XHJcbiAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XHJcbiAgICAgICAgICBjb3B5ID0gZiA/IHtcclxuICAgICAgICAgICAgY2FzZTogc291cmNlLmNhc2UsXHJcbiAgICAgICAgICAgIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKVxyXG4gICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgY2FzZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCB1ZiBvZiB0eXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgdHlwZS5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChhbnksIHVmLm5vLCB1Zi53aXJlVHlwZSwgdWYuZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xyXG5mdW5jdGlvbiBjbG9uZVNpbmd1bGFyRmllbGQodmFsdWUpIHtcclxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICBpZiAoaXNNZXNzYWdlKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLmNsb25lKCk7XHJcbiAgfVxyXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5ieXRlTGVuZ3RoKTtcclxuICAgIGMuc2V0KHZhbHVlKTtcclxuICAgIHJldHVybiBjO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLy8gY29udmVydHMgYW55IEFycmF5TGlrZTxudW1iZXI+IHRvIFVpbnQ4QXJyYXkgaWYgbmVjZXNzYXJ5LlxyXG5mdW5jdGlvbiB0b1U4QXJyKGlucHV0KSB7XHJcbiAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGlucHV0IDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG5mdW5jdGlvbiBtYWtlUHJvdG9SdW50aW1lKHN5bnRheCwgbmV3RmllbGRMaXN0LCBpbml0RmllbGRzKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHN5bnRheCxcclxuICAgIGpzb246IG1ha2VKc29uRm9ybWF0KCksXHJcbiAgICBiaW46IG1ha2VCaW5hcnlGb3JtYXQoKSxcclxuICAgIHV0aWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWFrZVV0aWxDb21tb24oKSksIHtcclxuICAgICAgbmV3RmllbGRMaXN0LFxyXG4gICAgICBpbml0RmllbGRzXHJcbiAgICB9KSxcclxuICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcclxuICAgICAgcmV0dXJuIG1ha2VNZXNzYWdlVHlwZSh0aGlzLCB0eXBlTmFtZSwgZmllbGRzLCBvcHQpO1xyXG4gICAgfSxcclxuICAgIG1ha2VFbnVtLFxyXG4gICAgbWFrZUVudW1UeXBlLFxyXG4gICAgZ2V0RW51bVR5cGUsXHJcbiAgICBtYWtlRXh0ZW5zaW9uKHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpIHtcclxuICAgICAgcmV0dXJuIG1ha2VFeHRlbnNpb24odGhpcywgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xyXG4gIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xyXG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xyXG4gICAgdGhpcy5fbm9ybWFsaXplciA9IG5vcm1hbGl6ZXI7XHJcbiAgfVxyXG4gIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xyXG4gICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xyXG4gICAgICBjb25zdCB0ID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xyXG4gICAgICAgIHRbZi5qc29uTmFtZV0gPSB0W2YubmFtZV0gPSBmO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmpzb25OYW1lc1tqc29uTmFtZV07XHJcbiAgfVxyXG4gIGZpbmQoZmllbGRObykge1xyXG4gICAgaWYgKCF0aGlzLm51bWJlcnMpIHtcclxuICAgICAgY29uc3QgdCA9IHt9O1xyXG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcclxuICAgICAgICB0W2Yubm9dID0gZjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm51bWJlcnMgPSB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcclxuICB9XHJcbiAgbGlzdCgpIHtcclxuICAgIGlmICghdGhpcy5hbGwpIHtcclxuICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hbGw7XHJcbiAgfVxyXG4gIGJ5TnVtYmVyKCkge1xyXG4gICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcclxuICAgICAgdGhpcy5udW1iZXJzQXNjID0gdGhpcy5saXN0KCkuY29uY2F0KCkuc29ydCgoYSwgYikgPT4gYS5ubyAtIGIubm8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcclxuICB9XHJcbiAgYnlNZW1iZXIoKSB7XHJcbiAgICBpZiAoIXRoaXMubWVtYmVycykge1xyXG4gICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcclxuICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcclxuICAgICAgbGV0IG87XHJcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xyXG4gICAgICAgIGlmIChmLm9uZW9mKSB7XHJcbiAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xyXG4gICAgICAgICAgICBvID0gZi5vbmVvZjtcclxuICAgICAgICAgICAgYS5wdXNoKG8pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhLnB1c2goZik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxyXG4gKlxyXG4gKiBGaWVsZCBuYW1lcyAtIGluY2x1ZGluZyBvbmVvZnMgLSBhcmUgY29udmVydGVkIHRvIGxvd2VyQ2FtZWxDYXNlLiBGb3JcclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxyXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXHJcbiAqIHdpdGggYW4gdW5kZXJzY29yZS4gRm9yIG1ldGhvZHMsIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbWFkZSBsb3dlcmNhc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIGZpZWxkIGluIGdlbmVyYXRlZCBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBpbk9uZW9mKSB7XHJcbiAgY29uc3QgbmFtZSA9IHByb3RvQ2FtZWxDYXNlKHByb3RvTmFtZSk7XHJcbiAgaWYgKGluT25lb2YpIHtcclxuICAgIC8vIG9uZW9mIG1lbWJlciBuYW1lcyBhcmUgbm90IHByb3BlcnRpZXMsIGJ1dCB2YWx1ZXMgb2YgdGhlIGBjYXNlYCBwcm9wZXJ0eS5cclxuICAgIHJldHVybiBuYW1lO1xyXG4gIH1cclxuICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcclxuICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxyXG4gKi9cclxuY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xyXG4vKipcclxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBwcm90b0NhbWVsQ2FzZSBhY2NvcmRpbmcgdG8gdGhlIGNvbnZlbnRpb25cclxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm90b0NhbWVsQ2FzZShzbmFrZUNhc2UpIHtcclxuICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xyXG4gIGNvbnN0IGIgPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYWtlQ2FzZS5sZW5ndGg7IGkrKykge1xyXG4gICAgbGV0IGMgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xyXG4gICAgc3dpdGNoIChjKSB7XHJcbiAgICAgIGNhc2UgXCJfXCI6XHJcbiAgICAgICAgY2FwTmV4dCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCIwXCI6XHJcbiAgICAgIGNhc2UgXCIxXCI6XHJcbiAgICAgIGNhc2UgXCIyXCI6XHJcbiAgICAgIGNhc2UgXCIzXCI6XHJcbiAgICAgIGNhc2UgXCI0XCI6XHJcbiAgICAgIGNhc2UgXCI1XCI6XHJcbiAgICAgIGNhc2UgXCI2XCI6XHJcbiAgICAgIGNhc2UgXCI3XCI6XHJcbiAgICAgIGNhc2UgXCI4XCI6XHJcbiAgICAgIGNhc2UgXCI5XCI6XHJcbiAgICAgICAgYi5wdXNoKGMpO1xyXG4gICAgICAgIGNhcE5leHQgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBpZiAoY2FwTmV4dCkge1xyXG4gICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xyXG4gICAgICAgICAgYyA9IGMudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYi5wdXNoKGMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYi5qb2luKFwiXCIpO1xyXG59XHJcbi8qKlxyXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXHJcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cclxuICovXHJcbmNvbnN0IHJlc2VydmVkT2JqZWN0UHJvcGVydGllcyA9IG5ldyBTZXQoW1xyXG4vLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XHJcblwiY29uc3RydWN0b3JcIiwgXCJ0b1N0cmluZ1wiLCBcInRvSlNPTlwiLCBcInZhbHVlT2ZcIl0pO1xyXG4vKipcclxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxyXG4gKiBieSB0aGUgcnVudGltZS5cclxuICovXHJcbmNvbnN0IHJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMgPSBuZXcgU2V0KFtcclxuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcclxuXCJnZXRUeXBlXCIsIFwiY2xvbmVcIiwgXCJlcXVhbHNcIiwgXCJmcm9tQmluYXJ5XCIsIFwiZnJvbUpzb25cIiwgXCJmcm9tSnNvblN0cmluZ1wiLCBcInRvQmluYXJ5XCIsIFwidG9Kc29uXCIsIFwidG9Kc29uU3RyaW5nXCIsXHJcbi8vIG5hbWVzIHJlc2VydmVkIGJ5IHRoZSBydW50aW1lIGZvciB0aGUgZnV0dXJlXHJcblwidG9PYmplY3RcIl0pO1xyXG5jb25zdCBmYWxsYmFjayA9IG5hbWUgPT4gXCJcIi5jb25jYXQobmFtZSwgXCIkXCIpO1xyXG4vKipcclxuICogV2lsbCB3cmFwIG5hbWVzIHRoYXQgYXJlIE9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllcyBvciBuYW1lcyByZXNlcnZlZFxyXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cclxuICovXHJcbmNvbnN0IHNhZmVNZXNzYWdlUHJvcGVydHkgPSBuYW1lID0+IHtcclxuICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcclxuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcclxuICB9XHJcbiAgcmV0dXJuIG5hbWU7XHJcbn07XHJcbi8qKlxyXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXHJcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cclxuICovXHJcbmNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IG5hbWUgPT4ge1xyXG4gIGlmIChyZXNlcnZlZE9iamVjdFByb3BlcnRpZXMuaGFzKG5hbWUpKSB7XHJcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiBuYW1lO1xyXG59O1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXHJcbi8vXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbi8vXHJcbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbi8vXHJcbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgIHRoaXMua2luZCA9IFwib25lb2ZcIjtcclxuICAgIHRoaXMucmVwZWF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMucGFja2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLm9wdCA9IGZhbHNlO1xyXG4gICAgdGhpcy5yZXEgPSBmYWxzZTtcclxuICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZmllbGRzID0gW107XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcclxuICB9XHJcbiAgYWRkRmllbGQoZmllbGQpIHtcclxuICAgIGFzc2VydChmaWVsZC5vbmVvZiA9PT0gdGhpcywgXCJmaWVsZCBcIi5jb25jYXQoZmllbGQubmFtZSwgXCIgbm90IG9uZSBvZiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xyXG4gICAgdGhpcy5maWVsZHMucHVzaChmaWVsZCk7XHJcbiAgfVxyXG4gIGZpbmRGaWVsZChsb2NhbE5hbWUpIHtcclxuICAgIGlmICghdGhpcy5fbG9va3VwKSB7XHJcbiAgICAgIHRoaXMuX2xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9sb29rdXBbdGhpcy5maWVsZHNbaV0ubG9jYWxOYW1lXSA9IHRoaXMuZmllbGRzW2ldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fbG9va3VwW2xvY2FsTmFtZV07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogQ29udmVydCBhIGNvbGxlY3Rpb24gb2YgZmllbGQgaW5mbyB0byBhbiBhcnJheSBvZiBub3JtYWxpemVkIEZpZWxkSW5mby5cclxuICpcclxuICogVGhlIGFyZ3VtZW50IGBwYWNrZWRCeURlZmF1bHRgIHNwZWNpZmllcyB3aGV0aGVyIGZpZWxkcyB0aGF0IGRvIG5vdCBzcGVjaWZ5XHJcbiAqIGBwYWNrZWRgIHNob3VsZCBiZSBwYWNrZWQgKHByb3RvMykgb3IgdW5wYWNrZWQgKHByb3RvMikuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zKGZpZWxkSW5mb3MsIHBhY2tlZEJ5RGVmYXVsdCkge1xyXG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gIGNvbnN0IHIgPSBbXTtcclxuICBsZXQgbztcclxuICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVvZiBmaWVsZEluZm9zID09IFwiZnVuY3Rpb25cIiA/IGZpZWxkSW5mb3MoKSA6IGZpZWxkSW5mb3MpIHtcclxuICAgIGNvbnN0IGYgPSBmaWVsZDtcclxuICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XHJcbiAgICBmLmpzb25OYW1lID0gKF9hID0gZmllbGQuanNvbk5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpZWxkSnNvbk5hbWUoZmllbGQubmFtZSk7XHJcbiAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xyXG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xyXG4gICAgICBmLkwgPSAoX2MgPSBmaWVsZC5MKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBMb25nVHlwZS5CSUdJTlQ7XHJcbiAgICB9XHJcbiAgICBmLmRlbGltaXRlZCA9IChfZCA9IGZpZWxkLmRlbGltaXRlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XHJcbiAgICBmLnJlcSA9IChfZSA9IGZpZWxkLnJlcSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XHJcbiAgICBmLm9wdCA9IChfZiA9IGZpZWxkLm9wdCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogZmFsc2U7XHJcbiAgICBpZiAoZmllbGQucGFja2VkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAge1xyXG4gICAgICAgIGYucGFja2VkID0gZmllbGQua2luZCA9PSBcImVudW1cIiB8fCBmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmIGZpZWxkLlQgIT0gU2NhbGFyVHlwZS5TVFJJTkc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXHJcbiAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XHJcbiAgICBpZiAoZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBvb25hbWUgPSB0eXBlb2YgZmllbGQub25lb2YgPT0gXCJzdHJpbmdcIiA/IGZpZWxkLm9uZW9mIDogZmllbGQub25lb2YubmFtZTtcclxuICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcclxuICAgICAgICBvID0gbmV3IEludGVybmFsT25lb2ZJbmZvKG9vbmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgZi5vbmVvZiA9IG87XHJcbiAgICAgIG8uYWRkRmllbGQoZik7XHJcbiAgICB9XHJcbiAgICByLnB1c2goZik7XHJcbiAgfVxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxyXG4gKi9cclxuY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCBmaWVsZHMgPT4ge1xyXG4gIHJldHVybiBuZXcgSW50ZXJuYWxGaWVsZExpc3QoZmllbGRzLCBzb3VyY2UgPT4gbm9ybWFsaXplRmllbGRJbmZvcyhzb3VyY2UpKTtcclxufSxcclxuLy8gVE9ETyBtZXJnZSB3aXRoIHByb3RvMiBhbmQgaW5pdEV4dGVuc2lvbkZpZWxkLCBhbHNvIHNlZSBpbml0UGFydGlhbCwgZXF1YWxzLCBjbG9uZVxyXG50YXJnZXQgPT4ge1xyXG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIHRhcmdldC5nZXRUeXBlKCkuZmllbGRzLmJ5TWVtYmVyKCkpIHtcclxuICAgIGlmIChtZW1iZXIub3B0KSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsXHJcbiAgICAgIHQgPSB0YXJnZXQ7XHJcbiAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XHJcbiAgICAgIHRbbmFtZV0gPSBbXTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XHJcbiAgICAgIGNhc2UgXCJvbmVvZlwiOlxyXG4gICAgICAgIHRbbmFtZV0gPSB7XHJcbiAgICAgICAgICBjYXNlOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiZW51bVwiOlxyXG4gICAgICAgIHRbbmFtZV0gPSAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwibWFwXCI6XHJcbiAgICAgICAgdFtuYW1lXSA9IHt9O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XHJcbiAgICAgICAgdFtuYW1lXSA9IHNjYWxhclplcm9WYWx1ZShtZW1iZXIuVCwgbWVtYmVyLkwpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cclxuLy9cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuLy9cclxuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuLy9cclxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4vKipcclxuICogQSBUaW1lc3RhbXAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvciBsb2NhbFxyXG4gKiBjYWxlbmRhciwgZW5jb2RlZCBhcyBhIGNvdW50IG9mIHNlY29uZHMgYW5kIGZyYWN0aW9ucyBvZiBzZWNvbmRzIGF0XHJcbiAqIG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gVGhlIGNvdW50IGlzIHJlbGF0aXZlIHRvIGFuIGVwb2NoIGF0IFVUQyBtaWRuaWdodCBvblxyXG4gKiBKYW51YXJ5IDEsIDE5NzAsIGluIHRoZSBwcm9sZXB0aWMgR3JlZ29yaWFuIGNhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXHJcbiAqIEdyZWdvcmlhbiBjYWxlbmRhciBiYWNrd2FyZHMgdG8geWVhciBvbmUuXHJcbiAqXHJcbiAqIEFsbCBtaW51dGVzIGFyZSA2MCBzZWNvbmRzIGxvbmcuIExlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwXHJcbiAqIHNlY29uZCB0YWJsZSBpcyBuZWVkZWQgZm9yIGludGVycHJldGF0aW9uLCB1c2luZyBhIFsyNC1ob3VyIGxpbmVhclxyXG4gKiBzbWVhcl0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vdGltZS9zbWVhcikuXHJcbiAqXHJcbiAqIFRoZSByYW5nZSBpcyBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTkuOTk5OTk5OTk5Wi4gQnlcclxuICogcmVzdHJpY3RpbmcgdG8gdGhhdCByYW5nZSwgd2UgZW5zdXJlIHRoYXQgd2UgY2FuIGNvbnZlcnQgdG8gYW5kIGZyb20gW1JGQ1xyXG4gKiAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGRhdGUgc3RyaW5ncy5cclxuICpcclxuICogIyBFeGFtcGxlc1xyXG4gKlxyXG4gKiBFeGFtcGxlIDE6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gUE9TSVggYHRpbWUoKWAuXHJcbiAqXHJcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xyXG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKHRpbWUoTlVMTCkpO1xyXG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygwKTtcclxuICpcclxuICogRXhhbXBsZSAyOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGBnZXR0aW1lb2ZkYXkoKWAuXHJcbiAqXHJcbiAqICAgICBzdHJ1Y3QgdGltZXZhbCB0djtcclxuICogICAgIGdldHRpbWVvZmRheSgmdHYsIE5VTEwpO1xyXG4gKlxyXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0di50dl9zZWMpO1xyXG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcyh0di50dl91c2VjICogMTAwMCk7XHJcbiAqXHJcbiAqIEV4YW1wbGUgMzogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBXaW4zMiBgR2V0U3lzdGVtVGltZUFzRmlsZVRpbWUoKWAuXHJcbiAqXHJcbiAqICAgICBGSUxFVElNRSBmdDtcclxuICogICAgIEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKCZmdCk7XHJcbiAqICAgICBVSU5UNjQgdGlja3MgPSAoKChVSU5UNjQpZnQuZHdIaWdoRGF0ZVRpbWUpIDw8IDMyKSB8IGZ0LmR3TG93RGF0ZVRpbWU7XHJcbiAqXHJcbiAqICAgICAvLyBBIFdpbmRvd3MgdGljayBpcyAxMDAgbmFub3NlY29uZHMuIFdpbmRvd3MgZXBvY2ggMTYwMS0wMS0wMVQwMDowMDowMFpcclxuICogICAgIC8vIGlzIDExNjQ0NDczNjAwIHNlY29uZHMgYmVmb3JlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXHJcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xyXG4gKiAgICAgdGltZXN0YW1wLnNldF9zZWNvbmRzKChJTlQ2NCkgKCh0aWNrcyAvIDEwMDAwMDAwKSAtIDExNjQ0NDczNjAwTEwpKTtcclxuICogICAgIHRpbWVzdGFtcC5zZXRfbmFub3MoKElOVDMyKSAoKHRpY2tzICUgMTAwMDAwMDApICogMTAwKSk7XHJcbiAqXHJcbiAqIEV4YW1wbGUgNDogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBTeXN0ZW0uY3VycmVudFRpbWVNaWxsaXMoKWAuXHJcbiAqXHJcbiAqICAgICBsb25nIG1pbGxpcyA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xyXG4gKlxyXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhtaWxsaXMgLyAxMDAwKVxyXG4gKiAgICAgICAgIC5zZXROYW5vcygoaW50KSAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkpLmJ1aWxkKCk7XHJcbiAqXHJcbiAqIEV4YW1wbGUgNTogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBKYXZhIGBJbnN0YW50Lm5vdygpYC5cclxuICpcclxuICogICAgIEluc3RhbnQgbm93ID0gSW5zdGFudC5ub3coKTtcclxuICpcclxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPVxyXG4gKiAgICAgICAgIFRpbWVzdGFtcC5uZXdCdWlsZGVyKCkuc2V0U2Vjb25kcyhub3cuZ2V0RXBvY2hTZWNvbmQoKSlcclxuICogICAgICAgICAgICAgLnNldE5hbm9zKG5vdy5nZXROYW5vKCkpLmJ1aWxkKCk7XHJcbiAqXHJcbiAqIEV4YW1wbGUgNjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBjdXJyZW50IHRpbWUgaW4gUHl0aG9uLlxyXG4gKlxyXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcclxuICogICAgIHRpbWVzdGFtcC5HZXRDdXJyZW50VGltZSgpXHJcbiAqXHJcbiAqICMgSlNPTiBNYXBwaW5nXHJcbiAqXHJcbiAqIEluIEpTT04gZm9ybWF0LCB0aGUgVGltZXN0YW1wIHR5cGUgaXMgZW5jb2RlZCBhcyBhIHN0cmluZyBpbiB0aGVcclxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXHJcbiAqIGZvcm1hdCBpcyBcInt5ZWFyfS17bW9udGh9LXtkYXl9VHtob3VyfTp7bWlufTp7c2VjfVsue2ZyYWNfc2VjfV1aXCJcclxuICogd2hlcmUge3llYXJ9IGlzIGFsd2F5cyBleHByZXNzZWQgdXNpbmcgZm91ciBkaWdpdHMgd2hpbGUge21vbnRofSwge2RheX0sXHJcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxyXG4gKiBzZWNvbmRzLCB3aGljaCBjYW4gZ28gdXAgdG8gOSBkaWdpdHMgKGkuZS4gdXAgdG8gMSBuYW5vc2Vjb25kIHJlc29sdXRpb24pLFxyXG4gKiBhcmUgb3B0aW9uYWwuIFRoZSBcIlpcIiBzdWZmaXggaW5kaWNhdGVzIHRoZSB0aW1lem9uZSAoXCJVVENcIik7IHRoZSB0aW1lem9uZVxyXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XHJcbiAqIFwiWlwiKSB3aGVuIHByaW50aW5nIHRoZSBUaW1lc3RhbXAgdHlwZSBhbmQgYSBwcm90bzMgSlNPTiBwYXJzZXIgc2hvdWxkIGJlXHJcbiAqIGFibGUgdG8gYWNjZXB0IGJvdGggVVRDIGFuZCBvdGhlciB0aW1lem9uZXMgKGFzIGluZGljYXRlZCBieSBhbiBvZmZzZXQpLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgXCIyMDE3LTAxLTE1VDAxOjMwOjE1LjAxWlwiIGVuY29kZXMgMTUuMDEgc2Vjb25kcyBwYXN0XHJcbiAqIDAxOjMwIFVUQyBvbiBKYW51YXJ5IDE1LCAyMDE3LlxyXG4gKlxyXG4gKiBJbiBKYXZhU2NyaXB0LCBvbmUgY2FuIGNvbnZlcnQgYSBEYXRlIG9iamVjdCB0byB0aGlzIGZvcm1hdCB1c2luZyB0aGVcclxuICogc3RhbmRhcmRcclxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXHJcbiAqIG1ldGhvZC4gSW4gUHl0aG9uLCBhIHN0YW5kYXJkIGBkYXRldGltZS5kYXRldGltZWAgb2JqZWN0IGNhbiBiZSBjb252ZXJ0ZWRcclxuICogdG8gdGhpcyBmb3JtYXQgdXNpbmdcclxuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxyXG4gKiB0aGUgdGltZSBmb3JtYXQgc3BlYyAnJVktJW0tJWRUJUg6JU06JVMuJWZaJy4gTGlrZXdpc2UsIGluIEphdmEsIG9uZSBjYW4gdXNlXHJcbiAqIHRoZSBKb2RhIFRpbWUncyBbYElTT0RhdGVUaW1lRm9ybWF0LmRhdGVUaW1lKClgXShcclxuICogaHR0cDovL2pvZGEtdGltZS5zb3VyY2Vmb3JnZS5uZXQvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lKClcclxuICogKSB0byBvYnRhaW4gYSBmb3JtYXR0ZXIgY2FwYWJsZSBvZiBnZW5lcmF0aW5nIHRpbWVzdGFtcHMgaW4gdGhpcyBmb3JtYXQuXHJcbiAqXHJcbiAqXHJcbiAqIEBnZW5lcmF0ZWQgZnJvbSBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcclxuICovXHJcbmNsYXNzIFRpbWVzdGFtcCBleHRlbmRzIE1lc3NhZ2Uge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoXHJcbiAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXHJcbiAgICAgKiA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcclxuICAgICAqL1xyXG4gICAgdGhpcy5zZWNvbmRzID0gcHJvdG9JbnQ2NC56ZXJvO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOb24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gTmVnYXRpdmVcclxuICAgICAqIHNlY29uZCB2YWx1ZXMgd2l0aCBmcmFjdGlvbnMgbXVzdCBzdGlsbCBoYXZlIG5vbi1uZWdhdGl2ZSBuYW5vcyB2YWx1ZXNcclxuICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxyXG4gICAgICogaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xyXG4gICAgICovXHJcbiAgICB0aGlzLm5hbm9zID0gMDtcclxuICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xyXG4gIH1cclxuICBmcm9tSnNvbihqc29uLCBvcHRpb25zKSB7XHJcbiAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogXCIuY29uY2F0KHByb3RvMy5qc29uLmRlYnVnKGpzb24pKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaGVzID0ganNvbi5tYXRjaCgvXihbMC05XXs0fSktKFswLTldezJ9KS0oWzAtOV17Mn0pVChbMC05XXsyfSk6KFswLTldezJ9KTooWzAtOV17Mn0pKD86WnxcXC4oWzAtOV17Myw5fSlafChbKy1dWzAtOV1bMC05XTpbMC05XVswLTldKSkkLyk7XHJcbiAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogaW52YWxpZCBSRkMgMzMzOSBzdHJpbmdcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtcyA9IERhdGUucGFyc2UobWF0Y2hlc1sxXSArIFwiLVwiICsgbWF0Y2hlc1syXSArIFwiLVwiICsgbWF0Y2hlc1szXSArIFwiVFwiICsgbWF0Y2hlc1s0XSArIFwiOlwiICsgbWF0Y2hlc1s1XSArIFwiOlwiICsgbWF0Y2hlc1s2XSArIChtYXRjaGVzWzhdID8gbWF0Y2hlc1s4XSA6IFwiWlwiKSk7XHJcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG1zKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ1wiKTtcclxuICAgIH1cclxuICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVcIik7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0LnBhcnNlKG1zIC8gMTAwMCk7XHJcbiAgICB0aGlzLm5hbm9zID0gMDtcclxuICAgIGlmIChtYXRjaGVzWzddKSB7XHJcbiAgICAgIHRoaXMubmFub3MgPSBwYXJzZUludChcIjFcIiArIG1hdGNoZXNbN10gKyBcIjBcIi5yZXBlYXQoOSAtIG1hdGNoZXNbN10ubGVuZ3RoKSkgLSAxMDAwMDAwMDAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIHRvSnNvbihvcHRpb25zKSB7XHJcbiAgICBjb25zdCBtcyA9IE51bWJlcih0aGlzLnNlY29uZHMpICogMTAwMDtcclxuICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm5hbm9zIDwgMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVcIik7XHJcbiAgICB9XHJcbiAgICBsZXQgeiA9IFwiWlwiO1xyXG4gICAgaWYgKHRoaXMubmFub3MgPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5hbm9zU3RyID0gKHRoaXMubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcclxuICAgICAgaWYgKG5hbm9zU3RyLnN1YnN0cmluZygzKSA9PT0gXCIwMDAwMDBcIikge1xyXG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArIFwiWlwiO1xyXG4gICAgICB9IGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gXCIwMDBcIikge1xyXG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArIFwiWlwiO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyICsgXCJaXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRGF0ZShtcykudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiLjAwMFpcIiwgeik7XHJcbiAgfVxyXG4gIHRvRGF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDAgKyBNYXRoLmNlaWwodGhpcy5uYW5vcyAvIDEwMDAwMDApKTtcclxuICB9XHJcbiAgc3RhdGljIG5vdygpIHtcclxuICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbURhdGUobmV3IERhdGUoKSk7XHJcbiAgfVxyXG4gIHN0YXRpYyBmcm9tRGF0ZShkYXRlKSB7XHJcbiAgICBjb25zdCBtcyA9IGRhdGUuZ2V0VGltZSgpO1xyXG4gICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoe1xyXG4gICAgICBzZWNvbmRzOiBwcm90b0ludDY0LnBhcnNlKE1hdGguZmxvb3IobXMgLyAxMDAwKSksXHJcbiAgICAgIG5hbm9zOiBtcyAlIDEwMDAgKiAxMDAwMDAwXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcclxuICB9XHJcbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xyXG4gICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUaW1lc3RhbXAsIGEsIGIpO1xyXG4gIH1cclxufVxyXG5UaW1lc3RhbXAucnVudGltZSA9IHByb3RvMztcclxuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XHJcblRpbWVzdGFtcC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInNlY29uZHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDMgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJuYW5vc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn1dKTtcclxuXHJcbmNvbnN0IE1ldHJpY3NCYXRjaCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY3NCYXRjaFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidGltZXN0YW1wX21zXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJub3JtYWxpemVkX3RpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVzdGFtcFxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJzdHJfZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ0aW1lX3Nlcmllc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVTZXJpZXNNZXRyaWMsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiZXZlbnRzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRXZlbnRNZXRyaWMsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBUaW1lU2VyaWVzTWV0cmljID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVGltZVNlcmllc01ldHJpY1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwibGFiZWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInNhbXBsZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBNZXRyaWNTYW1wbGUsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwicmlkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgTWV0cmljU2FtcGxlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuTWV0cmljU2FtcGxlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVGltZXN0YW1wXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInZhbHVlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAyXHJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xyXG59XSk7XHJcbmNvbnN0IEV2ZW50TWV0cmljID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRXZlbnRNZXRyaWNcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImxhYmVsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJzdGFydF90aW1lc3RhbXBfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImVuZF90aW1lc3RhbXBfbXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDMsXHJcbiAgb3B0OiB0cnVlXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfc3RhcnRfdGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVGltZXN0YW1wXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfZW5kX3RpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVzdGFtcCxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJyaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBCYWNrdXBDb2RlY1BvbGljeSQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5CYWNrdXBDb2RlY1BvbGljeVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiUFJFRkVSX1JFR1JFU1NJT05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJTSU1VTENBU1RcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJSRUdSRVNTSU9OXCJcclxufV0pO1xyXG5jb25zdCBUcmFja1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlRyYWNrVHlwZVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiQVVESU9cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJWSURFT1wiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkRBVEFcIlxyXG59XSk7XHJcbmNvbnN0IFRyYWNrU291cmNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5UcmFja1NvdXJjZVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiVU5LTk9XTlwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkNBTUVSQVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIk1JQ1JPUEhPTkVcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJTQ1JFRU5fU0hBUkVfQVVESU9cIlxyXG59XSk7XHJcbmNvbnN0IFZpZGVvUXVhbGl0eSQxID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5WaWRlb1F1YWxpdHlcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIkxPV1wiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIk1FRElVTVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkhJR0hcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJPRkZcIlxyXG59XSk7XHJcbmNvbnN0IENvbm5lY3Rpb25RdWFsaXR5JDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5XCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJQT09SXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiR09PRFwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkVYQ0VMTEVOVFwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIkxPU1RcIlxyXG59XSk7XHJcbmNvbnN0IENsaWVudENvbmZpZ1NldHRpbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlVOU0VUXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiRElTQUJMRURcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJFTkFCTEVEXCJcclxufV0pO1xyXG5jb25zdCBEaXNjb25uZWN0UmVhc29uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5EaXNjb25uZWN0UmVhc29uXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCJcclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIlxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIlxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJNSUdSQVRJT05cIlxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJTSUdOQUxfQ0xPU0VcIlxyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwiUk9PTV9DTE9TRURcIlxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwiVVNFUl9VTkFWQUlMQUJMRVwiXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJVU0VSX1JFSkVDVEVEXCJcclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcIlNJUF9UUlVOS19GQUlMVVJFXCJcclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcIkNPTk5FQ1RJT05fVElNRU9VVFwiXHJcbn0sIHtcclxuICBubzogMTUsXHJcbiAgbmFtZTogXCJNRURJQV9GQUlMVVJFXCJcclxufV0pO1xyXG5jb25zdCBSZWNvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlJlY29ubmVjdFJlYXNvblwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiUlJfVU5LTk9XTlwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIlJSX1NJR05BTF9ESVNDT05ORUNURURcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiUlJfU1VCU0NSSUJFUl9GQUlMRURcIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJSUl9TV0lUQ0hfQ0FORElEQVRFXCJcclxufV0pO1xyXG5jb25zdCBTdWJzY3JpcHRpb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlNFX1VOS05PV05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJTRV9DT0RFQ19VTlNVUFBPUlRFRFwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCJcclxufV0pO1xyXG5jb25zdCBBdWRpb1RyYWNrRmVhdHVyZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQXVkaW9UcmFja0ZlYXR1cmVcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlRGX1NURVJFT1wiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIlRGX05PX0RUWFwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIlRGX0FVVE9fR0FJTl9DT05UUk9MXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiVEZfRUNIT19DQU5DRUxMQVRJT05cIlxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJURl9OT0lTRV9TVVBQUkVTU0lPTlwiXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTlwiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcIlRGX1BSRUNPTk5FQ1RfQlVGRkVSXCJcclxufV0pO1xyXG5jb25zdCBSb29tJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJuYW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZW1wdHlfdGltZW91dFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDE0LFxyXG4gIG5hbWU6IFwiZGVwYXJ0dXJlX3RpbWVvdXRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwibWF4X3BhcnRpY2lwYW50c1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJjcmVhdGlvbl90aW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwiY3JlYXRpb25fdGltZV9tc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwidHVybl9wYXNzd29yZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImVuYWJsZWRfY29kZWNzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogQ29kZWMsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwibWV0YWRhdGFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJudW1fcGFydGljaXBhbnRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMTEsXHJcbiAgbmFtZTogXCJudW1fcHVibGlzaGVyc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwiYWN0aXZlX3JlY29yZGluZ1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwidmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRpbWVkVmVyc2lvblxyXG59XSk7XHJcbmNvbnN0IENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29kZWNcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcIm1pbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJmbXRwX2xpbmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IFBhcnRpY2lwYW50UGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY2FuX3N1YnNjcmliZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJjYW5fcHVibGlzaFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9kYXRhXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcImNhbl9wdWJsaXNoX3NvdXJjZXNcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImhpZGRlblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJyZWNvcmRlclwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwiYWdlbnRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVfbWV0cmljc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59XSk7XHJcbmNvbnN0IFBhcnRpY2lwYW50SW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJzdGF0ZVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInRyYWNrc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYWNrSW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcImpvaW5lZF9hdFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAxNyxcclxuICBuYW1lOiBcImpvaW5lZF9hdF9tc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMTEsXHJcbiAgbmFtZTogXCJwZXJtaXNzaW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRQZXJtaXNzaW9uXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJyZWdpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwiaXNfcHVibGlzaGVyXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJraW5kXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kKVxyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxyXG4gIGtpbmQ6IFwibWFwXCIsXHJcbiAgSzogOSxcclxuICBWOiB7XHJcbiAgICBraW5kOiBcInNjYWxhclwiLFxyXG4gICAgVDogOVxyXG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxuICB9XHJcbn0sIHtcclxuICBubzogMTYsXHJcbiAgbmFtZTogXCJkaXNjb25uZWN0X3JlYXNvblwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKVxyXG59LCB7XHJcbiAgbm86IDE4LFxyXG4gIG5hbWU6IFwia2luZF9kZXRhaWxzXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsKSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJKT0lOSU5HXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiSk9JTkVEXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiQUNUSVZFXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiRElTQ09OTkVDVEVEXCJcclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudEluZm9fS2luZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmRcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlNUQU5EQVJEXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiSU5HUkVTU1wiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkVHUkVTU1wiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIlNJUFwiXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIkFHRU5UXCJcclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudEluZm9fS2luZERldGFpbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmREZXRhaWxcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIkNMT1VEX0FHRU5UXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiRk9SV0FSREVEXCJcclxufV0pO1xyXG5jb25zdCBFbmNyeXB0aW9uX1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiTk9ORVwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkdDTVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIkNVU1RPTVwiXHJcbn1dKTtcclxuY29uc3QgU2ltdWxjYXN0Q29kZWNJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJtaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJjaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJsYXllcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBWaWRlb0xheWVyLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVHJhY2tJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0eXBlXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIm11dGVkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIndpZHRoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcImhlaWdodFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJzaW11bGNhc3RcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwic291cmNlXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKVxyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwibGF5ZXJzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVmlkZW9MYXllcixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcIm1pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTMsXHJcbiAgbmFtZTogXCJjb2RlY3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTaW11bGNhc3RDb2RlY0luZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcInN0ZXJlb1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxNixcclxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxyXG59LCB7XHJcbiAgbm86IDE3LFxyXG4gIG5hbWU6IFwic3RyZWFtXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxOCxcclxuICBuYW1lOiBcInZlcnNpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUaW1lZFZlcnNpb25cclxufSwge1xyXG4gIG5vOiAxOSxcclxuICBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDIwLFxyXG4gIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShCYWNrdXBDb2RlY1BvbGljeSQxKVxyXG59XSk7XHJcbmNvbnN0IFZpZGVvTGF5ZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5WaWRlb0xheWVyXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJxdWFsaXR5XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvUXVhbGl0eSQxKVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ3aWR0aFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJoZWlnaHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiYml0cmF0ZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJzc3JjXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgRGF0YVBhY2tldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFQYWNrZXRcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImtpbmRcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVBhY2tldF9LaW5kKVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImRlc3RpbmF0aW9uX2lkZW50aXRpZXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidXNlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVzZXJQYWNrZXQsXHJcbiAgb25lb2Y6IFwidmFsdWVcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJzcGVha2VyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInNpcF9kdG1mXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2lwRFRNRixcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcInRyYW5zY3JpcHRpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFuc2NyaXB0aW9uLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwibWV0cmljc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IE1ldHJpY3NCYXRjaCxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcImNoYXRfbWVzc2FnZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENoYXRNZXNzYWdlLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcInJwY19yZXF1ZXN0XCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUnBjUmVxdWVzdCxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTEsXHJcbiAgbmFtZTogXCJycGNfYWNrXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUnBjQWNrLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcInJwY19yZXNwb25zZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJwY1Jlc3BvbnNlLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcInN0cmVhbV9oZWFkZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEYXRhU3RyZWFtX0hlYWRlcixcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMTQsXHJcbiAgbmFtZTogXCJzdHJlYW1fY2h1bmtcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEYXRhU3RyZWFtX0NodW5rLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcInN0cmVhbV90cmFpbGVyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRGF0YVN0cmVhbV9UcmFpbGVyLFxyXG4gIG9uZW9mOiBcInZhbHVlXCJcclxufSwge1xyXG4gIG5vOiAxNixcclxuICBuYW1lOiBcInNlcXVlbmNlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMTcsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IERhdGFQYWNrZXRfS2luZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGF0YVBhY2tldC5LaW5kXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJSRUxJQUJMRVwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIkxPU1NZXCJcclxufV0pO1xyXG5jb25zdCBBY3RpdmVTcGVha2VyVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTcGVha2VySW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFNwZWFrZXJJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3BlYWtlckluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInNpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImxldmVsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAyXHJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJhY3RpdmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBVc2VyUGFja2V0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXNlclBhY2tldFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJwYXlsb2FkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxMlxyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZGVzdGluYXRpb25fc2lkc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInRvcGljXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIG9wdDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA5LFxyXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNCxcclxuICBvcHQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcImVuZF90aW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA0LFxyXG4gIG9wdDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwibm9uY2VcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEyXHJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xyXG59XSk7XHJcbmNvbnN0IFNpcERUTUYgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaXBEVE1GXCIsICgpID0+IFt7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJjb2RlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImRpZ2l0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBUcmFuc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhbnNjcmlwdGlvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidHJhbnNjcmliZWRfcGFydGljaXBhbnRfaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ0cmFja19pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInNlZ21lbnRzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhbnNjcmlwdGlvblNlZ21lbnQsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBUcmFuc2NyaXB0aW9uU2VnbWVudCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYW5zY3JpcHRpb25TZWdtZW50XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRleHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJzdGFydF90aW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA0XHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwiZW5kX3RpbWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDRcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJmaW5hbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJsYW5ndWFnZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgQ2hhdE1lc3NhZ2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DaGF0TWVzc2FnZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImVkaXRfdGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzLFxyXG4gIG9wdDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwiZGVsZXRlZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJnZW5lcmF0ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBScGNSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjUmVxdWVzdFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJtZXRob2RcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJwYXlsb2FkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicmVzcG9uc2VfdGltZW91dF9tc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgUnBjQWNrID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUnBjQWNrXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBScGNSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1Jlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOSxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImVycm9yXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUnBjRXJyb3IkMSxcclxuICBvbmVvZjogXCJ2YWx1ZVwiXHJcbn1dKTtcclxuY29uc3QgUnBjRXJyb3IkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY0Vycm9yXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjb2RlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIm1lc3NhZ2VcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJkYXRhXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudFRyYWNrcyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50VHJhY2tzXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgU2VydmVySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNlcnZlckluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImVkaXRpb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwicHJvdG9jb2xcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDVcclxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInJlZ2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIm5vZGVfaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJkZWJ1Z19pbmZvXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiYWdlbnRfcHJvdG9jb2xcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDVcclxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXHJcbn1dKTtcclxuY29uc3QgU2VydmVySW5mb19FZGl0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlN0YW5kYXJkXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiQ2xvdWRcIlxyXG59XSk7XHJcbmNvbnN0IENsaWVudEluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DbGllbnRJbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzZGtcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50SW5mb19TREspXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInZlcnNpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJwcm90b2NvbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwib3NcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJvc192ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiZGV2aWNlX21vZGVsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiYnJvd3NlclwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImJyb3dzZXJfdmVyc2lvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcImFkZHJlc3NcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwibmV0d29ya1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMTEsXHJcbiAgbmFtZTogXCJvdGhlcl9zZGtzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBDbGllbnRJbmZvX1NESyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ2xpZW50SW5mby5TREtcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIlVOS05PV05cIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJKU1wiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIlNXSUZUXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiQU5EUk9JRFwiXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIkZMVVRURVJcIlxyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJHT1wiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcIlVOSVRZXCJcclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCJcclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiUlVTVFwiXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcIlBZVEhPTlwiXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJDUFBcIlxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwiVU5JVFlfV0VCXCJcclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcIk5PREVcIlxyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwiVU5SRUFMXCJcclxufV0pO1xyXG5jb25zdCBDbGllbnRDb25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2xpZW50Q29uZmlndXJhdGlvblwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidmlkZW9cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBWaWRlb0NvbmZpZ3VyYXRpb25cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwic2NyZWVuXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVmlkZW9Db25maWd1cmF0aW9uXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IERpc2FibGVkQ29kZWNzXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImZvcmNlX3JlbGF5XCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXHJcbn1dKTtcclxuY29uc3QgVmlkZW9Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJoYXJkd2FyZV9lbmNvZGVyXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXHJcbn1dKTtcclxuY29uc3QgRGlzYWJsZWRDb2RlY3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY29kZWNzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogQ29kZWMsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicHVibGlzaFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENvZGVjLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVGltZWRWZXJzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVGltZWRWZXJzaW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ1bml4X21pY3JvXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0aWNrc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkRhdGFTdHJlYW0uT3BlcmF0aW9uVHlwZVwiLCBbe1xyXG4gIG5vOiAwLFxyXG4gIG5hbWU6IFwiQ1JFQVRFXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiVVBEQVRFXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiREVMRVRFXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiUkVBQ1RJT05cIlxyXG59XSk7XHJcbmNvbnN0IERhdGFTdHJlYW1fVGV4dEhlYWRlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uVGV4dEhlYWRlclwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwib3BlcmF0aW9uX3R5cGVcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlKVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA1XHJcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJyZXBseV90b19zdHJlYW1faWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJhdHRhY2hlZF9zdHJlYW1faWRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImdlbmVyYXRlZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59XSwge1xyXG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RleHRIZWFkZXJcIlxyXG59KTtcclxuY29uc3QgRGF0YVN0cmVhbV9CeXRlSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5CeXRlSGVhZGVyXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJuYW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0sIHtcclxuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9CeXRlSGVhZGVyXCJcclxufSk7XHJcbmNvbnN0IERhdGFTdHJlYW1fSGVhZGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5IZWFkZXJcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInN0cmVhbV9pZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidG9waWNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJ0b3RhbF9sZW5ndGhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDQsXHJcbiAgb3B0OiB0cnVlXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImVuY3J5cHRpb25fdHlwZVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcclxuICBraW5kOiBcIm1hcFwiLFxyXG4gIEs6IDksXHJcbiAgVjoge1xyXG4gICAga2luZDogXCJzY2FsYXJcIixcclxuICAgIFQ6IDlcclxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbiAgfVxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJ0ZXh0X2hlYWRlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IERhdGFTdHJlYW1fVGV4dEhlYWRlcixcclxuICBvbmVvZjogXCJjb250ZW50X2hlYWRlclwiXHJcbn0sIHtcclxuICBubzogMTAsXHJcbiAgbmFtZTogXCJieXRlX2hlYWRlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IERhdGFTdHJlYW1fQnl0ZUhlYWRlcixcclxuICBvbmVvZjogXCJjb250ZW50X2hlYWRlclwiXHJcbn1dLCB7XHJcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fSGVhZGVyXCJcclxufSk7XHJcbmNvbnN0IERhdGFTdHJlYW1fQ2h1bmsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkNodW5rXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzdHJlYW1faWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJjaHVua19pbmRleFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNFxyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImNvbnRlbnRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEyXHJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA1XHJcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJpdlwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTIsXHJcbiAgb3B0OiB0cnVlXHJcbn1dLCB7XHJcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQ2h1bmtcIlxyXG59KTtcclxuY29uc3QgRGF0YVN0cmVhbV9UcmFpbGVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YVN0cmVhbS5UcmFpbGVyXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzdHJlYW1faWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJyZWFzb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXHJcbiAga2luZDogXCJtYXBcIixcclxuICBLOiA5LFxyXG4gIFY6IHtcclxuICAgIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgICBUOiA5XHJcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG4gIH1cclxufV0sIHtcclxuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9UcmFpbGVyXCJcclxufSk7XHJcbmNvbnN0IFNpZ25hbFRhcmdldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJQVUJMSVNIRVJcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJTVUJTQ1JJQkVSXCJcclxufV0pO1xyXG5jb25zdCBTdHJlYW1TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3RyZWFtU3RhdGVcIiwgW3tcclxuICBubzogMCxcclxuICBuYW1lOiBcIkFDVElWRVwiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIlBBVVNFRFwiXHJcbn1dKTtcclxuY29uc3QgQ2FuZGlkYXRlUHJvdG9jb2wgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJVRFBcIlxyXG59LCB7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJUQ1BcIlxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJUTFNcIlxyXG59XSk7XHJcbmNvbnN0IFNpZ25hbFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaWduYWxSZXF1ZXN0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJvZmZlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiYW5zd2VyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ0cmlja2xlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJpY2tsZVJlcXVlc3QsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImFkZF90cmFja1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IEFkZFRyYWNrUmVxdWVzdCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwibXV0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IE11dGVUcmFja1JlcXVlc3QsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbixcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwidHJhY2tfc2V0dGluZ1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZVRyYWNrU2V0dGluZ3MsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImxlYXZlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogTGVhdmVSZXF1ZXN0LFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwidXBkYXRlX2xheWVyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFVwZGF0ZVZpZGVvTGF5ZXJzLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDEyLFxyXG4gIG5hbWU6IFwic3luY19zdGF0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN5bmNTdGF0ZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcInNpbXVsYXRlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2ltdWxhdGVTY2VuYXJpbyxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcInBpbmdcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDMsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTUsXHJcbiAgbmFtZTogXCJ1cGRhdGVfbWV0YWRhdGFcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE2LFxyXG4gIG5hbWU6IFwicGluZ19yZXFcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQaW5nLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE3LFxyXG4gIG5hbWU6IFwidXBkYXRlX2F1ZGlvX3RyYWNrXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVXBkYXRlTG9jYWxBdWRpb1RyYWNrLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE4LFxyXG4gIG5hbWU6IFwidXBkYXRlX3ZpZGVvX3RyYWNrXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVXBkYXRlTG9jYWxWaWRlb1RyYWNrLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59XSk7XHJcbmNvbnN0IFNpZ25hbFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2lnbmFsUmVzcG9uc2VcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImpvaW5cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBKb2luUmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImFuc3dlclwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwib2ZmZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInRyaWNrbGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmlja2xlUmVxdWVzdCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwidXBkYXRlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRVcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInRyYWNrX3B1Ymxpc2hlZFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogOCxcclxuICBuYW1lOiBcImxlYXZlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogTGVhdmVSZXF1ZXN0LFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJtdXRlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogTXV0ZVRyYWNrUmVxdWVzdCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcInNwZWFrZXJzX2NoYW5nZWRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTcGVha2Vyc0NoYW5nZWQsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTEsXHJcbiAgbmFtZTogXCJyb29tX3VwZGF0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJvb21VcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTIsXHJcbiAgbmFtZTogXCJjb25uZWN0aW9uX3F1YWxpdHlcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxMyxcclxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZV91cGRhdGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdHJlYW1TdGF0ZVVwZGF0ZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAxNSxcclxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTYsXHJcbiAgbmFtZTogXCJyZWZyZXNoX3Rva2VuXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE3LFxyXG4gIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMTgsXHJcbiAgbmFtZTogXCJwb25nXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDE5LFxyXG4gIG5hbWU6IFwicmVjb25uZWN0XCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUmVjb25uZWN0UmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMjAsXHJcbiAgbmFtZTogXCJwb25nX3Jlc3BcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQb25nLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDIxLFxyXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Jlc3BvbnNlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3Vic2NyaXB0aW9uUmVzcG9uc2UsXHJcbiAgb25lb2Y6IFwibWVzc2FnZVwiXHJcbn0sIHtcclxuICBubzogMjIsXHJcbiAgbmFtZTogXCJyZXF1ZXN0X3Jlc3BvbnNlXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUmVxdWVzdFJlc3BvbnNlLFxyXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxyXG59LCB7XHJcbiAgbm86IDIzLFxyXG4gIG5hbWU6IFwidHJhY2tfc3Vic2NyaWJlZFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFRyYWNrU3Vic2NyaWJlZCxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufSwge1xyXG4gIG5vOiAyNCxcclxuICBuYW1lOiBcInJvb21fbW92ZWRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBSb29tTW92ZWRSZXNwb25zZSxcclxuICBvbmVvZjogXCJtZXNzYWdlXCJcclxufV0pO1xyXG5jb25zdCBTaW11bGNhc3RDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjb2RlY1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImNpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgQWRkVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJjaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJuYW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwidHlwZVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcIndpZHRoXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcImhlaWdodFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJtdXRlZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJkaXNhYmxlX2R0eFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJzb3VyY2VcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcImxheWVyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFZpZGVvTGF5ZXIsXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAxMCxcclxuICBuYW1lOiBcInNpbXVsY2FzdF9jb2RlY3NcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTaW11bGNhc3RDb2RlYyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwic2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcInN0ZXJlb1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAxNCxcclxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKVxyXG59LCB7XHJcbiAgbm86IDE1LFxyXG4gIG5hbWU6IFwic3RyZWFtXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAxNixcclxuICBuYW1lOiBcImJhY2t1cF9jb2RlY19wb2xpY3lcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQmFja3VwQ29kZWNQb2xpY3kkMSlcclxufSwge1xyXG4gIG5vOiAxNyxcclxuICBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFRyaWNrbGVSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJpY2tsZVJlcXVlc3RcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNhbmRpZGF0ZUluaXRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ0YXJnZXRcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJmaW5hbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59XSk7XHJcbmNvbnN0IE11dGVUcmFja1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5NdXRlVHJhY2tSZXF1ZXN0XCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJtdXRlZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOFxyXG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xyXG59XSk7XHJcbmNvbnN0IEpvaW5SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkpvaW5SZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicm9vbVwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFJvb20kMVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFBhcnRpY2lwYW50SW5mb1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJvdGhlcl9wYXJ0aWNpcGFudHNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQYXJ0aWNpcGFudEluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwic2VydmVyX3ZlcnNpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDUsXHJcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IElDRVNlcnZlcixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDYsXHJcbiAgbmFtZTogXCJzdWJzY3JpYmVyX3ByaW1hcnlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiA4LFxyXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBDbGllbnRDb25maWd1cmF0aW9uXHJcbn0sIHtcclxuICBubzogOSxcclxuICBuYW1lOiBcInNlcnZlcl9yZWdpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDEwLFxyXG4gIG5hbWU6IFwicGluZ190aW1lb3V0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA1XHJcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDExLFxyXG4gIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNVxyXG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiAxMixcclxuICBuYW1lOiBcInNlcnZlcl9pbmZvXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2VydmVySW5mb1xyXG59LCB7XHJcbiAgbm86IDEzLFxyXG4gIG5hbWU6IFwic2lmX3RyYWlsZXJcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEyXHJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xyXG59LCB7XHJcbiAgbm86IDE0LFxyXG4gIG5hbWU6IFwiZW5hYmxlZF9wdWJsaXNoX2NvZGVjc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENvZGVjLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMTUsXHJcbiAgbmFtZTogXCJmYXN0X3B1Ymxpc2hcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBSZWNvbm5lY3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlY29ubmVjdFJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJpY2Vfc2VydmVyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IElDRVNlcnZlcixcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJjbGllbnRfY29uZmlndXJhdGlvblwiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic2VydmVyX2luZm9cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTZXJ2ZXJJbmZvXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcImxhc3RfbWVzc2FnZV9zZXFcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiY2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidHJhY2tcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBUcmFja0luZm9cclxufV0pO1xyXG5jb25zdCBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgU2Vzc2lvbkRlc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0eXBlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwic2RwXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBQYXJ0aWNpcGFudFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBhcnRpY2lwYW50VXBkYXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudHNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQYXJ0aWNpcGFudEluZm8sXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVTdWJzY3JpcHRpb25cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwic3Vic2NyaWJlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X3RyYWNrc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFBhcnRpY2lwYW50VHJhY2tzLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVXBkYXRlVHJhY2tTZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiZGlzYWJsZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkkMSlcclxufSwge1xyXG4gIG5vOiA1LFxyXG4gIG5hbWU6IFwid2lkdGhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwiaGVpZ2h0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogNyxcclxuICBuYW1lOiBcImZwc1wiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJwcmlvcml0eVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsQXVkaW9UcmFja1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiZmVhdHVyZXNcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9UcmFja0ZlYXR1cmUpLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVXBkYXRlTG9jYWxWaWRlb1RyYWNrID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlTG9jYWxWaWRlb1RyYWNrXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ3aWR0aFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJoZWlnaHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDEzXHJcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cclxufV0pO1xyXG5jb25zdCBMZWF2ZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNhbl9yZWNvbm5lY3RcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicmVhc29uXCIsXHJcbiAga2luZDogXCJlbnVtXCIsXHJcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImFjdGlvblwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShMZWF2ZVJlcXVlc3RfQWN0aW9uKVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJyZWdpb25zXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUmVnaW9uU2V0dGluZ3NcclxufV0pO1xyXG5jb25zdCBMZWF2ZVJlcXVlc3RfQWN0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJESVNDT05ORUNUXCJcclxufSwge1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwiUkVTVU1FXCJcclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwiUkVDT05ORUNUXCJcclxufV0pO1xyXG5jb25zdCBVcGRhdGVWaWRlb0xheWVycyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVZpZGVvTGF5ZXJzXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJsYXllcnNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBWaWRlb0xheWVyLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGFcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcIm1ldGFkYXRhXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwibmFtZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcclxuICBraW5kOiBcIm1hcFwiLFxyXG4gIEs6IDksXHJcbiAgVjoge1xyXG4gICAga2luZDogXCJzY2FsYXJcIixcclxuICAgIFQ6IDlcclxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbiAgfVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn1dKTtcclxuY29uc3QgSUNFU2VydmVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuSUNFU2VydmVyXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ1cmxzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInVzZXJuYW1lXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiY3JlZGVudGlhbFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn1dKTtcclxuY29uc3QgU3BlYWtlcnNDaGFuZ2VkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3BlYWtlcnNDaGFuZ2VkXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzcGVha2Vyc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFNwZWFrZXJJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgUm9vbVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21VcGRhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInJvb21cIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBSb29tJDFcclxufV0pO1xyXG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInF1YWxpdHlcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ29ubmVjdGlvblF1YWxpdHkkMSlcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic2NvcmVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDJcclxuICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXHJcbn1dKTtcclxuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidXBkYXRlc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFN0cmVhbVN0YXRlSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN0cmVhbVN0YXRlSW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwic3RhdGVcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpXHJcbn1dKTtcclxuY29uc3QgU3RyZWFtU3RhdGVVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN0cmVhbVN0YXRlSW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFN1YnNjcmliZWRRdWFsaXR5ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3Vic2NyaWJlZFF1YWxpdHlcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInF1YWxpdHlcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcImVuYWJsZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBTdWJzY3JpYmVkQ29kZWMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImNvZGVjXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwicXVhbGl0aWVzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufV0pO1xyXG5jb25zdCBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJzdWJzY3JpYmVkX3F1YWxpdGllc1wiLFxyXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxyXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5LFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU3Vic2NyaWJlZENvZGVjLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgVHJhY2tQZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJhbGxfdHJhY2tzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59XSk7XHJcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJhbGxfcGFydGljaXBhbnRzXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4XHJcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRyYWNrX3Blcm1pc3Npb25zXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhY2tQZXJtaXNzaW9uLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOVxyXG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcImFsbG93ZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDhcclxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cclxufV0pO1xyXG5jb25zdCBSb29tTW92ZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21Nb3ZlZFJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyb29tXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUm9vbSQxXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRva2VuXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwicGFydGljaXBhbnRcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBQYXJ0aWNpcGFudEluZm9cclxufSwge1xyXG4gIG5vOiA0LFxyXG4gIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUGFydGljaXBhbnRJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn1dKTtcclxuY29uc3QgU3luY1N0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3luY1N0YXRlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJhbnN3ZXJcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cclxufSwge1xyXG4gIG5vOiAyLFxyXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcInB1Ymxpc2hfdHJhY2tzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59LCB7XHJcbiAgbm86IDQsXHJcbiAgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogRGF0YUNoYW5uZWxJbmZvLFxyXG4gIHJlcGVhdGVkOiB0cnVlXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcIm9mZmVyXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXHJcbn0sIHtcclxuICBubzogNixcclxuICBuYW1lOiBcInRyYWNrX3NpZHNfZGlzYWJsZWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDksXHJcbiAgcmVwZWF0ZWQ6IHRydWVcclxufSwge1xyXG4gIG5vOiA3LFxyXG4gIG5hbWU6IFwiZGF0YWNoYW5uZWxfcmVjZWl2ZV9zdGF0ZXNcIixcclxuICBraW5kOiBcIm1lc3NhZ2VcIixcclxuICBUOiBEYXRhQ2hhbm5lbFJlY2VpdmVTdGF0ZSxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IERhdGFDaGFubmVsUmVjZWl2ZVN0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YUNoYW5uZWxSZWNlaXZlU3RhdGVcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcInB1Ymxpc2hlcl9zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJsYXN0X3NlcVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59XSk7XHJcbmNvbnN0IERhdGFDaGFubmVsSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFDaGFubmVsSW5mb1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwibGFiZWxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJpZFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogMTNcclxuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJ0YXJnZXRcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxyXG59XSk7XHJcbmNvbnN0IFNpbXVsYXRlU2NlbmFyaW8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaW11bGF0ZVNjZW5hcmlvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJzcGVha2VyX3VwZGF0ZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogNSxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIm5vZGVfZmFpbHVyZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOCxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn0sIHtcclxuICBubzogMyxcclxuICBuYW1lOiBcIm1pZ3JhdGlvblwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOCxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn0sIHtcclxuICBubzogNCxcclxuICBuYW1lOiBcInNlcnZlcl9sZWF2ZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogOCxcclxuICBvbmVvZjogXCJzY2VuYXJpb1wiXHJcbn0sIHtcclxuICBubzogNSxcclxuICBuYW1lOiBcInN3aXRjaF9jYW5kaWRhdGVfcHJvdG9jb2xcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLFxyXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcclxufSwge1xyXG4gIG5vOiA2LFxyXG4gIG5hbWU6IFwic3Vic2NyaWJlcl9iYW5kd2lkdGhcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDMsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDcsXHJcbiAgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDgsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDgsXHJcbiAgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVfbm9fbWVzc2FnZXNcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDgsXHJcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxyXG59LCB7XHJcbiAgbm86IDksXHJcbiAgbmFtZTogXCJsZWF2ZV9yZXF1ZXN0X2Z1bGxfcmVjb25uZWN0XCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA4LFxyXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcclxufV0pO1xyXG5jb25zdCBQaW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGluZ1wiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidGltZXN0YW1wXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAzXHJcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJydHRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn1dKTtcclxuY29uc3QgUG9uZyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlBvbmdcIiwgKCkgPT4gW3tcclxuICBubzogMSxcclxuICBuYW1lOiBcImxhc3RfcGluZ190aW1lc3RhbXBcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDNcclxuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufV0pO1xyXG5jb25zdCBSZWdpb25TZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlZ2lvblNldHRpbmdzXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyZWdpb25zXCIsXHJcbiAga2luZDogXCJtZXNzYWdlXCIsXHJcbiAgVDogUmVnaW9uSW5mbyxcclxuICByZXBlYXRlZDogdHJ1ZVxyXG59XSk7XHJcbmNvbnN0IFJlZ2lvbkluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWdpb25JbmZvXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyZWdpb25cIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJ1cmxcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJkaXN0YW5jZVwiLFxyXG4gIGtpbmQ6IFwic2NhbGFyXCIsXHJcbiAgVDogM1xyXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cclxufV0pO1xyXG5jb25zdCBTdWJzY3JpcHRpb25SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcclxuICBraW5kOiBcInNjYWxhclwiLFxyXG4gIFQ6IDlcclxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xyXG59LCB7XHJcbiAgbm86IDIsXHJcbiAgbmFtZTogXCJlcnJcIixcclxuICBraW5kOiBcImVudW1cIixcclxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpXHJcbn1dKTtcclxuY29uc3QgUmVxdWVzdFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlXCIsICgpID0+IFt7XHJcbiAgbm86IDEsXHJcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiAxM1xyXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcInJlYXNvblwiLFxyXG4gIGtpbmQ6IFwiZW51bVwiLFxyXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShSZXF1ZXN0UmVzcG9uc2VfUmVhc29uKVxyXG59LCB7XHJcbiAgbm86IDMsXHJcbiAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5jb25zdCBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5SZXF1ZXN0UmVzcG9uc2UuUmVhc29uXCIsIFt7XHJcbiAgbm86IDAsXHJcbiAgbmFtZTogXCJPS1wiXHJcbn0sIHtcclxuICBubzogMSxcclxuICBuYW1lOiBcIk5PVF9GT1VORFwiXHJcbn0sIHtcclxuICBubzogMixcclxuICBuYW1lOiBcIk5PVF9BTExPV0VEXCJcclxufSwge1xyXG4gIG5vOiAzLFxyXG4gIG5hbWU6IFwiTElNSVRfRVhDRUVERURcIlxyXG59XSk7XHJcbmNvbnN0IFRyYWNrU3Vic2NyaWJlZCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrU3Vic2NyaWJlZFwiLCAoKSA9PiBbe1xyXG4gIG5vOiAxLFxyXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXHJcbiAga2luZDogXCJzY2FsYXJcIixcclxuICBUOiA5XHJcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cclxufV0pO1xyXG5cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcclxuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xyXG59XHJcblxyXG52YXIgbG9nbGV2ZWwkMSA9IHtleHBvcnRzOiB7fX07XHJcblxyXG4vKlxyXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXHJcbipcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG52YXIgbG9nbGV2ZWwgPSBsb2dsZXZlbCQxLmV4cG9ydHM7XHJcbnZhciBoYXNSZXF1aXJlZExvZ2xldmVsO1xyXG5mdW5jdGlvbiByZXF1aXJlTG9nbGV2ZWwoKSB7XHJcbiAgaWYgKGhhc1JlcXVpcmVkTG9nbGV2ZWwpIHJldHVybiBsb2dsZXZlbCQxLmV4cG9ydHM7XHJcbiAgaGFzUmVxdWlyZWRMb2dsZXZlbCA9IDE7XHJcbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuICAgIChmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xyXG5cclxuICAgICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKGxvZ2xldmVsLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXHJcbiAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcclxuICAgICAgdmFyIGlzSUUgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlICYmIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgICAgdmFyIGxvZ01ldGhvZHMgPSBbXCJ0cmFjZVwiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXTtcclxuICAgICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XHJcbiAgICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcclxuICAgICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XHJcbiAgICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XHJcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XHJcbiAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cclxuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxyXG4gICAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcclxuICAgICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcclxuICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcclxuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xyXG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMuZ2V0TGV2ZWwoKTtcclxuXHJcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgYWN0dWFsIG1ldGhvZHMuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XHJcbiAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gaSA8IGxldmVsID8gbm9vcCA6IHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgdGhpcy5uYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcclxuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBhbnkgaW1wb3J0YW50IHdhcm5pbmdzLlxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cclxuICAgICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcclxuICAgICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXHJcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXHJcbiAgICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIF9sZXZlbCwgX2xvZ2dlck5hbWUpIHtcclxuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZmFjdG9yeSkge1xyXG4gICAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcclxuICAgICAgICAgKiBjYWNoZSB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gZGVsZWdhdGluZyB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgc3RheXNcclxuICAgICAgICAgKiBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsb2dnaW5nIG1ldGhvZHMgdGhhdCB3ZSBoYXZlIGluc3RhbGxlZCAodGhlXHJcbiAgICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcclxuICAgICAgICAgKiBpbiB0aGlzIGNoaWxkIHlldCkuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgaW5oZXJpdGVkTGV2ZWw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcclxuICAgICAgICAgKiBgaW5oZXJpdGVkTGV2ZWxgLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgZGVmYXVsdExldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcclxuICAgICAgICAgKiBgZGVmYXVsdExldmVsYC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHVzZXJMZXZlbDtcclxuICAgICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcclxuICAgICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcclxuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcclxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XHJcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XHJcbiAgICAgICAgICAgICAgdmFyIGNvb2tpZU5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSk7XHJcbiAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcclxuICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24gKyBjb29raWVOYW1lLmxlbmd0aCArIDEpKVsxXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxyXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG5cclxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xyXG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVMZXZlbChpbnB1dCkge1xyXG4gICAgICAgICAgdmFyIGxldmVsID0gaW5wdXQ7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxldmVsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHNlbGYubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgc2VsZi5sZXZlbHMgPSB7XHJcbiAgICAgICAgICBcIlRSQUNFXCI6IDAsXHJcbiAgICAgICAgICBcIkRFQlVHXCI6IDEsXHJcbiAgICAgICAgICBcIklORk9cIjogMixcclxuICAgICAgICAgIFwiV0FSTlwiOiAzLFxyXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LFxyXG4gICAgICAgICAgXCJTSUxFTlRcIjogNVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcclxuICAgICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKHVzZXJMZXZlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRMZXZlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TGV2ZWw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdGVkTGV2ZWw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XHJcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XHJcbiAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKHVzZXJMZXZlbCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTk9URTogaW4gdjIsIHRoaXMgc2hvdWxkIGNhbGwgcmVidWlsZCgpLCB3aGljaCB1cGRhdGVzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGxldmVsKTtcclxuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xyXG4gICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XHJcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XHJcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBpZiAoZGVmYXVsdExvZ2dlciAhPT0gc2VsZikge1xyXG4gICAgICAgICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcclxuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xyXG4gICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cclxuICAgICAgICBpbmhlcml0ZWRMZXZlbCA9IG5vcm1hbGl6ZUxldmVsKGRlZmF1bHRMb2dnZXIgPyBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkgOiBcIldBUk5cIik7XHJcbiAgICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XHJcbiAgICAgICAgaWYgKGluaXRpYWxMZXZlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLypcclxuICAgICAgICpcclxuICAgICAgICogVG9wLWxldmVsIEFQSVxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XHJcbiAgICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcclxuICAgICAgICBpZiAoIWxvZ2dlcikge1xyXG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKG5hbWUsIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2dnZXI7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcclxuICAgICAgdmFyIF9sb2cgPSB0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcclxuICAgICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcclxuICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcclxuICAgICAgfTtcclxuICAgICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcclxuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XHJcbiAgICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XHJcbiAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xyXG4gICAgfSk7XHJcbiAgfSkobG9nbGV2ZWwkMSk7XHJcbiAgcmV0dXJuIGxvZ2xldmVsJDEuZXhwb3J0cztcclxufVxyXG5cclxudmFyIGxvZ2xldmVsRXhwb3J0cyA9IHJlcXVpcmVMb2dsZXZlbCgpO1xyXG5cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xyXG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZGVidWdcIl0gPSAxXSA9IFwiZGVidWdcIjtcclxuICBMb2dMZXZlbFtMb2dMZXZlbFtcImluZm9cIl0gPSAyXSA9IFwiaW5mb1wiO1xyXG4gIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XHJcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJlcnJvclwiXSA9IDRdID0gXCJlcnJvclwiO1xyXG4gIExvZ0xldmVsW0xvZ0xldmVsW1wic2lsZW50XCJdID0gNV0gPSBcInNpbGVudFwiO1xyXG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xyXG52YXIgTG9nZ2VyTmFtZXM7XHJcbihmdW5jdGlvbiAoTG9nZ2VyTmFtZXMpIHtcclxuICBMb2dnZXJOYW1lc1tcIkRlZmF1bHRcIl0gPSBcImxpdmVraXRcIjtcclxuICBMb2dnZXJOYW1lc1tcIlJvb21cIl0gPSBcImxpdmVraXQtcm9vbVwiO1xyXG4gIExvZ2dlck5hbWVzW1wiUGFydGljaXBhbnRcIl0gPSBcImxpdmVraXQtcGFydGljaXBhbnRcIjtcclxuICBMb2dnZXJOYW1lc1tcIlRyYWNrXCJdID0gXCJsaXZla2l0LXRyYWNrXCI7XHJcbiAgTG9nZ2VyTmFtZXNbXCJQdWJsaWNhdGlvblwiXSA9IFwibGl2ZWtpdC10cmFjay1wdWJsaWNhdGlvblwiO1xyXG4gIExvZ2dlck5hbWVzW1wiRW5naW5lXCJdID0gXCJsaXZla2l0LWVuZ2luZVwiO1xyXG4gIExvZ2dlck5hbWVzW1wiU2lnbmFsXCJdID0gXCJsaXZla2l0LXNpZ25hbFwiO1xyXG4gIExvZ2dlck5hbWVzW1wiUENNYW5hZ2VyXCJdID0gXCJsaXZla2l0LXBjLW1hbmFnZXJcIjtcclxuICBMb2dnZXJOYW1lc1tcIlBDVHJhbnNwb3J0XCJdID0gXCJsaXZla2l0LXBjLXRyYW5zcG9ydFwiO1xyXG4gIExvZ2dlck5hbWVzW1wiRTJFRVwiXSA9IFwibGstZTJlZVwiO1xyXG59KShMb2dnZXJOYW1lcyB8fCAoTG9nZ2VyTmFtZXMgPSB7fSkpO1xyXG5sZXQgbGl2ZWtpdExvZ2dlciA9IGxvZ2xldmVsRXhwb3J0cy5nZXRMb2dnZXIoJ2xpdmVraXQnKTtcclxuY29uc3QgbGl2ZWtpdExvZ2dlcnMgPSBPYmplY3QudmFsdWVzKExvZ2dlck5hbWVzKS5tYXAobmFtZSA9PiBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKG5hbWUpKTtcclxubGl2ZWtpdExvZ2dlci5zZXREZWZhdWx0TGV2ZWwoTG9nTGV2ZWwuaW5mbyk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XHJcbiAgY29uc3QgbG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKTtcclxuICBsb2dnZXIuc2V0RGVmYXVsdExldmVsKGxpdmVraXRMb2dnZXIuZ2V0TGV2ZWwoKSk7XHJcbiAgcmV0dXJuIGxvZ2dlcjtcclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCwgbG9nZ2VyTmFtZSkge1xyXG4gIGlmIChsb2dnZXJOYW1lKSB7XHJcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9yIChjb25zdCBsb2dnZXIgb2YgbGl2ZWtpdExvZ2dlcnMpIHtcclxuICAgICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIHVzZSB0aGlzIHRvIGhvb2sgaW50byB0aGUgbG9nZ2luZyBmdW5jdGlvbiB0byBhbGxvdyBzZW5kaW5nIGludGVybmFsIGxpdmVraXQgbG9ncyB0byB0aGlyZCBwYXJ0eSBzZXJ2aWNlc1xyXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9nRXh0ZW5zaW9uKGV4dGVuc2lvbiwgbG9nZ2VyKSB7XHJcbiAgY29uc3QgbG9nZ2VycyA9IGxvZ2dlciA/IFtsb2dnZXJdIDogbGl2ZWtpdExvZ2dlcnM7XHJcbiAgbG9nZ2Vycy5mb3JFYWNoKGxvZ1IgPT4ge1xyXG4gICAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nUi5tZXRob2RGYWN0b3J5O1xyXG4gICAgbG9nUi5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSk7XHJcbiAgICAgIGNvbnN0IGxvZ0xldmVsID0gTG9nTGV2ZWxbbWV0aG9kTmFtZV07XHJcbiAgICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcclxuICAgICAgcmV0dXJuIChtc2csIGNvbnRleHQpID0+IHtcclxuICAgICAgICBpZiAoY29udGV4dCkgcmF3TWV0aG9kKG1zZywgY29udGV4dCk7ZWxzZSByYXdNZXRob2QobXNnKTtcclxuICAgICAgICBpZiAobmVlZExvZykge1xyXG4gICAgICAgICAgZXh0ZW5zaW9uKGxvZ0xldmVsLCBtc2csIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcbiAgICBsb2dSLnNldExldmVsKGxvZ1IuZ2V0TGV2ZWwoKSk7XHJcbiAgfSk7XHJcbn1cclxuY29uc3Qgd29ya2VyTG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcignbGstZTJlZScpO1xyXG5cclxuY29uc3QgbWF4UmV0cnlEZWxheSA9IDcwMDA7XHJcbmNvbnN0IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TID0gWzAsIDMwMCwgMiAqIDIgKiAzMDAsIDMgKiAzICogMzAwLCA0ICogNCAqIDMwMCwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheSwgbWF4UmV0cnlEZWxheV07XHJcbmNsYXNzIERlZmF1bHRSZWNvbm5lY3RQb2xpY3kge1xyXG4gIGNvbnN0cnVjdG9yKHJldHJ5RGVsYXlzKSB7XHJcbiAgICB0aGlzLl9yZXRyeURlbGF5cyA9IHJldHJ5RGVsYXlzICE9PSB1bmRlZmluZWQgPyBbLi4ucmV0cnlEZWxheXNdIDogREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVM7XHJcbiAgfVxyXG4gIG5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0KSB7XHJcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50ID49IHRoaXMuX3JldHJ5RGVsYXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheXNbY29udGV4dC5yZXRyeUNvdW50XTtcclxuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPD0gMSkgcmV0dXJuIHJldHJ5RGVsYXk7XHJcbiAgICByZXR1cm4gcmV0cnlEZWxheSArIE1hdGgucmFuZG9tKCkgKiAxMDAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcclxuXHJcbnZhciBldmVudHMgPSB7ZXhwb3J0czoge319O1xyXG5cclxudmFyIGhhc1JlcXVpcmVkRXZlbnRzO1xyXG5mdW5jdGlvbiByZXF1aXJlRXZlbnRzKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZEV2ZW50cykgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xyXG4gIGhhc1JlcXVpcmVkRXZlbnRzID0gMTtcclxuICB2YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsO1xyXG4gIHZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nID8gUi5hcHBseSA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XHJcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XHJcbiAgfTtcclxuICB2YXIgUmVmbGVjdE93bktleXM7XHJcbiAgaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XHJcbiAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XHJcbiAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xyXG4gIH1cclxuICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcbiAgICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xyXG4gIH1cclxuICBldmVudHMuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuICBldmVudHMuZXhwb3J0cy5vbmNlID0gb25jZTtcclxuXHJcbiAgLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XHJcbiAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXHJcbiAgLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cclxuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xyXG4gIGZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcclxuICAgIH1cclxuICB9KTtcclxuICBFdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcclxuICAgIH1cclxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXHJcbiAgLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xyXG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xyXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcclxuICAgIH1cclxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG4gIGZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xyXG4gICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XHJcbiAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xyXG4gIH1cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcclxuICAgIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xyXG4gIH07XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG4gICAgdmFyIGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xyXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7ZWxzZSBpZiAoIWRvRXJyb3IpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXHJcbiAgICBpZiAoZG9FcnJvcikge1xyXG4gICAgICB2YXIgZXI7XHJcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcclxuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcclxuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxyXG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxyXG4gICAgICB9XHJcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XHJcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XHJcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcclxuICAgIH1cclxuICAgIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcclxuICAgICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XHJcbiAgICB2YXIgbTtcclxuICAgIHZhciBldmVudHM7XHJcbiAgICB2YXIgZXhpc3Rpbmc7XHJcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xyXG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxyXG4gICAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXHJcbiAgICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcclxuICAgICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XHJcbiAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XHJcbiAgICAgIH1cclxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XHJcbiAgICB9XHJcbiAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cclxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuICAgICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxyXG4gICAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XHJcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxyXG4gICAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcclxuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcclxuICAgICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcclxuICAgICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xyXG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcclxuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICsgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArICdpbmNyZWFzZSBsaW1pdCcpO1xyXG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xyXG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcclxuICAgICAgICB3LnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XHJcbiAgICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG4gIH1cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICB9O1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xyXG4gICAgaWYgKCF0aGlzLmZpcmVkKSB7XHJcbiAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xyXG4gICAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xyXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgZmlyZWQ6IGZhbHNlLFxyXG4gICAgICB3cmFwRm46IHVuZGVmaW5lZCxcclxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxyXG4gICAgfTtcclxuICAgIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XHJcbiAgICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xyXG4gICAgcmV0dXJuIHdyYXBwZWQ7XHJcbiAgfVxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcclxuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xyXG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcclxuICAgIGxpc3QgPSBldmVudHNbdHlwZV07XHJcbiAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcclxuICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xyXG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtlbHNlIHtcclxuICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xyXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBwb3NpdGlvbiA9IC0xO1xyXG4gICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcclxuICAgICAgICAgIHBvc2l0aW9uID0gaTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcclxuICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSBsaXN0LnNoaWZ0KCk7ZWxzZSB7XHJcbiAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XHJcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xyXG4gICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xyXG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xyXG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XHJcbiAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcclxuICAgICAgdmFyIGtleTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XHJcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XHJcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XHJcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIExJRk8gb3JkZXJcclxuICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG4gIGZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcclxuICAgIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcclxuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xyXG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XHJcbiAgICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XHJcbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcclxuICAgIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xyXG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XHJcbiAgfTtcclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XHJcbiAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XHJcbiAgfTtcclxuICBFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcclxuICAgIH1cclxuICB9O1xyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XHJcbiAgZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XHJcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xyXG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xyXG4gICAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XHJcbiAgICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldO1xyXG4gICAgcmV0dXJuIGNvcHk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xyXG4gICAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcclxuICAgIGxpc3QucG9wKCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcclxuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xyXG4gICAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcbiAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xyXG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwge1xyXG4gICAgICAgIG9uY2U6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XHJcbiAgICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwge1xyXG4gICAgICAgICAgb25jZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcclxuICAgIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XHJcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcclxuICAgICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcclxuICAgICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cclxuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcclxuICAgICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXHJcbiAgICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cclxuICAgICAgICBpZiAoZmxhZ3Mub25jZSkge1xyXG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3RlbmVyKGFyZyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xyXG59XHJcblxyXG52YXIgZXZlbnRzRXhwb3J0cyA9IHJlcXVpcmVFdmVudHMoKTtcclxuXHJcbi8qXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXHJcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcclxuICogIHRyZWUuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxuXHJcbmxldCBsb2dEaXNhYmxlZF8gPSB0cnVlO1xyXG5sZXQgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cclxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxyXG4gKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RWZXJzaW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcclxuICBjb25zdCBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xyXG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlRmxvYXQobWF0Y2hbcG9zXSwgMTApO1xyXG59XHJcblxyXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cclxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XHJcbi8vIHRoZSBldmVudCkuXHJcbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcHJvdG8gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xyXG4gIGNvbnN0IG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xyXG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xyXG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XHJcbiAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSBlID0+IHtcclxuICAgICAgY29uc3QgbW9kaWZpZWRFdmVudCA9IHdyYXBwZXIoZSk7XHJcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGNiLmhhbmRsZUV2ZW50KSB7XHJcbiAgICAgICAgICBjYi5oYW5kbGVFdmVudChtb2RpZmllZEV2ZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fZXZlbnRNYXAgPSB0aGlzLl9ldmVudE1hcCB8fCB7fTtcclxuICAgIGlmICghdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xyXG4gICAgICB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zZXQoY2IsIHdyYXBwZWRDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB3cmFwcGVkQ2FsbGJhY2tdKTtcclxuICB9O1xyXG4gIGNvbnN0IG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xyXG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwIHx8ICF0aGlzLl9ldmVudE1hcCB8fCAhdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xyXG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmhhcyhjYikpIHtcclxuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVud3JhcHBlZENiID0gdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5nZXQoY2IpO1xyXG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xyXG4gICAgaWYgKHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2l6ZSA9PT0gMCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXTtcclxuICAgIH1cclxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9ldmVudE1hcCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcDtcclxuICAgIH1cclxuICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsIHVud3JhcHBlZENiXSk7XHJcbiAgfTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcclxuICAgIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xyXG4gICAgfSxcclxuICAgIHNldChjYikge1xyXG4gICAgICBpZiAodGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLCB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYikge1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdID0gY2IpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRpc2FibGVMb2coYm9vbCkge1xyXG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcclxuICB9XHJcbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcclxuICByZXR1cm4gYm9vbCA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDogJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcclxufVxyXG5cclxuLyoqXHJcbiAqIERpc2FibGUgb3IgZW5hYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzXHJcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIGRpc2FibGVXYXJuaW5ncyhib29sKSB7XHJcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcclxuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xyXG4gIH1cclxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xyXG4gIHJldHVybiAnYWRhcHRlci5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyAnICsgKGJvb2wgPyAnZGlzYWJsZWQnIDogJ2VuYWJsZWQnKTtcclxufVxyXG5mdW5jdGlvbiBsb2coKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAobG9nRGlzYWJsZWRfKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkTWV0aG9kLCBuZXdNZXRob2QpIHtcclxuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXHJcbiAqXHJcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxyXG4gKiAgICAgcHJvcGVydGllcy5cclxuICovXHJcbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XHJcbiAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cclxuICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICBicm93c2VyOiBudWxsLFxyXG4gICAgdmVyc2lvbjogbnVsbFxyXG4gIH07XHJcblxyXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8ICF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkge1xyXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgbmF2aWdhdG9yXHJcbiAgfSA9IHdpbmRvdztcclxuXHJcbiAgLy8gUHJlZmVyIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLlxyXG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMpIHtcclxuICAgIGNvbnN0IGNocm9taXVtID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzLmZpbmQoYnJhbmQgPT4ge1xyXG4gICAgICByZXR1cm4gYnJhbmQuYnJhbmQgPT09ICdDaHJvbWl1bSc7XHJcbiAgICB9KTtcclxuICAgIGlmIChjaHJvbWl1bSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGJyb3dzZXI6ICdjaHJvbWUnLFxyXG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50KGNocm9taXVtLnZlcnNpb24sIDEwKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xyXG4gICAgLy8gRmlyZWZveC5cclxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xyXG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpKTtcclxuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHwgd2luZG93LmlzU2VjdXJlQ29udGV4dCA9PT0gZmFsc2UgJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cclxuICAgIC8vIFZlcnNpb24gbWF0Y2hlcyBDaHJvbWUvV2ViUlRDIHZlcnNpb24uXHJcbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXHJcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxyXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnY2hyb21lJztcclxuICAgIHJlc3VsdC52ZXJzaW9uID0gcGFyc2VJbnQoZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpKTtcclxuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XHJcbiAgICAvLyBTYWZhcmkuXHJcbiAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xyXG4gICAgcmVzdWx0LnZlcnNpb24gPSBwYXJzZUludChleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKSk7XHJcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcclxuICAgIC8vIE9ubHkgZm9yIGludGVybmFsIHVzYWdlLlxyXG4gICAgcmVzdWx0Ll9zYWZhcmlWZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL1ZlcnNpb25cXC8oXFxkKyhcXC4/XFxkKykpLywgMSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXHJcbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xyXG4gKiBmcm9tIGEgbmVzdGVkIG9iamVjdCAtLSBhbiBlbmhhbmNlZCBhbmQgdmFuaWxsYSB2ZXJzaW9uXHJcbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3QoZGF0YSkge1xyXG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bXVsYXRvciwga2V5KSB7XHJcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGFba2V5XSk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xyXG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eU9iamVjdCkge1xyXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2N1bXVsYXRvciwge1xyXG4gICAgICBba2V5XTogdmFsdWVcclxuICAgIH0pO1xyXG4gIH0sIHt9KTtcclxufVxyXG5cclxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xyXG5mdW5jdGlvbiB3YWxrU3RhdHMoc3RhdHMsIGJhc2UsIHJlc3VsdFNldCkge1xyXG4gIGlmICghYmFzZSB8fCByZXN1bHRTZXQuaGFzKGJhc2UuaWQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHJlc3VsdFNldC5zZXQoYmFzZS5pZCwgYmFzZSk7XHJcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChuYW1lID0+IHtcclxuICAgIGlmIChuYW1lLmVuZHNXaXRoKCdJZCcpKSB7XHJcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xyXG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xyXG4gICAgICBiYXNlW25hbWVdLmZvckVhY2goaWQgPT4ge1xyXG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXHJcbmZ1bmN0aW9uIGZpbHRlclN0YXRzKHJlc3VsdCwgdHJhY2ssIG91dGJvdW5kKSB7XHJcbiAgY29uc3Qgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XHJcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XHJcbiAgaWYgKHRyYWNrID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XHJcbiAgfVxyXG4gIGNvbnN0IHRyYWNrU3RhdHMgPSBbXTtcclxuICByZXN1bHQuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJiB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XHJcbiAgICAgIHRyYWNrU3RhdHMucHVzaCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgdHJhY2tTdGF0cy5mb3JFYWNoKHRyYWNrU3RhdCA9PiB7XHJcbiAgICByZXN1bHQuZm9yRWFjaChzdGF0cyA9PiB7XHJcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XHJcbiAgICAgICAgd2Fsa1N0YXRzKHJlc3VsdCwgc3RhdHMsIGZpbHRlcmVkUmVzdWx0KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xyXG59XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbmNvbnN0IGxvZ2dpbmcgPSBsb2c7XHJcbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XHJcbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24gKGMpIHtcclxuICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5tYW5kYXRvcnkgfHwgYy5vcHRpb25hbCkge1xyXG4gICAgICByZXR1cm4gYztcclxuICAgIH1cclxuICAgIGNvbnN0IGNjID0ge307XHJcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHIgPSB0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JyA/IGNba2V5XSA6IHtcclxuICAgICAgICBpZGVhbDogY1trZXldXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgb2xkbmFtZV8gPSBmdW5jdGlvbiAocHJlZml4LCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2RldmljZUlkJyA/ICdzb3VyY2VJZCcgOiBuYW1lO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcclxuICAgICAgICBsZXQgb2MgPSB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xyXG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XHJcbiAgICAgICAgICBvYyA9IHt9O1xyXG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcclxuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xyXG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xyXG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2gobWl4ID0+IHtcclxuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XHJcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXyhtaXgsIGtleSldID0gclttaXhdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChjLmFkdmFuY2VkKSB7XHJcbiAgICAgIGNjLm9wdGlvbmFsID0gKGNjLm9wdGlvbmFsIHx8IFtdKS5jb25jYXQoYy5hZHZhbmNlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2M7XHJcbiAgfTtcclxuICBjb25zdCBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBmdW5jKSB7XHJcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MSkge1xyXG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XHJcbiAgICB9XHJcbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcclxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24gKG9iaiwgYSwgYikge1xyXG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xyXG4gICAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xyXG4gICAgICAgICAgZGVsZXRlIG9ialthXTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xyXG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XHJcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdnb29nTm9pc2VTdXBwcmVzc2lvbicpO1xyXG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcclxuICAgIH1cclxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIFNoaW0gZmFjaW5nTW9kZSBmb3IgbW9iaWxlICYgc3VyZmFjZSBwcm8uXHJcbiAgICAgIGxldCBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcclxuICAgICAgZmFjZSA9IGZhY2UgJiYgKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JyA/IGZhY2UgOiB7XHJcbiAgICAgICAgaWRlYWw6IGZhY2VcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xyXG4gICAgICBpZiAoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpICYmICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJiAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XHJcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XHJcbiAgICAgICAgbGV0IG1hdGNoZXM7XHJcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xyXG4gICAgICAgICAgbWF0Y2hlcyA9IFsnYmFjaycsICdyZWFyJ107XHJcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XHJcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cclxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGRldmljZXMgPT4ge1xyXG4gICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XHJcbiAgICAgICAgICAgIGxldCBkZXYgPSBkZXZpY2VzLmZpbmQoZCA9PiBtYXRjaGVzLnNvbWUobWF0Y2ggPT4gZC5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG1hdGNoKSkpO1xyXG4gICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcclxuICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZXYpIHtcclxuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7XHJcbiAgICAgICAgICAgICAgICBleGFjdDogZGV2LmRldmljZUlkXHJcbiAgICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgIGlkZWFsOiBkZXYuZGV2aWNlSWRcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xyXG4gICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XHJcbiAgICB9XHJcbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xyXG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xyXG4gIH07XHJcbiAgY29uc3Qgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NCkge1xyXG4gICAgICByZXR1cm4gZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHtcclxuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxyXG4gICAgICAgIFBlcm1pc3Npb25EaXNtaXNzZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXHJcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxyXG4gICAgICAgIERldmljZXNOb3RGb3VuZEVycm9yOiAnTm90Rm91bmRFcnJvcicsXHJcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InLFxyXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxyXG4gICAgICAgIE1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93bjogJ05vdEFsbG93ZWRFcnJvcicsXHJcbiAgICAgICAgTWVkaWFEZXZpY2VLaWxsU3dpdGNoT246ICdOb3RBbGxvd2VkRXJyb3InLFxyXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxyXG4gICAgICAgIFNjcmVlbkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxyXG4gICAgICAgIERldmljZUNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InXHJcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXHJcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcclxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50IHx8IGUuY29uc3RyYWludE5hbWUsXHJcbiAgICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcbiAgY29uc3QgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBjID0+IHtcclxuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGUgPT4ge1xyXG4gICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcclxuXHJcbiAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxyXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxyXG4gIC8vIGNvbnN0cmFpbnRzLlxyXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xyXG4gICAgY29uc3Qgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XHJcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjcykge1xyXG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcclxuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8IGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xyXG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJycsICdOb3RGb3VuZEVycm9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICAgIH0sIGUgPT4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSkpKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbmZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcclxuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1PblRyYWNrJDEod2luZG93KSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldChmKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcclxuICAgICAgfSxcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5fb250cmFja3BvbHkpIHtcclxuICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IGUgPT4ge1xyXG4gICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcclxuICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxyXG4gICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XHJcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpLmZpbmQociA9PiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRlLnRyYWNrLmlkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcclxuICAgICAgICAgICAgICAgIHRyYWNrOiB0ZS50cmFja1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XHJcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XHJcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xyXG4gICAgICAgICAgICAgIHJlY2VpdmVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcclxuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlY2VpdmVyID0ge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xyXG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xyXG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xyXG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHtcclxuICAgICAgICAgICAgICByZWNlaXZlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gZXZlbiBpZiBSVENSdHBUcmFuc2NlaXZlciBpcyBpbiB3aW5kb3csIGl0IGlzIG9ubHkgdXNlZCBhbmRcclxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxyXG4gICAgLy8gdG8gdW5jb25kaXRpb25hbGx5IHdyYXAgdGhlIGV2ZW50LlxyXG4gICAgd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcclxuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICd0cmFuc2NlaXZlcicsIHtcclxuICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgIHJlY2VpdmVyOiBlLnJlY2VpdmVyXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcclxuICAvLyBPdmVycmlkZXMgYWRkVHJhY2svcmVtb3ZlVHJhY2ssIGRlcGVuZHMgb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2suXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSAmJiAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xyXG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24gKHBjLCB0cmFjaykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRyYWNrLFxyXG4gICAgICAgIGdldCBkdG1mKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcGM6IHBjXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGF1Z21lbnQgYWRkVHJhY2sgd2hlbiBnZXRTZW5kZXJzIGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycykge1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kZXJzLnNsaWNlKCk7IC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLlxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xyXG4gICAgICAgIGxldCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAoIXNlbmRlcikge1xyXG4gICAgICAgICAgc2VuZGVyID0gc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKTtcclxuICAgICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzZW5kZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VuZGVyO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XHJcbiAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xyXG4gICAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcclxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xyXG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcclxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuX3NlbmRlcnMuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcclxuICAgICAgICBpZiAoc2VuZGVyKSB7XHJcbiAgICAgICAgICAvLyByZW1vdmUgc2VuZGVyXHJcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcclxuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcclxuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcclxuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XHJcbiAgICAgIHJldHVybiBzZW5kZXJzO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgd2luZG93LlJUQ1J0cFJlY2VpdmVyKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXHJcbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcclxuICAgIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xyXG4gICAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XHJcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcclxuICAgICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcclxuICAgICAgICByZXR1cm4gc2VuZGVycztcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XHJcbiAgICBpZiAob3JpZ0FkZFRyYWNrKSB7XHJcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcclxuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICBzZW5kZXIuX3BjID0gdGhpcztcclxuICAgICAgICByZXR1cm4gc2VuZGVyO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcclxuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcclxuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cclxuICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxyXG4gICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xyXG4gICAgICAgKiAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSB0aGUgUlRDUnRwU2VuZGVyLlxyXG4gICAgICAgKi9cclxuICAgICAgZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBzaGltIHJlY2VpdmVyIHN0YXRzLlxyXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcclxuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcclxuICAgIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XHJcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xyXG4gICAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xyXG4gICAgICAgIHJldHVybiByZWNlaXZlcnM7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xyXG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcclxuICAgICAgcmV0dXJuIGU7XHJcbiAgICB9KTtcclxuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcclxuICAgICAgY29uc3QgcmVjZWl2ZXIgPSB0aGlzO1xyXG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKHJlc3VsdCA9PiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cclxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xyXG4gICAgICBjb25zdCB0cmFjayA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgbGV0IHNlbmRlcjtcclxuICAgICAgbGV0IHJlY2VpdmVyO1xyXG4gICAgICBsZXQgZXJyO1xyXG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHMgPT4ge1xyXG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xyXG4gICAgICAgICAgaWYgKHNlbmRlcikge1xyXG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2VuZGVyID0gcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2gociA9PiB7XHJcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XHJcbiAgICAgICAgICBpZiAocmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY2VpdmVyID0gcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHIudHJhY2sgPT09IHRyYWNrO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGVyciB8fCBzZW5kZXIgJiYgcmVjZWl2ZXIpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcclxuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcclxuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIpIHtcclxuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignVGhlcmUgaXMgbm8gc2VuZGVyIG9yIHJlY2VpdmVyIGZvciB0aGUgdHJhY2suJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcclxuICAvLyBzaGltIGFkZFRyYWNrL3JlbW92ZVRyYWNrIHdpdGggbmF0aXZlIHZhcmlhbnRzIGluIG9yZGVyIHRvIG1ha2VcclxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXHJcbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xyXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcclxuICB9O1xyXG4gIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcclxuICAgIGlmICghc3RyZWFtKSB7XHJcbiAgICAgIHJldHVybiBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xyXG4gICAgY29uc3Qgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xyXG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtLCBzZW5kZXJdO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0uaW5kZXhPZihzZW5kZXIpID09PSAtMSkge1xyXG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbmRlcjtcclxuICB9O1xyXG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcclxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xyXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcclxuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3QgZXhpc3RpbmdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCk7XHJcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBjb25zdCBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XHJcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtXS5jb25jYXQobmV3U2VuZGVycyk7XHJcbiAgfTtcclxuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcclxuICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XHJcbiAgICByZXR1cm4gb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbiAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XHJcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcclxuICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykuZm9yRWFjaChzdHJlYW1JZCA9PiB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xyXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXHJcbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NSkge1xyXG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xyXG4gIH1cclxuXHJcbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcclxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXHJcbiAgY29uc3Qgb3JpZ0dldExvY2FsU3RyZWFtcyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xyXG4gICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XHJcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xyXG4gICAgcmV0dXJuIG5hdGl2ZVN0cmVhbXMubWFwKHN0cmVhbSA9PiB0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcclxuICB9O1xyXG4gIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcclxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xyXG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcclxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XHJcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxyXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXHJcbiAgICBpZiAoIXRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pIHtcclxuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xyXG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XHJcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XHJcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcclxuICAgIH1cclxuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xyXG4gIH07XHJcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xyXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XHJcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xyXG4gICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdIHx8IHN0cmVhbV0pO1xyXG4gICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZF07XHJcbiAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xyXG4gIH07XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcclxuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggIT09IDEgfHwgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZCh0ID0+IHQgPT09IHRyYWNrKSkge1xyXG4gICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XHJcbiAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxyXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgKyAnIHN0cmVhbSB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0cmFjay4nLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xyXG4gICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XHJcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xyXG4gICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xyXG4gICAgaWYgKG9sZFN0cmVhbSkge1xyXG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxyXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxyXG4gICAgICAvLyBOb3RlOiB3ZSByZWx5IG9uIHRoZSBoaWdoLWxldmVsIGFkZFRyYWNrL2R0bWYgc2hpbSB0b1xyXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXHJcbiAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XHJcblxyXG4gICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShbdHJhY2tdKTtcclxuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xyXG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xyXG4gICAgICB0aGlzLmFkZFN0cmVhbShuZXdTdHJlYW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XHJcbiAgfTtcclxuXHJcbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcclxuICAvLyB2aWNlIHZlcnNhLlxyXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xyXG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcclxuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcclxuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XHJcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xyXG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGludGVybmFsU3RyZWFtLmlkLCAnZycpLCBleHRlcm5hbFN0cmVhbS5pZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcclxuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcclxuICAgICAgc2RwXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xyXG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xyXG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcclxuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XHJcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoZXh0ZXJuYWxTdHJlYW0uaWQsICdnJyksIGludGVybmFsU3RyZWFtLmlkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xyXG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxyXG4gICAgICBzZHBcclxuICAgIH0pO1xyXG4gIH1cclxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xyXG4gICAgY29uc3QgbWV0aG9kT2JqID0ge1xyXG4gICAgICBbbWV0aG9kXSgpIHtcclxuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIGNvbnN0IGlzTGVnYWN5Q2FsbCA9IGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc2MgPSByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcclxuICAgICAgICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhcmdzWzFdKSB7XHJcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCBhcmd1bWVudHNbMl1dKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xyXG4gIH0pO1xyXG4gIGNvbnN0IG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgIWFyZ3VtZW50c1swXS50eXBlKSB7XHJcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgYXJndW1lbnRzWzBdID0gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQodGhpcywgYXJndW1lbnRzWzBdKTtcclxuICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcblxyXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxyXG5cclxuICBjb25zdCBvcmlnTG9jYWxEZXNjcmlwdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xyXG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcclxuICAgIH1cclxuICB9KTtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XHJcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXHJcbiAgICAvLyBzaW5jZSB3ZSBzaGltIFJUUFNlbmRlci4gU28gd2UgY2hlY2sgaWYgc2VuZGVyLl9wYyBpcyBzZXQuXHJcbiAgICBpZiAoIXNlbmRlci5fcGMpIHtcclxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICsgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzTG9jYWwgPSBzZW5kZXIuX3BjID09PSB0aGlzO1xyXG4gICAgaWYgKCFpc0xvY2FsKSB7XHJcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbmRlciB3YXMgbm90IGNyZWF0ZWQgYnkgdGhpcyBjb25uZWN0aW9uLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuYXRpdmUgc3RyZWFtIHRoZSBzZW5kZXJzIHRyYWNrIGJlbG9uZ3MgdG8uXHJcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcclxuICAgIGxldCBzdHJlYW07XHJcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHJlYW1zKS5mb3JFYWNoKHN0cmVhbWlkID0+IHtcclxuICAgICAgY29uc3QgaGFzVHJhY2sgPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXS5nZXRUcmFja3MoKS5maW5kKHRyYWNrID0+IHNlbmRlci50cmFjayA9PT0gdHJhY2spO1xyXG4gICAgICBpZiAoaGFzVHJhY2spIHtcclxuICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbWlkXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3RyZWFtKSB7XHJcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xyXG4gICAgICAgIC8vIHRha2VzIGNhcmUgb2YgYW55IHNoaW1tZWQgX3NlbmRlcnMuXHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgc2FtZSBvZGQgY2hyb21lIGJlaGF2aW91ciBhcyBhYm92ZS5cclxuICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcclxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xyXG4gIH1cclxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXHJcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xyXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XHJcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcclxuICAgICAgICBbbWV0aG9kXSgpIHtcclxuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEF0dGVtcHQgdG8gZml4IE9OTiBpbiBwbGFuLWIgbW9kZS5cclxuZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ25lZ290aWF0aW9ubmVlZGVkJywgZSA9PiB7XHJcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCBwYy5nZXRDb25maWd1cmF0aW9uICYmIHBjLmdldENvbmZpZ3VyYXRpb24oKS5zZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XHJcbiAgICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG52YXIgY2hyb21lU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgZml4TmVnb3RpYXRpb25OZWVkZWQ6IGZpeE5lZ290aWF0aW9uTmVlZGVkLFxyXG4gIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayxcclxuICBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmU6IHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSxcclxuICBzaGltR2V0U2VuZGVyc1dpdGhEdG1mOiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mLFxyXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEkMixcclxuICBzaGltTWVkaWFTdHJlYW06IHNoaW1NZWRpYVN0cmVhbSxcclxuICBzaGltT25UcmFjazogc2hpbU9uVHJhY2skMSxcclxuICBzaGltUGVlckNvbm5lY3Rpb246IHNoaW1QZWVyQ29ubmVjdGlvbiQxLFxyXG4gIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzOiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0c1xyXG59KTtcclxuXHJcbi8qXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXHJcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcclxuICogIHRyZWUuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcclxuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcclxuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xyXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXHJcbiAgICBkZXByZWNhdGVkKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhJywgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XHJcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gIH07XHJcbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcclxuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24gKG9iaiwgYSwgYikge1xyXG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcclxuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XHJcbiAgICAgICAgZGVsZXRlIG9ialthXTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG5hdGl2ZUdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XHJcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGMuYXVkaW8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xyXG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XHJcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuYXRpdmVHZXRVc2VyTWVkaWEoYyk7XHJcbiAgICB9O1xyXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcclxuICAgICAgY29uc3QgbmF0aXZlR2V0U2V0dGluZ3MgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncztcclxuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICByZW1hcChvYmosICdtb3pBdXRvR2FpbkNvbnRyb2wnLCAnYXV0b0dhaW5Db250cm9sJyk7XHJcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMpIHtcclxuICAgICAgY29uc3QgbmF0aXZlQXBwbHlDb25zdHJhaW50cyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHM7XHJcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XHJcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xyXG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXHJcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcclxuICogIHRyZWUuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxuXHJcbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xyXG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xyXG4gICAgaWYgKCEoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8pKSB7XHJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XHJcbiAgICAgIGVyci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xyXG4gICAgICAvLyBmcm9tIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1ET01FeGNlcHRpb24tZXJyb3ItbmFtZXNcclxuICAgICAgZXJyLmNvZGUgPSA4O1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xyXG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcclxuICAgICAgICBtZWRpYVNvdXJjZTogcHJlZmVycmVkTWVkaWFTb3VyY2VcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1lZGlhU291cmNlID0gcHJlZmVycmVkTWVkaWFTb3VyY2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcclxuICB9O1xyXG59XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuLyogZXNsaW50LWVudiBub2RlICovXHJcbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcclxuICAgIHJldHVybjsgLy8gcHJvYmFibHkgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZD1mYWxzZSBpbiBhYm91dDpjb25maWdcclxuICB9XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcclxuICB9XHJcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xyXG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXHJcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcclxuICAgICAgY29uc3QgbWV0aG9kT2JqID0ge1xyXG4gICAgICAgIFttZXRob2RdKCkge1xyXG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjb25zdCBtb2Rlcm5TdGF0c1R5cGVzID0ge1xyXG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcclxuICAgIG91dGJvdW5kcnRwOiAnb3V0Ym91bmQtcnRwJyxcclxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXHJcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXHJcbiAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xyXG4gIH07XHJcbiAgY29uc3QgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcclxuICAgIGNvbnN0IFtzZWxlY3Rvciwgb25TdWNjLCBvbkVycl0gPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKS50aGVuKHN0YXRzID0+IHtcclxuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XHJcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xyXG4gICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XHJcbiAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcclxuICAgICAgICAgIHN0YXRzLmZvckVhY2goKHN0YXQsIGkpID0+IHtcclxuICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcclxuICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3RhdHM7XHJcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdykge1xyXG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xyXG4gIGlmIChvcmlnR2V0U2VuZGVycykge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcclxuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcclxuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XHJcbiAgICAgIHJldHVybiBzZW5kZXJzO1xyXG4gICAgfTtcclxuICB9XHJcbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcclxuICBpZiAob3JpZ0FkZFRyYWNrKSB7XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XHJcbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcclxuICAgICAgcmV0dXJuIHNlbmRlcjtcclxuICAgIH07XHJcbiAgfVxyXG4gIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFjayA/IHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spIDogUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcclxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcclxuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XHJcbiAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xyXG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcclxuICAgICAgcmV0dXJuIHJlY2VpdmVycztcclxuICAgIH07XHJcbiAgfVxyXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XHJcbiAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcclxuICAgIHJldHVybiBlO1xyXG4gIH0pO1xyXG4gIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcclxuICAgIGRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xyXG4gICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzZW5kZXIgPT4ge1xyXG4gICAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHN0cmVhbS5nZXRUcmFja3MoKS5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVUcmFjayhzZW5kZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcclxuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE3Mzg1MVxyXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xyXG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XHJcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xyXG4gIGlmIChvcmlnQWRkVHJhbnNjZWl2ZXIpIHtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiBhZGRUcmFuc2NlaXZlcigpIHtcclxuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcclxuICAgICAgLy8gV2ViSURMIGlucHV0IGNvZXJjaW9uIGFuZCB2YWxpZGF0aW9uXHJcbiAgICAgIGxldCBzZW5kRW5jb2RpbmdzID0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zZW5kRW5jb2RpbmdzO1xyXG4gICAgICBpZiAoc2VuZEVuY29kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2VuZEVuY29kaW5ncyA9IFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbmRFbmNvZGluZ3MgPSBbLi4uc2VuZEVuY29kaW5nc107XHJcbiAgICAgIGNvbnN0IHNob3VsZFBlcmZvcm1DaGVjayA9IHNlbmRFbmNvZGluZ3MubGVuZ3RoID4gMDtcclxuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xyXG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxyXG4gICAgICAgIHNlbmRFbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZ1BhcmFtID0+IHtcclxuICAgICAgICAgIGlmICgncmlkJyBpbiBlbmNvZGluZ1BhcmFtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcclxuICAgICAgICAgICAgaWYgKCFyaWRSZWdleC50ZXN0KGVuY29kaW5nUGFyYW0ucmlkKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgUklEIHZhbHVlIHByb3ZpZGVkLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJ3NjYWxlUmVzb2x1dGlvbkRvd25CeScgaW4gZW5jb2RpbmdQYXJhbSkge1xyXG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieSBtdXN0IGJlID49IDEuMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoJ21heEZyYW1lcmF0ZScgaW4gZW5jb2RpbmdQYXJhbSkge1xyXG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0ubWF4RnJhbWVyYXRlKSA+PSAwKSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluaXQgb3B0aW9ucyB3ZXJlIGFwcGxpZWQuIElmIG5vdCB3ZSBkbyB0aGlzIGluIGFuXHJcbiAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gdWdseSBoYWNrLCBidXQgYXQgdGhlIHNhbWUgdGltZSBpcyB3YXkgbW9yZSByb2J1c3QgdGhhblxyXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzZW5kZXIgcGFyYW1ldGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjcmVhdGVPZmZlclxyXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XHJcbiAgICAgICAgLy8gdGhlIHBhcmFtcyB3ZXJlIGFzeW5jaHJvbm91c2x5IGFwcGxpZWQgc28gd2UgbWlnaHQgbWlzcyB0aGVcclxuICAgICAgICAvLyBvcHBvcnR1bml0eSB0byByZWNyZWF0ZSBvZmZlci5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBzZW5kZXJcclxuICAgICAgICB9ID0gdHJhbnNjZWl2ZXI7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcclxuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XHJcbiAgICAgICAgLy8gQXZvaWQgYmVpbmcgZm9vbGVkIGJ5IHBhdGNoZWQgZ2V0UGFyYW1ldGVycygpIGJlbG93LlxyXG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID09PSAxICYmIE9iamVjdC5rZXlzKHBhcmFtcy5lbmNvZGluZ3NbMF0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XHJcbiAgICAgICAgICBzZW5kZXIuc2VuZEVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XHJcbiAgICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5wdXNoKHNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcclxuICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcclxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnR2V0UGFyYW1ldGVycyA9IHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFBhcmFtZXRlcnM7XHJcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XHJcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gZ2V0UGFyYW1ldGVycygpIHtcclxuICAgICAgY29uc3QgcGFyYW1zID0gb3JpZ0dldFBhcmFtZXRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xyXG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbXS5jb25jYXQodGhpcy5zZW5kRW5jb2RpbmdzIHx8IFt7fV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XHJcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XHJcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcigpIHtcclxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcclxuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcclxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcigpIHtcclxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxudmFyIGZpcmVmb3hTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBzaGltQWRkVHJhbnNjZWl2ZXI6IHNoaW1BZGRUcmFuc2NlaXZlcixcclxuICBzaGltQ3JlYXRlQW5zd2VyOiBzaGltQ3JlYXRlQW5zd2VyLFxyXG4gIHNoaW1DcmVhdGVPZmZlcjogc2hpbUNyZWF0ZU9mZmVyLFxyXG4gIHNoaW1HZXREaXNwbGF5TWVkaWE6IHNoaW1HZXREaXNwbGF5TWVkaWEsXHJcbiAgc2hpbUdldFBhcmFtZXRlcnM6IHNoaW1HZXRQYXJhbWV0ZXJzLFxyXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEkMSxcclxuICBzaGltT25UcmFjazogc2hpbU9uVHJhY2ssXHJcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24sXHJcbiAgc2hpbVJUQ0RhdGFDaGFubmVsOiBzaGltUlRDRGF0YUNoYW5uZWwsXHJcbiAgc2hpbVJlY2VpdmVyR2V0U3RhdHM6IHNoaW1SZWNlaXZlckdldFN0YXRzLFxyXG4gIHNoaW1SZW1vdmVTdHJlYW06IHNoaW1SZW1vdmVTdHJlYW0sXHJcbiAgc2hpbVNlbmRlckdldFN0YXRzOiBzaGltU2VuZGVyR2V0U3RhdHNcclxufSk7XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XHJcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RyZWFtcztcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICghKCdhZGRTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICBjb25zdCBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cclxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cclxuICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgc3RyZWFtKSk7XHJcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xyXG4gICAgfTtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xyXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgICAgc3RyZWFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0cmVhbXMpIHtcclxuICAgICAgICBzdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcclxuICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xyXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XHJcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goc2VuZGVyID0+IHtcclxuICAgICAgICBpZiAodHJhY2tzLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbiBnZXRSZW1vdGVTdHJlYW1zKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb25hZGRzdHJlYW0nLCB7XHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldChmKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtKTtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29uYWRkc3RyZWFtID0gZik7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGUgPT4ge1xyXG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW1vdGVTdHJlYW1zKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdGVTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcclxuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcclxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcclxuICAgICAgY29uc3QgcGMgPSB0aGlzO1xyXG4gICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xyXG4gICAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xyXG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseShwYywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSBwcm90b3R5cGUuY3JlYXRlT2ZmZXI7XHJcbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XHJcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xyXG4gIGNvbnN0IHNldFJlbW90ZURlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xyXG4gIGNvbnN0IGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XHJcbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XHJcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XHJcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfTtcclxuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcclxuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9O1xyXG4gIGxldCB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBwcm9taXNlID0gc2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcclxuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9O1xyXG4gIHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xyXG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBzZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcclxuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICB9O1xyXG4gIHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcclxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgY29uc3QgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XHJcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfTtcclxuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XHJcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XHJcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcclxuICAgIC8vIHNoaW0gbm90IG5lZWRlZCBpbiBTYWZhcmkgMTIuMVxyXG4gICAgY29uc3QgbWVkaWFEZXZpY2VzID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcclxuICAgIGNvbnN0IF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcclxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gY29uc3RyYWludHMgPT4ge1xyXG4gICAgICByZXR1cm4gX2dldFVzZXJNZWRpYShzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XHJcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcclxuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4oY2IsIGVycmNiKTtcclxuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcclxuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbnN0cmFpbnRzLCB7XHJcbiAgICAgIHZpZGVvOiBjb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBjb25zdHJhaW50cztcclxufVxyXG5mdW5jdGlvbiBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpIHtcclxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xyXG4gIGNvbnN0IE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbiBSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xyXG4gICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcclxuICAgICAgY29uc3QgbmV3SWNlU2VydmVycyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBjQ29uZmlnLmljZVNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcclxuICAgICAgICBpZiAoc2VydmVyLnVybHMgPT09IHVuZGVmaW5lZCAmJiBzZXJ2ZXIudXJsKSB7XHJcbiAgICAgICAgICBkZXByZWNhdGVkKCdSVENJY2VTZXJ2ZXIudXJsJywgJ1JUQ0ljZVNlcnZlci51cmxzJyk7XHJcbiAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xyXG4gICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xyXG4gICAgICAgICAgZGVsZXRlIHNlcnZlci51cmw7XHJcbiAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcclxuICB9O1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBPcmlnUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xyXG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXHJcbiAgaWYgKCdnZW5lcmF0ZUNlcnRpZmljYXRlJyBpbiBPcmlnUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9yaWdQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcclxuICAvLyBBZGQgZXZlbnQudHJhbnNjZWl2ZXIgbWVtYmVyIG92ZXIgZGVwcmVjYXRlZCBldmVudC5yZWNlaXZlclxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcclxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihvZmZlck9wdGlvbnMpIHtcclxuICAgIGlmIChvZmZlck9wdGlvbnMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcclxuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAnYXVkaW8nKTtcclxuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XHJcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xyXG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJiAhYXVkaW9UcmFuc2NlaXZlcikge1xyXG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xyXG4gICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcclxuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nKTtcclxuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XHJcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xyXG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJiAhdmlkZW9UcmFuc2NlaXZlcikge1xyXG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywge1xyXG4gICAgICAgICAgZGlyZWN0aW9uOiAncmVjdm9ubHknXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1BdWRpb0NvbnRleHQod2luZG93KSB7XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8IHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XHJcbn1cclxuXHJcbnZhciBzYWZhcmlTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG4gIF9fcHJvdG9fXzogbnVsbCxcclxuICBzaGltQXVkaW9Db250ZXh0OiBzaGltQXVkaW9Db250ZXh0LFxyXG4gIHNoaW1DYWxsYmFja3NBUEk6IHNoaW1DYWxsYmFja3NBUEksXHJcbiAgc2hpbUNvbnN0cmFpbnRzOiBzaGltQ29uc3RyYWludHMsXHJcbiAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5OiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3ksXHJcbiAgc2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSxcclxuICBzaGltTG9jYWxTdHJlYW1zQVBJOiBzaGltTG9jYWxTdHJlYW1zQVBJLFxyXG4gIHNoaW1SVENJY2VTZXJ2ZXJVcmxzOiBzaGltUlRDSWNlU2VydmVyVXJscyxcclxuICBzaGltUmVtb3RlU3RyZWFtc0FQSTogc2hpbVJlbW90ZVN0cmVhbXNBUEksXHJcbiAgc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcjogc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlclxyXG59KTtcclxuXHJcbnZhciBzZHAkMSA9IHtleHBvcnRzOiB7fX07XHJcblxyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxudmFyIGhhc1JlcXVpcmVkU2RwO1xyXG5mdW5jdGlvbiByZXF1aXJlU2RwKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZFNkcCkgcmV0dXJuIHNkcCQxLmV4cG9ydHM7XHJcbiAgaGFzUmVxdWlyZWRTZHAgPSAxO1xyXG4gIChmdW5jdGlvbiAobW9kdWxlKSB7XHJcblxyXG4gICAgLy8gU0RQIGhlbHBlcnMuXHJcbiAgICBjb25zdCBTRFBVdGlscyA9IHt9O1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxyXG4gICAgLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcclxuICAgIFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxyXG4gICAgU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xyXG5cclxuICAgIC8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXHJcbiAgICBTRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXHJcbiAgICBTRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xyXG4gICAgICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbicpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uLlxyXG4gICAgU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoYmxvYikge1xyXG4gICAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XHJcbiAgICAgIHJldHVybiBzZWN0aW9ucyAmJiBzZWN0aW9uc1swXTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cclxuICAgIFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xyXG4gICAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XHJcbiAgICAgIHNlY3Rpb25zLnNoaWZ0KCk7XHJcbiAgICAgIHJldHVybiBzZWN0aW9ucztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cclxuICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24gKGJsb2IsIHByZWZpeCkge1xyXG4gICAgICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxyXG4gICAgLy8gcnBvcnQgNTU5OTZcIlxyXG4gICAgLy8gSW5wdXQgY2FuIGJlIHByZWZpeGVkIHdpdGggYT0uXHJcbiAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIGxldCBwYXJ0cztcclxuICAgICAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cclxuICAgICAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcclxuICAgICAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2FuZGlkYXRlID0ge1xyXG4gICAgICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxyXG4gICAgICAgIGNvbXBvbmVudDoge1xyXG4gICAgICAgICAgMTogJ3J0cCcsXHJcbiAgICAgICAgICAyOiAncnRjcCdcclxuICAgICAgICB9W3BhcnRzWzFdXSB8fCBwYXJ0c1sxXSxcclxuICAgICAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcclxuICAgICAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcclxuICAgICAgICBpcDogcGFydHNbNF0sXHJcbiAgICAgICAgYWRkcmVzczogcGFydHNbNF0sXHJcbiAgICAgICAgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXHJcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbNV0sIDEwKSxcclxuICAgICAgICAvLyBza2lwIHBhcnRzWzZdID09ICd0eXAnXHJcbiAgICAgICAgdHlwZTogcGFydHNbN11cclxuICAgICAgfTtcclxuICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHN3aXRjaCAocGFydHNbaV0pIHtcclxuICAgICAgICAgIGNhc2UgJ3JhZGRyJzpcclxuICAgICAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3Jwb3J0JzpcclxuICAgICAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGNwdHlwZSc6XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3VmcmFnJzpcclxuICAgICAgICAgICAgY2FuZGlkYXRlLnVmcmFnID0gcGFydHNbaSArIDFdOyAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICAgICAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnLiBEb24ndCBvdmVyd3JpdGUuXHJcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGVbcGFydHNbaV1dID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxyXG4gICAgLy8gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBhPSBwcmVmaXghXHJcbiAgICBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcclxuICAgICAgY29uc3Qgc2RwID0gW107XHJcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcclxuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcclxuICAgICAgaWYgKGNvbXBvbmVudCA9PT0gJ3J0cCcpIHtcclxuICAgICAgICBzZHAucHVzaCgxKTtcclxuICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xyXG4gICAgICAgIHNkcC5wdXNoKDIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnByb3RvY29sLnRvVXBwZXJDYXNlKCkpO1xyXG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xyXG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUuYWRkcmVzcyB8fCBjYW5kaWRhdGUuaXApO1xyXG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucG9ydCk7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcclxuICAgICAgc2RwLnB1c2goJ3R5cCcpO1xyXG4gICAgICBzZHAucHVzaCh0eXBlKTtcclxuICAgICAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiYgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XHJcbiAgICAgICAgc2RwLnB1c2goJ3JhZGRyJyk7XHJcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcclxuICAgICAgICBzZHAucHVzaCgncnBvcnQnKTtcclxuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcclxuICAgICAgICBzZHAucHVzaCgndGNwdHlwZScpO1xyXG4gICAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XHJcbiAgICAgICAgc2RwLnB1c2goJ3VmcmFnJyk7XHJcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXHJcbiAgICAvLyBTYW1wbGUgaW5wdXQ6XHJcbiAgICAvLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcclxuICAgIFNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIGEgcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxyXG4gICAgLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxyXG4gICAgU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xyXG4gICAgICBjb25zdCBwYXJzZWQgPSB7XHJcbiAgICAgICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSAvLyB3YXM6IGlkXHJcbiAgICAgIH07XHJcbiAgICAgIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcclxuICAgICAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcclxuICAgICAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXHJcbiAgICAgIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xyXG4gICAgICAvLyBsZWdhY3kgYWxpYXMsIGdvdCByZW5hbWVkIGJhY2sgdG8gY2hhbm5lbHMgaW4gT1JUQy5cclxuICAgICAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xyXG4gICAgICByZXR1cm4gcGFyc2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZXMgYSBydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxyXG4gICAgLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxyXG4gICAgU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbiAoY29kZWMpIHtcclxuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XHJcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XHJcbiAgICAgIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhIGV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxyXG4gICAgLy8gYT1leHRtYXA6Mi9zZW5kb25seSB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XHJcbiAgICBTRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcclxuICAgICAgICBkaXJlY3Rpb246IHBhcnRzWzBdLmluZGV4T2YoJy8nKSA+IDAgPyBwYXJ0c1swXS5zcGxpdCgnLycpWzFdIDogJ3NlbmRyZWN2JyxcclxuICAgICAgICB1cmk6IHBhcnRzWzFdLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXHJcbiAgICAvLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXHJcbiAgICBTRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uIChoZWFkZXJFeHRlbnNpb24pIHtcclxuICAgICAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICsgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gOiAnJykgKyAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgKGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzID8gJyAnICsgaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgOiAnJykgKyAnXFxyXFxuJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIGEgZm10cCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcclxuICAgIC8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXHJcbiAgICAvLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cclxuICAgIFNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uIChsaW5lKSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xyXG4gICAgICBsZXQga3Y7XHJcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcclxuICAgICAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbiAoY29kZWMpIHtcclxuICAgICAgbGV0IGxpbmUgPSAnJztcclxuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XHJcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgICAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcclxuICAgICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxyXG4gICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxyXG4gICAgU0RQVXRpbHMucGFyc2VSdGNwRmIgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxyXG4gICAgICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uIChjb2RlYykge1xyXG4gICAgICBsZXQgbGluZXMgPSAnJztcclxuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XHJcbiAgICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcclxuICAgICAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cclxuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmYiA9PiB7XHJcbiAgICAgICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgKyAoZmIucGFyYW1ldGVyICYmIGZiLnBhcmFtZXRlci5sZW5ndGggPyAnICcgKyBmYi5wYXJhbWV0ZXIgOiAnJykgKyAnXFxyXFxuJztcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbGluZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBhIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XHJcbiAgICAvLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcclxuICAgIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgY29uc3Qgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcclxuICAgICAgY29uc3QgcGFydHMgPSB7XHJcbiAgICAgICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHJpbmcoNywgc3ApLCAxMClcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XHJcbiAgICAgIGlmIChjb2xvbiA+IC0xKSB7XHJcbiAgICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxLCBjb2xvbik7XHJcbiAgICAgICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyaW5nKHNwICsgMSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxyXG4gICAgLy8gYT1zc3JjLWdyb3VwOnNlbWFudGljcyAxMiAzNFxyXG4gICAgU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEzKS5zcGxpdCgnICcpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcclxuICAgICAgICBzc3JjczogcGFydHMubWFwKHNzcmMgPT4gcGFyc2VJbnQoc3NyYywgMTApKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXHJcbiAgICAvLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cclxuICAgIFNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XHJcbiAgICAgIGlmIChtaWQpIHtcclxuICAgICAgICByZXR1cm4gbWlkLnN1YnN0cmluZyg2KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgYSBmaW5nZXJwcmludCBsaW5lIGZvciBEVExTLVNSVFAuXHJcbiAgICBTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXHJcbiAgICAgICAgdmFsdWU6IHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkgLy8gdGhlIGRlZmluaXRpb24gaXMgdXBwZXItY2FzZSBpbiBSRkMgNDU3Mi5cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXHJcbiAgICAvLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcclxuICAgIC8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxyXG4gICAgU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xyXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1maW5nZXJwcmludDonKTtcclxuICAgICAgLy8gTm90ZTogYT1zZXR1cCBsaW5lIGlzIGlnbm9yZWQgc2luY2Ugd2UgdXNlIHRoZSAnYXV0bycgcm9sZSBpbiBFZGdlLlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJvbGU6ICdhdXRvJyxcclxuICAgICAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXHJcbiAgICBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcywgc2V0dXBUeXBlKSB7XHJcbiAgICAgIGxldCBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XHJcbiAgICAgIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XHJcbiAgICAgICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHNkcDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cclxuICAgIC8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXHJcbiAgICBTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFnOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxyXG4gICAgICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcclxuICAgICAgICBrZXlQYXJhbXM6IHBhcnRzWzJdLFxyXG4gICAgICAgIHNlc3Npb25QYXJhbXM6IHBhcnRzLnNsaWNlKDMpXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU0RQVXRpbHMud3JpdGVDcnlwdG9MaW5lID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICAgICAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgKyBwYXJhbWV0ZXJzLmNyeXB0b1N1aXRlICsgJyAnICsgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCcgPyBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyhwYXJhbWV0ZXJzLmtleVBhcmFtcykgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgKyAocGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zID8gJyAnICsgcGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zLmpvaW4oJyAnKSA6ICcnKSArICdcXHJcXG4nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXHJcbiAgICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxyXG4gICAgU0RQVXRpbHMucGFyc2VDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbiAoa2V5UGFyYW1zKSB7XHJcbiAgICAgIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyaW5nKDcpLnNwbGl0KCd8Jyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAga2V5TWV0aG9kOiAnaW5saW5lJyxcclxuICAgICAgICBrZXlTYWx0OiBwYXJ0c1swXSxcclxuICAgICAgICBsaWZlVGltZTogcGFydHNbMV0sXHJcbiAgICAgICAgbWtpVmFsdWU6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVswXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xyXG4gICAgICByZXR1cm4ga2V5UGFyYW1zLmtleU1ldGhvZCArICc6JyArIGtleVBhcmFtcy5rZXlTYWx0ICsgKGtleVBhcmFtcy5saWZlVGltZSA/ICd8JyArIGtleVBhcmFtcy5saWZlVGltZSA6ICcnKSArIChrZXlQYXJhbXMubWtpVmFsdWUgJiYga2V5UGFyYW1zLm1raUxlbmd0aCA/ICd8JyArIGtleVBhcmFtcy5ta2lWYWx1ZSArICc6JyArIGtleVBhcmFtcy5ta2lMZW5ndGggOiAnJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4dHJhY3RzIGFsbCBTREVTIHBhcmFtZXRlcnMuXHJcbiAgICBTRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9Y3J5cHRvOicpO1xyXG4gICAgICByZXR1cm4gbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cclxuICAgIC8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxyXG4gICAgLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cclxuICAgIFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xyXG4gICAgICBjb25zdCB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtdWZyYWc6JylbMF07XHJcbiAgICAgIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtcHdkOicpWzBdO1xyXG4gICAgICBpZiAoISh1ZnJhZyAmJiBwd2QpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxyXG4gICAgICAgIHBhc3N3b3JkOiBwd2Quc3Vic3RyaW5nKDEwKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTZXJpYWxpemVzIElDRSBwYXJhbWV0ZXJzIHRvIFNEUC5cclxuICAgIFNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xyXG4gICAgICBpZiAocGFyYW1zLmljZUxpdGUpIHtcclxuICAgICAgICBzZHAgKz0gJ2E9aWNlLWxpdGVcXHJcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZHA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cclxuICAgIFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XHJcbiAgICAgICAgY29kZWNzOiBbXSxcclxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcclxuICAgICAgICBmZWNNZWNoYW5pc21zOiBbXSxcclxuICAgICAgICBydGNwOiBbXVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcclxuICAgICAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xyXG4gICAgICBkZXNjcmlwdGlvbi5wcm9maWxlID0gbWxpbmVbMl07XHJcbiAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyBmaW5kIGFsbCBjb2RlY3MgZnJvbSBtbGluZVszLi5dXHJcbiAgICAgICAgY29uc3QgcHQgPSBtbGluZVtpXTtcclxuICAgICAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcclxuICAgICAgICBpZiAocnRwbWFwbGluZSkge1xyXG4gICAgICAgICAgY29uc3QgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcclxuICAgICAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XHJcbiAgICAgICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxyXG4gICAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcclxuICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XHJcbiAgICAgICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cclxuICAgICAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1VMUEZFQyc6XHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2gobGluZSA9PiB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHdpbGRjYXJkUnRjcEZiID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOiogJykubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcclxuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xyXG4gICAgICAgIHdpbGRjYXJkUnRjcEZiLmZvckVhY2goZmIgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZHVwbGljYXRlID0gY29kZWMucnRjcEZlZWRiYWNrLmZpbmQoZXhpc3RpbmdGZWVkYmFjayA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiYgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcclxuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXHJcbiAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGVzIHBhcnRzIG9mIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBkZXNjcmliaW5nIHRoZSBjYXBhYmlsaXRpZXMgL1xyXG4gICAgLy8gcGFyYW1ldGVycy5cclxuICAgIFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoa2luZCwgY2Fwcykge1xyXG4gICAgICBsZXQgc2RwID0gJyc7XHJcblxyXG4gICAgICAvLyBCdWlsZCB0aGUgbWxpbmUuXHJcbiAgICAgIHNkcCArPSAnbT0nICsga2luZCArICcgJztcclxuICAgICAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXHJcbiAgICAgIHNkcCArPSAnICcgKyAoY2Fwcy5wcm9maWxlIHx8ICdVRFAvVExTL1JUUC9TQVZQRicpICsgJyAnO1xyXG4gICAgICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGNvZGVjID0+IHtcclxuICAgICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XHJcbiAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xyXG4gICAgICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xyXG4gICAgICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcclxuXHJcbiAgICAgIC8vIEFkZCBhPXJ0cG1hcCBsaW5lcyBmb3IgZWFjaCBjb2RlYy4gQWxzbyBmbXRwIGFuZCBydGNwLWZiLlxyXG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcclxuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xyXG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xyXG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQgbWF4cHRpbWUgPSAwO1xyXG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcclxuICAgICAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xyXG4gICAgICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAobWF4cHRpbWUgPiAwKSB7XHJcbiAgICAgICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcclxuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xyXG4gICAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXHJcbiAgICAgIHJldHVybiBzZHA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcclxuICAgIC8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cclxuICAgIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBjb25zdCBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcclxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcclxuICAgICAgY29uc3QgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XHJcbiAgICAgIGNvbnN0IGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xyXG5cclxuICAgICAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxyXG4gICAgICBjb25zdCBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKHBhcnRzID0+IHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XHJcbiAgICAgIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xyXG4gICAgICBsZXQgc2Vjb25kYXJ5U3NyYztcclxuICAgICAgY29uc3QgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJykubWFwKGxpbmUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHBhcnNlSW50KHBhcnQsIDEwKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xyXG4gICAgICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcclxuICAgICAgfVxyXG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XHJcbiAgICAgICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcclxuICAgICAgICAgIGxldCBlbmNQYXJhbSA9IHtcclxuICAgICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXHJcbiAgICAgICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMClcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xyXG4gICAgICAgICAgICBlbmNQYXJhbS5ydHggPSB7XHJcbiAgICAgICAgICAgICAgc3NyYzogc2Vjb25kYXJ5U3NyY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xyXG4gICAgICAgICAgaWYgKGhhc1JlZCkge1xyXG4gICAgICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcclxuICAgICAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xyXG4gICAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxyXG4gICAgICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XHJcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xyXG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmNcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXHJcbiAgICAgIGxldCBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xyXG4gICAgICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XHJcbiAgICAgICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDcpLCAxMCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xyXG4gICAgICAgICAgLy8gdXNlIGZvcm11bGEgZnJvbSBKU0VQIHRvIGNvbnZlcnQgYj1BUyB0byBUSUFTIHZhbHVlLlxyXG4gICAgICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg1KSwgMTApICogMTAwMCAqIDAuOTUgLSA1MCAqIDQwICogODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xyXG4gICAgICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcclxuICAgIH07XHJcblxyXG4gICAgLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXHJcbiAgICBTRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xyXG5cclxuICAgICAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXHJcbiAgICAgIC8vIFNTUkNzLlxyXG4gICAgICBjb25zdCByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIob2JqID0+IG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZScpWzBdO1xyXG4gICAgICBpZiAocmVtb3RlU3NyYykge1xyXG4gICAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcclxuICAgICAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXHJcbiAgICAgIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxyXG4gICAgICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xyXG4gICAgICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XHJcbiAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xyXG5cclxuICAgICAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxyXG4gICAgICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cclxuICAgICAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xyXG4gICAgICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcclxuICAgICAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xyXG4gICAgfTtcclxuICAgIFNEUFV0aWxzLndyaXRlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocnRjcFBhcmFtZXRlcnMpIHtcclxuICAgICAgbGV0IHNkcCA9ICcnO1xyXG4gICAgICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcclxuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xyXG4gICAgICAgIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xyXG4gICAgICAgIHNkcCArPSAnYT1zc3JjOicgKyBydGNwUGFyYW1ldGVycy5zc3JjICsgJyBjbmFtZTonICsgcnRjcFBhcmFtZXRlcnMuY25hbWUgKyAnXFxyXFxuJztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2RwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXHJcbiAgICAvLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxyXG4gICAgU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBsZXQgcGFydHM7XHJcbiAgICAgIGNvbnN0IHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XHJcbiAgICAgIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc3RyZWFtOiBwYXJ0c1swXSxcclxuICAgICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcclxuICAgICAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0cmVhbTogcGFydHNbMF0sXHJcbiAgICAgICAgICB0cmFjazogcGFydHNbMV1cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNDVFBcclxuICAgIC8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xyXG4gICAgLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcclxuICAgIFNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBjb25zdCBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcclxuICAgICAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XHJcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcclxuICAgICAgaWYgKG1heFNpemVMaW5lLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNOYU4obWF4TWVzc2FnZVNpemUpKSB7XHJcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xyXG4gICAgICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHJpbmcoMTIpLCAxMCksXHJcbiAgICAgICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxyXG4gICAgICAgICAgbWF4TWVzc2FnZVNpemVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNjdHBNYXBMaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKTtcclxuICAgICAgaWYgKHNjdHBNYXBMaW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF0uc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxyXG4gICAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxyXG4gICAgICAgICAgbWF4TWVzc2FnZVNpemVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNDVFBcclxuICAgIC8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcclxuICAgIC8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXHJcbiAgICAvLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxyXG4gICAgLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxyXG4gICAgU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAobWVkaWEsIHNjdHApIHtcclxuICAgICAgbGV0IG91dHB1dCA9IFtdO1xyXG4gICAgICBpZiAobWVkaWEucHJvdG9jb2wgIT09ICdEVExTL1NDVFAnKSB7XHJcbiAgICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJywgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLCAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJywgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cclxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcclxuICAgIC8vIHJlY29tbWVuZHMgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gK3ZlIDY0LWJpdCB2YWx1ZVxyXG4gICAgLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXHJcbiAgICBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBXcml0ZSBib2lsZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxyXG4gICAgLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcclxuICAgIC8vIGJlIGdlbmVyYXRlZCByYW5kb21seVxyXG4gICAgLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcclxuICAgIC8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXHJcbiAgICBTRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uIChzZXNzSWQsIHNlc3NWZXIsIHNlc3NVc2VyKSB7XHJcbiAgICAgIGxldCBzZXNzaW9uSWQ7XHJcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcclxuICAgICAgaWYgKHNlc3NJZCkge1xyXG4gICAgICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXNzaW9uSWQgPSBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xyXG4gICAgICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cclxuICAgICAgcmV0dXJuICd2PTBcXHJcXG4nICsgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICsgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArICdzPS1cXHJcXG4nICsgJ3Q9MCAwXFxyXFxuJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXHJcbiAgICBTRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xyXG4gICAgICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XHJcbiAgICAgICAgICBjYXNlICdhPXNlbmRyZWN2JzpcclxuICAgICAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxyXG4gICAgICAgICAgY2FzZSAnYT1yZWN2b25seSc6XHJcbiAgICAgICAgICBjYXNlICdhPWluYWN0aXZlJzpcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cmluZygyKTtcclxuICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlc3Npb25wYXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICdzZW5kcmVjdic7XHJcbiAgICB9O1xyXG4gICAgU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcclxuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XHJcbiAgICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cmluZygyKTtcclxuICAgIH07XHJcbiAgICBTRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcclxuICAgIH07XHJcbiAgICBTRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xyXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcclxuICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBraW5kOiBwYXJ0c1swXSxcclxuICAgICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxyXG4gICAgICAgIHByb3RvY29sOiBwYXJ0c1syXSxcclxuICAgICAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlcm5hbWU6IHBhcnRzWzBdLFxyXG4gICAgICAgIHNlc3Npb25JZDogcGFydHNbMV0sXHJcbiAgICAgICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXHJcbiAgICAgICAgbmV0VHlwZTogcGFydHNbM10sXHJcbiAgICAgICAgYWRkcmVzc1R5cGU6IHBhcnRzWzRdLFxyXG4gICAgICAgIGFkZHJlc3M6IHBhcnRzWzVdXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cclxuICAgIFNEUFV0aWxzLmlzVmFsaWRTRFAgPSBmdW5jdGlvbiAoYmxvYikge1xyXG4gICAgICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPCAyIHx8IGxpbmVzW2ldLmNoYXJBdCgxKSAhPT0gJz0nKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBtb2RpZmllciBhIGJpdCBtb3JlLlxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXHJcbiAgICB7XHJcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XHJcbiAgICB9XHJcbiAgfSkoc2RwJDEpO1xyXG4gIHJldHVybiBzZHAkMS5leHBvcnRzO1xyXG59XHJcblxyXG52YXIgc2RwRXhwb3J0cyA9IHJlcXVpcmVTZHAoKTtcclxudmFyIFNEUFV0aWxzID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNkcEV4cG9ydHMpO1xyXG5cclxudmFyIHNkcCA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgZGVmYXVsdDogU0RQVXRpbHNcclxufSwgW3NkcEV4cG9ydHNdKTtcclxuXHJcbi8qXHJcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXHJcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcclxuICogIHRyZWUuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cclxuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpIHtcclxuICAvLyBmb3VuZGF0aW9uIGlzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBhbiBpbmRpY2F0b3IgZm9yIGZ1bGwgc3VwcG9ydCBmb3JcclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXHJcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XHJcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIFJUQ0ljZUNhbmRpZGF0ZShhcmdzKSB7XHJcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxyXG4gICAgaWYgKHR5cGVvZiBhcmdzID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XHJcbiAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcclxuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUubGVuZ3RoKSB7XHJcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cclxuICAgICAgY29uc3QgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcclxuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoYXJncy5jYW5kaWRhdGUpO1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gbmF0aXZlQ2FuZGlkYXRlKSkge1xyXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNhbmRpZGF0ZSwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdmVycmlkZSBzZXJpYWxpemVyIHRvIG5vdCBzZXJpYWxpemUgdGhlIGV4dHJhIGF0dHJpYnV0ZXMuXHJcbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGNhbmRpZGF0ZTogbmF0aXZlQ2FuZGlkYXRlLmNhbmRpZGF0ZSxcclxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcclxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxyXG4gICAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogbmF0aXZlQ2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnRcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gbmF0aXZlQ2FuZGlkYXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XHJcbiAgfTtcclxuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XHJcblxyXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXHJcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxyXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xyXG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xyXG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXHJcbiAgICAgICAgd3JpdGFibGU6ICdmYWxzZSdcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpIHtcclxuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXHJcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxyXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xyXG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSk7XHJcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBsaWJ3ZWJydGMtc3BlY2lmaWMgbWFwcGluZyBvZiBsb2NhbCB0eXBlIHByZWZlcmVuY2VcclxuICAgICAgICAvLyB0byByZWxheVByb3RvY29sLlxyXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XHJcbiAgICAgICAgICAwOiAndGxzJyxcclxuICAgICAgICAgIDE6ICd0Y3AnLFxyXG4gICAgICAgICAgMjogJ3VkcCdcclxuICAgICAgICB9W3BhcnNlZENhbmRpZGF0ZS5wcmlvcml0eSA+PiAyNF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBlO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKCEoJ3NjdHAnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XHJcbiAgICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xyXG4gICAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhZGVzY3JpcHRpb24uc2RwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xyXG4gICAgc2VjdGlvbnMuc2hpZnQoKTtcclxuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XHJcbiAgICAgIGNvbnN0IG1MaW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xyXG4gICAgICByZXR1cm4gbUxpbmUgJiYgbUxpbmUua2luZCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBtTGluZS5wcm90b2NvbC5pbmRleE9mKCdTQ1RQJykgIT09IC0xO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBjb25zdCBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xyXG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xyXG4gICAgY29uc3QgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XHJcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXHJcbiAgICByZXR1cm4gdmVyc2lvbiAhPT0gdmVyc2lvbiA/IC0xIDogdmVyc2lvbjtcclxuICB9O1xyXG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChyZW1vdGVJc0ZpcmVmb3gpIHtcclxuICAgIC8vIEV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgY2FuIHNlbmQgYXQgbGVhc3QgNjQgS2lCLlxyXG4gICAgLy8gTm90ZTogQWx0aG91Z2ggQ2hyb21lIGlzIHRlY2huaWNhbGx5IGFibGUgdG8gc2VuZCB1cCB0byAyNTYgS2lCLCB0aGVcclxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXHJcbiAgICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD04NDE5XHJcbiAgICBsZXQgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gNjU1MzY7XHJcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XHJcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTcpIHtcclxuICAgICAgICBpZiAocmVtb3RlSXNGaXJlZm94ID09PSAtMSkge1xyXG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXHJcbiAgICAgICAgICAvLyBmcmFnbWVudGF0aW9uLlxyXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMTYzODQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEhvd2V2ZXIsIG90aGVyIEZGIChhbmQgUkFXUlRDKSBjYW4gcmVhc3NlbWJsZSBQUElELWZyYWdtZW50ZWRcclxuICAgICAgICAgIC8vIG1lc3NhZ2VzLiBUaHVzLCBzdXBwb3J0aW5nIH4yIEdpQiB3aGVuIHNlbmRpbmcuXHJcbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjApIHtcclxuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcclxuICAgICAgICAvLyB0byB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIGEgZGF0YSBjaGFubmVsIGlzIGNyZWF0ZWQgYXQgYSBsYXRlclxyXG4gICAgICAgIC8vIHN0YWdlLiA6KFxyXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxyXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3ID8gNjU1MzUgOiA2NTUzNjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxyXG4gICAgICAgIGNhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjYW5TZW5kTWF4TWVzc2FnZVNpemU7XHJcbiAgfTtcclxuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XHJcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcclxuICAgIC8vICAgICAgIGV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgc3VwcG9ydHMgcmVjZWl2aW5nIDY1NTM2IGJ5dGVzLlxyXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XHJcblxyXG4gICAgLy8gRkYgNTcgaGFzIGEgc2xpZ2h0bHkgaW5jb3JyZWN0IGRlZmF1bHQgcmVtb3RlIG1heCBtZXNzYWdlIHNpemUsIHNvXHJcbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcclxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcpIHtcclxuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoZGVzY3JpcHRpb24uc2RwLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xyXG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XHJcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiByZW1vdGVJc0ZpcmVmb3ggIT09IC0xKSB7XHJcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcclxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcclxuICAgICAgLy8gfjIgR2lCLlxyXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XHJcbiAgfTtcclxuICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcclxuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xyXG4gICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cclxuICAgIC8vIEFzIHVzdWFsLCBhZGFwdGVyLmpzIGhhcyB0byBkbyBhbiAndWdseSB3b3Jha2Fyb3VuZCdcclxuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxyXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHNkcFNlbWFudGljc1xyXG4gICAgICB9ID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCk7XHJcbiAgICAgIGlmIChzZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xyXG4gICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxyXG4gICAgICBjb25zdCBpc0ZpcmVmb3ggPSBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihhcmd1bWVudHNbMF0pO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSB0aGUgbG9jYWwgcGVlciBpcyBjYXBhYmxlIG9mIHNlbmRpbmdcclxuICAgICAgY29uc3QgY2FuU2VuZE1NUyA9IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShpc0ZpcmVmb3gpO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBvZiB0aGUgcmVtb3RlIHBlZXIuXHJcbiAgICAgIGNvbnN0IHJlbW90ZU1NUyA9IGdldE1heE1lc3NhZ2VTaXplKGFyZ3VtZW50c1swXSwgaXNGaXJlZm94KTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxyXG4gICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XHJcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xyXG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICB9IGVsc2UgaWYgKGNhblNlbmRNTVMgPT09IDAgfHwgcmVtb3RlTU1TID09PSAwKSB7XHJcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5taW4oY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgUlRDU2N0cFRyYW5zcG9ydCBvYmplY3QgYW5kIHRoZSAnbWF4TWVzc2FnZVNpemUnXHJcbiAgICAgIC8vIGF0dHJpYnV0ZS5cclxuICAgICAgY29uc3Qgc2N0cCA9IHt9O1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2N0cCwgJ21heE1lc3NhZ2VTaXplJywge1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLl9zY3RwID0gc2N0cDtcclxuICAgIH1cclxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XHJcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdjcmVhdGVEYXRhQ2hhbm5lbCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIE5vdGU6IEFsdGhvdWdoIEZpcmVmb3ggPj0gNTcgaGFzIGEgbmF0aXZlIGltcGxlbWVudGF0aW9uLCB0aGUgbWF4aW11bVxyXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXHJcbiAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI2ODMxXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XHJcbiAgICBjb25zdCBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcclxuICAgIGRjLnNlbmQgPSBmdW5jdGlvbiBzZW5kKCkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCB8fCBkYXRhLnNpemUgfHwgZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICBpZiAoZGMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIHBjLnNjdHAgJiYgbGVuZ3RoID4gcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnRGF0YUNoYW5uZWxTZW5kLmFwcGx5KGRjLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgY29uc3Qgb3JpZ0NyZWF0ZURhdGFDaGFubmVsID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbDtcclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XHJcbiAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgd3JhcERjU2VuZChkYXRhQ2hhbm5lbCwgdGhpcyk7XHJcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XHJcbiAgfTtcclxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdkYXRhY2hhbm5lbCcsIGUgPT4ge1xyXG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcclxuICAgIHJldHVybiBlO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKiBzaGltcyBSVENDb25uZWN0aW9uU3RhdGUgYnkgcHJldGVuZGluZyBpdCBpcyB0aGUgc2FtZSBhcyBpY2VDb25uZWN0aW9uU3RhdGUuXHJcbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcclxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XHJcbiAqIHNpbmNlIERUTFMgZmFpbHVyZXMgd291bGQgYmUgaGlkZGVuLiBTZWVcclxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xyXG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcclxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25uZWN0aW9uU3RhdGUnLCB7XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY29tcGxldGVkOiAnY29ubmVjdGVkJyxcclxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXHJcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xyXG4gICAgfSxcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWVcclxuICB9KTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcclxuICAgIGdldCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIHx8IG51bGw7XHJcbiAgICB9LFxyXG4gICAgc2V0KGNiKSB7XHJcbiAgICAgIGlmICh0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2IpIHtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gY2IpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gIH0pO1xyXG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2gobWV0aG9kID0+IHtcclxuICAgIGNvbnN0IG9yaWdNZXRob2QgPSBwcm90b1ttZXRob2RdO1xyXG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSA9IGUgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcclxuICAgICAgICAgIGlmIChwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSAhPT0gcGMuY29ubmVjdGlvblN0YXRlKSB7XHJcbiAgICAgICAgICAgIHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGMuY29ubmVjdGlvblN0YXRlO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XHJcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xyXG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJyAmJiBicm93c2VyRGV0YWlscy5fc2FmYXJpVmVyc2lvbiA+PSAxMy4xKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG5hdGl2ZVNSRCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XHJcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcclxuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XHJcbiAgICAgIGNvbnN0IHNkcCA9IGRlc2Muc2RwLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xyXG4gICAgICB9KS5qb2luKCdcXG4nKTtcclxuICAgICAgLy8gU2FmYXJpIGVuZm9yY2VzIHJlYWQtb25seS1uZXNzIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiBmaWVsZHMuXHJcbiAgICAgIGlmICh3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICYmIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24oe1xyXG4gICAgICAgICAgdHlwZTogZGVzYy50eXBlLFxyXG4gICAgICAgICAgc2RwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVzYy5zZHAgPSBzZHA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgLy8gU3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxyXG4gIC8vIGFzIHdlbGwgYXMgYWRkSWNlQ2FuZGlkYXRlKHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0pXHJcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXHJcbiAgLy8gTm90ZTogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIHBvbHlmaWxscyB3aGljaCBjaGFuZ2UgdGhlIHNpZ25hdHVyZS5cclxuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XHJcbiAgaWYgKCFuYXRpdmVBZGRJY2VDYW5kaWRhdGUgfHwgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcclxuICAgIGlmICghYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcclxuICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcclxuICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLlxyXG4gICAgLy8gTmF0aXZlIHN1cHBvcnQgZm9yIGlnbm9yaW5nIGV4aXN0cyBmb3IgQ2hyb21lIE03NysuXHJcbiAgICAvLyBTYWZhcmkgaWdub3JlcyBhcyB3ZWxsLCBleGFjdCB2ZXJzaW9uIHVua25vd24gYnV0IHdvcmtzIGluIHRoZSBzYW1lXHJcbiAgICAvLyB2ZXJzaW9uIHRoYXQgYWxzbyBpZ25vcmVzIGFkZEljZUNhbmRpZGF0ZShudWxsKS5cclxuICAgIGlmICgoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScpICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gTm90ZTogTWFrZSBzdXJlIHRvIGNhbGwgdGhpcyBhaGVhZCBvZiBBUElzIHRoYXQgbW9kaWZ5XHJcbi8vIHNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoXHJcbmZ1bmN0aW9uIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XHJcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XHJcbiAgaWYgKCFuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIHx8IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XHJcbiAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcgfHwgZGVzYy50eXBlICYmIGRlc2Muc2RwKSB7XHJcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgcmVtYWluaW5nIHN0ZXBzIHNob3VsZCB0ZWNobmljYWxseSBoYXBwZW4gd2hlbiBTTEQgY29tZXMgb2ZmIHRoZVxyXG4gICAgLy8gUlRDUGVlckNvbm5lY3Rpb24ncyBvcGVyYXRpb25zIGNoYWluIChub3QgYWhlYWQgb2YgZ29pbmcgb24gaXQpLCBidXRcclxuICAgIC8vIHRoaXMgaXMgdG9vIGRpZmZpY3VsdCB0byBzaGltLiBJbnN0ZWFkLCB0aGlzIHNoaW0gb25seSBjb3ZlcnMgdGhlXHJcbiAgICAvLyBjb21tb24gY2FzZSB3aGVyZSB0aGUgb3BlcmF0aW9ucyBjaGFpbiBpcyBlbXB0eS4gVGhpcyBpcyBpbXBlcmZlY3QsIGJ1dFxyXG4gICAgLy8gc2hvdWxkIGNvdmVyIG1hbnkgY2FzZXMuIFJhdGlvbmFsZTogRXZlbiBpZiB3ZSBjYW4ndCByZWR1Y2UgdGhlIGdsYXJlXHJcbiAgICAvLyB3aW5kb3cgdG8gemVybyBvbiBpbXBlcmZlY3QgaW1wbGVtZW50YXRpb25zLCB0aGVyZSdzIHZhbHVlIGluIHRhcHBpbmdcclxuICAgIC8vIGludG8gdGhlIHBlcmZlY3QgbmVnb3RpYXRpb24gcGF0dGVybiB0aGF0IHNldmVyYWwgYnJvd3NlcnMgc3VwcG9ydC5cclxuICAgIGRlc2MgPSB7XHJcbiAgICAgIHR5cGU6IGRlc2MudHlwZSxcclxuICAgICAgc2RwOiBkZXNjLnNkcFxyXG4gICAgfTtcclxuICAgIGlmICghZGVzYy50eXBlKSB7XHJcbiAgICAgIHN3aXRjaCAodGhpcy5zaWduYWxpbmdTdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0YWJsZSc6XHJcbiAgICAgICAgY2FzZSAnaGF2ZS1sb2NhbC1vZmZlcic6XHJcbiAgICAgICAgY2FzZSAnaGF2ZS1yZW1vdGUtcHJhbnN3ZXInOlxyXG4gICAgICAgICAgZGVzYy50eXBlID0gJ29mZmVyJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnYW5zd2VyJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZGVzYy5zZHAgfHwgZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpIHtcclxuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZ1bmMgPSBkZXNjLnR5cGUgPT09ICdvZmZlcicgPyB0aGlzLmNyZWF0ZU9mZmVyIDogdGhpcy5jcmVhdGVBbnN3ZXI7XHJcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzKS50aGVuKGQgPT4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZF0pKTtcclxuICB9O1xyXG59XHJcblxyXG52YXIgY29tbW9uU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZDogcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCxcclxuICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHk6IHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSxcclxuICBzaGltQ29ubmVjdGlvblN0YXRlOiBzaGltQ29ubmVjdGlvblN0YXRlLFxyXG4gIHNoaW1NYXhNZXNzYWdlU2l6ZTogc2hpbU1heE1lc3NhZ2VTaXplLFxyXG4gIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbjogc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uLFxyXG4gIHNoaW1SVENJY2VDYW5kaWRhdGU6IHNoaW1SVENJY2VDYW5kaWRhdGUsXHJcbiAgc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2w6IHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sLFxyXG4gIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3I6IHNoaW1TZW5kVGhyb3dUeXBlRXJyb3JcclxufSk7XHJcblxyXG4vKlxyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKlxyXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxyXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXHJcbiAqICB0cmVlLlxyXG4gKi9cclxuXHJcbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxyXG5mdW5jdGlvbiBhZGFwdGVyRmFjdG9yeSgpIHtcclxuICBsZXQge1xyXG4gICAgd2luZG93XHJcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcclxuICAgIHNoaW1DaHJvbWU6IHRydWUsXHJcbiAgICBzaGltRmlyZWZveDogdHJ1ZSxcclxuICAgIHNoaW1TYWZhcmk6IHRydWVcclxuICB9O1xyXG4gIC8vIFV0aWxzLlxyXG4gIGNvbnN0IGxvZ2dpbmcgPSBsb2c7XHJcbiAgY29uc3QgYnJvd3NlckRldGFpbHMgPSBkZXRlY3RCcm93c2VyKHdpbmRvdyk7XHJcbiAgY29uc3QgYWRhcHRlciA9IHtcclxuICAgIGJyb3dzZXJEZXRhaWxzLFxyXG4gICAgY29tbW9uU2hpbSxcclxuICAgIGV4dHJhY3RWZXJzaW9uOiBleHRyYWN0VmVyc2lvbixcclxuICAgIGRpc2FibGVMb2c6IGRpc2FibGVMb2csXHJcbiAgICBkaXNhYmxlV2FybmluZ3M6IGRpc2FibGVXYXJuaW5ncyxcclxuICAgIC8vIEV4cG9zZSBzZHAgYXMgYSBjb252ZW5pZW5jZS4gRm9yIHByb2R1Y3Rpb24gYXBwcyBpbmNsdWRlIGRpcmVjdGx5LlxyXG4gICAgc2RwXHJcbiAgfTtcclxuXHJcbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxyXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xyXG4gICAgY2FzZSAnY2hyb21lJzpcclxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24kMSB8fCAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XHJcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gY2FuIG5vdCBkZXRlcm1pbmUgdmVyc2lvbiwgbm90IHNoaW1taW5nLicpO1xyXG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xyXG4gICAgICB9XHJcbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xyXG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxyXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcclxuXHJcbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXHJcbiAgICAgIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbU1lZGlhU3RyZWFtKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbiQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltT25UcmFjayQxKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XHJcbiAgICAgIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcclxuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XHJcbiAgICAgIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnZmlyZWZveCc6XHJcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIXNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xyXG4gICAgICAgIGxvZ2dpbmcoJ0ZpcmVmb3ggc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XHJcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XHJcbiAgICAgIH1cclxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBmaXJlZm94LicpO1xyXG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxyXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XHJcblxyXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxyXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3cpO1xyXG4gICAgICBzaGltR2V0VXNlck1lZGlhJDEod2luZG93LCBicm93c2VyRGV0YWlscyk7XHJcbiAgICAgIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbU9uVHJhY2sod2luZG93KTtcclxuICAgICAgc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpO1xyXG4gICAgICBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KTtcclxuICAgICAgc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcclxuICAgICAgc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpO1xyXG4gICAgICBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpO1xyXG4gICAgICBzaGltQ3JlYXRlT2ZmZXIod2luZG93KTtcclxuICAgICAgc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpO1xyXG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcclxuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnc2FmYXJpJzpcclxuICAgICAgaWYgKCFzYWZhcmlTaGltIHx8ICFvcHRpb25zLnNoaW1TYWZhcmkpIHtcclxuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XHJcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XHJcbiAgICAgIH1cclxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBzYWZhcmkuJyk7XHJcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXHJcbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xyXG5cclxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cclxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcclxuICAgICAgc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KTtcclxuICAgICAgc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdyk7XHJcbiAgICAgIHNoaW1DYWxsYmFja3NBUEkod2luZG93KTtcclxuICAgICAgc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpO1xyXG4gICAgICBzaGltUmVtb3RlU3RyZWFtc0FQSSh3aW5kb3cpO1xyXG4gICAgICBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcclxuICAgICAgc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpO1xyXG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XHJcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcclxuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xyXG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gYWRhcHRlcjtcclxufVxyXG5cclxuLypcclxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcclxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxyXG4gKiAgdHJlZS5cclxuICovXHJcbi8qIGVzbGludC1lbnYgbm9kZSAqL1xyXG5cclxuYWRhcHRlckZhY3Rvcnkoe1xyXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3dcclxufSk7XHJcblxyXG5jb25zdCBFTkNSWVBUSU9OX0FMR09SSVRITSA9ICdBRVMtR0NNJztcclxuLy8gSG93IG1hbnkgY29uc2VjdXRpdmUgZnJhbWVzIGNhbiBmYWlsIGRlY3J5cHRpbmcgYmVmb3JlIGEgcGFydGljdWxhciBrZXkgZ2V0cyBtYXJrZWQgYXMgaW52YWxpZFxyXG5jb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XHJcbi8vIGZsYWcgc2V0IHRvIGluZGljYXRlIHRoYXQgZTJlZSBoYXMgYmVlbiBzZXR1cCBmb3Igc2VuZGVyL3JlY2VpdmVyO1xyXG5jb25zdCBFMkVFX0ZMQUcgPSAnbGtfZTJlZSc7XHJcbmNvbnN0IFNBTFQgPSAnTEtGcmFtZUVuY3J5cHRpb25LZXknO1xyXG5jb25zdCBLRVlfUFJPVklERVJfREVGQVVMVFMgPSB7XHJcbiAgc2hhcmVkS2V5OiBmYWxzZSxcclxuICByYXRjaGV0U2FsdDogU0FMVCxcclxuICByYXRjaGV0V2luZG93U2l6ZTogOCxcclxuICBmYWlsdXJlVG9sZXJhbmNlOiBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFLFxyXG4gIGtleXJpbmdTaXplOiAxNlxyXG59O1xyXG5cclxudmFyIEtleVByb3ZpZGVyRXZlbnQ7XHJcbihmdW5jdGlvbiAoS2V5UHJvdmlkZXJFdmVudCkge1xyXG4gIEtleVByb3ZpZGVyRXZlbnRbXCJTZXRLZXlcIl0gPSBcInNldEtleVwiO1xyXG4gIC8qKiBFdmVudCBmb3IgcmVxdWVzdGluZyB0byByYXRjaGV0IHRoZSBrZXkgdXNlZCB0byBlbmNyeXB0IHRoZSBzdHJlYW0gKi9cclxuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XHJcbiAgLyoqIEVtaXR0ZWQgd2hlbiBhIGtleSBpcyByYXRjaGV0ZWQuIENvdWxkIGJlIGFmdGVyIGF1dG8tcmF0Y2hldGluZyBvbiBkZWNyeXB0aW9uIGZhaWx1cmUgb3JcclxuICAgKiAgZm9sbG93aW5nIGEgYFJhdGNoZXRSZXF1ZXN0YCwgd2lsbCBjb250YWluIHRoZSByYXRjaGV0ZWQga2V5IG1hdGVyaWFsICovXHJcbiAgS2V5UHJvdmlkZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XHJcbn0pKEtleVByb3ZpZGVyRXZlbnQgfHwgKEtleVByb3ZpZGVyRXZlbnQgPSB7fSkpO1xyXG52YXIgS2V5SGFuZGxlckV2ZW50O1xyXG4oZnVuY3Rpb24gKEtleUhhbmRsZXJFdmVudCkge1xyXG4gIC8qKiBFbWl0dGVkIHdoZW4gYSBrZXkgaGFzIGJlZW4gcmF0Y2hldGVkLiBJcyBlbWl0dGVkIHdoZW4gYW55IGtleSBoYXMgYmVlbiByYXRjaGV0ZWRcclxuICAgKiBpLmUuIHdoZW4gdGhlIEZyYW1lQ3J5cHRvciB0cmllZCB0byByYXRjaGV0IHdoZW4gZGVjcnlwdGlvbiBpcyBmYWlsaW5nICAqL1xyXG4gIEtleUhhbmRsZXJFdmVudFtcIktleVJhdGNoZXRlZFwiXSA9IFwia2V5UmF0Y2hldGVkXCI7XHJcbn0pKEtleUhhbmRsZXJFdmVudCB8fCAoS2V5SGFuZGxlckV2ZW50ID0ge30pKTtcclxudmFyIEVuY3J5cHRpb25FdmVudDtcclxuKGZ1bmN0aW9uIChFbmNyeXB0aW9uRXZlbnQpIHtcclxuICBFbmNyeXB0aW9uRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XHJcbiAgRW5jcnlwdGlvbkV2ZW50W1wiRW5jcnlwdGlvbkVycm9yXCJdID0gXCJlbmNyeXB0aW9uRXJyb3JcIjtcclxufSkoRW5jcnlwdGlvbkV2ZW50IHx8IChFbmNyeXB0aW9uRXZlbnQgPSB7fSkpO1xyXG52YXIgQ3J5cHRvckV2ZW50O1xyXG4oZnVuY3Rpb24gKENyeXB0b3JFdmVudCkge1xyXG4gIENyeXB0b3JFdmVudFtcIkVycm9yXCJdID0gXCJjcnlwdG9yRXJyb3JcIjtcclxufSkoQ3J5cHRvckV2ZW50IHx8IChDcnlwdG9yRXZlbnQgPSB7fSkpO1xyXG5cclxuZnVuY3Rpb24gaXNFMkVFU3VwcG9ydGVkKCkge1xyXG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkge1xyXG4gIC8vIEB0cy1pZ25vcmVcclxuICByZXR1cm4gdHlwZW9mIHdpbmRvdy5SVENSdHBTY3JpcHRUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcclxuICByZXR1cm4gdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCc7XHJcbn1cclxuZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKGZyYW1lKSB7XHJcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcclxufVxyXG5mdW5jdGlvbiBpbXBvcnRLZXkoa2V5Qnl0ZXNfMSkge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChrZXlCeXRlcykge1xyXG4gICAgbGV0IGFsZ29yaXRobSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xyXG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITVxyXG4gICAgfTtcclxuICAgIGxldCB1c2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2VuY3J5cHQnO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5XHJcbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywga2V5Qnl0ZXMsIGFsZ29yaXRobSwgZmFsc2UsIHVzYWdlID09PSAnZGVyaXZlJyA/IFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSA6IFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xyXG4gICAgfSgpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhwYXNzd29yZCkge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBsZXQgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBlbmMuZW5jb2RlKHBhc3N3b3JkKSwge1xyXG4gICAgICBuYW1lOiAnUEJLREYyJ1xyXG4gICAgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XHJcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcikge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBjcnlwdG9CdWZmZXIsICdIS0RGJywgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XHJcbiAgICByZXR1cm4ga2V5TWF0ZXJpYWw7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxnb09wdGlvbnMoYWxnb3JpdGhtTmFtZSwgc2FsdCkge1xyXG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgY29uc3QgZW5jb2RlZFNhbHQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc2FsdCk7XHJcbiAgc3dpdGNoIChhbGdvcml0aG1OYW1lKSB7XHJcbiAgICBjYXNlICdIS0RGJzpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiAnSEtERicsXHJcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXHJcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxyXG4gICAgICAgIGluZm86IG5ldyBBcnJheUJ1ZmZlcigxMjgpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlICdQQktERjInOlxyXG4gICAgICB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIG5hbWU6ICdQQktERjInLFxyXG4gICAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXHJcbiAgICAgICAgICBoYXNoOiAnU0hBLTI1NicsXHJcbiAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbGdvcml0aG0gXCIuY29uY2F0KGFsZ29yaXRobU5hbWUsIFwiIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZFwiKSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXJpdmVzIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgbWFzdGVyIGtleS5cclxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxyXG4gKi9cclxuZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbCwgc2FsdCkge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVLZXkjSEtERlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hrZGZQYXJhbXNcclxuICAgIGNvbnN0IGVuY3J5cHRpb25LZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwge1xyXG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSxcclxuICAgICAgbGVuZ3RoOiAxMjhcclxuICAgIH0sIGZhbHNlLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG1hdGVyaWFsLFxyXG4gICAgICBlbmNyeXB0aW9uS2V5XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUUyRUVLZXkoKSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJhdGNoZXRzIGEga2V5LiBTZWVcclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LW9tYXJhLXNmcmFtZS0wMCNzZWN0aW9uLTQuMy41LjFcclxuICovXHJcbmZ1bmN0aW9uIHJhdGNoZXQobWF0ZXJpYWwsIHNhbHQpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlQml0c1xyXG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwgMjU2KTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YSkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVEYXRhLmxlbmd0aCAtIDM7IGkrKykge1xyXG4gICAgaWYgKGZyYW1lRGF0YVtpXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDJdID09IDMpIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbSkge1xyXG4gIGNvbnN0IGRhdGFPdXQgPSBbXTtcclxuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbS5sZW5ndGg7KSB7XHJcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXHJcbiAgICAvLyBpICsgMyBjYW4gb3ZlcmZsb3csIGJ1dCBieXRlX2xlbmd0aF8gLSBpIGNhbid0LCBiZWNhdXNlIGkgPCBieXRlX2xlbmd0aF9cclxuICAgIC8vIGFib3ZlLCBhbmQgdGhhdCBleHByZXNzaW9uIHdpbGwgcHJvZHVjZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGxlZnQgaW5cclxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXHJcbiAgICBpZiAobGVuZ3RoIC0gaSA+PSAzICYmICFzdHJlYW1baV0gJiYgIXN0cmVhbVtpICsgMV0gJiYgc3RyZWFtW2kgKyAyXSA9PSAzKSB7XHJcbiAgICAgIC8vIFR3byByYnNwIGJ5dGVzLlxyXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xyXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xyXG4gICAgICAvLyBTa2lwIHRoZSBlbXVsYXRpb24gYnl0ZS5cclxuICAgICAgaSsrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gU2luZ2xlIHJic3AgYnl0ZS5cclxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xyXG59XHJcbmNvbnN0IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSA9IDI7XHJcbmNvbnN0IGtFbXVsYXRpb25CeXRlID0gMztcclxuZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW4pIHtcclxuICBjb25zdCBkYXRhT3V0ID0gW107XHJcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV9pbi5sZW5ndGg7ICsraSkge1xyXG4gICAgdmFyIGJ5dGUgPSBkYXRhX2luW2ldO1xyXG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcclxuICAgICAgLy8gTmVlZCB0byBlc2NhcGUuXHJcbiAgICAgIGRhdGFPdXQucHVzaChrRW11bGF0aW9uQnl0ZSk7XHJcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xyXG4gICAgfVxyXG4gICAgZGF0YU91dC5wdXNoKGJ5dGUpO1xyXG4gICAgaWYgKGJ5dGUgPT0gMCkge1xyXG4gICAgICArK251bUNvbnNlY3V0aXZlWmVyb3M7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xyXG59XHJcblxyXG4vKipcclxuICogQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxuY2xhc3MgQmFzZUtleVByb3ZpZGVyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gICAgc3VwZXIoKTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgYmVpbmcgaW52b2tlZCBhZnRlciBhIGtleSBoYXMgYmVlbiByYXRjaGV0ZWQuXHJcbiAgICAgKiBDYW4gaGFwcGVuIHdoZW46XHJcbiAgICAgKiAtIEEgZGVjcnlwdGlvbiBmYWlsdXJlIG9jY3VycyBhbmQgdGhlIGtleSBpcyBhdXRvLXJhdGNoZXRlZFxyXG4gICAgICogLSBBIHJhdGNoZXQgcmVxdWVzdCBpcyBzZW50IChzZWUge0BsaW5rIHJhdGNoZXRLZXkoKX0pXHJcbiAgICAgKiBAcGFyYW0gcmF0Y2hldFJlc3VsdCBDb250YWlucyB0aGUgcmF0Y2hldGVkIGNoYWluIGtleSAoZXhwb3J0YWJsZSB0byBvdGhlciBwYXJ0aWNpcGFudHMpIGFuZCB0aGUgZGVyaXZlZCBuZXcga2V5IG1hdGVyaWFsLlxyXG4gICAgICogQHBhcmFtIHBhcnRpY2lwYW50SWRcclxuICAgICAqIEBwYXJhbSBrZXlJbmRleFxyXG4gICAgICovXHJcbiAgICB0aGlzLm9uS2V5UmF0Y2hldGVkID0gKHJhdGNoZXRSZXN1bHQsIHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSA9PiB7XHJcbiAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2tleSByYXRjaGV0ZWQgZXZlbnQgcmVjZWl2ZWQnLCB7XHJcbiAgICAgICAgcmF0Y2hldFJlc3VsdCxcclxuICAgICAgICBwYXJ0aWNpcGFudElkLFxyXG4gICAgICAgIGtleUluZGV4XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMua2V5SW5mb01hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgS0VZX1BST1ZJREVSX0RFRkFVTFRTKSwgb3B0aW9ucyk7XHJcbiAgICB0aGlzLm9uKEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCB0aGlzLm9uS2V5UmF0Y2hldGVkKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgYSBrZXkgaGFzIGJlZW4gc2V0IGZvciBhIHBhcnRpY2lwYW50XHJcbiAgICogQHBhcmFtIGtleVxyXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkZW50aXR5XHJcbiAgICogQHBhcmFtIGtleUluZGV4XHJcbiAgICovXHJcbiAgb25TZXRFbmNyeXB0aW9uS2V5KGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcclxuICAgIGNvbnN0IGtleUluZm8gPSB7XHJcbiAgICAgIGtleSxcclxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcclxuICAgICAga2V5SW5kZXhcclxuICAgIH07XHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGFyZWRLZXkgJiYgIXBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0aWNpcGFudCBpZGVudGl0eSBuZWVkcyB0byBiZSBwYXNzZWQgZm9yIGVuY3J5cHRpb24ga2V5IGlmIHNoYXJlZEtleSBvcHRpb24gaXMgZmFsc2UnKTtcclxuICAgIH1cclxuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoXCJcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSAhPT0gbnVsbCAmJiBwYXJ0aWNpcGFudElkZW50aXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNpcGFudElkZW50aXR5IDogJ3NoYXJlZCcsIFwiLVwiKS5jb25jYXQoa2V5SW5kZXggIT09IG51bGwgJiYga2V5SW5kZXggIT09IHZvaWQgMCA/IGtleUluZGV4IDogMCksIGtleUluZm8pO1xyXG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuU2V0S2V5LCBrZXlJbmZvKTtcclxuICB9XHJcbiAgZ2V0S2V5cygpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5SW5mb01hcC52YWx1ZXMoKSk7XHJcbiAgfVxyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gIH1cclxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XHJcbiAgICB0aGlzLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5SYXRjaGV0UmVxdWVzdCwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQSBiYXNpYyBLZXlQcm92aWRlciBpbXBsZW1lbnRhdGlvbiBpbnRlbmRlZCBmb3IgYSBzaW5nbGUgc2hhcmVkXHJcbiAqIHBhc3NwaHJhc2UgYmV0d2VlbiBhbGwgcGFydGljaXBhbnRzXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XHJcbiAgICAgIHNoYXJlZEtleTogdHJ1ZSxcclxuICAgICAgLy8gZm9yIGEgc2hhcmVkIGtleSBwcm92aWRlciBmYWlsaW5nIHRvIGRlY3J5cHQgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnRcclxuICAgICAgLy8gc2hvdWxkIG5vdCBtYXJrIHRoZSBrZXkgYXMgaW52YWxpZCwgc28gd2UgYWNjZXB0IHdyb25nIGtleXMgZm9yZXZlclxyXG4gICAgICAvLyBhbmQgd29uJ3QgdHJ5IHRvIGF1dG8tcmF0Y2hldFxyXG4gICAgICByYXRjaGV0V2luZG93U2l6ZTogMCxcclxuICAgICAgZmFpbHVyZVRvbGVyYW5jZTogLTFcclxuICAgIH0pO1xyXG4gICAgc3VwZXIob3B0cyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXHJcbiAgICogV2hlbiBwYXNzaW5nIGluIGEgc3RyaW5nLCBQQktERjIgaXMgdXNlZC5cclxuICAgKiBXaGVuIHBhc3NpbmcgaW4gYW4gQXJyYXkgYnVmZmVyIG9mIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSBudW1iZXJzLCBIS0RGIGlzIGJlaW5nIHVzZWQuIChyZWNvbW1lbmRlZClcclxuICAgKiBAcGFyYW0ga2V5XHJcbiAgICovXHJcbiAgc2V0S2V5KGtleSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8geWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKGtleSkgOiB5aWVsZCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoa2V5KTtcclxuICAgICAgdGhpcy5vblNldEVuY3J5cHRpb25LZXkoZGVyaXZlZEtleSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XHJcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xyXG4gICAgdGhpcy5uYW1lID0gJ0xpdmVLaXRFcnJvcic7XHJcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gIH1cclxufVxyXG52YXIgQ29ubmVjdGlvbkVycm9yUmVhc29uO1xyXG4oZnVuY3Rpb24gKENvbm5lY3Rpb25FcnJvclJlYXNvbikge1xyXG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJOb3RBbGxvd2VkXCJdID0gMF0gPSBcIk5vdEFsbG93ZWRcIjtcclxuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiU2VydmVyVW5yZWFjaGFibGVcIl0gPSAxXSA9IFwiU2VydmVyVW5yZWFjaGFibGVcIjtcclxuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiSW50ZXJuYWxFcnJvclwiXSA9IDJdID0gXCJJbnRlcm5hbEVycm9yXCI7XHJcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkNhbmNlbGxlZFwiXSA9IDNdID0gXCJDYW5jZWxsZWRcIjtcclxuICBDb25uZWN0aW9uRXJyb3JSZWFzb25bQ29ubmVjdGlvbkVycm9yUmVhc29uW1wiTGVhdmVSZXF1ZXN0XCJdID0gNF0gPSBcIkxlYXZlUmVxdWVzdFwiO1xyXG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJUaW1lb3V0XCJdID0gNV0gPSBcIlRpbWVvdXRcIjtcclxufSkoQ29ubmVjdGlvbkVycm9yUmVhc29uIHx8IChDb25uZWN0aW9uRXJyb3JSZWFzb24gPSB7fSkpO1xyXG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbiwgc3RhdHVzLCBjb250ZXh0KSB7XHJcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0aW9uRXJyb3InO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSBDb25uZWN0aW9uRXJyb3JSZWFzb25bcmVhc29uXTtcclxuICB9XHJcbn1cclxuY2xhc3MgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgc3VwZXIoMjEsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcclxuICAgIHRoaXMubmFtZSA9ICdEZXZpY2VVbnN1cHBvcnRlZEVycm9yJztcclxuICB9XHJcbn1cclxuY2xhc3MgVHJhY2tJbnZhbGlkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgIHN1cGVyKDIwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndHJhY2sgaXMgaW52YWxpZCcpO1xyXG4gICAgdGhpcy5uYW1lID0gJ1RyYWNrSW52YWxpZEVycm9yJztcclxuICB9XHJcbn1cclxuY2xhc3MgVW5zdXBwb3J0ZWRTZXJ2ZXIgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcclxuICAgIHN1cGVyKDEwLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5zdXBwb3J0ZWQgc2VydmVyJyk7XHJcbiAgICB0aGlzLm5hbWUgPSAnVW5zdXBwb3J0ZWRTZXJ2ZXInO1xyXG4gIH1cclxufVxyXG5jbGFzcyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICBzdXBlcigxMiwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xyXG4gICAgdGhpcy5uYW1lID0gJ1VuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUnO1xyXG4gIH1cclxufVxyXG5jbGFzcyBOZWdvdGlhdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICBzdXBlcigxMywgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcclxuICAgIHRoaXMubmFtZSA9ICdOZWdvdGlhdGlvbkVycm9yJztcclxuICB9XHJcbn1cclxuY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgc3VwZXIoMTQsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bmFibGUgdG8gcHVibGlzaCBkYXRhJyk7XHJcbiAgICB0aGlzLm5hbWUgPSAnUHVibGlzaERhdGFFcnJvcic7XHJcbiAgfVxyXG59XHJcbmNsYXNzIFB1Ymxpc2hUcmFja0Vycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMpIHtcclxuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcclxuICAgIHRoaXMubmFtZSA9ICdQdWJsaXNoVHJhY2tFcnJvcic7XHJcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcclxuICB9XHJcbn1cclxuY2xhc3MgU2lnbmFsUmVxdWVzdEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZWFzb24pIHtcclxuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcclxuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xyXG4gICAgdGhpcy5yZWFzb25OYW1lID0gdHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycgPyByZWFzb24gOiBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uW3JlYXNvbl07XHJcbiAgfVxyXG59XHJcbnZhciBNZWRpYURldmljZUZhaWx1cmU7XHJcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XHJcbiAgLy8gdXNlciByZWplY3RlZCBwZXJtaXNzaW9uc1xyXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIlBlcm1pc3Npb25EZW5pZWRcIl0gPSBcIlBlcm1pc3Npb25EZW5pZWRcIjtcclxuICAvLyBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZVxyXG4gIE1lZGlhRGV2aWNlRmFpbHVyZVtcIk5vdEZvdW5kXCJdID0gXCJOb3RGb3VuZFwiO1xyXG4gIC8vIGRldmljZSBpcyBpbiB1c2UuIE9uIFdpbmRvd3MsIG9ubHkgYSBzaW5nbGUgdGFiIG1heSBnZXQgYWNjZXNzIHRvIGEgZGV2aWNlIGF0IGEgdGltZS5cclxuICBNZWRpYURldmljZUZhaWx1cmVbXCJEZXZpY2VJblVzZVwiXSA9IFwiRGV2aWNlSW5Vc2VcIjtcclxuICBNZWRpYURldmljZUZhaWx1cmVbXCJPdGhlclwiXSA9IFwiT3RoZXJcIjtcclxufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xyXG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xyXG4gIGZ1bmN0aW9uIGdldEZhaWx1cmUoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnRGV2aWNlc05vdEZvdW5kRXJyb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5Ob3RGb3VuZDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicpIHtcclxuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLlBlcm1pc3Npb25EZW5pZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xyXG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5PdGhlcjtcclxuICAgIH1cclxuICB9XHJcbiAgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUgPSBnZXRGYWlsdXJlO1xyXG59KShNZWRpYURldmljZUZhaWx1cmUgfHwgKE1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XHJcblxyXG52YXIgQ3J5cHRvckVycm9yUmVhc29uO1xyXG4oZnVuY3Rpb24gKENyeXB0b3JFcnJvclJlYXNvbikge1xyXG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJJbnZhbGlkS2V5XCJdID0gMF0gPSBcIkludmFsaWRLZXlcIjtcclxuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiTWlzc2luZ0tleVwiXSA9IDFdID0gXCJNaXNzaW5nS2V5XCI7XHJcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIkludGVybmFsRXJyb3JcIl0gPSAyXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xyXG59KShDcnlwdG9yRXJyb3JSZWFzb24gfHwgKENyeXB0b3JFcnJvclJlYXNvbiA9IHt9KSk7XHJcbmNsYXNzIENyeXB0b3JFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xyXG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ3J5cHRvckVycm9yUmVhc29uLkludGVybmFsRXJyb3I7XHJcbiAgICBsZXQgcGFydGljaXBhbnRJZGVudGl0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xyXG4gICAgc3VwZXIoNDAsIG1lc3NhZ2UpO1xyXG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XHJcbiAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV2ZW50cyBhcmUgdGhlIHByaW1hcnkgd2F5IExpdmVLaXQgbm90aWZpZXMgeW91ciBhcHBsaWNhdGlvbiBvZiBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIGFyZSBldmVudHMgZW1pdHRlZCBieSBbW1Jvb21dXSwgbGlzdGVuIHRvIHJvb20gZXZlbnRzIGxpa2VcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiByb29tLm9uKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpID0+IHt9KVxyXG4gKiBgYGBcclxuICovXHJcbnZhciBSb29tRXZlbnQ7XHJcbihmdW5jdGlvbiAoUm9vbUV2ZW50KSB7XHJcbiAgLyoqXHJcbiAgICogV2hlbiB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xyXG4gICAqIHRvIHJlY29ubmVjdC5cclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gdGhlIHNpZ25hbCBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQuIFRoaXMgaXNuJ3Qgbm90aWNlYWJsZSB0byB1c2VycyBtb3N0IG9mIHRoZSB0aW1lLlxyXG4gICAqIEl0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYFJvb21FdmVudC5SZWNvbm5lY3RlZGAgb25jZSB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWQuXHJcbiAgICogSWYgbWVkaWEgZmFpbHMgYWRkaXRpb25hbGx5IGl0IGFuIGFkZGl0aW9uYWwgYFJvb21FdmVudC5SZWNvbm5lY3RpbmdgIHdpbGwgYmUgZW1pdHRlZC5cclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xyXG4gIC8qKlxyXG4gICAqIEZpcmVzIHdoZW4gYSByZWNvbm5lY3Rpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bC5cclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RlZFwiXSA9IFwicmVjb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcclxuICAgKiB3aGVuIGFuIHVucmVjb3ZlcmFibGUgY29ubmVjdGlvbiBpc3N1ZSBoYWQgb2NjdXJlZC5cclxuICAgKlxyXG4gICAqIERpc2Nvbm5lY3RSZWFzb24gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoeSB0aGUgcGFydGljaXBhbnQgd2FzIGRpc2Nvbm5lY3RlZC4gTm90YWJsZSByZWFzb25zIGFyZVxyXG4gICAqIC0gRFVQTElDQVRFX0lERU5USVRZOiBhbm90aGVyIGNsaWVudCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5IGhhcyBqb2luZWQgdGhlIHJvb21cclxuICAgKiAtIFBBUlRJQ0lQQU5UX1JFTU9WRUQ6IHBhcnRpY2lwYW50IHdhcyByZW1vdmVkIGJ5IFJlbW92ZVBhcnRpY2lwYW50IEFQSVxyXG4gICAqIC0gUk9PTV9ERUxFVEVEOiB0aGUgcm9vbSBoYXMgZW5kZWQgdmlhIERlbGV0ZVJvb20gQVBJXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tEaXNjb25uZWN0UmVhc29uXV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tDb25uZWN0aW9uU3RhdGVdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBwYXJ0aWNpcGFudCBoYXMgYmVlbiBtb3ZlZCB0byBhIGRpZmZlcmVudCByb29tIGJ5IHRoZSBzZXJ2aWNlIHJlcXVlc3QuXHJcbiAgICogVGhlIGJlaGF2aW9yIGxvb2tzIGxpa2UgdGhlIHBhcnRpY2lwYW50IGhhcyBiZWVuIGRpc2Nvbm5lY3RlZCBhbmQgcmVjb25uZWN0ZWQgdG8gYSBkaWZmZXJlbnQgcm9vbVxyXG4gICAqIHNlYW1sZXNzbHkgd2l0aG91dCBjb25uZWN0aW9uIHN0YXRlIHRyYW5zaXRpb24uXHJcbiAgICogQSBuZXcgdG9rZW4gd2lsbCBiZSBwcm92aWRlZCBmb3IgcmVjb25uZWN0aW5nIHRvIHRoZSBuZXcgcm9vbSBpZiBuZWVkZWQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tyb29tOiBzdHJpbmcsIHRva2VuOiBzdHJpbmddXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJNb3ZlZFwiXSA9IFwibW92ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJNZWRpYURldmljZXNDaGFuZ2VkXCJdID0gXCJtZWRpYURldmljZXNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBqb2lucyAqYWZ0ZXIqIHRoZSBsb2NhbFxyXG4gICAqIHBhcnRpY2lwYW50LiBJdCB3aWxsIG5vdCBlbWl0IGV2ZW50cyBmb3IgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFscmVhZHlcclxuICAgKiBpbiB0aGUgcm9vbVxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudENvbm5lY3RlZFwiXSA9IFwicGFydGljaXBhbnRDb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxyXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCJdID0gXCJwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcclxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXHJcbiAgICpcclxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXHJcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogVGhlIFtbTG9jYWxQYXJ0aWNpcGFudF1dIGhhcyBzdWJzY3JpYmVkIHRvIGEgbmV3IHRyYWNrLiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKlxyXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmliZWRcIl0gPSBcInRyYWNrU3Vic2NyaWJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xyXG4gICAqXHJcbiAgICogYXJnczogKHRyYWNrIHNpZCwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1VucHVibGlzaGVkXCJdID0gXCJ0cmFja1VucHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXHJcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrVW5zdWJzY3JpYmVkXCJdID0gXCJ0cmFja1Vuc3Vic2NyaWJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrTXV0ZWRcIl0gPSBcInRyYWNrTXV0ZWRcIjtcclxuICAvKipcclxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcclxuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXHJcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cclxuICAgKlxyXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXHJcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXHJcbiAgICogb24gdGhhdCB0cmFjayBhbmQgZW1pdHMgdGhlIExvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQgZXZlbnQgaW4gdGhhdCBjYXNlLlxyXG4gICAqIFRoaXMgYWxsb3dzIGZvciBhcHBsaWNhdGlvbnMgdG8gc2hvdyBVSSBpbmZvcm1pbmcgdXNlcnMgdGhhdCB0aGV5IG1pZ2h0IGhhdmUgdG9cclxuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZFwiXSA9IFwibG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEFjdGl2ZSBzcGVha2VycyBjaGFuZ2VkLiBMaXN0IG9mIHNwZWFrZXJzIGFyZSBvcmRlcmVkIGJ5IHRoZWlyIGF1ZGlvIGxldmVsLlxyXG4gICAqIGxvdWRlc3Qgc3BlYWtlcnMgZmlyc3QuIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBMb2NhbFBhcnRpY2lwYW50IHRvby5cclxuICAgKlxyXG4gICAqIFNwZWFrZXIgdXBkYXRlcyBhcmUgc2VudCBvbmx5IHRvIHRoZSBwdWJsaXNoaW5nIHBhcnRpY2lwYW50IGFuZCB0aGVpciBzdWJzY3JpYmVycy5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwiYWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXHJcbiAgICogYWxsIHVzZXJzLlxyXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xyXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxyXG4gICAqXHJcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXHJcbiAgICpcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXHJcbiAgICpcclxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXHJcbiAgICpcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xyXG4gICAqIGFsbCB1c2Vycy5cclxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlcyBhbmQgdGhlIHBhcnRpY2lwYW50XHJcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHBhcnRpY2lwYW50J3Mgc3RhdGUgY2hhbmdlcyB0byBBQ1RJVkUgYW5kIGlzIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBkYXRhIG1lc3NhZ2VzXHJcbiAgICpcclxuICAgKiBhcmdzOiAocGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEFjdGl2ZVwiXSA9IFwicGFydGljaXBhbnRBY3RpdmVcIjtcclxuICAvKipcclxuICAgKiBSb29tIG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xyXG4gICAqIGFsbCB1c2Vycy5cclxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxyXG4gICAqICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoc3RyaW5nKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlJvb21NZXRhZGF0YUNoYW5nZWRcIl0gPSBcInJvb21NZXRhZGF0YUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cclxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cclxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dLCB0b3BpYz86IHN0cmluZylcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJEYXRhUmVjZWl2ZWRcIl0gPSBcImRhdGFSZWNlaXZlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFNJUCBEVE1GIHRvbmVzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBkdG1mOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlNpcERUTUZSZWNlaXZlZFwiXSA9IFwic2lwRFRNRlJlY2VpdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIGEgcGFydGljaXBhbnQncyB0cmFjay5cclxuICAgKiBAYmV0YVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcclxuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxyXG4gICAqIHN1YnNjcmliZWQgdG8uXHJcbiAgICpcclxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgKHJlbW90ZSkgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcclxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXHJcbiAgICpcclxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXHJcbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSxcclxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcclxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXHJcbiAgICogYmUgZW1pdHRlZC5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxyXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzXV0sXHJcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHN0YXR1cyBmb3IgdGhlIGN1cnJlbnRcclxuICAgKiBwYXJ0aWNpcGFudC5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxyXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcclxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCBhdWRpbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cclxuICAgKiBhdWRpbyBlbGVtZW50cy4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXHJcbiAgICogYFJvb20uY2FuUGxheWJhY2tBdWRpb2Agd2lsbCBpbmRpY2F0ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBwZXJtaXR0ZWQuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIHZpZGVvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xyXG4gICAqIGEgdmlkZW8gZWxlbWVudC4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXHJcbiAgICogQ2FsbGluZyBgcm9vbS5zdGFydFZpZGVvKClgIGluIGEgdXNlciBnZXN0dXJlIGV2ZW50IGhhbmRsZXIgd2lsbCByZXN1bWUgdGhlIHZpZGVvIHBsYXliYWNrLlxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJ2aWRlb1BsYXliYWNrQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxyXG4gICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cclxuICAgKiBVc2UgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUoZXJyb3IpIHRvIGdldCB0aGUgcmVhc29uIG9mIGZhaWx1cmUuXHJcbiAgICogW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RDYW1lcmFFcnJvcl1dIGFuZCBbW0xvY2FsUGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvcl1dXHJcbiAgICogd2lsbCBpbmRpY2F0ZSBpZiBpdCBoYWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiTWVkaWFEZXZpY2VzRXJyb3JcIl0gPSBcIm1lZGlhRGV2aWNlc0Vycm9yXCI7XHJcbiAgLyoqXHJcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuXHJcbiAgICogYXJnczogKHByZXZQZXJtaXNzaW9uczogW1tQYXJ0aWNpcGFudFBlcm1pc3Npb25dXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBTaWduYWwgY29ubmVjdGVkLCBjYW4gcHVibGlzaCB0cmFja3MuXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiU2lnbmFsQ29ubmVjdGVkXCJdID0gXCJzaWduYWxDb25uZWN0ZWRcIjtcclxuICAvKipcclxuICAgKiBSZWNvcmRpbmcgb2YgYSByb29tIGhhcyBzdGFydGVkL3N0b3BwZWQuIFJvb20uaXNSZWNvcmRpbmcgd2lsbCBiZSB1cGRhdGVkIHRvby5cclxuICAgKiBhcmdzOiAoaXNSZWNvcmRpbmc6IGJvb2xlYW4pXHJcbiAgICovXHJcbiAgUm9vbUV2ZW50W1wiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiXSA9IFwicmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiO1xyXG4gIFJvb21FdmVudFtcIlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWRcIjtcclxuICBSb29tRXZlbnRbXCJFbmNyeXB0aW9uRXJyb3JcIl0gPSBcImVuY3J5cHRpb25FcnJvclwiO1xyXG4gIC8qKlxyXG4gICAqIEVtaXRzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGJ1ZmZlciBzdGF0dXMgb2YgYSBkYXRhIGNoYW5uZWwgY2hhbmdlc1xyXG4gICAqIGFyZ3M6IChpc0xvdzogYm9vbGVhbiwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWRcIl0gPSBcImRjQnVmZmVyU3RhdHVzQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJlZCBieSBhIGNhbGwgdG8gcm9vbS5zd2l0Y2hBY3RpdmVEZXZpY2VcclxuICAgKiBhcmdzOiAoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nKVxyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkFjdGl2ZURldmljZUNoYW5nZWRcIl0gPSBcImFjdGl2ZURldmljZUNoYW5nZWRcIjtcclxuICBSb29tRXZlbnRbXCJDaGF0TWVzc2FnZVwiXSA9IFwiY2hhdE1lc3NhZ2VcIjtcclxuICAvKipcclxuICAgKiBmaXJlZCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIGxvY2FsUGFydGljaXBhbnQncyB0cmFja1xyXG4gICAqL1xyXG4gIFJvb21FdmVudFtcIkxvY2FsVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJsb2NhbFRyYWNrU3Vic2NyaWJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIGZpcmVkIHdoZW4gdGhlIGNsaWVudCByZWNlaXZlcyBjb25uZWN0aW9uIG1ldHJpY3MgZnJvbSBvdGhlciBwYXJ0aWNpcGFudHNcclxuICAgKi9cclxuICBSb29tRXZlbnRbXCJNZXRyaWNzUmVjZWl2ZWRcIl0gPSBcIm1ldHJpY3NSZWNlaXZlZFwiO1xyXG59KShSb29tRXZlbnQgfHwgKFJvb21FdmVudCA9IHt9KSk7XHJcbnZhciBQYXJ0aWNpcGFudEV2ZW50O1xyXG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcclxuICAvKipcclxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXHJcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxyXG4gICAqXHJcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xyXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxyXG4gICAqIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaWJlZFwiXSA9IFwidHJhY2tTdWJzY3JpYmVkXCI7XHJcbiAgLyoqXHJcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXHJcbiAgICpcclxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcclxuICAvKipcclxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xyXG4gICAqXHJcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1VucHVibGlzaGVkXCJdID0gXCJ0cmFja1VucHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXHJcbiAgICogZXZlbnQgYW5kIGVuc3VyZSB0aGV5IGRldGFjaCB0cmFja3MuXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxyXG4gICAqXHJcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXHJcbiAgICpcclxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3dcclxuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXHJcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cclxuICAgKlxyXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXHJcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcImxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiO1xyXG4gIC8qKlxyXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xyXG4gICAqIGFsbCB1c2Vycy5cclxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcclxuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cclxuICAgKiBUbyBhY2Nlc3MgdGhlIGN1cnJlbnQgbWV0YWRhdGEsIHNlZSBbW1BhcnRpY2lwYW50Lm1ldGFkYXRhXV0uXHJcbiAgICpcclxuICAgKiBhcmdzOiAocHJldk1ldGFkYXRhOiBzdHJpbmcpXHJcbiAgICpcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxyXG4gICAqXHJcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50TmFtZUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXHJcbiAgICogRGF0YSBwYWNrZXRzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIHVzZSBMaXZlS2l0IHRvIHNlbmQvcmVjZWl2ZSBhcmJpdHJhcnkgcGF5bG9hZHMuXHJcbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXHJcbiAgICpcclxuICAgKiBhcmdzOiAocGF5bG9hZDogVWludDhBcnJheSwga2luZDogW1tEYXRhUGFja2V0X0tpbmRdXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcclxuICAvKipcclxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxyXG4gICAqXHJcbiAgICogYXJnczogKGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlNpcERUTUZSZWNlaXZlZFwiXSA9IFwic2lwRFRNRlJlY2VpdmVkXCI7XHJcbiAgLyoqXHJcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgZGF0YSBzb3VyY2UuXHJcbiAgICogQGJldGFcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcclxuICAvKipcclxuICAgKiBIYXMgc3BlYWtpbmcgc3RhdHVzIGNoYW5nZWQgZm9yIHRoZSBjdXJyZW50IHBhcnRpY2lwYW50XHJcbiAgICpcclxuICAgKiBhcmdzOiAoc3BlYWtpbmc6IGJvb2xlYW4pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXHJcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcclxuICAgKiBzdWJzY3JpYmVkIHRvLlxyXG4gICAqXHJcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XHJcbiAgLyoqXHJcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxyXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcclxuICAgKlxyXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cclxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcclxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXHJcbiAgICogYmUgZW1pdHRlZC5cclxuICAgKlxyXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxyXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSlcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xyXG4gIC8qKlxyXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXHJcbiAgICpcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcclxuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcclxuICAvKiogQGludGVybmFsICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xyXG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXVkaW9TdHJlYW1BY3F1aXJlZFwiXSA9IFwiYXVkaW9TdHJlYW1BY3F1aXJlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxyXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0pXHJcbiAgICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiUENUcmFja0FkZGVkXCJdID0gXCJwY1RyYWNrQWRkZWRcIjtcclxuICAvKipcclxuICAgKiBQYXJ0aWNpcGFudCBhdHRyaWJ1dGVzIGlzIGFuIGFwcC1zcGVjaWZpYyBrZXkgdmFsdWUgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXHJcbiAgICogYWxsIHVzZXJzLlxyXG4gICAqIFdoZW4gYSBwYXJ0aWNpcGFudCdzIGF0dHJpYnV0ZXMgY2hhbmdlZCwgdGhpcyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzXHJcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dKVxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJBdHRyaWJ1dGVzQ2hhbmdlZFwiXSA9IFwiYXR0cmlidXRlc0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBmaXJlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCBvbmx5LCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIHRyYWNrIHNwZWNpZmllZCBpbiB0aGUgcGF5bG9hZFxyXG4gICAqL1xyXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrU3Vic2NyaWJlZFwiXSA9IFwibG9jYWxUcmFja1N1YnNjcmliZWRcIjtcclxuICAvKiogb25seSBlbWl0dGVkIG9uIGxvY2FsIHBhcnRpY2lwYW50ICovXHJcbiAgUGFydGljaXBhbnRFdmVudFtcIkNoYXRNZXNzYWdlXCJdID0gXCJjaGF0TWVzc2FnZVwiO1xyXG4gIC8qKlxyXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgcGFydGljaXBhbnQncyBzdGF0ZSBjaGFuZ2VzIHRvIEFDVElWRSBhbmQgaXMgcmVhZHkgdG8gc2VuZC9yZWNlaXZlIGRhdGEgbWVzc2FnZXNcclxuICAgKi9cclxuICBQYXJ0aWNpcGFudEV2ZW50W1wiQWN0aXZlXCJdID0gXCJhY3RpdmVcIjtcclxufSkoUGFydGljaXBhbnRFdmVudCB8fCAoUGFydGljaXBhbnRFdmVudCA9IHt9KSk7XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxudmFyIEVuZ2luZUV2ZW50O1xyXG4oZnVuY3Rpb24gKEVuZ2luZUV2ZW50KSB7XHJcbiAgRW5naW5lRXZlbnRbXCJUcmFuc3BvcnRzQ3JlYXRlZFwiXSA9IFwidHJhbnNwb3J0c0NyZWF0ZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJEaXNjb25uZWN0ZWRcIl0gPSBcImRpc2Nvbm5lY3RlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1pbmdcIl0gPSBcInJlc3VtaW5nXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSZXN1bWVkXCJdID0gXCJyZXN1bWVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0aW5nXCJdID0gXCJyZXN0YXJ0aW5nXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdW1lZFwiXSA9IFwic2lnbmFsUmVzdW1lZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVzdGFydGVkXCJdID0gXCJzaWduYWxSZXN0YXJ0ZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcclxuICBFbmdpbmVFdmVudFtcIk1lZGlhVHJhY2tBZGRlZFwiXSA9IFwibWVkaWFUcmFja0FkZGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJBY3RpdmVTcGVha2Vyc1VwZGF0ZVwiXSA9IFwiYWN0aXZlU3BlYWtlcnNVcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIkRhdGFQYWNrZXRSZWNlaXZlZFwiXSA9IFwiZGF0YVBhY2tldFJlY2VpdmVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSVFBWaWRlb01hcFVwZGF0ZVwiXSA9IFwicnRwVmlkZW9NYXBVcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIkRDQnVmZmVyU3RhdHVzQ2hhbmdlZFwiXSA9IFwiZGNCdWZmZXJTdGF0dXNDaGFuZ2VkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJQYXJ0aWNpcGFudFVwZGF0ZVwiXSA9IFwicGFydGljaXBhbnRVcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIlJvb21VcGRhdGVcIl0gPSBcInJvb21VcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIlNwZWFrZXJzQ2hhbmdlZFwiXSA9IFwic3BlYWtlcnNDaGFuZ2VkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInN0cmVhbVN0YXRlQ2hhbmdlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlVcGRhdGVcIl0gPSBcImNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJTdWJzY3JpcHRpb25FcnJvclwiXSA9IFwic3Vic2NyaXB0aW9uRXJyb3JcIjtcclxuICBFbmdpbmVFdmVudFtcIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcclxuICBFbmdpbmVFdmVudFtcIlJlbW90ZU11dGVcIl0gPSBcInJlbW90ZU11dGVcIjtcclxuICBFbmdpbmVFdmVudFtcIlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCJdID0gXCJzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcclxuICBFbmdpbmVFdmVudFtcIkxvY2FsVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJsb2NhbFRyYWNrU3Vic2NyaWJlZFwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiT2ZmbGluZVwiXSA9IFwib2ZmbGluZVwiO1xyXG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVxdWVzdFJlc3BvbnNlXCJdID0gXCJzaWduYWxSZXF1ZXN0UmVzcG9uc2VcIjtcclxuICBFbmdpbmVFdmVudFtcIlNpZ25hbENvbm5lY3RlZFwiXSA9IFwic2lnbmFsQ29ubmVjdGVkXCI7XHJcbiAgRW5naW5lRXZlbnRbXCJSb29tTW92ZWRcIl0gPSBcInJvb21Nb3ZlZFwiO1xyXG59KShFbmdpbmVFdmVudCB8fCAoRW5naW5lRXZlbnQgPSB7fSkpO1xyXG52YXIgVHJhY2tFdmVudDtcclxuKGZ1bmN0aW9uIChUcmFja0V2ZW50KSB7XHJcbiAgVHJhY2tFdmVudFtcIk1lc3NhZ2VcIl0gPSBcIm1lc3NhZ2VcIjtcclxuICBUcmFja0V2ZW50W1wiTXV0ZWRcIl0gPSBcIm11dGVkXCI7XHJcbiAgVHJhY2tFdmVudFtcIlVubXV0ZWRcIl0gPSBcInVubXV0ZWRcIjtcclxuICAvKipcclxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlJlc3RhcnRlZFwiXSA9IFwicmVzdGFydGVkXCI7XHJcbiAgVHJhY2tFdmVudFtcIkVuZGVkXCJdID0gXCJlbmRlZFwiO1xyXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XHJcbiAgVHJhY2tFdmVudFtcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTZXR0aW5nc1wiXSA9IFwidXBkYXRlU2V0dGluZ3NcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIlVwZGF0ZVN1YnNjcmlwdGlvblwiXSA9IFwidXBkYXRlU3Vic2NyaXB0aW9uXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1BsYXliYWNrU3RhcnRlZFwiXSA9IFwiYXVkaW9QbGF5YmFja1N0YXJ0ZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIkF1ZGlvUGxheWJhY2tGYWlsZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tGYWlsZWRcIjtcclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsQXVkaW9UcmFjayBpbnN0YW5jZXNcclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiQXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIl0gPSBcImF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIFRyYWNrRXZlbnRbXCJWaXNpYmlsaXR5Q2hhbmdlZFwiXSA9IFwidmlzaWJpbGl0eUNoYW5nZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIlZpZGVvRGltZW5zaW9uc0NoYW5nZWRcIl0gPSBcInZpZGVvRGltZW5zaW9uc0NoYW5nZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIlZpZGVvUGxheWJhY2tTdGFydGVkXCJdID0gXCJ2aWRlb1BsYXliYWNrU3RhcnRlZFwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja0ZhaWxlZFwiXSA9IFwidmlkZW9QbGF5YmFja0ZhaWxlZFwiO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBUcmFja0V2ZW50W1wiRWxlbWVudEF0dGFjaGVkXCJdID0gXCJlbGVtZW50QXR0YWNoZWRcIjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgVHJhY2tFdmVudFtcIkVsZW1lbnREZXRhY2hlZFwiXSA9IFwiZWxlbWVudERldGFjaGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJVcHN0cmVhbVBhdXNlZFwiXSA9IFwidXBzdHJlYW1QYXVzZWRcIjtcclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlVwc3RyZWFtUmVzdW1lZFwiXSA9IFwidXBzdHJlYW1SZXN1bWVkXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwic3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcclxuICAvKipcclxuICAgKiBGaXJlcyBvbiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwic3Vic2NyaXB0aW9uRmFpbGVkXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlRyYWNrUHJvY2Vzc29yVXBkYXRlXCJdID0gXCJ0cmFja1Byb2Nlc3NvclVwZGF0ZVwiO1xyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZVwiXSA9IFwiYXVkaW9UcmFja0ZlYXR1cmVVcGRhdGVcIjtcclxuICAvKipcclxuICAgKiBAYmV0YVxyXG4gICAqL1xyXG4gIFRyYWNrRXZlbnRbXCJUcmFuc2NyaXB0aW9uUmVjZWl2ZWRcIl0gPSBcInRyYW5zY3JpcHRpb25SZWNlaXZlZFwiO1xyXG4gIC8qKlxyXG4gICAqIEBleHBlcmltZW50YWxcclxuICAgKi9cclxuICBUcmFja0V2ZW50W1wiVGltZVN5bmNVcGRhdGVcIl0gPSBcInRpbWVTeW5jVXBkYXRlXCI7XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgVHJhY2tFdmVudFtcIlByZUNvbm5lY3RCdWZmZXJGbHVzaGVkXCJdID0gXCJwcmVDb25uZWN0QnVmZmVyRmx1c2hlZFwiO1xyXG59KShUcmFja0V2ZW50IHx8IChUcmFja0V2ZW50ID0ge30pKTtcclxuXHJcbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlZENsb25lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgbm90IGEgcHJveHkgYnkgc3ByZWFkaW5nIGl0XHJcbiAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gdGlueSwgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXIvYmxvYi9tYXN0ZXIvc3JjL3BhcnNlci1icm93c2Vycy5qc1xyXG4vLyByZWR1Y2VkIHRvIG9ubHkgZGlmZmVyZW50aWF0ZSBDaHJvbWUoaXVtKSBiYXNlZCBicm93c2VycyAvIEZpcmVmb3ggLyBTYWZhcmlcclxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcclxubGV0IGJyb3dzZXJEZXRhaWxzO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCcm93c2VyKHVzZXJBZ2VudCkge1xyXG4gIGxldCBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcclxuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgdWEgPSAodXNlckFnZW50ICE9PSBudWxsICYmIHVzZXJBZ2VudCAhPT0gdm9pZCAwID8gdXNlckFnZW50IDogbmF2aWdhdG9yLnVzZXJBZ2VudCkudG9Mb3dlckNhc2UoKTtcclxuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xyXG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKF9yZWYgPT4ge1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIHRlc3RcclxuICAgICAgfSA9IF9yZWY7XHJcbiAgICAgIHJldHVybiB0ZXN0LnRlc3QodWEpO1xyXG4gICAgfSk7XHJcbiAgICBicm93c2VyRGV0YWlscyA9IGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5kZXNjcmliZSh1YSk7XHJcbiAgfVxyXG4gIHJldHVybiBicm93c2VyRGV0YWlscztcclxufVxyXG5jb25zdCBicm93c2Vyc0xpc3QgPSBbe1xyXG4gIHRlc3Q6IC9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pLFxyXG4gIGRlc2NyaWJlKHVhKSB7XHJcbiAgICBjb25zdCBicm93c2VyID0ge1xyXG4gICAgICBuYW1lOiAnRmlyZWZveCcsXHJcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcclxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2Z4aW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZCxcclxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJyb3dzZXI7XHJcbiAgfVxyXG59LCB7XHJcbiAgdGVzdDogL2Nocm9tfGNyaW9zfGNybW8vaSxcclxuICBkZXNjcmliZSh1YSkge1xyXG4gICAgY29uc3QgYnJvd3NlciA9IHtcclxuICAgICAgbmFtZTogJ0Nocm9tZScsXHJcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpjaHJvbWV8Y2hyb21pdW18Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcclxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NyaW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZCxcclxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJyb3dzZXI7XHJcbiAgfVxyXG59LCAvKiBTYWZhcmkgKi9cclxue1xyXG4gIHRlc3Q6IC9zYWZhcml8YXBwbGV3ZWJraXQvaSxcclxuICBkZXNjcmliZSh1YSkge1xyXG4gICAgY29uc3QgYnJvd3NlciA9IHtcclxuICAgICAgbmFtZTogJ1NhZmFyaScsXHJcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKGNvbW1vblZlcnNpb25JZGVudGlmaWVyLCB1YSksXHJcbiAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnLFxyXG4gICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSlcclxuICAgIH07XHJcbiAgICByZXR1cm4gYnJvd3NlcjtcclxuICB9XHJcbn1dO1xyXG5mdW5jdGlvbiBnZXRNYXRjaChleHAsIHVhKSB7XHJcbiAgbGV0IGlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xyXG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcclxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IGlkICYmIG1hdGNoW2lkXSB8fCAnJztcclxufVxyXG5mdW5jdGlvbiBnZXRPU1ZlcnNpb24odWEpIHtcclxuICByZXR1cm4gdWEuaW5jbHVkZXMoJ21hYyBvcycpID8gZ2V0TWF0Y2goL1xcKC4rPyhcXGQrX1xcZCsoOj9fXFxkKyk/KS8sIHVhLCAxKS5yZXBsYWNlKC9fL2csICcuJykgOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbnZhciB2ZXJzaW9uJDEgPSBcIjIuMTMuNVwiO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IHZlcnNpb24kMTtcclxuY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gMTY7XHJcblxyXG4vKipcclxuICogVGltZXJzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcclxuICogdGhhdCBlbnN1cmUgdGhhdCB0aGV5IGFyZSBmaXJlZC4gVGhlc2Ugc2hvdWxkIGJlIHVzZWQgd2hlbiBpdCBpcyBjcml0aWNhbFxyXG4gKiB0aGF0IHRoZSB0aW1lciBmaXJlcyBvbiB0aW1lLlxyXG4gKi9cclxuY2xhc3MgQ3JpdGljYWxUaW1lcnMge31cclxuQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gc2V0VGltZW91dCguLi5hcmd1bWVudHMpO1xyXG59O1xyXG5Dcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCA9XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXHJcbmZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gc2V0SW50ZXJ2YWwoLi4uYXJndW1lbnRzKTtcclxufTtcclxuQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBjbGVhclRpbWVvdXQoLi4uYXJndW1lbnRzKTtcclxufTtcclxuQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gY2xlYXJJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xyXG59O1xyXG5cclxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XHJcbi8vIGtlZXAgb2xkIGF1ZGlvIGVsZW1lbnRzIHdoZW4gZGV0YWNoZWQsIHdlIHdvdWxkIHJlLXVzZSB0aGVtIHNpbmNlIG9uIGlPU1xyXG4vLyBTYWZhcmkgdHJhY2tzIHdoaWNoIGF1ZGlvIGVsZW1lbnRzIGhhdmUgYmVlbiBcImJsZXNzZWRcIiBieSB0aGUgdXNlci5cclxuY29uc3QgcmVjeWNsZWRFbGVtZW50cyA9IFtdO1xyXG52YXIgVmlkZW9RdWFsaXR5O1xyXG4oZnVuY3Rpb24gKFZpZGVvUXVhbGl0eSkge1xyXG4gIFZpZGVvUXVhbGl0eVtWaWRlb1F1YWxpdHlbXCJMT1dcIl0gPSAwXSA9IFwiTE9XXCI7XHJcbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1FRElVTVwiXSA9IDFdID0gXCJNRURJVU1cIjtcclxuICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiSElHSFwiXSA9IDJdID0gXCJISUdIXCI7XHJcbn0pKFZpZGVvUXVhbGl0eSB8fCAoVmlkZW9RdWFsaXR5ID0ge30pKTtcclxuY2xhc3MgVHJhY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywga2luZCkge1xyXG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5pc011dGVkID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXHJcbiAgICAgKiBoYXMgYmVlbiBwYXVzZWQgYnkgY29uZ2VzdGlvbiBjb250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RyZWFtU3RhdGUgPSBUcmFjay5TdHJlYW1TdGF0ZS5BY3RpdmU7XHJcbiAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRUaW1lb3V0KSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYmFja2dyb3VuZFRpbWVvdXQpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGRlbGF5IGFwcCB2aXNpYmlsaXR5IHVwZGF0ZSBpZiBpdCBnb2VzIHRvIGhpZGRlblxyXG4gICAgICAvLyB1cGRhdGUgaW1tZWRpYXRlbHkgaWYgaXQgY29tZXMgYmFjayB0byBmb2N1c1xyXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSwgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5UcmFjayk7XHJcbiAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xyXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcclxuICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrID0gbWVkaWFUcmFjaztcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtSUQgPSBtZWRpYVRyYWNrLmlkO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcclxuICB9XHJcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2EgPSB0aGlzLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRoaXMpKTtcclxuICB9XHJcbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cclxuICBnZXQgY3VycmVudEJpdHJhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJpdHJhdGU7XHJcbiAgfVxyXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIHVzZWQgZm9yIGtlZXAgbWVkaWFTdHJlYW0ncyBmaXJzdCBpZCwgc2luY2UgaXQncyBpZCBtaWdodCBjaGFuZ2VcclxuICAgKiBpZiB3ZSBkaXNhYmxlL2VuYWJsZSBhIHRyYWNrXHJcbiAgICovXHJcbiAgZ2V0IG1lZGlhU3RyZWFtSUQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1JRDtcclxuICB9XHJcbiAgYXR0YWNoKGVsZW1lbnQpIHtcclxuICAgIGxldCBlbGVtZW50VHlwZSA9ICdhdWRpbyc7XHJcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICB0aGlzLmFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgIGlmIChlLnBhcmVudEVsZW1lbnQgPT09IG51bGwgJiYgIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHBvb2xcclxuICAgICAgICAgIHJlY3ljbGVkRWxlbWVudHMuc3BsaWNlKHJlY3ljbGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpIHtcclxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBldmVuIGlmIHdlIGJlbGlldmUgaXQncyBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50LCBpdCdzIHBvc3NpYmxlXHJcbiAgICAvLyB0aGUgZWxlbWVudCdzIHNyY09iamVjdCB3YXMgc2V0IHRvIHNvbWV0aGluZyBlbHNlIG91dCBvZiBiYW5kLlxyXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXHJcbiAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcclxuICAgIC8vIGhhbmRsZSBhdXRvIHBsYXliYWNrIGZhaWx1cmVzXHJcbiAgICBjb25zdCBhbGxNZWRpYVN0cmVhbVRyYWNrcyA9IGVsZW1lbnQuc3JjT2JqZWN0LmdldFRyYWNrcygpO1xyXG4gICAgY29uc3QgaGFzQXVkaW8gPSBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICdhdWRpbycpO1xyXG4gICAgLy8gbWFudWFsbHkgcGxheSBtZWRpYSB0byBkZXRlY3QgYXV0byBwbGF5YmFjayBzdGF0dXNcclxuICAgIGVsZW1lbnQucGxheSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCk7XHJcbiAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcclxuICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tGYWlsZWQsIGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgICAgLy8gY29tbW9ubHkgdHJpZ2dlcmVkIGJ5IGFub3RoZXIgYHBsYXlgIHJlcXVlc3QsIG9ubHkgbG9nIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwiXCIuY29uY2F0KGhhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbycsIFwiIHBsYXliYWNrIGFib3J0ZWQsIGxpa2VseSBkdWUgdG8gbmV3IHBsYXkgcmVxdWVzdFwiKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiY291bGQgbm90IHBsYXliYWNrIFwiLmNvbmNhdChoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nKSwgZSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgYXVkaW8gcGxheWJhY2sgaXNuJ3QgYWxsb3dlZCBtYWtlIHN1cmUgd2Ugc3RpbGwgcGxheSBiYWNrIHRoZSB2aWRlb1xyXG4gICAgICBpZiAoaGFzQXVkaW8gJiYgZWxlbWVudCAmJiBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICd2aWRlbycpICYmIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcclxuICAgICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcclxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAvLyBjYXRjaCBmb3IgU2FmYXJpLCBleGNlZWRlZCBvcHRpb25zIGF0IHRoaXMgcG9pbnQgdG8gYXV0b21hdGljYWxseSBwbGF5IHRoZSBtZWRpYSBlbGVtZW50XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudEF0dGFjaGVkLCBlbGVtZW50KTtcclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuICBkZXRhY2goZWxlbWVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gZGV0YWNoIGZyb20gYSBzaW5nbGUgZWxlbWVudFxyXG4gICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGV0YWNoZWQgPSBbXTtcclxuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxtID0+IHtcclxuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsbSk7XHJcbiAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xyXG4gICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxtKTtcclxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsbSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xyXG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcclxuICAgICAgcmV0dXJuIGRldGFjaGVkO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XHJcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICB9XHJcbiAgZW5hYmxlKCkge1xyXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gdHJ1ZTtcclxuICB9XHJcbiAgZGlzYWJsZSgpIHtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICBzdG9wTW9uaXRvcigpIHtcclxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xyXG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvckludGVydmFsKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnRpbWVTeW5jSGFuZGxlKSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudGltZVN5bmNIYW5kbGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgdXBkYXRlTG9nZ2VyT3B0aW9ucyhsb2dnZXJPcHRpb25zKSB7XHJcbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSB7XHJcbiAgICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2IpIHtcclxuICAgICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcclxuICAgIH1cclxuICB9XHJcbiAgcmVjeWNsZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XHJcbiAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byByZS11c2UgYSBzaW5nbGUgZWxlbWVudFxyXG4gICAgICBsZXQgc2hvdWxkQ2FjaGUgPSB0cnVlO1xyXG4gICAgICBlbGVtZW50LnBhdXNlKCk7XHJcbiAgICAgIHJlY3ljbGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgc2hvdWxkQ2FjaGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcclxuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcclxuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwucGxheSgpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgIC8qKiBjYXRjaCBjbGF1c2UgbmVjZXNzYXJ5IGZvciBTYWZhcmkgKi9cclxuICAgICAgICB9KSksIDApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xyXG4gICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XHJcbiAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrLCBlbGVtZW50KSB7XHJcbiAgbGV0IG1lZGlhU3RyZWFtO1xyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XHJcbiAgICBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gIH1cclxuICAvLyBjaGVjayBpZiB0cmFjayBtYXRjaGVzIGV4aXN0aW5nIHRyYWNrXHJcbiAgbGV0IGV4aXN0aW5nVHJhY2tzO1xyXG4gIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XHJcbiAgICBleGlzdGluZ1RyYWNrcyA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcclxuICB9XHJcbiAgaWYgKCFleGlzdGluZ1RyYWNrcy5pbmNsdWRlcyh0cmFjaykpIHtcclxuICAgIGV4aXN0aW5nVHJhY2tzLmZvckVhY2goZXQgPT4ge1xyXG4gICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhldCk7XHJcbiAgICB9KTtcclxuICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcclxuICB9XHJcbiAgaWYgKCFpc1NhZmFyaSgpIHx8ICEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XHJcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcclxuICAgIC8vIHdoZW4gYSB2aWRlbyBzdGFydHMgdGhhdCBoYXMgdGhlIGBhdXRvcGxheWAgYXR0cmlidXRlIGlzIHNldC5cclxuICAgIC8vIHdlIHdvcmsgYXJvdW5kIHRoaXMgYnkgX25vdF8gc2V0dGluZyB0aGUgYXV0b3BsYXkgYXR0cmlidXRlIG9uIHNhZmFyaSBhbmQgaW5zdGVhZCBjYWxsIGBzZXRUaW1lb3V0KCgpID0+IGVsLnBsYXkoKSwwKWAgZnVydGhlciBkb3duXHJcbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcclxuICB9XHJcbiAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgbm8gYXVkaW8gdHJhY2tzIHByZXNlbnQgb24gdGhlIG1lZGlhc3RyZWFtLCB3ZSBzZXQgdGhlIGVsZW1lbnQgYXMgbXV0ZWQgdG8gZW5zdXJlIGF1dG9wbGF5IHdvcmtzXHJcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xyXG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XHJcbiAgfVxyXG4gIC8vIGF2b2lkIGZsaWNrZXJcclxuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgIT09IG1lZGlhU3RyZWFtKSB7XHJcbiAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xyXG4gICAgaWYgKChpc1NhZmFyaSgpIHx8IGlzRmlyZUZveCgpKSAmJiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xyXG4gICAgICAvLyBGaXJlZm94IGFsc28gaGFzIGEgdGltaW5nIGlzc3VlIHdoZXJlIHZpZGVvIGRvZXNuJ3QgYWN0dWFsbHkgZ2V0IGF0dGFjaGVkIHVubGVzc1xyXG4gICAgICAvLyBwZXJmb3JtZWQgb3V0LW9mLWJhbmRcclxuICAgICAgLy8gU2FmYXJpIDE1IGhhcyBhIGJ1ZyB3aGVyZSBpbiBjZXJ0YWluIGxheW91dHMsIHZpZGVvIGVsZW1lbnQgcmVuZGVyc1xyXG4gICAgICAvLyBibGFjayB1bnRpbCB0aGUgcGFnZSBpcyByZXNpemVkIG9yIG90aGVyIGNoYW5nZXMgdGFrZSBwbGFjZS5cclxuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBzcmMgdHJpZ2dlcnMgaXQgdG8gcmVuZGVyLlxyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9ydW1zL3RocmVhZC82OTA1MjNcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcclxuICAgICAgICAvLyBTYWZhcmkgMTUgc29tZXRpbWVzIGZhaWxzIHRvIHN0YXJ0IGEgdmlkZW9cclxuICAgICAgICAvLyB3aGVuIHRoZSB3aW5kb3cgaXMgYmFja2dyb3VuZGVkIGJlZm9yZSB0aGUgZmlyc3QgZnJhbWUgaXMgZHJhd25cclxuICAgICAgICAvLyBtYW51YWxseSBjYWxsaW5nIHBsYXkgaGVyZSBzZWVtcyB0byBmaXggdGhhdFxyXG4gICAgICAgIGVsZW1lbnQucGxheSgpLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgIC8qKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIGRldGFjaFRyYWNrKHRyYWNrLCBlbGVtZW50KSB7XHJcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcclxuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XHJcbiAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XHJcbiAgICBpZiAobWVkaWFTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4oZnVuY3Rpb24gKFRyYWNrKSB7XHJcbiAgbGV0IEtpbmQ7XHJcbiAgKGZ1bmN0aW9uIChLaW5kKSB7XHJcbiAgICBLaW5kW1wiQXVkaW9cIl0gPSBcImF1ZGlvXCI7XHJcbiAgICBLaW5kW1wiVmlkZW9cIl0gPSBcInZpZGVvXCI7XHJcbiAgICBLaW5kW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xyXG4gIH0pKEtpbmQgPSBUcmFjay5LaW5kIHx8IChUcmFjay5LaW5kID0ge30pKTtcclxuICBsZXQgU291cmNlO1xyXG4gIChmdW5jdGlvbiAoU291cmNlKSB7XHJcbiAgICBTb3VyY2VbXCJDYW1lcmFcIl0gPSBcImNhbWVyYVwiO1xyXG4gICAgU291cmNlW1wiTWljcm9waG9uZVwiXSA9IFwibWljcm9waG9uZVwiO1xyXG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVcIl0gPSBcInNjcmVlbl9zaGFyZVwiO1xyXG4gICAgU291cmNlW1wiU2NyZWVuU2hhcmVBdWRpb1wiXSA9IFwic2NyZWVuX3NoYXJlX2F1ZGlvXCI7XHJcbiAgICBTb3VyY2VbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XHJcbiAgfSkoU291cmNlID0gVHJhY2suU291cmNlIHx8IChUcmFjay5Tb3VyY2UgPSB7fSkpO1xyXG4gIGxldCBTdHJlYW1TdGF0ZSQxO1xyXG4gIChmdW5jdGlvbiAoU3RyZWFtU3RhdGUpIHtcclxuICAgIFN0cmVhbVN0YXRlW1wiQWN0aXZlXCJdID0gXCJhY3RpdmVcIjtcclxuICAgIFN0cmVhbVN0YXRlW1wiUGF1c2VkXCJdID0gXCJwYXVzZWRcIjtcclxuICAgIFN0cmVhbVN0YXRlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xyXG4gIH0pKFN0cmVhbVN0YXRlJDEgPSBUcmFjay5TdHJlYW1TdGF0ZSB8fCAoVHJhY2suU3RyZWFtU3RhdGUgPSB7fSkpO1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBmdW5jdGlvbiBraW5kVG9Qcm90byhrKSB7XHJcbiAgICBzd2l0Y2ggKGspIHtcclxuICAgICAgY2FzZSBLaW5kLkF1ZGlvOlxyXG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XHJcbiAgICAgIGNhc2UgS2luZC5WaWRlbzpcclxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIEZJWE1FIHRoaXMgd2FzIFVOUkVDT0dOSVpFRCBiZWZvcmVcclxuICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkRBVEE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFRyYWNrLmtpbmRUb1Byb3RvID0ga2luZFRvUHJvdG87XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGZ1bmN0aW9uIGtpbmRGcm9tUHJvdG8odCkge1xyXG4gICAgc3dpdGNoICh0KSB7XHJcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxyXG4gICAgICAgIHJldHVybiBLaW5kLkF1ZGlvO1xyXG4gICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcclxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gS2luZC5Vbmtub3duO1xyXG4gICAgfVxyXG4gIH1cclxuICBUcmFjay5raW5kRnJvbVByb3RvID0ga2luZEZyb21Qcm90bztcclxuICAvKiogQGludGVybmFsICovXHJcbiAgZnVuY3Rpb24gc291cmNlVG9Qcm90byhzKSB7XHJcbiAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxyXG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5DQU1FUkE7XHJcbiAgICAgIGNhc2UgU291cmNlLk1pY3JvcGhvbmU6XHJcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XHJcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlOlxyXG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU7XHJcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XHJcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5LTk9XTjtcclxuICAgIH1cclxuICB9XHJcbiAgVHJhY2suc291cmNlVG9Qcm90byA9IHNvdXJjZVRvUHJvdG87XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGZ1bmN0aW9uIHNvdXJjZUZyb21Qcm90byhzKSB7XHJcbiAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XHJcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5DYW1lcmE7XHJcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcclxuICAgICAgICByZXR1cm4gU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxyXG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmU7XHJcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxyXG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gU291cmNlLlVua25vd247XHJcbiAgICB9XHJcbiAgfVxyXG4gIFRyYWNrLnNvdXJjZUZyb21Qcm90byA9IHNvdXJjZUZyb21Qcm90bztcclxuICAvKiogQGludGVybmFsICovXHJcbiAgZnVuY3Rpb24gc3RyZWFtU3RhdGVGcm9tUHJvdG8ocykge1xyXG4gICAgc3dpdGNoIChzKSB7XHJcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuQUNUSVZFOlxyXG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLkFjdGl2ZTtcclxuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5QQVVTRUQ6XHJcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlJDEuUGF1c2VkO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLlVua25vd247XHJcbiAgICB9XHJcbiAgfVxyXG4gIFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvID0gc3RyZWFtU3RhdGVGcm9tUHJvdG87XHJcbn0pKFRyYWNrIHx8IChUcmFjayA9IHt9KSk7XHJcblxyXG5jbGFzcyBWaWRlb1ByZXNldCB7XHJcbiAgY29uc3RydWN0b3Iod2lkdGhPck9wdGlvbnMsIGhlaWdodCwgbWF4Qml0cmF0ZSwgbWF4RnJhbWVyYXRlLCBwcmlvcml0eSkge1xyXG4gICAgaWYgKHR5cGVvZiB3aWR0aE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zLndpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IHdpZHRoT3JPcHRpb25zLmhlaWdodDtcclxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHdpZHRoT3JPcHRpb25zLmFzcGVjdFJhdGlvO1xyXG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xyXG4gICAgICAgIG1heEJpdHJhdGU6IHdpZHRoT3JPcHRpb25zLm1heEJpdHJhdGUsXHJcbiAgICAgICAgbWF4RnJhbWVyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhGcmFtZXJhdGUsXHJcbiAgICAgICAgcHJpb3JpdHk6IHdpZHRoT3JPcHRpb25zLnByaW9yaXR5XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1heEJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGhPck9wdGlvbnM7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMgLyBoZWlnaHQ7XHJcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSB7XHJcbiAgICAgICAgbWF4Qml0cmF0ZSxcclxuICAgICAgICBtYXhGcmFtZXJhdGUsXHJcbiAgICAgICAgcHJpb3JpdHlcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIG9wdGlvbnM6IHByb3ZpZGUgYXQgbGVhc3Qgd2lkdGgsIGhlaWdodCBhbmQgbWF4Qml0cmF0ZScpO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgcmVzb2x1dGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICBmcmFtZVJhdGU6IHRoaXMuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxyXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy5hc3BlY3RSYXRpb1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuY29uc3QgYmFja3VwQ29kZWNzID0gWyd2cDgnLCAnaDI2NCddO1xyXG5jb25zdCB2aWRlb0NvZGVjcyA9IFsndnA4JywgJ2gyNjQnLCAndnA5JywgJ2F2MSddO1xyXG5mdW5jdGlvbiBpc0JhY2t1cENvZGVjKGNvZGVjKSB7XHJcbiAgcmV0dXJuICEhYmFja3VwQ29kZWNzLmZpbmQoYmFja3VwID0+IGJhY2t1cCA9PT0gY29kZWMpO1xyXG59XHJcbnZhciBCYWNrdXBDb2RlY1BvbGljeTtcclxuKGZ1bmN0aW9uIChCYWNrdXBDb2RlY1BvbGljeSkge1xyXG4gIC8vIGNvZGVjIHJlZ3Jlc3Npb24gaXMgcHJlZmVycmVkLCB0aGUgc2Z1IHdpbGwgdHJ5IHRvIHJlZ3Jlc3MgY29kZWMgaWYgcG9zc2libGUgYnV0IG5vdCBndWFyYW50ZWVkXHJcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJQUkVGRVJfUkVHUkVTU0lPTlwiXSA9IDBdID0gXCJQUkVGRVJfUkVHUkVTU0lPTlwiO1xyXG4gIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCwgcHVibGlzaCBib3RoIHByaW1hcnkgYW5kIGJhY2t1cCBjb2RlYyBhdCB0aGUgc2FtZSB0aW1lXHJcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJTSU1VTENBU1RcIl0gPSAxXSA9IFwiU0lNVUxDQVNUXCI7XHJcbiAgLy8gYWx3YXlzIHVzZSBiYWNrdXAgY29kZWMgb25seVxyXG4gIEJhY2t1cENvZGVjUG9saWN5W0JhY2t1cENvZGVjUG9saWN5W1wiUkVHUkVTU0lPTlwiXSA9IDJdID0gXCJSRUdSRVNTSU9OXCI7XHJcbn0pKEJhY2t1cENvZGVjUG9saWN5IHx8IChCYWNrdXBDb2RlY1BvbGljeSA9IHt9KSk7XHJcbnZhciBBdWRpb1ByZXNldHM7XHJcbihmdW5jdGlvbiAoQXVkaW9QcmVzZXRzKSB7XHJcbiAgQXVkaW9QcmVzZXRzLnRlbGVwaG9uZSA9IHtcclxuICAgIG1heEJpdHJhdGU6IDEyMDAwXHJcbiAgfTtcclxuICBBdWRpb1ByZXNldHMuc3BlZWNoID0ge1xyXG4gICAgbWF4Qml0cmF0ZTogMjQwMDBcclxuICB9O1xyXG4gIEF1ZGlvUHJlc2V0cy5tdXNpYyA9IHtcclxuICAgIG1heEJpdHJhdGU6IDQ4MDAwXHJcbiAgfTtcclxuICBBdWRpb1ByZXNldHMubXVzaWNTdGVyZW8gPSB7XHJcbiAgICBtYXhCaXRyYXRlOiA2NDAwMFxyXG4gIH07XHJcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHkgPSB7XHJcbiAgICBtYXhCaXRyYXRlOiA5NjAwMFxyXG4gIH07XHJcbiAgQXVkaW9QcmVzZXRzLm11c2ljSGlnaFF1YWxpdHlTdGVyZW8gPSB7XHJcbiAgICBtYXhCaXRyYXRlOiAxMjgwMDBcclxuICB9O1xyXG59KShBdWRpb1ByZXNldHMgfHwgKEF1ZGlvUHJlc2V0cyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBTYW5lIHByZXNldHMgZm9yIHZpZGVvIHJlc29sdXRpb24vZW5jb2RpbmdcclxuICovXHJcbmNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcclxuICBoOTA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDkwLCA5MDAwMCwgMjApLFxyXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwMDAwLCAyMCksXHJcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODAwMDAsIDIwKSxcclxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDQ1MDAwMCwgMjApLFxyXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwMDAwLCAyNSksXHJcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTcwMDAwMCwgMzApLFxyXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgMzAwMDAwMCwgMzApLFxyXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMjU2MCwgMTQ0MCwgNTAwMDAwMCwgMzApLFxyXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgODAwMDAwMCwgMzApXHJcbn07XHJcbi8qKlxyXG4gKiBGb3VyIGJ5IHRocmVlIHByZXNldHNcclxuICovXHJcbmNvbnN0IFZpZGVvUHJlc2V0czQzID0ge1xyXG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzAwMDAsIDIwKSxcclxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMjQwLCAxODAsIDEyNTAwMCwgMjApLFxyXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwMDAwLCAyMCksXHJcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzAwMDAsIDIwKSxcclxuICBoNDgwOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCA0ODAsIDUwMDAwMCwgMjApLFxyXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwMDAwLCAyNSksXHJcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxMzAwMDAwLCAzMCksXHJcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxNDQwLCAxMDgwLCAyMzAwMDAwLCAzMCksXHJcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxNDQwLCAzODAwMDAwLCAzMClcclxufTtcclxuY29uc3QgU2NyZWVuU2hhcmVQcmVzZXRzID0ge1xyXG4gIGgzNjBmcHMzOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMDAwMCwgMywgJ21lZGl1bScpLFxyXG4gIGgzNjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0MDAwMDAsIDE1LCAnbWVkaXVtJyksXHJcbiAgaDcyMGZwczU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDgwMDAwMCwgNSwgJ21lZGl1bScpLFxyXG4gIGg3MjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTUwMDAwMCwgMTUsICdtZWRpdW0nKSxcclxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDIwMDAwMDAsIDMwLCAnbWVkaXVtJyksXHJcbiAgaDEwODBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDI1MDAwMDAsIDE1LCAnbWVkaXVtJyksXHJcbiAgaDEwODBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDUwMDAwMDAsIDMwLCAnbWVkaXVtJyksXHJcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xyXG4gIG9yaWdpbmFsOiBuZXcgVmlkZW9QcmVzZXQoMCwgMCwgNzAwMDAwMCwgMzAsICdtZWRpdW0nKVxyXG59O1xyXG5cclxuY29uc3Qgc2VwYXJhdG9yID0gJ3wnO1xyXG5jb25zdCBkZEV4dGVuc2lvblVSSSA9ICdodHRwczovL2FvbWVkaWFjb2RlYy5naXRodWIuaW8vYXYxLXJ0cC1zcGVjLyNkZXBlbmRlbmN5LWRlc2NyaXB0b3ItcnRwLWhlYWRlci1leHRlbnNpb24nO1xyXG5mdW5jdGlvbiB1bnBhY2tTdHJlYW1JZChwYWNrZWQpIHtcclxuICBjb25zdCBwYXJ0cyA9IHBhY2tlZC5zcGxpdChzZXBhcmF0b3IpO1xyXG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICByZXR1cm4gW3BhcnRzWzBdLCBwYWNrZWQuc3Vic3RyKHBhcnRzWzBdLmxlbmd0aCArIDEpXTtcclxuICB9XHJcbiAgcmV0dXJuIFtwYWNrZWQsICcnXTtcclxufVxyXG5mdW5jdGlvbiBzbGVlcChkdXJhdGlvbikge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XHJcbiAgfSk7XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkge1xyXG4gIHJldHVybiAnYWRkVHJhbnNjZWl2ZXInIGluIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIHN1cHBvcnRzQWRkVHJhY2soKSB7XHJcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xyXG59XHJcbmZ1bmN0aW9uIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0oKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIHN1cHBvcnRzRHluYWNhc3QoKSB7XHJcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcclxufVxyXG5mdW5jdGlvbiBzdXBwb3J0c0FWMSgpIHtcclxuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChpc1NhZmFyaSgpKSB7XHJcbiAgICAvLyBTYWZhcmkgMTcgb24gaVBob25lMTQgcmVwb3J0cyBBVjEgY2FwYWJpbGl0eSwgYnV0IGRvZXMgbm90IGFjdHVhbGx5IHN1cHBvcnQgaXRcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcygndmlkZW8nKTtcclxuICBsZXQgaGFzQVYxID0gZmFsc2U7XHJcbiAgaWYgKGNhcGFiaWxpdGllcykge1xyXG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBhYmlsaXRpZXMuY29kZWNzKSB7XHJcbiAgICAgIGlmIChjb2RlYy5taW1lVHlwZSA9PT0gJ3ZpZGVvL0FWMScpIHtcclxuICAgICAgICBoYXNBVjEgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBoYXNBVjE7XHJcbn1cclxuZnVuY3Rpb24gc3VwcG9ydHNWUDkoKSB7XHJcbiAgaWYgKCEoJ2dldENhcGFiaWxpdGllcycgaW4gUlRDUnRwU2VuZGVyKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoaXNGaXJlRm94KCkpIHtcclxuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjMzODc2XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChpc1NhZmFyaSgpKSB7XHJcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xyXG4gICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XHJcbiAgICAgIC8vIFNhZmFyaSAxNiBhbmQgYmVsb3cgZG9lcyBub3Qgc3VwcG9ydCBWUDlcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKCd2aWRlbycpO1xyXG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcclxuICBpZiAoY2FwYWJpbGl0aWVzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcGFiaWxpdGllcy5jb2RlY3MpIHtcclxuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xyXG4gICAgICAgIGhhc1ZQOSA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGhhc1ZQOTtcclxufVxyXG5mdW5jdGlvbiBpc1NWQ0NvZGVjKGNvZGVjKSB7XHJcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XHJcbn1cclxuZnVuY3Rpb24gc3VwcG9ydHNTZXRTaW5rSWQoZWxtKSB7XHJcbiAgaWYgKCFkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoIWVsbSkge1xyXG4gICAgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcclxuICB9XHJcbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcclxufVxyXG5mdW5jdGlvbiBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XHJcbiAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XHJcbn1cclxuZnVuY3Rpb24gaXNGaXJlRm94KCkge1xyXG4gIHZhciBfYTtcclxuICByZXR1cm4gKChfYSA9IGdldEJyb3dzZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnRmlyZWZveCc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XHJcbiAgdmFyIF9hO1xyXG4gIHJldHVybiAoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdTYWZhcmknO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FmYXJpQmFzZWQoKSB7XHJcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcclxuICByZXR1cm4gKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5uYW1lKSA9PT0gJ1NhZmFyaScgfHwgKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5vcykgPT09ICdpT1MnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FmYXJpMTcoKSB7XHJcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcclxuICByZXR1cm4gKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgYi52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3LicpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FmYXJpU3ZjQXBpKGJyb3dzZXIpIHtcclxuICBpZiAoIWJyb3dzZXIpIHtcclxuICAgIGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XHJcbiAgfVxyXG4gIC8vIFNhZmFyaSAxOC40IHJlcXVpcmVzIGxlZ2FjeSBzdmMgYXBpIGFuZCBzY2FsZVJlc29sdXRpb25Eb3duIHRvIGJlIHNldFxyXG4gIHJldHVybiAoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnU2FmYXJpJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3Nlci52ZXJzaW9uLCAnMTguMycpID4gMDtcclxufVxyXG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcclxuICB2YXIgX2EsIF9iO1xyXG4gIGlmICghaXNXZWIoKSkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiAoXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGB1c2VyQWdlbnREYXRhYCBpcyBub3QgeWV0IHBhcnQgb2YgdHlwZXNjcmlwdFxyXG4gICAgKF9iID0gKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2JpbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC9UYWJsZXR8aVBhZHxNb2JpbGV8QW5kcm9pZHxCbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXHJcbiAgKTtcclxufVxyXG5mdW5jdGlvbiBpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSB7XHJcbiAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICBjb25zdCBzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uID0gJzE3LjInOyAvLyBzZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI1NzgwM1xyXG4gIGlmIChicm93c2VyKSB7XHJcbiAgICBpZiAoYnJvd3Nlci5uYW1lICE9PSAnU2FmYXJpJyAmJiBicm93c2VyLm9zICE9PSAnaU9TJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAoYnJvd3Nlci5vcyA9PT0gJ2lPUycgJiYgYnJvd3Nlci5vc1ZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKHN1cHBvcnRlZFNhZmFyaVZlcnNpb24sIGJyb3dzZXIub3NWZXJzaW9uKSA+PSAwKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChicm93c2VyLm5hbWUgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLnZlcnNpb24pID49IDApIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzV2ViKCkge1xyXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XHJcbiAgLy8gbmF2aWdhdG9yLnByb2R1Y3QgaXMgZGVwcmVjYXRlZCBvbiBicm93c2VycywgYnV0IHdpbGwgYmUgc2V0IGFwcHJvcHJpYXRlbHkgZm9yIHJlYWN0LW5hdGl2ZS5cclxuICByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3QgPT0gJ1JlYWN0TmF0aXZlJztcclxufVxyXG5mdW5jdGlvbiBpc0Nsb3VkKHNlcnZlclVybCkge1xyXG4gIHJldHVybiBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LmNsb3VkJykgfHwgc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5ydW4nKTtcclxufVxyXG5mdW5jdGlvbiBnZXRMS1JlYWN0TmF0aXZlSW5mbygpIHtcclxuICAvLyBnbG9iYWwgZGVmaW5lZCBvbmx5IGZvciBSZWFjdE5hdGl2ZS5cclxuICAvLyBAdHMtaWdub3JlXHJcbiAgaWYgKGdsb2JhbCAmJiBnbG9iYWwuTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbDtcclxuICB9XHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBnZXRSZWFjdE5hdGl2ZU9zKCkge1xyXG4gIGlmICghaXNSZWFjdE5hdGl2ZSgpKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XHJcbiAgaWYgKGluZm8pIHtcclxuICAgIHJldHVybiBpbmZvLnBsYXRmb3JtO1xyXG4gIH1cclxuICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XHJcbiAgaWYgKGlzV2ViKCkpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICB9XHJcbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgbGV0IGluZm8gPSBnZXRMS1JlYWN0TmF0aXZlSW5mbygpO1xyXG4gICAgaWYgKGluZm8pIHtcclxuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIDE7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZVZlcnNpb25zKHYxLCB2Mikge1xyXG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XHJcbiAgY29uc3QgcGFydHMyID0gdjIuc3BsaXQoJy4nKTtcclxuICBjb25zdCBrID0gTWF0aC5taW4ocGFydHMxLmxlbmd0aCwgcGFydHMyLmxlbmd0aCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcclxuICAgIGNvbnN0IHAxID0gcGFyc2VJbnQocGFydHMxW2ldLCAxMCk7XHJcbiAgICBjb25zdCBwMiA9IHBhcnNlSW50KHBhcnRzMltpXSwgMTApO1xyXG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xyXG4gICAgaWYgKHAxIDwgcDIpIHJldHVybiAtMTtcclxuICAgIGlmIChpID09PSBrIC0gMSAmJiBwMSA9PT0gcDIpIHJldHVybiAwO1xyXG4gIH1cclxuICBpZiAodjEgPT09ICcnICYmIHYyICE9PSAnJykge1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcclxufVxyXG5mdW5jdGlvbiByb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xyXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgZW50cnkudGFyZ2V0LmhhbmRsZVJlc2l6ZShlbnRyeSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XHJcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xyXG4gIH1cclxufVxyXG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xyXG5jb25zdCBnZXRSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcclxuICBpZiAoIXJlc2l6ZU9ic2VydmVyKSByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihyb0Rpc3BhdGNoQ2FsbGJhY2spO1xyXG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcclxufTtcclxubGV0IGludGVyc2VjdGlvbk9ic2VydmVyID0gbnVsbDtcclxuY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XHJcbiAgaWYgKCFpbnRlcnNlY3Rpb25PYnNlcnZlcikge1xyXG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW9EaXNwYXRjaENhbGxiYWNrLCB7XHJcbiAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgIHJvb3RNYXJnaW46ICcwcHgnXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGludGVyc2VjdGlvbk9ic2VydmVyO1xyXG59O1xyXG5mdW5jdGlvbiBnZXRDbGllbnRJbmZvKCkge1xyXG4gIHZhciBfYTtcclxuICBjb25zdCBpbmZvID0gbmV3IENsaWVudEluZm8oe1xyXG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcclxuICAgIHByb3RvY29sOiBwcm90b2NvbFZlcnNpb24sXHJcbiAgICB2ZXJzaW9uXHJcbiAgfSk7XHJcbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgaW5mby5vcyA9IChfYSA9IGdldFJlYWN0TmF0aXZlT3MoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XHJcbiAgfVxyXG4gIHJldHVybiBpbmZvO1xyXG59XHJcbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s7XHJcbmZ1bmN0aW9uIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaygpIHtcclxuICBpZiAoIWVtcHR5VmlkZW9TdHJlYW1UcmFjaykge1xyXG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XHJcbiAgfVxyXG4gIHJldHVybiBlbXB0eVZpZGVvU3RyZWFtVHJhY2suY2xvbmUoKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soKSB7XHJcbiAgbGV0IHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxNjtcclxuICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcclxuICBsZXQgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XHJcbiAgbGV0IHBhaW50Q29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XHJcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgLy8gdGhlIGNhbnZhcyBzaXplIGlzIHNldCB0byAxNiBieSBkZWZhdWx0LCBiZWNhdXNlIGVsZWN0cm9uIGFwcHMgc2VlbSB0byBmYWlsIHdpdGggc21hbGxlciB2YWx1ZXNcclxuICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gIGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguYXJjKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgNTAsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSAnZ3JleSc7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gIH1cclxuICAvLyBAdHMtaWdub3JlXHJcbiAgY29uc3QgZHVtbXlTdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgpO1xyXG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xyXG4gIGlmICghZHVtbXlUcmFjaykge1xyXG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIHZpZGVvIHRyYWNrJyk7XHJcbiAgfVxyXG4gIGR1bW15VHJhY2suZW5hYmxlZCA9IGVuYWJsZWQ7XHJcbiAgcmV0dXJuIGR1bW15VHJhY2s7XHJcbn1cclxubGV0IGVtcHR5QXVkaW9TdHJlYW1UcmFjaztcclxuZnVuY3Rpb24gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCkge1xyXG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XHJcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dlYnJ0Yy93YXJtLXVwLXdpdGgtcmVwbGFjZXRyYWNrL1xyXG4gICAgY29uc3QgY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XHJcbiAgICBjb25zdCBnYWluID0gY3R4LmNyZWF0ZUdhaW4oKTtcclxuICAgIGdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcclxuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XHJcbiAgICBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbik7XHJcbiAgICBnYWluLmNvbm5lY3QoZHN0KTtcclxuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcclxuICAgIFtlbXB0eUF1ZGlvU3RyZWFtVHJhY2tdID0gZHN0LnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xyXG4gICAgaWYgKCFlbXB0eUF1ZGlvU3RyZWFtVHJhY2spIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XHJcbiAgICB9XHJcbiAgICBlbXB0eUF1ZGlvU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gZW1wdHlBdWRpb1N0cmVhbVRyYWNrLmNsb25lKCk7XHJcbn1cclxuY2xhc3MgRnV0dXJlIHtcclxuICBjb25zdHJ1Y3RvcihmdXR1cmVCYXNlLCBvbkZpbmFsbHkpIHtcclxuICAgIHRoaXMub25GaW5hbGx5ID0gb25GaW5hbGx5O1xyXG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcclxuICAgICAgICB5aWVsZCBmdXR1cmVCYXNlKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH0pKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5vbkZpbmFsbHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFuYWx5c2VyIHdlYiBhdWRpbyBub2RlIHRoYXQgaXMgYXR0YWNoZWQgdG8gdGhlIHByb3ZpZGVkIHRyYWNrLlxyXG4gKiBBZGRpdGlvbmFsbHkgcmV0dXJucyBhIGNvbnZlbmllbmNlIG1ldGhvZCBgY2FsY3VsYXRlVm9sdW1lYCB0byBwZXJmb3JtIGluc3RhbnQgdm9sdW1lIHJlYWRpbmdzIG9uIHRoYXQgdHJhY2suXHJcbiAqIENhbGwgdGhlIHJldHVybmVkIGBjbGVhbnVwYCBmdW5jdGlvbiB0byBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIGluc3RhbmNlIG9mIHRoaXMgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBdWRpb0FuYWx5c2VyKHRyYWNrLCBvcHRpb25zKSB7XHJcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgY2xvbmVUcmFjazogZmFsc2UsXHJcbiAgICBmZnRTaXplOiAyMDQ4LFxyXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjgsXHJcbiAgICBtaW5EZWNpYmVsczogLTEwMCxcclxuICAgIG1heERlY2liZWxzOiAtODBcclxuICB9LCBvcHRpb25zKTtcclxuICBjb25zdCBhdWRpb0NvbnRleHQgPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcclxuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBDb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XHJcbiAgfVxyXG4gIGNvbnN0IHN0cmVhbVRyYWNrID0gb3B0cy5jbG9uZVRyYWNrID8gdHJhY2subWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpIDogdHJhY2subWVkaWFTdHJlYW1UcmFjaztcclxuICBjb25zdCBtZWRpYVN0cmVhbVNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3N0cmVhbVRyYWNrXSkpO1xyXG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XHJcbiAgYW5hbHlzZXIubWluRGVjaWJlbHMgPSBvcHRzLm1pbkRlY2liZWxzO1xyXG4gIGFuYWx5c2VyLm1heERlY2liZWxzID0gb3B0cy5tYXhEZWNpYmVscztcclxuICBhbmFseXNlci5mZnRTaXplID0gb3B0cy5mZnRTaXplO1xyXG4gIGFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG9wdHMuc21vb3RoaW5nVGltZUNvbnN0YW50O1xyXG4gIG1lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xyXG4gIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXHJcbiAgICovXHJcbiAgY29uc3QgY2FsY3VsYXRlVm9sdW1lID0gKCkgPT4ge1xyXG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcclxuICAgIGxldCBzdW0gPSAwO1xyXG4gICAgZm9yIChjb25zdCBhbXBsaXR1ZGUgb2YgZGF0YUFycmF5KSB7XHJcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdm9sdW1lID0gTWF0aC5zcXJ0KHN1bSAvIGRhdGFBcnJheS5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHZvbHVtZTtcclxuICB9O1xyXG4gIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICB5aWVsZCBhdWRpb0NvbnRleHQuY2xvc2UoKTtcclxuICAgIGlmIChvcHRzLmNsb25lVHJhY2spIHtcclxuICAgICAgc3RyZWFtVHJhY2suc3RvcCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiB7XHJcbiAgICBjYWxjdWxhdGVWb2x1bWUsXHJcbiAgICBhbmFseXNlcixcclxuICAgIGNsZWFudXBcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzVmlkZW9Db2RlYyhtYXliZUNvZGVjKSB7XHJcbiAgcmV0dXJuIHZpZGVvQ29kZWNzLmluY2x1ZGVzKG1heWJlQ29kZWMpO1xyXG59XHJcbmZ1bmN0aW9uIHVud3JhcENvbnN0cmFpbnQoY29uc3RyYWludCkge1xyXG4gIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbnN0cmFpbnQgPT09ICdudW1iZXInKSB7XHJcbiAgICByZXR1cm4gY29uc3RyYWludDtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludCkpIHtcclxuICAgIHJldHVybiBjb25zdHJhaW50WzBdO1xyXG4gIH1cclxuICBpZiAoY29uc3RyYWludC5leGFjdCkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5leGFjdCkpIHtcclxuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29uc3RyYWludC5leGFjdDtcclxuICB9XHJcbiAgaWYgKGNvbnN0cmFpbnQuaWRlYWwpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuaWRlYWwpKSB7XHJcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWw7XHJcbiAgfVxyXG4gIHRocm93IEVycm9yKCdjb3VsZCBub3QgdW53cmFwIGNvbnN0cmFpbnQnKTtcclxufVxyXG5mdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmwpIHtcclxuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xyXG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XHJcbiAgfVxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuZnVuY3Rpb24gdG9IdHRwVXJsKHVybCkge1xyXG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xyXG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKHdzKS8sICdodHRwJyk7XHJcbiAgfVxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zY3JpcHRpb25TZWdtZW50cyh0cmFuc2NyaXB0aW9uLCBmaXJzdFJlY2VpdmVkVGltZXNNYXApIHtcclxuICByZXR1cm4gdHJhbnNjcmlwdGlvbi5zZWdtZW50cy5tYXAoX3JlZiA9PiB7XHJcbiAgICBsZXQge1xyXG4gICAgICBpZCxcclxuICAgICAgdGV4dCxcclxuICAgICAgbGFuZ3VhZ2UsXHJcbiAgICAgIHN0YXJ0VGltZSxcclxuICAgICAgZW5kVGltZSxcclxuICAgICAgZmluYWxcclxuICAgIH0gPSBfcmVmO1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZmlyc3RSZWNlaXZlZFRpbWUgPSAoX2EgPSBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZ2V0KGlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGxhc3RSZWNlaXZlZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgaWYgKGZpbmFsKSB7XHJcbiAgICAgIGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5kZWxldGUoaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLnNldChpZCwgZmlyc3RSZWNlaXZlZFRpbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQsXHJcbiAgICAgIHRleHQsXHJcbiAgICAgIHN0YXJ0VGltZTogTnVtYmVyLnBhcnNlSW50KHN0YXJ0VGltZS50b1N0cmluZygpKSxcclxuICAgICAgZW5kVGltZTogTnVtYmVyLnBhcnNlSW50KGVuZFRpbWUudG9TdHJpbmcoKSksXHJcbiAgICAgIGZpbmFsLFxyXG4gICAgICBsYW5ndWFnZSxcclxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWUsXHJcbiAgICAgIGxhc3RSZWNlaXZlZFRpbWVcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdENoYXRNZXNzYWdlKG1zZykge1xyXG4gIGNvbnN0IHtcclxuICAgIGlkLFxyXG4gICAgdGltZXN0YW1wLFxyXG4gICAgbWVzc2FnZSxcclxuICAgIGVkaXRUaW1lc3RhbXBcclxuICB9ID0gbXNnO1xyXG4gIHJldHVybiB7XHJcbiAgICBpZCxcclxuICAgIHRpbWVzdGFtcDogTnVtYmVyLnBhcnNlSW50KHRpbWVzdGFtcC50b1N0cmluZygpKSxcclxuICAgIGVkaXRUaW1lc3RhbXA6IGVkaXRUaW1lc3RhbXAgPyBOdW1iZXIucGFyc2VJbnQoZWRpdFRpbWVzdGFtcC50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcclxuICAgIG1lc3NhZ2VcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGUpIHtcclxuICBzd2l0Y2ggKGUucmVhc29uKSB7XHJcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3Q6XHJcbiAgICAgIHJldHVybiBlLmNvbnRleHQ7XHJcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQ6XHJcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQ7XHJcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkOlxyXG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5VU0VSX1JFSkVDVEVEO1xyXG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGU6XHJcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkpPSU5fRkFJTFVSRTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xyXG4gIH1cclxufVxyXG4vKiogY29udmVydCBiaWdpbnRzIHRvIG51bWJlcnMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXHJcbmZ1bmN0aW9uIGJpZ0ludFRvTnVtYmVyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBOdW1iZXIodmFsdWUpIDogdW5kZWZpbmVkO1xyXG59XHJcbi8qKiBjb252ZXJ0IG51bWJlcnMgdG8gYmlnaW50cyBwcmVzZXJ2aW5nIHVuZGVmaW5lZCB2YWx1ZXMgKi9cclxuZnVuY3Rpb24gbnVtYmVyVG9CaWdJbnQodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IEJpZ0ludCh2YWx1ZSkgOiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNMb2NhbFRyYWNrKHRyYWNrKSB7XHJcbiAgcmV0dXJuICEhdHJhY2sgJiYgISh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spICYmIHRyYWNrLmlzTG9jYWw7XHJcbn1cclxuZnVuY3Rpb24gaXNBdWRpb1RyYWNrKHRyYWNrKSB7XHJcbiAgcmV0dXJuICEhdHJhY2sgJiYgdHJhY2sua2luZCA9PSBUcmFjay5LaW5kLkF1ZGlvO1xyXG59XHJcbmZ1bmN0aW9uIGlzVmlkZW9UcmFjayh0cmFjaykge1xyXG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5WaWRlbztcclxufVxyXG5mdW5jdGlvbiBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykge1xyXG4gIHJldHVybiBpc0xvY2FsVHJhY2sodHJhY2spICYmIGlzVmlkZW9UcmFjayh0cmFjayk7XHJcbn1cclxuZnVuY3Rpb24gaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHtcclxuICByZXR1cm4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVtb3RlVHJhY2sodHJhY2spIHtcclxuICByZXR1cm4gISF0cmFjayAmJiAhdHJhY2suaXNMb2NhbDtcclxufVxyXG5mdW5jdGlvbiBpc1JlbW90ZVB1YihwdWIpIHtcclxuICByZXR1cm4gISFwdWIgJiYgIXB1Yi5pc0xvY2FsO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVtb3RlVmlkZW9UcmFjayh0cmFjaykge1xyXG4gIHJldHVybiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xyXG59XHJcbmZ1bmN0aW9uIGlzTG9jYWxQYXJ0aWNpcGFudChwKSB7XHJcbiAgcmV0dXJuIHAuaXNMb2NhbDtcclxufVxyXG5mdW5jdGlvbiBpc1JlbW90ZVBhcnRpY2lwYW50KHApIHtcclxuICByZXR1cm4gIXAuaXNMb2NhbDtcclxufVxyXG5mdW5jdGlvbiBzcGxpdFV0Zjgocywgbikge1xyXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjA0Mzc5N1xyXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gIGxldCBlbmNvZGVkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xyXG4gIHdoaWxlIChlbmNvZGVkLmxlbmd0aCA+IG4pIHtcclxuICAgIGxldCBrID0gbjtcclxuICAgIHdoaWxlIChrID4gMCkge1xyXG4gICAgICBjb25zdCBieXRlID0gZW5jb2RlZFtrXTtcclxuICAgICAgaWYgKGJ5dGUgIT09IHVuZGVmaW5lZCAmJiAoYnl0ZSAmIDB4YzApICE9PSAweDgwKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgay0tO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnB1c2goZW5jb2RlZC5zbGljZSgwLCBrKSk7XHJcbiAgICBlbmNvZGVkID0gZW5jb2RlZC5zbGljZShrKTtcclxuICB9XHJcbiAgaWYgKGVuY29kZWQubGVuZ3RoID4gMCkge1xyXG4gICAgcmVzdWx0LnB1c2goZW5jb2RlZCk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cykge1xyXG4gIHZhciBfYSwgX2I7XHJcbiAgdmFyIF9jLCBfZDtcclxuICBjb25zdCB7XHJcbiAgICBvcHRpb25zV2l0aG91dFByb2Nlc3NvcixcclxuICAgIGF1ZGlvUHJvY2Vzc29yLFxyXG4gICAgdmlkZW9Qcm9jZXNzb3JcclxuICB9ID0gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XHJcbiAgY29uc3QgZGVmYXVsdEF1ZGlvUHJvY2Vzc29yID0gYXVkaW9EZWZhdWx0cyA9PT0gbnVsbCB8fCBhdWRpb0RlZmF1bHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdWRpb0RlZmF1bHRzLnByb2Nlc3NvcjtcclxuICBjb25zdCBkZWZhdWx0VmlkZW9Qcm9jZXNzb3IgPSB2aWRlb0RlZmF1bHRzID09PSBudWxsIHx8IHZpZGVvRGVmYXVsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRGVmYXVsdHMucHJvY2Vzc29yO1xyXG4gIGNvbnN0IGNsb25lZE9wdGlvbnMgPSBvcHRpb25zV2l0aG91dFByb2Nlc3NvciAhPT0gbnVsbCAmJiBvcHRpb25zV2l0aG91dFByb2Nlc3NvciAhPT0gdm9pZCAwID8gb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgOiB7fTtcclxuICBpZiAoY2xvbmVkT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSkgY2xvbmVkT3B0aW9ucy5hdWRpbyA9IHt9O1xyXG4gIGlmIChjbG9uZWRPcHRpb25zLnZpZGVvID09PSB0cnVlKSBjbG9uZWRPcHRpb25zLnZpZGVvID0ge307XHJcbiAgLy8gdXNlIGRlZmF1bHRzXHJcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8pIHtcclxuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKGNsb25lZE9wdGlvbnMuYXVkaW8sIGF1ZGlvRGVmYXVsdHMpO1xyXG4gICAgKF9hID0gKF9jID0gY2xvbmVkT3B0aW9ucy5hdWRpbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9jLmRldmljZUlkID0ge1xyXG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgICB9O1xyXG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yIHx8IGRlZmF1bHRBdWRpb1Byb2Nlc3Nvcikge1xyXG4gICAgICBjbG9uZWRPcHRpb25zLmF1ZGlvLnByb2Nlc3NvciA9IGF1ZGlvUHJvY2Vzc29yICE9PSBudWxsICYmIGF1ZGlvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyBhdWRpb1Byb2Nlc3NvciA6IGRlZmF1bHRBdWRpb1Byb2Nlc3NvcjtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNsb25lZE9wdGlvbnMudmlkZW8pIHtcclxuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKGNsb25lZE9wdGlvbnMudmlkZW8sIHZpZGVvRGVmYXVsdHMpO1xyXG4gICAgKF9iID0gKF9kID0gY2xvbmVkT3B0aW9ucy52aWRlbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9kLmRldmljZUlkID0ge1xyXG4gICAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgICB9O1xyXG4gICAgaWYgKHZpZGVvUHJvY2Vzc29yIHx8IGRlZmF1bHRWaWRlb1Byb2Nlc3Nvcikge1xyXG4gICAgICBjbG9uZWRPcHRpb25zLnZpZGVvLnByb2Nlc3NvciA9IHZpZGVvUHJvY2Vzc29yICE9PSBudWxsICYmIHZpZGVvUHJvY2Vzc29yICE9PSB2b2lkIDAgPyB2aWRlb1Byb2Nlc3NvciA6IGRlZmF1bHRWaWRlb1Byb2Nlc3NvcjtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcobWFpbk9iamVjdCwgb2JqZWN0VG9NZXJnZSkge1xyXG4gIE9iamVjdC5rZXlzKG9iamVjdFRvTWVyZ2UpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGlmIChtYWluT2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkgbWFpbk9iamVjdFtrZXldID0gb2JqZWN0VG9NZXJnZVtrZXldO1xyXG4gIH0pO1xyXG4gIHJldHVybiBtYWluT2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgdmFyIF9hLCBfYjtcclxuICB2YXIgX2MsIF9kO1xyXG4gIGNvbnN0IGNvbnN0cmFpbnRzID0ge307XHJcbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcclxuICAgIC8vIGRlZmF1bHQgdmlkZW8gb3B0aW9uc1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBjb25zdCB2aWRlb09wdGlvbnMgPSB7fTtcclxuICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zO1xyXG4gICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnZpZGVvO1xyXG4gICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XHJcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gVmlkZW9SZXNvbHV0aW9uIGZpZWxkc1xyXG4gICAgICAgICAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyh0YXJnZXQsIHNvdXJjZS5yZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gdmlkZW9PcHRpb25zO1xyXG4gICAgICAoX2EgPSAoX2MgPSBjb25zdHJhaW50cy52aWRlbykuZGV2aWNlSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF9jLmRldmljZUlkID0ge1xyXG4gICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gb3B0aW9ucy52aWRlbyA/IHtcclxuICAgICAgICBkZXZpY2VJZDoge1xyXG4gICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gICAgICAgIH1cclxuICAgICAgfSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xyXG4gIH1cclxuICBpZiAob3B0aW9ucy5hdWRpbykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XHJcbiAgICAgIChfYiA9IChfZCA9IGNvbnN0cmFpbnRzLmF1ZGlvKS5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX2QuZGV2aWNlSWQgPSB7XHJcbiAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSB7XHJcbiAgICAgICAgZGV2aWNlSWQ6IHtcclxuICAgICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBjb25zdHJhaW50cztcclxufVxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHNpbGVuY2Ugb24gYSBnaXZlbiBbW1RyYWNrXV0gaW5zdGFuY2UuXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhY2sgc2VlbXMgdG8gYmUgZW50aXJlbHkgc2lsZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZSh0cmFja18xKSB7XHJcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHRyYWNrKSB7XHJcbiAgICBsZXQgdGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IGN0eCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xyXG4gICAgICBpZiAoY3R4KSB7XHJcbiAgICAgICAgY29uc3QgYW5hbHlzZXIgPSBjdHguY3JlYXRlQW5hbHlzZXIoKTtcclxuICAgICAgICBhbmFseXNlci5mZnRTaXplID0gMjA0ODtcclxuICAgICAgICBjb25zdCBidWZmZXJMZW5ndGggPSBhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudDtcclxuICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3RyYWNrLm1lZGlhU3RyZWFtVHJhY2tdKSk7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xyXG4gICAgICAgIHlpZWxkIHNsZWVwKHRpbWVPZmZzZXQpO1xyXG4gICAgICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShkYXRhQXJyYXkpO1xyXG4gICAgICAgIGNvbnN0IHNvbWVOb2lzZSA9IGRhdGFBcnJheS5zb21lKHNhbXBsZSA9PiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDApO1xyXG4gICAgICAgIGN0eC5jbG9zZSgpO1xyXG4gICAgICAgIHJldHVybiAhc29tZU5vaXNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0oKTtcclxuICB9KTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXROZXdBdWRpb0NvbnRleHQoKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IEF1ZGlvQ29udGV4dCA9XHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xyXG4gIGlmIChBdWRpb0NvbnRleHQpIHtcclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoe1xyXG4gICAgICBsYXRlbmN5SGludDogJ2ludGVyYWN0aXZlJ1xyXG4gICAgfSk7XHJcbiAgICAvLyBJZiB0aGUgYXVkaW8gY29udGV4dCBpcyBzdXNwZW5kZWQsIHdlIG5lZWQgdG8gcmVzdW1lIGl0IHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBwYWdlXHJcbiAgICBpZiAoYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gd2luZG93LmRvY3VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm9keSkpIHtcclxuICAgICAgY29uc3QgaGFuZGxlUmVzdW1lID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcclxuICAgICAgICAgICAgeWllbGQgYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgdHJ5aW5nIHRvIGF1dG8tcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gd2luZG93LmRvY3VtZW50LmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXVkaW9Db250ZXh0O1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBraW5kVG9Tb3VyY2Uoa2luZCkge1xyXG4gIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcclxuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcclxuICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xyXG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBUcmFjay5Tb3VyY2UuVW5rbm93bjtcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZSkge1xyXG4gIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSB7XHJcbiAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xyXG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XHJcbiAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpIHtcclxuICB2YXIgX2EsIF9iO1xyXG4gIGxldCB2aWRlb0NvbnN0cmFpbnRzID0gKF9hID0gb3B0aW9ucy52aWRlbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcclxuICAvLyB0cmVhdCAwIGFzIHVuY2FwcGVkXHJcbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAmJiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggPiAwICYmIG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHQgPiAwKSB7XHJcbiAgICB2aWRlb0NvbnN0cmFpbnRzID0gdHlwZW9mIHZpZGVvQ29uc3RyYWludHMgPT09ICdib29sZWFuJyA/IHt9IDogdmlkZW9Db25zdHJhaW50cztcclxuICAgIGlmIChpc1NhZmFyaSgpKSB7XHJcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZpZGVvQ29uc3RyYWludHMpLCB7XHJcbiAgICAgICAgd2lkdGg6IHtcclxuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmlkZW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9Db25zdHJhaW50cyksIHtcclxuICAgICAgICB3aWR0aDoge1xyXG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICBpZGVhbDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgYXVkaW86IChfYiA9IG9wdGlvbnMuYXVkaW8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxyXG4gICAgdmlkZW86IHZpZGVvQ29uc3RyYWludHMsXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBkaXNwbGF5IG1lZGlhIGZlYXR1cmVzXHJcbiAgICBjb250cm9sbGVyOiBvcHRpb25zLmNvbnRyb2xsZXIsXHJcbiAgICBzZWxmQnJvd3NlclN1cmZhY2U6IG9wdGlvbnMuc2VsZkJyb3dzZXJTdXJmYWNlLFxyXG4gICAgc3VyZmFjZVN3aXRjaGluZzogb3B0aW9ucy5zdXJmYWNlU3dpdGNoaW5nLFxyXG4gICAgc3lzdGVtQXVkaW86IG9wdGlvbnMuc3lzdGVtQXVkaW8sXHJcbiAgICBwcmVmZXJDdXJyZW50VGFiOiBvcHRpb25zLnByZWZlckN1cnJlbnRUYWJcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlKSB7XHJcbiAgcmV0dXJuIG1pbWVUeXBlLnNwbGl0KCcvJylbMV0udG9Mb3dlckNhc2UoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyh0cmFja3MpIHtcclxuICBjb25zdCBpbmZvcyA9IFtdO1xyXG4gIHRyYWNrcy5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgIGlmICh0cmFjay50cmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGluZm9zLnB1c2gobmV3IFRyYWNrUHVibGlzaGVkUmVzcG9uc2Uoe1xyXG4gICAgICAgIGNpZDogdHJhY2sudHJhY2subWVkaWFTdHJlYW1JRCxcclxuICAgICAgICB0cmFjazogdHJhY2sudHJhY2tJbmZvXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gaW5mb3M7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykge1xyXG4gIGlmICgnbWVkaWFTdHJlYW1UcmFjaycgaW4gdHJhY2spIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRyYWNrSUQ6IHRyYWNrLnNpZCxcclxuICAgICAgc291cmNlOiB0cmFjay5zb3VyY2UsXHJcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxyXG4gICAgICBlbmFibGVkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQsXHJcbiAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXHJcbiAgICAgIHN0cmVhbUlEOiB0cmFjay5tZWRpYVN0cmVhbUlELFxyXG4gICAgICBzdHJlYW1UcmFja0lEOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0cmFja0lEOiB0cmFjay50cmFja1NpZCxcclxuICAgICAgZW5hYmxlZDogdHJhY2suaXNFbmFibGVkLFxyXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcclxuICAgICAgdHJhY2tJbmZvOiBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICBtaW1lVHlwZTogdHJhY2subWltZVR5cGUsXHJcbiAgICAgICAgbmFtZTogdHJhY2sudHJhY2tOYW1lLFxyXG4gICAgICAgIGVuY3J5cHRlZDogdHJhY2suaXNFbmNyeXB0ZWQsXHJcbiAgICAgICAga2luZDogdHJhY2sua2luZCxcclxuICAgICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZVxyXG4gICAgICB9LCB0cmFjay50cmFjayA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2sudHJhY2spIDoge30pXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBSVENSdHBSZWNlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2dldFN5bmNocm9uaXphdGlvblNvdXJjZXMnIGluIFJUQ1J0cFJlY2VpdmVyO1xyXG59XHJcbmZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKG9sZFZhbHVlcywgbmV3VmFsdWVzKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGlmIChvbGRWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgb2xkVmFsdWVzID0ge307XHJcbiAgfVxyXG4gIGlmIChuZXdWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3VmFsdWVzID0ge307XHJcbiAgfVxyXG4gIGNvbnN0IGFsbEtleXMgPSBbLi4uT2JqZWN0LmtleXMobmV3VmFsdWVzKSwgLi4uT2JqZWN0LmtleXMob2xkVmFsdWVzKV07XHJcbiAgY29uc3QgZGlmZiA9IHt9O1xyXG4gIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcclxuICAgIGlmIChvbGRWYWx1ZXNba2V5XSAhPT0gbmV3VmFsdWVzW2tleV0pIHtcclxuICAgICAgZGlmZltrZXldID0gKF9hID0gbmV3VmFsdWVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGlmZjtcclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucykge1xyXG4gIGNvbnN0IG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcclxuICBsZXQgYXVkaW9Qcm9jZXNzb3I7XHJcbiAgbGV0IHZpZGVvUHJvY2Vzc29yO1xyXG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3IpIHtcclxuICAgIGF1ZGlvUHJvY2Vzc29yID0gbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3I7XHJcbiAgICBuZXdPcHRpb25zLmF1ZGlvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdPcHRpb25zLmF1ZGlvKSwge1xyXG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3IpIHtcclxuICAgIHZpZGVvUHJvY2Vzc29yID0gbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3I7XHJcbiAgICBuZXdPcHRpb25zLnZpZGVvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZXdPcHRpb25zLnZpZGVvKSwge1xyXG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBhdWRpb1Byb2Nlc3NvcixcclxuICAgIHZpZGVvUHJvY2Vzc29yLFxyXG4gICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGNsb25lRGVlcChuZXdPcHRpb25zKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8oc291cmNlKSB7XHJcbiAgc3dpdGNoIChzb3VyY2UpIHtcclxuICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxyXG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLkNhbWVyYTtcclxuICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcclxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xyXG4gICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XHJcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XHJcbiAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcclxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5Vbmtub3duO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmNsYXNzIEUyRUVNYW5hZ2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IGV2ID0+IHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIGtpbmQsXHJcbiAgICAgICAgZGF0YVxyXG4gICAgICB9ID0gZXYuZGF0YTtcclxuICAgICAgc3dpdGNoIChraW5kKSB7XHJcbiAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcihkYXRhLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGRhdGEuZXJyb3IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaW5pdEFjayc6XHJcbiAgICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XHJcbiAgICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2V5UHJvdmlkZXIuZ2V0S2V5cygpLmZvckVhY2goa2V5SW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25FbmFibGVkICE9PSBkYXRhLmVuYWJsZWQgJiYgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBkYXRhLmVuYWJsZWQsIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgICAgICAgICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGRhdGEuZW5hYmxlZDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gKF9iID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XHJcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjb3VsZG4ndCBzZXQgZW5jcnlwdGlvbiBzdGF0dXMsIHBhcnRpY2lwYW50IG5vdCBmb3VuZFwiLmNvbmNhdChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGRhdGEuZW5hYmxlZCwgcGFydGljaXBhbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmF0Y2hldEtleSc6XHJcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGRhdGEucmF0Y2hldFJlc3VsdCwgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5LCBkYXRhLmtleUluZGV4KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbldvcmtlckVycm9yID0gZXYgPT4ge1xyXG4gICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKCdlMmVlIHdvcmtlciBlbmNvdW50ZXJlZCBhbiBlcnJvcjonLCB7XHJcbiAgICAgICAgZXJyb3I6IGV2LmVycm9yXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXYuZXJyb3IpO1xyXG4gICAgfTtcclxuICAgIHRoaXMua2V5UHJvdmlkZXIgPSBvcHRpb25zLmtleVByb3ZpZGVyO1xyXG4gICAgdGhpcy53b3JrZXIgPSBvcHRpb25zLndvcmtlcjtcclxuICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc2V0dXAocm9vbSkge1xyXG4gICAgaWYgKCFpc0UyRUVTdXBwb3J0ZWQoKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigndHJpZWQgdG8gc2V0dXAgZW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9uIGFuIHVuc3VwcG9ydGVkIGJyb3dzZXInKTtcclxuICAgIH1cclxuICAgIGxpdmVraXRMb2dnZXIuaW5mbygnc2V0dGluZyB1cCBlMmVlJyk7XHJcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XHJcbiAgICAgIHRoaXMucm9vbSA9IHJvb207XHJcbiAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycyhyb29tLCB0aGlzLmtleVByb3ZpZGVyKTtcclxuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcclxuICAgICAgY29uc3QgbXNnID0ge1xyXG4gICAgICAgIGtpbmQ6ICdpbml0JyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBrZXlQcm92aWRlck9wdGlvbnM6IHRoaXMua2V5UHJvdmlkZXIuZ2V0T3B0aW9ucygpLFxyXG4gICAgICAgICAgbG9nbGV2ZWw6IHdvcmtlckxvZ2dlci5nZXRMZXZlbCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAodGhpcy53b3JrZXIpIHtcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJpbml0aWFsaXppbmcgd29ya2VyXCIsIHtcclxuICAgICAgICAgIHdvcmtlcjogdGhpcy53b3JrZXJcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLm9uV29ya2VyTWVzc2FnZTtcclxuICAgICAgICB0aGlzLndvcmtlci5vbmVycm9yID0gdGhpcy5vbldvcmtlckVycm9yO1xyXG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XHJcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwic2V0IGUyZWUgdG8gXCIuY29uY2F0KGVuYWJsZWQsIFwiIGZvciBwYXJ0aWNpcGFudCBcIikuY29uY2F0KHBhcnRpY2lwYW50SWRlbnRpdHkpKTtcclxuICAgIHRoaXMucG9zdEVuYWJsZShlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc2V0U2lmVHJhaWxlcih0cmFpbGVyKSB7XHJcbiAgICBpZiAoIXRyYWlsZXIgfHwgdHJhaWxlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiaWdub3Jpbmcgc2VydmVyIHNlbnQgdHJhaWxlciBhcyBpdCdzIGVtcHR5XCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5wb3N0U2lmVHJhaWxlcih0cmFpbGVyKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XHJcbiAgICBlbmdpbmUub24oRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCA9PiB7XHJcbiAgICAgIHRoaXMucG9zdFJUUE1hcChydHBNYXApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbSwga2V5UHJvdmlkZXIpIHtcclxuICAgIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAocHViLCBwYXJ0aWNpcGFudCkgPT4gdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KSk7XHJcbiAgICByb29tLm9uKFJvb21FdmVudC5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLCBzdGF0ZSA9PiB7XHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xyXG4gICAgICAgIHJvb20ucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4ge1xyXG4gICAgICAgICAgcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQocHViLnRyYWNrSW5mby5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSwgcGFydGljaXBhbnQuaWRlbnRpdHkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgKHRyYWNrLCBfLCBwYXJ0aWNpcGFudCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAgICBraW5kOiAncmVtb3ZlVHJhbnNmb3JtJyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudC5pZGVudGl0eSxcclxuICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLm1lZGlhU3RyZWFtSURcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIChfYSA9IHRoaXMud29ya2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UobXNnKTtcclxuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHViLCBwYXJ0aWNpcGFudCkgPT4ge1xyXG4gICAgICB0aGlzLnNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCBwYXJ0aWNpcGFudC5pZGVudGl0eSwgcHViLnRyYWNrSW5mbyk7XHJcbiAgICB9KS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5yb29tKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGVkIHJvb20gdG8gYmUgcHJlc2VudCBvbiBzaWduYWwgY29ubmVjdFwiKTtcclxuICAgICAgfVxyXG4gICAgICBrZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcclxuICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQodGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaXNFMkVFRW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpO1xyXG4gICAgfSk7XHJcbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMuc2V0dXBFMkVFU2VuZGVyKHB1YmxpY2F0aW9uLnRyYWNrLCBwdWJsaWNhdGlvbi50cmFjay5zZW5kZXIpO1xyXG4gICAgfSkpO1xyXG4gICAga2V5UHJvdmlkZXIub24oS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIGtleUluZm8gPT4gdGhpcy5wb3N0S2V5KGtleUluZm8pKS5vbihLZXlQcm92aWRlckV2ZW50LlJhdGNoZXRSZXF1ZXN0LCAocGFydGljaXBhbnRJZCwga2V5SW5kZXgpID0+IHRoaXMucG9zdFJhdGNoZXRSZXF1ZXN0KHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSk7XHJcbiAgfVxyXG4gIHBvc3RSYXRjaGV0UmVxdWVzdChwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCkge1xyXG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xyXG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHJhdGNoZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXNnID0ge1xyXG4gICAgICBraW5kOiAncmF0Y2hldFJlcXVlc3QnLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcclxuICAgICAgICBrZXlJbmRleFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcclxuICB9XHJcbiAgcG9zdEtleShfcmVmKSB7XHJcbiAgICBsZXQge1xyXG4gICAgICBrZXksXHJcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXHJcbiAgICAgIGtleUluZGV4XHJcbiAgICB9ID0gX3JlZjtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICghdGhpcy53b3JrZXIpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBzZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXNnID0ge1xyXG4gICAgICBraW5kOiAnc2V0S2V5JyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXHJcbiAgICAgICAgaXNQdWJsaXNoZXI6IHBhcnRpY2lwYW50SWRlbnRpdHkgPT09ICgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSxcclxuICAgICAgICBrZXksXHJcbiAgICAgICAga2V5SW5kZXhcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgfVxyXG4gIHBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSkge1xyXG4gICAgaWYgKHRoaXMud29ya2VyKSB7XHJcbiAgICAgIGNvbnN0IGVuYWJsZU1zZyA9IHtcclxuICAgICAgICBraW5kOiAnZW5hYmxlJyxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICBlbmFibGVkLFxyXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZW5hYmxlTXNnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignZmFpbGVkIHRvIGVuYWJsZSBlMmVlLCB3b3JrZXIgaXMgbm90IHJlYWR5Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBvc3RSVFBNYXAobWFwKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XHJcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgd29ya2VyIGlzIG1pc3NpbmcnKTtcclxuICAgIH1cclxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpKSB7XHJcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgbG9jYWwgcGFydGljaXBhbnQgaWRlbnRpdHkgaXMgbWlzc2luZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbXNnID0ge1xyXG4gICAgICBraW5kOiAnc2V0UlRQTWFwJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIG1hcCxcclxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcclxuICB9XHJcbiAgcG9zdFNpZlRyYWlsZXIodHJhaWxlcikge1xyXG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xyXG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHBvc3QgU0lGIHRyYWlsZXIsIHdvcmtlciBpcyBtaXNzaW5nJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgIGtpbmQ6ICdzZXRTaWZUcmFpbGVyJyxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHRyYWlsZXJcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XHJcbiAgfVxyXG4gIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCByZW1vdGVJZCwgdHJhY2tJbmZvKSB7XHJcbiAgICBpZiAoIXRyYWNrLnJlY2VpdmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKHRyYWNrSW5mbyA9PT0gbnVsbCB8fCB0cmFja0luZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrSW5mby5taW1lVHlwZSkgfHwgdHJhY2tJbmZvLm1pbWVUeXBlID09PSAnJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaW1lVHlwZSBtaXNzaW5nIGZyb20gdHJhY2tJbmZvLCBjYW5ub3Qgc2V0IHVwIEUyRUUgY3J5cHRvcicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5oYW5kbGVSZWNlaXZlcih0cmFjay5yZWNlaXZlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgcmVtb3RlSWQsIHRyYWNrLmtpbmQgPT09ICd2aWRlbycgPyBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyh0cmFja0luZm8ubWltZVR5cGUpIDogdW5kZWZpbmVkKTtcclxuICB9XHJcbiAgc2V0dXBFMkVFU2VuZGVyKHRyYWNrLCBzZW5kZXIpIHtcclxuICAgIGlmICghaXNMb2NhbFRyYWNrKHRyYWNrKSB8fCAhc2VuZGVyKSB7XHJcbiAgICAgIGlmICghc2VuZGVyKSBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vhcmx5IHJldHVybiBiZWNhdXNlIHNlbmRlciBpcyBub3QgcmVhZHknKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5oYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFjay5tZWRpYVN0cmVhbUlELCB1bmRlZmluZWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcclxuICAgKiBhIGZyYW1lIGRlY29kZXIuXHJcbiAgICpcclxuICAgKi9cclxuICBoYW5kbGVSZWNlaXZlcihyZWNlaXZlciwgdHJhY2tJZCwgcGFydGljaXBhbnRJZGVudGl0eSwgY29kZWMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAga2luZDogJ2RlY29kZScsXHJcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxyXG4gICAgICAgICAgdHJhY2tJZCxcclxuICAgICAgICAgIGNvZGVjXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgcmVjZWl2ZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKEUyRUVfRkxBRyBpbiByZWNlaXZlciAmJiBjb2RlYykge1xyXG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgY29kZWNcclxuICAgICAgICAgIGNvbnN0IG1zZyA9IHtcclxuICAgICAgICAgICAga2luZDogJ3VwZGF0ZUNvZGVjJyxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgIHRyYWNrSWQsXHJcbiAgICAgICAgICAgICAgY29kZWMsXHJcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCB3cml0YWJsZSA9IHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBsZXQgcmVhZGFibGUgPSByZWNlaXZlci5yZWFkYWJsZVN0cmVhbTtcclxuICAgICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJTdHJlYW1zID0gcmVjZWl2ZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcclxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgIHJlY2VpdmVyLndyaXRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xyXG4gICAgICAgICAgd3JpdGFibGUgPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICByZWNlaXZlci5yZWFkYWJsZVN0cmVhbSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcclxuICAgICAgICAgIHJlYWRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgcmVhZGFibGVTdHJlYW06IHJlYWRhYmxlLFxyXG4gICAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXHJcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrSWQsXHJcbiAgICAgICAgICAgIGNvZGVjLFxyXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtyZWFkYWJsZSwgd3JpdGFibGVdKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIHJlY2VpdmVyW0UyRUVfRkxBR10gPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXMgdGhlIGdpdmVuIHtAY29kZSBSVENSdHBTZW5kZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcclxuICAgKiBhIGZyYW1lIGVuY29kZXIuXHJcbiAgICpcclxuICAgKi9cclxuICBoYW5kbGVTZW5kZXIoc2VuZGVyLCB0cmFja0lkLCBjb2RlYykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKEUyRUVfRkxBRyBpbiBzZW5kZXIgfHwgIXRoaXMud29ya2VyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKChfYSA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpIHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xyXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2xvY2FsIGlkZW50aXR5IG5lZWRzIHRvIGJlIGtub3duIGluIG9yZGVyIHRvIHNldCB1cCBlbmNyeXB0ZWQgc2VuZGVyJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xyXG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgc2NyaXB0IHRyYW5zZm9ybScpO1xyXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxyXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxyXG4gICAgICAgIHRyYWNrSWQsXHJcbiAgICAgICAgY29kZWNcclxuICAgICAgfTtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBzZW5kZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgY29uc3Qgc2VuZGVyU3RyZWFtcyA9IHNlbmRlci5jcmVhdGVFbmNvZGVkU3RyZWFtcygpO1xyXG4gICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAga2luZDogJ2VuY29kZScsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXHJcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogc2VuZGVyU3RyZWFtcy53cml0YWJsZSxcclxuICAgICAgICAgIGNvZGVjLFxyXG4gICAgICAgICAgdHJhY2tJZCxcclxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLCBzZW5kZXJTdHJlYW1zLndyaXRhYmxlXSk7XHJcbiAgICB9XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBzZW5kZXJbRTJFRV9GTEFHXSA9IHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBkZWZhdWx0SWQgPSAnZGVmYXVsdCc7XHJcbmNsYXNzIERldmljZU1hbmFnZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fcHJldmlvdXNEZXZpY2VzID0gW107XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBEZXZpY2VNYW5hZ2VyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICB9XHJcbiAgZ2V0IHByZXZpb3VzRGV2aWNlcygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0RldmljZXM7XHJcbiAgfVxyXG4gIGdldERldmljZXMoa2luZF8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCkge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICBsZXQgcmVxdWVzdFBlcm1pc3Npb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCgoX2EgPSBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSA+IDApIHtcclxuICAgICAgICAgIGxpdmVraXRMb2dnZXIuZGVidWcoJ2F3YWl0aW5nIGdldFVzZXJNZWRpYSBwcm9taXNlJyk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoa2luZCkge1xyXG4gICAgICAgICAgICAgIHlpZWxkIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5nZXQoa2luZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnZhbHVlcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2Vycm9yIHdhaXRpbmcgZm9yIG1lZGlhIHBlcm1pc3NvbnMnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcclxuICAgICAgICBpZiAocmVxdWVzdFBlcm1pc3Npb25zICYmXHJcbiAgICAgICAgLy8gZm9yIHNhZmFyaSB3ZSBuZWVkIHRvIHNraXAgdGhpcyBjaGVjaywgYXMgb3RoZXJ3aXNlIGl0IHdpbGwgcmUtYWNxdWlyZSB1c2VyIG1lZGlhIGFuZCBmYWlsIG9uIGlPUyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXHJcbiAgICAgICAgIShpc1NhZmFyaSgpICYmIF90aGlzLmhhc0RldmljZUluVXNlKGtpbmQpKSkge1xyXG4gICAgICAgICAgY29uc3QgaXNEdW1teURldmljZU9yRW1wdHkgPSBkZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0ga2luZCkubGVuZ3RoID09PSAwIHx8IGRldmljZXMuc29tZShkZXZpY2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub0xhYmVsID0gZGV2aWNlLmxhYmVsID09PSAnJztcclxuICAgICAgICAgICAgY29uc3QgaXNSZWxldmFudCA9IGtpbmQgPyBkZXZpY2Uua2luZCA9PT0ga2luZCA6IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBub0xhYmVsICYmIGlzUmVsZXZhbnQ7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlmIChpc0R1bW15RGV2aWNlT3JFbXB0eSkge1xyXG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcclxuICAgICAgICAgICAgICB2aWRlbzoga2luZCAhPT0gJ2F1ZGlvaW5wdXQnICYmIGtpbmQgIT09ICdhdWRpb291dHB1dCcsXHJcbiAgICAgICAgICAgICAgYXVkaW86IGtpbmQgIT09ICd2aWRlb2lucHV0JyAmJiB7XHJcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDoge1xyXG4gICAgICAgICAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShwZXJtaXNzaW9uc1RvQWNxdWlyZSk7XHJcbiAgICAgICAgICAgIGRldmljZXMgPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcclxuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLl9wcmV2aW91c0RldmljZXMgPSBkZXZpY2VzO1xyXG4gICAgICAgIGlmIChraW5kKSB7XHJcbiAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZGV2aWNlID0+IGRldmljZS5raW5kID09PSBraW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRldmljZXM7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBub3JtYWxpemVEZXZpY2VJZChraW5kLCBkZXZpY2VJZCwgZ3JvdXBJZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcclxuICAgICAgICByZXR1cm4gZGV2aWNlSWQ7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXHJcbiAgICAgIC8vIGRldmljZSBoYXMgYmVlbiBjaG9zZW5cclxuICAgICAgY29uc3QgZGV2aWNlcyA9IHlpZWxkIHRoaXMuZ2V0RGV2aWNlcyhraW5kKTtcclxuICAgICAgY29uc3QgZGVmYXVsdERldmljZSA9IGRldmljZXMuZmluZChkID0+IGQuZGV2aWNlSWQgPT09IGRlZmF1bHRJZCk7XHJcbiAgICAgIGlmICghZGVmYXVsdERldmljZSkge1xyXG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IHJlbGlhYmx5IGRldGVybWluZSBkZWZhdWx0IGRldmljZScpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlcy5maW5kKGQgPT4gZC5kZXZpY2VJZCAhPT0gZGVmYXVsdElkICYmIGQuZ3JvdXBJZCA9PT0gKGdyb3VwSWQgIT09IG51bGwgJiYgZ3JvdXBJZCAhPT0gdm9pZCAwID8gZ3JvdXBJZCA6IGRlZmF1bHREZXZpY2UuZ3JvdXBJZCkpO1xyXG4gICAgICBpZiAoIWRldmljZSkge1xyXG4gICAgICAgIGxpdmVraXRMb2dnZXIud2FybignY291bGQgbm90IHJlbGlhYmx5IGRldGVybWluZSBkZWZhdWx0IGRldmljZScpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRldmljZSA9PT0gbnVsbCB8fCBkZXZpY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRldmljZS5kZXZpY2VJZDtcclxuICAgIH0pO1xyXG4gIH1cclxuICBoYXNEZXZpY2VJblVzZShraW5kKSB7XHJcbiAgICByZXR1cm4ga2luZCA/IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5oYXMoa2luZCkgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XHJcbiAgfVxyXG59XHJcbkRldmljZU1hbmFnZXIubWVkaWFEZXZpY2VLaW5kcyA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XHJcbkRldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcCA9IG5ldyBNYXAoKTtcclxuXHJcbnZhciBRdWV1ZVRhc2tTdGF0dXM7XHJcbihmdW5jdGlvbiAoUXVldWVUYXNrU3RhdHVzKSB7XHJcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIldBSVRJTkdcIl0gPSAwXSA9IFwiV0FJVElOR1wiO1xyXG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcclxuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiQ09NUExFVEVEXCJdID0gMl0gPSBcIkNPTVBMRVRFRFwiO1xyXG59KShRdWV1ZVRhc2tTdGF0dXMgfHwgKFF1ZXVlVGFza1N0YXR1cyA9IHt9KSk7XHJcbmNsYXNzIEFzeW5jUXVldWUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5wZW5kaW5nVGFza3MgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnRhc2tNdXRleCA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLm5leHRUYXNrSW5kZXggPSAwO1xyXG4gIH1cclxuICBydW4odGFzaykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdGFza0luZm8gPSB7XHJcbiAgICAgICAgaWQ6IHRoaXMubmV4dFRhc2tJbmRleCsrLFxyXG4gICAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXHJcbiAgICAgICAgc3RhdHVzOiBRdWV1ZVRhc2tTdGF0dXMuV0FJVElOR1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5zZXQodGFza0luZm8uaWQsIHRhc2tJbmZvKTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy50YXNrTXV0ZXgubG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRhc2tJbmZvLmV4ZWN1dGVkQXQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5SVU5OSU5HO1xyXG4gICAgICAgIHJldHVybiB5aWVsZCB0YXNrKCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLkNPTVBMRVRFRDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5kZWxldGUodGFza0luZm8uaWQpO1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZmx1c2goKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ydW4oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge30pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzbmFwc2hvdCgpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ1Rhc2tzLnZhbHVlcygpKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJ0Y1VybCh1cmwsIHNlYXJjaFBhcmFtcykge1xyXG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9XZWJzb2NrZXRVcmwodXJsKSk7XHJcbiAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgJ3J0YycpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1dzVXJsKSB7XHJcbiAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh0b0h0dHBVcmwocnRjV3NVcmwpKTtcclxuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICd2YWxpZGF0ZScpO1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVRyYWlsaW5nU2xhc2gocGF0aCkge1xyXG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgPyBwYXRoIDogXCJcIi5jb25jYXQocGF0aCwgXCIvXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGVuZFVybFBhdGgodXJsT2JqLCBwYXRoKSB7XHJcbiAgdXJsT2JqLnBhdGhuYW1lID0gXCJcIi5jb25jYXQoZW5zdXJlVHJhaWxpbmdTbGFzaCh1cmxPYmoucGF0aG5hbWUpKS5jb25jYXQocGF0aCk7XHJcbiAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xyXG59XHJcblxyXG5jb25zdCBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyA9IFsnc3luY1N0YXRlJywgJ3RyaWNrbGUnLCAnb2ZmZXInLCAnYW5zd2VyJywgJ3NpbXVsYXRlJywgJ2xlYXZlJ107XHJcbmZ1bmN0aW9uIGNhblBhc3NUaHJvdWdoUXVldWUocmVxKSB7XHJcbiAgY29uc3QgY2FuUGFzcyA9IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzLmluZGV4T2YocmVxLmNhc2UpID49IDA7XHJcbiAgbGl2ZWtpdExvZ2dlci50cmFjZSgncmVxdWVzdCBhbGxvd2VkIHRvIGJ5cGFzcyBxdWV1ZTonLCB7XHJcbiAgICBjYW5QYXNzLFxyXG4gICAgcmVxXHJcbiAgfSk7XHJcbiAgcmV0dXJuIGNhblBhc3M7XHJcbn1cclxudmFyIFNpZ25hbENvbm5lY3Rpb25TdGF0ZTtcclxuKGZ1bmN0aW9uIChTaWduYWxDb25uZWN0aW9uU3RhdGUpIHtcclxuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDBdID0gXCJDT05ORUNUSU5HXCI7XHJcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDFdID0gXCJDT05ORUNURURcIjtcclxuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xyXG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJESVNDT05ORUNUSU5HXCJdID0gM10gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcclxuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVEVEXCJdID0gNF0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xyXG59KShTaWduYWxDb25uZWN0aW9uU3RhdGUgfHwgKFNpZ25hbENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuY2xhc3MgU2lnbmFsQ2xpZW50IHtcclxuICBnZXQgY3VycmVudFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgfVxyXG4gIGdldCBpc0Rpc2Nvbm5lY3RlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fCB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xyXG4gIH1cclxuICBnZXQgaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XHJcbiAgfVxyXG4gIGdldE5leHRSZXF1ZXN0SWQoKSB7XHJcbiAgICB0aGlzLl9yZXF1ZXN0SWQgKz0gMTtcclxuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0SWQ7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbGV0IHVzZUpTT04gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xyXG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLyoqIHNpZ25hbCBydHQgaW4gbWlsbGlzZWNvbmRzICovXHJcbiAgICB0aGlzLnJ0dCA9IDA7XHJcbiAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcclxuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcclxuICAgIHRoaXMuX3JlcXVlc3RJZCA9IDA7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0aGlzLnJlc2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLm9uQW5zd2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uTGVhdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uTmVnb3RpYXRlUmVxdWVzdGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uT2ZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLm9uVHJpY2tsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5vbkNsb3NlID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuU2lnbmFsKTtcclxuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XHJcbiAgICB0aGlzLnVzZUpTT04gPSB1c2VKU09OO1xyXG4gICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xyXG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cyA9IFtdO1xyXG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25Mb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcclxuICB9XHJcbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgLy8gZHVyaW5nIGEgZnVsbCByZWNvbm5lY3QsIHdlJ2Qgd2FudCB0byBzdGFydCB0aGUgc2VxdWVuY2UgZXZlbiBpZiBjdXJyZW50bHlcclxuICAgICAgLy8gY29ubmVjdGVkXHJcbiAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORztcclxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0cztcclxuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0pO1xyXG4gIH1cclxuICByZWNvbm5lY3QodXJsLCB0b2tlbiwgc2lkLCByZWFzb24pIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIHRvIHJlY29ubmVjdCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIGJlaW5nIHNldCwgaWdub3JpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcclxuICAgICAgLy8gY2xlYXIgcGluZyBpbnRlcnZhbCBhbmQgcmVzdGFydCBpdCBvbmNlIHJlY29ubmVjdGVkXHJcbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcclxuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwge1xyXG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcclxuICAgICAgICBzaWQsXHJcbiAgICAgICAgcmVjb25uZWN0UmVhc29uOiByZWFzb25cclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVjb25uZWN0UmVzcG9uc2UpIHtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XHJcbiAgICB0aGlzLmNvbm5lY3RPcHRpb25zID0gb3B0cztcclxuICAgIGNvbnN0IGNsaWVudEluZm8gPSBnZXRDbGllbnRJbmZvKCk7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBjbGllbnRJbmZvLCBvcHRzKTtcclxuICAgIGNvbnN0IHJ0Y1VybCA9IGNyZWF0ZVJ0Y1VybCh1cmwsIHBhcmFtcyk7XHJcbiAgICBjb25zdCB2YWxpZGF0ZVVybCA9IGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1VybCk7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcclxuICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkIChzaWduYWwpJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHdzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgdGltZWQgb3V0IChzaWduYWwpJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSk7XHJcbiAgICAgICAgfSwgb3B0cy53ZWJzb2NrZXRUaW1lb3V0KTtcclxuICAgICAgICBpZiAoYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgIGNvbnN0IHJlZGFjdGVkVXJsID0gbmV3IFVSTChydGNVcmwpO1xyXG4gICAgICAgIGlmIChyZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuaGFzKCdhY2Nlc3NfdG9rZW4nKSkge1xyXG4gICAgICAgICAgcmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLnNldCgnYWNjZXNzX3Rva2VuJywgJzxyZWRhY3RlZD4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdChyZWRhY3RlZFVybCksIE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgcmVjb25uZWN0OiBvcHRzLnJlY29ubmVjdCxcclxuICAgICAgICAgIHJlY29ubmVjdFJlYXNvbjogb3B0cy5yZWNvbm5lY3RSZWFzb25cclxuICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgICAgICBpZiAodGhpcy53cykge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5jbG9zZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHJ0Y1VybCk7XHJcbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB5aWVsZCBmZXRjaCh2YWxpZGF0ZVVybCk7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB5aWVsZCByZXNwLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKG1zZywgQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQsIHJlc3Auc3RhdHVzKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKFwiRW5jb3VudGVyZWQgdW5rbm93biB3ZWJzb2NrZXQgZXJyb3IgZHVyaW5nIGNvbm5lY3Rpb246IFwiLmNvbmNhdChldi50b1N0cmluZygpKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsIHJlc3Auc3RhdHVzKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ3NlcnZlciB3YXMgbm90IHJlYWNoYWJsZScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIG90aGVyIGVycm9ycywgaGFuZGxlXHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVdTRXJyb3IoZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAvLyBub3QgY29uc2lkZXJlZCBjb25uZWN0ZWQgdW50aWwgSm9pblJlc3BvbnNlIGlzIHJlY2VpdmVkXHJcbiAgICAgICAgICBsZXQgcmVzcDtcclxuICAgICAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XHJcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tSnNvbihqc29uLCB7XHJcbiAgICAgICAgICAgICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGV2LmRhdGEpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFwiY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZTogXCIuY29uY2F0KHR5cGVvZiBldi5kYXRhKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQpIHtcclxuICAgICAgICAgICAgbGV0IHNob3VsZFByb2Nlc3NNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBqb2luIG1lc3NhZ2Ugb25seVxyXG4gICAgICAgICAgICBpZiAoKChfYSA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnam9pbicpIHtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcclxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA9IHJlc3AubWVzc2FnZS52YWx1ZS5waW5nVGltZW91dDtcclxuICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uID0gcmVzcC5tZXNzYWdlLnZhbHVlLnBpbmdJbnRlcnZhbDtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5waW5nVGltZW91dER1cmF0aW9uICYmIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwaW5nIGNvbmZpZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UGluZ0ludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcC5tZXNzYWdlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmIHJlc3AubWVzc2FnZS5jYXNlICE9PSAnbGVhdmUnKSB7XHJcbiAgICAgICAgICAgICAgLy8gaW4gcmVjb25uZWN0aW5nLCBhbnkgbWVzc2FnZSByZWNlaXZlZCBtZWFucyBzaWduYWwgcmVjb25uZWN0ZWRcclxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcclxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3AubWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAncmVjb25uZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLm1lc3NhZ2UudmFsdWUpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZGVjbGFyaW5nIHNpZ25hbCByZWNvbm5lY3RlZCB3aXRob3V0IHJlY29ubmVjdCByZXNwb25zZSByZWNlaXZlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRQcm9jZXNzTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uICYmIHJlc3AubWVzc2FnZS5jYXNlID09PSAnbGVhdmUnKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ1JlY2VpdmVkIGxlYXZlIHJlcXVlc3Qgd2hpbGUgdHJ5aW5nIHRvIChyZSljb25uZWN0JywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCwgdW5kZWZpbmVkLCByZXNwLm1lc3NhZ2UudmFsdWUucmVhc29uKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdHMucmVjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgLy8gbm9uLXJlY29ubmVjdCBjYXNlLCBzaG91bGQgcmVjZWl2ZSBqb2luIHJlc3BvbnNlIGZpcnN0XHJcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoXCJkaWQgbm90IHJlY2VpdmUgam9pbiByZXNwb25zZSwgZ290IFwiLmNvbmNhdCgoX2MgPSByZXNwLm1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXNlLCBcIiBpbnN0ZWFkXCIpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc2hvdWxkUHJvY2Vzc01lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnNpZ25hbExhdGVuY3kpIHtcclxuICAgICAgICAgICAgeWllbGQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVzcG9uc2UocmVzcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gZXYgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdXZWJzb2NrZXQgZ290IGNsb3NlZCBkdXJpbmcgYSAocmUpY29ubmVjdGlvbiBhdHRlbXB0JywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJ3ZWJzb2NrZXQgY2xvc2VkXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICByZWFzb246IGV2LnJlYXNvbixcclxuICAgICAgICAgICAgY29kZTogZXYuY29kZSxcclxuICAgICAgICAgICAgd2FzQ2xlYW46IGV2Lndhc0NsZWFuLFxyXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKGV2LnJlYXNvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gIH1cclxuICBjbG9zZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgbGV0IHVwZGF0ZVN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCBfdGhpcy5jbG9zaW5nTG9jay5sb2NrKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIF90aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XHJcbiAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpIHtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChfdGhpcy53cykge1xyXG4gICAgICAgICAgICBfdGhpcy53cy5vbm1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy53cy5vbm9wZW4gPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy53cy5vbmNsb3NlID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gY2FsbGluZyBgd3MuY2xvc2UoKWAgb25seSBzdGFydHMgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIChDTE9TSU5HIHN0YXRlKSwgcHJlZmVyIHRvIHdhaXQgdW50aWwgc3RhdGUgaXMgYWN0dWFsbHkgQ0xPU0VEXHJcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChfdGhpcy53cykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMud3Mub25jbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy53cy5yZWFkeVN0YXRlIDwgX3RoaXMud3MuQ0xPU0lORykge1xyXG4gICAgICAgICAgICAgIF90aGlzLndzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgLy8gMjUwbXMgZ3JhY2UgcGVyaW9kIGZvciB3cyB0byBjbG9zZSBncmFjZWZ1bGx5XHJcbiAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFtjbG9zZVByb21pc2UsIHNsZWVwKDI1MCldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy53cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHVubG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIGluaXRpYWwgb2ZmZXIgYWZ0ZXIgam9pbmluZ1xyXG4gIHNlbmRPZmZlcihvZmZlcikge1xyXG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgb2ZmZXJTZHA6IG9mZmVyLnNkcFxyXG4gICAgfSkpO1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICdvZmZlcicsXHJcbiAgICAgIHZhbHVlOiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG9mZmVyKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIGFuc3dlciBhIHNlcnZlci1pbml0aWF0ZWQgb2ZmZXJcclxuICBzZW5kQW5zd2VyKGFuc3dlcikge1xyXG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIGFuc3dlclNkcDogYW5zd2VyLnNkcFxyXG4gICAgfSkpO1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnYW5zd2VyJyxcclxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcclxuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGljZSBjYW5kaWRhdGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgY2FuZGlkYXRlXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICd0cmlja2xlJyxcclxuICAgICAgdmFsdWU6IG5ldyBUcmlja2xlUmVxdWVzdCh7XHJcbiAgICAgICAgY2FuZGlkYXRlSW5pdDogSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSxcclxuICAgICAgICB0YXJnZXRcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnbXV0ZScsXHJcbiAgICAgIHZhbHVlOiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCh7XHJcbiAgICAgICAgc2lkOiB0cmFja1NpZCxcclxuICAgICAgICBtdXRlZFxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRBZGRUcmFjayhyZXEpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ2FkZFRyYWNrJyxcclxuICAgICAgdmFsdWU6IHJlcVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKG1ldGFkYXRhXzEsIG5hbWVfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1ldGFkYXRhLCBuYW1lKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICBsZXQgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IF90aGlzMi5nZXROZXh0UmVxdWVzdElkKCk7XHJcbiAgICAgICAgeWllbGQgX3RoaXMyLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgICAgIGNhc2U6ICd1cGRhdGVNZXRhZGF0YScsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IFVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEoe1xyXG4gICAgICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhLFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SWQ7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncykge1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICd0cmFja1NldHRpbmcnLFxyXG4gICAgICB2YWx1ZTogc2V0dGluZ3NcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yikge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uJyxcclxuICAgICAgdmFsdWU6IHN1YlxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRTeW5jU3RhdGUoc3luYykge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnc3luY1N0YXRlJyxcclxuICAgICAgdmFsdWU6IHN5bmNcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kVXBkYXRlVmlkZW9MYXllcnModHJhY2tTaWQsIGxheWVycykge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAndXBkYXRlTGF5ZXJzJyxcclxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVWaWRlb0xheWVycyh7XHJcbiAgICAgICAgdHJhY2tTaWQsXHJcbiAgICAgICAgbGF5ZXJzXHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50cywgdHJhY2tQZXJtaXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbicsXHJcbiAgICAgIHZhbHVlOiBuZXcgU3Vic2NyaXB0aW9uUGVybWlzc2lvbih7XHJcbiAgICAgICAgYWxsUGFydGljaXBhbnRzLFxyXG4gICAgICAgIHRyYWNrUGVybWlzc2lvbnNcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kU2ltdWxhdGVTY2VuYXJpbyhzY2VuYXJpbykge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAnc2ltdWxhdGUnLFxyXG4gICAgICB2YWx1ZTogc2NlbmFyaW9cclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kUGluZygpIHtcclxuICAgIC8qKiBzZW5kIGJvdGggb2YgcGluZyBhbmQgcGluZ1JlcSBmb3IgY29tcGF0aWJpbGl0eSB0byBvbGQgYW5kIG5ldyBzZXJ2ZXIgKi9cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5zZW5kUmVxdWVzdCh7XHJcbiAgICAgIGNhc2U6ICdwaW5nJyxcclxuICAgICAgdmFsdWU6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSlcclxuICAgIH0pLCB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ3BpbmdSZXEnLFxyXG4gICAgICB2YWx1ZTogbmV3IFBpbmcoe1xyXG4gICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKSxcclxuICAgICAgICBydHQ6IHByb3RvSW50NjQucGFyc2UodGhpcy5ydHQpXHJcbiAgICAgIH0pXHJcbiAgICB9KV0pO1xyXG4gIH1cclxuICBzZW5kVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHRyYWNrU2lkLCBmZWF0dXJlcykge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xyXG4gICAgICBjYXNlOiAndXBkYXRlQXVkaW9UcmFjaycsXHJcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHtcclxuICAgICAgICB0cmFja1NpZCxcclxuICAgICAgICBmZWF0dXJlc1xyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRMZWF2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcclxuICAgICAgY2FzZTogJ2xlYXZlJyxcclxuICAgICAgdmFsdWU6IG5ldyBMZWF2ZVJlcXVlc3Qoe1xyXG4gICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxyXG4gICAgICAgIC8vIHNlcnZlciBkb2Vzbid0IHByb2Nlc3MgdGhpcyBmaWVsZCwga2VlcGluZyBpdCBoZXJlIHRvIGluZGljYXRlIHRoZSBpbnRlbnQgb2YgYSBmdWxsIGRpc2Nvbm5lY3RcclxuICAgICAgICBhY3Rpb246IExlYXZlUmVxdWVzdF9BY3Rpb24uRElTQ09OTkVDVFxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRSZXF1ZXN0KG1lc3NhZ2VfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgIGxldCBmcm9tUXVldWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBjYXB0dXJlIGFsbCByZXF1ZXN0cyB3aGlsZSByZWNvbm5lY3RpbmcgYW5kIHB1dCB0aGVtIGluIGEgcXVldWVcclxuICAgICAgICAvLyB1bmxlc3MgdGhlIHJlcXVlc3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBxdWV1ZSwgdGhlbiBkb24ndCBlbnF1ZXVlIGFnYWluXHJcbiAgICAgICAgY29uc3QgY2FuUXVldWUgPSAhZnJvbVF1ZXVlICYmICFjYW5QYXNzVGhyb3VnaFF1ZXVlKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmIChjYW5RdWV1ZSAmJiBfdGhpczMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcclxuICAgICAgICAgIF90aGlzMy5xdWV1ZWRSZXF1ZXN0cy5wdXNoKCgpID0+IF9fYXdhaXRlcihfdGhpczMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KG1lc3NhZ2UsIHRydWUpO1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlIHN1cmUgcHJldmlvdXNseSBxdWV1ZWQgcmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgZmlyc3RcclxuICAgICAgICBpZiAoIWZyb21RdWV1ZSkge1xyXG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcXVlc3RRdWV1ZS5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMzLnNpZ25hbExhdGVuY3kpIHtcclxuICAgICAgICAgIHlpZWxkIHNsZWVwKF90aGlzMy5zaWduYWxMYXRlbmN5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFfdGhpczMud3MgfHwgX3RoaXMzLndzLnJlYWR5U3RhdGUgIT09IF90aGlzMy53cy5PUEVOKSB7XHJcbiAgICAgICAgICBfdGhpczMubG9nLmVycm9yKFwiY2Fubm90IHNlbmQgc2lnbmFsIHJlcXVlc3QgYmVmb3JlIGNvbm5lY3RlZCwgdHlwZTogXCIuY29uY2F0KG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5jYXNlKSwgX3RoaXMzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXEgPSBuZXcgU2lnbmFsUmVxdWVzdCh7XHJcbiAgICAgICAgICBtZXNzYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmIChfdGhpczMudXNlSlNPTikge1xyXG4gICAgICAgICAgICBfdGhpczMud3Muc2VuZChyZXEudG9Kc29uU3RyaW5nKCkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3RoaXMzLndzLnNlbmQocmVxLnRvQmluYXJ5KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIF90aGlzMy5sb2cuZXJyb3IoJ2Vycm9yIHNlbmRpbmcgc2lnbmFsIG1lc3NhZ2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IG1zZyA9IHJlcy5tZXNzYWdlO1xyXG4gICAgaWYgKG1zZyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVuc3VwcG9ydGVkIG1lc3NhZ2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcGluZ0hhbmRsZWQgPSBmYWxzZTtcclxuICAgIGlmIChtc2cuY2FzZSA9PT0gJ2Fuc3dlcicpIHtcclxuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcclxuICAgICAgaWYgKHRoaXMub25BbnN3ZXIpIHtcclxuICAgICAgICB0aGlzLm9uQW5zd2VyKHNkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ29mZmVyJykge1xyXG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xyXG4gICAgICBpZiAodGhpcy5vbk9mZmVyKSB7XHJcbiAgICAgICAgdGhpcy5vbk9mZmVyKHNkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XHJcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IEpTT04ucGFyc2UobXNnLnZhbHVlLmNhbmRpZGF0ZUluaXQpO1xyXG4gICAgICBpZiAodGhpcy5vblRyaWNrbGUpIHtcclxuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndXBkYXRlJykge1xyXG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKChfYSA9IG1zZy52YWx1ZS5wYXJ0aWNpcGFudHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xyXG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpIHtcclxuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZChtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3BlYWtlcnNDaGFuZ2VkJykge1xyXG4gICAgICBpZiAodGhpcy5vblNwZWFrZXJzQ2hhbmdlZCkge1xyXG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdsZWF2ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xyXG4gICAgICAgIHRoaXMub25MZWF2ZShtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCkge1xyXG4gICAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZChtc2cudmFsdWUuc2lkLCBtc2cudmFsdWUubXV0ZWQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncm9vbVVwZGF0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25Sb29tVXBkYXRlICYmIG1zZy52YWx1ZS5yb29tKSB7XHJcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnY29ubmVjdGlvblF1YWxpdHknKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcclxuICAgICAgICB0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xyXG4gICAgICBpZiAodGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkge1xyXG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZScpIHtcclxuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcclxuICAgICAgaWYgKHRoaXMub25Ub2tlblJlZnJlc2gpIHtcclxuICAgICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1VucHVibGlzaGVkJykge1xyXG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkge1xyXG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblJlc3BvbnNlJykge1xyXG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xyXG4gICAgICB0aGlzLnJ0dCA9IERhdGUubm93KCkgLSBOdW1iZXIucGFyc2VJbnQobXNnLnZhbHVlLmxhc3RQaW5nVGltZXN0YW1wLnRvU3RyaW5nKCkpO1xyXG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcclxuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlcXVlc3RSZXNwb25zZScpIHtcclxuICAgICAgaWYgKHRoaXMub25SZXF1ZXN0UmVzcG9uc2UpIHtcclxuICAgICAgICB0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd0cmFja1N1YnNjcmliZWQnKSB7XHJcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQpIHtcclxuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQobXNnLnZhbHVlLnRyYWNrU2lkKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21Nb3ZlZCcpIHtcclxuICAgICAgaWYgKHRoaXMub25Ub2tlblJlZnJlc2gpIHtcclxuICAgICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoKG1zZy52YWx1ZS50b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMub25Sb29tTW92ZWQpIHtcclxuICAgICAgICB0aGlzLm9uUm9vbU1vdmVkKG1zZy52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnN1cHBvcnRlZCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgbXNnQ2FzZTogbXNnLmNhc2VcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwaW5nSGFuZGxlZCkge1xyXG4gICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0UmVjb25uZWN0ZWQoKSB7XHJcbiAgICB3aGlsZSAodGhpcy5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHJlcSA9IHRoaXMucXVldWVkUmVxdWVzdHMuc2hpZnQoKTtcclxuICAgICAgaWYgKHJlcSkge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnJ1bihyZXEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGhhbmRsZU9uQ2xvc2UocmVhc29uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCkgcmV0dXJuO1xyXG4gICAgICBjb25zdCBvbkNsb3NlQ2FsbGJhY2sgPSB0aGlzLm9uQ2xvc2U7XHJcbiAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQ6IFwiLmNvbmNhdChyZWFzb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICByZWFzb25cclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgb25DbG9zZUNhbGxiYWNrKHJlYXNvbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBoYW5kbGVXU0Vycm9yKGV2KSB7XHJcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIGVycm9yOiBldlxyXG4gICAgfSkpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXNldHMgdGhlIHBpbmcgdGltZW91dCBhbmQgc3RhcnRzIGEgbmV3IHRpbWVvdXQuXHJcbiAgICogQ2FsbCB0aGlzIGFmdGVyIHJlY2VpdmluZyBhIHBvbmcgbWVzc2FnZVxyXG4gICAqL1xyXG4gIHJlc2V0UGluZ1RpbWVvdXQoKSB7XHJcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcclxuICAgIGlmICghdGhpcy5waW5nVGltZW91dER1cmF0aW9uKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgdGltZW91dCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5waW5nVGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKFwicGluZyB0aW1lb3V0IHRyaWdnZXJlZC4gbGFzdCBwb25nIHJlY2VpdmVkIGF0OiBcIi5jb25jYXQobmV3IERhdGUoRGF0ZS5ub3coKSAtIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApLnRvVVRDU3RyaW5nKCkpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xyXG4gICAgfSwgdGhpcy5waW5nVGltZW91dER1cmF0aW9uICogMTAwMCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENsZWFycyBwaW5nIHRpbWVvdXQgKGRvZXMgbm90IHN0YXJ0IGEgbmV3IHRpbWVvdXQpXHJcbiAgICovXHJcbiAgY2xlYXJQaW5nVGltZW91dCgpIHtcclxuICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0KSB7XHJcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhcnRQaW5nSW50ZXJ2YWwoKSB7XHJcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XHJcbiAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQoKTtcclxuICAgIGlmICghdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbikge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgdGhpcy5zZW5kUGluZygpO1xyXG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiAqIDEwMDApO1xyXG4gIH1cclxuICBjbGVhclBpbmdJbnRlcnZhbCgpIHtcclxuICAgIHRoaXMubG9nLmRlYnVnKCdjbGVhcmluZyBwaW5nIGludGVydmFsJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgIHRoaXMuY2xlYXJQaW5nVGltZW91dCgpO1xyXG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XHJcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5waW5nSW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oc2QpIHtcclxuICBjb25zdCByc2QgPSB7XHJcbiAgICB0eXBlOiAnb2ZmZXInLFxyXG4gICAgc2RwOiBzZC5zZHBcclxuICB9O1xyXG4gIHN3aXRjaCAoc2QudHlwZSkge1xyXG4gICAgY2FzZSAnYW5zd2VyJzpcclxuICAgIGNhc2UgJ29mZmVyJzpcclxuICAgIGNhc2UgJ3ByYW5zd2VyJzpcclxuICAgIGNhc2UgJ3JvbGxiYWNrJzpcclxuICAgICAgcnNkLnR5cGUgPSBzZC50eXBlO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuIHJzZDtcclxufVxyXG5mdW5jdGlvbiB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHJzZCkge1xyXG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XHJcbiAgICBzZHA6IHJzZC5zZHAsXHJcbiAgICB0eXBlOiByc2QudHlwZVxyXG4gIH0pO1xyXG4gIHJldHVybiBzZDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBpbmZvLCBvcHRzKSB7XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XHJcbiAgLy8gb3B0c1xyXG4gIGlmIChvcHRzLnJlY29ubmVjdCkge1xyXG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcclxuICAgIGlmIChvcHRzLnNpZCkge1xyXG4gICAgICBwYXJhbXMuc2V0KCdzaWQnLCBvcHRzLnNpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcclxuICAvLyBDbGllbnRJbmZvXHJcbiAgcGFyYW1zLnNldCgnc2RrJywgaXNSZWFjdE5hdGl2ZSgpID8gJ3JlYWN0bmF0aXZlJyA6ICdqcycpO1xyXG4gIHBhcmFtcy5zZXQoJ3ZlcnNpb24nLCBpbmZvLnZlcnNpb24pO1xyXG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcclxuICBpZiAoaW5mby5kZXZpY2VNb2RlbCkge1xyXG4gICAgcGFyYW1zLnNldCgnZGV2aWNlX21vZGVsJywgaW5mby5kZXZpY2VNb2RlbCk7XHJcbiAgfVxyXG4gIGlmIChpbmZvLm9zKSB7XHJcbiAgICBwYXJhbXMuc2V0KCdvcycsIGluZm8ub3MpO1xyXG4gIH1cclxuICBpZiAoaW5mby5vc1ZlcnNpb24pIHtcclxuICAgIHBhcmFtcy5zZXQoJ29zX3ZlcnNpb24nLCBpbmZvLm9zVmVyc2lvbik7XHJcbiAgfVxyXG4gIGlmIChpbmZvLmJyb3dzZXIpIHtcclxuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXInLCBpbmZvLmJyb3dzZXIpO1xyXG4gIH1cclxuICBpZiAoaW5mby5icm93c2VyVmVyc2lvbikge1xyXG4gICAgcGFyYW1zLnNldCgnYnJvd3Nlcl92ZXJzaW9uJywgaW5mby5icm93c2VyVmVyc2lvbik7XHJcbiAgfVxyXG4gIGlmIChvcHRzLmFkYXB0aXZlU3RyZWFtKSB7XHJcbiAgICBwYXJhbXMuc2V0KCdhZGFwdGl2ZV9zdHJlYW0nLCAnMScpO1xyXG4gIH1cclxuICBpZiAob3B0cy5yZWNvbm5lY3RSZWFzb24pIHtcclxuICAgIHBhcmFtcy5zZXQoJ3JlY29ubmVjdF9yZWFzb24nLCBvcHRzLnJlY29ubmVjdFJlYXNvbi50b1N0cmluZygpKTtcclxuICB9XHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIGlmICgoX2EgPSBuYXZpZ2F0b3IuY29ubmVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHBhcmFtcy5zZXQoJ25ldHdvcmsnLCBuYXZpZ2F0b3IuY29ubmVjdGlvbi50eXBlKTtcclxuICB9XHJcbiAgcmV0dXJuIHBhcmFtcztcclxufVxyXG5cclxuY2xhc3MgRGF0YVBhY2tldEJ1ZmZlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xyXG4gICAgdGhpcy5fdG90YWxTaXplID0gMDtcclxuICB9XHJcbiAgcHVzaChpdGVtKSB7XHJcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGl0ZW0pO1xyXG4gICAgdGhpcy5fdG90YWxTaXplICs9IGl0ZW0uZGF0YS5ieXRlTGVuZ3RoO1xyXG4gIH1cclxuICBwb3AoKSB7XHJcbiAgICBjb25zdCBpdGVtID0gdGhpcy5idWZmZXIuc2hpZnQoKTtcclxuICAgIGlmIChpdGVtKSB7XHJcbiAgICAgIHRoaXMuX3RvdGFsU2l6ZSAtPSBpdGVtLmRhdGEuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtO1xyXG4gIH1cclxuICBnZXRBbGwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UoKTtcclxuICB9XHJcbiAgcG9wVG9TZXF1ZW5jZShzZXF1ZW5jZSkge1xyXG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLmJ1ZmZlclswXTtcclxuICAgICAgaWYgKGZpcnN0LnNlcXVlbmNlIDw9IHNlcXVlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBhbGlnbkJ1ZmZlcmVkQW1vdW50KGJ1ZmZlcmVkQW1vdW50KSB7XHJcbiAgICB3aGlsZSAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuYnVmZmVyWzBdO1xyXG4gICAgICBpZiAodGhpcy5fdG90YWxTaXplIC0gZmlyc3QuZGF0YS5ieXRlTGVuZ3RoIDw9IGJ1ZmZlcmVkQW1vdW50KSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wb3AoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IGxlbmd0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGg7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBUVExNYXAge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB0dGwgdHRsIG9mIHRoZSBrZXkgKG1zKVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHR0bCkge1xyXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5fbGFzdENsZWFudXAgPSAwO1xyXG4gICAgdGhpcy50dGwgPSB0dGw7XHJcbiAgfVxyXG4gIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgaWYgKG5vdyAtIHRoaXMuX2xhc3RDbGVhbnVwID4gdGhpcy50dGwgLyAyKSB7XHJcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbm93ICsgdGhpcy50dGw7XHJcbiAgICB0aGlzLl9tYXAuc2V0KGtleSwge1xyXG4gICAgICB2YWx1ZSxcclxuICAgICAgZXhwaXJlc0F0XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBnZXQoa2V5KSB7XHJcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcclxuICAgIGlmICghZW50cnkpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZW50cnkuZXhwaXJlc0F0IDwgRGF0ZS5ub3coKSkge1xyXG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbiAgfVxyXG4gIGhhcyhrZXkpIHtcclxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fbWFwLmdldChrZXkpO1xyXG4gICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKGVudHJ5LmV4cGlyZXNBdCA8IERhdGUubm93KCkpIHtcclxuICAgICAgdGhpcy5fbWFwLmRlbGV0ZShrZXkpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZGVsZXRlKGtleSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcclxuICB9XHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9tYXAuY2xlYXIoKTtcclxuICB9XHJcbiAgY2xlYW51cCgpIHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XHJcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPCBub3cpIHtcclxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX2xhc3RDbGVhbnVwID0gbm93O1xyXG4gIH1cclxuICBnZXQgc2l6ZSgpIHtcclxuICAgIHRoaXMuY2xlYW51cCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuX21hcC5zaXplO1xyXG4gIH1cclxuICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIHRoaXMuX21hcC5lbnRyaWVzKCkpIHtcclxuICAgICAgaWYgKGVudHJ5LmV4cGlyZXNBdCA+PSBEYXRlLm5vdygpKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZW50cnkudmFsdWUsIGtleSwgdGhpcy5hc1ZhbHVlTWFwKCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIG1hcChjYWxsYmFjaykge1xyXG4gICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGNvbnN0IHZhbHVlTWFwID0gdGhpcy5hc1ZhbHVlTWFwKCk7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWx1ZU1hcC5lbnRyaWVzKCkpIHtcclxuICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sodmFsdWUsIGtleSwgdmFsdWVNYXApKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGFzVmFsdWVNYXAoKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiB0aGlzLl9tYXAuZW50cmllcygpKSB7XHJcbiAgICAgIGlmIChlbnRyeS5leHBpcmVzQXQgPj0gRGF0ZS5ub3coKSkge1xyXG4gICAgICAgIHJlc3VsdC5zZXQoa2V5LCBlbnRyeS52YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgbGliID0ge307XHJcblxyXG52YXIgcGFyc2VyID0ge307XHJcblxyXG52YXIgZ3JhbW1hciA9IHtleHBvcnRzOiB7fX07XHJcblxyXG52YXIgaGFzUmVxdWlyZWRHcmFtbWFyO1xyXG5mdW5jdGlvbiByZXF1aXJlR3JhbW1hcigpIHtcclxuICBpZiAoaGFzUmVxdWlyZWRHcmFtbWFyKSByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xyXG4gIGhhc1JlcXVpcmVkR3JhbW1hciA9IDE7XHJcbiAgdmFyIGdyYW1tYXIkMSA9IGdyYW1tYXIuZXhwb3J0cyA9IHtcclxuICAgIHY6IFt7XHJcbiAgICAgIG5hbWU6ICd2ZXJzaW9uJyxcclxuICAgICAgcmVnOiAvXihcXGQqKSQvXHJcbiAgICB9XSxcclxuICAgIG86IFt7XHJcbiAgICAgIC8vIG89LSAyMDUxOCAwIElOIElQNCAyMDMuMC4xMTMuMVxyXG4gICAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcclxuICAgICAgbmFtZTogJ29yaWdpbicsXHJcbiAgICAgIHJlZzogL14oXFxTKikgKFxcZCopIChcXGQqKSAoXFxTKikgSVAoXFxkKSAoXFxTKikvLFxyXG4gICAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXHJcbiAgICAgIGZvcm1hdDogJyVzICVzICVkICVzIElQJWQgJXMnXHJcbiAgICB9XSxcclxuICAgIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxyXG4gICAgczogW3tcclxuICAgICAgbmFtZTogJ25hbWUnXHJcbiAgICB9XSxcclxuICAgIGk6IFt7XHJcbiAgICAgIG5hbWU6ICdkZXNjcmlwdGlvbidcclxuICAgIH1dLFxyXG4gICAgdTogW3tcclxuICAgICAgbmFtZTogJ3VyaSdcclxuICAgIH1dLFxyXG4gICAgZTogW3tcclxuICAgICAgbmFtZTogJ2VtYWlsJ1xyXG4gICAgfV0sXHJcbiAgICBwOiBbe1xyXG4gICAgICBuYW1lOiAncGhvbmUnXHJcbiAgICB9XSxcclxuICAgIHo6IFt7XHJcbiAgICAgIG5hbWU6ICd0aW1lem9uZXMnXHJcbiAgICB9XSxcclxuICAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhY3R1YWxseSBiZSBwYXJzZWQgcHJvcGVybHkuLi5cclxuICAgIHI6IFt7XHJcbiAgICAgIG5hbWU6ICdyZXBlYXRzJ1xyXG4gICAgfV0sXHJcbiAgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWxzbyBiZSBwYXJzZWQgcHJvcGVybHlcclxuICAgIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcclxuICAgIHQ6IFt7XHJcbiAgICAgIC8vIHQ9MCAwXHJcbiAgICAgIG5hbWU6ICd0aW1pbmcnLFxyXG4gICAgICByZWc6IC9eKFxcZCopIChcXGQqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3N0YXJ0JywgJ3N0b3AnXSxcclxuICAgICAgZm9ybWF0OiAnJWQgJWQnXHJcbiAgICB9XSxcclxuICAgIGM6IFt7XHJcbiAgICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxyXG4gICAgICBuYW1lOiAnY29ubmVjdGlvbicsXHJcbiAgICAgIHJlZzogL15JTiBJUChcXGQpIChcXFMqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcclxuICAgICAgZm9ybWF0OiAnSU4gSVAlZCAlcydcclxuICAgIH1dLFxyXG4gICAgYjogW3tcclxuICAgICAgLy8gYj1BUzo0MDAwXHJcbiAgICAgIHB1c2g6ICdiYW5kd2lkdGgnLFxyXG4gICAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbGltaXQnXSxcclxuICAgICAgZm9ybWF0OiAnJXM6JXMnXHJcbiAgICB9XSxcclxuICAgIG06IFt7XHJcbiAgICAgIC8vIG09dmlkZW8gNTE3NDQgUlRQL0FWUCAxMjYgOTcgOTggMzQgMzFcclxuICAgICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxyXG4gICAgICAvLyBUT0RPOiBydHAvZm10cCBzaG91bGQgYmUgZmlsdGVyZWQgYnkgdGhlIHBheWxvYWRzIGZvdW5kIGhlcmU/XHJcbiAgICAgIHJlZzogL14oXFx3KikgKFxcZCopIChbXFx3L10qKSg/OiAoLiopKT8vLFxyXG4gICAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcclxuICAgICAgZm9ybWF0OiAnJXMgJWQgJXMgJXMnXHJcbiAgICB9XSxcclxuICAgIGE6IFt7XHJcbiAgICAgIC8vIGE9cnRwbWFwOjExMCBvcHVzLzQ4MDAwLzJcclxuICAgICAgcHVzaDogJ3J0cCcsXHJcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXHJcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29kZWMnLCAncmF0ZScsICdlbmNvZGluZyddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8uZW5jb2RpbmcgPyAncnRwbWFwOiVkICVzLyVzLyVzJyA6IG8ucmF0ZSA/ICdydHBtYXA6JWQgJXMvJXMnIDogJ3J0cG1hcDolZCAlcyc7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXHJcbiAgICAgIC8vIGE9Zm10cDoxMTEgbWlucHRpbWU9MTA7IHVzZWluYmFuZGZlYz0xXHJcbiAgICAgIHB1c2g6ICdmbXRwJyxcclxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxyXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvbmZpZyddLFxyXG4gICAgICBmb3JtYXQ6ICdmbXRwOiVkICVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWNvbnRyb2w6c3RyZWFtaWQ9MFxyXG4gICAgICBuYW1lOiAnY29udHJvbCcsXHJcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxyXG4gICAgICBmb3JtYXQ6ICdjb250cm9sOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcclxuICAgICAgbmFtZTogJ3J0Y3AnLFxyXG4gICAgICByZWc6IC9ecnRjcDooXFxkKikoPzogKFxcUyopIElQKFxcZCkgKFxcUyopKT8vLFxyXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8uYWRkcmVzcyAhPSBudWxsID8gJ3J0Y3A6JWQgJXMgSVAlZCAlcycgOiAncnRjcDolZCc7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1ydGNwLWZiOjk4IHRyci1pbnQgMTAwXHJcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxyXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIHRyci1pbnQgKFxcZCopLyxcclxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd2YWx1ZSddLFxyXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcclxuICAgICAgcHVzaDogJ3J0Y3BGYicsXHJcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgKFtcXHctX10qKSg/OiAoW1xcdy1fXSopKT8vLFxyXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3R5cGUnLCAnc3VidHlwZSddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8uc3VidHlwZSAhPSBudWxsID8gJ3J0Y3AtZmI6JXMgJXMgJXMnIDogJ3J0Y3AtZmI6JXMgJXMnO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxyXG4gICAgICAvLyBhPWV4dG1hcDoxL3JlY3Zvbmx5IFVSSS1ncHMtc3RyaW5nXHJcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcclxuICAgICAgcHVzaDogJ2V4dCcsXHJcbiAgICAgIHJlZzogL15leHRtYXA6KFxcZCspKD86XFwvKFxcdyspKT8oPzogKHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OmVuY3J5cHQpKT8gKFxcUyopKD86IChcXFMqKSk/LyxcclxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiAnZXh0bWFwOiVkJyArIChvLmRpcmVjdGlvbiA/ICcvJXMnIDogJyV2JykgKyAob1snZW5jcnlwdC11cmknXSA/ICcgJXMnIDogJyV2JykgKyAnICVzJyArIChvLmNvbmZpZyA/ICcgJXMnIDogJycpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9ZXh0bWFwLWFsbG93LW1peGVkXHJcbiAgICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcclxuICAgICAgcmVnOiAvXihleHRtYXAtYWxsb3ctbWl4ZWQpL1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxyXG4gICAgICBwdXNoOiAnY3J5cHRvJyxcclxuICAgICAgcmVnOiAvXmNyeXB0bzooXFxkKikgKFtcXHdfXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gby5zZXNzaW9uQ29uZmlnICE9IG51bGwgPyAnY3J5cHRvOiVkICVzICVzICVzJyA6ICdjcnlwdG86JWQgJXMgJXMnO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9c2V0dXA6YWN0cGFzc1xyXG4gICAgICBuYW1lOiAnc2V0dXAnLFxyXG4gICAgICByZWc6IC9ec2V0dXA6KFxcdyopLyxcclxuICAgICAgZm9ybWF0OiAnc2V0dXA6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Y29ubmVjdGlvbjpuZXdcclxuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25UeXBlJyxcclxuICAgICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxyXG4gICAgICBmb3JtYXQ6ICdjb25uZWN0aW9uOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPW1pZDoxXHJcbiAgICAgIG5hbWU6ICdtaWQnLFxyXG4gICAgICByZWc6IC9ebWlkOihbXlxcc10qKS8sXHJcbiAgICAgIGZvcm1hdDogJ21pZDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1tc2lkOjBjOGIwNjRkLWQ4MDctNDNiNC1iNDM0LWY5MmE4ODlkODU4NyA5ODE3ODY4NS1kNDA5LTQ2ZTAtOGUxNi03ZWYwZGIwZGI2NGFcclxuICAgICAgbmFtZTogJ21zaWQnLFxyXG4gICAgICByZWc6IC9ebXNpZDooLiopLyxcclxuICAgICAgZm9ybWF0OiAnbXNpZDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1wdGltZToyMFxyXG4gICAgICBuYW1lOiAncHRpbWUnLFxyXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcclxuICAgICAgZm9ybWF0OiAncHRpbWU6JWQnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcclxuICAgICAgbmFtZTogJ21heHB0aW1lJyxcclxuICAgICAgcmVnOiAvXm1heHB0aW1lOihcXGQqKD86XFwuXFxkKikqKS8sXHJcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXNlbmRyZWN2XHJcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxyXG4gICAgICByZWc6IC9eKHNlbmRyZWN2fHJlY3Zvbmx5fHNlbmRvbmx5fGluYWN0aXZlKS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1pY2UtbGl0ZVxyXG4gICAgICBuYW1lOiAnaWNlbGl0ZScsXHJcbiAgICAgIHJlZzogL14oaWNlLWxpdGUpL1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWljZS11ZnJhZzpGN2dJXHJcbiAgICAgIG5hbWU6ICdpY2VVZnJhZycsXHJcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcclxuICAgICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xyXG4gICAgICBuYW1lOiAnaWNlUHdkJyxcclxuICAgICAgcmVnOiAvXmljZS1wd2Q6KFxcUyopLyxcclxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1maW5nZXJwcmludDpTSEEtMSAwMDoxMToyMjozMzo0NDo1NTo2Njo3Nzo4ODo5OTpBQTpCQjpDQzpERDpFRTpGRjowMDoxMToyMjozM1xyXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxyXG4gICAgICByZWc6IC9eZmluZ2VycHJpbnQ6KFxcUyopIChcXFMqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnaGFzaCddLFxyXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1jYW5kaWRhdGU6MCAxIFVEUCAyMTEzNjY3MzI3IDIwMy4wLjExMy4xIDU0NDAwIHR5cCBob3N0XHJcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXHJcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB1ZHAgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXHJcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjIyOTgxNTYyMCAxIHRjcCAxNTE4MjgwNDQ3IDE5Mi4xNjguMTUwLjE5IDYwMDE3IHR5cCBob3N0IHRjcHR5cGUgYWN0aXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXHJcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxyXG4gICAgICBwdXNoOiAnY2FuZGlkYXRlcycsXHJcbiAgICAgIHJlZzogL15jYW5kaWRhdGU6KFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgdHlwIChcXFMqKSg/OiByYWRkciAoXFxTKikgcnBvcnQgKFxcZCopKT8oPzogdGNwdHlwZSAoXFxTKikpPyg/OiBnZW5lcmF0aW9uIChcXGQqKSk/KD86IG5ldHdvcmstaWQgKFxcZCopKT8oPzogbmV0d29yay1jb3N0IChcXGQqKSk/LyxcclxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzdHIgPSAnY2FuZGlkYXRlOiVzICVkICVzICVkICVzICVkIHR5cCAlcyc7XHJcbiAgICAgICAgc3RyICs9IG8ucmFkZHIgIT0gbnVsbCA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xyXG5cclxuICAgICAgICAvLyBOQjogY2FuZGlkYXRlIGhhcyB0aHJlZSBvcHRpb25hbCBjaHVua3MsIHNvICV2b2lkIG1pZGRsZXMgb25lIGlmIGl0J3MgbWlzc2luZ1xyXG4gICAgICAgIHN0ciArPSBvLnRjcHR5cGUgIT0gbnVsbCA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xyXG4gICAgICAgIGlmIChvLmdlbmVyYXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyICs9ICcgZ2VuZXJhdGlvbiAlZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0ciArPSBvWyduZXR3b3JrLWlkJ10gIT0gbnVsbCA/ICcgbmV0d29yay1pZCAlZCcgOiAnJXYnO1xyXG4gICAgICAgIHN0ciArPSBvWyduZXR3b3JrLWNvc3QnXSAhPSBudWxsID8gJyBuZXR3b3JrLWNvc3QgJWQnIDogJyV2JztcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXHJcbiAgICAgIG5hbWU6ICdlbmRPZkNhbmRpZGF0ZXMnLFxyXG4gICAgICByZWc6IC9eKGVuZC1vZi1jYW5kaWRhdGVzKS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1yZW1vdGUtY2FuZGlkYXRlczoxIDIwMy4wLjExMy4xIDU0NDAwIDIgMjAzLjAuMTEzLjEgNTQ0MDEgLi4uXHJcbiAgICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcclxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxyXG4gICAgICBmb3JtYXQ6ICdyZW1vdGUtY2FuZGlkYXRlczolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXHJcbiAgICAgIG5hbWU6ICdpY2VPcHRpb25zJyxcclxuICAgICAgcmVnOiAvXmljZS1vcHRpb25zOihcXFMqKS8sXHJcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXNzcmM6MjU2NjEwNzU2OSBjbmFtZTp0OVlVOE0xVXhURjhZMUExXHJcbiAgICAgIHB1c2g6ICdzc3JjcycsXHJcbiAgICAgIHJlZzogL15zc3JjOihcXGQqKSAoW1xcd18tXSopKD86OiguKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2F0dHJpYnV0ZScsICd2YWx1ZSddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9ICdzc3JjOiVkJztcclxuICAgICAgICBpZiAoby5hdHRyaWJ1dGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xyXG4gICAgICAgICAgaWYgKG8udmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJzolcyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcclxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcclxuICAgICAgcHVzaDogJ3NzcmNHcm91cHMnLFxyXG4gICAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxyXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxyXG4gICAgICBuYW1lczogWydzZW1hbnRpY3MnLCAnc3NyY3MnXSxcclxuICAgICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1tc2lkLXNlbWFudGljOiBXTVMgSnZsYW01WDNTWDFPUDZwbjIweldvZ3ZhS0p6NUhqZjlPbmxWXHJcbiAgICAgIG5hbWU6ICdtc2lkU2VtYW50aWMnLFxyXG4gICAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljJywgJ3Rva2VuJ10sXHJcbiAgICAgIGZvcm1hdDogJ21zaWQtc2VtYW50aWM6ICVzICVzJyAvLyBzcGFjZSBhZnRlciAnOicgaXMgbm90IGFjY2lkZW50YWxcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW9cclxuICAgICAgcHVzaDogJ2dyb3VwcycsXHJcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXHJcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbWlkcyddLFxyXG4gICAgICBmb3JtYXQ6ICdncm91cDolcyAlcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1ydGNwLW11eFxyXG4gICAgICBuYW1lOiAncnRjcE11eCcsXHJcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXJ0Y3AtcnNpemVcclxuICAgICAgbmFtZTogJ3J0Y3BSc2l6ZScsXHJcbiAgICAgIHJlZzogL14ocnRjcC1yc2l6ZSkvXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XHJcbiAgICAgIG5hbWU6ICdzY3RwbWFwJyxcclxuICAgICAgcmVnOiAvXnNjdHBtYXA6KFtcXHdfL10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxyXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8ubWF4TWVzc2FnZVNpemUgIT0gbnVsbCA/ICdzY3RwbWFwOiVzICVzICVzJyA6ICdzY3RwbWFwOiVzICVzJztcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxyXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxyXG4gICAgICByZWc6IC9eeC1nb29nbGUtZmxhZzooW15cXHNdKikvLFxyXG4gICAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPXJpZDoxIHNlbmQgbWF4LXdpZHRoPTEyODA7bWF4LWhlaWdodD03MjA7bWF4LWZwcz0zMDtkZXBlbmQ9MFxyXG4gICAgICBwdXNoOiAncmlkcycsXHJcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXHJcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ2RpcmVjdGlvbicsICdwYXJhbXMnXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvLnBhcmFtcyA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cclxuICAgICAgLy8gYT1pbWFnZWF0dHI6KiBzZW5kIFt4PTgwMCx5PTY0MF0gcmVjdiAqXHJcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cclxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxyXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXHJcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3XHJcbiAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXHJcbiAgICAgIC8vIHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF1cclxuICAgICAgJ1tcXFxcc1xcXFx0XSsoc2VuZHxyZWN2KVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopJyArXHJcbiAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxyXG4gICAgICAnKD86W1xcXFxzXFxcXHRdKyhyZWN2fHNlbmQpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKikpPycpLFxyXG4gICAgICBuYW1lczogWydwdCcsICdkaXIxJywgJ2F0dHJzMScsICdkaXIyJywgJ2F0dHJzMiddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuICdpbWFnZWF0dHI6JXMgJXMgJXMnICsgKG8uZGlyMiA/ICcgJXMgJXMnIDogJycpO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnNlbmQgMSwyLDM7fjQsfjUgcmVjdiA2O343LH44XHJcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnJlY3YgMTs0LDUgc2VuZCA2OzdcclxuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXHJcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcclxuICAgICAgLy8gYT1zaW11bGNhc3Q6XHJcbiAgICAgICdec2ltdWxjYXN0OicgK1xyXG4gICAgICAvLyBzZW5kIDEsMiwzO340LH41XHJcbiAgICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xyXG4gICAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxyXG4gICAgICAnKD86XFxcXHM/KHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKykpPycgK1xyXG4gICAgICAvLyBlbmRcclxuICAgICAgJyQnKSxcclxuICAgICAgbmFtZXM6IFsnZGlyMScsICdsaXN0MScsICdkaXIyJywgJ2xpc3QyJ10sXHJcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcclxuICAgICAgLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2RwLXNpbXVsY2FzdC0wM1xyXG4gICAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XHJcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XHJcbiAgICAgIG5hbWU6ICdzaW11bGNhc3RfMDMnLFxyXG4gICAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxyXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxyXG4gICAgICBmb3JtYXQ6ICdzaW11bGNhc3Q6ICVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWZyYW1lcmF0ZToyNVxyXG4gICAgICAvLyBhPWZyYW1lcmF0ZToyOS45N1xyXG4gICAgICBuYW1lOiAnZnJhbWVyYXRlJyxcclxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcclxuICAgICAgZm9ybWF0OiAnZnJhbWVyYXRlOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBSRkM0NTcwXHJcbiAgICAgIC8vIGE9c291cmNlLWZpbHRlcjogaW5jbCBJTiBJUDQgMjM5LjUuMi4zMSAxMC4xLjE1LjVcclxuICAgICAgbmFtZTogJ3NvdXJjZUZpbHRlcicsXHJcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxyXG4gICAgICBuYW1lczogWydmaWx0ZXJNb2RlJywgJ25ldFR5cGUnLCAnYWRkcmVzc1R5cGVzJywgJ2Rlc3RBZGRyZXNzJywgJ3NyY0xpc3QnXSxcclxuICAgICAgZm9ybWF0OiAnc291cmNlLWZpbHRlcjogJXMgJXMgJXMgJXMgJXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9YnVuZGxlLW9ubHlcclxuICAgICAgbmFtZTogJ2J1bmRsZU9ubHknLFxyXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cclxuICAgIH0sIHtcclxuICAgICAgLy8gYT1sYWJlbDoxXHJcbiAgICAgIG5hbWU6ICdsYWJlbCcsXHJcbiAgICAgIHJlZzogL15sYWJlbDooLispLyxcclxuICAgICAgZm9ybWF0OiAnbGFiZWw6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xyXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYjc2VjdGlvbi01XHJcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXHJcbiAgICAgIHJlZzogL15zY3RwLXBvcnQ6KFxcZCspJC8sXHJcbiAgICAgIGZvcm1hdDogJ3NjdHAtcG9ydDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gUkZDIHZlcnNpb24gMjYgZm9yIFNDVFAgb3ZlciBEVExTXHJcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcclxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcclxuICAgICAgcmVnOiAvXm1heC1tZXNzYWdlLXNpemU6KFxcZCspJC8sXHJcbiAgICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIFJGQzcyNzNcclxuICAgICAgLy8gYT10cy1yZWZjbGs6cHRwPUlFRUUxNTg4LTIwMDg6MzktQTctOTQtRkYtRkUtMDctQ0ItRDA6MzdcclxuICAgICAgcHVzaDogJ3RzUmVmQ2xvY2tzJyxcclxuICAgICAgcmVnOiAvXnRzLXJlZmNsazooW15cXHM9XSopKD86PShcXFMqKSk/LyxcclxuICAgICAgbmFtZXM6IFsnY2xrc3JjJywgJ2Nsa3NyY0V4dCddLFxyXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cy1yZWZjbGs6JXMnICsgKG8uY2xrc3JjRXh0ICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBSRkM3MjczXHJcbiAgICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxyXG4gICAgICBuYW1lOiAnbWVkaWFDbGsnLFxyXG4gICAgICByZWc6IC9ebWVkaWFjbGs6KD86aWQ9KFxcUyopKT8gKihbXlxccz1dKikoPzo9KFxcUyopKT8oPzogKnJhdGU9KFxcZCspXFwvKFxcZCspKT8vLFxyXG4gICAgICBuYW1lczogWydpZCcsICdtZWRpYUNsb2NrTmFtZScsICdtZWRpYUNsb2NrVmFsdWUnLCAncmF0ZU51bWVyYXRvcicsICdyYXRlRGVub21pbmF0b3InXSxcclxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzdHIgPSAnbWVkaWFjbGs6JztcclxuICAgICAgICBzdHIgKz0gby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJztcclxuICAgICAgICBzdHIgKz0gby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJyc7XHJcbiAgICAgICAgc3RyICs9IG8ucmF0ZU51bWVyYXRvciAhPSBudWxsID8gJyByYXRlPSVzJyA6ICcnO1xyXG4gICAgICAgIHN0ciArPSBvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJztcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9XHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXHJcbiAgICAgIG5hbWU6ICdrZXl3b3JkcycsXHJcbiAgICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxyXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Y29udGVudDptYWluXHJcbiAgICAgIG5hbWU6ICdjb250ZW50JyxcclxuICAgICAgcmVnOiAvXmNvbnRlbnQ6KC4rKS8sXHJcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQ6JXMnXHJcbiAgICB9LFxyXG4gICAgLy8gQkZDUCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDU4M1xyXG4gICAge1xyXG4gICAgICAvLyBhPWZsb29yY3RybDpjLXNcclxuICAgICAgbmFtZTogJ2JmY3BGbG9vckN0cmwnLFxyXG4gICAgICByZWc6IC9eZmxvb3JjdHJsOihjLW9ubHl8cy1vbmx5fGMtcykvLFxyXG4gICAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIGE9Y29uZmlkOjFcclxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxyXG4gICAgICByZWc6IC9eY29uZmlkOihcXGQrKS8sXHJcbiAgICAgIGZvcm1hdDogJ2NvbmZpZDolcydcclxuICAgIH0sIHtcclxuICAgICAgLy8gYT11c2VyaWQ6MVxyXG4gICAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXHJcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcclxuICAgICAgZm9ybWF0OiAndXNlcmlkOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhPWZsb29yaWQ6MVxyXG4gICAgICBuYW1lOiAnYmZjcEZsb29ySWQnLFxyXG4gICAgICByZWc6IC9eZmxvb3JpZDooLispICg/Om0tc3RyZWFtfG1zdHJtKTooLispLyxcclxuICAgICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxyXG4gICAgICBmb3JtYXQ6ICdmbG9vcmlkOiVzIG1zdHJtOiVzJ1xyXG4gICAgfSwge1xyXG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxyXG4gICAgICBwdXNoOiAnaW52YWxpZCcsXHJcbiAgICAgIG5hbWVzOiBbJ3ZhbHVlJ11cclxuICAgIH1dXHJcbiAgfTtcclxuXHJcbiAgLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXHJcbiAgT2JqZWN0LmtleXMoZ3JhbW1hciQxKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHZhciBvYmpzID0gZ3JhbW1hciQxW2tleV07XHJcbiAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICBpZiAoIW9iai5yZWcpIHtcclxuICAgICAgICBvYmoucmVnID0gLyguKikvO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghb2JqLmZvcm1hdCkge1xyXG4gICAgICAgIG9iai5mb3JtYXQgPSAnJXMnO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xyXG59XHJcblxyXG52YXIgaGFzUmVxdWlyZWRQYXJzZXI7XHJcbmZ1bmN0aW9uIHJlcXVpcmVQYXJzZXIoKSB7XHJcbiAgaWYgKGhhc1JlcXVpcmVkUGFyc2VyKSByZXR1cm4gcGFyc2VyO1xyXG4gIGhhc1JlcXVpcmVkUGFyc2VyID0gMTtcclxuICAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcclxuICAgIHZhciB0b0ludElmSW50ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcclxuICAgIH07XHJcbiAgICB2YXIgYXR0YWNoUHJvcGVydGllcyA9IGZ1bmN0aW9uIChtYXRjaCwgbG9jYXRpb24sIG5hbWVzLCByYXdOYW1lKSB7XHJcbiAgICAgIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xyXG4gICAgICAgIGxvY2F0aW9uW3Jhd05hbWVdID0gdG9JbnRJZkludChtYXRjaFsxXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgaWYgKG1hdGNoW2kgKyAxXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uW25hbWVzW2ldXSA9IHRvSW50SWZJbnQobWF0Y2hbaSArIDFdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgcGFyc2VSZWcgPSBmdW5jdGlvbiAob2JqLCBsb2NhdGlvbiwgY29udGVudCkge1xyXG4gICAgICB2YXIgbmVlZHNCbGFuayA9IG9iai5uYW1lICYmIG9iai5uYW1lcztcclxuICAgICAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcclxuICAgICAgICBsb2NhdGlvbltvYmoucHVzaF0gPSBbXTtcclxuICAgICAgfSBlbHNlIGlmIChuZWVkc0JsYW5rICYmICFsb2NhdGlvbltvYmoubmFtZV0pIHtcclxuICAgICAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcclxuICAgICAgfVxyXG4gICAgICB2YXIga2V5TG9jYXRpb24gPSBvYmoucHVzaCA/IHt9IDpcclxuICAgICAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcclxuICAgICAgbmVlZHNCbGFuayA/IGxvY2F0aW9uW29iai5uYW1lXSA6IGxvY2F0aW9uOyAvLyBvdGhlcndpc2UsIG5hbWVkIGxvY2F0aW9uIG9yIHJvb3RcclxuXHJcbiAgICAgIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xyXG4gICAgICBpZiAob2JqLnB1c2gpIHtcclxuICAgICAgICBsb2NhdGlvbltvYmoucHVzaF0ucHVzaChrZXlMb2NhdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XHJcbiAgICB2YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcclxuICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XHJcbiAgICAgIHZhciBzZXNzaW9uID0ge30sXHJcbiAgICAgICAgbWVkaWEgPSBbXSxcclxuICAgICAgICBsb2NhdGlvbiA9IHNlc3Npb247IC8vIHBvaW50cyBhdCB3aGVyZSBwcm9wZXJ0aWVzIGdvIHVuZGVyIChvbmUgb2YgdGhlIGFib3ZlKVxyXG5cclxuICAgICAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxyXG4gICAgICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5maWx0ZXIodmFsaWRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBsWzBdO1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ20nKSB7XHJcbiAgICAgICAgICBtZWRpYS5wdXNoKHtcclxuICAgICAgICAgICAgcnRwOiBbXSxcclxuICAgICAgICAgICAgZm10cDogW11cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGggLSAxXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xyXG4gICAgICAgICAgaWYgKG9iai5yZWcudGVzdChjb250ZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXHJcbiAgICAgIHJldHVybiBzZXNzaW9uO1xyXG4gICAgfTtcclxuICAgIHZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XHJcbiAgICAgIHZhciBzID0gZXhwci5zcGxpdCgvPSguKykvLCAyKTtcclxuICAgICAgaWYgKHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcclxuICAgICAgfSBlbHNlIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBleHByLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBhY2Nbc1swXV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH07XHJcbiAgICBleHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgLSBhbGlhcyB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLjBcclxuICAgIGV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gZXhwb3J0cy5wYXJzZVBhcmFtcztcclxuICAgIGV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XHJcbiAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgnICcpLm1hcCh0b0ludElmSW50KTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XHJcbiAgICAgICAgICBjb21wb25lbnQ6IHBhcnRzW2ldLFxyXG4gICAgICAgICAgaXA6IHBhcnRzW2kgKyAxXSxcclxuICAgICAgICAgIHBvcnQ6IHBhcnRzW2kgKyAyXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5zdWJzdHJpbmcoMSwgaXRlbS5sZW5ndGggLSAxKS5zcGxpdCgnLCcpLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiBzdHJlYW0uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgICAgICAgdmFyIHNjaWQsXHJcbiAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XHJcbiAgICAgICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjaWQ6IHNjaWQsXHJcbiAgICAgICAgICAgIHBhdXNlZDogcGF1c2VkXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSkocGFyc2VyKTtcclxuICByZXR1cm4gcGFyc2VyO1xyXG59XHJcblxyXG52YXIgd3JpdGVyO1xyXG52YXIgaGFzUmVxdWlyZWRXcml0ZXI7XHJcbmZ1bmN0aW9uIHJlcXVpcmVXcml0ZXIoKSB7XHJcbiAgaWYgKGhhc1JlcXVpcmVkV3JpdGVyKSByZXR1cm4gd3JpdGVyO1xyXG4gIGhhc1JlcXVpcmVkV3JpdGVyID0gMTtcclxuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XHJcblxyXG4gIC8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xyXG4gIHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZHYlXS9nO1xyXG4gIHZhciBmb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgaSA9IDE7XHJcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcclxuICAgIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgIGlmIChpID49IGxlbikge1xyXG4gICAgICAgIHJldHVybiB4OyAvLyBtaXNzaW5nIGFyZ3VtZW50XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XHJcbiAgICAgIGkgKz0gMTtcclxuICAgICAgc3dpdGNoICh4KSB7XHJcbiAgICAgICAgY2FzZSAnJSUnOlxyXG4gICAgICAgICAgcmV0dXJuICclJztcclxuICAgICAgICBjYXNlICclcyc6XHJcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XHJcbiAgICAgICAgY2FzZSAnJWQnOlxyXG4gICAgICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xyXG4gICAgICAgIGNhc2UgJyV2JzpcclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXHJcbiAgfTtcclxuICB2YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xyXG4gICAgdmFyIHN0ciA9IG9iai5mb3JtYXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG9iai5mb3JtYXQob2JqLnB1c2ggPyBsb2NhdGlvbiA6IGxvY2F0aW9uW29iai5uYW1lXSkgOiBvYmouZm9ybWF0O1xyXG4gICAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XHJcbiAgICBpZiAob2JqLm5hbWVzKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XHJcbiAgICAgICAgaWYgKG9iai5uYW1lKSB7XHJcbiAgICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdW25dKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcclxuICAgICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZXNbaV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcclxuICB9O1xyXG5cclxuICAvLyBSRkMgc3BlY2lmaWVkIG9yZGVyXHJcbiAgLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcclxuICB2YXIgZGVmYXVsdE91dGVyT3JkZXIgPSBbJ3YnLCAnbycsICdzJywgJ2knLCAndScsICdlJywgJ3AnLCAnYycsICdiJywgJ3QnLCAncicsICd6JywgJ2EnXTtcclxuICB2YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcclxuICB3cml0ZXIgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xyXG4gICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XHJcbiAgICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcclxuICAgICAgc2Vzc2lvbi52ZXJzaW9uID0gMDsgLy8gJ3Y9MCcgbXVzdCBiZSB0aGVyZSAob25seSBkZWZpbmVkIHZlcnNpb24gYXRtKVxyXG4gICAgfVxyXG4gICAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XHJcbiAgICAgIHNlc3Npb24ubmFtZSA9ICcgJzsgLy8gJ3M9ICcgbXVzdCBiZSB0aGVyZSBpZiBubyBtZWFuaW5nZnVsIG5hbWUgc2V0XHJcbiAgICB9XHJcbiAgICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XHJcbiAgICAgIGlmIChtTGluZS5wYXlsb2FkcyA9PSBudWxsKSB7XHJcbiAgICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcclxuICAgIHZhciBpbm5lck9yZGVyID0gb3B0cy5pbm5lck9yZGVyIHx8IGRlZmF1bHRJbm5lck9yZGVyO1xyXG4gICAgdmFyIHNkcCA9IFtdO1xyXG5cclxuICAgIC8vIGxvb3AgdGhyb3VnaCBvdXRlck9yZGVyIGZvciBtYXRjaGluZyBwcm9wZXJ0aWVzIG9uIHNlc3Npb25cclxuICAgIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIGlmIChvYmoubmFtZSBpbiBzZXNzaW9uICYmIHNlc3Npb25bb2JqLm5hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBzZXNzaW9uW29iai5wdXNoXS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcclxuICAgIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcclxuICAgICAgc2RwLnB1c2gobWFrZUxpbmUoJ20nLCBncmFtbWFyLm1bMF0sIG1MaW5lKSk7XHJcbiAgICAgIGlubmVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBtTGluZSkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChvYmoucHVzaCBpbiBtTGluZSAmJiBtTGluZVtvYmoucHVzaF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIGVsKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHNkcC5qb2luKCdcXHJcXG4nKSArICdcXHJcXG4nO1xyXG4gIH07XHJcbiAgcmV0dXJuIHdyaXRlcjtcclxufVxyXG5cclxudmFyIGhhc1JlcXVpcmVkTGliO1xyXG5mdW5jdGlvbiByZXF1aXJlTGliKCkge1xyXG4gIGlmIChoYXNSZXF1aXJlZExpYikgcmV0dXJuIGxpYjtcclxuICBoYXNSZXF1aXJlZExpYiA9IDE7XHJcbiAgdmFyIHBhcnNlciA9IHJlcXVpcmVQYXJzZXIoKTtcclxuICB2YXIgd3JpdGVyID0gcmVxdWlyZVdyaXRlcigpO1xyXG4gIHZhciBncmFtbWFyID0gcmVxdWlyZUdyYW1tYXIoKTtcclxuICBsaWIuZ3JhbW1hciA9IGdyYW1tYXI7XHJcbiAgbGliLndyaXRlID0gd3JpdGVyO1xyXG4gIGxpYi5wYXJzZSA9IHBhcnNlci5wYXJzZTtcclxuICBsaWIucGFyc2VQYXJhbXMgPSBwYXJzZXIucGFyc2VQYXJhbXM7XHJcbiAgbGliLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7IC8vIEFsaWFzIG9mIHBhcnNlUGFyYW1zKCkuXHJcbiAgbGliLnBhcnNlUGF5bG9hZHMgPSBwYXJzZXIucGFyc2VQYXlsb2FkcztcclxuICBsaWIucGFyc2VSZW1vdGVDYW5kaWRhdGVzID0gcGFyc2VyLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcztcclxuICBsaWIucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBwYXJzZXIucGFyc2VJbWFnZUF0dHJpYnV0ZXM7XHJcbiAgbGliLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IHBhcnNlci5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3Q7XHJcbiAgcmV0dXJuIGxpYjtcclxufVxyXG5cclxudmFyIGxpYkV4cG9ydHMgPSByZXF1aXJlTGliKCk7XHJcblxyXG5mdW5jdGlvbiByKHIsIGUsIG4pIHtcclxuICB2YXIgaSwgdCwgbztcclxuICB2b2lkIDAgPT09IGUgJiYgKGUgPSA1MCksIHZvaWQgMCA9PT0gbiAmJiAobiA9IHt9KTtcclxuICB2YXIgYSA9IG51bGwgIT0gKGkgPSBuLmlzSW1tZWRpYXRlKSAmJiBpLFxyXG4gICAgdSA9IG51bGwgIT0gKHQgPSBuLmNhbGxiYWNrKSAmJiB0LFxyXG4gICAgYyA9IG4ubWF4V2FpdCxcclxuICAgIHYgPSBEYXRlLm5vdygpLFxyXG4gICAgbCA9IFtdO1xyXG4gIGZ1bmN0aW9uIGYoKSB7XHJcbiAgICBpZiAodm9pZCAwICE9PSBjKSB7XHJcbiAgICAgIHZhciByID0gRGF0ZS5ub3coKSAtIHY7XHJcbiAgICAgIGlmIChyICsgZSA+PSBjKSByZXR1cm4gYyAtIHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZTtcclxuICB9XHJcbiAgdmFyIGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgbiA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGksIHQpIHtcclxuICAgICAgdmFyIGMgPSBhICYmIHZvaWQgMCA9PT0gbztcclxuICAgICAgaWYgKHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobyA9IHZvaWQgMCwgdiA9IERhdGUubm93KCksICFhKSB7XHJcbiAgICAgICAgICB2YXIgaSA9IHIuYXBwbHkobiwgZSk7XHJcbiAgICAgICAgICB1ICYmIHUoaSksIGwuZm9yRWFjaChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIHIucmVzb2x2ZSkoaSk7XHJcbiAgICAgICAgICB9KSwgbCA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgZigpKSwgYykge1xyXG4gICAgICAgIHZhciBkID0gci5hcHBseShuLCBlKTtcclxuICAgICAgICByZXR1cm4gdSAmJiB1KGQpLCBpKGQpO1xyXG4gICAgICB9XHJcbiAgICAgIGwucHVzaCh7XHJcbiAgICAgICAgcmVzb2x2ZTogaSxcclxuICAgICAgICByZWplY3Q6IHRcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG4gIHJldHVybiBkLmNhbmNlbCA9IGZ1bmN0aW9uIChyKSB7XHJcbiAgICB2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgcmV0dXJuICgwLCBlLnJlamVjdCkocik7XHJcbiAgICB9KSwgbCA9IFtdO1xyXG4gIH0sIGQ7XHJcbn1cclxuXHJcbi8qIFRoZSBzdmMgY29kZWMgKGF2MS92cDkpIHdvdWxkIHVzZSBhIHZlcnkgbG93IGJpdHJhdGUgYXQgdGhlIGJlZ2luaW5nIGFuZFxyXG5pbmNyZWFzZSBzbG93bHkgYnkgdGhlIGJhbmR3aWR0aCBlc3RpbWF0b3IgdW50aWwgaXQgcmVhY2ggdGhlIHRhcmdldCBiaXRyYXRlLiBUaGVcclxucHJvY2VzcyBjb21tb25seSBjb3N0IG1vcmUgdGhhbiAxMCBzZWNvbmRzIGNhdXNlIHN1YnNjcmliZXIgd2lsbCBnZXQgYmx1ciB2aWRlbyBhdFxyXG50aGUgZmlyc3QgZmV3IHNlY29uZHMuIFNvIHdlIHVzZSBhIDcwJSBvZiB0YXJnZXQgYml0cmF0ZSBoZXJlIGFzIHRoZSBzdGFydCBiaXRyYXRlIHRvXHJcbmVsaW1pbmF0ZSB0aGlzIGlzc3VlLlxyXG4qL1xyXG5jb25zdCBzdGFydEJpdHJhdGVGb3JTVkMgPSAwLjc7XHJcbmNvbnN0IGRlYm91bmNlSW50ZXJ2YWwgPSAyMDtcclxuY29uc3QgUENFdmVudHMgPSB7XHJcbiAgTmVnb3RpYXRpb25TdGFydGVkOiAnbmVnb3RpYXRpb25TdGFydGVkJyxcclxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXHJcbiAgUlRQVmlkZW9QYXlsb2FkVHlwZXM6ICdydHBWaWRlb1BheWxvYWRUeXBlcydcclxufTtcclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5jbGFzcyBQQ1RyYW5zcG9ydCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICBnZXQgcGMoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3BjKSB7XHJcbiAgICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3BjO1xyXG4gIH1cclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICAgIHZhciBfYTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLmRkRXh0SUQgPSAwO1xyXG4gICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xyXG4gICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMgPSBbXTtcclxuICAgIHRoaXMucmVtb3RlU3RlcmVvTWlkcyA9IFtdO1xyXG4gICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IFtdO1xyXG4gICAgLy8gZGVib3VuY2VkIG5lZ290aWF0ZSBpbnRlcmZhY2VcclxuICAgIHRoaXMubmVnb3RpYXRlID0gcihvbkVycm9yID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICBvbkVycm9yKGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSksIGRlYm91bmNlSW50ZXJ2YWwpO1xyXG4gICAgdGhpcy5jbG9zZSA9ICgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9wYykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9wYy5jbG9zZSgpO1xyXG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgdGhpcy5fcGMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUENUcmFuc3BvcnQpO1xyXG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XHJcbiAgfVxyXG4gIGNyZWF0ZVBDKCkge1xyXG4gICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpO1xyXG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSBldiA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKCFldi5jYW5kaWRhdGUpIHJldHVybjtcclxuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYuY2FuZGlkYXRlKTtcclxuICAgIH07XHJcbiAgICBwYy5vbmljZWNhbmRpZGF0ZWVycm9yID0gZXYgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIHBjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLmljZUNvbm5lY3Rpb25TdGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHBjLnNpZ25hbGluZ1N0YXRlKTtcclxuICAgIH07XHJcbiAgICBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5jb25uZWN0aW9uU3RhdGUpO1xyXG4gICAgfTtcclxuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSBldiA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vbkRhdGFDaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XHJcbiAgICB9O1xyXG4gICAgcGMub250cmFjayA9IGV2ID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSB0aGlzLm9uVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gcGM7XHJcbiAgfVxyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcclxuICB9XHJcbiAgZ2V0IGlzSUNFQ29ubmVjdGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BjICE9PSBudWxsICYmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKTtcclxuICB9XHJcbiAgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24gJiYgIXRoaXMucmVzdGFydGluZ0ljZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGxldCBtdW5nZWRTRFAgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIHN0ZXJlb01pZHMsXHJcbiAgICAgICAgICBuYWNrTWlkc1xyXG4gICAgICAgIH0gPSBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKHNkKTtcclxuICAgICAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBzdGVyZW9NaWRzO1xyXG4gICAgICAgIHRoaXMucmVtb3RlTmFja01pZHMgPSBuYWNrTWlkcztcclxuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xyXG4gICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gc2Quc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XHJcbiAgICAgICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2gobWVkaWEgPT4ge1xyXG4gICAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcclxuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcclxuICAgICAgICAgICAgICBpZiAoIXRyYWNrYnIudHJhbnNjZWl2ZXIgfHwgbWVkaWEubWlkICE9IHRyYWNrYnIudHJhbnNjZWl2ZXIubWlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xyXG4gICAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCBmbXRwRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnID0gZm10cC5jb25maWcuc3BsaXQoJzsnKS5maWx0ZXIoYXR0ciA9PiAhYXR0ci5pbmNsdWRlcygnbWF4YXZlcmFnZWJpdHJhdGUnKSkuam9pbignOycpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjttYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGZtdHBGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrYnIubWF4YnIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogXCJtYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApXHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbXVuZ2VkU0RQID0gbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWRTRFAsIHRydWUpO1xyXG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcclxuICAgICAgICB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xyXG4gICAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucmVuZWdvdGlhdGUpIHtcclxuICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcclxuICAgICAgfSBlbHNlIGlmIChzZC50eXBlID09PSAnYW5zd2VyJykge1xyXG4gICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlKTtcclxuICAgICAgICBpZiAoc2Quc2RwKSB7XHJcbiAgICAgICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKHNkLnNkcCk7XHJcbiAgICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBtZWRpYS5ydHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVBbmRTZW5kT2ZmZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB0aGlzLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9wYyAmJiB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XHJcbiAgICAgICAgLy8gd2UncmUgd2FpdGluZyBmb3IgdGhlIHBlZXIgdG8gYWNjZXB0IG91ciBvZmZlciwgc28gd2UnbGwganVzdCB3YWl0XHJcbiAgICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcclxuICAgICAgICBjb25zdCBjdXJyZW50U0QgPSB0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbjtcclxuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSAmJiBjdXJyZW50U0QpIHtcclxuICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgLy8gdGhlIGJlc3QgdGhpbmcgdG8gZG8gaXMgdG8gcmVjcmVhdGUgdGhlIHBlZXJjb25uZWN0aW9uXHJcbiAgICAgICAgICB5aWVsZCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihjdXJyZW50U0QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BjIHx8IHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBjcmVhdGVPZmZlciB3aXRoIGNsb3NlZCBwZWVyIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBhY3R1YWxseSBuZWdvdGlhdGVcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0aW5nIHRvIG5lZ290aWF0ZScsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIGNvbnN0IG9mZmVyID0geWllbGQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ29yaWdpbmFsIG9mZmVyJywgT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgc2RwOiBvZmZlci5zZHBcclxuICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XHJcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gb2ZmZXIuc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XHJcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcclxuICAgICAgICBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpO1xyXG4gICAgICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XHJcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICB0aGlzLnRyYWNrQml0cmF0ZXMuc29tZSh0cmFja2JyID0+IHtcclxuICAgICAgICAgICAgaWYgKCFtZWRpYS5tc2lkIHx8ICF0cmFja2JyLmNpZCB8fCAhbWVkaWEubXNpZC5pbmNsdWRlcyh0cmFja2JyLmNpZCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XHJcbiAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTVkNDb2RlYyh0cmFja2JyLmNvZGVjKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSwgc2RwUGFyc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBhdjEgc2xvdyBzdGFydGluZyBpc3N1ZSBhbHJlYWR5IGZpeGVkIGluIGNocm9tZSAxMjQsIGNsZWFuIHRoaXMgYWZ0ZXIgc29tZSB2ZXJzaW9uc1xyXG4gICAgICAgICAgICAvLyBtdW5nIHNkcCBmb3IgYXYxIGJpdHJhdGUgc2V0dGluZyB0aGF0IGNhbid0IGFwcGx5IGJ5IHNlbmRFbmNvZGluZ1xyXG4gICAgICAgICAgICBpZiAodHJhY2tici5jb2RlYyAhPT0gJ2F2MScpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdGFydEJpdHJhdGUgPSBNYXRoLnJvdW5kKHRyYWNrYnIubWF4YnIgKiBzdGFydEJpdHJhdGVGb3JTVkMpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbWVkaWEuZm10cCkge1xyXG4gICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgYW5vdGhlciB0cmFjaydzIGZtdHAgYWxyZWFkeSBpcyBzZXQsIHdlIGNhbm5vdCBvdmVycmlkZSB0aGUgYml0cmF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBoYXMgdGhlIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nIGZvcmNlZCB0byB1c2UgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHRyYWNrJ3MgYml0cmF0ZSBmb3IgYWxsIHRyYWNrc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygneC1nb29nbGUtc3RhcnQtYml0cmF0ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IFwiO3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGU9XCIuY29uY2F0KHN0YXJ0Qml0cmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLnNldE11bmdlZFNEUChvZmZlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcclxuICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVBbmRTZXRBbnN3ZXIoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XHJcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gYW5zd2VyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xyXG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XHJcbiAgICAgICAgZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKTtcclxuICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xyXG4gICAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpKTtcclxuICAgICAgcmV0dXJuIGFuc3dlcjtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcclxuICB9XHJcbiAgYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYy5hZGRUcmFuc2NlaXZlcihtZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xyXG4gIH1cclxuICBhZGRUcmFjayh0cmFjaykge1xyXG4gICAgaWYgKCF0aGlzLl9wYykge1xyXG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgY2xvc2VkLCBjYW5ub3QgYWRkIHRyYWNrJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2spO1xyXG4gIH1cclxuICBzZXRUcmFja0NvZGVjQml0cmF0ZShpbmZvKSB7XHJcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMucHVzaChpbmZvKTtcclxuICB9XHJcbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICghdGhpcy5fcGMpIHtcclxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpO1xyXG4gIH1cclxuICBjYW5SZW1vdmVUcmFjaygpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKTtcclxuICB9XHJcbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVUcmFjayhzZW5kZXIpO1xyXG4gIH1cclxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvblN0YXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnY2xvc2VkJztcclxuICB9XHJcbiAgZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmljZUNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XHJcbiAgfVxyXG4gIGdldFNpZ25hbGxpbmdTdGF0ZSgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWduYWxpbmdTdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XHJcbiAgfVxyXG4gIGdldFRyYW5zY2VpdmVycygpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUcmFuc2NlaXZlcnMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgfVxyXG4gIGdldFNlbmRlcnMoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VuZGVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICB9XHJcbiAgZ2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsRGVzY3JpcHRpb247XHJcbiAgfVxyXG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMucGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVEZXNjcmlwdGlvbjtcclxuICB9XHJcbiAgZ2V0U3RhdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYy5nZXRTdGF0cygpO1xyXG4gIH1cclxuICBnZXRDb25uZWN0ZWRBZGRyZXNzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoIXRoaXMuX3BjKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9ICcnO1xyXG4gICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXAoKTtcclxuICAgICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXHJcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcclxuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHYudHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcclxuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJyAmJiB2LnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LmlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdyZW1vdGUtY2FuZGlkYXRlJzpcclxuICAgICAgICAgICAgY2FuZGlkYXRlcy5zZXQodi5pZCwgXCJcIi5jb25jYXQodi5hZGRyZXNzLCBcIjpcIikuY29uY2F0KHYucG9ydCkpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzZWxlY3RlZElEID0gKF9hID0gY2FuZGlkYXRlUGFpcnMuZ2V0KHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZUNhbmRpZGF0ZUlkO1xyXG4gICAgICBpZiAoc2VsZWN0ZWRJRCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FuZGlkYXRlcy5nZXQoc2VsZWN0ZWRJRCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0TXVuZ2VkU0RQKHNkLCBtdW5nZWQsIHJlbW90ZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKG11bmdlZCkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2RwID0gc2Quc2RwO1xyXG4gICAgICAgIHNkLnNkcCA9IG11bmdlZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIG11bmdlZCBcIi5jb25jYXQocmVtb3RlID8gJ3JlbW90ZScgOiAnbG9jYWwnLCBcIiBkZXNjcmlwdGlvblwiKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIGlmIChyZW1vdGUpIHtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJub3QgYWJsZSB0byBzZXQgXCIuY29uY2F0KHNkLnR5cGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gdW5tb2RpZmllZCBzZHBcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZSxcclxuICAgICAgICAgICAgc2RwOiBtdW5nZWRcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIHNkLnNkcCA9IG9yaWdpbmFsU2RwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChyZW1vdGUpIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxldCBtc2cgPSAndW5rbm93biBlcnJvcic7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgbXNnID0gZS5tZXNzYWdlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBtc2cgPSBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWVsZHMgPSB7XHJcbiAgICAgICAgICBlcnJvcjogbXNnLFxyXG4gICAgICAgICAgc2RwOiBzZC5zZHBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghcmVtb3RlICYmIHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgIGZpZWxkcy5yZW1vdGVTZHAgPSB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvZy5lcnJvcihcInVuYWJsZSB0byBzZXQgXCIuY29uY2F0KHNkLnR5cGUpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGZpZWxkc1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aHJvdyBuZXcgTmVnb3RpYXRpb25FcnJvcihtc2cpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSwgc2RwKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgZGRGb3VuZCA9IChfYSA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZXh0ID0+IHtcclxuICAgICAgaWYgKGV4dC51cmkgPT09IGRkRXh0ZW5zaW9uVVJJKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRkRm91bmQpIHtcclxuICAgICAgaWYgKHRoaXMuZGRFeHRJRCA9PT0gMCkge1xyXG4gICAgICAgIGxldCBtYXhJRCA9IDA7XHJcbiAgICAgICAgc2RwLm1lZGlhLmZvckVhY2gobSA9PiB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICBpZiAobS50eXBlICE9PSAndmlkZW8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIChfYSA9IG0uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChleHQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXh0LnZhbHVlID4gbWF4SUQpIHtcclxuICAgICAgICAgICAgICBtYXhJRCA9IGV4dC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZEV4dElEID0gbWF4SUQgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIChfYiA9IG1lZGlhLmV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnB1c2goe1xyXG4gICAgICAgIHZhbHVlOiB0aGlzLmRkRXh0SUQsXHJcbiAgICAgICAgdXJpOiBkZEV4dGVuc2lvblVSSVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBzdGVyZW9NaWRzLCBuYWNrTWlkcykge1xyXG4gIC8vIGZvdW5kIG9wdXMgY29kZWMgdG8gYWRkIG5hY2sgZmJcclxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xyXG4gIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XHJcbiAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcclxuICAgICAgb3B1c1BheWxvYWQgPSBydHAucGF5bG9hZDtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSk7XHJcbiAgLy8gYWRkIG5hY2sgcnRjcGZiIGlmIG5vdCBleGlzdFxyXG4gIGlmIChvcHVzUGF5bG9hZCA+IDApIHtcclxuICAgIGlmICghbWVkaWEucnRjcEZiKSB7XHJcbiAgICAgIG1lZGlhLnJ0Y3BGYiA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hY2tNaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkgJiYgIW1lZGlhLnJ0Y3BGYi5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcclxuICAgICAgbWVkaWEucnRjcEZiLnB1c2goe1xyXG4gICAgICAgIHBheWxvYWQ6IG9wdXNQYXlsb2FkLFxyXG4gICAgICAgIHR5cGU6ICduYWNrJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChzdGVyZW9NaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkpIHtcclxuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xyXG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XHJcbiAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCdzdGVyZW89MScpKSB7XHJcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7c3RlcmVvPTEnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIob2ZmZXIpIHtcclxuICB2YXIgX2E7XHJcbiAgY29uc3Qgc3RlcmVvTWlkcyA9IFtdO1xyXG4gIGNvbnN0IG5hY2tNaWRzID0gW107XHJcbiAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcclxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xyXG4gIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XHJcbiAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XHJcbiAgICAgICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XHJcbiAgICAgICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICgoX2EgPSBtZWRpYS5ydGNwRmIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcclxuICAgICAgICBuYWNrTWlkcy5wdXNoKG1lZGlhLm1pZCk7XHJcbiAgICAgIH1cclxuICAgICAgbWVkaWEuZm10cC5zb21lKGZtdHAgPT4ge1xyXG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XHJcbiAgICAgICAgICBpZiAoZm10cC5jb25maWcuaW5jbHVkZXMoJ3Nwcm9wLXN0ZXJlbz0xJykpIHtcclxuICAgICAgICAgICAgc3RlcmVvTWlkcy5wdXNoKG1lZGlhLm1pZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4ge1xyXG4gICAgc3RlcmVvTWlkcyxcclxuICAgIG5hY2tNaWRzXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpIHtcclxuICAvLyBDaHJvbWUgY291bGQgZ2VuZXJhdGUgc2RwIHdpdGggYyA9IElOIElQNCA8aXB2NiBhZGRyPlxyXG4gIC8vIGluIGVkZ2UgY2FzZSBhbmQgcmV0dXJuIGVycm9yIHdoZW4gc2V0IHNkcC5UaGlzIGlzIG5vdCBhXHJcbiAgLy8gc2RrIGVycm9yIGJ1dCBjb3JyZWN0IGl0IGlmIHRoZSBpc3N1ZSBkZXRlY3RlZC5cclxuICBpZiAobWVkaWEuY29ubmVjdGlvbikge1xyXG4gICAgY29uc3QgaXNWNiA9IG1lZGlhLmNvbm5lY3Rpb24uaXAuaW5kZXhPZignOicpID49IDA7XHJcbiAgICBpZiAobWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA0ICYmIGlzVjYgfHwgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA2ICYmICFpc1Y2KSB7XHJcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGR1bW15IGFkZHJlc3NcclxuICAgICAgbWVkaWEuY29ubmVjdGlvbi5pcCA9ICcwLjAuMC4wJztcclxuICAgICAgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID0gNDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGRlZmF1bHRWaWRlb0NvZGVjID0gJ3ZwOCc7XHJcbmNvbnN0IHB1Ymxpc2hEZWZhdWx0cyA9IHtcclxuICBhdWRpb1ByZXNldDogQXVkaW9QcmVzZXRzLm11c2ljLFxyXG4gIGR0eDogdHJ1ZSxcclxuICByZWQ6IHRydWUsXHJcbiAgZm9yY2VTdGVyZW86IGZhbHNlLFxyXG4gIHNpbXVsY2FzdDogdHJ1ZSxcclxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcclxuICBzdG9wTWljVHJhY2tPbk11dGU6IGZhbHNlLFxyXG4gIHZpZGVvQ29kZWM6IGRlZmF1bHRWaWRlb0NvZGVjLFxyXG4gIGJhY2t1cENvZGVjOiB0cnVlLFxyXG4gIHByZUNvbm5lY3RCdWZmZXI6IGZhbHNlXHJcbn07XHJcbmNvbnN0IGF1ZGlvRGVmYXVsdHMgPSB7XHJcbiAgZGV2aWNlSWQ6IHtcclxuICAgIGlkZWFsOiAnZGVmYXVsdCdcclxuICB9LFxyXG4gIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcclxuICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxyXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXHJcbiAgdm9pY2VJc29sYXRpb246IHRydWVcclxufTtcclxuY29uc3QgdmlkZW9EZWZhdWx0cyA9IHtcclxuICBkZXZpY2VJZDoge1xyXG4gICAgaWRlYWw6ICdkZWZhdWx0J1xyXG4gIH0sXHJcbiAgcmVzb2x1dGlvbjogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvblxyXG59O1xyXG5jb25zdCByb29tT3B0aW9uRGVmYXVsdHMgPSB7XHJcbiAgYWRhcHRpdmVTdHJlYW06IGZhbHNlLFxyXG4gIGR5bmFjYXN0OiBmYWxzZSxcclxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxyXG4gIHJlY29ubmVjdFBvbGljeTogbmV3IERlZmF1bHRSZWNvbm5lY3RQb2xpY3koKSxcclxuICBkaXNjb25uZWN0T25QYWdlTGVhdmU6IHRydWUsXHJcbiAgd2ViQXVkaW9NaXg6IGZhbHNlXHJcbn07XHJcbmNvbnN0IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMgPSB7XHJcbiAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcclxuICBtYXhSZXRyaWVzOiAxLFxyXG4gIHBlZXJDb25uZWN0aW9uVGltZW91dDogMTUwMDAsXHJcbiAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcclxufTtcclxuXHJcbnZhciBQQ1RyYW5zcG9ydFN0YXRlO1xyXG4oZnVuY3Rpb24gKFBDVHJhbnNwb3J0U3RhdGUpIHtcclxuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJORVdcIl0gPSAwXSA9IFwiTkVXXCI7XHJcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XHJcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMl0gPSBcIkNPTk5FQ1RFRFwiO1xyXG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkZBSUxFRFwiXSA9IDNdID0gXCJGQUlMRURcIjtcclxuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TSU5HXCJdID0gNF0gPSBcIkNMT1NJTkdcIjtcclxuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TRURcIl0gPSA1XSA9IFwiQ0xPU0VEXCI7XHJcbn0pKFBDVHJhbnNwb3J0U3RhdGUgfHwgKFBDVHJhbnNwb3J0U3RhdGUgPSB7fSkpO1xyXG5jbGFzcyBQQ1RyYW5zcG9ydE1hbmFnZXIge1xyXG4gIGdldCBuZWVkc1B1Ymxpc2hlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkO1xyXG4gIH1cclxuICBnZXQgbmVlZHNTdWJzY3JpYmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkO1xyXG4gIH1cclxuICBnZXQgY3VycmVudFN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKHJ0Y0NvbmZpZywgc3Vic2NyaWJlclByaW1hcnksIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XHJcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGVzID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMubWFwKHRyID0+IHRyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcclxuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICdjb25uZWN0ZWQnKSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRDtcclxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdmYWlsZWQnKSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRDtcclxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNUSU5HO1xyXG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRDtcclxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjbG9zZWQnKSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NJTkc7XHJcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ25ldycpKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwYyBzdGF0ZSBjaGFuZ2U6IGZyb20gXCIuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbcHJldmlvdXNTdGF0ZV0sIFwiIHRvIFwiKS5jb25jYXQoUENUcmFuc3BvcnRTdGF0ZVt0aGlzLnN0YXRlXSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5vblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLnN0YXRlLCB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSwgdGhpcy5zdWJzY3JpYmVyLmdldENvbm5lY3Rpb25TdGF0ZSgpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUENNYW5hZ2VyKTtcclxuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XHJcbiAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkID0gIXN1YnNjcmliZXJQcmltYXJ5O1xyXG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSBzdWJzY3JpYmVyUHJpbWFyeTtcclxuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLnN1YnNjcmliZXIgPSBuZXcgUENUcmFuc3BvcnQocnRjQ29uZmlnLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIHRoaXMucHVibGlzaGVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcclxuICAgIHRoaXMuc3Vic2NyaWJlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XHJcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xyXG4gICAgdGhpcy5wdWJsaXNoZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XHJcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNhbmRpZGF0ZSA9IGNhbmRpZGF0ZSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xyXG4gICAgfTtcclxuICAgIC8vIGluIHN1YnNjcmliZXIgcHJpbWFyeSBtb2RlLCBzZXJ2ZXIgc2lkZSBvcGVucyBzdWIgZGF0YSBjaGFubmVscy5cclxuICAgIHRoaXMuc3Vic2NyaWJlci5vbkRhdGFDaGFubmVsID0gZXYgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuc3Vic2NyaWJlci5vblRyYWNrID0gZXYgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIHRoaXMucHVibGlzaGVyLm9uT2ZmZXIgPSBvZmZlciA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5vblB1Ymxpc2hlck9mZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBvZmZlcik7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xyXG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLnJlbW90ZU9mZmVyTG9jayA9IG5ldyBfKCk7XHJcbiAgfVxyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpLmxvZ2dlckNvbnRleHRDYikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcclxuICB9XHJcbiAgcmVxdWlyZVB1Ymxpc2hlcigpIHtcclxuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XHJcbiAgfVxyXG4gIHJlcXVpcmVTdWJzY3JpYmVyKCkge1xyXG4gICAgbGV0IHJlcXVpcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XHJcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XHJcbiAgfVxyXG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpO1xyXG4gIH1cclxuICBzZXRQdWJsaXNoZXJBbnN3ZXIoc2QpIHtcclxuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XHJcbiAgfVxyXG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xyXG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XHJcbiAgfVxyXG4gIGNsb3NlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMucHVibGlzaGVyICYmIHRoaXMucHVibGlzaGVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpICE9PSAnY2xvc2VkJykge1xyXG4gICAgICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2VuZGVyIG9mIHB1Ymxpc2hlci5nZXRTZW5kZXJzKCkpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBoYXZlIHJlbW92ZVRyYWNrIHlldC5cclxuICAgICAgICAgICAgaWYgKHB1Ymxpc2hlci5jYW5SZW1vdmVUcmFjaygpKSB7XHJcbiAgICAgICAgICAgICAgcHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHJlbW92ZVRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5wdWJsaXNoZXIuY2xvc2UoKSwgdGhpcy5zdWJzY3JpYmVyLmNsb3NlKCldKTtcclxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHRyaWdnZXJJY2VSZXN0YXJ0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5zdWJzY3JpYmVyLnJlc3RhcnRpbmdJY2UgPSB0cnVlO1xyXG4gICAgICAvLyBvbmx5IHJlc3RhcnQgcHVibGlzaGVyIGlmIGl0J3MgbmVlZGVkXHJcbiAgICAgIGlmICh0aGlzLm5lZWRzUHVibGlzaGVyKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVBbmRTZW5kUHVibGlzaGVyT2ZmZXIoe1xyXG4gICAgICAgICAgaWNlUmVzdGFydDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGUsXHJcbiAgICAgICAgc2RwOiBzZC5zZHAsXHJcbiAgICAgICAgc2lnbmFsaW5nU3RhdGU6IHRoaXMuc3Vic2NyaWJlci5nZXRTaWduYWxsaW5nU3RhdGUoKS50b1N0cmluZygpXHJcbiAgICAgIH0pKTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5yZW1vdGVPZmZlckxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuc3Vic2NyaWJlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XHJcbiAgICAgICAgLy8gYW5zd2VyIHRoZSBvZmZlclxyXG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcclxuICAgICAgICByZXR1cm4gYW5zd2VyO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWcsIGljZVJlc3RhcnQpIHtcclxuICAgIHRoaXMucHVibGlzaGVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcclxuICAgIHRoaXMuc3Vic2NyaWJlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XHJcbiAgICBpZiAoaWNlUmVzdGFydCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXJJY2VSZXN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgJiYgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkgIT09ICdjb25uZWN0ZWQnICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGluZycpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCduZWdvdGlhdGlvbiByZXF1aXJlZCwgc3RhcnQgbmVnb3RpYXRpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKChfYSA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKHRyYW5zcG9ydCA9PiB0aGlzLmVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCh0cmFuc3BvcnQsIGFib3J0Q29udHJvbGxlciwgdGltZW91dCkpKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIG5lZ290aWF0ZShhYm9ydENvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgbmVnb3RpYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xyXG4gICAgICAgIH0sIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcclxuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgIHJlamVjdCgnbmVnb3RpYXRpb24gYWJvcnRlZCcpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQsICgpID0+IHtcclxuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hlci5uZWdvdGlhdGUoZSA9PiB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrLCB0cmFuc2NlaXZlckluaXQpIHtcclxuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcclxuICB9XHJcbiAgYWRkUHVibGlzaGVyVHJhY2sodHJhY2spIHtcclxuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XHJcbiAgfVxyXG4gIGNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpIHtcclxuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcmVxdWlyZWQgdHJhbnNwb3J0J3MgYWRkcmVzcyBpZiBubyBleHBsaWNpdCB0YXJnZXQgaXMgc3BlY2lmaWVkXHJcbiAgICovXHJcbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcyh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUikge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzWzBdLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcclxuICB9XHJcbiAgZ2V0IHJlcXVpcmVkVHJhbnNwb3J0cygpIHtcclxuICAgIGNvbnN0IHRyYW5zcG9ydHMgPSBbXTtcclxuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XHJcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnB1Ymxpc2hlcik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcclxuICAgICAgdHJhbnNwb3J0cy5wdXNoKHRoaXMuc3Vic2NyaWJlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNwb3J0cztcclxuICB9XHJcbiAgZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHBjVHJhbnNwb3J0XzEsIGFib3J0Q29udHJvbGxlcl8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocGNUcmFuc3BvcnQsIGFib3J0Q29udHJvbGxlcikge1xyXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZSA9IHBjVHJhbnNwb3J0LmdldENvbm5lY3Rpb25TdGF0ZSgpO1xyXG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy53YXJuKCdhYm9ydCB0cmFuc3BvcnQgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xyXG4gICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcignY291bGQgbm90IGVzdGFibGlzaCBwYyBjb25uZWN0aW9uJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcclxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgICAgd2hpbGUgKHRoaXMuc3RhdGUgIT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTsgLy8gRklYTUUgd2Ugc2hvdWxkbid0IHJlbHkgb24gYHNsZWVwYCBpbiB0aGUgY29ubmVjdGlvbiBwYXRocywgYXMgaXQgaW52b2tlcyBgc2V0VGltZW91dGAgd2hpY2ggY2FuIGJlIGRyYXN0aWNhbGx5IHRocm90dGxlZCBieSBicm93c2VyIGltcGxlbWVudGF0aW9uc1xyXG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFNQRFgtRmlsZUNvcHlyaWdodFRleHQ6IDIwMjQgTGl2ZUtpdCwgSW5jLlxyXG4vL1xyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxyXG4vKipcclxuICogU3BlY2lhbGl6ZWQgZXJyb3IgaGFuZGxpbmcgZm9yIFJQQyBtZXRob2RzLlxyXG4gKlxyXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyB0eXBlLCB3aGVuIHRocm93biBpbiBhIG1ldGhvZCBoYW5kbGVyLCB3aWxsIGhhdmUgdGhlaXIgYG1lc3NhZ2VgXHJcbiAqIHNlcmlhbGl6ZWQgYW5kIHNlbnQgYWNyb3NzIHRoZSB3aXJlLiBUaGUgc2VuZGVyIHdpbGwgcmVjZWl2ZSBhbiBlcXVpdmFsZW50IGVycm9yIG9uIHRoZSBvdGhlciBzaWRlLlxyXG4gKlxyXG4gKiBCdWlsdC1pbiB0eXBlcyBhcmUgaW5jbHVkZWQgYnV0IGRldmVsb3BlcnMgbWF5IHVzZSBhbnkgc3RyaW5nLCB3aXRoIGEgbWF4IGxlbmd0aCBvZiAyNTYgYnl0ZXMuXHJcbiAqL1xyXG5jbGFzcyBScGNFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2RlIGFuZCBtZXNzYWdlLCBwbHVzIGFuIG9wdGlvbmFsIGRhdGEgcGF5bG9hZC5cclxuICAgKlxyXG4gICAqIElmIHRocm93biBpbiBhbiBSUEMgbWV0aG9kIGhhbmRsZXIsIHRoZSBlcnJvciB3aWxsIGJlIHNlbnQgYmFjayB0byB0aGUgY2FsbGVyLlxyXG4gICAqXHJcbiAgICogRXJyb3IgY29kZXMgMTAwMS0xOTk5IGFyZSByZXNlcnZlZCBmb3IgYnVpbHQtaW4gZXJyb3JzIChzZWUgUnBjRXJyb3IuRXJyb3JDb2RlIGZvciB0aGVpciBtZWFuaW5ncykuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xyXG4gICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gdHJ1bmNhdGVCeXRlcyhtZXNzYWdlLCBScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyk7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhID8gdHJ1bmNhdGVCeXRlcyhkYXRhLCBScGNFcnJvci5NQVhfREFUQV9CWVRFUykgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tUHJvdG8ocHJvdG8pIHtcclxuICAgIHJldHVybiBuZXcgUnBjRXJyb3IocHJvdG8uY29kZSwgcHJvdG8ubWVzc2FnZSwgcHJvdG8uZGF0YSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHRvUHJvdG8oKSB7XHJcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yJDEoe1xyXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgZGF0YTogdGhpcy5kYXRhXHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgZnJvbSB0aGUgY29kZSwgd2l0aCBhbiBhdXRvLXBvcHVsYXRlZCBtZXNzYWdlLlxyXG4gICAqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc3RhdGljIGJ1aWx0SW4oa2V5LCBkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKFJwY0Vycm9yLkVycm9yQ29kZVtrZXldLCBScGNFcnJvci5FcnJvck1lc3NhZ2Vba2V5XSwgZGF0YSk7XHJcbiAgfVxyXG59XHJcblJwY0Vycm9yLk1BWF9NRVNTQUdFX0JZVEVTID0gMjU2O1xyXG5ScGNFcnJvci5NQVhfREFUQV9CWVRFUyA9IDE1MzYwOyAvLyAxNSBLQlxyXG5ScGNFcnJvci5FcnJvckNvZGUgPSB7XHJcbiAgQVBQTElDQVRJT05fRVJST1I6IDE1MDAsXHJcbiAgQ09OTkVDVElPTl9USU1FT1VUOiAxNTAxLFxyXG4gIFJFU1BPTlNFX1RJTUVPVVQ6IDE1MDIsXHJcbiAgUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRDogMTUwMyxcclxuICBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRTogMTUwNCxcclxuICBTRU5EX0ZBSUxFRDogMTUwNSxcclxuICBVTlNVUFBPUlRFRF9NRVRIT0Q6IDE0MDAsXHJcbiAgUkVDSVBJRU5UX05PVF9GT1VORDogMTQwMSxcclxuICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAxNDAyLFxyXG4gIFVOU1VQUE9SVEVEX1NFUlZFUjogMTQwMyxcclxuICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAxNDA0XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcblJwY0Vycm9yLkVycm9yTWVzc2FnZSA9IHtcclxuICBBUFBMSUNBVElPTl9FUlJPUjogJ0FwcGxpY2F0aW9uIGVycm9yIGluIG1ldGhvZCBoYW5kbGVyJyxcclxuICBDT05ORUNUSU9OX1RJTUVPVVQ6ICdDb25uZWN0aW9uIHRpbWVvdXQnLFxyXG4gIFJFU1BPTlNFX1RJTUVPVVQ6ICdSZXNwb25zZSB0aW1lb3V0JyxcclxuICBSRUNJUElFTlRfRElTQ09OTkVDVEVEOiAnUmVjaXBpZW50IGRpc2Nvbm5lY3RlZCcsXHJcbiAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6ICdSZXNwb25zZSBwYXlsb2FkIHRvbyBsYXJnZScsXHJcbiAgU0VORF9GQUlMRUQ6ICdGYWlsZWQgdG8gc2VuZCcsXHJcbiAgVU5TVVBQT1JURURfTUVUSE9EOiAnTWV0aG9kIG5vdCBzdXBwb3J0ZWQgYXQgZGVzdGluYXRpb24nLFxyXG4gIFJFQ0lQSUVOVF9OT1RfRk9VTkQ6ICdSZWNpcGllbnQgbm90IGZvdW5kJyxcclxuICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAnUmVxdWVzdCBwYXlsb2FkIHRvbyBsYXJnZScsXHJcbiAgVU5TVVBQT1JURURfU0VSVkVSOiAnUlBDIG5vdCBzdXBwb3J0ZWQgYnkgc2VydmVyJyxcclxuICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAnVW5zdXBwb3J0ZWQgUlBDIHZlcnNpb24nXHJcbn07XHJcbi8qXHJcbiAqIE1heGltdW0gcGF5bG9hZCBzaXplIGZvciBSUEMgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy4gSWYgYSBwYXlsb2FkIGV4Y2VlZHMgdGhpcyBzaXplLFxyXG4gKiB0aGUgUlBDIGNhbGwgd2lsbCBmYWlsIHdpdGggYSBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFKDE0MDIpIG9yIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFKDE1MDQpIGVycm9yLlxyXG4gKi9cclxuY29uc3QgTUFYX1BBWUxPQURfQllURVMgPSAxNTM2MDsgLy8gMTUgS0JcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHIpIHtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cikubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHRydW5jYXRlQnl0ZXMoc3RyLCBtYXhCeXRlcykge1xyXG4gIGlmIChieXRlTGVuZ3RoKHN0cikgPD0gbWF4Qnl0ZXMpIHtcclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG4gIGxldCBsb3cgPSAwO1xyXG4gIGxldCBoaWdoID0gc3RyLmxlbmd0aDtcclxuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2ggKyAxKSAvIDIpO1xyXG4gICAgaWYgKGVuY29kZXIuZW5jb2RlKHN0ci5zbGljZSgwLCBtaWQpKS5sZW5ndGggPD0gbWF4Qnl0ZXMpIHtcclxuICAgICAgbG93ID0gbWlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGlnaCA9IG1pZCAtIDE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdHIuc2xpY2UoMCwgbG93KTtcclxufVxyXG5cclxuY29uc3QgbW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XHJcbmZ1bmN0aW9uIGNvbXB1dGVCaXRyYXRlKGN1cnJlbnRTdGF0cywgcHJldlN0YXRzKSB7XHJcbiAgaWYgKCFwcmV2U3RhdHMpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBsZXQgYnl0ZXNOb3c7XHJcbiAgbGV0IGJ5dGVzUHJldjtcclxuICBpZiAoJ2J5dGVzUmVjZWl2ZWQnIGluIGN1cnJlbnRTdGF0cykge1xyXG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNSZWNlaXZlZDtcclxuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1JlY2VpdmVkO1xyXG4gIH0gZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XHJcbiAgICBieXRlc05vdyA9IGN1cnJlbnRTdGF0cy5ieXRlc1NlbnQ7XHJcbiAgICBieXRlc1ByZXYgPSBwcmV2U3RhdHMuYnl0ZXNTZW50O1xyXG4gIH1cclxuICBpZiAoYnl0ZXNOb3cgPT09IHVuZGVmaW5lZCB8fCBieXRlc1ByZXYgPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50U3RhdHMudGltZXN0YW1wID09PSB1bmRlZmluZWQgfHwgcHJldlN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgcmV0dXJuIChieXRlc05vdyAtIGJ5dGVzUHJldikgKiA4ICogMTAwMCAvIChjdXJyZW50U3RhdHMudGltZXN0YW1wIC0gcHJldlN0YXRzLnRpbWVzdGFtcCk7XHJcbn1cclxuXHJcbi8vIENoZWNrIGlmIE1lZGlhUmVjb3JkZXIgaXMgYXZhaWxhYmxlXHJcbmNvbnN0IGlzTWVkaWFSZWNvcmRlckF2YWlsYWJsZSA9IHR5cGVvZiBNZWRpYVJlY29yZGVyICE9PSAndW5kZWZpbmVkJztcclxuLy8gRmFsbGJhY2sgY2xhc3MgZm9yIGVudmlyb25tZW50cyB3aXRob3V0IE1lZGlhUmVjb3JkZXJcclxuY2xhc3MgRmFsbGJhY2tSZWNvcmRlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lZGlhUmVjb3JkZXIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XHJcbiAgfVxyXG59XHJcbi8vIFVzZSBjb25kaXRpb25hbCBpbmhlcml0YW5jZSB0byBhdm9pZCBwYXJzZS10aW1lIGVycm9yc1xyXG5jb25zdCBSZWNvcmRlckJhc2UgPSBpc01lZGlhUmVjb3JkZXJBdmFpbGFibGUgPyBNZWRpYVJlY29yZGVyIDogRmFsbGJhY2tSZWNvcmRlcjtcclxuY2xhc3MgTG9jYWxUcmFja1JlY29yZGVyIGV4dGVuZHMgUmVjb3JkZXJCYXNlIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKCFpc01lZGlhUmVjb3JkZXJBdmFpbGFibGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZWRpYVJlY29yZGVyIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xyXG4gICAgfVxyXG4gICAgc3VwZXIobmV3IE1lZGlhU3RyZWFtKFt0cmFjay5tZWRpYVN0cmVhbVRyYWNrXSksIG9wdGlvbnMpO1xyXG4gICAgbGV0IGRhdGFMaXN0ZW5lcjtcclxuICAgIGxldCBzdHJlYW1Db250cm9sbGVyO1xyXG4gICAgY29uc3QgaXNDbG9zZWQgPSAoKSA9PiBzdHJlYW1Db250cm9sbGVyID09PSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBvblN0b3AgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGRhdGFMaXN0ZW5lcik7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcCcsIG9uU3RvcCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcclxuICAgICAgc3RyZWFtQ29udHJvbGxlciA9PT0gbnVsbCB8fCBzdHJlYW1Db250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25FcnJvciA9IGV2ZW50ID0+IHtcclxuICAgICAgc3RyZWFtQ29udHJvbGxlciA9PT0gbnVsbCB8fCBzdHJlYW1Db250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHJlYW1Db250cm9sbGVyLmVycm9yKGV2ZW50KTtcclxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZGF0YUxpc3RlbmVyKTtcclxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdG9wJywgb25TdG9wKTtcclxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xyXG4gICAgICBzdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHRoaXMuYnl0ZVN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XHJcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcclxuICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcclxuICAgICAgICBkYXRhTGlzdGVuZXIgPSBldmVudCA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IHlpZWxkIGV2ZW50LmRhdGEuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgIGlmIChpc0Nsb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGRhdGFMaXN0ZW5lcik7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNhbmNlbDogKCkgPT4ge1xyXG4gICAgICAgIG9uU3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignc3RvcCcsIG9uU3RvcCk7XHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XHJcbiAgfVxyXG59XHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiByZWNvcmRpbmcgaXMgc3VwcG9ydGVkXHJcbmZ1bmN0aW9uIGlzUmVjb3JkaW5nU3VwcG9ydGVkKCkge1xyXG4gIHJldHVybiBpc01lZGlhUmVjb3JkZXJBdmFpbGFibGU7XHJcbn1cclxuXHJcbmNvbnN0IERFRkFVTFRfRElNRU5TSU9OU19USU1FT1VUID0gMTAwMDtcclxuY29uc3QgUFJFX0NPTk5FQ1RfQlVGRkVSX1RJTUVPVVQgPSAxMDAwMDtcclxuY2xhc3MgTG9jYWxUcmFjayBleHRlbmRzIFRyYWNrIHtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgZ2V0IHNlbmRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZW5kZXI7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXQgc2VuZGVyKHNlbmRlcikge1xyXG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xyXG4gIH1cclxuICBnZXQgY29uc3RyYWludHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29uc3RyYWludHM7XHJcbiAgfVxyXG4gIGdldCBoYXNQcmVDb25uZWN0QnVmZmVyKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXI7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcclxuICAgKiBAcGFyYW0ga2luZFxyXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXHJcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywga2luZCwgY29uc3RyYWludHMpIHtcclxuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XHJcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xyXG4gICAgc3VwZXIobWVkaWFUcmFjaywga2luZCwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCA9ICgpID0+IHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlcigpLmNhdGNoKCgpID0+IHRoaXMubG9nLmRlYnVnKCd0cmFjayBtdXRlIGJvdW5jZSBnb3QgY2FuY2VsbGVkIGJ5IGFuIHVubXV0ZSBldmVudCcsIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyID0gcigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbSgpO1xyXG4gICAgfSksIDUwMDApO1xyXG4gICAgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCd1bm11dGUnKTtcclxuICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmhhbmRsZUVuZGVkID0gKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5pc0luQmFja2dyb3VuZCkge1xyXG4gICAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xyXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XHJcbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XHJcbiAgICB0aGlzLm11dGVMb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMucGF1c2VVcHN0cmVhbUxvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5wcm9jZXNzb3JMb2NrID0gbmV3IF8oKTtcclxuICAgIHRoaXMucmVzdGFydExvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xyXG4gICAgLy8gYWRkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciwgY29uc3RyYWludHMgYXJlIHN5bmNlZCB3aXRoIE1lZGlhU3RyZWFtVHJhY2tcclxuICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbWVkaWFUcmFjay5nZXRDb25zdHJhaW50cygpO1xyXG4gICAgaWYgKGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldCBpZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmlkO1xyXG4gIH1cclxuICBnZXQgZGltZW5zaW9ucygpIHtcclxuICAgIGlmICh0aGlzLmtpbmQgIT09IFRyYWNrLktpbmQuVmlkZW8pIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHtcclxuICAgICAgd2lkdGgsXHJcbiAgICAgIGhlaWdodFxyXG4gICAgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcclxuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHRcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQ7XHJcbiAgfVxyXG4gIGdldCBpc1VzZXJQcm92aWRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xyXG4gIH1cclxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9jZXNzZWRUcmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcclxuICB9XHJcbiAgZ2V0IGlzTG9jYWwoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogcmV0dXJucyBtZWRpYVN0cmVhbVRyYWNrIHNldHRpbmdzIG9mIHRoZSBjYXB0dXJpbmcgbWVkaWFzdHJlYW10cmFjayBzb3VyY2UgLSBpZ25vcmluZyBwcm9jZXNzb3JzXHJcbiAgICovXHJcbiAgZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpIHtcclxuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XHJcbiAgfVxyXG4gIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2ssIGZvcmNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcclxuICAgICAgICAvLyBkZXRhY2hcclxuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRUcmFja011dGVIYW5kbGVyLmNhbmNlbCgnbmV3LXRyYWNrJyk7XHJcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLm1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtuZXdUcmFja10pO1xyXG4gICAgICBpZiAobmV3VHJhY2spIHtcclxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xyXG4gICAgICAgIC8vIHdoZW4gdW5kZXJseWluZyB0cmFjayBlbWl0cyBtdXRlLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGV2aWNlIGlzIHVuYWJsZVxyXG4gICAgICAgIC8vIHRvIHByb2R1Y2UgbWVkaWEuIEluIHRoaXMgY2FzZSB3ZSdsbCBuZWVkIHRvIHNpZ25hbCB3aXRoIHJlbW90ZSB0aGF0XHJcbiAgICAgICAgLy8gdGhlIHRyYWNrIGlzIFwibXV0ZWRcIlxyXG4gICAgICAgIC8vIG5vdGUgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBMb2NhbFRyYWNrLm11dGUgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xyXG4gICAgICAgIC8vIHRvdWNoIE1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZFxyXG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcclxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbmV3VHJhY2suZ2V0Q29uc3RyYWludHMoKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcHJvY2Vzc2VkVHJhY2s7XHJcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiBuZXdUcmFjaykge1xyXG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgYXR0YWNoVG9FbGVtZW50KG5ld1RyYWNrLCB0aGlzLnByb2Nlc3NvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlIHByb2Nlc3NvckVsZW1lbnQgaXRzZWxmIHN0YXlzIG11dGVkXHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnByb2Nlc3Nvci5yZXN0YXJ0KHtcclxuICAgICAgICAgICAgdHJhY2s6IG5ld1RyYWNrLFxyXG4gICAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMucHJvY2Vzc29yRWxlbWVudFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwcm9jZXNzZWRUcmFjayA9IHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB1bmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2VuZGVyICYmICgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBpZiBgbmV3VHJhY2tgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBleGlzdGluZyB0cmFjaywgc3RvcCB0aGVcclxuICAgICAgLy8gb2xkZXIgdHJhY2sganVzdCBiZWZvcmUgcmVwbGFjaW5nIGl0XHJcbiAgICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcclxuICAgICAgaWYgKG5ld1RyYWNrKSB7XHJcbiAgICAgICAgLy8gc3luYyBtdXRlZCBzdGF0ZSB3aXRoIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBuZXdseSBwcm92aWRlZCB0cmFja1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XHJcbiAgICAgICAgLy8gd2hlbiBhIHZhbGlkIHRyYWNrIGlzIHJlcGxhY2UsIHdlJ2Qgd2FudCB0byBzdGFydCBwcm9kdWNpbmdcclxuICAgICAgICB5aWVsZCB0aGlzLnJlc3VtZVVwc3RyZWFtKCk7XHJcbiAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICAgICAgYXR0YWNoVG9FbGVtZW50KHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrLCBlbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICB3YWl0Rm9yRGltZW5zaW9ucygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IERFRkFVTFRfRElNRU5TSU9OU19USU1FT1VUO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKF90aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBkaW1lbnNpb25zIGZvciBhdWRpbyB0cmFja3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcykgPT09ICdpT1MnKSB7XHJcbiAgICAgICAgICAvLyBicm93c2VycyByZXBvcnQgd3JvbmcgaW5pdGlhbCByZXNvbHV0aW9uIG9uIGlPUy5cclxuICAgICAgICAgIC8vIHdoZW4gc2xpZ2h0bHkgZGVsYXlpbmcgdGhlIGNhbGwgdG8gLmdldFNldHRpbmdzKCksIHRoZSBjb3JyZWN0IHJlc29sdXRpb24gaXMgYmVpbmcgcmVwb3J0ZWRcclxuICAgICAgICAgIHlpZWxkIHNsZWVwKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydGVkIDwgdGltZW91dCkge1xyXG4gICAgICAgICAgY29uc3QgZGltcyA9IF90aGlzLmRpbWVuc2lvbnM7XHJcbiAgICAgICAgICBpZiAoZGltcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGltcztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHlpZWxkIHNsZWVwKDUwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gZ2V0IHRyYWNrIGRpbWVuc2lvbnMgYWZ0ZXIgdGltZW91dCcpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0RGV2aWNlSWQoZGV2aWNlSWQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID0gZGV2aWNlSWQ7XHJcbiAgICAgIC8vIHdoZW4gdHJhY2sgaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXHJcbiAgICAgIC8vIHdpbGwgYmUgcmVzdGFydGVkIGxhdGVyXHJcbiAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnRUcmFjaygpO1xyXG4gICAgICByZXR1cm4gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcclxuICAgKi9cclxuICBnZXREZXZpY2VJZCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcbiAgICAgIGxldCBub3JtYWxpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIC8vIHNjcmVlbiBzaGFyZSBkb2Vzbid0IGhhdmUgYSB1c2FibGUgZGV2aWNlIGlkXHJcbiAgICAgICAgaWYgKF90aGlzMi5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBkZXZpY2VJZCxcclxuICAgICAgICAgIGdyb3VwSWRcclxuICAgICAgICB9ID0gX3RoaXMyLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XHJcbiAgICAgICAgY29uc3Qga2luZCA9IF90aGlzMi5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvID8gJ2F1ZGlvaW5wdXQnIDogJ3ZpZGVvaW5wdXQnO1xyXG4gICAgICAgIHJldHVybiBub3JtYWxpemUgPyBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkubm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIDogZGV2aWNlSWQ7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBtdXRlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5zZXRUcmFja011dGVkKHRydWUpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG4gIH1cclxuICB1bm11dGUoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnNldFRyYWNrTXV0ZWQoZmFsc2UpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXBsYWNlVHJhY2sodHJhY2ssIHVzZXJQcm92aWRlZE9yT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIHJlcGxhY2UgYW4gdW5wdWJsaXNoZWQgdHJhY2snKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2s7XHJcbiAgICAgIGxldCBzdG9wUHJvY2Vzc29yO1xyXG4gICAgICBpZiAodHlwZW9mIHVzZXJQcm92aWRlZE9yT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgdXNlclByb3ZpZGVkVHJhY2sgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnM7XHJcbiAgICAgIH0gZWxzZSBpZiAodXNlclByb3ZpZGVkT3JPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy51c2VyUHJvdmlkZWRUcmFjaztcclxuICAgICAgICBzdG9wUHJvY2Vzc29yID0gdXNlclByb3ZpZGVkT3JPcHRpb25zLnN0b3BQcm9jZXNzb3I7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrICE9PSBudWxsICYmIHVzZXJQcm92aWRlZFRyYWNrICE9PSB2b2lkIDAgPyB1c2VyUHJvdmlkZWRUcmFjayA6IHRydWU7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXBsYWNlIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sodHJhY2spO1xyXG4gICAgICAvLyB0aGlzIG11c3QgYmUgc3luY2VkICphZnRlciogc2V0dGluZyBtZWRpYVN0cmVhbVRyYWNrIGFib3ZlLCBzaW5jZSBpdCByZWxpZXNcclxuICAgICAgLy8gb24gdGhlIHByZXZpb3VzIHN0YXRlIGluIG9yZGVyIHRvIGNsZWFudXBcclxuICAgICAgaWYgKHN0b3BQcm9jZXNzb3IgJiYgdGhpcy5wcm9jZXNzb3IpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXN0YXJ0KGNvbnN0cmFpbnRzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnJlc3RhcnRMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHRoaXMuX2NvbnN0cmFpbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGRldmljZUlkLFxyXG4gICAgICAgICAgICBmYWNpbmdNb2RlXHJcbiAgICAgICAgICB9ID0gY29uc3RyYWludHMsXHJcbiAgICAgICAgICBvdGhlckNvbnN0cmFpbnRzID0gX19yZXN0KGNvbnN0cmFpbnRzLCBbXCJkZXZpY2VJZFwiLCBcImZhY2luZ01vZGVcIl0pO1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHRyYWNrIHdpdGggY29uc3RyYWludHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGNvbnN0cmFpbnRzXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0ge1xyXG4gICAgICAgICAgYXVkaW86IGZhbHNlLFxyXG4gICAgICAgICAgdmlkZW86IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgICAgICBzdHJlYW1Db25zdHJhaW50cy52aWRlbyA9IGRldmljZUlkIHx8IGZhY2luZ01vZGUgPyB7XHJcbiAgICAgICAgICAgIGRldmljZUlkLFxyXG4gICAgICAgICAgICBmYWNpbmdNb2RlXHJcbiAgICAgICAgICB9IDogdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RyZWFtQ29uc3RyYWludHMuYXVkaW8gPSBkZXZpY2VJZCA/IHtcclxuICAgICAgICAgICAgZGV2aWNlSWRcclxuICAgICAgICAgIH0gOiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGVzZSBzdGVwcyBhcmUgZHVwbGljYXRlZCBmcm9tIHNldE1lZGlhU3RyZWFtVHJhY2sgYmVjYXVzZSB3ZSBtdXN0IHN0b3BcclxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgdHJhY2tzIGJlZm9yZSBuZXcgdHJhY2tzIGNhbiBiZSBhY3F1aXJlZFxyXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcclxuICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgICAvLyBvbiBTYWZhcmksIHRoZSBvbGQgYXVkaW8gdHJhY2sgbXVzdCBiZSBzdG9wcGVkIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGFjcXVpcmVcclxuICAgICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxyXG4gICAgICAgIC8vICdBIE1lZGlhU3RyZWFtVHJhY2sgZW5kZWQgZHVlIHRvIGEgY2FwdHVyZSBmYWlsdXJlYFxyXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgdHJhY2sgYW5kIGF0dGFjaFxyXG4gICAgICAgIGNvbnN0IG1lZGlhU3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoc3RyZWFtQ29uc3RyYWludHMpO1xyXG4gICAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XHJcbiAgICAgICAgeWllbGQgbmV3VHJhY2suYXBwbHlDb25zdHJhaW50cyhvdGhlckNvbnN0cmFpbnRzKTtcclxuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2spO1xyXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5tYW51YWxseVN0b3BwZWQpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3RyYWNrIHdhcyBzdG9wcGVkIGR1cmluZyBhIHJlc3RhcnQsIHN0b3BwaW5nIHJlc3RhcnRlZCB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXRUcmFja011dGVkKG11dGVkKSB7XHJcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgXCIuY29uY2F0KHRoaXMua2luZCwgXCIgdHJhY2sgXCIpLmNvbmNhdChtdXRlZCA/ICdtdXRlZCcgOiAndW5tdXRlZCcpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcclxuICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xyXG4gIH1cclxuICBnZXQgbmVlZHNSZUFjcXVpc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVhZHlTdGF0ZSAhPT0gJ2xpdmUnIHx8IHRoaXMuX21lZGlhU3RyZWFtVHJhY2subXV0ZWQgfHwgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fCB0aGlzLnJlYWNxdWlyZVRyYWNrO1xyXG4gIH1cclxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xyXG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcclxuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwidmlzaWJpbGl0eSBjaGFuZ2VkLCBpcyBpbiBCYWNrZ3JvdW5kOiBcIi5jb25jYXQodGhpcy5pc0luQmFja2dyb3VuZCksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nIFwiLmNvbmNhdCh0aGlzLnNvdXJjZSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RvcCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcclxuICAgIHN1cGVyLnN0b3AoKTtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xyXG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xyXG4gICAgKF9hID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XHJcbiAgICB0aGlzLnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogcGF1c2VzIHB1Ymxpc2hpbmcgdG8gdGhlIHNlcnZlciB3aXRob3V0IGRpc2FibGluZyB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFja1xyXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xyXG4gICAqIHRoZSBzZXJ2ZXIuXHJcbiAgICogdGhpcyBBUEkgaXMgdW5zdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIgZHVlIHRvIGEgYnVnXHJcbiAgICoqL1xyXG4gIHBhdXNlVXBzdHJlYW0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbUxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byBwYXVzZSB1cHN0cmVhbSBmb3IgYW4gdW5wdWJsaXNoZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcyk7XHJcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgICAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzEyLjAnKSA8IDApIHtcclxuICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODQ5MTFcclxuICAgICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc3VtZVVwc3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xyXG4gICAgICAgICAgdGhpcy5sb2cud2FybigndW5hYmxlIHRvIHJlc3VtZSB1cHN0cmVhbSBmb3IgYW4gdW5wdWJsaXNoZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcclxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICAgIC8vIHRoaXMgb3BlcmF0aW9uIGlzIG5vb3AgaWYgbWVkaWFzdHJlYW10cmFjayBpcyBhbHJlYWR5IGJlaW5nIHNlbnRcclxuICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIFJUQ1N0YXRzUmVwb3J0IGZvciB0aGUgTG9jYWxUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwU2VuZGVyXHJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxyXG4gICAqXHJcbiAgICogQHJldHVybnMgUHJvbWlzZTxSVENTdGF0c1JlcG9ydD4gfCB1bmRlZmluZWRcclxuICAgKi9cclxuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xyXG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHByb2Nlc3NvciBvbiB0aGlzIHRyYWNrLlxyXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXHJcbiAgICpcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcHJvY2Vzc29yXHJcbiAgICogQHBhcmFtIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5XHJcbiAgICogQHJldHVybnNcclxuICAgKi9cclxuICBzZXRQcm9jZXNzb3IocHJvY2Vzc29yXzEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgX3RoaXMzLmxvZy5kZWJ1Zygnc2V0dGluZyB1cCBwcm9jZXNzb3InLCBfdGhpczMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChfdGhpczMua2luZCk7XHJcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBraW5kOiBfdGhpczMua2luZCxcclxuICAgICAgICAgICAgdHJhY2s6IF90aGlzMy5fbWVkaWFTdHJlYW1UcmFjayxcclxuICAgICAgICAgICAgZWxlbWVudDogcHJvY2Vzc29yRWxlbWVudCxcclxuICAgICAgICAgICAgYXVkaW9Db250ZXh0OiBfdGhpczMuYXVkaW9Db250ZXh0XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XHJcbiAgICAgICAgICBfdGhpczMubG9nLmRlYnVnKCdwcm9jZXNzb3IgaW5pdGlhbGl6ZWQnLCBfdGhpczMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICBpZiAoX3RoaXMzLnByb2Nlc3Nvcikge1xyXG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuc3RvcFByb2Nlc3NvcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKF90aGlzMy5raW5kID09PSAndW5rbm93bicpIHtcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIHByb2Nlc3NvckVsZW1lbnQpO1xyXG4gICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XHJcbiAgICAgICAgICBwcm9jZXNzb3JFbGVtZW50LnBsYXkoKS5jYXRjaChlcnJvciA9PiBfdGhpczMubG9nLmVycm9yKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgX3RoaXMzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcclxuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3JFbGVtZW50ID0gcHJvY2Vzc29yRWxlbWVudDtcclxuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgX3RoaXMzLmF0dGFjaGVkRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICBpZiAoZWwgIT09IF90aGlzMy5wcm9jZXNzb3JFbGVtZW50ICYmIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5KSB7XHJcbiAgICAgICAgICAgICAgICBkZXRhY2hUcmFjayhfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLCBlbCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIChfYSA9IF90aGlzMy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlVHJhY2soX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBfdGhpczMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCBfdGhpczMucHJvY2Vzc29yKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0UHJvY2Vzc29yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTdG9wcyB0aGUgdHJhY2sgcHJvY2Vzc29yXHJcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcclxuICAgKlxyXG4gICAqIEBleHBlcmltZW50YWxcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIHN0b3BQcm9jZXNzb3IoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG4gICAgICBsZXQga2VlcEVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCFfdGhpczQucHJvY2Vzc29yKSByZXR1cm47XHJcbiAgICAgICAgX3RoaXM0LmxvZy5kZWJ1Zygnc3RvcHBpbmcgcHJvY2Vzc29yJywgX3RoaXM0LmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIChfYSA9IF90aGlzNC5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XHJcbiAgICAgICAgeWllbGQgX3RoaXM0LnByb2Nlc3Nvci5kZXN0cm95KCk7XHJcbiAgICAgICAgX3RoaXM0LnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIWtlZXBFbGVtZW50KSB7XHJcbiAgICAgICAgICAoX2IgPSBfdGhpczQucHJvY2Vzc29yRWxlbWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlbW92ZSgpO1xyXG4gICAgICAgICAgX3RoaXM0LnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcGx5IG9yaWdpbmFsIHRyYWNrIGNvbnN0cmFpbnRzIGluIGNhc2UgdGhlIHByb2Nlc3NvciBjaGFuZ2VkIHRoZW1cclxuICAgICAgICB5aWVsZCBfdGhpczQuX21lZGlhU3RyZWFtVHJhY2suYXBwbHlDb25zdHJhaW50cyhfdGhpczQuX2NvbnN0cmFpbnRzKTtcclxuICAgICAgICAvLyBmb3JjZSByZS1zZXR0aW5nIG9mIHRoZSBtZWRpYVN0cmVhbVRyYWNrIG9uIHRoZSBzZW5kZXJcclxuICAgICAgICB5aWVsZCBfdGhpczQuc2V0TWVkaWFTdHJlYW1UcmFjayhfdGhpczQuX21lZGlhU3RyZWFtVHJhY2ssIHRydWUpO1xyXG4gICAgICAgIF90aGlzNC5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXJ0UHJlQ29ubmVjdEJ1ZmZlcigpIHtcclxuICAgIGxldCB0aW1lc2xpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEwMDtcclxuICAgIGlmICghaXNSZWNvcmRpbmdTdXBwb3J0ZWQoKSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdNZWRpYVJlY29yZGVyIGlzIG5vdCBhdmFpbGFibGUsIGNhbm5vdCBzdGFydCBwcmVjb25uZWN0IGJ1ZmZlcicsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIpIHtcclxuICAgICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIgPSBuZXcgTG9jYWxUcmFja1JlY29yZGVyKHRoaXMsIHtcclxuICAgICAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07Y29kZWNzPW9wdXMnXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5sb2cud2FybigncHJlY29ubmVjdCBidWZmZXIgYWxyZWFkeSBzdGFydGVkJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyLnN0YXJ0KHRpbWVzbGljZSk7XHJcbiAgICB0aGlzLmF1dG9TdG9wUHJlQ29ubmVjdEJ1ZmZlciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdwcmVjb25uZWN0IGJ1ZmZlciB0aW1lZCBvdXQsIHN0b3BwaW5nIHJlY29yZGluZyBhdXRvbWF0aWNhbGx5JywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5zdG9wUHJlQ29ubmVjdEJ1ZmZlcigpO1xyXG4gICAgfSwgUFJFX0NPTk5FQ1RfQlVGRkVSX1RJTUVPVVQpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RvcFByZUNvbm5lY3RCdWZmZXIoKSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvU3RvcFByZUNvbm5lY3RCdWZmZXIpO1xyXG4gICAgaWYgKHRoaXMubG9jYWxUcmFja1JlY29yZGVyKSB7XHJcbiAgICAgIHRoaXMubG9jYWxUcmFja1JlY29yZGVyLnN0b3AoKTtcclxuICAgICAgdGhpcy5sb2NhbFRyYWNrUmVjb3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBnZXRQcmVDb25uZWN0QnVmZmVyKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIChfYSA9IHRoaXMubG9jYWxUcmFja1JlY29yZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnl0ZVN0cmVhbTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xyXG4gIC8qKlxyXG4gICAqIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGVuaGFuY2VkIG5vaXNlIGNhbmNlbGxhdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZCBvbiB0aGlzIHRyYWNrXHJcbiAgICovXHJcbiAgZ2V0IGVuaGFuY2VkTm9pc2VDYW5jZWxsYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXHJcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcclxuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xyXG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gICAgbGV0IGF1ZGlvQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xyXG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICB0aGlzLnN0b3BPbk11dGUgPSBmYWxzZTtcclxuICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc3RhdHM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYW5kbGVLcmlzcE5vaXNlRmlsdGVyRW5hYmxlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBlbmFibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlLCB0aGlzLCBBdWRpb1RyYWNrRmVhdHVyZS5URl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT04sIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBkaXNhYmxlZFwiLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XHJcbiAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xyXG4gIH1cclxuICBtdXRlKCkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIG11dGU6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlzYWJsZWQgc3BlY2lhbCBoYW5kbGluZyBhcyBpdCB3aWxsIGNhdXNlIEJUIGhlYWRzZXRzIHRvIHN3aXRjaCBjb21tdW5pY2F0aW9uIG1vZGVzXHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiB0aGlzLnN0b3BPbk11dGUgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBtaWMgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBtaWNyb3Bob25lIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXHJcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVubXV0ZSgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICB1bm11dGU6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSB1bm11dGVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZXZpY2VIYXNDaGFuZ2VkID0gdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkICE9PSB1bndyYXBDb25zdHJhaW50KHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkKTtcclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVhY3F1aXJpbmcgbWljIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydFRyYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIF9zdXBlci51bm11dGUuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc3RhcnRUcmFjayhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBsZXQgY29uc3RyYWludHM7XHJcbiAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xyXG4gICAgICAgICAgYXVkaW86IG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmVzdGFydChjb25zdHJhaW50cykge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIHJlc3RhcnQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnJlc3RhcnRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIF9zdXBlci5yZXN0YXJ0LmNhbGwodGhpcywgY29uc3RyYWludHMpO1xyXG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xyXG4gICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgc3RhcnRNb25pdG9yKCkge1xyXG4gICAgaWYgKCFpc1dlYigpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgdGhpcy5tb25pdG9yU2VuZGVyKCk7XHJcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcclxuICB9XHJcbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICghaXNSZWFjdE5hdGl2ZSgpICYmICF0aGlzLmF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMuc3RvcFByb2Nlc3NvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xyXG4gICAgICAgICAga2luZDogdGhpcy5raW5kLFxyXG4gICAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXHJcbiAgICAgICAgICAvLyBSTiB3b24ndCBoYXZlIG9yIHVzZSBBdWRpb0NvbnRleHRcclxuICAgICAgICAgIGF1ZGlvQ29udGV4dDogdGhpcy5hdWRpb0NvbnRleHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzb3IgXCIuY29uY2F0KHByb2Nlc3Nvci5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB5aWVsZCBwcm9jZXNzb3IuaW5pdChwcm9jZXNzb3JPcHRpb25zKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcclxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spIHtcclxuICAgICAgICAgIHlpZWxkIChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcclxuICAgICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUpO1xyXG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZGlzYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJEaXNhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMucHJvY2Vzc29yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBleHBlcmltZW50YWxcclxuICAgKi9cclxuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0KSB7XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcclxuICB9XHJcbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XHJcbiAgICAgIGxldCBhdWRpb1N0YXRzO1xyXG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xyXG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XHJcbiAgICAgICAgICBhdWRpb1N0YXRzID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxyXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcclxuICAgICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXHJcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxyXG4gICAgICAgICAgICBieXRlc1NlbnQ6IHYuYnl0ZXNTZW50LFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxyXG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lOiB2LnJvdW5kVHJpcFRpbWUsXHJcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXJcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGF1ZGlvU3RhdHM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tGb3JTaWxlbmNlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodGhpcyk7XHJcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTXV0ZWQpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1NpbGVuY2VEZXRlY3RlZCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRyYWNrSXNTaWxlbnQ7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gbWVkaWFUcmFja1RvTG9jYWxUcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgbG9nZ2VyT3B0aW9ucykge1xyXG4gIHN3aXRjaCAobWVkaWFTdHJlYW1UcmFjay5raW5kKSB7XHJcbiAgICBjYXNlICdhdWRpbyc6XHJcbiAgICAgIHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgdW5kZWZpbmVkLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIGNhc2UgJ3ZpZGVvJzpcclxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihcInVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6IFwiLmNvbmNhdChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpKTtcclxuICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcbmNvbnN0IHByZXNldHMxNjkgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0cyk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5jb25zdCBwcmVzZXRzNDMgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0czQzKTtcclxuLyogQGludGVybmFsICovXHJcbmNvbnN0IHByZXNldHNTY3JlZW5TaGFyZSA9IE9iamVjdC52YWx1ZXMoU2NyZWVuU2hhcmVQcmVzZXRzKTtcclxuLyogQGludGVybmFsICovXHJcbmNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5ID0gW1ZpZGVvUHJlc2V0cy5oMTgwLCBWaWRlb1ByZXNldHMuaDM2MF07XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5jb25zdCBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzID0gW1ZpZGVvUHJlc2V0czQzLmgxODAsIFZpZGVvUHJlc2V0czQzLmgzNjBdO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuY29uc3QgY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMgPSBmcm9tUHJlc2V0ID0+IHtcclxuICBjb25zdCBsYXllcnMgPSBbe1xyXG4gICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAyLFxyXG4gICAgZnBzOiBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZVxyXG4gIH1dO1xyXG4gIHJldHVybiBsYXllcnMubWFwKHQgPT4ge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiBuZXcgVmlkZW9QcmVzZXQoTWF0aC5mbG9vcihmcm9tUHJlc2V0LndpZHRoIC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLmZsb29yKGZyb21QcmVzZXQuaGVpZ2h0IC8gdC5zY2FsZVJlc29sdXRpb25Eb3duQnkpLCBNYXRoLm1heCgxNTAwMDAsIE1hdGguZmxvb3IoZnJvbVByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlIC8gKE1hdGgucG93KHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5LCAyKSAqICgoKF9hID0gZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDMwKSAvICgoX2IgPSB0LmZwcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMzApKSkpKSwgdC5mcHMsIGZyb21QcmVzZXQuZW5jb2RpbmcucHJpb3JpdHkpO1xyXG4gIH0pO1xyXG59O1xyXG4vLyAvKipcclxuLy8gICpcclxuLy8gICogQGludGVybmFsXHJcbi8vICAqIEBleHBlcmltZW50YWxcclxuLy8gICovXHJcbi8vIGNvbnN0IGNvbXB1dGVEZWZhdWx0TXVsdGlDb2RlY1NpbXVsY2FzdEVuY29kaW5ncyA9ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4vLyAgIC8vIHVzZSB2cDggYXMgYSBkZWZhdWx0XHJcbi8vICAgY29uc3QgdnA4ID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhmYWxzZSwgd2lkdGgsIGhlaWdodCk7XHJcbi8vICAgY29uc3QgdnA5ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMC45IH07XHJcbi8vICAgY29uc3QgaDI2NCA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDEuMSB9O1xyXG4vLyAgIGNvbnN0IGF2MSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuNyB9O1xyXG4vLyAgIHJldHVybiB7XHJcbi8vICAgICB2cDgsXHJcbi8vICAgICB2cDksXHJcbi8vICAgICBoMjY0LFxyXG4vLyAgICAgYXYxLFxyXG4vLyAgIH07XHJcbi8vIH07XHJcbmNvbnN0IHZpZGVvUmlkcyA9IFsncScsICdoJywgJ2YnXTtcclxuLyogQGludGVybmFsICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVWaWRlb0VuY29kaW5ncyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XHJcbiAgdmFyIF9hLCBfYjtcclxuICBsZXQgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0VuY29kaW5nO1xyXG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XHJcbiAgICB2aWRlb0VuY29kaW5nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcmVlblNoYXJlRW5jb2Rpbmc7XHJcbiAgfVxyXG4gIGNvbnN0IHVzZVNpbXVsY2FzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaW11bGNhc3Q7XHJcbiAgY29uc3Qgc2NhbGFiaWxpdHlNb2RlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjYWxhYmlsaXR5TW9kZTtcclxuICBjb25zdCB2aWRlb0NvZGVjID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ29kZWM7XHJcbiAgaWYgKCF2aWRlb0VuY29kaW5nICYmICF1c2VTaW11bGNhc3QgJiYgIXNjYWxhYmlsaXR5TW9kZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgLy8gd2hlbiB3ZSBhcmVuJ3Qgc2ltdWxjYXN0aW5nIG9yIHN2Yywgd2lsbCBuZWVkIHRvIHJldHVybiBhIHNpbmdsZSBlbmNvZGluZyB3aXRob3V0XHJcbiAgICAvLyBjYXBwaW5nIGJhbmR3aWR0aC4gd2UgYWx3YXlzIHJlcXVpcmUgYSBlbmNvZGluZyBmb3IgZHluYWNhc3RcclxuICAgIHJldHVybiBbe31dO1xyXG4gIH1cclxuICBpZiAoIXZpZGVvRW5jb2RpbmcpIHtcclxuICAgIC8vIGZpbmQgdGhlIHJpZ2h0IGVuY29kaW5nIGJhc2VkIG9uIHdpZHRoL2hlaWdodFxyXG4gICAgdmlkZW9FbmNvZGluZyA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgdmlkZW9Db2RlYyk7XHJcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1c2luZyB2aWRlbyBlbmNvZGluZycsIHZpZGVvRW5jb2RpbmcpO1xyXG4gIH1cclxuICBjb25zdCBzb3VyY2VGcmFtZXJhdGUgPSB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZTtcclxuICBjb25zdCBvcmlnaW5hbCA9IG5ldyBWaWRlb1ByZXNldCh3aWR0aCwgaGVpZ2h0LCB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsIHZpZGVvRW5jb2RpbmcubWF4RnJhbWVyYXRlLCB2aWRlb0VuY29kaW5nLnByaW9yaXR5KTtcclxuICBpZiAoc2NhbGFiaWxpdHlNb2RlICYmIGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcclxuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xyXG4gICAgY29uc3QgZW5jb2RpbmdzID0gW107XHJcbiAgICBpZiAoc20uc3BhdGlhbCA+IDMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgc2NhbGFiaWxpdHlNb2RlOiBcIi5jb25jYXQoc2NhbGFiaWxpdHlNb2RlKSk7XHJcbiAgICB9XHJcbiAgICAvLyBCZWZvcmUgTTExMyBpbiBDaHJvbWUsIGRlZmluaW5nIG11bHRpcGxlIGVuY29kaW5ncyB3aXRoIGFuIFNWQyBjb2RlYyBpbmRpY2F0ZWRcclxuICAgIC8vIHRoYXQgU1ZDIG1vZGUgc2hvdWxkIGJlIHVzZWQuIFNhZmFyaSBzdGlsbCB3b3JrcyB0aGlzIHdheS5cclxuICAgIC8vIFRoaXMgaXMgYSBiaXQgY29uZnVzaW5nIGJ1dCBpcyBkdWUgdG8gaG93IGxpYndlYnJ0YyBpbnRlcnByZXRlZCB0aGUgZW5jb2RpbmdzIGZpZWxkXHJcbiAgICAvLyBiZWZvcmUgTTExMy5cclxuICAgIC8vIEFubm91bmNlZCBoZXJlOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2cvZGlzY3Vzcy13ZWJydGMvYy8tUVEzcHhybC1mdz9wbGk9MVxyXG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgIGlmIChpc1NhZmFyaSgpIHx8XHJcbiAgICAvLyBFdmVuIHRobyBSTiBydW5zIE0xMTQsIGl0IGRvZXMgbm90IHByb2R1Y2UgU1ZDIGxheWVycyB3aGVuIGEgc2luZ2xlIGVuY29kaW5nXHJcbiAgICAvLyBpcyBwcm92aWRlZC4gU28gd2UnbGwgdXNlIHRoZSBsZWdhY3kgU1ZDIHNwZWNpZmljYXRpb24gZm9yIG5vdy5cclxuICAgIC8vIFRPRE86IHdoZW4gd2UgdXBzdHJlYW0gbGlid2VicnRjLCB0aGlzIHdpbGwgbmVlZCBhZGRpdGlvbmFsIHZlcmlmaWNhdGlvblxyXG4gICAgaXNSZWFjdE5hdGl2ZSgpIHx8IChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdDaHJvbWUnICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbiwgJzExMycpIDwgMCkge1xyXG4gICAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xyXG4gICAgICAvLyBzYWZhcmkgMTguNCB1c2VzIGEgZGlmZmVyZW50IHN2YyBBUEkgdGhhdCByZXF1aXJlcyBzY2FsZVJlc29sdXRpb25Eb3duQnkgdG8gYmUgc2V0LlxyXG4gICAgICBjb25zdCByZXF1aXJlU2NhbGUgPSBpc1NhZmFyaVN2Y0FwaShicm93c2VyKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcclxuICAgICAgICAvLyBpbiBsZWdhY3kgU1ZDLCBzY2FsZVJlc29sdXRpb25Eb3duQnkgY2Fubm90IGJlIHNldFxyXG4gICAgICAgIGVuY29kaW5ncy5wdXNoKHtcclxuICAgICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcclxuICAgICAgICAgIG1heEJpdHJhdGU6IHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSAvIE1hdGgucG93KGJpdHJhdGVzUmF0aW8sIGkpLFxyXG4gICAgICAgICAgbWF4RnJhbWVyYXRlOiBvcmlnaW5hbC5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXHJcbiAgICAgICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IHJlcXVpcmVTY2FsZSA/IE1hdGgucG93KDIsIGkpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gbGVnYWN5IFNWQywgc2NhbGFiaWxpdHlNb2RlIGlzIHNldCBvbmx5IG9uIHRoZSBmaXJzdCBlbmNvZGluZ1xyXG4gICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUgPSBzY2FsYWJpbGl0eU1vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbmNvZGluZ3MucHVzaCh7XHJcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLFxyXG4gICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxyXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICBzY2FsYWJpbGl0eU1vZGU6IHNjYWxhYmlsaXR5TW9kZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eSkge1xyXG4gICAgICBlbmNvZGluZ3NbMF0ucHJpb3JpdHkgPSBvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eTtcclxuICAgICAgZW5jb2RpbmdzWzBdLm5ldHdvcmtQcmlvcml0eSA9IG9yaWdpbmFsLmVuY29kaW5nLnByaW9yaXR5O1xyXG4gICAgfVxyXG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInVzaW5nIHN2YyBlbmNvZGluZ1wiLCB7XHJcbiAgICAgIGVuY29kaW5nc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xyXG4gIH1cclxuICBpZiAoIXVzZVNpbXVsY2FzdCkge1xyXG4gICAgcmV0dXJuIFt2aWRlb0VuY29kaW5nXTtcclxuICB9XHJcbiAgbGV0IHByZXNldHMgPSBbXTtcclxuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xyXG4gICAgcHJlc2V0cyA9IChfYSA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwcmVzZXRzID0gKF9iID0gc29ydFByZXNldHMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCk7XHJcbiAgfVxyXG4gIGxldCBtaWRQcmVzZXQ7XHJcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgbG93UHJlc2V0ID0gcHJlc2V0c1swXTtcclxuICAgIGlmIChwcmVzZXRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XHJcbiAgICB9XHJcbiAgICAvLyBOT1RFOlxyXG4gICAgLy8gICAxLiBPcmRlcmluZyBvZiB0aGVzZSBlbmNvZGluZ3MgaXMgaW1wb3J0YW50LiBDaHJvbWUgc2VlbXNcclxuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcclxuICAgIC8vICAgICAgdG8gZGlzYWJsZSB3aGVuIENQVSBjb25zdHJhaW5lZC5cclxuICAgIC8vICAgICAgU28gZW5jb2RpbmdzIHNob3VsZCBiZSBvcmRlcmVkIGluIGluY3JlYXNpbmcgc3BhdGlhbFxyXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxyXG4gICAgLy8gICAyLiBsaXZla2l0LXNlcnZlciB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXHJcbiAgICAvLyAgICAgIHNob3VsZCBoYXZlIHRoZSBiYXNlIGxheWVyIGBxYCBhbmQgdGhlbiBtb3JlIGFkZGVkXHJcbiAgICAvLyAgICAgIGJhc2VkIG9uIG90aGVyIGNvbmRpdGlvbnMuXHJcbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XHJcbiAgICBpZiAoc2l6ZSA+PSA5NjAgJiYgbWlkUHJlc2V0KSB7XHJcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBtaWRQcmVzZXQsIG9yaWdpbmFsXSwgc291cmNlRnJhbWVyYXRlKTtcclxuICAgIH1cclxuICAgIGlmIChzaXplID49IDQ4MCkge1xyXG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdLCBzb3VyY2VGcmFtZXJhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW29yaWdpbmFsXSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKSB7XHJcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcclxuICBpZiAoIW9wdHMuYmFja3VwQ29kZWMgfHwgb3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSB8fCBvcHRzLmJhY2t1cENvZGVjLmNvZGVjID09PSBvcHRzLnZpZGVvQ29kZWMpIHtcclxuICAgIC8vIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICh2aWRlb0NvZGVjICE9PSBvcHRzLmJhY2t1cENvZGVjLmNvZGVjKSB7XHJcbiAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3JlcXVlc3RlZCBhIGRpZmZlcmVudCBjb2RlYyB0aGFuIHNwZWNpZmllZCBhcyBiYWNrdXAnLCB7XHJcbiAgICAgIHNlcnZlclJlcXVlc3RlZDogdmlkZW9Db2RlYyxcclxuICAgICAgYmFja3VwOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjXHJcbiAgICB9KTtcclxuICB9XHJcbiAgb3B0cy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcclxuICAvLyB1c2UgYmFja3VwIGVuY29kaW5nIHNldHRpbmcgYXMgdmlkZW9FbmNvZGluZyBmb3IgYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmdcclxuICBvcHRzLnZpZGVvRW5jb2RpbmcgPSBvcHRzLmJhY2t1cENvZGVjLmVuY29kaW5nO1xyXG4gIGNvbnN0IHNldHRpbmdzID0gdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xyXG4gIGNvbnN0IHdpZHRoID0gKF9hID0gc2V0dGluZ3Mud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcclxuICBjb25zdCBoZWlnaHQgPSAoX2MgPSBzZXR0aW5ncy5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChfZCA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oZWlnaHQ7XHJcbiAgLy8gZGlzYWJsZSBzaW11bGNhc3QgZm9yIHNjcmVlbnNoYXJlIGJhY2t1cCBjb2RlYyBzaW5jZSBMMVR4IGlzIHVzZWQgYnkgcHJpbWFyeSBjb2RlY1xyXG4gIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBvcHRzLnNpbXVsY2FzdCkge1xyXG4gICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRzKTtcclxuICByZXR1cm4gZW5jb2RpbmdzO1xyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQsIGNvZGVjKSB7XHJcbiAgY29uc3QgcHJlc2V0cyA9IHByZXNldHNGb3JSZXNvbHV0aW9uKGlzU2NyZWVuU2hhcmUsIHdpZHRoLCBoZWlnaHQpO1xyXG4gIGxldCB7XHJcbiAgICBlbmNvZGluZ1xyXG4gIH0gPSBwcmVzZXRzWzBdO1xyXG4gIC8vIGhhbmRsZSBwb3J0cmFpdCBieSBzd2FwcGluZyBkaW1lbnNpb25zXHJcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgY29uc3QgcHJlc2V0ID0gcHJlc2V0c1tpXTtcclxuICAgIGVuY29kaW5nID0gcHJlc2V0LmVuY29kaW5nO1xyXG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBwcmVzZXRzIGFyZSBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiBvZiB2cDggYXMgYSBjb2RlY1xyXG4gIC8vIGZvciBvdGhlciBjb2RlY3Mgd2UgYWRqdXN0IHRoZSBtYXhCaXRyYXRlIGlmIG5vIHNwZWNpZmljIHZpZGVvRW5jb2RpbmcgaGFzIGJlZW4gcHJvdmlkZWRcclxuICAvLyB1c2VycyBzaG91bGQgb3ZlcnJpZGUgdGhlc2Ugd2l0aCBvbmVzIHRoYXQgYXJlIG9wdGltaXplZCBmb3IgdGhlaXIgdXNlIGNhc2VcclxuICAvLyBOT1RFOiBTVkMgY29kZWMgYml0cmF0ZXMgYXJlIGluY2x1c2l2ZSBvZiBhbGwgc2NhbGFiaWxpdHkgbGF5ZXJzLiB3aGlsZVxyXG4gIC8vIGJpdHJhdGUgZm9yIG5vbi1TVkMgY29kZWNzIGRvZXMgbm90IGluY2x1ZGUgb3RoZXIgc2ltdWxjYXN0IGxheWVycy5cclxuICBpZiAoY29kZWMpIHtcclxuICAgIHN3aXRjaCAoY29kZWMpIHtcclxuICAgICAgY2FzZSAnYXYxJzpcclxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcclxuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuNztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndnA5JzpcclxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcclxuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuODU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBlbmNvZGluZztcclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCkge1xyXG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XHJcbiAgICByZXR1cm4gcHJlc2V0c1NjcmVlblNoYXJlO1xyXG4gIH1cclxuICBjb25zdCBhc3BlY3QgPSB3aWR0aCA+IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogaGVpZ2h0IC8gd2lkdGg7XHJcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XHJcbiAgICByZXR1cm4gcHJlc2V0czE2OTtcclxuICB9XHJcbiAgcmV0dXJuIHByZXNldHM0MztcclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuZnVuY3Rpb24gZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCkge1xyXG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XHJcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMob3JpZ2luYWwpO1xyXG4gIH1cclxuICBjb25zdCB7XHJcbiAgICB3aWR0aCxcclxuICAgIGhlaWdodFxyXG4gIH0gPSBvcmlnaW5hbDtcclxuICBjb25zdCBhc3BlY3QgPSB3aWR0aCA+IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogaGVpZ2h0IC8gd2lkdGg7XHJcbiAgaWYgKE1hdGguYWJzKGFzcGVjdCAtIDE2LjAgLyA5KSA8IE1hdGguYWJzKGFzcGVjdCAtIDQuMCAvIDMpKSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XHJcbiAgfVxyXG4gIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czQzO1xyXG59XHJcbi8vIHByZXNldHMgc2hvdWxkIGJlIG9yZGVyZWQgYnkgbG93LCBtZWRpdW0sIGhpZ2hcclxuZnVuY3Rpb24gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgcHJlc2V0cywgc291cmNlRnJhbWVyYXRlKSB7XHJcbiAgY29uc3QgZW5jb2RpbmdzID0gW107XHJcbiAgcHJlc2V0cy5mb3JFYWNoKChwcmVzZXQsIGlkeCkgPT4ge1xyXG4gICAgaWYgKGlkeCA+PSB2aWRlb1JpZHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGNvbnN0IHJpZCA9IHZpZGVvUmlkc1tpZHhdO1xyXG4gICAgY29uc3QgZW5jb2RpbmcgPSB7XHJcbiAgICAgIHJpZCxcclxuICAgICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiBNYXRoLm1heCgxLCBzaXplIC8gTWF0aC5taW4ocHJlc2V0LndpZHRoLCBwcmVzZXQuaGVpZ2h0KSksXHJcbiAgICAgIG1heEJpdHJhdGU6IHByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlXHJcbiAgICB9O1xyXG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIHNvdXJjZUZyYW1lcmF0ZSBpcyB0aGUgaGlnaGVzdCBmcmFtZXJhdGUgYXBwbGllZCBhY3Jvc3MgYWxsIGxheWVycyBzbyB0aGF0IHRoZVxyXG4gICAgLy8gb3JpZ2luYWwgZW5jb2RpbmcgZG9lc24ndCBnZXQgYnVtcGVkIHVuaW50ZW50aW9uYWxseSBieSBhbnkgb2YgdGhlIG90aGVyIGxheWVyc1xyXG4gICAgY29uc3QgbWF4RnJhbWVyYXRlID0gc291cmNlRnJhbWVyYXRlICYmIHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUgPyBNYXRoLm1pbihzb3VyY2VGcmFtZXJhdGUsIHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUpIDogcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZTtcclxuICAgIGlmIChtYXhGcmFtZXJhdGUpIHtcclxuICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gbWF4RnJhbWVyYXRlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XHJcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLnByaW9yaXR5ICYmIGNhblNldFByaW9yaXR5KSB7XHJcbiAgICAgIGVuY29kaW5nLnByaW9yaXR5ID0gcHJlc2V0LmVuY29kaW5nLnByaW9yaXR5O1xyXG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XHJcbiAgICB9XHJcbiAgICBlbmNvZGluZ3MucHVzaChlbmNvZGluZyk7XHJcbiAgfSk7XHJcbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxyXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkgJiYgZ2V0UmVhY3ROYXRpdmVPcygpID09PSAnaW9zJykge1xyXG4gICAgbGV0IHRvcEZyYW1lcmF0ZSA9IHVuZGVmaW5lZDtcclxuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcclxuICAgICAgaWYgKCF0b3BGcmFtZXJhdGUpIHtcclxuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICYmIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA+IHRvcEZyYW1lcmF0ZSkge1xyXG4gICAgICAgIHRvcEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBsZXQgbm90aWZ5T25jZSA9IHRydWU7XHJcbiAgICBlbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZyA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAhPSB0b3BGcmFtZXJhdGUpIHtcclxuICAgICAgICBpZiAobm90aWZ5T25jZSkge1xyXG4gICAgICAgICAgbm90aWZ5T25jZSA9IGZhbHNlO1xyXG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5pbmZvKFwiU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiXCIuY29uY2F0KChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIFwiXFxcIiB0byBcIikuY29uY2F0KHRvcEZyYW1lcmF0ZSkpO1xyXG4gICAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IHRvcEZyYW1lcmF0ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBlbmNvZGluZ3M7XHJcbn1cclxuLyoqIEBpbnRlcm5hbCAqL1xyXG5mdW5jdGlvbiBzb3J0UHJlc2V0cyhwcmVzZXRzKSB7XHJcbiAgaWYgKCFwcmVzZXRzKSByZXR1cm47XHJcbiAgcmV0dXJuIHByZXNldHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBlbmNvZGluZzogYUVuY1xyXG4gICAgfSA9IGE7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGVuY29kaW5nOiBiRW5jXHJcbiAgICB9ID0gYjtcclxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XHJcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID09PSBiRW5jLm1heEJpdHJhdGUgJiYgYUVuYy5tYXhGcmFtZXJhdGUgJiYgYkVuYy5tYXhGcmFtZXJhdGUpIHtcclxuICAgICAgcmV0dXJuIGFFbmMubWF4RnJhbWVyYXRlID4gYkVuYy5tYXhGcmFtZXJhdGUgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9KTtcclxufVxyXG4vKiogQGludGVybmFsICovXHJcbmNsYXNzIFNjYWxhYmlsaXR5TW9kZSB7XHJcbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlKSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xyXG4gICAgaWYgKCFyZXN1bHRzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYWJpbGl0eSBtb2RlJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnNwYXRpYWwgPSBwYXJzZUludChyZXN1bHRzWzFdKTtcclxuICAgIHRoaXMudGVtcG9yYWwgPSBwYXJzZUludChyZXN1bHRzWzJdKTtcclxuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgc3dpdGNoIChyZXN1bHRzWzNdKSB7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgY2FzZSAnX0tFWSc6XHJcbiAgICAgICAgY2FzZSAnX0tFWV9TSElGVCc6XHJcbiAgICAgICAgICB0aGlzLnN1ZmZpeCA9IHJlc3VsdHNbM107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gXCJMXCIuY29uY2F0KHRoaXMuc3BhdGlhbCwgXCJUXCIpLmNvbmNhdCh0aGlzLnRlbXBvcmFsKS5jb25jYXQoKF9hID0gdGhpcy5zdWZmaXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjaykge1xyXG4gIC8vIGEgZmV3IG9mIHJlYXNvbnMgd2UgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBwYXRoczpcclxuICAvLyAxLiB3aXRob3V0IHRoaXMsIENocm9tZSBzZWVtcyB0byBhZ2dyZXNzaXZlbHkgcmVzaXplIHRoZSBTVkMgdmlkZW8gc3RhdGluZyBgcXVhbGl0eS1saW1pdGF0aW9uOiBiYW5kd2lkdGhgIGV2ZW4gd2hlbiBCVyBpc24ndCBhbiBpc3N1ZVxyXG4gIC8vIDIuIHNpbmNlIHdlIGFyZSBvdmVycmlkaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiAodG8gd29ya2Fyb3VuZCBMMVQzIHB1Ymxpc2hpbmcpLCBpdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZGVncmFkYXRpb25QcmVmZXJlbmNlIHRvIGBiYWxhbmNlZGBcclxuICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suY29uc3RyYWludHMuaGVpZ2h0ICYmIHVud3JhcENvbnN0cmFpbnQodHJhY2suY29uc3RyYWludHMuaGVpZ2h0KSA+PSAxMDgwKSB7XHJcbiAgICByZXR1cm4gJ21haW50YWluLXJlc29sdXRpb24nO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gJ2JhbGFuY2VkJztcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjID0gNTAwMDtcclxuY2xhc3MgTG9jYWxWaWRlb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjayB7XHJcbiAgZ2V0IHNlbmRlcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9zZW5kZXI7XHJcbiAgfVxyXG4gIHNldCBzZW5kZXIoc2VuZGVyKSB7XHJcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XHJcbiAgICBpZiAodGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UpIHtcclxuICAgICAgdGhpcy5zZXREZWdyYWRhdGlvblByZWZlcmVuY2UodGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXHJcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcclxuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xyXG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gICAgbGV0IGxvZ2dlck9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuVmlkZW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSAnYmFsYW5jZWQnO1xyXG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgc3RhdHM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFNlbmRlclN0YXRzKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXAoc3RhdHMubWFwKHMgPT4gW3MucmlkLCBzXSkpO1xyXG4gICAgICBpZiAodGhpcy5wcmV2U3RhdHMpIHtcclxuICAgICAgICBsZXQgdG90YWxCaXRyYXRlID0gMDtcclxuICAgICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcclxuICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgIGNvbnN0IHByZXYgPSAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChrZXkpO1xyXG4gICAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gdG90YWxCaXRyYXRlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHNNYXA7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBfKCk7XHJcbiAgfVxyXG4gIGdldCBpc1NpbXVsY2FzdCgpIHtcclxuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xyXG4gICAgaWYgKCFpc1dlYigpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXHJcbiAgICAvLyBUT0RPIDogbWVyZ2Ugc2ltdWxjYXN0IHRyYWNrcyBzdGF0c1xyXG4gICAgY29uc3QgcGFyYW1zID0gKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICBpZiAocGFyYW1zKSB7XHJcbiAgICAgIHRoaXMuZW5jb2RpbmdzID0gcGFyYW1zLmVuY29kaW5ncztcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgdGhpcy5tb25pdG9yU2VuZGVyKCk7XHJcbiAgICB9LCBtb25pdG9yRnJlcXVlbmN5KTtcclxuICB9XHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcclxuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2godHJhY2tJbmZvID0+IHtcclxuICAgICAgdHJhY2tJbmZvLm1lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xyXG4gICAgfSk7XHJcbiAgICBzdXBlci5zdG9wKCk7XHJcbiAgfVxyXG4gIHBhdXNlVXBzdHJlYW0oKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgcGF1c2VVcHN0cmVhbToge1xyXG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIucGF1c2VVcHN0cmVhbVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XHJcbiAgICAgIHZhciBfZDtcclxuICAgICAgeWllbGQgX3N1cGVyLnBhdXNlVXBzdHJlYW0uY2FsbCh0aGlzKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIF9mID0gX19hc3luY1ZhbHVlcyh0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSksIF9nOyBfZyA9IHlpZWxkIF9mLm5leHQoKSwgX2EgPSBfZy5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xyXG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcclxuICAgICAgICAgIF9lID0gZmFsc2U7XHJcbiAgICAgICAgICBjb25zdCBzYyA9IF9jO1xyXG4gICAgICAgICAgeWllbGQgKF9kID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZVRyYWNrKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcclxuICAgICAgICBlXzEgPSB7XHJcbiAgICAgICAgICBlcnJvcjogZV8xXzFcclxuICAgICAgICB9O1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIV9lICYmICFfYSAmJiAoX2IgPSBfZi5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9mKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc3VtZVVwc3RyZWFtKCkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIHJlc3VtZVVwc3RyZWFtOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN1bWVVcHN0cmVhbVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XHJcbiAgICAgIHZhciBfZDtcclxuICAgICAgeWllbGQgX3N1cGVyLnJlc3VtZVVwc3RyZWFtLmNhbGwodGhpcyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcclxuICAgICAgICAgIF9jID0gX2cudmFsdWU7XHJcbiAgICAgICAgICBfZSA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcclxuICAgICAgICAgIHlpZWxkIChfZCA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XHJcbiAgICAgICAgZV8yID0ge1xyXG4gICAgICAgICAgZXJyb3I6IGVfMl8xXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBtdXRlKCkge1xyXG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgIG11dGU6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLm11dGVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc3RvcHBpbmcgY2FtZXJhIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXHJcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB1bmxvY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVubXV0ZSgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICB1bm11dGU6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMubXV0ZUxvY2subG9jaygpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSB1bm11dGVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgX3N1cGVyLnVubXV0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xyXG4gICAgc3VwZXIuc2V0VHJhY2tNdXRlZChtdXRlZCk7XHJcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XHJcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XHJcbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcclxuICAgICAgICAgIGNvbnN0IHZzID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxyXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcclxuICAgICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXHJcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcclxuICAgICAgICAgICAgZnJhbWVzUGVyU2Vjb25kOiB2LmZyYW1lc1BlclNlY29uZCxcclxuICAgICAgICAgICAgZnJhbWVzU2VudDogdi5mcmFtZXNTZW50LFxyXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcclxuICAgICAgICAgICAgcGxpQ291bnQ6IHYucGxpQ291bnQsXHJcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXHJcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxyXG4gICAgICAgICAgICBieXRlc1NlbnQ6IHYuYnl0ZXNTZW50LFxyXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjogdi5xdWFsaXR5TGltaXRhdGlvblJlYXNvbixcclxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM6IHYucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMsXHJcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXM6IHYucXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlcyxcclxuICAgICAgICAgICAgcmlkOiAoX2EgPSB2LnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdi5pZCxcclxuICAgICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcclxuICAgICAgICAgICAgdGFyZ2V0Qml0cmF0ZTogdi50YXJnZXRCaXRyYXRlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy/CoGxvY2F0ZSB0aGUgYXBwcm9wcmlhdGUgcmVtb3RlLWluYm91bmQtcnRwIGl0ZW1cclxuICAgICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XHJcbiAgICAgICAgICBpZiAocikge1xyXG4gICAgICAgICAgICB2cy5qaXR0ZXIgPSByLmppdHRlcjtcclxuICAgICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xyXG4gICAgICAgICAgICB2cy5yb3VuZFRyaXBUaW1lID0gci5yb3VuZFRyaXBUaW1lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXRlbXMucHVzaCh2cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgLy8gbWFrZSBzdXJlIGhpZ2hlc3QgcmVzIGxheWVyIGlzIGFsd2F5cyBmaXJzdFxyXG4gICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKChfYSA9IGIuZnJhbWVXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgLSAoKF9iID0gYS5mcmFtZVdpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXRQdWJsaXNoaW5nUXVhbGl0eShtYXhRdWFsaXR5KSB7XHJcbiAgICBjb25zdCBxdWFsaXRpZXMgPSBbXTtcclxuICAgIGZvciAobGV0IHEgPSBWaWRlb1F1YWxpdHkuTE9XOyBxIDw9IFZpZGVvUXVhbGl0eS5ISUdIOyBxICs9IDEpIHtcclxuICAgICAgcXVhbGl0aWVzLnB1c2gobmV3IFN1YnNjcmliZWRRdWFsaXR5KHtcclxuICAgICAgICBxdWFsaXR5OiBxLFxyXG4gICAgICAgIGVuYWJsZWQ6IHEgPD0gbWF4UXVhbGl0eVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSBcIi5jb25jYXQobWF4UXVhbGl0eSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoaXNTVkNDb2RlYyh0aGlzLmNvZGVjKSwgcXVhbGl0aWVzKTtcclxuICB9XHJcbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XHJcbiAgICAgIHZhciBfZDtcclxuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xyXG4gICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKHtcclxuICAgICAgICAgIHZpZGVvOiBvcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xyXG4gICAgICAgICAgX2UgPSBmYWxzZTtcclxuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XHJcbiAgICAgICAgICBpZiAoc2Muc2VuZGVyICYmICgoX2QgPSBzYy5zZW5kZXIudHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3RhdGUpICE9PSAnY2xvc2VkJykge1xyXG4gICAgICAgICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlXzNfMSkge1xyXG4gICAgICAgIGVfMyA9IHtcclxuICAgICAgICAgIGVycm9yOiBlXzNfMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0UHJvY2Vzc29yKHByb2Nlc3Nvcl8xKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgc2V0UHJvY2Vzc29yOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5zZXRQcm9jZXNzb3JcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocHJvY2Vzc29yKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBlXzQsIF9iLCBfYztcclxuICAgICAgICB2YXIgX2QsIF9lO1xyXG4gICAgICAgIHlpZWxkIF9zdXBlci5zZXRQcm9jZXNzb3IuY2FsbChfdGhpcywgcHJvY2Vzc29yLCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSk7XHJcbiAgICAgICAgaWYgKChfZCA9IF90aGlzLnByb2Nlc3NvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnByb2Nlc3NlZFRyYWNrKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIF9nID0gX19hc3luY1ZhbHVlcyhfdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfaDsgX2ggPSB5aWVsZCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcclxuICAgICAgICAgICAgICBfYyA9IF9oLnZhbHVlO1xyXG4gICAgICAgICAgICAgIF9mID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2MgPSBfYztcclxuICAgICAgICAgICAgICB5aWVsZCAoX2UgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZXBsYWNlVHJhY2soX3RoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZV80XzEpIHtcclxuICAgICAgICAgICAgZV80ID0ge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBlXzRfMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBfZy5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9nKTtcclxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZXREZWdyYWRhdGlvblByZWZlcmVuY2UocHJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xyXG4gICAgICBpZiAodGhpcy5zZW5kZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZSB0byBcIi5jb25jYXQocHJlZmVyZW5jZSksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgICBwYXJhbXMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gcHJlZmVyZW5jZTtcclxuICAgICAgICAgIHRoaXMuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwiZmFpbGVkIHRvIHNldCBkZWdyYWRhdGlvblByZWZlcmVuY2VcIiwgT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBhZGRTaW11bGNhc3RUcmFjayhjb2RlYywgZW5jb2RpbmdzKSB7XHJcbiAgICBpZiAodGhpcy5zaW11bGNhc3RDb2RlY3MuaGFzKGNvZGVjKSkge1xyXG4gICAgICB0aGlzLmxvZy5lcnJvcihcIlwiLmNvbmNhdChjb2RlYywgXCIgYWxyZWFkeSBhZGRlZCwgc2tpcHBpbmcgYWRkaW5nIHNpbXVsY2FzdCBjb2RlY1wiKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0ge1xyXG4gICAgICBjb2RlYyxcclxuICAgICAgbWVkaWFTdHJlYW1UcmFjazogdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCksXHJcbiAgICAgIHNlbmRlcjogdW5kZWZpbmVkLFxyXG4gICAgICBlbmNvZGluZ3NcclxuICAgIH07XHJcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5zZXQoY29kZWMsIHNpbXVsY2FzdENvZGVjSW5mbyk7XHJcbiAgICByZXR1cm4gc2ltdWxjYXN0Q29kZWNJbmZvO1xyXG4gIH1cclxuICBzZXRTaW11bGNhc3RUcmFja1NlbmRlcihjb2RlYywgc2VuZGVyKSB7XHJcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xyXG4gICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciA9IHNlbmRlcjtcclxuICAgIC8vIGJyb3dzZXIgd2lsbCByZWVuYWJsZSBkaXNhYmxlZCBjb2RlYy9sYXllcnMgYWZ0ZXIgbmV3IGNvZGVjIGhhcyBiZWVuIHB1Ymxpc2hlZCxcclxuICAgIC8vIHNvIHJlZnJlc2ggc3Vic2NyaWJlZENvZGVjcyBhZnRlciBwdWJsaXNoIGEgbmV3IGNvZGVjXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZENvZGVjcykge1xyXG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGluZ0NvZGVjcyh0aGlzLnN1YnNjcmliZWRDb2RlY3MpO1xyXG4gICAgICB9XHJcbiAgICB9LCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxyXG4gICAqIGJlZW4gcHVibGlzaGVkXHJcbiAgICovXHJcbiAgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3MpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgY29kZWNzXzEsIGNvZGVjc18xXzE7XHJcbiAgICAgIHZhciBfYiwgZV81LCBfYywgX2Q7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgY29kZWNzLFxyXG4gICAgICAgIGN1cnJlbnRDb2RlYzogdGhpcy5jb2RlY1xyXG4gICAgICB9KSk7XHJcbiAgICAgIC8vIG9ubHkgZW5hYmxlIHNpbXVsY2FzdCBjb2RlYyBmb3IgcHJlZmVyZW5jZSBjb2RlYyBzZXR0ZWRcclxuICAgICAgaWYgKCF0aGlzLmNvZGVjICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKGlzU1ZDQ29kZWMoY29kZWNzWzBdLmNvZGVjKSwgY29kZWNzWzBdLnF1YWxpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc3Vic2NyaWJlZENvZGVjcyA9IGNvZGVjcztcclxuICAgICAgY29uc3QgbmV3Q29kZWNzID0gW107XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChfYSA9IHRydWUsIGNvZGVjc18xID0gX19hc3luY1ZhbHVlcyhjb2RlY3MpOyBjb2RlY3NfMV8xID0geWllbGQgY29kZWNzXzEubmV4dCgpLCBfYiA9IGNvZGVjc18xXzEuZG9uZSwgIV9iOyBfYSA9IHRydWUpIHtcclxuICAgICAgICAgIF9kID0gY29kZWNzXzFfMS52YWx1ZTtcclxuICAgICAgICAgIF9hID0gZmFsc2U7XHJcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IF9kO1xyXG4gICAgICAgICAgaWYgKCF0aGlzLmNvZGVjIHx8IHRoaXMuY29kZWMgPT09IGNvZGVjLmNvZGVjKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhpc1NWQ0NvZGVjKGNvZGVjLmNvZGVjKSwgY29kZWMucXVhbGl0aWVzKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYy5jb2RlYyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8gfHwgIXNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIpIHtcclxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHEgb2YgY29kZWMucXVhbGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIG5ld0NvZGVjcy5wdXNoKGNvZGVjLmNvZGVjKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MpIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInRyeSBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIFwiLmNvbmNhdChjb2RlYy5jb2RlYyksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyLCBzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzLCBjb2RlYy5xdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jaywgaXNTVkNDb2RlYyhjb2RlYy5jb2RlYyksIHRoaXMubG9nLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlXzVfMSkge1xyXG4gICAgICAgIGVfNSA9IHtcclxuICAgICAgICAgIGVycm9yOiBlXzVfMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGlmICghX2EgJiYgIV9iICYmIChfYyA9IGNvZGVjc18xLnJldHVybikpIHlpZWxkIF9jLmNhbGwoY29kZWNzXzEpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXdDb2RlY3M7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogU2V0cyBsYXllcnMgdGhhdCBzaG91bGQgYmUgcHVibGlzaGluZ1xyXG4gICAqL1xyXG4gIHNldFB1Ymxpc2hpbmdMYXllcnMoaXNTdmMsIHF1YWxpdGllcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBsYXllcnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBxdWFsaXRpZXNcclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAoIXRoaXMuc2VuZGVyIHx8ICF0aGlzLmVuY29kaW5ncykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHRoaXMuc2VuZGVyLCB0aGlzLmVuY29kaW5ncywgcXVhbGl0aWVzLCB0aGlzLnNlbmRlckxvY2ssIGlzU3ZjLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcclxuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xyXG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCBfc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQuY2FsbCh0aGlzKTtcclxuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XHJcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XHJcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNlbmRlciwgc2VuZGVyRW5jb2RpbmdzLCBxdWFsaXRpZXMsIHNlbmRlckxvY2ssIGlzU1ZDLCBsb2csIGxvZ0NvbnRleHQpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgY29uc3QgdW5sb2NrID0geWllbGQgc2VuZGVyTG9jay5sb2NrKCk7XHJcbiAgICBsb2cuZGVidWcoJ3NldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIHNlbmRlcixcclxuICAgICAgcXVhbGl0aWVzLFxyXG4gICAgICBzZW5kZXJFbmNvZGluZ3NcclxuICAgIH0pKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBlbmNvZGluZ3NcclxuICAgICAgfSA9IHBhcmFtcztcclxuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVuY29kaW5ncy5sZW5ndGggIT09IHNlbmRlckVuY29kaW5ncy5sZW5ndGgpIHtcclxuICAgICAgICBsb2cud2FybignY2Fubm90IHNldCBwdWJsaXNoaW5nIGxheWVycywgZW5jb2RpbmdzIG1pc21hdGNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZW5jb2RpbmdzLFxyXG4gICAgICAgICAgc2VuZGVyRW5jb2RpbmdzXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xyXG4gICAgICBjb25zdCBjbG9zYWJsZVNwYXRpYWwgPSAoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnQ2hyb21lJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24sICcxMzMnKSA+IDA7XHJcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgaWYgKGNsb3NhYmxlU3BhdGlhbCAmJiBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKSB7XHJcbiAgICAgICAgLy8gc3ZjIGR5bmFjYXN0IGVuY29kaW5nc1xyXG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gZW5jb2RpbmdzWzBdO1xyXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICBjb25zdCBtb2RlID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpO1xyXG4gICAgICAgIGxldCBtYXhRdWFsaXR5ID0gVmlkZW9RdWFsaXR5JDEuT0ZGO1xyXG4gICAgICAgIHF1YWxpdGllcy5mb3JFYWNoKHEgPT4ge1xyXG4gICAgICAgICAgaWYgKHEuZW5hYmxlZCAmJiAobWF4UXVhbGl0eSA9PT0gVmlkZW9RdWFsaXR5JDEuT0ZGIHx8IHEucXVhbGl0eSA+IG1heFF1YWxpdHkpKSB7XHJcbiAgICAgICAgICAgIG1heFF1YWxpdHkgPSBxLnF1YWxpdHk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG1heFF1YWxpdHkgPT09IFZpZGVvUXVhbGl0eSQxLk9GRikge1xyXG4gICAgICAgICAgaWYgKGVuY29kaW5nLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghZW5jb2RpbmcuYWN0aXZlIHx8IG1vZGUuc3BhdGlhbCAhPT0gbWF4UXVhbGl0eSArIDEpIHtcclxuICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2VuZGVyRW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSk7XHJcbiAgICAgICAgICBtb2RlLnNwYXRpYWwgPSBtYXhRdWFsaXR5ICsgMTtcclxuICAgICAgICAgIG1vZGUuc3VmZml4ID0gb3JpZ2luYWxNb2RlLnN1ZmZpeDtcclxuICAgICAgICAgIGlmIChtb2RlLnNwYXRpYWwgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gbm8gc3VmZml4IGZvciBMMVR4XHJcbiAgICAgICAgICAgIG1vZGUuc3VmZml4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gbW9kZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gTWF0aC5wb3coMiwgMiAtIG1heFF1YWxpdHkpO1xyXG4gICAgICAgICAgaWYgKHNlbmRlckVuY29kaW5nc1swXS5tYXhCaXRyYXRlKSB7XHJcbiAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIChlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgKiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNTVkMpIHtcclxuICAgICAgICAgIGNvbnN0IGhhc0VuYWJsZWRFbmNvZGluZyA9IHF1YWxpdGllcy5zb21lKHEgPT4gcS5lbmFibGVkKTtcclxuICAgICAgICAgIGlmIChoYXNFbmFibGVkRW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgcXVhbGl0aWVzLmZvckVhY2gocSA9PiBxLmVuYWJsZWQgPSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2ltdWxjYXN0IGR5bmFjYXN0IGVuY29kaW5nc1xyXG4gICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICBsZXQgcmlkID0gKF9hID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcclxuICAgICAgICAgIGlmIChyaWQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJpZCA9ICdxJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKTtcclxuICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWFsaXR5ID0gcXVhbGl0aWVzLmZpbmQocSA9PiBxLnF1YWxpdHkgPT09IHF1YWxpdHkpO1xyXG4gICAgICAgICAgaWYgKCFzdWJzY3JpYmVkUXVhbGl0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoZW5jb2RpbmcuYWN0aXZlICE9PSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkO1xyXG4gICAgICAgICAgICBsb2cuZGVidWcoXCJzZXR0aW5nIGxheWVyIFwiLmNvbmNhdChzdWJzY3JpYmVkUXVhbGl0eS5xdWFsaXR5LCBcIiB0byBcIikuY29uY2F0KGVuY29kaW5nLmFjdGl2ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcpLCBsb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgLy8gRmlyZUZveCBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgZW5jb2RpbmcuYWN0aXZlIHRvIGZhbHNlLCBzbyB3ZVxyXG4gICAgICAgICAgICAvLyBoYXZlIGEgd29ya2Fyb3VuZCBvZiBsb3dlcmluZyBpdHMgYml0cmF0ZSBhbmQgcmVzb2x1dGlvbiB0byB0aGUgbWluLlxyXG4gICAgICAgICAgICBpZiAoaXNGaXJlRm94KCkpIHtcclxuICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gc2VuZGVyRW5jb2RpbmdzW2lkeF0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEJpdHJhdGU7XHJcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhGcmFtZVJhdGU7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDQ7XHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gMTA7XHJcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XHJcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGVuY29kaW5ncztcclxuICAgICAgICBsb2cuZGVidWcoXCJzZXR0aW5nIGVuY29kaW5nc1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBlbmNvZGluZ3M6IHBhcmFtcy5lbmNvZGluZ3NcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgeWllbGQgc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdW5sb2NrKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCkge1xyXG4gIHN3aXRjaCAocmlkKSB7XHJcbiAgICBjYXNlICdmJzpcclxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xyXG4gICAgY2FzZSAnaCc6XHJcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTUVESVVNO1xyXG4gICAgY2FzZSAncSc6XHJcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTE9XO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5ISUdIO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB2aWRlb0xheWVyc0Zyb21FbmNvZGluZ3Mod2lkdGgsIGhlaWdodCwgZW5jb2RpbmdzLCBzdmMpIHtcclxuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxyXG4gIGlmICghZW5jb2RpbmdzKSB7XHJcbiAgICByZXR1cm4gW25ldyBWaWRlb0xheWVyKHtcclxuICAgICAgcXVhbGl0eTogVmlkZW9RdWFsaXR5LkhJR0gsXHJcbiAgICAgIHdpZHRoLFxyXG4gICAgICBoZWlnaHQsXHJcbiAgICAgIGJpdHJhdGU6IDAsXHJcbiAgICAgIHNzcmM6IDBcclxuICAgIH0pXTtcclxuICB9XHJcbiAgaWYgKHN2Yykge1xyXG4gICAgLy8gc3ZjIGxheWVyc1xyXG4gICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgY29uc3QgZW5jb2RpbmdTTSA9IGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGU7XHJcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2RpbmdTTSk7XHJcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcclxuICAgIGNvbnN0IHJlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDEuNSA6IDI7XHJcbiAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcclxuICAgICAgbGF5ZXJzLnB1c2gobmV3IFZpZGVvTGF5ZXIoe1xyXG4gICAgICAgIHF1YWxpdHk6IE1hdGgubWluKFZpZGVvUXVhbGl0eS5ISUdILCBzbS5zcGF0aWFsIC0gMSkgLSBpLFxyXG4gICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBNYXRoLnBvdyhyZXNSYXRpbywgaSkpLFxyXG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIE1hdGgucG93KHJlc1JhdGlvLCBpKSksXHJcbiAgICAgICAgYml0cmF0ZTogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgPyBNYXRoLmNlaWwoZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyBNYXRoLnBvdyhiaXRyYXRlc1JhdGlvLCBpKSkgOiAwLFxyXG4gICAgICAgIHNzcmM6IDBcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxheWVycztcclxuICB9XHJcbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoZW5jb2RpbmcgPT4ge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBjb25zdCBzY2FsZSA9IChfYSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgIGxldCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKChfYiA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xyXG4gICAgcmV0dXJuIG5ldyBWaWRlb0xheWVyKHtcclxuICAgICAgcXVhbGl0eSxcclxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcclxuICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0IC8gc2NhbGUpLFxyXG4gICAgICBiaXRyYXRlOiAoX2MgPSBlbmNvZGluZy5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxyXG4gICAgICBzc3JjOiAwXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuY29uc3QgbG9zc3lEYXRhQ2hhbm5lbCA9ICdfbG9zc3knO1xyXG5jb25zdCByZWxpYWJsZURhdGFDaGFubmVsID0gJ19yZWxpYWJsZSc7XHJcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcclxuY29uc3QgbGVhdmVSZWNvbm5lY3QgPSAnbGVhdmUtcmVjb25uZWN0JztcclxuY29uc3QgcmVsaWFiZVJlY2VpdmVTdGF0ZVRUTCA9IDMwMDAwO1xyXG52YXIgUENTdGF0ZTtcclxuKGZ1bmN0aW9uIChQQ1N0YXRlKSB7XHJcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiTmV3XCJdID0gMF0gPSBcIk5ld1wiO1xyXG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IDFdID0gXCJDb25uZWN0ZWRcIjtcclxuICBQQ1N0YXRlW1BDU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSAyXSA9IFwiRGlzY29ubmVjdGVkXCI7XHJcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gM10gPSBcIlJlY29ubmVjdGluZ1wiO1xyXG4gIFBDU3RhdGVbUENTdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcclxufSkoUENTdGF0ZSB8fCAoUENTdGF0ZSA9IHt9KSk7XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuY2xhc3MgUlRDRW5naW5lIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGdldCBpc0Nsb3NlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pc0Nsb3NlZDtcclxuICB9XHJcbiAgZ2V0IHBlbmRpbmdSZWNvbm5lY3QoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLnJlY29ubmVjdFRpbWVvdXQ7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5ydGNDb25maWcgPSB7fTtcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0ID0gcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cy5wZWVyQ29ubmVjdGlvblRpbWVvdXQ7XHJcbiAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcclxuICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBmYWxzZTtcclxuICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuTmV3O1xyXG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnMgPSB7fTtcclxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xyXG4gICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IDA7XHJcbiAgICB0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcclxuICAgIC8qKiBrZWVwcyB0cmFjayBvZiBob3cgb2Z0ZW4gYW4gaW5pdGlhbCBqb2luIGNvbm5lY3Rpb24gaGFzIGJlZW4gdHJpZWQgKi9cclxuICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcclxuICAgIC8qKiBzcGVjaWZpZXMgaG93IG9mdGVuIGFuIGluaXRpYWwgam9pbiBjb25uZWN0aW9uIGlzIGFsbG93ZWQgdG8gcmV0cnkgKi9cclxuICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gMTtcclxuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcclxuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcclxuICAgIHRoaXMucmVsaWFibGVEYXRhU2VxdWVuY2UgPSAxO1xyXG4gICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIgPSBuZXcgRGF0YVBhY2tldEJ1ZmZlcigpO1xyXG4gICAgdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUgPSBuZXcgVFRMTWFwKHJlbGlhYmVSZWNlaXZlU3RhdGVUVEwpO1xyXG4gICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCA9IF9hID0+IF9fYXdhaXRlcih0aGlzLCBbX2FdLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIGxldCB7XHJcbiAgICAgICAgY2hhbm5lbFxyXG4gICAgICB9ID0gX3JlZjtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XHJcbiAgICAgICAgICBfdGhpcy5yZWxpYWJsZURDU3ViID0gY2hhbm5lbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwubGFiZWwgPT09IGxvc3N5RGF0YUNoYW5uZWwpIHtcclxuICAgICAgICAgIF90aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLmxvZy5kZWJ1ZyhcIm9uIGRhdGEgY2hhbm5lbCBcIi5jb25jYXQoY2hhbm5lbC5pZCwgXCIsIFwiKS5jb25jYXQoY2hhbm5lbC5sYWJlbCksIF90aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIGNoYW5uZWwub25tZXNzYWdlID0gX3RoaXMuaGFuZGxlRGF0YU1lc3NhZ2U7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYW5kbGVEYXRhTWVzc2FnZSA9IG1lc3NhZ2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzcGVjdCBpbmNvbWluZyBkYXRhIG1lc3NhZ2Ugb3JkZXIgYnkgcHJvY2Vzc2luZyBtZXNzYWdlIGV2ZW50cyBvbmUgYWZ0ZXIgdGhlIG90aGVyXHJcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuZGF0YVByb2Nlc3NMb2NrLmxvY2soKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBkZWNvZGVcclxuICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgYnVmZmVyID0gbWVzc2FnZS5kYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xyXG4gICAgICAgICAgYnVmZmVyID0geWllbGQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCd1bnN1cHBvcnRlZCBkYXRhIHR5cGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRwID0gRGF0YVBhY2tldC5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xyXG4gICAgICAgIGlmIChkcC5zZXF1ZW5jZSA+IDAgJiYgZHAucGFydGljaXBhbnRTaWQgIT09ICcnKSB7XHJcbiAgICAgICAgICBjb25zdCBsYXN0U2VxID0gdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUuZ2V0KGRwLnBhcnRpY2lwYW50U2lkKTtcclxuICAgICAgICAgIGlmIChsYXN0U2VxICYmIGRwLnNlcXVlbmNlIDw9IGxhc3RTZXEpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIGR1cGxpY2F0ZSBvciBvdXQtb2Ytb3JkZXIgcGFja2V0cyBpbiByZWxpYWJsZSBjaGFubmVsXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlLnNldChkcC5wYXJ0aWNpcGFudFNpZCwgZHAuc2VxdWVuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKChfYSA9IGRwLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FzZSkgPT09ICdzcGVha2VyJykge1xyXG4gICAgICAgICAgLy8gZGlzcGF0Y2ggc3BlYWtlciB1cGRhdGVzXHJcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCgoX2IgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhc2UpID09PSAndXNlcicpIHtcclxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICBhcHBseVVzZXJEYXRhQ29tcGF0KGRwLCBkcC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCBkcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHVubG9jaygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlRGF0YUVycm9yID0gZXZlbnQgPT4ge1xyXG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gJ2xvc3N5JyA6ICdyZWxpYWJsZSc7XHJcbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVycm9yRXZlbnQgJiYgZXZlbnQuZXJyb3IpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBlcnJvclxyXG4gICAgICAgIH0gPSBldmVudC5lcnJvcjtcclxuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIkRhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCwgXCI6IFwiKS5jb25jYXQoZXZlbnQubWVzc2FnZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZXJyb3JcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJVbmtub3duIERhdGFDaGFubmVsIGVycm9yIG9uIFwiLmNvbmNhdChjaGFubmVsS2luZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZXZlbnRcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gZXZlbnQgPT4ge1xyXG4gICAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldDtcclxuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gRGF0YVBhY2tldF9LaW5kLkxPU1NZIDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFO1xyXG4gICAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gd2Vic29ja2V0IHJlY29ubmVjdCBiZWhhdmlvci4gaWYgd2Vic29ja2V0IGlzIGludGVycnVwdGVkLCBhbmQgdGhlIFBlZXJDb25uZWN0aW9uXHJcbiAgICAvLyBjb250aW51ZXMgdG8gd29yaywgd2UgY2FuIHJlY29ubmVjdCB0byB3ZWJzb2NrZXQgdG8gY29udGludWUgdGhlIHNlc3Npb25cclxuICAgIC8vIGFmdGVyIGEgbnVtYmVyIG9mIHJldHJpZXMsIHdlJ2xsIGNsb3NlIGFuZCBnaXZlIHVwIHBlcm1hbmVudGx5XHJcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QgPSAoY29ubmVjdGlvbiwgZGlzY29ubmVjdFJlYXNvbikgPT4ge1xyXG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sb2cud2FybihcIlwiLmNvbmNhdChjb25uZWN0aW9uLCBcIiBkaXNjb25uZWN0ZWRcIiksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzID09PSAwKSB7XHJcbiAgICAgICAgLy8gb25seSByZXNldCBzdGFydCB0aW1lIG9uIHRoZSBmaXJzdCB0cnlcclxuICAgICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXNjb25uZWN0ID0gZHVyYXRpb24gPT4ge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChkdXJhdGlvbiwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydDtcclxuICAgICAgbGV0IGRlbGF5ID0gdGhpcy5nZXROZXh0UmV0cnlEZWxheSh7XHJcbiAgICAgICAgZWxhcHNlZE1zOiBkdXJhdGlvbixcclxuICAgICAgICByZXRyeUNvdW50OiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoZGVsYXkgPT09IG51bGwpIHtcclxuICAgICAgICBkaXNjb25uZWN0KGR1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbm5lY3Rpb24gPT09IGxlYXZlUmVjb25uZWN0KSB7XHJcbiAgICAgICAgZGVsYXkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicmVjb25uZWN0aW5nIGluIFwiLmNvbmNhdChkZWxheSwgXCJtc1wiKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcclxuICAgICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xyXG4gICAgICAgIC8vIHRva2VuIG1heSBoYXZlIGJlZW4gcmVmcmVzaGVkLCB3ZSBkbyBub3Qgd2FudCB0byByZWNyZWF0ZSB0aGUgcmVnaW9uVXJsUHJvdmlkZXJcclxuICAgICAgICAvLyBzaW5jZSB0aGUgY3VycmVudCBlbmdpbmUgbWF5IGhhdmUgaW5oZXJpdGVkIGEgcmVnaW9uYWwgdXJsXHJcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0ZW1wdFJlY29ubmVjdChkaXNjb25uZWN0UmVhc29uKS5maW5hbGx5KCgpID0+IHRoaXMucmVjb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZCksIGRlbGF5KTtcclxuICAgIH07XHJcbiAgICB0aGlzLndhaXRGb3JSZXN0YXJ0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb25SZXN0YXJ0ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIG9uRGlzY29ubmVjdGVkKTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG9uRGlzY29ubmVjdGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XHJcbiAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcclxuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzID0ga2luZCA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCk7XHJcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiBzdGF0dXMgIT09IHRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XHJcbiAgICAgICAgdGhpcy5kY0J1ZmZlclN0YXR1cy5zZXQoa2luZCwgc3RhdHVzKTtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyA9IGtpbmQgPT4ge1xyXG4gICAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xyXG4gICAgICBpZiAoZGMpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XHJcbiAgICAgICAgICB0aGlzLnJlbGlhYmxlTWVzc2FnZUJ1ZmZlci5hbGlnbkJ1ZmZlcmVkQW1vdW50KGRjLmJ1ZmZlcmVkQW1vdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRjLmJ1ZmZlcmVkQW1vdW50IDw9IGRjLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lID0gKCkgPT4ge1xyXG4gICAgICAvLyBpbiBjYXNlIHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHJlY29ubmVjdGluZywgYXR0ZW1wdCBhIHJlY29ubmVjdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYnJvd3NlciBzdGF0ZSBoYXMgY2hhbmdlZCB0byAnb25MaW5lJ1xyXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcclxuICAgICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gb3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5FbmdpbmUpO1xyXG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0ge1xyXG4gICAgICBsb2dnZXJOYW1lOiBvcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KHVuZGVmaW5lZCwgdGhpcy5sb2dnZXJPcHRpb25zKTtcclxuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcclxuICAgIHRoaXMucmVjb25uZWN0UG9saWN5ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdFBvbGljeTtcclxuICAgIHRoaXMucmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xyXG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLmRhdGFQcm9jZXNzTG9jayA9IG5ldyBfKCk7XHJcbiAgICB0aGlzLmRjQnVmZmVyU3RhdHVzID0gbmV3IE1hcChbW0RhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZV0sIFtEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWVdXSk7XHJcbiAgICB0aGlzLmNsaWVudC5vblBhcnRpY2lwYW50VXBkYXRlID0gdXBkYXRlcyA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHVwZGF0ZXMpO1xyXG4gICAgdGhpcy5jbGllbnQub25Db25uZWN0aW9uUXVhbGl0eSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XHJcbiAgICB0aGlzLmNsaWVudC5vblJvb21VcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHVwZGF0ZSk7XHJcbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmlwdGlvbkVycm9yID0gcmVzcCA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xyXG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB1cGRhdGUpO1xyXG4gICAgdGhpcy5jbGllbnQub25TcGVha2Vyc0NoYW5nZWQgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdXBkYXRlKTtcclxuICAgIHRoaXMuY2xpZW50Lm9uU3RyZWFtU3RhdGVVcGRhdGUgPSB1cGRhdGUgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdXBkYXRlKTtcclxuICAgIHRoaXMuY2xpZW50Lm9uUmVxdWVzdFJlc3BvbnNlID0gcmVzcG9uc2UgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgcmVzcG9uc2UpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvb206IChfYiA9IChfYSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5hbWUsXHJcbiAgICAgIHJvb21JRDogKF9kID0gKF9jID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb29tKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2lkLFxyXG4gICAgICBwYXJ0aWNpcGFudDogKF9mID0gKF9lID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkZW50aXR5LFxyXG4gICAgICBwSUQ6IHRoaXMucGFydGljaXBhbnRTaWRcclxuICAgIH07XHJcbiAgfVxyXG4gIGpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMudXJsID0gdXJsO1xyXG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICAgIHRoaXMuc2lnbmFsT3B0cyA9IG9wdHM7XHJcbiAgICAgIHRoaXMubWF4Sm9pbkF0dGVtcHRzID0gb3B0cy5tYXhSZXRyaWVzO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzICs9IDE7XHJcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xyXG4gICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY2xpZW50LmpvaW4odXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xyXG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2U7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyUHJpbWFyeSA9IGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeTtcclxuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmNvbmZpZ3VyZShqb2luUmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgb2ZmZXJcclxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlclByaW1hcnkgfHwgam9pblJlc3BvbnNlLmZhc3RQdWJsaXNoKSB7XHJcbiAgICAgICAgICB0aGlzLm5lZ290aWF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24gPSBqb2luUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbjtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBqb2luUmVzcG9uc2UpO1xyXG4gICAgICAgIHJldHVybiBqb2luUmVzcG9uc2U7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvcikge1xyXG4gICAgICAgICAgaWYgKGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2cud2FybihcIkNvdWxkbid0IGNvbm5lY3QgdG8gc2VydmVyLCBhdHRlbXB0IFwiLmNvbmNhdCh0aGlzLmpvaW5BdHRlbXB0cywgXCIgb2YgXCIpLmNvbmNhdCh0aGlzLm1heEpvaW5BdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmpvaW5BdHRlbXB0cyA8IHRoaXMubWF4Sm9pbkF0dGVtcHRzKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNsb3NlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5jbG9zaW5nTG9jay5sb2NrKCk7XHJcbiAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ2xvc2luZyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBjbGVhbnVwUGVlckNvbm5lY3Rpb25zKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBkY0NsZWFudXAgPSBkYyA9PiB7XHJcbiAgICAgICAgaWYgKCFkYykgcmV0dXJuO1xyXG4gICAgICAgIGRjLmNsb3NlKCk7XHJcbiAgICAgICAgZGMub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XHJcbiAgICAgICAgZGMub25jbG9zZSA9IG51bGw7XHJcbiAgICAgICAgZGMub25jbG9zaW5nID0gbnVsbDtcclxuICAgICAgICBkYy5vbmVycm9yID0gbnVsbDtcclxuICAgICAgICBkYy5vbm1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgIGRjLm9ub3BlbiA9IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICAgIGRjQ2xlYW51cCh0aGlzLmxvc3N5REMpO1xyXG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDU3ViKTtcclxuICAgICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQyk7XHJcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlRENTdWIpO1xyXG4gICAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMubG9zc3lEQ1N1YiA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5yZWxpYWJsZURDID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMucmVsaWFibGVNZXNzYWdlQnVmZmVyID0gbmV3IERhdGFQYWNrZXRCdWZmZXIoKTtcclxuICAgICAgdGhpcy5yZWxpYWJsZURhdGFTZXF1ZW5jZSA9IDE7XHJcbiAgICAgIHRoaXMucmVsaWFibGVSZWNlaXZlZFN0YXRlLmNsZWFyKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2xlYW51cENsaWVudCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIHRoaXMuY2xpZW50LmNsb3NlKCk7XHJcbiAgICAgIHRoaXMuY2xpZW50LnJlc2V0Q2FsbGJhY2tzKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYWRkVHJhY2socmVxKSB7XHJcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcclxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCdhIHRyYWNrIHdpdGggdGhlIHNhbWUgSUQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXTtcclxuICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncHVibGljYXRpb24gb2YgbG9jYWwgdHJhY2sgdGltZWQgb3V0LCBubyByZXNwb25zZSBmcm9tIHNlcnZlcicsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5UaW1lb3V0KSk7XHJcbiAgICAgIH0sIDEwMDAwKTtcclxuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0gPSB7XHJcbiAgICAgICAgcmVzb2x2ZTogaW5mbyA9PiB7XHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQocHVibGljYXRpb25UaW1lb3V0KTtcclxuICAgICAgICAgIHJlc29sdmUoaW5mbyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWplY3Q6ICgpID0+IHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChwdWJsaWNhdGlvblRpbWVvdXQpO1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2FuY2VsbGVkIHB1YmxpY2F0aW9uIGJ5IGNhbGxpbmcgdW5wdWJsaXNoJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5jbGllbnQuc2VuZEFkZFRyYWNrKHJlcSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzZW5kZXIgZnJvbSBQZWVyQ29ubmVjdGlvbiwgcmV0dXJuaW5nIHRydWUgaWYgaXQgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICogYW5kIGEgbmVnb3RpYXRpb24gaXMgbmVjZXNzYXJ5XHJcbiAgICogQHBhcmFtIHNlbmRlclxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XHJcbiAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3NlbmRlci50cmFjay5pZF0pIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHJlamVjdFxyXG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcclxuICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgIHJlamVjdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5wY01hbmFnZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byByZW1vdmUgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBlcnJvcjogZVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHVwZGF0ZU11dGVTdGF0dXModHJhY2tTaWQsIG11dGVkKSB7XHJcbiAgICB0aGlzLmNsaWVudC5zZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCk7XHJcbiAgfVxyXG4gIGdldCBkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yZWxpYWJsZURDU3ViKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZTtcclxuICB9XHJcbiAgZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgcmV0dXJuIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIHNldFJlZ2lvblVybFByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgfVxyXG4gIGNvbmZpZ3VyZShqb2luUmVzcG9uc2UpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIC8vIGFscmVhZHkgY29uZmlndXJlZFxyXG4gICAgICBpZiAodGhpcy5wY01hbmFnZXIgJiYgdGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLk5FVykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gKF9hID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkO1xyXG4gICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKGpvaW5SZXNwb25zZSk7XHJcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gbmV3IFBDVHJhbnNwb3J0TWFuYWdlcihydGNDb25maWcsIGpvaW5SZXNwb25zZS5zdWJzY3JpYmVyUHJpbWFyeSwgdGhpcy5sb2dnZXJPcHRpb25zKTtcclxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlRyYW5zcG9ydHNDcmVhdGVkLCB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIsIHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpO1xyXG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnBjTWFuYWdlci5vblB1Ymxpc2hlck9mZmVyID0gb2ZmZXIgPT4ge1xyXG4gICAgICAgIHRoaXMuY2xpZW50LnNlbmRPZmZlcihvZmZlcik7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uRGF0YUNoYW5uZWwgPSB0aGlzLmhhbmRsZURhdGFDaGFubmVsO1xyXG4gICAgICB0aGlzLnBjTWFuYWdlci5vblN0YXRlQ2hhbmdlID0gKGNvbm5lY3Rpb25TdGF0ZSwgcHVibGlzaGVyU3RhdGUsIHN1YnNjcmliZXJTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJpbWFyeSBQQyBzdGF0ZSBjaGFuZ2VkIFwiLmNvbmNhdChjb25uZWN0aW9uU3RhdGUpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIGlmIChbJ2Nsb3NlZCcsICdkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10uaW5jbHVkZXMocHVibGlzaGVyU3RhdGUpKSB7XHJcbiAgICAgICAgICAvLyByZXNldCBwdWJsaXNoZXIgY29ubmVjdGlvbiBwcm9taXNlXHJcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xyXG4gICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5OZXc7XHJcbiAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkNvbm5lY3RlZDtcclxuICAgICAgICAgIGlmIChzaG91bGRFbWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0ZWQsIGpvaW5SZXNwb25zZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEKSB7XHJcbiAgICAgICAgICAvLyBvbiBTYWZhcmksIFBlZXJDb25uZWN0aW9uIHdpbGwgc3dpdGNoIHRvICdkaXNjb25uZWN0ZWQnIGR1cmluZyByZW5lZ290aWF0aW9uXHJcbiAgICAgICAgICBpZiAodGhpcy5wY1N0YXRlID09PSBQQ1N0YXRlLkNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLkRpc2Nvbm5lY3RlZDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLCBzdWJzY3JpYmVyU3RhdGUgPT09ICdmYWlsZWQnID8gUmVjb25uZWN0UmVhc29uLlJSX1NVQlNDUklCRVJfRkFJTEVEIDogUmVjb25uZWN0UmVhc29uLlJSX1BVQkxJU0hFUl9GQUlMRUQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZXRlY3QgY2FzZXMgd2hlcmUgYm90aCBzaWduYWwgY2xpZW50IGFuZCBwZWVyIGNvbm5lY3Rpb24gYXJlIHNldmVyZWQgYW5kIGFzc3VtZSB0aGF0IHVzZXIgaGFzIGxvc3QgbmV0d29yayBjb25uZWN0aW9uXHJcbiAgICAgICAgY29uc3QgaXNTaWduYWxTZXZlcmVkID0gdGhpcy5jbGllbnQuaXNEaXNjb25uZWN0ZWQgfHwgdGhpcy5jbGllbnQuY3VycmVudFN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HO1xyXG4gICAgICAgIGNvbnN0IGlzUENTZXZlcmVkID0gW1BDVHJhbnNwb3J0U3RhdGUuRkFJTEVELCBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NJTkcsIFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0VEXS5pbmNsdWRlcyhjb25uZWN0aW9uU3RhdGUpO1xyXG4gICAgICAgIGlmIChpc1NpZ25hbFNldmVyZWQgJiYgaXNQQ1NldmVyZWQgJiYgIXRoaXMuX2lzQ2xvc2VkKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuT2ZmbGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5wY01hbmFnZXIub25UcmFjayA9IGV2ID0+IHtcclxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTWVkaWFUcmFja0FkZGVkLCBldi50cmFjaywgZXYuc3RyZWFtc1swXSwgZXYucmVjZWl2ZXIpO1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoIXN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKChfYiA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHJvdG9jb2wpKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xyXG4gICAgLy8gY29uZmlndXJlIHNpZ25hbGluZyBjbGllbnRcclxuICAgIHRoaXMuY2xpZW50Lm9uQW5zd2VyID0gc2QgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgUlRDU2RwVHlwZTogc2QudHlwZVxyXG4gICAgICB9KSk7XHJcbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XHJcbiAgICB9KTtcclxuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxyXG4gICAgdGhpcy5jbGllbnQub25Ucmlja2xlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ2dvdCBJQ0UgY2FuZGlkYXRlIGZyb20gcGVlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGNhbmRpZGF0ZSxcclxuICAgICAgICB0YXJnZXRcclxuICAgICAgfSkpO1xyXG4gICAgICB0aGlzLnBjTWFuYWdlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIC8vIHdoZW4gc2VydmVyIGNyZWF0ZXMgYW4gb2ZmZXIgZm9yIHRoZSBjbGllbnRcclxuICAgIHRoaXMuY2xpZW50Lm9uT2ZmZXIgPSBzZCA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XHJcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRBbnN3ZXIoYW5zd2VyKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcmVzID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdHJhY2tQdWJsaXNoZWRSZXNwb25zZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGNpZDogcmVzLmNpZCxcclxuICAgICAgICB0cmFjazogKF9hID0gcmVzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXSkge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKFwibWlzc2luZyB0cmFjayByZXNvbHZlciBmb3IgXCIuY29uY2F0KHJlcy5jaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGNpZDogcmVzLmNpZFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHJlc29sdmVcclxuICAgICAgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xyXG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XHJcbiAgICAgIHJlc29sdmUocmVzLnRyYWNrKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHJlc3BvbnNlID0+IHtcclxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1N1YnNjcmliZWQgPSB0cmFja1NpZCA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tTaWQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuY2xpZW50Lm9uVG9rZW5SZWZyZXNoID0gdG9rZW4gPT4ge1xyXG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25SZW1vdGVNdXRlQ2hhbmdlZCA9ICh0cmFja1NpZCwgbXV0ZWQpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlbW90ZU11dGUsIHRyYWNrU2lkLCBtdXRlZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmNsaWVudC5vblJvb21Nb3ZlZCA9IHJlcyA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgdGhpcy5wYXJ0aWNpcGFudFNpZCA9IChfYSA9IHJlcy5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZDtcclxuICAgICAgaWYgKHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2Uucm9vbSA9IHJlcy5yb29tO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Sb29tTW92ZWQsIHJlcyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcclxuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdzaWduYWwnLCBSZWNvbm5lY3RSZWFzb24uUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGllbnQub25MZWF2ZSA9IGxlYXZlID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ2NsaWVudCBsZWF2ZSByZXF1ZXN0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgcmVhc29uOiBsZWF2ZSA9PT0gbnVsbCB8fCBsZWF2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmUucmVhc29uXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKGxlYXZlLnJlZ2lvbnMgJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyByZWdpb25zJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhsZWF2ZS5yZWdpb25zKTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKGxlYXZlLmFjdGlvbikge1xyXG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5ESVNDT05ORUNUOlxyXG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvbik7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVDT05ORUNUOlxyXG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG5leHQgYXR0ZW1wdFxyXG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRVNVTUU6XHJcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcclxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIG1ha2VSVENDb25maWd1cmF0aW9uKHNlcnZlclJlc3BvbnNlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBydGNDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJ0Y0NvbmZpZyk7XHJcbiAgICBpZiAoKF9hID0gdGhpcy5zaWduYWxPcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZTJlZUVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ0UyRUUgLSBzZXR0aW5nIHVwIHRyYW5zcG9ydHMgd2l0aCBpbnNlcnRhYmxlIHN0cmVhbXMnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAvLyAgdGhpcyBtYWtlcyBzdXJlIHRoYXQgbm8gZGF0YSBpcyBzZW50IGJlZm9yZSB0aGUgdHJhbnNmb3JtcyBhcmUgcmVhZHlcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBydGNDb25maWcuZW5jb2RlZEluc2VydGFibGVTdHJlYW1zID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIHVwZGF0ZSBJQ0Ugc2VydmVycyBiZWZvcmUgY3JlYXRpbmcgUGVlckNvbm5lY3Rpb25cclxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzICYmICFydGNDb25maWcuaWNlU2VydmVycykge1xyXG4gICAgICBjb25zdCBydGNJY2VTZXJ2ZXJzID0gW107XHJcbiAgICAgIHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMuZm9yRWFjaChpY2VTZXJ2ZXIgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlciA9IHtcclxuICAgICAgICAgIHVybHM6IGljZVNlcnZlci51cmxzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKSBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XHJcbiAgICAgICAgaWYgKGljZVNlcnZlci5jcmVkZW50aWFsKSB7XHJcbiAgICAgICAgICBydGNJY2VTZXJ2ZXIuY3JlZGVudGlhbCA9IGljZVNlcnZlci5jcmVkZW50aWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBydGNJY2VTZXJ2ZXJzLnB1c2gocnRjSWNlU2VydmVyKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcclxuICAgIH1cclxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uICYmIHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24uZm9yY2VSZWxheSA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5FTkFCTEVEKSB7XHJcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xyXG4gICAgfVxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcnRjQ29uZmlnLnNkcFNlbWFudGljcyA9ICd1bmlmaWVkLXBsYW4nO1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcnRjQ29uZmlnLmNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSA9ICdnYXRoZXJfY29udGludWFsbHknO1xyXG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcclxuICB9XHJcbiAgY3JlYXRlRGF0YUNoYW5uZWxzKCkge1xyXG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBjbGVhciBvbGQgZGF0YSBjaGFubmVsIGNhbGxiYWNrcyBpZiByZWNyZWF0ZVxyXG4gICAgaWYgKHRoaXMubG9zc3lEQykge1xyXG4gICAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gbnVsbDtcclxuICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMucmVsaWFibGVEQykge1xyXG4gICAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gbnVsbDtcclxuICAgICAgdGhpcy5yZWxpYWJsZURDLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcclxuICAgIHRoaXMubG9zc3lEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxvc3N5RGF0YUNoYW5uZWwsIHtcclxuICAgICAgb3JkZXJlZDogZmFsc2UsXHJcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwXHJcbiAgICB9KTtcclxuICAgIHRoaXMucmVsaWFibGVEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKHJlbGlhYmxlRGF0YUNoYW5uZWwsIHtcclxuICAgICAgb3JkZXJlZDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvLyBhbHNvIGhhbmRsZSBtZXNzYWdlcyBvdmVyIHRoZSBwdWIgY2hhbm5lbCwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcclxuICAgIHRoaXMucmVsaWFibGVEQy5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xyXG4gICAgLy8gaGFuZGxlIGRhdGFjaGFubmVsIGVycm9yc1xyXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcclxuICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XHJcbiAgICAvLyBzZXQgdXAgZGMgYnVmZmVyIHRocmVzaG9sZCwgc2V0IHRvIDY0a0IgKG90aGVyd2lzZSAwIGJ5IGRlZmF1bHQpXHJcbiAgICB0aGlzLmxvc3N5REMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcclxuICAgIHRoaXMucmVsaWFibGVEQy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IDY1NTM1O1xyXG4gICAgLy8gaGFuZGxlIGJ1ZmZlciBhbW91bnQgbG93IGV2ZW50c1xyXG4gICAgdGhpcy5sb3NzeURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xyXG4gICAgdGhpcy5yZWxpYWJsZURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xyXG4gIH1cclxuICBjcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XHJcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybigndXNpbmcgYWRkLXRyYWNrIGZhbGxiYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICBjb25zdCBzZW5kZXIgPSB5aWVsZCB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcclxuICAgICAgICByZXR1cm4gc2VuZGVyO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdSZXF1aXJlZCB3ZWJSVEMgQVBJcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcclxuICAgICAgaWYgKHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xyXG4gICAgICBpZiAodHJhY2subWVkaWFTdHJlYW0pIHtcclxuICAgICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgdHJhY2suY29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xyXG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcclxuICAgICAgICBzdHJlYW1zXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcclxuICAgICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcclxuICAgICAgfVxyXG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXHJcbiAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0geWllbGQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2subWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcclxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xyXG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5J1xyXG4gICAgICB9O1xyXG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XHJcbiAgICAgIH1cclxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxyXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XHJcbiAgICAgIGlmICghb3B0cy52aWRlb0NvZGVjKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRyYWNrLnNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKG9wdHMudmlkZW9Db2RlYywgdHJhbnNjZWl2ZXIuc2VuZGVyKTtcclxuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVSVENSdHBTZW5kZXIodHJhY2spIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGlzIGNsb3NlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFjayh0cmFjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXR0ZW1wdFJlY29ubmVjdChyZWFzb24pIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gZ3VhcmQgZm9yIGF0dGVtcHRpbmcgcmVjb25uZWN0aW9uIG11bHRpcGxlIHRpbWVzIHdoaWxlIG9uZSBhdHRlbXB0IGlzIHN0aWxsIG5vdCBmaW5pc2hlZFxyXG4gICAgICBpZiAodGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0KSB7XHJcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhbHJlYWR5IGF0dGVtcHRpbmcgcmVjb25uZWN0LCByZXR1cm5pbmcgZWFybHknLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoKChfYSA9IHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZUNvbm5lY3Rpb24pID09PSBDbGllbnRDb25maWdTZXR0aW5nLkRJU0FCTEVEIHx8XHJcbiAgICAgIC8vIHNpZ25hbGluZyBzdGF0ZSBjb3VsZCBjaGFuZ2UgdG8gY2xvc2VkIGR1ZSB0byBoYXJkd2FyZSBzbGVlcFxyXG4gICAgICAvLyB0aG9zZSBjb25uZWN0aW9ucyBjYW5ub3QgYmUgcmVzdW1lZFxyXG4gICAgICAoKF9jID0gKF9iID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXJyZW50U3RhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcclxuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5mdWxsUmVjb25uZWN0T25OZXh0KSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdW1lQ29ubmVjdGlvbihyZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xyXG4gICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IGZhbHNlO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArPSAxO1xyXG4gICAgICAgIGxldCByZWNvdmVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5yZWNvdmVyYWJsZSBlcnJvcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgLy8gdW5yZWNvdmVyYWJsZVxyXG4gICAgICAgICAgcmVjb3ZlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xyXG4gICAgICAgICAgLy8gY2Fubm90IHJlc3VtZVxyXG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ3JlY29ubmVjdCcsIFJlY29ubmVjdFJlYXNvbi5SUl9VTktOT1dOKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5sb2cuaW5mbyhcImNvdWxkIG5vdCByZWNvdmVyIGNvbm5lY3Rpb24gYWZ0ZXIgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsIFwiIGF0dGVtcHRzLCBcIikuY29uY2F0KERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0LCBcIm1zLiBnaXZpbmcgdXBcIiksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcclxuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXROZXh0UmV0cnlEZWxheShjb250ZXh0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RQb2xpY3kubmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdlbmNvdW50ZXJlZCBlcnJvciBpbiByZWNvbm5lY3QgcG9saWN5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgZXJyb3I6IGVcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLy8gZXJyb3IgaW4gdXNlciBjb2RlIHdpdGggcHJvdmlkZWQgcmVjb25uZWN0IHBvbGljeSwgc3RvcCByZWNvbm5lY3RpbmdcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXN0YXJ0Q29ubmVjdGlvbihyZWdpb25VcmwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcclxuICAgICAgICAgIC8vIHBlcm1hbmVudCBmYWlsdXJlLCBkb24ndCBhdHRlbXB0IHJlY29ubmVjdGlvblxyXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcInJlY29ubmVjdGluZywgYXR0ZW1wdDogXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcclxuICAgICAgICBpZiAoIXRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5zZW5kTGVhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwUGVlckNvbm5lY3Rpb25zKCk7XHJcbiAgICAgICAgeWllbGQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XHJcbiAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCF0aGlzLnNpZ25hbE9wdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIGNvbm5lY3Rpb24gcmVzdGFydCwgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBwcmVzZW50JywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBpbiBjYXNlIGEgcmVnaW9uVXJsIGlzIHBhc3NlZCwgdGhlIHJlZ2lvbiBVUkwgdGFrZXMgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5qb2luKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnNpZ25hbE9wdHMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdG9rZW4gbWlnaHQgYmUgZXhwaXJlZCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XHJcbiAgICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcclxuICAgICAgICB5aWVsZCB0aGlzLndhaXRGb3JQQ1JlY29ubmVjdGVkKCk7XHJcbiAgICAgICAgLy8gcmUtY2hlY2sgc2lnbmFsIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgZW5naW5lIGFzIHJlc3VtZWRcclxuICAgICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0QXR0ZW1wdHMoKTtcclxuICAgICAgICAvLyByZWNvbm5lY3Qgc3VjY2Vzc1xyXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0ZWQpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IG5leHRSZWdpb25VcmwgPSB5aWVsZCAoX2IgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcclxuICAgICAgICBpZiAobmV4dFJlZ2lvblVybCkge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbihuZXh0UmVnaW9uVXJsKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gbm8gbW9yZSByZWdpb25zIHRvIHRyeSAob3Igd2UncmUgbm90IG9uIGNsb3VkKVxyXG4gICAgICAgICAgKF9jID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc2V0QXR0ZW1wdHMoKTtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc3VtZUNvbm5lY3Rpb24ocmVhc29uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcclxuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxyXG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3B1Ymxpc2hlciBhbmQgc3Vic2NyaWJlciBjb25uZWN0aW9ucyB1bnNldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9nLmluZm8oXCJyZXN1bWluZyBzaWduYWwgY29ubmVjdGlvbiwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWluZyk7XHJcbiAgICAgIGxldCByZXM7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xyXG4gICAgICAgIHJlcyA9IHlpZWxkIHRoaXMuY2xpZW50LnJlY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5wYXJ0aWNpcGFudFNpZCwgcmVhc29uKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKGVycm9yLm1lc3NhZ2UsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCkge1xyXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcihtZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCk7XHJcbiAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKHJlcyk7XHJcbiAgICAgICAgdGhpcy5wY01hbmFnZXIudXBkYXRlQ29uZmlndXJhdGlvbihydGNDb25maWcpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhdGVzdEpvaW5SZXNwb25zZSkge1xyXG4gICAgICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2Uuc2VydmVySW5mbyA9IHJlcy5zZXJ2ZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdEaWQgbm90IHJlY2VpdmUgcmVjb25uZWN0IHJlc3BvbnNlJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zaG91bGRGYWlsTmV4dCkge1xyXG4gICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcclxuICAgICAgeWllbGQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xyXG4gICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxyXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcclxuICAgICAgLy8gcmVjcmVhdGUgcHVibGlzaCBkYXRhY2hhbm5lbCBpZiBpdCdzIGlkIGlzIG51bGxcclxuICAgICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcclxuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlbGlhYmxlREMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nICYmIHRoaXMucmVsaWFibGVEQy5pZCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5sYXN0TWVzc2FnZVNlcSkge1xyXG4gICAgICAgIHRoaXMucmVzZW5kUmVsaWFibGVNZXNzYWdlc0ZvclJlc3VtZShyZXMubGFzdE1lc3NhZ2VTZXEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlc3VtZSBzdWNjZXNzXHJcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWVkKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24oYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuUmVjb25uZWN0aW5nO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnd2FpdGluZyBmb3IgcGVlciBjb25uZWN0aW9uIHRvIHJlY29ubmVjdCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgeWllbGQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxyXG4gICAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCB0aGlzLnBjTWFuYWdlci5lbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24odW5kZWZpbmVkLCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgYSBgZmFpbGVkYCBzdGF0ZSBoZXJlIGZvciB0aGUgUEM/XHJcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcImNvdWxkIG5vdCBlc3RhYmxpc2ggUEMgY29ubmVjdGlvbiwgXCIuY29uY2F0KGUubWVzc2FnZSksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwdWJsaXNoUnBjUmVzcG9uc2UoZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxyXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ3JwY1Jlc3BvbnNlJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjUmVzcG9uc2Uoe1xyXG4gICAgICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIHZhbHVlOiBlcnJvciA/IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiBlcnJvci50b1Byb3RvKClcclxuICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICBjYXNlOiAncGF5bG9hZCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQgIT09IG51bGwgJiYgcGF5bG9hZCAhPT0gdm9pZCAwID8gcGF5bG9hZCA6ICcnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHB1Ymxpc2hScGNBY2soZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXHJcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBjYXNlOiAncnBjQWNrJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjQWNrKHtcclxuICAgICAgICAgICAgcmVxdWVzdElkXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIHNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvIGhhdmUgYSBkYXRhIGNvbm5lY3Rpb25cclxuICAgICAgeWllbGQgdGhpcy5lbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCk7XHJcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcclxuICAgICAgICBwYWNrZXQuc2VxdWVuY2UgPSB0aGlzLnJlbGlhYmxlRGF0YVNlcXVlbmNlO1xyXG4gICAgICAgIHRoaXMucmVsaWFibGVEYXRhU2VxdWVuY2UgKz0gMTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBtc2cgPSBwYWNrZXQudG9CaW5hcnkoKTtcclxuICAgICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcclxuICAgICAgaWYgKGRjKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSkge1xyXG4gICAgICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIucHVzaCh7XHJcbiAgICAgICAgICAgIGRhdGE6IG1zZyxcclxuICAgICAgICAgICAgc2VxdWVuY2U6IHBhY2tldC5zZXF1ZW5jZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGMuc2VuZChtc2cpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGtpbmQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc2VuZFJlbGlhYmxlTWVzc2FnZXNGb3JSZXN1bWUobGFzdE1lc3NhZ2VTZXEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgaWYgKGRjKSB7XHJcbiAgICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIucG9wVG9TZXF1ZW5jZShsYXN0TWVzc2FnZVNlcSk7XHJcbiAgICAgICAgdGhpcy5yZWxpYWJsZU1lc3NhZ2VCdWZmZXIuZ2V0QWxsKCkuZm9yRWFjaChtc2cgPT4ge1xyXG4gICAgICAgICAgZGMuc2VuZChtc2cuZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICB3YWl0Rm9yQnVmZmVyU3RhdHVzTG93KGtpbmQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG9uQ2xvc2luZyA9ICgpID0+IHJlamVjdCgnRW5naW5lIGNsb3NlZCcpO1xyXG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkNsb3NpbmcpO1xyXG4gICAgICAgIHdoaWxlICghdGhpcy5kY0J1ZmZlclN0YXR1cy5nZXQoa2luZCkpIHtcclxuICAgICAgICAgIHlpZWxkIHNsZWVwKDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuQ2xvc2luZywgb25DbG9zaW5nKTtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kXzEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICBsZXQgc3Vic2NyaWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zdWJzY3JpYmVyUHJpbWFyeTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghX3RoaXMyLnBjTWFuYWdlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN1YnNjcmliZXIgPyBfdGhpczIucGNNYW5hZ2VyLnN1YnNjcmliZXIgOiBfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlcjtcclxuICAgICAgICBjb25zdCB0cmFuc3BvcnROYW1lID0gc3Vic2NyaWJlciA/ICdTdWJzY3JpYmVyJyA6ICdQdWJsaXNoZXInO1xyXG4gICAgICAgIGlmICghdHJhbnNwb3J0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFwiXCIuY29uY2F0KHRyYW5zcG9ydE5hbWUsIFwiIGNvbm5lY3Rpb24gbm90IHNldFwiKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmVlZE5lZ290aWF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVyICYmICFfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpKSB7XHJcbiAgICAgICAgICBfdGhpczIuY3JlYXRlRGF0YUNoYW5uZWxzKCk7XHJcbiAgICAgICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5lZWROZWdvdGlhdGlvbiAmJiAhc3Vic2NyaWJlciAmJiAhX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXIuaXNJQ0VDb25uZWN0ZWQgJiYgX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkgIT09ICdjaGVja2luZycpIHtcclxuICAgICAgICAgIG5lZWROZWdvdGlhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkTmVnb3RpYXRpb24pIHtcclxuICAgICAgICAgIC8vIHN0YXJ0IG5lZ290aWF0aW9uXHJcbiAgICAgICAgICBfdGhpczIubmVnb3RpYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSBfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xyXG4gICAgICAgIGlmICgodGFyZ2V0Q2hhbm5lbCA9PT0gbnVsbCB8fCB0YXJnZXRDaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRDaGFubmVsLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FpdCB1bnRpbCBJQ0UgY29ubmVjdGVkXHJcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgX3RoaXMyLnBlZXJDb25uZWN0aW9uVGltZW91dDtcclxuICAgICAgICB3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBlbmRUaW1lKSB7XHJcbiAgICAgICAgICBpZiAodHJhbnNwb3J0LmlzSUNFQ29ubmVjdGVkICYmICgoX2EgPSBfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB5aWVsZCBzbGVlcCg1MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uLCBzdGF0ZTogXCIpLmNvbmNhdCh0cmFuc3BvcnQuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcik7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSA9IHRoaXMuZW5zdXJlRGF0YVRyYW5zcG9ydENvbm5lY3RlZChraW5kLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiBAaW50ZXJuYWwgKi9cclxuICB2ZXJpZnlUcmFuc3BvcnQoKSB7XHJcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHByaW1hcnkgY29ubmVjdGlvblxyXG4gICAgaWYgKHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gZW5zdXJlIHNpZ25hbCBpcyBjb25uZWN0ZWRcclxuICAgIGlmICghdGhpcy5jbGllbnQud3MgfHwgdGhpcy5jbGllbnQud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIG5lZ290aWF0ZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIC8vIG9ic2VydmUgc2lnbmFsIHN0YXRlXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBOZWdvdGlhdGlvbkVycm9yKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wY01hbmFnZXIucmVxdWlyZVB1Ymxpc2hlcigpO1xyXG4gICAgICAgIC8vIGRvbid0IG5lZ290aWF0ZSB3aXRob3V0IGFueSB0cmFuc2NlaXZlcnMgb3IgZGF0YSBjaGFubmVsLCBpdCB3aWxsIGdlbmVyYXRlIHNkcCB3aXRob3V0IGljZSBmcmFnIHRoZW4gbmVnb3RpYXRlIGZhaWxlZFxyXG4gICAgICAgIGlmICh0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkubGVuZ3RoID09IDAgJiYgIXRoaXMubG9zc3lEQyAmJiAhdGhpcy5yZWxpYWJsZURDKSB7XHJcbiAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2VkID0gKCkgPT4ge1xyXG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZW5naW5lIGRpc2Nvbm5lY3RlZCB3aGlsZSBuZWdvdGlhdGlvbiB3YXMgb25nb2luZycsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xyXG4gICAgICAgICAgcmVqZWN0KCdjYW5ub3QgbmVnb3RpYXRlIG9uIGNsb3NlZCBlbmdpbmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xyXG4gICAgICAgIHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLCBydHBUeXBlcyA9PiB7XHJcbiAgICAgICAgICBjb25zdCBydHBNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICBydHBUeXBlcy5mb3JFYWNoKHJ0cCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gcnRwLmNvZGVjLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZpZGVvQ29kZWMoY29kZWMpKSB7XHJcbiAgICAgICAgICAgICAgcnRwTWFwLnNldChydHAucGF5bG9hZCwgY29kZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIubmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOZWdvdGlhdGlvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ25lZ290aWF0aW9uJywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xyXG4gICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWIpIHtcclxuICAgIGlmICghc3ViKSB7XHJcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3NzeURDO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQ1N1YjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1YjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdzeW5jIHN0YXRlIGNhbm5vdCBiZSBzZW50IHdpdGhvdXQgcGVlciBjb25uZWN0aW9uIHNldHVwJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJldmlvdXNBbnN3ZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldExvY2FsRGVzY3JpcHRpb24oKTtcclxuICAgIGNvbnN0IHByZXZpb3VzT2ZmZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XHJcbiAgICAvKiAxLiBhdXRvc3Vic2NyaWJlIG9uLCBzbyBzdWJzY3JpYmVkIHRyYWNrcyA9IGFsbCB0cmFja3MgLSB1bnN1YiB0cmFja3MsXHJcbiAgICAgICAgICBpbiB0aGlzIGNhc2UsIHdlIHNlbmQgdW5zdWIgdHJhY2tzLCBzbyBzZXJ2ZXIgYWRkIGFsbCB0cmFja3MgdG8gdGhpc1xyXG4gICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxyXG4gICAgICAgMi4gYXV0b3N1YnNjcmliZSBvZmYsIHdlIHNlbmQgc3Vic2NyaWJlZCB0cmFja3MuXHJcbiAgICAqL1xyXG4gICAgY29uc3QgYXV0b1N1YnNjcmliZSA9IChfYiA9IChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XHJcbiAgICBjb25zdCB0cmFja1NpZHMgPSBuZXcgQXJyYXkoKTtcclxuICAgIGNvbnN0IHRyYWNrU2lkc0Rpc2FibGVkID0gbmV3IEFycmF5KCk7XHJcbiAgICByZW1vdGVUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgIGlmICh0cmFjay5pc0Rlc2lyZWQgIT09IGF1dG9TdWJzY3JpYmUpIHtcclxuICAgICAgICB0cmFja1NpZHMucHVzaCh0cmFjay50cmFja1NpZCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0cmFjay5pc0VuYWJsZWQpIHtcclxuICAgICAgICB0cmFja1NpZHNEaXNhYmxlZC5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmNsaWVudC5zZW5kU3luY1N0YXRlKG5ldyBTeW5jU3RhdGUoe1xyXG4gICAgICBhbnN3ZXI6IHByZXZpb3VzQW5zd2VyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XHJcbiAgICAgICAgc2RwOiBwcmV2aW91c0Fuc3dlci5zZHAsXHJcbiAgICAgICAgdHlwZTogcHJldmlvdXNBbnN3ZXIudHlwZVxyXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcclxuICAgICAgb2ZmZXI6IHByZXZpb3VzT2ZmZXIgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcclxuICAgICAgICBzZHA6IHByZXZpb3VzT2ZmZXIuc2RwLFxyXG4gICAgICAgIHR5cGU6IHByZXZpb3VzT2ZmZXIudHlwZVxyXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcclxuICAgICAgc3Vic2NyaXB0aW9uOiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcclxuICAgICAgICB0cmFja1NpZHMsXHJcbiAgICAgICAgc3Vic2NyaWJlOiAhYXV0b1N1YnNjcmliZSxcclxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrczogW11cclxuICAgICAgfSksXHJcbiAgICAgIHB1Ymxpc2hUcmFja3M6IGdldFRyYWNrUHVibGljYXRpb25JbmZvKGxvY2FsVHJhY2tzKSxcclxuICAgICAgZGF0YUNoYW5uZWxzOiB0aGlzLmRhdGFDaGFubmVsc0luZm8oKSxcclxuICAgICAgdHJhY2tTaWRzRGlzYWJsZWQsXHJcbiAgICAgIGRhdGFjaGFubmVsUmVjZWl2ZVN0YXRlczogdGhpcy5yZWxpYWJsZVJlY2VpdmVkU3RhdGUubWFwKChzZXEsIHNpZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUNoYW5uZWxSZWNlaXZlU3RhdGUoe1xyXG4gICAgICAgICAgcHVibGlzaGVyU2lkOiBzaWQsXHJcbiAgICAgICAgICBsYXN0U2VxOiBzZXFcclxuICAgICAgICB9KTtcclxuICAgICAgfSlcclxuICAgIH0pKTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgZmFpbE5leHQoKSB7XHJcbiAgICAvLyBkZWJ1Z2dpbmcgbWV0aG9kIHRvIGZhaWwgdGhlIG5leHQgcmVjb25uZWN0L3Jlc3VtZSBhdHRlbXB0XHJcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gdHJ1ZTtcclxuICB9XHJcbiAgZGF0YUNoYW5uZWxzSW5mbygpIHtcclxuICAgIGNvbnN0IGluZm9zID0gW107XHJcbiAgICBjb25zdCBnZXRJbmZvID0gKGRjLCB0YXJnZXQpID0+IHtcclxuICAgICAgaWYgKChkYyA9PT0gbnVsbCB8fCBkYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGMuaWQpICE9PSB1bmRlZmluZWQgJiYgZGMuaWQgIT09IG51bGwpIHtcclxuICAgICAgICBpbmZvcy5wdXNoKG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xyXG4gICAgICAgICAgbGFiZWw6IGRjLmxhYmVsLFxyXG4gICAgICAgICAgaWQ6IGRjLmlkLFxyXG4gICAgICAgICAgdGFyZ2V0XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1kpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcclxuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XHJcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcclxuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlKSwgU2lnbmFsVGFyZ2V0LlNVQlNDUklCRVIpO1xyXG4gICAgcmV0dXJuIGluZm9zO1xyXG4gIH1cclxuICBjbGVhclJlY29ubmVjdFRpbWVvdXQoKSB7XHJcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XHJcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XHJcbiAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZW91dCgpO1xyXG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XHJcbiAgfVxyXG4gIHJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKSB7XHJcbiAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcclxuICAgIH1cclxuICB9XHJcbiAgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xyXG4gICAgaWYgKGlzV2ViKCkpIHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cclxuZnVuY3Rpb24gc3VwcG9ydE9wdGlvbmFsRGF0YWNoYW5uZWwocHJvdG9jb2wpIHtcclxuICByZXR1cm4gcHJvdG9jb2wgIT09IHVuZGVmaW5lZCAmJiBwcm90b2NvbCA+IDEzO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VXNlckRhdGFDb21wYXQobmV3T2JqLCBvbGRPYmopIHtcclxuICBjb25zdCBwYXJ0aWNpcGFudElkZW50aXR5ID0gbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPyBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA6IG9sZE9iai5wYXJ0aWNpcGFudElkZW50aXR5O1xyXG4gIG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcclxuICBvbGRPYmoucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XHJcbiAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gbmV3T2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcy5sZW5ndGggIT09IDAgPyBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzIDogb2xkT2JqLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcclxuICBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xyXG4gIG9sZE9iai5kZXN0aW5hdGlvbklkZW50aXRpZXMgPSBkZXN0aW5hdGlvbklkZW50aXRpZXM7XHJcbn1cclxuXHJcbmNsYXNzIFJlZ2lvblVybFByb3ZpZGVyIHtcclxuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XHJcbiAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IDA7XHJcbiAgICB0aGlzLnNldHRpbmdzQ2FjaGVUaW1lID0gMzAwMDtcclxuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xyXG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XHJcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgfVxyXG4gIHVwZGF0ZVRva2VuKHRva2VuKSB7XHJcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgfVxyXG4gIGlzQ2xvdWQoKSB7XHJcbiAgICByZXR1cm4gaXNDbG91ZCh0aGlzLnNlcnZlclVybCk7XHJcbiAgfVxyXG4gIGdldFNlcnZlclVybCgpIHtcclxuICAgIHJldHVybiB0aGlzLnNlcnZlclVybDtcclxuICB9XHJcbiAgZ2V0TmV4dEJlc3RSZWdpb25VcmwoYWJvcnRTaWduYWwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0Nsb3VkKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF0aGlzLnJlZ2lvblNldHRpbmdzIHx8IERhdGUubm93KCkgLSB0aGlzLmxhc3RVcGRhdGVBdCA+IHRoaXMuc2V0dGluZ3NDYWNoZVRpbWUpIHtcclxuICAgICAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0geWllbGQgdGhpcy5mZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZWdpb25zTGVmdCA9IHRoaXMucmVnaW9uU2V0dGluZ3MucmVnaW9ucy5maWx0ZXIocmVnaW9uID0+ICF0aGlzLmF0dGVtcHRlZFJlZ2lvbnMuZmluZChhdHRlbXB0ZWQgPT4gYXR0ZW1wdGVkLnVybCA9PT0gcmVnaW9uLnVybCkpO1xyXG4gICAgICBpZiAocmVnaW9uc0xlZnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IG5leHRSZWdpb24gPSByZWdpb25zTGVmdFswXTtcclxuICAgICAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMucHVzaChuZXh0UmVnaW9uKTtcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwibmV4dCByZWdpb246IFwiLmNvbmNhdChuZXh0UmVnaW9uLnJlZ2lvbikpO1xyXG4gICAgICAgIHJldHVybiBuZXh0UmVnaW9uLnVybDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJlc2V0QXR0ZW1wdHMoKSB7XHJcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgZmV0Y2hSZWdpb25TZXR0aW5ncyhzaWduYWwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzUmVzcG9uc2UgPSB5aWVsZCBmZXRjaChcIlwiLmNvbmNhdChnZXRDbG91ZENvbmZpZ1VybCh0aGlzLnNlcnZlclVybCksIFwiL3JlZ2lvbnNcIiksIHtcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodGhpcy50b2tlbilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpZ25hbFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IHlpZWxkIHJlZ2lvblNldHRpbmdzUmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUF0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICByZXR1cm4gcmVnaW9uU2V0dGluZ3M7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3M6IFwiLmNvbmNhdChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHQpLCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyA9PT0gNDAxID8gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgOiBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0U2VydmVyUmVwb3J0ZWRSZWdpb25zKHJlZ2lvbnMpIHtcclxuICAgIHRoaXMucmVnaW9uU2V0dGluZ3MgPSByZWdpb25zO1xyXG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSBEYXRlLm5vdygpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpIHtcclxuICByZXR1cm4gXCJcIi5jb25jYXQoc2VydmVyVXJsLnByb3RvY29sLnJlcGxhY2UoJ3dzJywgJ2h0dHAnKSwgXCIvL1wiKS5jb25jYXQoc2VydmVyVXJsLmhvc3QsIFwiL3NldHRpbmdzXCIpO1xyXG59XHJcblxyXG5jbGFzcyBCYXNlU3RyZWFtUmVhZGVyIHtcclxuICBnZXQgaW5mbygpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbmZvO1xyXG4gIH1cclxuICBjb25zdHJ1Y3RvcihpbmZvLCBzdHJlYW0sIHRvdGFsQnl0ZVNpemUpIHtcclxuICAgIHRoaXMucmVhZGVyID0gc3RyZWFtO1xyXG4gICAgdGhpcy50b3RhbEJ5dGVTaXplID0gdG90YWxCeXRlU2l6ZTtcclxuICAgIHRoaXMuX2luZm8gPSBpbmZvO1xyXG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICB9XHJcbn1cclxuY2xhc3MgQnl0ZVN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xyXG4gIGhhbmRsZUNodW5rUmVjZWl2ZWQoY2h1bmspIHtcclxuICAgIHZhciBfYTtcclxuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XHJcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemUgPyB0aGlzLmJ5dGVzUmVjZWl2ZWQgLyB0aGlzLnRvdGFsQnl0ZVNpemUgOiB1bmRlZmluZWQ7XHJcbiAgICAoX2EgPSB0aGlzLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGN1cnJlbnRQcm9ncmVzcyk7XHJcbiAgfVxyXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XHJcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnJlYWRlci5nZXRSZWFkZXIoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5leHQ6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICBkb25lLFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgfSA9IHlpZWxkIHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaHVua1JlY2VpdmVkKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuY29udGVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvcnNcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSxcclxuICAgICAgcmV0dXJuKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIHJlYWRBbGwoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xyXG4gICAgICBsZXQgY2h1bmtzID0gbmV3IFNldCgpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSBfX2FzeW5jVmFsdWVzKHRoaXMpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcclxuICAgICAgICAgIF9jID0gX2YudmFsdWU7XHJcbiAgICAgICAgICBfZCA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcclxuICAgICAgICAgIGNodW5rcy5hZGQoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcclxuICAgICAgICBlXzEgPSB7XHJcbiAgICAgICAgICBlcnJvcjogZV8xXzFcclxuICAgICAgICB9O1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9lKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjaHVua3MpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRvIHJlYWQgY2h1bmtzIGZyb20gYSBSZWFkYWJsZVN0cmVhbSBhbmQgcHJvdmlkZSB0aGVtIGluIGEgc3RydWN0dXJlZCBmb3JtYXQuXHJcbiAqL1xyXG5jbGFzcyBUZXh0U3RyZWFtUmVhZGVyIGV4dGVuZHMgQmFzZVN0cmVhbVJlYWRlciB7XHJcbiAgLyoqXHJcbiAgICogQSBUZXh0U3RyZWFtUmVhZGVyIGluc3RhbmNlIGNhbiBiZSB1c2VkIGFzIGFuIEFzeW5jSXRlcmF0b3IgdGhhdCByZXR1cm5zIHRoZSBlbnRpcmUgc3RyaW5nXHJcbiAgICogdGhhdCBoYXMgYmVlbiByZWNlaXZlZCB1cCB0byB0aGUgY3VycmVudCBwb2ludCBpbiB0aW1lLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGluZm8sIHN0cmVhbSwgdG90YWxDaHVua0NvdW50KSB7XHJcbiAgICBzdXBlcihpbmZvLCBzdHJlYW0sIHRvdGFsQ2h1bmtDb3VudCk7XHJcbiAgICB0aGlzLnJlY2VpdmVkQ2h1bmtzID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuICBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBpbmRleCA9IGJpZ0ludFRvTnVtYmVyKGNodW5rLmNodW5rSW5kZXgpO1xyXG4gICAgY29uc3QgcHJldmlvdXNDaHVua0F0SW5kZXggPSB0aGlzLnJlY2VpdmVkQ2h1bmtzLmdldChpbmRleCk7XHJcbiAgICBpZiAocHJldmlvdXNDaHVua0F0SW5kZXggJiYgcHJldmlvdXNDaHVua0F0SW5kZXgudmVyc2lvbiA+IGNodW5rLnZlcnNpb24pIHtcclxuICAgICAgLy8gd2UgaGF2ZSBhIG5ld2VyIHZlcnNpb24gYWxyZWFkeSwgZHJvcHBpbmcgdGhlIG9sZCBvbmVcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZWNlaXZlZENodW5rcy5zZXQoaW5kZXgsIGNodW5rKTtcclxuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XHJcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemUgPyB0aGlzLmJ5dGVzUmVjZWl2ZWQgLyB0aGlzLnRvdGFsQnl0ZVNpemUgOiB1bmRlZmluZWQ7XHJcbiAgICAoX2EgPSB0aGlzLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGN1cnJlbnRQcm9ncmVzcyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFzeW5jIGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIHRvIGFsbG93IHVzYWdlIG9mIGBmb3IgYXdhaXQuLi5vZmAgc3ludGF4LlxyXG4gICAqIFlpZWxkcyBzdHJ1Y3R1cmVkIGNodW5rcyBmcm9tIHRoZSBzdHJlYW0uXHJcbiAgICpcclxuICAgKi9cclxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xyXG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgZG9uZSxcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IGRlY29kZXIuZGVjb2RlKHZhbHVlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yc1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgICByZXR1cm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbiAgcmVhZEFsbCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XHJcbiAgICAgIGxldCBmaW5hbFN0cmluZyA9ICcnO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgX2UgPSBfX2FzeW5jVmFsdWVzKHRoaXMpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcclxuICAgICAgICAgIF9jID0gX2YudmFsdWU7XHJcbiAgICAgICAgICBfZCA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcclxuICAgICAgICAgIGZpbmFsU3RyaW5nICs9IGNodW5rO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZV8yXzEpIHtcclxuICAgICAgICBlXzIgPSB7XHJcbiAgICAgICAgICBlcnJvcjogZV8yXzFcclxuICAgICAgICB9O1xyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKF9lKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmluYWxTdHJpbmc7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEJhc2VTdHJlYW1Xcml0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKHdyaXRhYmxlU3RyZWFtLCBpbmZvLCBvbkNsb3NlKSB7XHJcbiAgICB0aGlzLndyaXRhYmxlU3RyZWFtID0gd3JpdGFibGVTdHJlYW07XHJcbiAgICB0aGlzLmRlZmF1bHRXcml0ZXIgPSB3cml0YWJsZVN0cmVhbS5nZXRXcml0ZXIoKTtcclxuICAgIHRoaXMub25DbG9zZSA9IG9uQ2xvc2U7XHJcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gIH1cclxuICB3cml0ZShjaHVuaykge1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFdyaXRlci53cml0ZShjaHVuayk7XHJcbiAgfVxyXG4gIGNsb3NlKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB5aWVsZCB0aGlzLmRlZmF1bHRXcml0ZXIuY2xvc2UoKTtcclxuICAgICAgdGhpcy5kZWZhdWx0V3JpdGVyLnJlbGVhc2VMb2NrKCk7XHJcbiAgICAgIChfYSA9IHRoaXMub25DbG9zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuY2xhc3MgVGV4dFN0cmVhbVdyaXRlciBleHRlbmRzIEJhc2VTdHJlYW1Xcml0ZXIge31cclxuY2xhc3MgQnl0ZVN0cmVhbVdyaXRlciBleHRlbmRzIEJhc2VTdHJlYW1Xcml0ZXIge31cclxuXHJcbmNsYXNzIFJlbW90ZVRyYWNrIGV4dGVuZHMgVHJhY2sge1xyXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIHNpZCwga2luZCwgcmVjZWl2ZXIsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy5zaWQgPSBzaWQ7XHJcbiAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XHJcbiAgfVxyXG4gIGdldCBpc0xvY2FsKCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0TXV0ZWQobXV0ZWQpIHtcclxuICAgIGlmICh0aGlzLmlzTXV0ZWQgIT09IG11dGVkKSB7XHJcbiAgICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xyXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XHJcbiAgICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0TWVkaWFTdHJlYW0oc3RyZWFtKSB7XHJcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhY2sgaXMgZmluaXNoZWRcclxuICAgIHRoaXMubWVkaWFTdHJlYW0gPSBzdHJlYW07XHJcbiAgICBjb25zdCBvblJlbW92ZVRyYWNrID0gZXZlbnQgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQudHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcclxuICAgICAgICBzdHJlYW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcclxuICAgICAgICBpZiAodGhpcy5yZWNlaXZlciAmJiAncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xyXG4gICAgICAgICAgdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcclxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcclxuICB9XHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLnN0YXJ0TW9uaXRvcigpO1xyXG4gICAgLy8gdXNlIGBlbmFibGVkYCBvZiB0cmFjayB0byBlbmFibGUgcmUtdXNlIG9mIHRyYW5zY2VpdmVyXHJcbiAgICBzdXBlci5lbmFibGUoKTtcclxuICB9XHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuc3RvcE1vbml0b3IoKTtcclxuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxyXG4gICAgc3VwZXIuZGlzYWJsZSgpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxyXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDU3RhdHNSZXBvcnRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICghKChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XHJcbiAgICAgIHJldHVybiBzdGF0c1JlcG9ydDtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBBbGxvd3MgdG8gc2V0IGEgcGxheW91dCBkZWxheSAoaW4gc2Vjb25kcykgZm9yIHRoaXMgdHJhY2suXHJcbiAgICogQSBoaWdoZXIgdmFsdWUgYWxsb3dzIGZvciBtb3JlIGJ1ZmZlcmluZyBvZiB0aGUgdHJhY2sgaW4gdGhlIGJyb3dzZXJcclxuICAgKiBhbmQgd2lsbCByZXN1bHQgaW4gYSBkZWxheSBvZiBtZWRpYSBiZWluZyBwbGF5ZWQgYmFjayBvZiBgZGVsYXlJblNlY29uZHNgXHJcbiAgICovXHJcbiAgc2V0UGxheW91dERlbGF5KGRlbGF5SW5TZWNvbmRzKSB7XHJcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xyXG4gICAgICBpZiAoJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQgPSBkZWxheUluU2Vjb25kcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBzZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIG9mIHRoaXMgdHJhY2suXHJcbiAgICovXHJcbiAgZ2V0UGxheW91dERlbGF5KCkge1xyXG4gICAgaWYgKHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBnZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIC8qIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXJ0TW9uaXRvcigpIHtcclxuICAgIGlmICghdGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcclxuICAgICAgdGhpcy5tb25pdG9ySW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm1vbml0b3JSZWNlaXZlcigpLCBtb25pdG9yRnJlcXVlbmN5KTtcclxuICAgIH1cclxuICAgIGlmIChzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSkge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmVnaXN0ZXJUaW1lU3luY1VwZGF0ZSgpIHtcclxuICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgdGhpcy50aW1lU3luY0hhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBsb29wKCkpO1xyXG4gICAgICBjb25zdCBzb3VyY2VzID0gKF9hID0gdGhpcy5yZWNlaXZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN5bmNocm9uaXphdGlvblNvdXJjZXMoKVswXTtcclxuICAgICAgaWYgKHNvdXJjZXMpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgICBydHBUaW1lc3RhbXBcclxuICAgICAgICB9ID0gc291cmNlcztcclxuICAgICAgICBpZiAocnRwVGltZXN0YW1wICYmIHRoaXMucnRwVGltZXN0YW1wICE9PSBydHBUaW1lc3RhbXApIHtcclxuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlRpbWVTeW5jVXBkYXRlLCB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcclxuICAgICAgICAgICAgcnRwVGltZXN0YW1wXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHRoaXMucnRwVGltZXN0YW1wID0gcnRwVGltZXN0YW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGxvb3AoKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFJlbW90ZUF1ZGlvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjayB7XHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYXVkaW9Db250ZXh0LCBhdWRpb091dHB1dCwgbG9nZ2VyT3B0aW9ucykge1xyXG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLm1vbml0b3JSZWNlaXZlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnJlY2VpdmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xyXG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMgJiYgdGhpcy5yZWNlaXZlcikge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gY29tcHV0ZUJpdHJhdGUoc3RhdHMsIHRoaXMucHJldlN0YXRzKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcclxuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IFtdO1xyXG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XHJcbiAgICAgIHRoaXMuc2lua0lkID0gYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHNldHMgdGhlIHZvbHVtZSBmb3IgYWxsIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzXHJcbiAgICovXHJcbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcclxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgKF9hID0gdGhpcy5nYWluTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZvbHVtZSwgMCwgMC4xKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLl9zZXRWb2x1bWUodm9sdW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudFZvbHVtZSA9IHZvbHVtZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9mIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzIChsb3VkZXN0KVxyXG4gICAqL1xyXG4gIGdldFZvbHVtZSgpIHtcclxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcclxuICAgIH1cclxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxyXG4gICAgICByZXR1cm4gMS4wO1xyXG4gICAgfVxyXG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xyXG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgIGlmIChlbGVtZW50LnZvbHVtZSA+IGhpZ2hlc3RWb2x1bWUpIHtcclxuICAgICAgICBoaWdoZXN0Vm9sdW1lID0gZWxlbWVudC52b2x1bWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGhpZ2hlc3RWb2x1bWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGNhbGxzIHNldFNpbmtJZCBvbiBhbGwgYXR0YWNoZWQgZWxlbWVudHMsIGlmIHN1cHBvcnRlZFxyXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBhdWRpbyBvdXRwdXQgZGV2aWNlXHJcbiAgICovXHJcbiAgc2V0U2lua0lkKGRldmljZUlkKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLnNpbmtJZCA9IGRldmljZUlkO1xyXG4gICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLmF0dGFjaGVkRWxlbWVudHMubWFwKGVsbSA9PiB7XHJcbiAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZChlbG0pKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cclxuICAgICAgICByZXR1cm4gZWxtLnNldFNpbmtJZChkZXZpY2VJZCk7XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBhdHRhY2goZWxlbWVudCkge1xyXG4gICAgY29uc3QgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24gPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwO1xyXG4gICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnNpbmtJZCAmJiBzdXBwb3J0c1NldFNpbmtJZChlbGVtZW50KSkge1xyXG4gICAgICBlbGVtZW50LnNldFNpbmtJZCh0aGlzLnNpbmtJZCkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ0ZhaWxlZCB0byBzZXQgc2luayBpZCBvbiByZW1vdGUgYXVkaW8gdHJhY2snLCBlLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbikge1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIGVsZW1lbnQpO1xyXG4gICAgICBlbGVtZW50LnZvbHVtZSA9IDA7XHJcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgdm9sdW1lIHNldHRpbmcgaXMgYmVpbmcgYXBwbGllZCB0byB0aGUgbmV3bHkgYXR0YWNoZWQgZWxlbWVudFxyXG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG4gIGRldGFjaChlbGVtZW50KSB7XHJcbiAgICBsZXQgZGV0YWNoZWQ7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgZGV0YWNoZWQgPSBzdXBlci5kZXRhY2goKTtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKGVsZW1lbnQpO1xyXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgYW55IGF0dGFjaGVkIGVsZW1lbnRzIGFmdGVyIGRldGFjaGluZywgY29ubmVjdCB3ZWJhdWRpbyB0byB0aGUgZmlyc3QgZWxlbWVudCB0aGF0J3MgbGVmdFxyXG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxyXG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRldGFjaGVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICovXHJcbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XHJcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKGF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcclxuICAgIH0gZWxzZSBpZiAoIWF1ZGlvQ29udGV4dCkge1xyXG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAZXhwZXJpbWVudGFsXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGVbXX0gbm9kZXMgLSBBbiBhcnJheSBvZiBXZWJBdWRpbyBub2Rlcy4gVGhlc2Ugbm9kZXMgc2hvdWxkIG5vdCBiZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciB3aGVuIHBhc3NlZCwgYXMgdGhlIHNkayB3aWxsIHRha2UgY2FyZSBvZiBjb25uZWN0aW5nIHRoZW0gaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheS5cclxuICAgKi9cclxuICBzZXRXZWJBdWRpb1BsdWdpbnMobm9kZXMpIHtcclxuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xyXG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwICYmIHRoaXMuYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25uZWN0V2ViQXVkaW8oY29udGV4dCwgZWxlbWVudCkge1xyXG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcclxuICAgIC8vIEB0cy1pZ25vcmUgYXR0YWNoZWQgZWxlbWVudHMgYWx3YXlzIGhhdmUgYSBzcmNPYmplY3Qgc2V0XHJcbiAgICB0aGlzLnNvdXJjZU5vZGUgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKGVsZW1lbnQuc3JjT2JqZWN0KTtcclxuICAgIGxldCBsYXN0Tm9kZSA9IHRoaXMuc291cmNlTm9kZTtcclxuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICBsYXN0Tm9kZS5jb25uZWN0KG5vZGUpO1xyXG4gICAgICBsYXN0Tm9kZSA9IG5vZGU7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgIGxhc3ROb2RlLmNvbm5lY3QodGhpcy5nYWluTm9kZSk7XHJcbiAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XHJcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xyXG4gICAgfVxyXG4gICAgLy8gdHJ5IHRvIHJlc3VtZSB0aGUgY29udGV4dCBpZiBpdCBpc24ndCBydW5uaW5nIGFscmVhZHlcclxuICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcclxuICAgICAgY29udGV4dC5yZXN1bWUoKS50aGVuKCgpID0+IHtcclxuICAgICAgICBpZiAoY29udGV4dC5zdGF0ZSAhPT0gJ3J1bm5pbmcnKSB7XHJcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KS5jYXRjaChlID0+IHtcclxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRpc2Nvbm5lY3RXZWJBdWRpbygpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICAoX2EgPSB0aGlzLmdhaW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xyXG4gICAgKF9iID0gdGhpcy5zb3VyY2VOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xyXG4gICAgdGhpcy5nYWluTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuc291cmNlTm9kZSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XHJcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xyXG4gICAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcclxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXHJcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcclxuICAgICAgICAgICAgY29uY2VhbGVkU2FtcGxlczogdi5jb25jZWFsZWRTYW1wbGVzLFxyXG4gICAgICAgICAgICBjb25jZWFsbWVudEV2ZW50czogdi5jb25jZWFsbWVudEV2ZW50cyxcclxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbGVkU2FtcGxlczogdi5zaWxlbnRDb25jZWFsZWRTYW1wbGVzLFxyXG4gICAgICAgICAgICBzaWxlbnRDb25jZWFsbWVudEV2ZW50czogdi5zaWxlbnRDb25jZWFsbWVudEV2ZW50cyxcclxuICAgICAgICAgICAgdG90YWxBdWRpb0VuZXJneTogdi50b3RhbEF1ZGlvRW5lcmd5LFxyXG4gICAgICAgICAgICB0b3RhbFNhbXBsZXNEdXJhdGlvbjogdi50b3RhbFNhbXBsZXNEdXJhdGlvblxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgUkVBQ1RJT05fREVMQVkgPSAxMDA7XHJcbmNsYXNzIFJlbW90ZVZpZGVvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjayB7XHJcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncywgbG9nZ2VyT3B0aW9ucykge1xyXG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLlZpZGVvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XHJcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xyXG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcclxuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcclxuICAgIH0pO1xyXG4gICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUgPSByKCgpID0+IHtcclxuICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICB9LCBSRUFDVElPTl9ERUxBWSk7XHJcbiAgICB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzO1xyXG4gIH1cclxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcclxuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgIT09IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogTm90ZTogV2hlbiB1c2luZyBhZGFwdGl2ZVN0cmVhbSwgeW91IG5lZWQgdG8gdXNlIHJlbW90ZVZpZGVvVHJhY2suYXR0YWNoKCkgdG8gYWRkIHRoZSB0cmFjayB0byBhIEhUTUxWaWRlb0VsZW1lbnQsIG90aGVyd2lzZSB5b3VyIHZpZGVvIHRyYWNrcyBtaWdodCBuZXZlciBzdGFydFxyXG4gICAqL1xyXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRNdXRlZChtdXRlZCkge1xyXG4gICAgc3VwZXIuc2V0TXV0ZWQobXV0ZWQpO1xyXG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgIC8vIGRldGFjaCBvciBhdHRhY2hcclxuICAgICAgaWYgKG11dGVkKSB7XHJcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXR0YWNoKGVsZW1lbnQpIHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICAvLyBJdCdzIHBvc3NpYmxlIGF0dGFjaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gYW4gZWxlbWVudC4gV2hlbiB0aGF0J3NcclxuICAgIC8vIHRoZSBjYXNlLCB3ZSdkIHdhbnQgdG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZSBlbGVtZW50SW5mb3NcclxuICAgIGlmICh0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgJiYgdGhpcy5lbGVtZW50SW5mb3MuZmluZChpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlbGVtZW50SW5mbyA9IG5ldyBIVE1MRWxlbWVudEluZm8oZWxlbWVudCk7XHJcbiAgICAgIHRoaXMub2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuICAvKipcclxuICAgKiBPYnNlcnZlIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzIHdoZW4gYWRhcHRpdmUgc3RyZWFtaW5nLlxyXG4gICAqIEBwYXJhbSBlbGVtZW50SW5mb1xyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIG9ic2VydmVFbGVtZW50SW5mbyhlbGVtZW50SW5mbykge1xyXG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgZWxlbWVudEluZm8uaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5wdXNoKGVsZW1lbnRJbmZvKTtcclxuICAgICAgZWxlbWVudEluZm8ub2JzZXJ2ZSgpO1xyXG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXHJcbiAgICAgIC8vIGlmIHRoZSB0YWIgaXMgYmFja2dyb3VuZGVkLCB0aGUgaW5pdGlhbCByZXNpemUgZXZlbnQgZG9lcyBub3QgZmlyZSB1bnRpbFxyXG4gICAgICAvLyB0aGUgdGFiIGNvbWVzIGludG8gZm9jdXMgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xyXG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3Zpc2liaWxpdHkgcmVzaXplIG9ic2VydmVyIG5vdCB0cmlnZ2VyZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBTdG9wIG9ic2VydmluZyBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcy5cclxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cclxuICBzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8oZWxlbWVudEluZm8pIHtcclxuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKTtcclxuICAgIGZvciAoY29uc3QgaW5mbyBvZiBzdG9wRWxlbWVudEluZm9zKSB7XHJcbiAgICAgIGluZm8uc3RvcE9ic2VydmluZygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoaW5mbyA9PiBpbmZvICE9PSBlbGVtZW50SW5mbyk7XHJcbiAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcclxuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XHJcbiAgfVxyXG4gIGRldGFjaChlbGVtZW50KSB7XHJcbiAgICBsZXQgZGV0YWNoZWRFbGVtZW50cyA9IFtdO1xyXG4gICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5zdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgcmV0dXJuIHN1cGVyLmRldGFjaChlbGVtZW50KTtcclxuICAgIH1cclxuICAgIGRldGFjaGVkRWxlbWVudHMgPSBzdXBlci5kZXRhY2goKTtcclxuICAgIGZvciAoY29uc3QgZSBvZiBkZXRhY2hlZEVsZW1lbnRzKSB7XHJcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGdldERlY29kZXJJbXBsZW1lbnRhdGlvbigpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSB0aGlzLnByZXZTdGF0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29kZXJJbXBsZW1lbnRhdGlvbjtcclxuICB9XHJcbiAgZ2V0UmVjZWl2ZXJTdGF0cygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcclxuICAgICAgbGV0IHJlY2VpdmVyU3RhdHM7XHJcbiAgICAgIGxldCBjb2RlY0lEID0gJyc7XHJcbiAgICAgIGxldCBjb2RlY3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xyXG4gICAgICAgICAgY29kZWNJRCA9IHYuY29kZWNJZDtcclxuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd2aWRlbycsXHJcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxyXG4gICAgICAgICAgICBmcmFtZXNEZWNvZGVkOiB2LmZyYW1lc0RlY29kZWQsXHJcbiAgICAgICAgICAgIGZyYW1lc0Ryb3BwZWQ6IHYuZnJhbWVzRHJvcHBlZCxcclxuICAgICAgICAgICAgZnJhbWVzUmVjZWl2ZWQ6IHYuZnJhbWVzUmVjZWl2ZWQsXHJcbiAgICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogdi5wYWNrZXRzUmVjZWl2ZWQsXHJcbiAgICAgICAgICAgIHBhY2tldHNMb3N0OiB2LnBhY2tldHNMb3N0LFxyXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXHJcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxyXG4gICAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcclxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXHJcbiAgICAgICAgICAgIG5hY2tDb3VudDogdi5uYWNrQ291bnQsXHJcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcclxuICAgICAgICAgICAgZGVjb2RlckltcGxlbWVudGF0aW9uOiB2LmRlY29kZXJJbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gJ2NvZGVjJykge1xyXG4gICAgICAgICAgY29kZWNzLnNldCh2LmlkLCB2KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAocmVjZWl2ZXJTdGF0cyAmJiBjb2RlY0lEICE9PSAnJyAmJiBjb2RlY3MuZ2V0KGNvZGVjSUQpKSB7XHJcbiAgICAgICAgcmVjZWl2ZXJTdGF0cy5taW1lVHlwZSA9IGNvZGVjcy5nZXQoY29kZWNJRCkubWltZVR5cGU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCk7XHJcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xyXG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyhpbmZvKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XHJcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XHJcbiAgICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSByZXR1cm47XHJcbiAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVwZGF0ZVZpc2liaWxpdHkoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgbGFzdFZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLmVsZW1lbnRJbmZvcy5yZWR1Y2UoKHByZXYsIGluZm8pID0+IE1hdGgubWF4KHByZXYsIGluZm8udmlzaWJpbGl0eUNoYW5nZWRBdCB8fCAwKSwgMCk7XHJcbiAgICBjb25zdCBiYWNrZ3JvdW5kUGF1c2UgPSAoKF9iID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2VWaWRlb0luQmFja2dyb3VuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWVcclxuICAgICkgPyB0aGlzLmlzSW5CYWNrZ3JvdW5kIDogZmFsc2U7XHJcbiAgICBjb25zdCBpc1BpUE1vZGUgPSB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGluZm8gPT4gaW5mby5waWN0dXJlSW5QaWN0dXJlKTtcclxuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMuZWxlbWVudEluZm9zLnNvbWUoaW5mbyA9PiBpbmZvLnZpc2libGUpICYmICFiYWNrZ3JvdW5kUGF1c2UgfHwgaXNQaVBNb2RlO1xyXG4gICAgaWYgKHRoaXMubGFzdFZpc2libGUgPT09IGlzVmlzaWJsZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmlzaWJsZSAmJiBEYXRlLm5vdygpIC0gbGFzdFZpc2liaWxpdHlDaGFuZ2UgPCBSRUFDVElPTl9ERUxBWSkge1xyXG4gICAgICAvLyBkZWxheSBoaWRkZW4gZXZlbnRzXHJcbiAgICAgIENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xyXG4gICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMubGFzdFZpc2libGUgPSBpc1Zpc2libGU7XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgaXNWaXNpYmxlLCB0aGlzKTtcclxuICB9XHJcbiAgdXBkYXRlRGltZW5zaW9ucygpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xyXG4gICAgbGV0IG1heEhlaWdodCA9IDA7XHJcbiAgICBjb25zdCBwaXhlbERlbnNpdHkgPSB0aGlzLmdldFBpeGVsRGVuc2l0eSgpO1xyXG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHRoaXMuZWxlbWVudEluZm9zKSB7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50V2lkdGggPSBpbmZvLndpZHRoKCkgKiBwaXhlbERlbnNpdHk7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50SGVpZ2h0ID0gaW5mby5oZWlnaHQoKSAqIHBpeGVsRGVuc2l0eTtcclxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50V2lkdGggKyBjdXJyZW50RWxlbWVudEhlaWdodCA+IG1heFdpZHRoICsgbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50RWxlbWVudFdpZHRoO1xyXG4gICAgICAgIG1heEhlaWdodCA9IGN1cnJlbnRFbGVtZW50SGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKChfYSA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgPT09IG1heFdpZHRoICYmICgoX2IgPSB0aGlzLmxhc3REaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSA9PT0gbWF4SGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMubGFzdERpbWVuc2lvbnMgPSB7XHJcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBtYXhIZWlnaHRcclxuICAgIH07XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcclxuICB9XHJcbiAgZ2V0UGl4ZWxEZW5zaXR5KCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcGl4ZWxEZW5zaXR5ID0gKF9hID0gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGl4ZWxEZW5zaXR5O1xyXG4gICAgaWYgKHBpeGVsRGVuc2l0eSA9PT0gJ3NjcmVlbicpIHtcclxuICAgICAgcmV0dXJuIGdldERldmljZVBpeGVsUmF0aW8oKTtcclxuICAgIH0gZWxzZSBpZiAoIXBpeGVsRGVuc2l0eSkge1xyXG4gICAgICAvLyB3aGVuIHVuc2V0LCB3ZSdsbCBwaWNrIGEgc2FuZSBkZWZhdWx0IGhlcmUuXHJcbiAgICAgIC8vIGZvciBoaWdoZXIgcGl4ZWwgZGVuc2l0eSBkZXZpY2VzIChtb2JpbGUgcGhvbmVzLCBldGMpLCB3ZSdsbCB1c2UgMlxyXG4gICAgICAvLyBvdGhlcndpc2UgaXQgZGVmYXVsdHMgdG8gMVxyXG4gICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xyXG4gICAgICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyA+IDIpIHtcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBpeGVsRGVuc2l0eTtcclxuICB9XHJcbn1cclxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIHtcclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmlzUGlQIHx8IHRoaXMuaXNJbnRlcnNlY3Rpbmc7XHJcbiAgfVxyXG4gIGdldCBwaWN0dXJlSW5QaWN0dXJlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNQaVA7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpc2libGUpIHtcclxuICAgIHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZCA9IGVudHJ5ID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXHJcbiAgICAgIH0gPSBlbnRyeTtcclxuICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xyXG4gICAgICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLm9uRW50ZXJQaVAgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAoX2IgPSAoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2luZG93KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xyXG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcclxuICAgICAgKF9jID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxlYXZlUGlQID0gKCkgPT4ge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IHZpc2libGUgIT09IG51bGwgJiYgdmlzaWJsZSAhPT0gdm9pZCAwID8gdmlzaWJsZSA6IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XHJcbiAgICB0aGlzLmlzUGlQID0gaXNXZWIoKSAmJiBpc0VsZW1lbnRJblBpUChlbGVtZW50KTtcclxuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IDA7XHJcbiAgfVxyXG4gIHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aDtcclxuICB9XHJcbiAgaGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgfVxyXG4gIG9ic2VydmUoKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIGN1cnJlbnQgdmlzaWJsZSBzdGF0ZSBvbmNlIHdlIHN0YXJ0IHRvIG9ic2VydmVcclxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0VsZW1lbnRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XHJcbiAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcclxuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgKF9hID0gdGhpcy5oYW5kbGVSZXNpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9IHRoaXMub25WaXNpYmlsaXR5Q2hhbmdlZDtcclxuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCkub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgZ2V0UmVzaXplT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XHJcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZW50ZXJwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkVudGVyUGlQKTtcclxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uTGVhdmVQaVApO1xyXG4gICAgKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkVudGVyUGlQKTtcclxuICAgIChfYyA9IChfYiA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aW5kb3cpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XHJcbiAgfVxyXG4gIHN0b3BPYnNlcnZpbmcoKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgKF9hID0gZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgKF9iID0gZ2V0UmVzaXplT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XHJcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgdGhpcy5vbkxlYXZlUGlQKTtcclxuICAgIChfYyA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XHJcbiAgICAoX2UgPSAoX2QgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2luZG93KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc0VsZW1lbnRJblBpUChlbCkge1xyXG4gIHZhciBfYSwgX2I7XHJcbiAgLy8gU2ltcGxlIHZpZGVvIFBpUFxyXG4gIGlmIChkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCA9PT0gZWwpIHJldHVybiB0cnVlO1xyXG4gIC8vIERvY3VtZW50IFBpUFxyXG4gIGlmICgoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2luZG93KSByZXR1cm4gaXNFbGVtZW50SW5WaWV3cG9ydChlbCwgKF9iID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpbmRvdyk7XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIGRvZXMgbm90IGFjY291bnQgZm9yIG9jY2x1c2lvbiBieSBvdGhlciBlbGVtZW50cyBvciBvcGFjaXR5IHByb3BlcnR5XHJcbmZ1bmN0aW9uIGlzRWxlbWVudEluVmlld3BvcnQoZWwsIHdpbikge1xyXG4gIGNvbnN0IHZpZXdwb3J0V2luZG93ID0gd2luIHx8IHdpbmRvdztcclxuICBsZXQgdG9wID0gZWwub2Zmc2V0VG9wO1xyXG4gIGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcclxuICBjb25zdCB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xyXG4gIGNvbnN0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcclxuICBjb25zdCB7XHJcbiAgICBoaWRkZW5cclxuICB9ID0gZWw7XHJcbiAgY29uc3Qge1xyXG4gICAgZGlzcGxheVxyXG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XHJcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcclxuICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XHJcbiAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XHJcbiAgfVxyXG4gIHJldHVybiB0b3AgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWU9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVySGVpZ2h0ICYmIGxlZnQgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWE9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVyV2lkdGggJiYgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgJiYgbGVmdCArIHdpZHRoID4gdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgJiYgIWhpZGRlbiAmJiBkaXNwbGF5ICE9PSAnbm9uZSc7XHJcbn1cclxuXHJcbmNsYXNzIFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3Ioa2luZCwgaWQsIG5hbWUsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZW5jcnlwdGlvbiA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xyXG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xyXG4gICAgdGhpcy5oYW5kbGVNdXRlZCA9ICgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuTXV0ZWQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlVW5tdXRlZCA9ICgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5tdXRlZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucyA9PT0gbnVsbCB8fCBsb2dnZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlB1YmxpY2F0aW9uKTtcclxuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gdGhpcy5sb2dnZXJDb250ZXh0Q2I7XHJcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xyXG4gICAgdGhpcy5raW5kID0ga2luZDtcclxuICAgIHRoaXMudHJhY2tTaWQgPSBpZDtcclxuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcclxuICAgIHRoaXMuc291cmNlID0gVHJhY2suU291cmNlLlVua25vd247XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRUcmFjayh0cmFjaykge1xyXG4gICAgaWYgKHRoaXMudHJhY2spIHtcclxuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XHJcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcclxuICAgIH1cclxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICAvLyBmb3J3YXJkIGV2ZW50c1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXQgbG9nQ29udGV4dCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcykpO1xyXG4gIH1cclxuICBnZXQgaXNNdXRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhTXV0ZWQ7XHJcbiAgfVxyXG4gIGdldCBpc0VuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZ2V0IGlzU3Vic2NyaWJlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBhbiBbQXVkaW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhbiBhdWRpbyB0cmFja1xyXG4gICAqL1xyXG4gIGdldCBhdWRpb1RyYWNrKCkge1xyXG4gICAgaWYgKGlzQXVkaW9UcmFjayh0aGlzLnRyYWNrKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogYW4gW1ZpZGVvVHJhY2tdIGlmIHRoaXMgcHVibGljYXRpb24gaG9sZHMgYSB2aWRlbyB0cmFja1xyXG4gICAqL1xyXG4gIGdldCB2aWRlb1RyYWNrKCkge1xyXG4gICAgaWYgKGlzVmlkZW9UcmFjayh0aGlzLnRyYWNrKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHVwZGF0ZUluZm8oaW5mbykge1xyXG4gICAgdGhpcy50cmFja1NpZCA9IGluZm8uc2lkO1xyXG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XHJcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLnNvdXJjZUZyb21Qcm90byhpbmZvLnNvdXJjZSk7XHJcbiAgICB0aGlzLm1pbWVUeXBlID0gaW5mby5taW1lVHlwZTtcclxuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcclxuICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xyXG4gICAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHRcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbmNyeXB0aW9uID0gaW5mby5lbmNyeXB0aW9uO1xyXG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xyXG4gICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0ZSBwdWJsaWNhdGlvbiBpbmZvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIGluZm9cclxuICAgIH0pKTtcclxuICB9XHJcbn1cclxuKGZ1bmN0aW9uIChUcmFja1B1YmxpY2F0aW9uKSB7XHJcbiAgKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25TdGF0dXMpIHtcclxuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIkRlc2lyZWRcIl0gPSBcImRlc2lyZWRcIjtcclxuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlN1YnNjcmliZWRcIl0gPSBcInN1YnNjcmliZWRcIjtcclxuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XHJcbiAgfSkoVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzID0ge30pKTtcclxuICAoZnVuY3Rpb24gKFBlcm1pc3Npb25TdGF0dXMpIHtcclxuICAgIFBlcm1pc3Npb25TdGF0dXNbXCJBbGxvd2VkXCJdID0gXCJhbGxvd2VkXCI7XHJcbiAgICBQZXJtaXNzaW9uU3RhdHVzW1wiTm90QWxsb3dlZFwiXSA9IFwibm90X2FsbG93ZWRcIjtcclxuICB9KShUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMgfHwgKFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyA9IHt9KSk7XHJcbn0pKFRyYWNrUHVibGljYXRpb24gfHwgKFRyYWNrUHVibGljYXRpb24gPSB7fSkpO1xyXG5cclxuY2xhc3MgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgVHJhY2tQdWJsaWNhdGlvbiB7XHJcbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBzdHJlYW1QYXVzZWQ7XHJcbiAgfVxyXG4gIGNvbnN0cnVjdG9yKGtpbmQsIHRpLCB0cmFjaywgbG9nZ2VyT3B0aW9ucykge1xyXG4gICAgc3VwZXIoa2luZCwgdGkuc2lkLCB0aS5uYW1lLCBsb2dnZXJPcHRpb25zKTtcclxuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhhbmRsZVRyYWNrRW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xyXG4gICAgdGhpcy5zZXRUcmFjayh0cmFjayk7XHJcbiAgfVxyXG4gIHNldFRyYWNrKHRyYWNrKSB7XHJcbiAgICBpZiAodGhpcy50cmFjaykge1xyXG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xyXG4gICAgfVxyXG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xyXG4gICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldCBpc011dGVkKCkge1xyXG4gICAgaWYgKHRoaXMudHJhY2spIHtcclxuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBlci5pc011dGVkO1xyXG4gIH1cclxuICBnZXQgYXVkaW9UcmFjaygpIHtcclxuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrO1xyXG4gIH1cclxuICBnZXQgdmlkZW9UcmFjaygpIHtcclxuICAgIHJldHVybiBzdXBlci52aWRlb1RyYWNrO1xyXG4gIH1cclxuICBnZXQgaXNMb2NhbCgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBNdXRlIHRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxyXG4gICAqL1xyXG4gIG11dGUoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubXV0ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFVubXV0ZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvblxyXG4gICAqL1xyXG4gIHVubXV0ZSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgcmV0dXJuIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51bm11dGUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQYXVzZXMgdGhlIG1lZGlhIHN0cmVhbSB0cmFjayBhc3NvY2lhdGVkIHdpdGggdGhpcyBwdWJsaWNhdGlvbiBmcm9tIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gICAqIGFuZCBzaWduYWxzIFwibXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHNcclxuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGF1c2UgdGhlIHN0cmVhbSB3aXRob3V0IHBhdXNpbmcgdGhlIGxvY2FsIG1lZGlhIHN0cmVhbSB0cmFja1xyXG4gICAqL1xyXG4gIHBhdXNlVXBzdHJlYW0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVVwc3RyZWFtKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmVzdW1lcyBzZW5kaW5nIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gdG8gdGhlIHNlcnZlciBhZnRlciBhIGNhbGwgdG8gW1twYXVzZVVwc3RyZWFtKCldXVxyXG4gICAqIGFuZCBzaWduYWxzIFwidW5tdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50cyAodW5sZXNzIHRoZSB0cmFjayBpcyBleHBsaWNpdGx5IG11dGVkKVxyXG4gICAqL1xyXG4gIHJlc3VtZVVwc3RyZWFtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICB5aWVsZCAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdW1lVXBzdHJlYW0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRUcmFja0ZlYXR1cmVzKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKGlzQXVkaW9UcmFjayh0aGlzLnRyYWNrKSkge1xyXG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMudHJhY2suZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpO1xyXG4gICAgICBjb25zdCBmZWF0dXJlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgaWYgKHNldHRpbmdzLmF1dG9HYWluQ29udHJvbCkge1xyXG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9BVVRPX0dBSU5fQ09OVFJPTCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNldHRpbmdzLmVjaG9DYW5jZWxsYXRpb24pIHtcclxuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfRUNIT19DQU5DRUxMQVRJT04pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXR0aW5ncy5ub2lzZVN1cHByZXNzaW9uKSB7XHJcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PSVNFX1NVUFBSRVNTSU9OKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGluZ3MuY2hhbm5lbENvdW50ICYmIHNldHRpbmdzLmNoYW5uZWxDb3VudCA+IDEpIHtcclxuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfU1RFUkVPKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoISgoX2EgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kdHgpKSB7XHJcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PX0RUWCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMudHJhY2suZW5oYW5jZWROb2lzZUNhbmNlbGxhdGlvbikge1xyXG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT04pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZlYXR1cmVzLnZhbHVlcygpKTtcclxuICAgIH0gZWxzZSByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXHJcbiAqIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3MgdG9nZXRoZXIsIGl0J2xsIGRpc3BsYXkgYSBzaW5nbGUgcGVybWlzc2lvbiBwcm9tcHQgdG9cclxuICogdGhlIHVzZXIgaW5zdGVhZCBvZiB0d28gc2VwYXJhdGUgb25lcy5cclxuICogQHBhcmFtIG9wdGlvbnNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsVHJhY2tzKG9wdGlvbnMsIGxvZ2dlck9wdGlvbnMpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogb3B0aW9ucyA9IHt9O1xyXG4gICAgbGV0IGF0dGVtcHRFeGFjdE1hdGNoID0gZmFsc2U7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGF1ZGlvUHJvY2Vzc29yLFxyXG4gICAgICB2aWRlb1Byb2Nlc3NvcixcclxuICAgICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGludGVybmFsT3B0aW9uc1xyXG4gICAgfSA9IGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICBsZXQgcmV0cnlBdWRpb09wdGlvbnMgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW87XHJcbiAgICBsZXQgcmV0cnlWaWRlb09wdGlvbnMgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW87XHJcbiAgICBpZiAoYXVkaW9Qcm9jZXNzb3IgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLnByb2Nlc3NvciA9IGF1ZGlvUHJvY2Vzc29yO1xyXG4gICAgfVxyXG4gICAgaWYgKHZpZGVvUHJvY2Vzc29yICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlby5wcm9jZXNzb3IgPSB2aWRlb1Byb2Nlc3NvcjtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoZSB1c2VyIHBhc3NlcyBhIGRldmljZSBpZCBhcyBhIHN0cmluZywgd2UgZGVmYXVsdCB0byBleGFjdCBtYXRjaFxyXG4gICAgaWYgKG9wdGlvbnMuYXVkaW8gJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgY29uc3QgZGV2aWNlSWQgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQ7XHJcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpby5kZXZpY2VJZCA9IHtcclxuICAgICAgICBleGFjdDogZGV2aWNlSWRcclxuICAgICAgfTtcclxuICAgICAgYXR0ZW1wdEV4YWN0TWF0Y2ggPSB0cnVlO1xyXG4gICAgICByZXRyeUF1ZGlvT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxPcHRpb25zLmF1ZGlvKSwge1xyXG4gICAgICAgIGRldmljZUlkOiB7XHJcbiAgICAgICAgICBpZGVhbDogZGV2aWNlSWRcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGludGVybmFsT3B0aW9ucy52aWRlbyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCBkZXZpY2VJZCA9IGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZDtcclxuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID0ge1xyXG4gICAgICAgIGV4YWN0OiBkZXZpY2VJZFxyXG4gICAgICB9O1xyXG4gICAgICBhdHRlbXB0RXhhY3RNYXRjaCA9IHRydWU7XHJcbiAgICAgIHJldHJ5VmlkZW9PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbE9wdGlvbnMudmlkZW8pLCB7XHJcbiAgICAgICAgZGV2aWNlSWQ6IHtcclxuICAgICAgICAgIGlkZWFsOiBkZXZpY2VJZFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSB0cnVlIHx8IHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmICFpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQpIHtcclxuICAgICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID0ge1xyXG4gICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09IHRydWUpIHtcclxuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvID0ge1xyXG4gICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgIWludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCkge1xyXG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPSAnZGVmYXVsdCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhpbnRlcm5hbE9wdGlvbnMsIGF1ZGlvRGVmYXVsdHMsIHZpZGVvRGVmYXVsdHMpO1xyXG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XHJcbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwcm9taXNlIG9uIERldmljZU1hbmFnZXIgYW5kIGF3YWl0IGl0IGluIGdldExvY2FsRGV2aWNlcygpXHJcbiAgICAvLyB3b3JrcyBhcm91bmQgaU9TIFNhZmFyaSBCdWcgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3OTM2M1xyXG4gICAgY29uc3QgbWVkaWFQcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgaWYgKGludGVybmFsT3B0aW9ucy5hdWRpbykge1xyXG4gICAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcclxuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ2F1ZGlvaW5wdXQnKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvKSB7XHJcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xyXG4gICAgICBtZWRpYVByb21pc2UuY2F0Y2goKCkgPT4gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmRlbGV0ZSgndmlkZW9pbnB1dCcpKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHlpZWxkIG1lZGlhUHJvbWlzZTtcclxuICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHN0cmVhbS5nZXRUcmFja3MoKS5tYXAobWVkaWFTdHJlYW1UcmFjayA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcclxuICAgICAgICBsZXQgdHJhY2tPcHRpb25zID0gaXNBdWRpbyA/IG9wdHMuYXVkaW8gOiBvcHRzLnZpZGVvO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xyXG4gICAgICAgICAgdHJhY2tPcHRpb25zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzO1xyXG4gICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uT3JCb29sICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSBjb25PckJvb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29uc3RyYWludHMgd2l0aCB0aGUgZGV2aWNlIGlkIHRoZSB1c2VyIGdhdmUgcGVybWlzc2lvbnMgdG8gaW4gdGhlIHBlcm1pc3Npb24gcHJvbXB0XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggdHJhY2sgcmVzdGFydCAoZS5nLiBtdXRlIC0gdW5tdXRlKSB3aWxsIHRyeSB0byBpbml0aWFsaXplIHRoZSBkZXZpY2UgYWdhaW4gLT4gY2F1c2luZyBhZGRpdGlvbmFsIHBlcm1pc3Npb24gcHJvbXB0c1xyXG4gICAgICAgIGNvbnN0IG5ld0RldmljZUlkID0gbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xyXG4gICAgICAgIGlmICgodHJhY2tDb25zdHJhaW50cyA9PT0gbnVsbCB8fCB0cmFja0NvbnN0cmFpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkKSAmJiB1bndyYXBDb25zdHJhaW50KHRyYWNrQ29uc3RyYWludHMuZGV2aWNlSWQpICE9PSBuZXdEZXZpY2VJZCkge1xyXG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCA9IG5ld0RldmljZUlkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYWNrQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSB7XHJcbiAgICAgICAgICAgIGRldmljZUlkOiBuZXdEZXZpY2VJZFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuQ2FtZXJhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xyXG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xyXG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2sodHJhY2spICYmIGF1ZGlvUHJvY2Vzc29yKSB7XHJcbiAgICAgICAgICB5aWVsZCB0cmFjay5zZXRQcm9jZXNzb3IoYXVkaW9Qcm9jZXNzb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSAmJiB2aWRlb1Byb2Nlc3Nvcikge1xyXG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKHZpZGVvUHJvY2Vzc29yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgICB9KSkpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBpZiAoIWF0dGVtcHRFeGFjdE1hdGNoKSB7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFja3MoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwge1xyXG4gICAgICAgIGF1ZGlvOiByZXRyeUF1ZGlvT3B0aW9ucyxcclxuICAgICAgICB2aWRlbzogcmV0cnlWaWRlb09wdGlvbnNcclxuICAgICAgfSksIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgW1tMb2NhbFZpZGVvVHJhY2tdXSB3aXRoIGdldFVzZXJNZWRpYSgpXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2sob3B0aW9ucykge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XHJcbiAgICAgIGF1ZGlvOiBmYWxzZSxcclxuICAgICAgdmlkZW86IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRyYWNrc1swXTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sob3B0aW9ucykge1xyXG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XHJcbiAgICAgIGF1ZGlvOiBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB0cnVlLFxyXG4gICAgICB2aWRlbzogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRyYWNrc1swXTtcclxuICB9KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNjcmVlbiBjYXB0dXJlIHRyYWNrcyB3aXRoIGdldERpc3BsYXlNZWRpYSgpLlxyXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcclxuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uID09PSB1bmRlZmluZWQgJiYgIWlzU2FmYXJpMTcoKSkge1xyXG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcclxuICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xyXG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xyXG4gICAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcclxuICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XHJcbiAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xyXG4gIH0pO1xyXG59XHJcblxyXG52YXIgQ29ubmVjdGlvblF1YWxpdHk7XHJcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcclxuICBDb25uZWN0aW9uUXVhbGl0eVtcIkV4Y2VsbGVudFwiXSA9IFwiZXhjZWxsZW50XCI7XHJcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJHb29kXCJdID0gXCJnb29kXCI7XHJcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJQb29yXCJdID0gXCJwb29yXCI7XHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHRoYXQgYSBwYXJ0aWNpcGFudCBoYXMgdGVtcG9yYXJpbHkgKG9yIHBlcm1hbmVudGx5KSBsb3N0IGNvbm5lY3Rpb24gdG8gTGl2ZUtpdC5cclxuICAgKiBGb3IgcGVybWFuZW50IGRpc2Nvbm5lY3Rpb24gYSBgUGFydGljaXBhbnREaXNjb25uZWN0ZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBhZnRlciBhIHRpbWVvdXRcclxuICAgKi9cclxuICBDb25uZWN0aW9uUXVhbGl0eVtcIkxvc3RcIl0gPSBcImxvc3RcIjtcclxuICBDb25uZWN0aW9uUXVhbGl0eVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcclxufSkoQ29ubmVjdGlvblF1YWxpdHkgfHwgKENvbm5lY3Rpb25RdWFsaXR5ID0ge30pKTtcclxuZnVuY3Rpb24gcXVhbGl0eUZyb21Qcm90byhxKSB7XHJcbiAgc3dpdGNoIChxKSB7XHJcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuRVhDRUxMRU5UOlxyXG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuRXhjZWxsZW50O1xyXG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkdPT0Q6XHJcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Hb29kO1xyXG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLlBPT1I6XHJcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xyXG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkxPU1Q6XHJcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Mb3N0O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XHJcbiAgfVxyXG59XHJcbmNsYXNzIFBhcnRpY2lwYW50IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlck9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XHJcbiAgfVxyXG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYWNrUHVibGljYXRpb25zLnNpemUgPiAwICYmIEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZXZlcnkodHIgPT4gdHIuaXNFbmNyeXB0ZWQpO1xyXG4gIH1cclxuICBnZXQgaXNBZ2VudCgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFnZW50KSB8fCB0aGlzLmtpbmQgPT09IFBhcnRpY2lwYW50SW5mb19LaW5kLkFHRU5UO1xyXG4gIH1cclxuICBnZXQgaXNBY3RpdmUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKChfYSA9IHRoaXMucGFydGljaXBhbnRJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFO1xyXG4gIH1cclxuICBnZXQga2luZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9raW5kO1xyXG4gIH1cclxuICAvKiogcGFydGljaXBhbnQgYXR0cmlidXRlcywgc2ltaWxhciB0byBtZXRhZGF0YSwgYnV0IGFzIGEga2V5L3ZhbHVlIG1hcCAqL1xyXG4gIGdldCBhdHRyaWJ1dGVzKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYXR0cmlidXRlcykpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIGxldCBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBQYXJ0aWNpcGFudEluZm9fS2luZC5TVEFOREFSRDtcclxuICAgIHZhciBfYTtcclxuICAgIHN1cGVyKCk7XHJcbiAgICAvKiogYXVkaW8gbGV2ZWwgYmV0d2VlbiAwLTEuMCwgMSBiZWluZyBsb3VkZXN0LCAwIGJlaW5nIHNvZnRlc3QgKi9cclxuICAgIHRoaXMuYXVkaW9MZXZlbCA9IDA7XHJcbiAgICAvKiogaWYgcGFydGljaXBhbnQgaXMgY3VycmVudGx5IHNwZWFraW5nICovXHJcbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gQ29ubmVjdGlvblF1YWxpdHkuVW5rbm93bjtcclxuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcclxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMgPT09IG51bGwgfHwgbG9nZ2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QYXJ0aWNpcGFudCk7XHJcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xyXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcclxuICAgIHRoaXMuc2lkID0gc2lkO1xyXG4gICAgdGhpcy5pZGVudGl0eSA9IGlkZW50aXR5O1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLl9raW5kID0ga2luZDtcclxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzICE9PSBudWxsICYmIGF0dHJpYnV0ZXMgIT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMgOiB7fTtcclxuICB9XHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgc291cmNlIGZpbHRlciwgZm9yIGV4YW1wbGUsIGdldHRpbmdcclxuICAgKiB0aGUgdXNlcidzIGNhbWVyYSB0cmFjayB3aXRoIGdldFRyYWNrQnlTb3VyY2UoVHJhY2suU291cmNlLkNhbWVyYSkuXHJcbiAgICovXHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcclxuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrUHVibGljYXRpb25zKSB7XHJcbiAgICAgIGlmIChwdWIuc291cmNlID09PSBzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gcHViO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHRyYWNrJ3MgbmFtZS5cclxuICAgKi9cclxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcclxuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrUHVibGljYXRpb25zKSB7XHJcbiAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1YjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvKipcclxuICAgKiBXYWl0cyB1bnRpbCB0aGUgcGFydGljaXBhbnQgaXMgYWN0aXZlIGFuZCByZWFkeSB0byByZWNlaXZlIGRhdGEgbWVzc2FnZXNcclxuICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBpcyBhY3RpdmVcclxuICAgKi9cclxuICB3YWl0VW50aWxBY3RpdmUoKSB7XHJcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hY3RpdmVGdXR1cmUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRnV0dXJlLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICB0aGlzLmFjdGl2ZUZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcclxuICAgIHRoaXMub25jZShQYXJ0aWNpcGFudEV2ZW50LkFjdGl2ZSwgKCkgPT4ge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLmFjdGl2ZUZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgdGhpcy5hY3RpdmVGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzLmFjdGl2ZUZ1dHVyZS5wcm9taXNlO1xyXG4gIH1cclxuICBnZXQgY29ubmVjdGlvblF1YWxpdHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XHJcbiAgfVxyXG4gIGdldCBpc0NhbWVyYUVuYWJsZWQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcclxuICAgIHJldHVybiAhKChfYSA9IHRyYWNrID09PSBudWxsIHx8IHRyYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFjay5pc011dGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcclxuICB9XHJcbiAgZ2V0IGlzTWljcm9waG9uZUVuYWJsZWQoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XHJcbiAgICByZXR1cm4gISgoX2EgPSB0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2suaXNNdXRlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XHJcbiAgfVxyXG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpIHtcclxuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSk7XHJcbiAgICByZXR1cm4gISF0cmFjaztcclxuICB9XHJcbiAgZ2V0IGlzTG9jYWwoKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8qKiB3aGVuIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbSAqL1xyXG4gIGdldCBqb2luZWRBdCgpIHtcclxuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SW5mbykge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRoaXMucGFydGljaXBhbnRJbmZvLmpvaW5lZEF0LnRvU3RyaW5nKCkpICogMTAwMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERhdGUoKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHVwZGF0ZUluZm8oaW5mbykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgdXBkYXRlIGNvdWxkIGJlIGFwcGxpZWQgb3V0IG9mIG9yZGVyIGR1ZSB0byBhd2FpdFxyXG4gICAgLy8gZHVyaW5nIHJlY29ubmVjdCBzZXF1ZW5jZXMuIHdoZW4gdGhhdCBoYXBwZW5zLCBpdCdzIHBvc3NpYmxlIGZvciBzZXJ2ZXJcclxuICAgIC8vIHRvIGhhdmUgc2VudCBtb3JlIHJlY2VudCB2ZXJzaW9uIG9mIHBhcnRpY2lwYW50IGluZm8gd2hpbGUgSlMgaXMgd2FpdGluZ1xyXG4gICAgLy8gdG8gcHJvY2VzcyB0aGUgZXhpc3RpbmcgcGF5bG9hZC5cclxuICAgIC8vIHdoZW4gdGhlIHBhcnRpY2lwYW50IHNpZCByZW1haW5zIHRoZSBzYW1lLCBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgbGF0ZXIgdmVyc2lvblxyXG4gICAgLy8gb2YgdGhlIHBheWxvYWQsIHRoZXkgY2FuIGJlIHNhZmVseSBza2lwcGVkXHJcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8gJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8uc2lkID09PSBpbmZvLnNpZCAmJiB0aGlzLnBhcnRpY2lwYW50SW5mby52ZXJzaW9uID4gaW5mby52ZXJzaW9uKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuaWRlbnRpdHkgPSBpbmZvLmlkZW50aXR5O1xyXG4gICAgdGhpcy5zaWQgPSBpbmZvLnNpZDtcclxuICAgIHRoaXMuX3NldE5hbWUoaW5mby5uYW1lKTtcclxuICAgIHRoaXMuX3NldE1ldGFkYXRhKGluZm8ubWV0YWRhdGEpO1xyXG4gICAgdGhpcy5fc2V0QXR0cmlidXRlcyhpbmZvLmF0dHJpYnV0ZXMpO1xyXG4gICAgaWYgKGluZm8uc3RhdGUgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5BQ1RJVkUgJiYgKChfYSA9IHRoaXMucGFydGljaXBhbnRJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGUpICE9PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuQUNUSVZFKSB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5mby5wZXJtaXNzaW9uKSB7XHJcbiAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMoaW5mby5wZXJtaXNzaW9uKTtcclxuICAgIH1cclxuICAgIC8vIHNldCB0aGlzIGxhc3Qgc28gc2V0TWV0YWRhdGEgY2FuIGRldGVjdCBjaGFuZ2VzXHJcbiAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyA9IGluZm87XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBtZXRhZGF0YSBmcm9tIHNlcnZlclxyXG4gICAqKi9cclxuICBfc2V0TWV0YWRhdGEobWQpIHtcclxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcclxuICAgIGNvbnN0IHByZXZNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XHJcbiAgICB0aGlzLm1ldGFkYXRhID0gbWQ7XHJcbiAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3NldE5hbWUobmFtZSkge1xyXG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubmFtZSAhPT0gbmFtZTtcclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBtZXRhZGF0YSBmcm9tIHNlcnZlclxyXG4gICAqKi9cclxuICBfc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XHJcbiAgICBjb25zdCBkaWZmID0gZGlmZkF0dHJpYnV0ZXModGhpcy5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcclxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG4gICAgaWYgKE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIGRpZmYpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcclxuICAgIGNvbnN0IGNoYW5nZWQgPSBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2gpIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZSAhPT0gKChfYiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5TdWJzY3JpYmUpIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSAoKF9jID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhblB1Ymxpc2hEYXRhKSB8fCBwZXJtaXNzaW9ucy5oaWRkZW4gIT09ICgoX2QgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGlkZGVuKSB8fCBwZXJtaXNzaW9ucy5yZWNvcmRlciAhPT0gKChfZSA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWNvcmRlcikgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICByZXR1cm4gdmFsdWUgIT09ICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUHVibGlzaFNvdXJjZXNbaW5kZXhdKTtcclxuICAgIH0pIHx8IHBlcm1pc3Npb25zLmNhblN1YnNjcmliZU1ldHJpY3MgIT09ICgoX2YgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FuU3Vic2NyaWJlTWV0cmljcyk7XHJcbiAgICB0aGlzLnBlcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XHJcbiAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0SXNTcGVha2luZyhzcGVha2luZykge1xyXG4gICAgaWYgKHNwZWFraW5nID09PSB0aGlzLmlzU3BlYWtpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pc1NwZWFraW5nID0gc3BlYWtpbmc7XHJcbiAgICBpZiAoc3BlYWtpbmcpIHtcclxuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Jc1NwZWFraW5nQ2hhbmdlZCwgc3BlYWtpbmcpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0Q29ubmVjdGlvblF1YWxpdHkocSkge1xyXG4gICAgY29uc3QgcHJldlF1YWxpdHkgPSB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eTtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5ID0gcXVhbGl0eUZyb21Qcm90byhxKTtcclxuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLl9jb25uZWN0aW9uUXVhbGl0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldERpc2Nvbm5lY3RlZCgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBpZiAodGhpcy5hY3RpdmVGdXR1cmUpIHtcclxuICAgICAgKF9iID0gKF9hID0gdGhpcy5hY3RpdmVGdXR1cmUpLnJlamVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG5ldyBFcnJvcignUGFydGljaXBhbnQgZGlzY29ubmVjdGVkJykpO1xyXG4gICAgICB0aGlzLmFjdGl2ZUZ1dHVyZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc2V0QXVkaW9Db250ZXh0KGN0eCkge1xyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBjdHg7XHJcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0cmFjayA9PiBpc0F1ZGlvVHJhY2sodHJhY2sudHJhY2spICYmIHRyYWNrLnRyYWNrLnNldEF1ZGlvQ29udGV4dChjdHgpKTtcclxuICB9XHJcbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xyXG4gICAgLy8gZm9yd2FyZCBwdWJsaWNhdGlvbiBkcml2ZW4gZXZlbnRzXHJcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50Lk11dGVkLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5Vbm11dGVkLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHVibGljYXRpb24pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwdWIgPSBwdWJsaWNhdGlvbjtcclxuICAgIGlmIChwdWIudHJhY2spIHtcclxuICAgICAgcHViLnRyYWNrLnNpZCA9IHB1YmxpY2F0aW9uLnRyYWNrU2lkO1xyXG4gICAgfVxyXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcclxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xyXG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XHJcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFRyYWNrLktpbmQuVmlkZW86XHJcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwZXJtcykge1xyXG4gIHZhciBfYSwgX2IsIF9jO1xyXG4gIGlmICghcGVybXMucGFydGljaXBhbnRTaWQgJiYgIXBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFjayBwZXJtaXNzaW9uLCBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHBhcnRpY2lwYW50SWRlbnRpdHkgYW5kIHBhcnRpY2lwYW50U2lkJyk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKHtcclxuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IChfYSA9IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxyXG4gICAgcGFydGljaXBhbnRTaWQ6IChfYiA9IHBlcm1zLnBhcnRpY2lwYW50U2lkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcclxuICAgIGFsbFRyYWNrczogKF9jID0gcGVybXMuYWxsb3dBbGwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxyXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdXHJcbiAgfSk7XHJcbn1cclxuXHJcbmNvbnN0IFNUUkVBTV9DSFVOS19TSVpFID0gMTUwMDA7XHJcbmNsYXNzIExvY2FsUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGNvbnN0cnVjdG9yKHNpZCwgaWRlbnRpdHksIGVuZ2luZSwgb3B0aW9ucywgcm9vbVJwY0hhbmRsZXJzKSB7XHJcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XHJcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmVuZ2luZS5sb2dDb250ZXh0XHJcbiAgICB9KTtcclxuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcgPSBuZXcgU2V0KCk7XHJcbiAgICB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IFtdO1xyXG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSB0cnVlO1xyXG4gICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IEVuY3J5cHRpb25fVHlwZS5OT05FO1xyXG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gW107XHJcbiAgICB0aGlzLnBlbmRpbmdBY2tzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcclxuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcclxuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZS5wcm9taXNlLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVqZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgJ0dvdCBkaXNjb25uZWN0ZWQgZHVyaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKSB7XHJcbiAgICAgICAgKF9kID0gKF9jID0gdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsICdHb3QgZGlzY29ubmVjdGVkIHdpdGhvdXQgc2lnbmFsIGNvbm5lY3RlZCcpO1xyXG4gICAgICAgIHRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIChfZiA9IChfZSA9IHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWplY3QpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lLCAnR290IGRpc2Nvbm5lY3RlZCB3aXRob3V0IGFjdGl2ZSBhZ2VudCBwcmVzZW50Jyk7XHJcbiAgICAgIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuZmlyc3RBY3RpdmVBZ2VudCA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVNpZ25hbENvbm5lY3RlZCA9IGpvaW5SZXNwb25zZSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGlmIChqb2luUmVzcG9uc2UucGFydGljaXBhbnQpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUluZm8oam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuc2lnbmFsQ29ubmVjdGVkRnV0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICAgIH1cclxuICAgICAgKF9iID0gKF9hID0gdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUpLnJlc29sdmUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICByZWFzb24sXHJcbiAgICAgICAgbWVzc2FnZVxyXG4gICAgICB9ID0gcmVzcG9uc2U7XHJcbiAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3QgPSB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcclxuICAgICAgaWYgKHRhcmdldFJlcXVlc3QpIHtcclxuICAgICAgICBpZiAocmVhc29uICE9PSBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uLk9LKSB7XHJcbiAgICAgICAgICB0YXJnZXRSZXF1ZXN0LnJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKG1lc3NhZ2UsIHJlYXNvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlRGF0YVBhY2tldCA9IHBhY2tldCA9PiB7XHJcbiAgICAgIHN3aXRjaCAocGFja2V0LnZhbHVlLmNhc2UpIHtcclxuICAgICAgICBjYXNlICdycGNSZXNwb25zZSc6XHJcbiAgICAgICAgICBsZXQgcnBjUmVzcG9uc2UgPSBwYWNrZXQudmFsdWUudmFsdWU7XHJcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IG51bGw7XHJcbiAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgaWYgKHJwY1Jlc3BvbnNlLnZhbHVlLmNhc2UgPT09ICdwYXlsb2FkJykge1xyXG4gICAgICAgICAgICBwYXlsb2FkID0gcnBjUmVzcG9uc2UudmFsdWUudmFsdWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHJwY1Jlc3BvbnNlLnZhbHVlLmNhc2UgPT09ICdlcnJvcicpIHtcclxuICAgICAgICAgICAgZXJyb3IgPSBScGNFcnJvci5mcm9tUHJvdG8ocnBjUmVzcG9uc2UudmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlKHJwY1Jlc3BvbnNlLnJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncnBjQWNrJzpcclxuICAgICAgICAgIGxldCBycGNBY2sgPSBwYWNrZXQudmFsdWUudmFsdWU7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjQWNrKHJwY0Fjay5yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyB0cmFjayBzdWJzY3JpcHRpb24gcGVybWlzc2lvbnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkOiB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSxcclxuICAgICAgICBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXHJcbiAgICAgIH0pKTtcclxuICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyh0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSwgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMubWFwKHAgPT4gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwKSkpO1xyXG4gICAgfTtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHRoaXMub25UcmFja1VubXV0ZWQgPSB0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc1Vwc3RyZWFtUGF1c2VkKTtcclxuICAgIH07XHJcbiAgICAvLyB3aGVuIHRoZSBsb2NhbCB0cmFjayBjaGFuZ2VzIGluIG11dGUgc3RhdHVzLCB3ZSdsbCBub3RpZnkgc2VydmVyIGFzIHN1Y2hcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHRoaXMub25UcmFja011dGVkID0gKHRyYWNrLCBtdXRlZCkgPT4ge1xyXG4gICAgICBpZiAobXV0ZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG11dGVkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRyYWNrLnNpZCkge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgdXBkYXRlIG11dGUgc3RhdHVzIGZvciB1bnB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbmdpbmUudXBkYXRlTXV0ZVN0YXR1cyh0cmFjay5zaWQsIG11dGVkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uVHJhY2tVcHN0cmVhbVBhdXNlZCA9IHRyYWNrID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHBhdXNlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRydWUpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCA9IHRyYWNrID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHJlc3VtZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc011dGVkKTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlID0gdHJhY2sgPT4ge1xyXG4gICAgICBjb25zdCBwdWIgPSB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYWNrLnNpZCk7XHJcbiAgICAgIGlmICghcHViKSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCB1cGRhdGUgbG9jYWwgYXVkaW8gdHJhY2sgc2V0dGluZ3MsIG1pc3NpbmcgcHVibGljYXRpb24gZm9yIHRyYWNrIFwiLmNvbmNhdCh0cmFjay5zaWQpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayhwdWIudHJhY2tTaWQsIHB1Yi5nZXRUcmFja0ZlYXR1cmVzKCkpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1cGRhdGUgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xyXG4gICAgICB2YXIgX2Q7XHJcbiAgICAgIGlmICghKChfZCA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5keW5hY2FzdCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmdldCh1cGRhdGUudHJhY2tTaWQpO1xyXG4gICAgICBpZiAoIXB1Yikge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3JlY2VpdmVkIHN1YnNjcmliZWQgcXVhbGl0eSB1cGRhdGUgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIHRyYWNrU2lkOiB1cGRhdGUudHJhY2tTaWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghcHViLnZpZGVvVHJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmV3Q29kZWNzID0geWllbGQgcHViLnZpZGVvVHJhY2suc2V0UHVibGlzaGluZ0NvZGVjcyh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBuZXdDb2RlY3NfMSA9IF9fYXN5bmNWYWx1ZXMobmV3Q29kZWNzKSwgbmV3Q29kZWNzXzFfMTsgbmV3Q29kZWNzXzFfMSA9IHlpZWxkIG5ld0NvZGVjc18xLm5leHQoKSwgX2EgPSBuZXdDb2RlY3NfMV8xLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XHJcbiAgICAgICAgICBfYyA9IG5ld0NvZGVjc18xXzEudmFsdWU7XHJcbiAgICAgICAgICBfZSA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3QgY29kZWMgPSBfYztcclxuICAgICAgICAgIGlmIChpc0JhY2t1cENvZGVjKGNvZGVjKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2ggXCIuY29uY2F0KGNvZGVjLCBcIiBmb3IgXCIpLmNvbmNhdChwdWIudmlkZW9UcmFjay5zaWQpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSkpO1xyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XHJcbiAgICAgICAgZV8xID0ge1xyXG4gICAgICAgICAgZXJyb3I6IGVfMV8xXHJcbiAgICAgICAgfTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gbmV3Q29kZWNzXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChuZXdDb2RlY3NfMSk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYW5kbGVMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSB1bnB1Ymxpc2hlZCA9PiB7XHJcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodW5wdWJsaXNoZWQudHJhY2tTaWQpO1xyXG4gICAgICBpZiAoIXRyYWNrKSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgdW5wdWJsaXNoZWQgZXZlbnQgZm9yIHVua25vd24gdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjay50cmFjayk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gdHJhY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbykge1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnB1Ymxpc2hpbmcgbG9jYWwgdHJhY2sgZHVlIHRvIFRyYWNrRW5kZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHJhY2suaXNVc2VyUHJvdmlkZWQpIHtcclxuICAgICAgICB5aWVsZCB0cmFjay5tdXRlKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQZXJtaXNzaW9ucyA9IHlpZWxkIG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGVybWlzc2lvbiBxdWVyeSBmb3IgY2FtZXJhIGFuZCBtaWNyb3Bob25lIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIFNhZmFyaSBhbmQgRmlyZWZveFxyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICAgICAgbmFtZTogdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhID8gJ2NhbWVyYScgOiAnbWljcm9waG9uZSdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zICYmIGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSA9PT0gJ2RlbmllZCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJ1c2VyIGhhcyByZXZva2VkIGFjY2VzcyB0byBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGdyYW50ZWQgY2hhbmdlIGFmdGVyIHBlcm1pc3Npb25zIHdlcmUgZGVuaWVkIHRvIHRyeSBhbmQgcmVzdW1lIHRoZW5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSAhPT0gJ2RlbmllZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHZXRVc2VyTWVkaWEgUGVybWlzc2lvbiBkZW5pZWQnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9ucyBxdWVyeSBmYWlscyBmb3IgZmlyZWZveCwgd2UgY29udGludWUgYW5kIHRyeSB0byByZXN0YXJ0IHRoZSB0cmFja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXRyYWNrLmlzTXV0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIGVuZGVkLCBhdHRlbXB0aW5nIHRvIHVzZSBhIGRpZmZlcmVudCBkZXZpY2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCBkZXZpY2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKHtcclxuICAgICAgICAgICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJjb3VsZCBub3QgcmVzdGFydCB0cmFjaywgbXV0aW5nIGluc3RlYWRcIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICB0aGlzLnJvb21PcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMuc2V0dXBFbmdpbmUoZW5naW5lKTtcclxuICAgIHRoaXMuYWN0aXZlRGV2aWNlTWFwID0gbmV3IE1hcChbWydhdWRpb2lucHV0JywgJ2RlZmF1bHQnXSwgWyd2aWRlb2lucHV0JywgJ2RlZmF1bHQnXSwgWydhdWRpb291dHB1dCcsICdkZWZhdWx0J11dKTtcclxuICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5ycGNIYW5kbGVycyA9IHJvb21ScGNIYW5kbGVycztcclxuICB9XHJcbiAgZ2V0IGxhc3RDYW1lcmFFcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xyXG4gIH1cclxuICBnZXQgbGFzdE1pY3JvcGhvbmVFcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLm1pY3JvcGhvbmVFcnJvcjtcclxuICB9XHJcbiAgZ2V0IGlzRTJFRUVuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XHJcbiAgfVxyXG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlKSB7XHJcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSkge1xyXG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpO1xyXG4gICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgIHJldHVybiB0cmFjaztcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgc2V0dXBFbmdpbmUoZW5naW5lKSB7XHJcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJlbW90ZU11dGUsICh0cmFja1NpZCwgbXV0ZWQpID0+IHtcclxuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodHJhY2tTaWQpO1xyXG4gICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChtdXRlZCkge1xyXG4gICAgICAgIHB1Yi5tdXRlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHViLnVubXV0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCB0aGlzLmhhbmRsZVNpZ25hbENvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKS5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVxdWVzdFJlc3BvbnNlLCB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpO1xyXG4gICAgdGhpcy5zaWduYWxDb25uZWN0ZWRGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG1ldGFkYXRhIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cclxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cclxuICAgKiBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zXHJcbiAgICogQHBhcmFtIG1ldGFkYXRhXHJcbiAgICovXHJcbiAgc2V0TWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHlpZWxkIHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcclxuICAgICAgICBtZXRhZGF0YVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBuYW1lIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudC5cclxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cclxuICAgKiBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zXHJcbiAgICogQHBhcmFtIG1ldGFkYXRhXHJcbiAgICovXHJcbiAgc2V0TmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7XHJcbiAgICAgICAgbmFtZVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXQgb3IgdXBkYXRlIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMuIEl0IHdpbGwgbWFrZSB1cGRhdGVzIG9ubHkgdG8ga2V5cyB0aGF0XHJcbiAgICogYXJlIHByZXNlbnQgaW4gYGF0dHJpYnV0ZXNgLCBhbmQgd2lsbCBub3Qgb3ZlcnJpZGUgb3RoZXJzLlxyXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxyXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXHJcbiAgICovXHJcbiAgc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7XHJcbiAgICAgICAgYXR0cmlidXRlc1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXF1ZXN0TWV0YWRhdGFVcGRhdGUoX2EpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgIGxldCB7XHJcbiAgICAgICAgbWV0YWRhdGEsXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBhdHRyaWJ1dGVzXHJcbiAgICAgIH0gPSBfcmVmO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgaXNSZWplY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEoKF9hID0gbWV0YWRhdGEgIT09IG51bGwgJiYgbWV0YWRhdGEgIT09IHZvaWQgMCA/IG1ldGFkYXRhIDogdGhpcy5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIChfYiA9IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IHRoaXMubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwge1xyXG4gICAgICAgICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgICAgICAgcmVqZWN0OiBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgaXNSZWplY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB3aGlsZSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUgPCA1MDAwICYmICFpc1JlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCghbmFtZSB8fCB0aGlzLm5hbWUgPT09IG5hbWUpICYmICghbWV0YWRhdGEgfHwgdGhpcy5tZXRhZGF0YSA9PT0gbWV0YWRhdGEpICYmICghYXR0cmlidXRlcyB8fCBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5ldmVyeShfcmVmMiA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV0gPT09IHZhbHVlIHx8IHZhbHVlID09PSAnJyAmJiAhdGhpcy5hdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgICAgfSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlamVjdChuZXcgU2lnbmFsUmVxdWVzdEVycm9yKCdSZXF1ZXN0IHRvIHVwZGF0ZSBsb2NhbCBtZXRhZGF0YSB0aW1lZCBvdXQnLCAnVGltZW91dEVycm9yJykpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSByZWplY3QoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIGNhbWVyYSB0cmFjay5cclxuICAgKlxyXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXHJcbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIHNldENhbWVyYUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuQ2FtZXJhLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrLlxyXG4gICAqXHJcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cclxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgc2V0TWljcm9waG9uZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSwgZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTdGFydCBvciBzdG9wIHNoYXJpbmcgYSBwYXJ0aWNpcGFudCdzIHNjcmVlblxyXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcclxuICAgKi9cclxuICBzZXRTY3JlZW5TaGFyZUVuYWJsZWQoZW5hYmxlZCwgb3B0aW9ucywgcHVibGlzaE9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XHJcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xyXG4gICAgY29uc3QgY2hhbmdlZCA9IHN1cGVyLnNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcclxuICAgIGlmIChjaGFuZ2VkICYmIHByZXZQZXJtaXNzaW9ucykge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IGVuYWJsZWQgPyBFbmNyeXB0aW9uX1R5cGUuR0NNIDogRW5jcnlwdGlvbl9UeXBlLk5PTkU7XHJcbiAgICAgIHlpZWxkIHRoaXMucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldFRyYWNrRW5hYmxlZChzb3VyY2UsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0VHJhY2tFbmFibGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIGVuYWJsZWRcclxuICAgICAgfSkpO1xyXG4gICAgICBpZiAodGhpcy5yZXB1Ymxpc2hQcm9taXNlKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5yZXB1Ymxpc2hQcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xyXG4gICAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgICAgeWllbGQgdHJhY2sudW5tdXRlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxldCBsb2NhbFRyYWNrcztcclxuICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGlmICghcGVuZGluZ1RyYWNrKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgICAgc291cmNlXHJcbiAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHBlbmRpbmdUcmFjayA9PT0gbnVsbCB8fCBwZW5kaW5nVHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdUcmFjay51bm11dGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdUcmFjaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKHNvdXJjZSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcclxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xyXG4gICAgICAgICAgICAgICAgICB2aWRlbzogKF9hID0gb3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxyXG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XHJcbiAgICAgICAgICAgICAgICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLlNjcmVlblNoYXJlOlxyXG4gICAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVNjcmVlblRyYWNrcyhPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9jYWxUcmFja3MgPT09IG51bGwgfHwgbG9jYWxUcmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsVHJhY2tzLmZvckVhY2godHIgPT4ge1xyXG4gICAgICAgICAgICAgIHRyLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgZSwgc291cmNlVG9LaW5kKHNvdXJjZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgaXNBdWRpb1RyYWNrKGxvY2FsVHJhY2spICYmIChwdWJsaXNoT3B0aW9ucyA9PT0gbnVsbCB8fCBwdWJsaXNoT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHVibGlzaE9wdGlvbnMucHJlQ29ubmVjdEJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdzdGFydGluZyBwcmVjb25uZWN0IGJ1ZmZlciBmb3IgbWljcm9waG9uZScsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgICAgICAgICAgIGxvY2FsVHJhY2suc3RhcnRQcmVDb25uZWN0QnVmZmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hQcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdwdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKGxvY2FsVHJhY2spKSk7XHJcbiAgICAgICAgICAgICAgcHVibGlzaFByb21pc2VzLnB1c2godGhpcy5wdWJsaXNoVHJhY2sobG9jYWxUcmFjaywgcHVibGlzaE9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwdWJsaXNoZWRUcmFja3MgPSB5aWVsZCBQcm9taXNlLmFsbChwdWJsaXNoUHJvbWlzZXMpO1xyXG4gICAgICAgICAgICAvLyBmb3Igc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9ucyBpbmNsdWRpbmcgYXVkaW8sIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0aGUgc2NyZWVuIHNoYXJlIHB1YmxpY2F0aW9uLCBub3QgdGhlIHNjcmVlbiBzaGFyZSBhdWRpbyBvbmVcclxuICAgICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcclxuICAgICAgICAgICAgW3RyYWNrXSA9IHB1Ymxpc2hlZFRyYWNrcztcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9jYWxUcmFja3MgPT09IG51bGwgfHwgbG9jYWxUcmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsVHJhY2tzLmZvckVhY2godHIgPT4ge1xyXG4gICAgICAgICAgICAgIHRyLnN0b3AoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoISh0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2sudHJhY2spICYmIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gdHJhY2sgYXZhaWxhYmxlIHlldCBmaXJzdCB3YWl0IGZvciBwZW5kaW5nIHB1Ymxpc2hpbmcgcHJvbWlzZXMgb2YgdGhhdCBzb3VyY2UgdG8gc2VlIGlmIGl0IGJlY29tZXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICB0cmFjayA9IHlpZWxkIHRoaXMud2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSk7XHJcbiAgICAgICAgICBpZiAoIXRyYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dhaXRpbmcgZm9yIHBlbmRpbmcgcHVibGljYXRpb24gcHJvbWlzZSB0aW1lZCBvdXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgICBzb3VyY2VcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2sudHJhY2spIHtcclxuICAgICAgICAgIC8vIHNjcmVlbnNoYXJlIGNhbm5vdCBiZSBtdXRlZCwgdW5wdWJsaXNoIGluc3RlYWRcclxuICAgICAgICAgIGlmIChzb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSkge1xyXG4gICAgICAgICAgICB0cmFjayA9IHlpZWxkIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2spO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JlZW5BdWRpb1RyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKTtcclxuICAgICAgICAgICAgaWYgKHNjcmVlbkF1ZGlvVHJhY2sgJiYgc2NyZWVuQXVkaW9UcmFjay50cmFjaykge1xyXG4gICAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXHJcbiAgICogZGlzcGxheWluZyBhIHNpbmdsZSBQZXJtaXNzaW9uIERpYWxvZyBib3ggdG8gdGhlIGVuZCB1c2VyLlxyXG4gICAqL1xyXG4gIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHwgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpKSB7XHJcbiAgICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKFRyYWNrLlNvdXJjZS5DYW1lcmEpO1xyXG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xyXG4gICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodHJhY2sgPT4gdGhpcy5wdWJsaXNoVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGxvY2FsIGNhbWVyYSBhbmQvb3IgbWljcm9waG9uZSB0cmFja3NcclxuICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgY3JlYXRlVHJhY2tzKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcclxuICAgICAgY29uc3QgbWVyZ2VkT3B0aW9uc1dpdGhQcm9jZXNzb3JzID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCAoX2EgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXVkaW9DYXB0dXJlRGVmYXVsdHMsIChfYiA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3MobWVyZ2VkT3B0aW9uc1dpdGhQcm9jZXNzb3JzLCB7XHJcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gdHJhY2tzLm1hcCh0cmFjayA9PiB7XHJcbiAgICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdHJhY2suc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcclxuICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0cmFjaztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbG9jYWxUcmFja3M7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcclxuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gZXJyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXHJcbiAgICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gICAqIElmIHsgYXVkaW86IHRydWUgfSwgYW5kIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIGNhcHR1cmUsIGEgTG9jYWxBdWRpb1RyYWNrIGlzIGFsc28gY3JlYXRlZC5cclxuICAgKi9cclxuICBjcmVhdGVTY3JlZW5UcmFja3Mob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxNygpKSB7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjb25zdHJhaW4gdGhlIGRpbWVuc2lvbnMsIG90aGVyd2lzZSBpdCBjb3VsZCBsZWFkIHRvIGxvdyBiaXRyYXRlXHJcbiAgICAgICAgLy8gZHVlIHRvIGVuY29kaW5nIGEgaHVnZSB2aWRlby4gRW5jb2Rpbmcgc3VjaCBsYXJnZSBzdXJmYWNlcyBpcyByZWFsbHkgZXhwZW5zaXZlXHJcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSBTYWZhcmkgMTcgaGFzIGEgYnV0IGFuZCBjYW5ub3QgYmUgY29uc3RyYWluZWQgYnkgZGVmYXVsdFxyXG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XHJcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xyXG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzY3JlZW5WaWRlbyA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2tzWzBdLCB1bmRlZmluZWQsIGZhbHNlLCB7XHJcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICAgIH0pO1xyXG4gICAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XHJcbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRIaW50KSB7XHJcbiAgICAgICAgc2NyZWVuVmlkZW8ubWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9IG9wdGlvbnMuY29udGVudEhpbnQ7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSBbc2NyZWVuVmlkZW9dO1xyXG4gICAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcclxuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2NyZWVuQXVkaW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW87XHJcbiAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGxvY2FsVHJhY2tzO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFB1Ymxpc2ggYSBuZXcgdHJhY2sgdG8gdGhlIHJvb21cclxuICAgKiBAcGFyYW0gdHJhY2tcclxuICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHB1Ymxpc2hUcmFjayh0cmFjaywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrXzEsIG9wdGlvbnNfMSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHRyYWNrLCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICBsZXQgaXNSZXB1Ymxpc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgICAgdHJhY2suc2V0QXVkaW9Db250ZXh0KF90aGlzMi5hdWRpb0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczIucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcclxuICAgICAgICBpZiAoX3RoaXMyLnJlcHVibGlzaFByb21pc2UgJiYgIWlzUmVwdWJsaXNoKSB7XHJcbiAgICAgICAgICB5aWVsZCBfdGhpczIucmVwdWJsaXNoUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTG9jYWxUcmFjayh0cmFjaykgJiYgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuaGFzKHRyYWNrKSkge1xyXG4gICAgICAgICAgeWllbGQgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlZmF1bHRDb25zdHJhaW50cztcclxuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XHJcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyB3ZSB3YW50IHRvIGFjY2VzcyBjb25zdHJhaW50cyBkaXJlY3RseSBhcyBgdHJhY2subWVkaWFTdHJlYW1UcmFja2BcclxuICAgICAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcclxuICAgICAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IHRyYWNrLmNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgbGV0IGRldmljZUtpbmQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBzd2l0Y2ggKHRyYWNrLnNvdXJjZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lOlxyXG4gICAgICAgICAgICAgIGRldmljZUtpbmQgPSAnYXVkaW9pbnB1dCc7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcclxuICAgICAgICAgICAgICBkZXZpY2VLaW5kID0gJ3ZpZGVvaW5wdXQnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGRldmljZUtpbmQgJiYgX3RoaXMyLmFjdGl2ZURldmljZU1hcC5oYXMoZGV2aWNlS2luZCkpIHtcclxuICAgICAgICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uc3RyYWludHMpLCB7XHJcbiAgICAgICAgICAgICAgZGV2aWNlSWQ6IF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb252ZXJ0IHJhdyBtZWRpYSB0cmFjayBpbnRvIGF1ZGlvIG9yIHZpZGVvIHRyYWNrXHJcbiAgICAgICAgaWYgKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykge1xyXG4gICAgICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcclxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbEF1ZGlvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwgX3RoaXMyLmF1ZGlvQ29udGV4dCwge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IF90aGlzMi5sb2dDb250ZXh0XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcclxuICAgICAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IF90aGlzMi5sb2dDb250ZXh0XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgTWVkaWFTdHJlYW1UcmFjayBraW5kIFwiLmNvbmNhdCh0cmFjay5raW5kKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyYWNrLnVwZGF0ZUxvZ2dlck9wdGlvbnMoe1xyXG4gICAgICAgICAgICBsb2dnZXJOYW1lOiBfdGhpczIucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlzIGl0IGFscmVhZHkgcHVibGlzaGVkPyBpZiBzbyBza2lwXHJcbiAgICAgICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb247XHJcbiAgICAgICAgX3RoaXMyLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xyXG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbi50cmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nUHVibGljYXRpb24gPSBwdWJsaWNhdGlvbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xyXG4gICAgICAgICAgX3RoaXMyLmxvZy53YXJuKCd0cmFjayBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1B1YmxpY2F0aW9uKSkpO1xyXG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUHVibGljYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPSAnY2hhbm5lbENvdW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxyXG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5jaGFubmVsQ291bnQgPT09IDIgfHwgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpLmNoYW5uZWxDb3VudCA9PT0gMjtcclxuICAgICAgICBjb25zdCBpc1N0ZXJlbyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVN0ZXJlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaXNTdGVyZW9JbnB1dDtcclxuICAgICAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcclxuICAgICAgICBpZiAoaXNTdGVyZW8pIHtcclxuICAgICAgICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIk9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKF9jID0gb3B0aW9ucy5kdHgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wdGlvbnMuZHR4ID0gZmFsc2U7XHJcbiAgICAgICAgICAoX2QgPSBvcHRpb25zLnJlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogb3B0aW9ucy5yZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLnJvb21PcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICghaXNFMkVFU2ltdWxjYXN0U3VwcG9ydGVkKCkgJiYgX3RoaXMyLnJvb21PcHRpb25zLmUyZWUpIHtcclxuICAgICAgICAgIF90aGlzMi5sb2cuaW5mbyhcIkVuZC10by1lbmQgZW5jcnlwdGlvbiBpcyBzZXQgdXAsIHNpbXVsY2FzdCBwdWJsaXNoaW5nIHdpbGwgYmUgZGlzYWJsZWQgb24gU2FmYXJpIHZlcnNpb25zIGFuZCBpT1MgYnJvd3NlcnMgcnVubmluZyBpT1MgPCB2MTcuMlwiLCBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCkpO1xyXG4gICAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuc291cmNlKSB7XHJcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMyLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZ2luZS5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlZmVycmluZyB0cmFjayBwdWJsaWNhdGlvbiB1bnRpbCBzaWduYWwgaXMgY29ubmVjdGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICAgICAgICB0cmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaylcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQdWJsaXNoVHJhY2tFcnJvcigncHVibGlzaGluZyByZWplY3RlZCBhcyBlbmdpbmUgbm90IGNvbm5lY3RlZCB3aXRoaW4gdGltZW91dCcsIDQwOCkpO1xyXG4gICAgICAgICAgICAgIH0sIDE1MDAwKTtcclxuICAgICAgICAgICAgICB5aWVsZCB0aGlzLndhaXRVbnRpbEVuZ2luZUNvbm5lY3RlZCgpO1xyXG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwdWJsaWNhdGlvbik7XHJcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLnNldCh0cmFjaywgcHVibGlzaFByb21pc2UpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xyXG4gICAgICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmRlbGV0ZSh0cmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgd2FpdFVudGlsRW5naW5lQ29ubmVjdGVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSkge1xyXG4gICAgICB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZSA9IG5ldyBGdXR1cmUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnNpZ25hbENvbm5lY3RlZEZ1dHVyZS5wcm9taXNlO1xyXG4gIH1cclxuICBoYXNQZXJtaXNzaW9uc1RvUHVibGlzaCh0cmFjaykge1xyXG4gICAgaWYgKCF0aGlzLnBlcm1pc3Npb25zKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ25vIHBlcm1pc3Npb25zIHByZXNlbnQgZm9yIHB1Ymxpc2hpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHtcclxuICAgICAgY2FuUHVibGlzaCxcclxuICAgICAgY2FuUHVibGlzaFNvdXJjZXNcclxuICAgIH0gPSB0aGlzLnBlcm1pc3Npb25zO1xyXG4gICAgaWYgKGNhblB1Ymxpc2ggJiYgKGNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCA9PT0gMCB8fCBjYW5QdWJsaXNoU291cmNlcy5tYXAoc291cmNlID0+IGdldFRyYWNrU291cmNlRnJvbVByb3RvKHNvdXJjZSkpLmluY2x1ZGVzKHRyYWNrLnNvdXJjZSkpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2cud2FybignaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zIHRvIHB1Ymxpc2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XHJcbiAgICAgIGlmICghdGhpcy5oYXNQZXJtaXNzaW9uc1RvUHVibGlzaCh0cmFjaykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ2ZhaWxlZCB0byBwdWJsaXNoIHRyYWNrLCBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnLCA0MDMpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChwdWJsaXNoZWRUcmFjayA9PiBpc0xvY2FsVHJhY2sodHJhY2spICYmIHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gdHJhY2suc291cmNlKTtcclxuICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcInB1Ymxpc2hpbmcgYSBzZWNvbmQgdHJhY2sgd2l0aCB0aGUgc2FtZSBzb3VyY2U6IFwiLmNvbmNhdCh0cmFjay5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdHMuc3RvcE1pY1RyYWNrT25NdXRlICYmIGlzQXVkaW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICB0cmFjay5zdG9wT25NdXRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgaXNGaXJlRm94KCkpIHtcclxuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHNpbXVsY2FzdGVkIHNjcmVlbiBzaGFyZVxyXG4gICAgICAgIC8vIHdlIGZyZXF1ZW50bHkgZ2V0IG5vIGRhdGEgb24gbGF5ZXIgMCB3aGVuIGVuYWJsZWRcclxuICAgICAgICBvcHRzLnNpbXVsY2FzdCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJlcXVpcmUgZnVsbCBBVjEvVlA5IFNWQyBzdXBwb3J0IHByaW9yIHRvIHVzaW5nIGl0XHJcbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICdhdjEnICYmICFzdXBwb3J0c0FWMSgpKSB7XHJcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICd2cDknICYmICFzdXBwb3J0c1ZQOSgpKSB7XHJcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IGRlZmF1bHRWaWRlb0NvZGVjO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGEgc3VwcG9ydGVkIGNvZGVjIGlmIGl0IGlzIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcy5zb21lKGMgPT4gb3B0cy52aWRlb0NvZGVjID09PSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhjLm1pbWUpKSkge1xyXG4gICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzWzBdLm1pbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2aWRlb0NvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xyXG4gICAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcclxuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xyXG4gICAgICBjb25zdCBhdWRpb0ZlYXR1cmVzID0gW107XHJcbiAgICAgIGNvbnN0IGRpc2FibGVEdHggPSAhKChfYSA9IG9wdHMuZHR4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcclxuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTb3VyY2VUcmFja1NldHRpbmdzKCk7XHJcbiAgICAgIGlmIChzZXR0aW5ncy5hdXRvR2FpbkNvbnRyb2wpIHtcclxuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfQVVUT19HQUlOX0NPTlRST0wpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZXR0aW5ncy5lY2hvQ2FuY2VsbGF0aW9uKSB7XHJcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VDSE9fQ0FOQ0VMTEFUSU9OKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2V0dGluZ3Mubm9pc2VTdXBwcmVzc2lvbikge1xyXG4gICAgICAgIGF1ZGlvRmVhdHVyZXMucHVzaChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT0lTRV9TVVBQUkVTU0lPTik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNldHRpbmdzLmNoYW5uZWxDb3VudCAmJiBzZXR0aW5ncy5jaGFubmVsQ291bnQgPiAxKSB7XHJcbiAgICAgICAgYXVkaW9GZWF0dXJlcy5wdXNoKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1NURVJFTyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRpc2FibGVEdHgpIHtcclxuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfTk9fRFRYKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spICYmIHRyYWNrLmhhc1ByZUNvbm5lY3RCdWZmZXIpIHtcclxuICAgICAgICBhdWRpb0ZlYXR1cmVzLnB1c2goQXVkaW9UcmFja0ZlYXR1cmUuVEZfUFJFQ09OTkVDVF9CVUZGRVIpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGNyZWF0ZSB0cmFjayBwdWJsaWNhdGlvbiBmcm9tIHRyYWNrXHJcbiAgICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xyXG4gICAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXHJcbiAgICAgICAgY2lkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxyXG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcclxuICAgICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcclxuICAgICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcclxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcclxuICAgICAgICBkaXNhYmxlRHR4LFxyXG4gICAgICAgIGVuY3J5cHRpb246IHRoaXMuZW5jcnlwdGlvblR5cGUsXHJcbiAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcclxuICAgICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgISgoX2IgPSBvcHRzLnJlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSksXHJcbiAgICAgICAgc3RyZWFtOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuc3RyZWFtLFxyXG4gICAgICAgIGJhY2t1cENvZGVjUG9saWN5OiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYmFja3VwQ29kZWNQb2xpY3ksXHJcbiAgICAgICAgYXVkaW9GZWF0dXJlc1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cclxuICAgICAgbGV0IGVuY29kaW5ncztcclxuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcclxuICAgICAgICBsZXQgZGltcyA9IHtcclxuICAgICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgICAgaGVpZ2h0OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZGltcyA9IHlpZWxkIHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgLy8gdXNlIGRlZmF1bHRzLCBpdCdzIHF1aXRlIHBhaW5mdWwgZm9yIGNvbmdlc3Rpb24gY29udHJvbCB3aXRob3V0IHNpbXVsY2FzdFxyXG4gICAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXHJcbiAgICAgICAgICBjb25zdCBkZWZhdWx0UmVzID0gKF9kID0gKF9jID0gdGhpcy5yb29tT3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc29sdXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFZpZGVvUHJlc2V0cy5oNzIwLnJlc29sdXRpb247XHJcbiAgICAgICAgICBkaW1zID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBkZWZhdWx0UmVzLmhlaWdodFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIC8vIGxvZyBmYWlsdXJlXHJcbiAgICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcclxuICAgICAgICAgICAgZGltc1xyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xyXG4gICAgICAgIHJlcS53aWR0aCA9IGRpbXMud2lkdGg7XHJcbiAgICAgICAgcmVxLmhlaWdodCA9IGRpbXMuaGVpZ2h0O1xyXG4gICAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXHJcbiAgICAgICAgaWYgKGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgICAgaWYgKGlzU1ZDQ29kZWModmlkZW9Db2RlYykpIHtcclxuICAgICAgICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XHJcbiAgICAgICAgICAgICAgLy8gdnA5IHN2YyB3aXRoIHNjcmVlbnNoYXJlIGNhbm5vdCBlbmNvZGUgbXVsdGlwbGUgc3BhdGlhbCBsYXllcnNcclxuICAgICAgICAgICAgICAvLyBkb2luZyBzbyByZWR1Y2VzIHB1Ymxpc2ggcmVzb2x1dGlvbiB0byBtaW5pbWFsIHJlc29sdXRpb25cclxuICAgICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcclxuICAgICAgICAgICAgICAvLyBDaHJvbWUgZG9lcyBub3QgYWxsb3cgbW9yZSB0aGFuIDUgZnBzIHdpdGggTDFUMywgYW5kIGl0IGhhcyBlbmNvZGluZyBidWdzIHdpdGggTDNUM1xyXG4gICAgICAgICAgICAgIC8vIEl0IGhhcyBhIGRpZmZlcmVudCBwYXRoIGZvciBzY3JlZW5zaGFyZSBoYW5kbGluZyBhbmQgaXQgc2VlbXMgdG8gYmUgdW50ZXN0ZWQvYnVnZ3lcclxuICAgICAgICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHdlIGFyZSBzZXR0aW5nIGNvbnRlbnRIaW50IHRvIGZvcmNlIGl0IHRvIGdvIHRocm91Z2ggdGhlIHNhbWVcclxuICAgICAgICAgICAgICAvLyBwYXRoIGFzIHJlZ3VsYXIgY2FtZXJhIHZpZGVvLiBXaGlsZSB0aGlzIGlzIG5vdCBvcHRpbWFsLCBpdCBkZWxpdmVycyB0aGUgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgICAvLyB0aGF0IHdlIG5lZWRcclxuICAgICAgICAgICAgICBpZiAoJ2NvbnRlbnRIaW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gJ21vdGlvbic7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdmb3JjaW5nIGNvbnRlbnRIaW50IHRvIG1vdGlvbiBmb3Igc2NyZWVuc2hhcmUgd2l0aCBTVkMgY29kZWNzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9IChfZSA9IG9wdHMuc2NhbGFiaWxpdHlNb2RlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnTDNUM19LRVknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcyA9IFtuZXcgU2ltdWxjYXN0Q29kZWMoe1xyXG4gICAgICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcclxuICAgICAgICAgICAgY2lkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXHJcbiAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAvLyBzZXQgdXAgYmFja3VwXHJcbiAgICAgICAgICBpZiAob3B0cy5iYWNrdXBDb2RlYyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0ge1xyXG4gICAgICAgICAgICAgIGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgJiYgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxyXG4gICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgY29kZWNzXHJcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUpIHtcclxuICAgICAgICAgICAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0IHJlcXVpcmVzIGR5bmFjYXN0XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yb29tT3B0aW9ucy5keW5hY2FzdCkge1xyXG4gICAgICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcS5zaW11bGNhc3RDb2RlY3MucHVzaChuZXcgU2ltdWxjYXN0Q29kZWMoe1xyXG4gICAgICAgICAgICAgIGNvZGVjOiBvcHRzLmJhY2t1cENvZGVjLmNvZGVjLFxyXG4gICAgICAgICAgICAgIGNpZDogJydcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHJlcS53aWR0aCwgcmVxLmhlaWdodCwgb3B0cyk7XHJcbiAgICAgICAgcmVxLmxheWVycyA9IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyhyZXEud2lkdGgsIHJlcS5oZWlnaHQsIGVuY29kaW5ncywgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpKTtcclxuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XHJcbiAgICAgICAgZW5jb2RpbmdzID0gW3tcclxuICAgICAgICAgIG1heEJpdHJhdGU6IChfZiA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXhCaXRyYXRlLFxyXG4gICAgICAgICAgcHJpb3JpdHk6IChfaCA9IChfZyA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wcmlvcml0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogJ2hpZ2gnLFxyXG4gICAgICAgICAgbmV0d29ya1ByaW9yaXR5OiAoX2sgPSAoX2ogPSBvcHRzLmF1ZGlvUHJlc2V0KSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucHJpb3JpdHkpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6ICdoaWdoJ1xyXG4gICAgICAgIH1dO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY2Fubm90IHB1Ymxpc2ggdHJhY2sgd2hlbiBub3QgY29ubmVjdGVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgbmVnb3RpYXRlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncGNNYW5hZ2VyIGlzIG5vdCByZWFkeScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjay5zZW5kZXIgPSB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XHJcbiAgICAgICAgaWYgKGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xyXG4gICAgICAgICAgKF9hID0gb3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdHMuZGVncmFkYXRpb25QcmVmZXJlbmNlID0gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjayk7XHJcbiAgICAgICAgICB0cmFjay5zZXREZWdyYWRhdGlvblByZWZlcmVuY2Uob3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XHJcbiAgICAgICAgICBpZiAoaXNGaXJlRm94KCkgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xyXG4gICAgICAgICAgICAvKiBSZWZlciB0byBSRkMgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3NTg3I3NlY3Rpb24tNi4xLFxyXG4gICAgICAgICAgICAgICBsaXZla2l0LXNlcnZlciB1c2VzIG1heGF2ZXJhZ2ViaXRyYXRlPTUxMDAwMCBpbiB0aGUgYW5zd2VyIHNkcCB0byBwZXJtaXQgY2xpZW50IHRvXHJcbiAgICAgICAgICAgICAgIHB1Ymxpc2ggaGlnaCBxdWFsaXR5IGF1ZGlvIHRyYWNrLiBCdXQgZmlyZWZveCBhbHdheXMgdXNlcyB0aGlzIHZhbHVlIGFzIHRoZSBhY3R1YWxcclxuICAgICAgICAgICAgICAgYml0cmF0ZXMsIGNhdXNpbmcgdGhlIGF1ZGlvIGJpdHJhdGVzIHRvIHJpc2UgdG8gNTEwS2JwcyBpbiBhbnkgc3RlcmVvIGNhc2UgdW5leHBlY3RlZGx5LlxyXG4gICAgICAgICAgICAgICBTbyB0aGUgY2xpZW50IG5lZWQgdG8gbW9kaWZ5IG1heGF2ZXJyYWdlYml0cmF0ZXMgaW4gYW5zd2VyIHNkcCB0byB1c2VyIHByb3ZpZGVkIHZhbHVlIHRvXHJcbiAgICAgICAgICAgICAgIGZpeCB0aGUgaXNzdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsZXQgdHJhY2tUcmFuc2NlaXZlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRlciA9PT0gdHJhY2suc2VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcclxuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxyXG4gICAgICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcclxuICAgICAgICAgICAgICAgIG1heGJyOiAoKF9iID0gZW5jb2RpbmdzWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4Qml0cmF0ZSkgPyBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAgOiAwXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2suY29kZWMgJiYgaXNTVkNDb2RlYyh0cmFjay5jb2RlYykgJiYgKChfYyA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1heEJpdHJhdGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuc2V0VHJhY2tDb2RlY0JpdHJhdGUoe1xyXG4gICAgICAgICAgICAgIGNpZDogcmVxLmNpZCxcclxuICAgICAgICAgICAgICBjb2RlYzogdHJhY2suY29kZWMsXHJcbiAgICAgICAgICAgICAgbWF4YnI6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gMTAwMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQgdGk7XHJcbiAgICAgIGNvbnN0IGFkZFRyYWNrUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRpID0geWllbGQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcclxuICAgICAgICAgIHJlc29sdmUodGkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgaWYgKHRyYWNrLnNlbmRlciAmJiAoKF9hID0gdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVibGlzaGVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnJlbW92ZVRyYWNrKHRyYWNrLnNlbmRlcik7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpLmNhdGNoKG5lZ290aWF0ZUVyciA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2ZhaWxlZCB0byBuZWdvdGlhdGUgYWZ0ZXIgcmVtb3ZpbmcgdHJhY2sgZHVlIHRvIGZhaWxlZCBhZGQgdHJhY2sgcmVxdWVzdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSksIHtcclxuICAgICAgICAgICAgICAgIGVycm9yOiBuZWdvdGlhdGVFcnJcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IHJldHMgPSB5aWVsZCBQcm9taXNlLmFsbChbYWRkVHJhY2tQcm9taXNlLCBuZWdvdGlhdGUoKV0pO1xyXG4gICAgICAgIHRpID0gcmV0c1swXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aSA9IHlpZWxkIGFkZFRyYWNrUHJvbWlzZTtcclxuICAgICAgICAvLyBzZXJ2ZXIgbWlnaHQgbm90IHN1cHBvcnQgdGhlIGNvZGVjIHRoZSBjbGllbnQgaGFzIHJlcXVlc3RlZCwgaW4gdGhhdCBjYXNlLCBmYWxsYmFja1xyXG4gICAgICAgIC8vIHRvIGEgc3VwcG9ydGVkIGNvZGVjXHJcbiAgICAgICAgbGV0IHByaW1hcnlDb2RlY01pbWU7XHJcbiAgICAgICAgdGkuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xyXG4gICAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBwcmltYXJ5Q29kZWNNaW1lID0gY29kZWMubWltZVR5cGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xyXG4gICAgICAgICAgY29uc3QgdXBkYXRlZENvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcocHJpbWFyeUNvZGVjTWltZSk7XHJcbiAgICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gc2VydmVyIHNlbGVjdGVkIGNvZGVjJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xyXG4gICAgICAgICAgICAgIGNvZGVjOiB1cGRhdGVkQ29kZWNcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XHJcbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSBlbmNvZGluZ3Mgc2luY2UgYml0cmF0ZXMvZXRjIGNvdWxkIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBlbmNvZGluZ3MgPSBjb21wdXRlVmlkZW9FbmNvZGluZ3ModHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIHJlcS53aWR0aCwgcmVxLmhlaWdodCwgb3B0cyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIG5lZ290aWF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbih0cmFjay5raW5kLCB0aSwgdHJhY2ssIHtcclxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIHNhdmUgb3B0aW9ucyBmb3Igd2hlbiBpdCBuZWVkcyB0byBiZSByZXB1Ymxpc2hlZCBhZ2FpblxyXG4gICAgICBwdWJsaWNhdGlvbi5vcHRpb25zID0gb3B0cztcclxuICAgICAgdHJhY2suc2lkID0gdGkuc2lkO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hpbmcgXCIuY29uY2F0KHRyYWNrLmtpbmQsIFwiIHdpdGggZW5jb2RpbmdzXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICBlbmNvZGluZ3MsXHJcbiAgICAgICAgdHJhY2tJbmZvOiB0aVxyXG4gICAgICB9KSk7XHJcbiAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IodGhpcy5lbmdpbmUuY2xpZW50KTtcclxuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xyXG4gICAgICAvLyBzZW5kIGV2ZW50IGZvciBwdWJsaWNhdGlvblxyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XHJcbiAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgJiYgdGkuYXVkaW9GZWF0dXJlcy5pbmNsdWRlcyhBdWRpb1RyYWNrRmVhdHVyZS5URl9QUkVDT05ORUNUX0JVRkZFUikpIHtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSB0cmFjay5nZXRQcmVDb25uZWN0QnVmZmVyKCk7XHJcbiAgICAgICAgLy8gVE9ETzogd2UncmUgcmVnaXN0ZXJpbmcgdGhlIGxpc3RlbmVyIGFmdGVyIG5lZ290aWF0aW9uLCBzbyB0aGVyZSBtaWdodCBiZSBhIHJhY2VcclxuICAgICAgICB0aGlzLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHB1YiA9PiB7XHJcbiAgICAgICAgICBpZiAocHViLnRyYWNrU2lkID09PSB0aS5zaWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0cmFjay5oYXNQcmVDb25uZWN0QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5sb2cud2Fybignc3Vic2NyaWJlIGV2ZW50IGNhbWUgdG8gbGF0ZSwgYnVmZmVyIGFscmVhZHkgY2xvc2VkJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2ZpbmlzaGVkIHJlY29yZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgICAgdHJhY2suc3RvcFByZUNvbm5lY3RCdWZmZXIoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoc3RyZWFtKSB7XHJcbiAgICAgICAgICBjb25zdCBidWZmZXJTdHJlYW1Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xyXG4gICAgICAgICAgICB2YXIgX2QsIF9lO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBhZ2VudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgICAgICBjb25zdCBhZ2VudEFjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2FnZW50IG5vdCBhY3RpdmUgd2l0aGluIDEwIHNlY29uZHMnKSk7XHJcbiAgICAgICAgICAgICAgfSwgMTAwMDApO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGFnZW50ID0geWllbGQgdGhpcy53YWl0VW50aWxBY3RpdmVBZ2VudFByZXNlbnQoKTtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWdlbnRBY3RpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBwcmVjb25uZWN0IGJ1ZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcclxuICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnN0cmVhbUJ5dGVzKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcmVjb25uZWN0LWJ1ZmZlcicsXHJcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogJ2F1ZGlvL29wdXMnLFxyXG4gICAgICAgICAgICAgICAgdG9waWM6ICdsay5hZ2VudC5wcmUtY29ubmVjdC1hdWRpby1idWZmZXInLFxyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbYWdlbnQuaWRlbnRpdHldLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgICAgICAgICAgICB0cmFja0lkOiBwdWJsaWNhdGlvbi50cmFja1NpZCxcclxuICAgICAgICAgICAgICAgICAgc2FtcGxlUmF0ZTogU3RyaW5nKChfZCA9IHNldHRpbmdzLnNhbXBsZVJhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICc0ODAwMCcpLFxyXG4gICAgICAgICAgICAgICAgICBjaGFubmVsczogU3RyaW5nKChfZSA9IHNldHRpbmdzLmNoYW5uZWxDb3VudCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJzEnKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHN0cmVhbV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW0pLCBzdHJlYW1fMV8xOyBzdHJlYW1fMV8xID0geWllbGQgc3RyZWFtXzEubmV4dCgpLCBfYSA9IHN0cmVhbV8xXzEuZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgX2MgPSBzdHJlYW1fMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xyXG4gICAgICAgICAgICAgICAgICB5aWVsZCB3cml0ZXIud3JpdGUoY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XHJcbiAgICAgICAgICAgICAgICBlXzIgPSB7XHJcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlXzJfMVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gc3RyZWFtXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChzdHJlYW1fMSk7XHJcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgYnVmZmVyU3RyZWFtUHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3ByZWNvbm5lY3QgYnVmZmVyIHNlbnQgc3VjY2Vzc2Z1bGx5JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xyXG4gICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBzZW5kaW5nIHByZWNvbm5lY3QgYnVmZmVyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xyXG4gICAgICAgICAgICAgIGVycm9yOiBlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHVibGljYXRpb247XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0IGlzTG9jYWwoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbFxyXG4gICAqIHB1Ymxpc2ggYWRkaXRpb25hbCBjb2RlYyB0byBleGlzdGluZyB0cmFja1xyXG4gICAqL1xyXG4gIHB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayh0cmFjaywgdmlkZW9Db2RlYywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAvLyBUT0RPIHJlbW92ZSBvbmNlIGUyZWUgaXMgc3VwcG9ydGVkIGZvciBiYWNrdXAgdHJhY2tzXHJcbiAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICAvLyBpcyBpdCBub3QgcHVibGlzaGVkPyBpZiBzbyBza2lwXHJcbiAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xyXG4gICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xyXG4gICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xyXG4gICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghZXhpc3RpbmdQdWJsaWNhdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd0cmFjayBpcyBub3QgYSB2aWRlbyB0cmFjaycpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcclxuICAgICAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVRyYWNrQmFja3VwRW5jb2RpbmdzKHRyYWNrLCB2aWRlb0NvZGVjLCBvcHRzKTtcclxuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcclxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcclxuICAgICAgaWYgKCFzaW11bGNhc3RUcmFjaykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcclxuICAgICAgICBjaWQ6IHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXHJcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXHJcbiAgICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXHJcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXHJcbiAgICAgICAgc2lkOiB0cmFjay5zaWQsXHJcbiAgICAgICAgc2ltdWxjYXN0Q29kZWNzOiBbe1xyXG4gICAgICAgICAgY29kZWM6IG9wdHMudmlkZW9Db2RlYyxcclxuICAgICAgICAgIGNpZDogc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxyXG4gICAgICAgIH1dXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzKTtcclxuICAgICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZWdvdGlhdGUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcclxuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJldHMgPSB5aWVsZCBQcm9taXNlLmFsbChbdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKSwgbmVnb3RpYXRlKCldKTtcclxuICAgICAgY29uc3QgdGkgPSByZXRzWzBdO1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInB1Ymxpc2hlZCBcIi5jb25jYXQodmlkZW9Db2RlYywgXCIgZm9yIHRyYWNrIFwiKS5jb25jYXQodHJhY2suc2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgZW5jb2RpbmdzLFxyXG4gICAgICAgIHRyYWNrSW5mbzogdGlcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVucHVibGlzaFRyYWNrKHRyYWNrLCBzdG9wT25VbnB1Ymxpc2gpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spKSB7XHJcbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcclxuICAgICAgICBpZiAocHVibGlzaFByb21pc2UpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2F3YWl0aW5nIHB1Ymxpc2ggcHJvbWlzZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB1bnB1Ymxpc2gnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XHJcbiAgICAgICAgICB5aWVsZCBwdWJsaXNoUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gbG9vayB0aHJvdWdoIGFsbCBwdWJsaXNoZWQgdHJhY2tzIHRvIGZpbmQgdGhlIHJpZ2h0IG9uZXNcclxuICAgICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xyXG4gICAgICBjb25zdCBwdWJMb2dDb250ZXh0ID0gcHVibGljYXRpb24gPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSA6IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCkpO1xyXG4gICAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3RyYWNrIHdhcyBub3QgdW5wdWJsaXNoZWQgYmVjYXVzZSBubyBwdWJsaWNhdGlvbiB3YXMgZm91bmQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHB1YkxvZ0NvbnRleHQpKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIHRyYWNrID0gcHVibGljYXRpb24udHJhY2s7XHJcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLm9uVHJhY2tNdXRlZCk7XHJcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xyXG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcclxuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1QYXVzZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUGF1c2VkKTtcclxuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xyXG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSk7XHJcbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2ggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHN0b3BPblVucHVibGlzaCA9IChfYiA9IChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdG9wT25VbnB1Ymxpc2gpIHtcclxuICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJhY2suc3RvcE1vbml0b3IoKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbmVnb3RpYXRpb25OZWVkZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgdHJhY2tTZW5kZXIgPSB0cmFjay5zZW5kZXI7XHJcbiAgICAgIHRyYWNrLnNlbmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgaWYgKHRoaXMuZW5naW5lLnBjTWFuYWdlciAmJiB0aGlzLmVuZ2luZS5wY01hbmFnZXIuY3VycmVudFN0YXRlIDwgUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQgJiYgdHJhY2tTZW5kZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHNlbmRlciBpcyBub3QgY3VycmVudGx5IHNlbmRpbmcgKGFmdGVyIHJlcGxhY2VUcmFjayhudWxsKSlcclxuICAgICAgICAgICAgLy8gcmVtb3ZlVHJhY2sgd291bGQgaGF2ZSBubyBlZmZlY3QuXHJcbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBlbmQgdXAgc3VjY2Vzc2Z1bGx5IHJlbW92aW5nIHRoZSB0cmFjaywgbWFudWFsbHkgc2V0XHJcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2NlaXZlciB0byBpbmFjdGl2ZVxyXG4gICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZGVyID09PSB0cmFja1NlbmRlcikge1xyXG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tTZW5kZXIpKSB7XHJcbiAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbLCB0cmFja0luZm9dIG9mIHRyYWNrLnNpbXVsY2FzdENvZGVjcykge1xyXG4gICAgICAgICAgICAgIGlmICh0cmFja0luZm8uc2VuZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHVucHVibGlzaCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyByZW1vdmUgZnJvbSBvdXIgbWFwc1xyXG4gICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XHJcbiAgICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xyXG4gICAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcclxuICAgICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxyXG4gICAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcclxuICAgICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcclxuICAgICAgaWYgKG5lZ290aWF0aW9uTmVlZGVkKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHVucHVibGlzaFRyYWNrcyh0cmFja3MpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHRyYWNrID0+IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2spKSk7XHJcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcih0cmFjayA9PiAhIXRyYWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXB1Ymxpc2hBbGxUcmFja3Mob3B0aW9uc18xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuICAgICAgbGV0IHJlc3RhcnRUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlmIChfdGhpczMucmVwdWJsaXNoUHJvbWlzZSkge1xyXG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcHVibGlzaFByb21pc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhbFB1YnMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHB1Yi50cmFjaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgcHViLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHB1Yi5vcHRpb25zKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2NhbFB1YnMucHVzaChwdWIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGxvY2FsUHVicy5tYXAocHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcclxuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3RhcnRUcmFja3MgJiYgIXRyYWNrLmlzTXV0ZWQgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyAmJiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkgJiYgIXRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBnZW5lcmFsbHkgd2UgbmVlZCB0byByZXN0YXJ0IHRoZSB0cmFjayBiZWZvcmUgcHVibGlzaGluZywgb2Z0ZW4gYSBmdWxsIHJlY29ubmVjdFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgY29tcHV0ZXIgaGFkIGdvbmUgdG8gc2xlZXAuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVzdGFydGluZyBleGlzdGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICAgICAgICB0cmFjazogcHViLnRyYWNrU2lkXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFjaywgcHViLm9wdGlvbnMsIHRydWUpO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdGhpcy5yZXB1Ymxpc2hQcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB5aWVsZCBfdGhpczMucmVwdWJsaXNoUHJvbWlzZTtcclxuICAgICAgfSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcclxuICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gZmllbGQgaW4gcHVibGlzaE9wdGlvbnMgaXMgZW1wdHlcclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25hbGx5IHNwZWNpZnkgYSBgcmVsaWFibGVgLCBgdG9waWNgIGFuZCBgZGVzdGluYXRpb25gXHJcbiAgICovXHJcbiAgcHVibGlzaERhdGEoZGF0YV8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBraW5kID0gb3B0aW9ucy5yZWxpYWJsZSA/IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSA6IERhdGFQYWNrZXRfS2luZC5MT1NTWTtcclxuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcclxuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnMudG9waWM7XHJcbiAgICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgICAga2luZDoga2luZCxcclxuICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgIGNhc2U6ICd1c2VyJyxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBVc2VyUGFja2V0KHtcclxuICAgICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBfdGhpczQuaWRlbnRpdHksXHJcbiAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcclxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgdG9waWNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB5aWVsZCBfdGhpczQuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCk7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQdWJsaXNoIFNJUCBEVE1GIG1lc3NhZ2UgdG8gdGhlIHJvb20uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29kZSBEVE1GIGNvZGVcclxuICAgKiBAcGFyYW0gZGlnaXQgRFRNRiBkaWdpdFxyXG4gICAqL1xyXG4gIHB1Ymxpc2hEdG1mKGNvZGUsIGRpZ2l0KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBjYXNlOiAnc2lwRHRtZicsXHJcbiAgICAgICAgICB2YWx1ZTogbmV3IFNpcERUTUYoe1xyXG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG4gICAgICAgICAgICBkaWdpdDogZGlnaXRcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNlbmRDaGF0TWVzc2FnZSh0ZXh0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBtc2cgPSB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgbWVzc2FnZTogdGV4dCxcclxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgYXR0YWNoZWRGaWxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtc2cpLCB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cudGltZXN0YW1wKVxyXG4gICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgbXNnKTtcclxuICAgICAgcmV0dXJuIG1zZztcclxuICAgIH0pO1xyXG4gIH1cclxuICBlZGl0Q2hhdE1lc3NhZ2UoZWRpdFRleHQsIG9yaWdpbmFsTWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgbXNnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbE1lc3NhZ2UpLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZWRpdFRleHQsXHJcbiAgICAgICAgZWRpdFRpbWVzdGFtcDogRGF0ZS5ub3coKVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBjYXNlOiAnY2hhdE1lc3NhZ2UnLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1zZyksIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy50aW1lc3RhbXApLFxyXG4gICAgICAgICAgICBlZGl0VGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy5lZGl0VGltZXN0YW1wKVxyXG4gICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgbXNnKTtcclxuICAgICAgcmV0dXJuIG1zZztcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kVGV4dCh0ZXh0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHN0cmVhbUlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcclxuICAgICAgY29uc3QgdGV4dEluQnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XHJcbiAgICAgIGNvbnN0IHRvdGFsVGV4dExlbmd0aCA9IHRleHRJbkJ5dGVzLmJ5dGVMZW5ndGg7XHJcbiAgICAgIGNvbnN0IGZpbGVJZHMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKCkgPT4gY3J5cHRvLnJhbmRvbVVVSUQoKSk7XHJcbiAgICAgIGNvbnN0IHByb2dyZXNzZXMgPSBuZXcgQXJyYXkoZmlsZUlkcyA/IGZpbGVJZHMubGVuZ3RoICsgMSA6IDEpLmZpbGwoMCk7XHJcbiAgICAgIGNvbnN0IGhhbmRsZVByb2dyZXNzID0gKHByb2dyZXNzLCBpZHgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcHJvZ3Jlc3Nlc1tpZHhdID0gcHJvZ3Jlc3M7XHJcbiAgICAgICAgY29uc3QgdG90YWxQcm9ncmVzcyA9IHByb2dyZXNzZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcclxuICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25Qcm9ncmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdG90YWxQcm9ncmVzcyk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMuc3RyZWFtVGV4dCh7XHJcbiAgICAgICAgc3RyZWFtSWQsXHJcbiAgICAgICAgdG90YWxTaXplOiB0b3RhbFRleHRMZW5ndGgsXHJcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgIHRvcGljOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMsXHJcbiAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IGZpbGVJZHMsXHJcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXNcclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh0ZXh0KTtcclxuICAgICAgLy8gc2V0IHRleHQgcGFydCBvZiBwcm9ncmVzcyB0byAxXHJcbiAgICAgIGhhbmRsZVByb2dyZXNzKDEsIDApO1xyXG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcclxuICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHMpICYmIGZpbGVJZHMpIHtcclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChvcHRpb25zLmF0dGFjaG1lbnRzLm1hcCgoZmlsZSwgaWR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEZpbGUoZmlsZUlkc1tpZHhdLCBmaWxlLCB7XHJcbiAgICAgICAgICAgIHRvcGljOiBvcHRpb25zLnRvcGljLFxyXG4gICAgICAgICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxyXG4gICAgICAgICAgICBvblByb2dyZXNzOiBwcm9ncmVzcyA9PiB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlUHJvZ3Jlc3MocHJvZ3Jlc3MsIGlkeCArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAZXhwZXJpbWVudGFsIENBVVRJT04sIG1pZ2h0IGdldCByZW1vdmVkIGluIGEgbWlub3IgcmVsZWFzZVxyXG4gICAqL1xyXG4gIHN0cmVhbVRleHQob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgaWQ6IHN0cmVhbUlkLFxyXG4gICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIHRvcGljOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9waWMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxyXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXHJcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXNcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcclxuICAgICAgICBzdHJlYW1JZCxcclxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcclxuICAgICAgICB0b3BpYzogaW5mby50b3BpYyxcclxuICAgICAgICB0aW1lc3RhbXA6IG51bWJlclRvQmlnSW50KGluZm8udGltZXN0YW1wKSxcclxuICAgICAgICB0b3RhbExlbmd0aDogbnVtYmVyVG9CaWdJbnQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvdGFsU2l6ZSksXHJcbiAgICAgICAgYXR0cmlidXRlczogaW5mby5hdHRyaWJ1dGVzLFxyXG4gICAgICAgIGNvbnRlbnRIZWFkZXI6IHtcclxuICAgICAgICAgIGNhc2U6ICd0ZXh0SGVhZGVyJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9UZXh0SGVhZGVyKHtcclxuICAgICAgICAgICAgdmVyc2lvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZlcnNpb24sXHJcbiAgICAgICAgICAgIGF0dGFjaGVkU3RyZWFtSWRzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNoZWRTdHJlYW1JZHMsXHJcbiAgICAgICAgICAgIHJlcGx5VG9TdHJlYW1JZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGx5VG9TdHJlYW1JZCxcclxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZTogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50eXBlKSA9PT0gJ3VwZGF0ZScgPyBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUuVVBEQVRFIDogRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlLkNSRUFURVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xyXG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICBjYXNlOiAnc3RyZWFtSGVhZGVyJyxcclxuICAgICAgICAgIHZhbHVlOiBoZWFkZXJcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgIGxldCBjaHVua0lkID0gMDtcclxuICAgICAgY29uc3QgbG9jYWxQID0gdGhpcztcclxuICAgICAgY29uc3Qgd3JpdGFibGVTdHJlYW0gPSBuZXcgV3JpdGFibGVTdHJlYW0oe1xyXG4gICAgICAgIC8vIEltcGxlbWVudCB0aGUgc2lua1xyXG4gICAgICAgIHdyaXRlKHRleHQpIHtcclxuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGV4dEJ5dGVDaHVuayBvZiBzcGxpdFV0ZjgodGV4dCwgU1RSRUFNX0NIVU5LX1NJWkUpKSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgbG9jYWxQLmVuZ2luZS53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgRGF0YVN0cmVhbV9DaHVuayh7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0Qnl0ZUNodW5rLFxyXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQsXHJcbiAgICAgICAgICAgICAgICBjaHVua0luZGV4OiBudW1iZXJUb0JpZ0ludChjaHVua0lkKVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbUNodW5rJyxcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgeWllbGQgbG9jYWxQLmVuZ2luZS5zZW5kRGF0YVBhY2tldChjaHVua1BhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgICAgICAgICBjaHVua0lkICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XHJcbiAgICAgICAgICAgICAgc3RyZWFtSWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtVHJhaWxlcicsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhaWxlclxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUuc2VuZERhdGFQYWNrZXQodHJhaWxlclBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWJvcnQoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnU2luayBlcnJvcjonLCBlcnIpO1xyXG4gICAgICAgICAgLy8gVE9ETyBoYW5kbGUgYWJvcnRzIHRvIHNpZ25hbCBzb21ldGhpbmcgdG8gcmVjZWl2ZXIgc2lkZVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGxldCBvbkVuZ2luZUNsb3NlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xyXG4gICAgICB9KTtcclxuICAgICAgbG9jYWxQLmVuZ2luZS5vbmNlKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpO1xyXG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgVGV4dFN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbywgKCkgPT4gdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpKTtcclxuICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgIH0pO1xyXG4gIH1cclxuICBzZW5kRmlsZShmaWxlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBzdHJlYW1JZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XHJcbiAgICAgIHlpZWxkIHRoaXMuX3NlbmRGaWxlKHN0cmVhbUlkLCBmaWxlLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogc3RyZWFtSWRcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBfc2VuZEZpbGUoc3RyZWFtSWQsIGZpbGUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5zdHJlYW1CeXRlcyh7XHJcbiAgICAgICAgc3RyZWFtSWQsXHJcbiAgICAgICAgdG90YWxTaXplOiBmaWxlLnNpemUsXHJcbiAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxyXG4gICAgICAgIG1pbWVUeXBlOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpbGUudHlwZSxcclxuICAgICAgICB0b3BpYzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljLFxyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllc1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICBkb25lLFxyXG4gICAgICAgICAgdmFsdWVcclxuICAgICAgICB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICBpZiAoZG9uZSkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgeWllbGQgd3JpdGVyLmNsb3NlKCk7XHJcbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcclxuICAgIH0pO1xyXG4gIH1cclxuICBzdHJlYW1CeXRlcyhvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgICBjb25zdCBzdHJlYW1JZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHJlYW1JZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3J5cHRvLnJhbmRvbVVVSUQoKTtcclxuICAgICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcclxuICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICBpZDogc3RyZWFtSWQsXHJcbiAgICAgICAgbWltZVR5cGU6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXHJcbiAgICAgICAgdG9waWM6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJycsXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzLFxyXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXHJcbiAgICAgICAgbmFtZTogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICd1bmtub3duJ1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBoZWFkZXIgPSBuZXcgRGF0YVN0cmVhbV9IZWFkZXIoe1xyXG4gICAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJUb0JpZ0ludCgoX2UgPSBpbmZvLnNpemUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDApLFxyXG4gICAgICAgIG1pbWVUeXBlOiBpbmZvLm1pbWVUeXBlLFxyXG4gICAgICAgIHN0cmVhbUlkLFxyXG4gICAgICAgIHRvcGljOiBpbmZvLnRvcGljLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoRGF0ZS5ub3coKSksXHJcbiAgICAgICAgYXR0cmlidXRlczogaW5mby5hdHRyaWJ1dGVzLFxyXG4gICAgICAgIGNvbnRlbnRIZWFkZXI6IHtcclxuICAgICAgICAgIGNhc2U6ICdieXRlSGVhZGVyJyxcclxuICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9CeXRlSGVhZGVyKHtcclxuICAgICAgICAgICAgbmFtZTogaW5mby5uYW1lXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcclxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgIGNhc2U6ICdzdHJlYW1IZWFkZXInLFxyXG4gICAgICAgICAgdmFsdWU6IGhlYWRlclxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgbGV0IGNodW5rSWQgPSAwO1xyXG4gICAgICBjb25zdCB3cml0ZU11dGV4ID0gbmV3IF8oKTtcclxuICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5lbmdpbmU7XHJcbiAgICAgIGNvbnN0IGxvZyA9IHRoaXMubG9nO1xyXG4gICAgICBjb25zdCB3cml0YWJsZVN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XHJcbiAgICAgICAgd3JpdGUoY2h1bmspIHtcclxuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHdyaXRlTXV0ZXgubG9jaygpO1xyXG4gICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGJ5dGVPZmZzZXQgPCBjaHVuay5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJDaHVuayA9IGNodW5rLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBTVFJFQU1fQ0hVTktfU0laRSk7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBlbmdpbmUud2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtQ2h1bmsnLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9DaHVuayh7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzdWJDaHVuayxcclxuICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2h1bmtJbmRleDogbnVtYmVyVG9CaWdJbnQoY2h1bmtJZClcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldChjaHVua1BhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgICAgICAgICAgICAgIGNodW5rSWQgKz0gMTtcclxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gc3ViQ2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvc2UoKSB7XHJcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XHJcbiAgICAgICAgICAgICAgc3RyZWFtSWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XHJcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtVHJhaWxlcicsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhaWxlclxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHlpZWxkIGVuZ2luZS5zZW5kRGF0YVBhY2tldCh0cmFpbGVyUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhYm9ydChlcnIpIHtcclxuICAgICAgICAgIGxvZy5lcnJvcignU2luayBlcnJvcjonLCBlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGJ5dGVXcml0ZXIgPSBuZXcgQnl0ZVN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbyk7XHJcbiAgICAgIHJldHVybiBieXRlV3JpdGVyO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEluaXRpYXRlIGFuIFJQQyBjYWxsIHRvIGEgcmVtb3RlIHBhcnRpY2lwYW50XHJcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGluaXRpYXRpbmcgdGhlIFJQQyBjYWxsLCBzZWUge0BsaW5rIFBlcmZvcm1ScGNQYXJhbXN9XHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgcGF5bG9hZCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICogQHRocm93cyBFcnJvciBvbiBmYWlsdXJlLiBEZXRhaWxzIGluIGBtZXNzYWdlYC5cclxuICAgKi9cclxuICBwZXJmb3JtUnBjKF9hKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZjMpIHtcclxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XHJcbiAgICAgIGxldCB7XHJcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0eSxcclxuICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICByZXNwb25zZVRpbWVvdXQgPSAxMDAwMFxyXG4gICAgICB9ID0gX3JlZjM7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IG1heFJvdW5kVHJpcExhdGVuY3kgPSAyMDAwO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXM1LCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgIGlmIChieXRlTGVuZ3RoKHBheWxvYWQpID4gTUFYX1BBWUxPQURfQllURVMpIHtcclxuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFUVVFU1RfUEFZTE9BRF9UT09fTEFSR0UnKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gdGhpcy5lbmdpbmUubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnZlcnNpb24pICYmIGNvbXBhcmVWZXJzaW9ucygoX2QgPSAoX2MgPSB0aGlzLmVuZ2luZS5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmVyc2lvbiwgJzEuOC4wJykgPCAwKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9TRVJWRVInKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IGlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcclxuICAgICAgICAgIHlpZWxkIHRoaXMucHVibGlzaFJwY1JlcXVlc3QoZGVzdGluYXRpb25JZGVudGl0eSwgaWQsIG1ldGhvZCwgcGF5bG9hZCwgcmVzcG9uc2VUaW1lb3V0IC0gbWF4Um91bmRUcmlwTGF0ZW5jeSk7XHJcbiAgICAgICAgICBjb25zdCBhY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignQ09OTkVDVElPTl9USU1FT1VUJykpO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dElkKTtcclxuICAgICAgICAgIH0sIG1heFJvdW5kVHJpcExhdGVuY3kpO1xyXG4gICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5zZXQoaWQsIHtcclxuICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChhY2tUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignUkVTUE9OU0VfVElNRU9VVCcpKTtcclxuICAgICAgICAgIH0sIHJlc3BvbnNlVGltZW91dCk7XHJcbiAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuc2V0KGlkLCB7XHJcbiAgICAgICAgICAgIHJlc29sdmU6IChyZXNwb25zZVBheWxvYWQsIHJlc3BvbnNlRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdBY2tzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUlBDIHJlc3BvbnNlIHJlY2VpdmVkIGJlZm9yZSBhY2snLCBpZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZUVycm9yKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZVBheWxvYWQgIT09IG51bGwgJiYgcmVzcG9uc2VQYXlsb2FkICE9PSB2b2lkIDAgPyByZXNwb25zZVBheWxvYWQgOiAnJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0oKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHJvb20ucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcclxuICAgKi9cclxuICByZWdpc3RlclJwY01ldGhvZChtZXRob2QsIGhhbmRsZXIpIHtcclxuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oXCJ5b3UncmUgb3ZlcnJpZGluZyB0aGUgUlBDIGhhbmRsZXIgZm9yIG1ldGhvZCBcIi5jb25jYXQobWV0aG9kLCBcIiwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3JcIikpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ycGNIYW5kbGVycy5zZXQobWV0aG9kLCBoYW5kbGVyKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnVucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcclxuICAgKi9cclxuICB1bnJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ29udHJvbCB3aG8gY2FuIHN1YnNjcmliZSB0byBMb2NhbFBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrcy5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBwYXJ0aWNpcGFudHMgY2FuIHN1YnNjcmliZS4gVGhpcyBhbGxvd3MgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlclxyXG4gICAqIHdobyBpcyBhYmxlIHRvIHN1YnNjcmliZSBhdCBhIHBhcnRpY2lwYW50IGFuZCB0cmFjayBsZXZlbC5cclxuICAgKlxyXG4gICAqIE5vdGU6IGlmIGFjY2VzcyBpcyBnaXZlbiBhdCBhIHRyYWNrLWxldmVsIChpLmUuIGJvdGggW2FsbFBhcnRpY2lwYW50c0FsbG93ZWRdIGFuZFxyXG4gICAqIFtQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5hbGxUcmFja3NBbGxvd2VkXSBhcmUgZmFsc2UpLCBhbnkgbmV3ZXIgcHVibGlzaGVkIHRyYWNrc1xyXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcclxuICAgKiBwZXJtaXNzaW9ucyB1cGRhdGUgdG8gYWxsb3cgc3Vic2NyaXB0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXHJcbiAgICogIFRha2VzIHByZWNlZGVuY2Ugb3ZlciBbW3BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uc11dIGlmIHNldCB0byB0cnVlLlxyXG4gICAqICBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHRydWUuXHJcbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcclxuICAgKiAgcGFydGljaXBhbnQvdHJhY2suIEFueSBvbWl0dGVkIHBhcnRpY2lwYW50cyB3aWxsIG5vdCByZWNlaXZlIGFueSBwZXJtaXNzaW9ucy5cclxuICAgKi9cclxuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50c0FsbG93ZWQpIHtcclxuICAgIGxldCBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xyXG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM7XHJcbiAgICB0aGlzLmFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSA9IGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ7XHJcbiAgICBpZiAoIXRoaXMuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlSW5jb21pbmdScGNBY2socmVxdWVzdElkKSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wZW5kaW5nQWNrcy5nZXQocmVxdWVzdElkKTtcclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgIGhhbmRsZXIucmVzb2x2ZSgpO1xyXG4gICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShyZXF1ZXN0SWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQWNrIHJlY2VpdmVkIGZvciB1bmV4cGVjdGVkIFJQQyByZXF1ZXN0JywgcmVxdWVzdElkKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShyZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmdldChyZXF1ZXN0SWQpO1xyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgaGFuZGxlci5yZXNvbHZlKHBheWxvYWQsIGVycm9yKTtcclxuICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShyZXF1ZXN0SWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgcmVjZWl2ZWQgZm9yIHVuZXhwZWN0ZWQgUlBDIHJlcXVlc3QnLCByZXF1ZXN0SWQpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHVibGlzaFJwY1JlcXVlc3QoZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xyXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxyXG4gICAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgY2FzZTogJ3JwY1JlcXVlc3QnLFxyXG4gICAgICAgICAgdmFsdWU6IG5ldyBScGNSZXF1ZXN0KHtcclxuICAgICAgICAgICAgaWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgICAgICByZXNwb25zZVRpbWVvdXRNczogcmVzcG9uc2VUaW1lb3V0LFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiAxXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocGFydGljaXBhbnRJZGVudGl0eSkge1xyXG4gICAgZm9yIChjb25zdCBbaWQsIHtcclxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGVuZGluZ0lkZW50aXR5XHJcbiAgICB9XSBvZiB0aGlzLnBlbmRpbmdBY2tzKSB7XHJcbiAgICAgIGlmIChwZW5kaW5nSWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgW2lkLCB7XHJcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlbmRpbmdJZGVudGl0eSxcclxuICAgICAgcmVzb2x2ZVxyXG4gICAgfV0gb2YgdGhpcy5wZW5kaW5nUmVzcG9uc2VzKSB7XHJcbiAgICAgIGlmIChwZW5kaW5nSWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgICAgICByZXNvbHZlKG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1JFQ0lQSUVOVF9ESVNDT05ORUNURUQnKSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldEVuYWJsZWRQdWJsaXNoQ29kZWNzKGNvZGVjcykge1xyXG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gY29kZWNzLmZpbHRlcihjID0+IGMubWltZS5zcGxpdCgnLycpWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlbycpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgdXBkYXRlSW5mbyhpbmZvKSB7XHJcbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxyXG4gICAgLy8gaWYgc2VydmVyJ3MgdHJhY2sgbXV0ZSBzdGF0dXMgZG9lc24ndCBtYXRjaCBhY3R1YWwsIHdlJ2xsIGhhdmUgdG8gdXBkYXRlXHJcbiAgICAvLyB0aGUgc2VydmVyJ3MgY29weVxyXG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRpLnNpZCk7XHJcbiAgICAgIGlmIChwdWIpIHtcclxuICAgICAgICBjb25zdCBtdXRlZE9uU2VydmVyID0gcHViLmlzTXV0ZWQgfHwgKChfYiA9IChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzVXBzdHJlYW1QYXVzZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKTtcclxuICAgICAgICBpZiAobXV0ZWRPblNlcnZlciAhPT0gdGkubXV0ZWQpIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSwge1xyXG4gICAgICAgICAgICBtdXRlZE9uU2VydmVyXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZE11dGVUcmFjayh0aS5zaWQsIG11dGVkT25TZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHNldEFjdGl2ZUFnZW50KGFnZW50KSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICB0aGlzLmZpcnN0QWN0aXZlQWdlbnQgPSBhZ2VudDtcclxuICAgIGlmIChhZ2VudCAmJiAhdGhpcy5maXJzdEFjdGl2ZUFnZW50KSB7XHJcbiAgICAgIHRoaXMuZmlyc3RBY3RpdmVBZ2VudCA9IGFnZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGFnZW50KSB7XHJcbiAgICAgIChfYiA9IChfYSA9IHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNvbHZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgYWdlbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgKF9kID0gKF9jID0gdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlamVjdCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsICdBZ2VudCBkaXNjb25uZWN0ZWQnKTtcclxuICAgIH1cclxuICAgIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHdhaXRVbnRpbEFjdGl2ZUFnZW50UHJlc2VudCgpIHtcclxuICAgIGlmICh0aGlzLmZpcnN0QWN0aXZlQWdlbnQpIHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmZpcnN0QWN0aXZlQWdlbnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLmFjdGl2ZUFnZW50RnV0dXJlKSB7XHJcbiAgICAgIHRoaXMuYWN0aXZlQWdlbnRGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBZ2VudEZ1dHVyZS5wcm9taXNlO1xyXG4gIH1cclxuICBnZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKSB7XHJcbiAgICBsZXQgcHVibGljYXRpb247XHJcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcclxuICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcclxuICAgICAgaWYgKCFsb2NhbFRyYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHRoaXMgbG9va3Mgb3Zlcmx5IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGlzIG9iamVjdCB0cmVlXHJcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcclxuICAgICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sobG9jYWxUcmFjaykgfHwgaXNMb2NhbFZpZGVvVHJhY2sobG9jYWxUcmFjaykpIHtcclxuICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XHJcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xyXG4gICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcclxuICB9XHJcbiAgd2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3Qgd2FpdEZvclBlbmRpbmdUaW1lb3V0ID0gMTAwMDA7XHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgc3RhcnRUaW1lICsgd2FpdEZvclBlbmRpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VFbnRyeSA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmVudHJpZXMoKSkuZmluZChfcmVmNCA9PiB7XHJcbiAgICAgICAgICBsZXQgW3BlbmRpbmdUcmFja10gPSBfcmVmNDtcclxuICAgICAgICAgIHJldHVybiBwZW5kaW5nVHJhY2suc291cmNlID09PSBzb3VyY2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlRW50cnkpIHtcclxuICAgICAgICAgIHJldHVybiBwdWJsaXNoUHJvbWlzZUVudHJ5WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCBzbGVlcCgyMCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xyXG4gIGNvbnN0cnVjdG9yKGtpbmQsIHRpLCBhdXRvU3Vic2NyaWJlLCBsb2dnZXJPcHRpb25zKSB7XHJcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xyXG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHRoaXMuYWxsb3dlZCA9IHRydWU7XHJcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcclxuICAgIHRoaXMuaGFuZGxlRW5kZWQgPSB0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQsIHRyYWNrKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB2aXNpYmxlID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5IFwiLmNvbmNhdCh0aGlzLnRyYWNrU2lkLCBcIiwgdmlzaWJsZT1cIikuY29uY2F0KHZpc2libGUpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0aGlzLmRpc2FibGVkID0gIXZpc2libGU7XHJcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UgPSBkaW1lbnNpb25zID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zIFwiLmNvbmNhdChkaW1lbnNpb25zLndpZHRoLCBcInhcIikuY29uY2F0KGRpbWVuc2lvbnMuaGVpZ2h0KSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xyXG4gICAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGF1dG9TdWJzY3JpYmU7XHJcbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgdG8gdGhpcyByZW1vdGUgdHJhY2tcclxuICAgKiBAcGFyYW0gc3Vic2NyaWJlZCB0cnVlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBmYWxzZSB0byB1bnN1YnNjcmliZVxyXG4gICAqL1xyXG4gIHNldFN1YnNjcmliZWQoc3Vic2NyaWJlZCkge1xyXG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xyXG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XHJcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xyXG4gICAgLy8gcmVzZXQgYWxsb3dlZCBzdGF0dXMgd2hlbiBkZXNpcmVkIHN1YnNjcmlwdGlvbiBzdGF0ZSBjaGFuZ2VzXHJcbiAgICAvLyBzZXJ2ZXIgd2lsbCBub3RpZnkgY2xpZW50IHZpYSBzaWduYWwgbWVzc2FnZSBpZiBpdCdzIG5vdCBhbGxvd2VkXHJcbiAgICBpZiAoc3Vic2NyaWJlZCkge1xyXG4gICAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3ViID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbih7XHJcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxyXG4gICAgICBzdWJzY3JpYmU6IHRoaXMuc3Vic2NyaWJlZCxcclxuICAgICAgcGFydGljaXBhbnRUcmFja3M6IFtuZXcgUGFydGljaXBhbnRUcmFja3Moe1xyXG4gICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcclxuICAgICAgICAvLyB0aGlzIGlzIGZpbGxlZCBpbiBieSB0aGUgcGFydGljaXBhbnQgdGhhdCByZWNlaXZlcyB0aGlzIG1lc3NhZ2VcclxuICAgICAgICBwYXJ0aWNpcGFudFNpZDogJycsXHJcbiAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF1cclxuICAgICAgfSldXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViKTtcclxuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcclxuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xyXG4gIH1cclxuICBnZXQgc3Vic2NyaXB0aW9uU3RhdHVzKCkge1xyXG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlVuc3Vic2NyaWJlZDtcclxuICAgIH1cclxuICAgIGlmICghc3VwZXIuaXNTdWJzY3JpYmVkKSB7XHJcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5EZXNpcmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlN1YnNjcmliZWQ7XHJcbiAgfVxyXG4gIGdldCBwZXJtaXNzaW9uU3RhdHVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWxsb3dlZCA/IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cy5BbGxvd2VkIDogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLk5vdEFsbG93ZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0cmFjayBpcyBzdWJzY3JpYmVkLCBhbmQgcmVhZHkgZm9yIHBsYXliYWNrXHJcbiAgICovXHJcbiAgZ2V0IGlzU3Vic2NyaWJlZCgpIHtcclxuICAgIGlmICh0aGlzLnN1YnNjcmliZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBlci5pc1N1YnNjcmliZWQ7XHJcbiAgfVxyXG4gIC8vIHJldHVybnMgY2xpZW50J3MgZGVzaXJlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBhbHNvIHRydWUgaWYgYXV0b1N1YnNjcmliZSBpcyBlbmFibGVkXHJcbiAgZ2V0IGlzRGVzaXJlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xyXG4gIH1cclxuICBnZXQgaXNFbmFibGVkKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xyXG4gIH1cclxuICBnZXQgaXNMb2NhbCgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogZGlzYWJsZSBzZXJ2ZXIgZnJvbSBzZW5kaW5nIGRvd24gZGF0YSBmb3IgdGhpcyB0cmFjay4gdGhpcyBpcyB1c2VmdWwgd2hlblxyXG4gICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cclxuICAgKiB0byByZWR1Y2UgYmFuZHdpZHRoIHJlcXVpcmVtZW50c1xyXG4gICAqIEBwYXJhbSBlbmFibGVkXHJcbiAgICovXHJcbiAgc2V0RW5hYmxlZChlbmFibGVkKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5kaXNhYmxlZCA9PT0gIWVuYWJsZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kaXNhYmxlZCA9ICFlbmFibGVkO1xyXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogZm9yIHRyYWNrcyB0aGF0IHN1cHBvcnQgc2ltdWxjYXN0aW5nLCBhZGp1c3Qgc3Vic2NyaWJlZCBxdWFsaXR5XHJcbiAgICpcclxuICAgKiBUaGlzIGluZGljYXRlcyB0aGUgaGlnaGVzdCBxdWFsaXR5IHRoZSBjbGllbnQgY2FuIGFjY2VwdC4gaWYgbmV0d29ya1xyXG4gICAqIGJhbmR3aWR0aCBkb2VzIG5vdCBhbGxvdywgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSByZWR1Y2UgcXVhbGl0eSB0b1xyXG4gICAqIG9wdGltaXplIGZvciB1bmludGVycnVwdGVkIHZpZGVvXHJcbiAgICovXHJcbiAgc2V0VmlkZW9RdWFsaXR5KHF1YWxpdHkpIHtcclxuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPT09IHF1YWxpdHkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gcXVhbGl0eTtcclxuICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcclxuICB9XHJcbiAgc2V0VmlkZW9EaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCgoX2EgPSB0aGlzLnZpZGVvRGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gZGltZW5zaW9ucy53aWR0aCAmJiAoKF9iID0gdGhpcy52aWRlb0RpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBkaW1lbnNpb25zLmhlaWdodCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XHJcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XHJcbiAgfVxyXG4gIHNldFZpZGVvRlBTKGZwcykge1xyXG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmZwcyA9PT0gZnBzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZnBzID0gZnBzO1xyXG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcclxuICB9XHJcbiAgZ2V0IHZpZGVvUXVhbGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRUcmFjayh0cmFjaykge1xyXG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xyXG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XHJcbiAgICBjb25zdCBwcmV2VHJhY2sgPSB0aGlzLnRyYWNrO1xyXG4gICAgaWYgKHByZXZUcmFjayA9PT0gdHJhY2spIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZXZUcmFjaykge1xyXG4gICAgICAvLyB1bnJlZ2lzdGVyIGxpc3RlbmVyXHJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XHJcbiAgICAgIHByZXZUcmFjay5vZmYoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcclxuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgcHJldlRyYWNrLmRldGFjaCgpO1xyXG4gICAgICBwcmV2VHJhY2suc3RvcE1vbml0b3IoKTtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2VHJhY2spO1xyXG4gICAgfVxyXG4gICAgc3VwZXIuc2V0VHJhY2sodHJhY2spO1xyXG4gICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgIHRyYWNrLnNpZCA9IHRoaXMudHJhY2tTaWQ7XHJcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xyXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcclxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgdHJhY2spO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XHJcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzZXRBbGxvd2VkKGFsbG93ZWQpIHtcclxuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcclxuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xyXG4gICAgdGhpcy5hbGxvd2VkID0gYWxsb3dlZDtcclxuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xyXG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc2V0U3Vic2NyaXB0aW9uRXJyb3IoZXJyb3IpIHtcclxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgdXBkYXRlSW5mbyhpbmZvKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbmZvKGluZm8pO1xyXG4gICAgY29uc3QgcHJldk1ldGFkYXRhTXV0ZWQgPSB0aGlzLm1ldGFkYXRhTXV0ZWQ7XHJcbiAgICB0aGlzLm1ldGFkYXRhTXV0ZWQgPSBpbmZvLm11dGVkO1xyXG4gICAgaWYgKHRoaXMudHJhY2spIHtcclxuICAgICAgdGhpcy50cmFjay5zZXRNdXRlZChpbmZvLm11dGVkKTtcclxuICAgIH0gZWxzZSBpZiAocHJldk1ldGFkYXRhTXV0ZWQgIT09IGluZm8ubXV0ZWQpIHtcclxuICAgICAgdGhpcy5lbWl0KGluZm8ubXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkKTtcclxuICAgIH1cclxuICB9XHJcbiAgZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2aW91c1N0YXR1cykge1xyXG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xyXG4gICAgaWYgKHByZXZpb3VzU3RhdHVzID09PSBjdXJyZW50U3RhdHVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIGN1cnJlbnRTdGF0dXMsIHByZXZpb3VzU3RhdHVzKTtcclxuICB9XHJcbiAgZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvblN0YXR1cyA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcclxuICAgIGlmIChjdXJyZW50UGVybWlzc2lvblN0YXR1cyAhPT0gcHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XHJcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCB0aGlzLnBlcm1pc3Npb25TdGF0dXMsIHByZXZpb3VzUGVybWlzc2lvblN0YXR1cyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHtcclxuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ2FkYXB0aXZlIHN0cmVhbSBpcyBlbmFibGVkLCBjYW5ub3QgY2hhbmdlIHZpZGVvIHRyYWNrIHNldHRpbmdzJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLmlzRGVzaXJlZCkge1xyXG4gICAgICB0aGlzLmxvZy53YXJuKCdjYW5ub3QgdXBkYXRlIHRyYWNrIHNldHRpbmdzIHdoZW4gbm90IHN1YnNjcmliZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XHJcbiAgICByZXR1cm4gaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcclxuICB9XHJcbiAgLyogQGludGVybmFsICovXHJcbiAgZW1pdFRyYWNrVXBkYXRlKCkge1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgVXBkYXRlVHJhY2tTZXR0aW5ncyh7XHJcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxyXG4gICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcclxuICAgICAgZnBzOiB0aGlzLmZwc1xyXG4gICAgfSk7XHJcbiAgICBpZiAodGhpcy52aWRlb0RpbWVuc2lvbnMpIHtcclxuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xyXG4gICAgICBzZXR0aW5ncy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMuaGVpZ2h0KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGRlZmF1bHRzIHRvIGhpZ2ggcXVhbGl0eVxyXG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgc2V0dGluZ3MpO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUmVtb3RlUGFydGljaXBhbnQgZXh0ZW5kcyBQYXJ0aWNpcGFudCB7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBmcm9tUGFydGljaXBhbnRJbmZvKHNpZ25hbENsaWVudCwgcGksIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIHJldHVybiBuZXcgUmVtb3RlUGFydGljaXBhbnQoc2lnbmFsQ2xpZW50LCBwaS5zaWQsIHBpLmlkZW50aXR5LCBwaS5uYW1lLCBwaS5tZXRhZGF0YSwgcGkuYXR0cmlidXRlcywgbG9nZ2VyT3B0aW9ucywgcGkua2luZCk7XHJcbiAgfVxyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3VwZXIubG9nQ29udGV4dCksIHtcclxuICAgICAgcnBJRDogdGhpcy5zaWQsXHJcbiAgICAgIHJlbW90ZVBhcnRpY2lwYW50OiB0aGlzLmlkZW50aXR5XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGNvbnN0cnVjdG9yKHNpZ25hbENsaWVudCwgc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcclxuICAgIGxldCBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBQYXJ0aWNpcGFudEluZm9fS2luZC5TVEFOREFSRDtcclxuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHkgfHwgJycsIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zLCBraW5kKTtcclxuICAgIHRoaXMuc2lnbmFsQ2xpZW50ID0gc2lnbmFsQ2xpZW50O1xyXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudm9sdW1lTWFwID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuICBhZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKSB7XHJcbiAgICBzdXBlci5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcclxuICAgIC8vIHJlZ2lzdGVyIGFjdGlvbiBldmVudHNcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NlbmQgdXBkYXRlIHNldHRpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xyXG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIgPT4ge1xyXG4gICAgICBzdWIucGFydGljaXBhbnRUcmFja3MuZm9yRWFjaChwdCA9PiB7XHJcbiAgICAgICAgcHQucGFydGljaXBhbnRTaWQgPSB0aGlzLnNpZDtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKTtcclxuICAgIH0pO1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgc3RhdHVzID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XHJcbiAgICB9KTtcclxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgc3RhdHVzID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBwdWJsaWNhdGlvbiwgc3RhdHVzKTtcclxuICAgIH0pO1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgdHJhY2ssIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2sgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1Vuc3Vic2NyaWJlZCwgcHJldmlvdXNUcmFjaywgcHVibGljYXRpb24pO1xyXG4gICAgfSk7XHJcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgcHVibGljYXRpb24udHJhY2tTaWQsIGVycm9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSkge1xyXG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpIHtcclxuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKTtcclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIHNldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBhdWRpbyB0cmFja1xyXG4gICAqIGJ5IGRlZmF1bHQsIHRoaXMgYWZmZWN0cyB0aGUgbWljcm9waG9uZSBwdWJsaWNhdGlvblxyXG4gICAqIGEgZGlmZmVyZW50IHNvdXJjZSBjYW4gYmUgcGFzc2VkIGluIGFzIGEgc2Vjb25kIGFyZ3VtZW50XHJcbiAgICogaWYgbm8gdHJhY2sgZXhpc3RzIHRoZSB2b2x1bWUgd2lsbCBiZSBhcHBsaWVkIHdoZW4gdGhlIG1pY3JvcGhvbmUgdHJhY2sgaXMgYWRkZWRcclxuICAgKi9cclxuICBzZXRWb2x1bWUodm9sdW1lKSB7XHJcbiAgICBsZXQgc291cmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcclxuICAgIHRoaXMudm9sdW1lTWFwLnNldChzb3VyY2UsIHZvbHVtZSk7XHJcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XHJcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XHJcbiAgICAgIGF1ZGlvUHVibGljYXRpb24udHJhY2suc2V0Vm9sdW1lKHZvbHVtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvbiB0aGUgcGFydGljaXBhbnQncyBtaWNyb3Bob25lIHRyYWNrXHJcbiAgICovXHJcbiAgZ2V0Vm9sdW1lKCkge1xyXG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XHJcbiAgICBjb25zdCBhdWRpb1B1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XHJcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XHJcbiAgICAgIHJldHVybiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrLmdldFZvbHVtZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudm9sdW1lTWFwLmdldChzb3VyY2UpO1xyXG4gIH1cclxuICAvKiogQGludGVybmFsICovXHJcbiAgYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCkge1xyXG4gICAgLy8gZmluZCB0aGUgdHJhY2sgcHVibGljYXRpb25cclxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cclxuICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZCk7XHJcbiAgICAvLyBpdCdzIGFsc28gcG9zc2libGUgdGhhdCB0aGUgYnJvd3NlciBkaWRuJ3QgaG9ub3Igb3VyIG9yaWdpbmFsIHRyYWNrIGlkXHJcbiAgICAvLyBGaXJlRm94IHdvdWxkIHVzZSBpdHMgb3duIGxvY2FsIHV1aWQgaW5zdGVhZCBvZiBzZXJ2ZXIgdHJhY2sgaWRcclxuICAgIGlmICghcHVibGljYXRpb24pIHtcclxuICAgICAgaWYgKCFzaWQuc3RhcnRzV2l0aCgnVFInKSkge1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0eXBlXHJcbiAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gd2hlbiB3ZSBjb3VsZG4ndCBsb2NhdGUgdGhlIHRyYWNrLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIG1ldGFkYXRhIGhhc24ndFxyXG4gICAgLy8geWV0IGFycml2ZWQuIFdhaXQgYSBiaXQgbG9uZ2VyIGZvciBpdCB0byBhcnJpdmUsIG9yIGZpcmUgYW4gZXJyb3JcclxuICAgIGlmICghcHVibGljYXRpb24pIHtcclxuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZmluZCBwdWJsaXNoZWQgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIHRyYWNrU2lkOiBzaWRcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHNpZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IHVuZGVmaW5lZCkgdHJpZXNMZWZ0ID0gMjA7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCAtIDEpO1xyXG4gICAgICB9LCAxNTApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XHJcbiAgICAgIHRoaXMubG9nLmVycm9yKCd1bmFibGUgdG8gc3Vic2NyaWJlIGJlY2F1c2UgTWVkaWFTdHJlYW1UcmFjayBpcyBlbmRlZC4gRG8gbm90IGNhbGwgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCknLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XHJcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBzaWQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xyXG4gICAgbGV0IHRyYWNrO1xyXG4gICAgaWYgKGlzVmlkZW8pIHtcclxuICAgICAgdHJhY2sgPSBuZXcgUmVtb3RlVmlkZW9UcmFjayhtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZUF1ZGlvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgdGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXVkaW9PdXRwdXQpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0IHRyYWNrIGluZm9cclxuICAgIHRyYWNrLnNvdXJjZSA9IHB1YmxpY2F0aW9uLnNvdXJjZTtcclxuICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcclxuICAgIHRyYWNrLmlzTXV0ZWQgPSBwdWJsaWNhdGlvbi5pc011dGVkO1xyXG4gICAgdHJhY2suc2V0TWVkaWFTdHJlYW0obWVkaWFTdHJlYW0pO1xyXG4gICAgdHJhY2suc3RhcnQoKTtcclxuICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHRyYWNrKTtcclxuICAgIC8vIHNldCBwYXJ0aWNpcGFudCB2b2x1bWVzIG9uIG5ldyBhdWRpbyB0cmFja3NcclxuICAgIGlmICh0aGlzLnZvbHVtZU1hcC5oYXMocHVibGljYXRpb24uc291cmNlKSAmJiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XHJcbiAgICAgIHRyYWNrLnNldFZvbHVtZSh0aGlzLnZvbHVtZU1hcC5nZXQocHVibGljYXRpb24uc291cmNlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHVibGljYXRpb247XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBnZXQgaGFzTWV0YWRhdGEoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLnBhcnRpY2lwYW50SW5mbztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXHJcbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHNpZCk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICB1cGRhdGVJbmZvKGluZm8pIHtcclxuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBhcmUgZ2V0dGluZyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0cmFja3MsIHJlY29uY2lsZSBpbiBoZXJlXHJcbiAgICAvLyBhbmQgc2VuZCBvdXQgZXZlbnRzIGZvciBjaGFuZ2VzXHJcbiAgICAvLyByZWNvbmNpbGUgdHJhY2sgcHVibGljYXRpb25zLCBwdWJsaXNoIGV2ZW50cyBvbmx5IGlmIG1ldGFkYXRhIGlzIGFscmVhZHkgdGhlcmVcclxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxyXG4gICAgY29uc3QgdmFsaWRUcmFja3MgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBuZXdUcmFja3MgPSBuZXcgTWFwKCk7XHJcbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKHRpID0+IHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodGkuc2lkKTtcclxuICAgICAgaWYgKCFwdWJsaWNhdGlvbikge1xyXG4gICAgICAgIC8vIG5ldyBwdWJsaWNhdGlvblxyXG4gICAgICAgIGNvbnN0IGtpbmQgPSBUcmFjay5raW5kRnJvbVByb3RvKHRpLnR5cGUpO1xyXG4gICAgICAgIGlmICgha2luZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWNhdGlvbiA9IG5ldyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKGtpbmQsIHRpLCAoX2EgPSB0aGlzLnNpZ25hbENsaWVudC5jb25uZWN0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUsIHtcclxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxyXG4gICAgICAgICAgbG9nZ2VyTmFtZTogKF9iID0gdGhpcy5sb2dnZXJPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9nZ2VyTmFtZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xyXG4gICAgICAgIG5ld1RyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5zb3VyY2UpKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHB1YmxpY2F0aW9uLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwicmVjZWl2ZWQgYSBzZWNvbmQgdHJhY2sgcHVibGljYXRpb24gZm9yIFwiLmNvbmNhdCh0aGlzLmlkZW50aXR5LCBcIiB3aXRoIHRoZSBzYW1lIHNvdXJjZTogXCIpLmNvbmNhdChwdWJsaWNhdGlvbi5zb3VyY2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgICAgb2xkVHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdUcmFja09mU291cmNlKSxcclxuICAgICAgICAgICAgbmV3VHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFsaWRUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xyXG4gICAgfSk7XHJcbiAgICAvLyBkZXRlY3QgcmVtb3ZlZCB0cmFja3NcclxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XHJcbiAgICAgIGlmICghdmFsaWRUcmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xyXG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xyXG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIGFsd2F5cyBlbWl0IGV2ZW50cyBmb3IgbmV3IHB1YmxpY2F0aW9ucywgUm9vbSB3aWxsIG5vdCBmb3J3YXJkIHRoZW0gdW5sZXNzIGl0J3MgcmVhZHlcclxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICB1bnB1Ymxpc2hUcmFjayhzaWQsIHNlbmRVbnB1Ymxpc2gpIHtcclxuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQoc2lkKTtcclxuICAgIGlmICghcHVibGljYXRpb24pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gYWxzbyBzZW5kIHVuc3Vic2NyaWJlLCBpZiB0cmFjayBpcyBhY3RpdmVseSBzdWJzY3JpYmVkXHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHRyYWNrXHJcbiAgICB9ID0gcHVibGljYXRpb247XHJcbiAgICBpZiAodHJhY2spIHtcclxuICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgLy8gcmVtb3ZlIHRyYWNrIGZyb20gbWFwcyBvbmx5IGFmdGVyIHVuc3Vic2NyaWJlZCBoYXMgYmVlbiBmaXJlZFxyXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5kZWxldGUoc2lkKTtcclxuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxyXG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XHJcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcclxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcclxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VuZFVucHVibGlzaCkge1xyXG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xyXG4gIHNldEF1ZGlvT3V0cHV0KG91dHB1dCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdGhpcy5hdWRpb091dHB1dCA9IG91dHB1dDtcclxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKGlzQXVkaW9UcmFjayhwdWIudHJhY2spICYmIGlzUmVtb3RlVHJhY2socHViLnRyYWNrKSkge1xyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwdWIudHJhY2suc2V0U2lua0lkKChfYSA9IG91dHB1dC5kZXZpY2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2RlZmF1bHQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBlbWl0KGV2ZW50KSB7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2cudHJhY2UoJ3BhcnRpY2lwYW50IGV2ZW50JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgIGV2ZW50LFxyXG4gICAgICBhcmdzXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgQ29ubmVjdGlvblN0YXRlO1xyXG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdGF0ZSkge1xyXG4gIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XHJcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xyXG4gIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XHJcbiAgQ29ubmVjdGlvblN0YXRlW1wiUmVjb25uZWN0aW5nXCJdID0gXCJyZWNvbm5lY3RpbmdcIjtcclxuICBDb25uZWN0aW9uU3RhdGVbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xyXG59KShDb25uZWN0aW9uU3RhdGUgfHwgKENvbm5lY3Rpb25TdGF0ZSA9IHt9KSk7XHJcbmNvbnN0IGNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kgPSA0ICogMTAwMDtcclxuLyoqXHJcbiAqIEluIExpdmVLaXQsIGEgcm9vbSBpcyB0aGUgbG9naWNhbCBncm91cGluZyBmb3IgYSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cclxuICogUGFydGljaXBhbnRzIGluIGEgcm9vbSBjYW4gcHVibGlzaCB0cmFja3MsIGFuZCBzdWJzY3JpYmUgdG8gb3RoZXJzJyB0cmFja3MuXHJcbiAqXHJcbiAqIGEgUm9vbSBmaXJlcyBbW1Jvb21FdmVudCB8IFJvb21FdmVudHNdXS5cclxuICpcclxuICogQG5vSW5oZXJpdERvY1xyXG4gKi9cclxuY2xhc3MgUm9vbSBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFJvb20sIHRoZSBwcmltYXJ5IGNvbnN0cnVjdCBmb3IgYSBMaXZlS2l0IHNlc3Npb24uXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICB2YXIgX3RoaXM7XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIHN1cGVyKCk7XHJcbiAgICBfdGhpcyA9IHRoaXM7XHJcbiAgICB0aGlzLnN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcclxuICAgIC8qKlxyXG4gICAgICogbGlzdCBvZiBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWN0aXZlbHkgc3BlYWtpbmcuIHdoZW4gdGhpcyBjaGFuZ2VzXHJcbiAgICAgKiBhIFtbUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZF1dIGV2ZW50IGlzIGZpcmVkXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcclxuICAgIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xyXG4gICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XHJcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcclxuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcclxuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnJwY0hhbmRsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5jb25uZWN0ID0gKHVybCwgdG9rZW4sIG9wdHMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBpZiAoIWlzQnJvd3NlclN1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJXZWJSVEMgaXNuJ3QgZGV0ZWN0ZWQsIGhhdmUgeW91IGNhbGxlZCByZWdpc3Rlckdsb2JhbHM/XCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkxpdmVLaXQgZG9lc24ndCBzZWVtIHRvIGJlIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuIFRyeSB0byB1cGRhdGUgeW91ciBicm93c2VyIGFuZCBtYWtlIHN1cmUgbm8gYnJvd3NlciBleHRlbnNpb25zIGFyZSBkaXNhYmxpbmcgd2ViUlRDLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gSW4gY2FzZSBhIGRpc2Nvbm5lY3QgY2FsbGVkIGhhcHBlbmVkIHJpZ2h0IGJlZm9yZSB0aGUgY29ubmVjdCBjYWxsLCBtYWtlIHN1cmUgdGhlIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVkIGZpcnN0IGJ5IGF3YWl0aW5nIGl0cyBsb2NrXHJcbiAgICAgIGNvbnN0IHVubG9ja0Rpc2Nvbm5lY3QgPSB5aWVsZCB0aGlzLmRpc2Nvbm5lY3RMb2NrLmxvY2soKTtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcclxuICAgICAgICAvLyB3aGVuIHRoZSBzdGF0ZSBpcyByZWNvbm5lY3Rpbmcgb3IgY29ubmVjdGVkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHlcclxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYWxyZWFkeSBjb25uZWN0ZWQgdG8gcm9vbSBcIi5jb25jYXQodGhpcy5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RGdXR1cmUpIHtcclxuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XHJcbiAgICAgIGlmICgoKF9hID0gdGhpcy5yZWdpb25VcmxQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNlcnZlclVybCgpLnRvU3RyaW5nKCkpICE9PSB1cmwpIHtcclxuICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZmlyc3QgZmV0Y2ggd2l0aG91dCB3YWl0aW5nIGZvciBhIHJlc3BvbnNlXHJcbiAgICAgICAgLy8gaWYgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxzLCB0aGlzIHdpbGwgc3BlZWQgdXAgcGlja2luZyByZWdpb25hbCB1cmxcclxuICAgICAgICAvLyBvbiBzdWJzZXF1ZW50IHJ1bnNcclxuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmZldGNoUmVnaW9uU2V0dGluZ3MoKS50aGVuKHNldHRpbmdzID0+IHtcclxuICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgIChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMoc2V0dGluZ3MpO1xyXG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbm5lY3RGbiA9IChyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleHBsaWNpdCBjcmVhdGlvbiBhcyBsb2NhbCB2YXIgbmVlZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIgd2hlbiBwYXNzaW5nIGl0IHRvIGBhdHRlbXB0Q29ubmVjdGlvbmAgZnVydGhlciBkb3duXHJcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xyXG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGludGVudGlvbiB0byBjb25uZWN0IGhhcyBiZWVuIHNpZ25hbGxlZCBzbyB3ZSBjYW4gYWxsb3cgY2FuY2VsbGluZyBvZiB0aGUgY29ubmVjdGlvbiB2aWEgZGlzY29ubmVjdCgpIGFnYWluXHJcbiAgICAgICAgdW5sb2NrRGlzY29ubmVjdCA9PT0gbnVsbCB8fCB1bmxvY2tEaXNjb25uZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmxvY2tEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHlpZWxkIHRoaXMuYXR0ZW1wdENvbm5lY3Rpb24ocmVnaW9uVXJsICE9PSBudWxsICYmIHJlZ2lvblVybCAhPT0gdm9pZCAwID8gcmVnaW9uVXJsIDogdXJsLCB0b2tlbiwgb3B0cywgYWJvcnRDb250cm9sbGVyKTtcclxuICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyICYmIGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQgJiYgZS5yZWFzb24gIT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0VXJsID0gbnVsbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBuZXh0VXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgoX2EgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZ25hbCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIChlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5leHRVcmwgJiYgISgoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpZ25hbC5hYm9ydGVkKSkge1xyXG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJJbml0aWFsIGNvbm5lY3Rpb24gZmFpbGVkIHdpdGggQ29ubmVjdGlvbkVycm9yOiBcIi5jb25jYXQoZS5tZXNzYWdlLCBcIi4gUmV0cnlpbmcgd2l0aCBhbm90aGVyIHJlZ2lvbjogXCIpLmNvbmNhdChuZXh0VXJsKSwgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XHJcbiAgICAgICAgICAgICAgeWllbGQgY29ubmVjdEZuKHJlc29sdmUsIHJlamVjdCwgbmV4dFVybCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKSk7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZGlzY29ubmVjdFJlYXNvbiA9IERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XHJcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgZGlzY29ubmVjdFJlYXNvbiA9IGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgZGlzY29ubmVjdFJlYXNvbik7XHJcbiAgICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZWdpb25VcmwgPSB0aGlzLnJlZ2lvblVybDtcclxuICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIHJlZ2lvblVybCk7XHJcbiAgICAgIH0sICgpID0+IHtcclxuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5jb25uZWN0U2lnbmFsID0gKHVybCwgdG9rZW4sIGVuZ2luZSwgY29ubmVjdE9wdGlvbnMsIHJvb21PcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIGVuZ2luZS5qb2luKHVybCwgdG9rZW4sIHtcclxuICAgICAgICBhdXRvU3Vic2NyaWJlOiBjb25uZWN0T3B0aW9ucy5hdXRvU3Vic2NyaWJlLFxyXG4gICAgICAgIGFkYXB0aXZlU3RyZWFtOiB0eXBlb2Ygcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnID8gdHJ1ZSA6IHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtLFxyXG4gICAgICAgIG1heFJldHJpZXM6IGNvbm5lY3RPcHRpb25zLm1heFJldHJpZXMsXHJcbiAgICAgICAgZTJlZUVuYWJsZWQ6ICEhdGhpcy5lMmVlTWFuYWdlcixcclxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiBjb25uZWN0T3B0aW9ucy53ZWJzb2NrZXRUaW1lb3V0XHJcbiAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICBsZXQgc2VydmVySW5mbyA9IGpvaW5SZXNwb25zZS5zZXJ2ZXJJbmZvO1xyXG4gICAgICBpZiAoIXNlcnZlckluZm8pIHtcclxuICAgICAgICBzZXJ2ZXJJbmZvID0ge1xyXG4gICAgICAgICAgdmVyc2lvbjogam9pblJlc3BvbnNlLnNlcnZlclZlcnNpb24sXHJcbiAgICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2VydmVySW5mbyA9IHNlcnZlckluZm87XHJcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGVkIHRvIExpdmVraXQgU2VydmVyIFwiLmNvbmNhdChPYmplY3QuZW50cmllcyhzZXJ2ZXJJbmZvKS5tYXAoX3JlZiA9PiB7XHJcbiAgICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQodmFsdWUpO1xyXG4gICAgICB9KS5qb2luKCcsICcpKSwge1xyXG4gICAgICAgIHJvb206IChfYSA9IGpvaW5SZXNwb25zZS5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSxcclxuICAgICAgICByb29tU2lkOiAoX2IgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNpZCxcclxuICAgICAgICBpZGVudGl0eTogKF9jID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWRlbnRpdHlcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghc2VydmVySW5mby52ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkU2VydmVyKCd1bmtub3duIHNlcnZlciB2ZXJzaW9uJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNlcnZlckluZm8udmVyc2lvbiA9PT0gJzAuMTUuMScgJiYgdGhpcy5vcHRpb25zLmR5bmFjYXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIC8vIGR5bmFjYXN0IGhhcyBhIGJ1ZyBpbiAwLjE1LjEsIHNvIHdlIGNhbm5vdCB1c2UgaXQgdGhlblxyXG4gICAgICAgIHJvb21PcHRpb25zLmR5bmFjYXN0ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGpvaW5SZXNwb25zZTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZSA9PiB7XHJcbiAgICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50O1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkID0gcGkuc2lkO1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPSBwaS5pZGVudGl0eTtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEVuYWJsZWRQdWJsaXNoQ29kZWNzKGpvaW5SZXNwb25zZS5lbmFibGVkUHVibGlzaENvZGVjcyk7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSAmJiB0aGlzLmUyZWVNYW5hZ2VyKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0U2lmVHJhaWxlcihqb2luUmVzcG9uc2Uuc2lmVHJhaWxlcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ0NvdWxkIG5vdCBzZXQgU2lmVHJhaWxlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBwb3B1bGF0ZSByZW1vdGUgcGFydGljaXBhbnRzLCB0aGVzZSBzaG91bGQgbm90IHRyaWdnZXIgbmV3IGV2ZW50c1xyXG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcGksIC4uLmpvaW5SZXNwb25zZS5vdGhlclBhcnRpY2lwYW50c10pO1xyXG4gICAgICBpZiAoam9pblJlc3BvbnNlLnJvb20pIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5hdHRlbXB0Q29ubmVjdGlvbiA9ICh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcgfHwgdGhpcy5pc1Jlc3VtaW5nIHx8ICgoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlbmRpbmdSZWNvbm5lY3QpKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnUmVjb25uZWN0aW9uIGF0dGVtcHQgcmVwbGFjZWQgYnkgbmV3IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGNsb3NlIGFuZCByZWNyZWF0ZSB0aGUgZXhpc3RpbmcgZW5naW5lIGluIG9yZGVyIHRvIGdldCByaWQgb2YgYW55IHBvdGVudGlhbGx5IG9uZ29pbmcgcmVjb25uZWN0aW9uIGF0dGVtcHRzXHJcbiAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBlbmdpbmUgaWYgcHJldmlvdXNseSBkaXNjb25uZWN0ZWRcclxuICAgICAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0Nsb3VkKCkpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZS5zZXRSZWdpb25VcmxQcm92aWRlcih0aGlzLnJlZ2lvblVybFByb3ZpZGVyKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKTtcclxuICAgICAgdGhpcy5jb25uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyksIG9wdHMpO1xyXG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5ydGNDb25maWcpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcclxuICAgICAgfVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY29ubmVjdFNpZ25hbCh1cmwsIHRva2VuLCB0aGlzLmVuZ2luZSwgdGhpcy5jb25uT3B0aW9ucywgdGhpcy5vcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcclxuICAgICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxyXG4gICAgICAgIHRoaXMuc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xyXG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcclxuICAgICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSk7XHJcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gXCJcIi5jb25jYXQocmVzdWx0aW5nRXJyb3IubWVzc2FnZSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XHJcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5yZWFzb24gPSBlcnIucmVhc29uO1xyXG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aHJvdyByZXN1bHRpbmdFcnJvcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gYXR0ZW1wdCBhYm9ydGVkXCIsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsIGFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xyXG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGFsc28gaG9vayB1bmxvYWQgZXZlbnRcclxuICAgICAgaWYgKGlzV2ViKCkgJiYgdGhpcy5vcHRpb25zLmRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSkge1xyXG4gICAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1dlYigpKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogZGlzY29ubmVjdHMgdGhlIHJvb20sIGVtaXRzIFtbUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZF1dXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3NfMSA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgICBhcmdzXzFbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgWy4uLmFyZ3NfMV0sIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG4gICAgICAgIGxldCBzdG9wVHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgX3RoaXMyLmRpc2Nvbm5lY3RMb2NrLmxvY2soKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICBfdGhpczIubG9nLmRlYnVnKCdhbHJlYWR5IGRpc2Nvbm5lY3RlZCcsIF90aGlzMi5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IF90aGlzMi5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCBfdGhpczIuaXNSZXN1bWluZykge1xyXG4gICAgICAgICAgICAgIC8vIHRyeSBhYm9ydGluZyBwZW5kaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdFxyXG4gICAgICAgICAgICAgIF90aGlzMi5sb2cud2FybignYWJvcnQgY29ubmVjdGlvbiBhdHRlbXB0JywgX3RoaXMyLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgIChfYSA9IF90aGlzMi5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxyXG4gICAgICAgICAgICAgIChfYyA9IChfYiA9IF90aGlzMi5jb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVqZWN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgbmV3IENvbm5lY3Rpb25FcnJvcignQ2xpZW50IGluaXRpYXRlZCBkaXNjb25uZWN0JywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xyXG4gICAgICAgICAgICAgIF90aGlzMi5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNlbmQgbGVhdmVcclxuICAgICAgICAgICAgaWYgKCEoKF9kID0gX3RoaXMyLmVuZ2luZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkpIHtcclxuICAgICAgICAgICAgICB5aWVsZCBfdGhpczIuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjbG9zZSBlbmdpbmUgKGFsc28gY2xvc2VzIGNsaWVudClcclxuICAgICAgICAgICAgaWYgKF90aGlzMi5lbmdpbmUpIHtcclxuICAgICAgICAgICAgICB5aWVsZCBfdGhpczIuZW5naW5lLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMyLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcclxuICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xyXG4gICAgICAgICAgICBfdGhpczIuZW5naW5lID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdW5sb2NrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSgpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uUGFnZUxlYXZlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLmxvZy5pbmZvKCdQYWdlIGxlYXZlIGRldGVjdGVkLCBkaXNjb25uZWN0aW5nJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgcG9saWNpZXMgcmVnYXJkaW5nIGF1ZGlvIHBsYXliYWNrLiBNb3N0IHJlcXVpcmluZ1xyXG4gICAgICogc29tZSBmb3JtIG9mIHVzZXIgaW50ZXJhY3Rpb24gKGNsaWNrL3RhcC9ldGMpLlxyXG4gICAgICogSW4gdGhvc2UgY2FzZXMsIGF1ZGlvIHdpbGwgYmUgc2lsZW50IHVudGlsIGEgY2xpY2svdGFwIHRyaWdnZXJpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmdcclxuICAgICAqIC0gYHN0YXJ0QXVkaW9gXHJcbiAgICAgKiAtIGBnZXRVc2VyTWVkaWFgXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhcnRBdWRpbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcclxuICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcclxuICAgICAgaWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5vcyA9PT0gJ2lPUycpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpT1MgYmxvY2tzIGF1ZGlvIGVsZW1lbnQgcGxheWJhY2sgaWZcclxuICAgICAgICAgKiAtIHVzZXIgaXMgbm90IHB1Ymxpc2hpbmcgYXVkaW8gdGhlbXNlbHZlcyBhbmRcclxuICAgICAgICAgKiAtIG5vIG90aGVyIGF1ZGlvIHNvdXJjZSBpcyBwbGF5aW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBhcyBhIHdvcmthcm91bmQsIHdlIGNyZWF0ZSBhbiBhdWRpbyBlbGVtZW50IHdpdGggYW4gZW1wdHkgdHJhY2ssIHNvIHRoYXRcclxuICAgICAgICAgKiBzaWxlbnQgYXVkaW8gaXMgYWx3YXlzIHBsYXlpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBhdWRpb0lkID0gJ2xpdmVraXQtZHVtbXktYXVkaW8tZWwnO1xyXG4gICAgICAgIGxldCBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhdWRpb0lkKTtcclxuICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xyXG4gICAgICAgICAgZHVtbXlBdWRpb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcclxuICAgICAgICAgIGR1bW15QXVkaW9FbC5pZCA9IGF1ZGlvSWQ7XHJcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuYXV0b3BsYXkgPSB0cnVlO1xyXG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICBjb25zdCB0cmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xyXG4gICAgICAgICAgdHJhY2suZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oW3RyYWNrXSk7XHJcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBzcmNPYmplY3QgdG8gbnVsbCBvbiBwYWdlIGhpZGUgaW4gb3JkZXIgdG8gcHJldmVudCBsb2NrIHNjcmVlbiBjb250cm9scyB0byBzaG93IHVwIGZvciBpdFxyXG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gZG9jdW1lbnQuaGlkZGVuID8gbnVsbCA6IHN0cmVhbTtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4pIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncGFnZSB2aXNpYmxlIGFnYWluLCB0cmlnZ2VyaW5nIHN0YXJ0QXVkaW8gdG8gcmVzdW1lIHBsYXliYWNrIGFuZCB1cGRhdGUgcGxheWJhY2sgc3RhdHVzJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXVkaW8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkdW1teUF1ZGlvRWwpO1xyXG4gICAgICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsICgpID0+IHtcclxuICAgICAgICAgICAgZHVtbXlBdWRpb0VsID09PSBudWxsIHx8IGR1bW15QXVkaW9FbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHVtbXlBdWRpb0VsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBudWxsO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZHVtbXlBdWRpb0VsKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgIHAuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHQgPT4ge1xyXG4gICAgICAgICAgaWYgKHQudHJhY2spIHtcclxuICAgICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKSwgLi4uZWxlbWVudHMubWFwKGUgPT4ge1xyXG4gICAgICAgICAgZS5tdXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIGUucGxheSgpO1xyXG4gICAgICAgIH0pXSk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCgpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQoZXJyKTtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zdGFydFZpZGVvID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcclxuICAgICAgICBwLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCh0ciA9PiB7XHJcbiAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAoX2EgPSB0ci50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudHMuaW5jbHVkZXMoZWwpKSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKGVsZW1lbnRzLm1hcChlbCA9PiBlbC5wbGF5KCkpKS50aGVuKCgpID0+IHtcclxuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XHJcbiAgICAgIH0pLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5sb2cud2FybignUmVzdW1pbmcgdmlkZW8gcGxheWJhY2sgZmFpbGVkLCBtYWtlIHN1cmUgeW91IGNhbGwgYHN0YXJ0VmlkZW9gIGRpcmVjdGx5IGluIGEgdXNlciBnZXN0dXJlIGhhbmRsZXInLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcclxuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcclxuICAgICAgLy8gaW4gY2FzZSB3ZSB3ZW50IGZyb20gcmVzdW1pbmcgdG8gZnVsbC1yZWNvbm5lY3QsIG1ha2Ugc3VyZSB0byByZWZsZWN0IGl0IG9uIHRoZSBpc1Jlc3VtaW5nIGZsYWdcclxuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XHJcbiAgICAgIC8vIGFsc28gdW53aW5kIGV4aXN0aW5nIHBhcnRpY2lwYW50cyAmIGV4aXN0aW5nIHN1YnNjcmlwdGlvbnNcclxuICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwLmlkZW50aXR5LCBwKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RpbmcpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBqb2luUmVzcG9uc2UgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXIsIHJlZ2lvbiBcIi5jb25jYXQoam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxyXG4gICAgICB9KSk7XHJcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcclxuICAgICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcclxuICAgICAgICB5aWVsZCB0aGlzLmxvY2FsUGFydGljaXBhbnQucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHRyeWluZyB0byByZS1wdWJsaXNoIHRyYWNrcyBhZnRlciByZWNvbm5lY3Rpb24nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcclxuICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xyXG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZnVsbHkgcmVjb25uZWN0ZWQgdG8gc2VydmVyXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9IGNhdGNoIChfYSkge1xyXG4gICAgICAgIC8vIHJlY29ubmVjdGlvbiBmYWlsZWQsIGhhbmRsZURpc2Nvbm5lY3QgaXMgYmVpbmcgaW52b2tlZCBhbHJlYWR5LCBqdXN0IHJldHVybiBoZXJlXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5SZWNvbm5lY3RlZCk7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkRXZlbnRzKCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzID0gcGFydGljaXBhbnRJbmZvcyA9PiB7XHJcbiAgICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHBhcnRpY2lwYW50IHN0YXRlLCBhbmQgc2VuZCBldmVudHNcclxuICAgICAgcGFydGljaXBhbnRJbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoaW5mby5pZGVudGl0eSA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB7XHJcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTGl2ZUtpdCBzZXJ2ZXIgZG9lc24ndCBzZW5kIGlkZW50aXR5IGluZm8gcHJpb3IgdG8gdmVyc2lvbiAxLjUuMiBpbiBkaXNjb25uZWN0IHVwZGF0ZXNcclxuICAgICAgICAvLyBzbyB3ZSB0cnkgdG8gbWFwIGFuIGVtcHR5IGlkZW50aXR5IHRvIGFuIGFscmVhZHkga25vd24gc0lEIG1hbnVhbGx5XHJcbiAgICAgICAgaWYgKGluZm8uaWRlbnRpdHkgPT09ICcnKSB7XHJcbiAgICAgICAgICBpbmZvLmlkZW50aXR5ID0gKF9hID0gdGhpcy5zaWRUb0lkZW50aXR5LmdldChpbmZvLnNpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaW5mby5pZGVudGl0eSk7XHJcbiAgICAgICAgLy8gd2hlbiBpdCdzIGRpc2Nvbm5lY3RlZCwgc2VuZCB1cGRhdGVzXHJcbiAgICAgICAgaWYgKGluZm8uc3RhdGUgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5ESVNDT05ORUNURUQpIHtcclxuICAgICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaW5mby5pZGVudGl0eSwgcmVtb3RlUGFydGljaXBhbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBjcmVhdGUgcGFydGljaXBhbnQgaWYgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcclxuICAgIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUgPSBzcGVha2VycyA9PiB7XHJcbiAgICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gW107XHJcbiAgICAgIGNvbnN0IHNlZW5TaWRzID0ge307XHJcbiAgICAgIHNwZWFrZXJzLmZvckVhY2goc3BlYWtlciA9PiB7XHJcbiAgICAgICAgc2VlblNpZHNbc3BlYWtlci5zaWRdID0gdHJ1ZTtcclxuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcclxuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcclxuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKHRydWUpO1xyXG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHNwZWFrZXIuc2lkKTtcclxuICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XHJcbiAgICAgICAgICAgIHAuc2V0SXNTcGVha2luZyh0cnVlKTtcclxuICAgICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoIXNlZW5TaWRzW3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRdKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSAwO1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICAgIGlmICghc2VlblNpZHNbcC5zaWRdKSB7XHJcbiAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSAwO1xyXG4gICAgICAgICAgcC5zZXRJc1NwZWFraW5nKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gYWN0aXZlU3BlYWtlcnM7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xyXG4gICAgfTtcclxuICAgIC8vIHByb2Nlc3MgbGlzdCBvZiBjaGFuZ2VkIHNwZWFrZXJzXHJcbiAgICB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZCA9IHNwZWFrZXJVcGRhdGVzID0+IHtcclxuICAgICAgY29uc3QgbGFzdFNwZWFrZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocC5pZGVudGl0eSk7XHJcbiAgICAgICAgaWYgKHJlbW90ZVBhcnRpY2lwYW50ICYmIHJlbW90ZVBhcnRpY2lwYW50LnNpZCAhPT0gcC5zaWQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGFzdFNwZWFrZXJzLnNldChwLnNpZCwgcCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKHNwZWFrZXIgPT4ge1xyXG4gICAgICAgIGxldCBwID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHNwZWFrZXIuc2lkKTtcclxuICAgICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcclxuICAgICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwLmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xyXG4gICAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XHJcbiAgICAgICAgaWYgKHNwZWFrZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHNwZWFrZXIuc2lkLCBwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGFzdFNwZWFrZXJzLmRlbGV0ZShzcGVha2VyLnNpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBBcnJheS5mcm9tKGxhc3RTcGVha2Vycy52YWx1ZXMoKSk7XHJcbiAgICAgIGFjdGl2ZVNwZWFrZXJzLnNvcnQoKGEsIGIpID0+IGIuYXVkaW9MZXZlbCAtIGEuYXVkaW9MZXZlbCk7XHJcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBhY3RpdmVTcGVha2VycztcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSA9IHN0cmVhbVN0YXRlVXBkYXRlID0+IHtcclxuICAgICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goc3RyZWFtU3RhdGUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHN0cmVhbVN0YXRlLnBhcnRpY2lwYW50U2lkKTtcclxuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzdHJlYW1TdGF0ZS50cmFja1NpZCk7XHJcbiAgICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdTdHJlYW1TdGF0ZSA9IFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvKHN0cmVhbVN0YXRlLnN0YXRlKTtcclxuICAgICAgICBpZiAobmV3U3RyZWFtU3RhdGUgIT09IHB1Yi50cmFjay5zdHJlYW1TdGF0ZSkge1xyXG4gICAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gbmV3U3RyZWFtU3RhdGU7XHJcbiAgICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcclxuICAgICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkLCBwdWIsIHB1Yi50cmFjay5zdHJlYW1TdGF0ZSwgcGFydGljaXBhbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHtcclxuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcclxuICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodXBkYXRlLnRyYWNrU2lkKTtcclxuICAgICAgaWYgKCFwdWIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcHViLnNldEFsbG93ZWQodXBkYXRlLmFsbG93ZWQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IgPSB1cGRhdGUgPT4ge1xyXG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQocCA9PiBwLnRyYWNrUHVibGljYXRpb25zLmhhcyh1cGRhdGUudHJhY2tTaWQpKTtcclxuICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodXBkYXRlLnRyYWNrU2lkKTtcclxuICAgICAgaWYgKCFwdWIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgcHViLnNldFN1YnNjcmlwdGlvbkVycm9yKHVwZGF0ZS5lcnIpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlRGF0YVBhY2tldCA9IHBhY2tldCA9PiB7XHJcbiAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XHJcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcclxuICAgICAgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAndXNlcicpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSwgcGFja2V0LmtpbmQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAndHJhbnNjcmlwdGlvbicpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zY3JpcHRpb24ocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzaXBEdG1mJykge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU2lwRHRtZihwYXJ0aWNpcGFudCwgcGFja2V0LnZhbHVlLnZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ2NoYXRNZXNzYWdlJykge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhdE1lc3NhZ2UocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdtZXRyaWNzJykge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTWV0cmljcyhwYWNrZXQudmFsdWUudmFsdWUsIHBhcnRpY2lwYW50KTtcclxuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUhlYWRlcicpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUhlYWRlcihwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5KTtcclxuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUNodW5rJykge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtQ2h1bmsocGFja2V0LnZhbHVlLnZhbHVlKTtcclxuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbVRyYWlsZXInKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW1UcmFpbGVyKHBhY2tldC52YWx1ZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdycGNSZXF1ZXN0Jykge1xyXG4gICAgICAgIGNvbnN0IHJwYyA9IHBhY2tldC52YWx1ZS52YWx1ZTtcclxuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVxdWVzdChwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSwgcnBjLmlkLCBycGMubWV0aG9kLCBycGMucGF5bG9hZCwgcnBjLnJlc3BvbnNlVGltZW91dE1zLCBycGMudmVyc2lvbik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQgPSAocGFydGljaXBhbnQsIHVzZXJQYWNrZXQsIGtpbmQpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwgcGFydGljaXBhbnQsIGtpbmQsIHVzZXJQYWNrZXQudG9waWMpO1xyXG4gICAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XHJcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlU2lwRHRtZiA9IChwYXJ0aWNpcGFudCwgZHRtZikgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpcERUTUZSZWNlaXZlZCwgZHRtZiwgcGFydGljaXBhbnQpO1xyXG4gICAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XHJcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuU2lwRFRNRlJlY2VpdmVkLCBkdG1mKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmJ1ZmZlcmVkU2VnbWVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLmhhbmRsZVRyYW5zY3JpcHRpb24gPSAoX3JlbW90ZVBhcnRpY2lwYW50LCB0cmFuc2NyaXB0aW9uKSA9PiB7XHJcbiAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XHJcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdHJhbnNjcmlwdGlvbi50cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA/IHRoaXMubG9jYWxQYXJ0aWNpcGFudCA6IHRoaXMuZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KHRyYW5zY3JpcHRpb24udHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5KTtcclxuICAgICAgY29uc3QgcHVibGljYXRpb24gPSBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYW5zY3JpcHRpb24udHJhY2tJZCk7XHJcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gZXh0cmFjdFRyYW5zY3JpcHRpb25TZWdtZW50cyh0cmFuc2NyaXB0aW9uLCB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzKTtcclxuICAgICAgcHVibGljYXRpb24gPT09IG51bGwgfHwgcHVibGljYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHB1YmxpY2F0aW9uLmVtaXQoVHJhY2tFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzKTtcclxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzLCBwdWJsaWNhdGlvbik7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cywgcGFydGljaXBhbnQsIHB1YmxpY2F0aW9uKTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUNoYXRNZXNzYWdlID0gKHBhcnRpY2lwYW50LCBjaGF0TWVzc2FnZSkgPT4ge1xyXG4gICAgICBjb25zdCBtc2cgPSBleHRyYWN0Q2hhdE1lc3NhZ2UoY2hhdE1lc3NhZ2UpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNoYXRNZXNzYWdlLCBtc2csIHBhcnRpY2lwYW50KTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZU1ldHJpY3MgPSAobWV0cmljcywgcGFydGljaXBhbnQpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZXRyaWNzUmVjZWl2ZWQsIG1ldHJpY3MsIHBhcnRpY2lwYW50KTtcclxuICAgIH07XHJcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkID0gZSA9PiB7XHJcbiAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwbGF5YmFjayBhdWRpbycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGVycm9yOiBlXHJcbiAgICAgIH0pKTtcclxuICAgICAgaWYgKCF0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcclxuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcclxuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGlmICgoKF9hID0gZ2V0QnJvd3NlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3MpICE9PSAnaU9TJykge1xyXG4gICAgICAgIC8vIGRlZmF1bHQgZGV2aWNlcyBhcmUgbm9uIGRldGVybWluaXN0aWMgb24gaU9TLCBzbyB3ZSBkb24ndCBhdHRlbXB0IHRvIHNlbGVjdCB0aGVtIGhlcmVcclxuICAgICAgICB5aWVsZCB0aGlzLnNlbGVjdERlZmF1bHREZXZpY2VzKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNDaGFuZ2VkKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYW5kbGVSb29tVXBkYXRlID0gcm9vbSA9PiB7XHJcbiAgICAgIGNvbnN0IG9sZFJvb20gPSB0aGlzLnJvb21JbmZvO1xyXG4gICAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcclxuICAgICAgaWYgKG9sZFJvb20gJiYgb2xkUm9vbS5tZXRhZGF0YSAhPT0gcm9vbS5tZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJvb21NZXRhZGF0YUNoYW5nZWQsIHJvb20ubWV0YWRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICgob2xkUm9vbSA9PT0gbnVsbCB8fCBvbGRSb29tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRSb29tLmFjdGl2ZVJlY29yZGluZykgIT09IHJvb20uYWN0aXZlUmVjb3JkaW5nKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCwgcm9vbS5hY3RpdmVSZWNvcmRpbmcpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhpcy5oYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XHJcbiAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goaW5mbyA9PiB7XHJcbiAgICAgICAgaWYgKGluZm8ucGFydGljaXBhbnRTaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcclxuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChpbmZvLnBhcnRpY2lwYW50U2lkKTtcclxuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcclxuICAgICAgICAgIHBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCA9IG1ldGFkYXRhID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCA9IG5hbWUgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsQXR0cmlidXRlc0NoYW5nZWQgPSBjaGFuZ2VkQXR0cmlidXRlcyA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZCA9IHB1YiA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCA9IHB1YiA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlID0gcHJvY2Vzc29yID0+IHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICAoX2EgPSBwcm9jZXNzb3IgPT09IG51bGwgfHwgcHJvY2Vzc29yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzb3Iub25QdWJsaXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9jZXNzb3IsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgIChfYSA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XHJcbiAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uKFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCk7XHJcbiAgICAgIChfZSA9IChfZCA9IChfYyA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFByb2Nlc3NvcigpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qub25QdWJsaXNoKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCwgdGhpcyk7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrKSkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrSXNTaWxlbnQgPSB5aWVsZCBwdWIudHJhY2suY2hlY2tGb3JTaWxlbmNlKCk7XHJcbiAgICAgICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcclxuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCAoX2YgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXREZXZpY2VJZChmYWxzZSk7XHJcbiAgICAgIGNvbnN0IGRldmljZUtpbmQgPSBzb3VyY2VUb0tpbmQocHViLnNvdXJjZSk7XHJcbiAgICAgIGlmIChkZXZpY2VLaW5kICYmIGRldmljZUlkICYmIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKSkge1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGRldmljZUtpbmQsIGRldmljZUlkKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gcHViID0+IHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2ZmKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XHJcbiAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9mZihUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMub25Mb2NhbFRyYWNrUmVzdGFydGVkID0gdHJhY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBjb25zdCBkZXZpY2VJZCA9IHlpZWxkIHRyYWNrLmdldERldmljZUlkKGZhbHNlKTtcclxuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZCh0cmFjay5zb3VyY2UpO1xyXG4gICAgICBpZiAoZGV2aWNlS2luZCAmJiBkZXZpY2VJZCAmJiBkZXZpY2VJZCAhPT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZCkpIHtcclxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcImxvY2FsIHRyYWNrIHJlc3RhcnRlZCwgc2V0dGluZyBcIi5jb25jYXQoZGV2aWNlS2luZCwgXCIgXCIpLmNvbmNhdChkZXZpY2VJZCwgXCIgYWN0aXZlXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsIGRldmljZUtpbmQsIGRldmljZUlkKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSBxdWFsaXR5ID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yID0gKGUsIGtpbmQpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNFcnJvciwgZSwga2luZCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSBwcmV2UGVybWlzc2lvbnMgPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50ID0gbXNnID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5DaGF0TWVzc2FnZSwgbXNnLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XHJcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuc2lkVG9JZGVudGl0eSA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vbU9wdGlvbkRlZmF1bHRzKSwgb3B0aW9ucyk7XHJcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUm9vbSk7XHJcbiAgICB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdWRpb0RlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzKTtcclxuICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XHJcbiAgICB0aGlzLm9wdGlvbnMucHVibGlzaERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHVibGlzaERlZmF1bHRzKTtcclxuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcclxuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgXygpO1xyXG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50ID0gbmV3IExvY2FsUGFydGljaXBhbnQoJycsICcnLCB0aGlzLmVuZ2luZSwgdGhpcy5vcHRpb25zLCB0aGlzLnJwY0hhbmRsZXJzKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpIHtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldCgnYXVkaW9pbnB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoKF9iID0gdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV2aWNlSWQpIHtcclxuICAgICAgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2UoJ2F1ZGlvb3V0cHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQpKS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XHJcbiAgICAgIHRoaXMuc2V0dXBFMkVFKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNXZWIoKSkge1xyXG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgIC8vIGluIG9yZGVyIHRvIGNhdGNoIGRldmljZSBjaGFuZ2VzIHByaW9yIHRvIHJvb20gY29ubmVjdGlvbiB3ZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBldmVudCBpbiB0aGUgY29uc3RydWN0b3JcclxuICAgICAgKF9jID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlLCB7XHJcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoUm9vbS5jbGVhbnVwUmVnaXN0cnkpIHtcclxuICAgICAgICBSb29tLmNsZWFudXBSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCAoKSA9PiB7XHJcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmhhcyh0b3BpYykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGV4dCBzdHJlYW0gaGFuZGxlciBmb3IgdG9waWMgXFxcIlwiLmNvbmNhdCh0b3BpYywgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gc2V0LlwiKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5zZXQodG9waWMsIGNhbGxiYWNrKTtcclxuICB9XHJcbiAgdW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKSB7XHJcbiAgICB0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5kZWxldGUodG9waWMpO1xyXG4gIH1cclxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLmhhcyh0b3BpYykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgYnl0ZSBzdHJlYW0gaGFuZGxlciBmb3IgdG9waWMgXFxcIlwiLmNvbmNhdCh0b3BpYywgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gc2V0LlwiKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5zZXQodG9waWMsIGNhbGxiYWNrKTtcclxuICB9XHJcbiAgdW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKSB7XHJcbiAgICB0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5kZWxldGUodG9waWMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBFc3RhYmxpc2hlcyB0aGUgcGFydGljaXBhbnQgYXMgYSByZWNlaXZlciBmb3IgY2FsbHMgb2YgdGhlIHNwZWNpZmllZCBSUEMgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBpbmRpY2F0ZWQgUlBDIG1ldGhvZFxyXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gV2lsbCBiZSBpbnZva2VkIHdoZW4gYW4gUlBDIHJlcXVlc3QgZm9yIHRoaXMgbWV0aG9kIGlzIHJlY2VpdmVkXHJcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbWV0aG9kIGlzIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkXHJcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGEgaGFuZGxlciBmb3IgdGhpcyBtZXRob2QgaXMgYWxyZWFkeSByZWdpc3RlcmVkIChtdXN0IGNhbGwgdW5yZWdpc3RlclJwY01ldGhvZCBmaXJzdClcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIHJvb20ubG9jYWxQYXJ0aWNpcGFudD8ucmVnaXN0ZXJScGNNZXRob2QoXHJcbiAgICogICAnZ3JlZXQnLFxyXG4gICAqICAgYXN5bmMgKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiB7XHJcbiAgICogICAgIGNvbnNvbGUubG9nKGBSZWNlaXZlZCBncmVldGluZyBmcm9tICR7ZGF0YS5jYWxsZXJJZGVudGl0eX06ICR7ZGF0YS5wYXlsb2FkfWApO1xyXG4gICAqICAgICByZXR1cm4gYEhlbGxvLCAke2RhdGEuY2FsbGVySWRlbnRpdHl9IWA7XHJcbiAgICogICB9XHJcbiAgICogKTtcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIFRoZSBoYW5kbGVyIHNob3VsZCByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcuXHJcbiAgICogSWYgdW5hYmxlIHRvIHJlc3BvbmQgd2l0aGluIGByZXNwb25zZVRpbWVvdXRgLCB0aGUgcmVxdWVzdCB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciBvbiB0aGUgY2FsbGVyJ3Mgc2lkZS5cclxuICAgKlxyXG4gICAqIFlvdSBtYXkgdGhyb3cgZXJyb3JzIG9mIHR5cGUgYFJwY0Vycm9yYCB3aXRoIGEgc3RyaW5nIGBtZXNzYWdlYCBpbiB0aGUgaGFuZGxlcixcclxuICAgKiBhbmQgdGhleSB3aWxsIGJlIHJlY2VpdmVkIG9uIHRoZSBjYWxsZXIncyBzaWRlIHdpdGggdGhlIG1lc3NhZ2UgaW50YWN0LlxyXG4gICAqIE90aGVyIGVycm9ycyB0aHJvd24gaW4geW91ciBoYW5kbGVyIHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIGFzLWlzLCBhbmQgd2lsbCBpbnN0ZWFkIGFycml2ZSB0byB0aGUgY2FsbGVyIGFzIGAxNTAwYCAoXCJBcHBsaWNhdGlvbiBFcnJvclwiKS5cclxuICAgKi9cclxuICByZWdpc3RlclJwY01ldGhvZChtZXRob2QsIGhhbmRsZXIpIHtcclxuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XHJcbiAgICAgIHRocm93IEVycm9yKFwiUlBDIGhhbmRsZXIgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtZXRob2QgXCIuY29uY2F0KG1ldGhvZCwgXCIsIHVucmVnaXN0ZXJScGNNZXRob2QgYmVmb3JlIHRyeWluZyB0byByZWdpc3RlciBhZ2FpblwiKSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBVbnJlZ2lzdGVycyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBSUEMgbWV0aG9kIHRvIHVucmVnaXN0ZXJcclxuICAgKi9cclxuICB1bnJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcclxuICB9XHJcbiAgaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0KGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG1ldGhvZCwgcGF5bG9hZCwgcmVzcG9uc2VUaW1lb3V0LCB2ZXJzaW9uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjQWNrKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQpO1xyXG4gICAgICBpZiAodmVyc2lvbiAhPT0gMSkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBudWxsLCBScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9WRVJTSU9OJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5ycGNIYW5kbGVycy5nZXQobWV0aG9kKTtcclxuICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1VOU1VQUE9SVEVEX01FVEhPRCcpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHJlc3BvbnNlRXJyb3IgPSBudWxsO1xyXG4gICAgICBsZXQgcmVzcG9uc2VQYXlsb2FkID0gbnVsbDtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGhhbmRsZXIoe1xyXG4gICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgY2FsbGVySWRlbnRpdHksXHJcbiAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgICAgcmVzcG9uc2VUaW1lb3V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGJ5dGVMZW5ndGgocmVzcG9uc2UpID4gTUFYX1BBWUxPQURfQllURVMpIHtcclxuICAgICAgICAgIHJlc3BvbnNlRXJyb3IgPSBScGNFcnJvci5idWlsdEluKCdSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRScpO1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwiUlBDIFJlc3BvbnNlIHBheWxvYWQgdG9vIGxhcmdlIGZvciBcIi5jb25jYXQobWV0aG9kKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc3BvbnNlUGF5bG9hZCA9IHJlc3BvbnNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBScGNFcnJvcikge1xyXG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBlcnJvciByZXR1cm5lZCBieSBSUEMgaGFuZGxlciBmb3IgXCIuY29uY2F0KG1ldGhvZCwgXCIuIFJldHVybmluZyBBUFBMSUNBVElPTl9FUlJPUiBpbnN0ZWFkLlwiKSwgZXJyb3IpO1xyXG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IFJwY0Vycm9yLmJ1aWx0SW4oJ0FQUExJQ0FUSU9OX0VSUk9SJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCByZXNwb25zZVBheWxvYWQsIHJlc3BvbnNlRXJyb3IpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBleHBlcmltZW50YWxcclxuICAgKi9cclxuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xyXG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCldKTtcclxuICAgICAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ICE9PSAnJykge1xyXG4gICAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IEVycm9yKCdlMmVlIG5vdCBjb25maWd1cmVkLCBwbGVhc2Ugc2V0IGUyZWUgc2V0dGluZ3Mgd2l0aGluIHRoZSByb29tIG9wdGlvbnMnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldHVwRTJFRSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZTJlZSkge1xyXG4gICAgICBpZiAoJ2UyZWVNYW5hZ2VyJyBpbiB0aGlzLm9wdGlvbnMuZTJlZSkge1xyXG4gICAgICAgIHRoaXMuZTJlZU1hbmFnZXIgPSB0aGlzLm9wdGlvbnMuZTJlZS5lMmVlTWFuYWdlcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gbmV3IEUyRUVNYW5hZ2VyKHRoaXMub3B0aW9ucy5lMmVlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCAoZW5hYmxlZCwgcGFydGljaXBhbnQpID0+IHtcclxuICAgICAgICBpZiAoaXNMb2NhbFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KSkge1xyXG4gICAgICAgICAgdGhpcy5pc0UyRUVFbmFibGVkID0gZW5hYmxlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yID0+IHRoaXMuZW1pdChSb29tRXZlbnQuRW5jcnlwdGlvbkVycm9yLCBlcnJvcikpO1xyXG4gICAgICAoX2EgPSB0aGlzLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0dXAodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldCBsb2dDb250ZXh0KCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcm9vbTogdGhpcy5uYW1lLFxyXG4gICAgICByb29tSUQ6IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaWQsXHJcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXHJcbiAgICAgIHBJRDogdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZFxyXG4gICAgfTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogaWYgdGhlIGN1cnJlbnQgcm9vbSBoYXMgYSBwYXJ0aWNpcGFudCB3aXRoIGByZWNvcmRlcjogdHJ1ZWAgaW4gaXRzIEpXVCBncmFudFxyXG4gICAqKi9cclxuICBnZXQgaXNSZWNvcmRpbmcoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVSZWNvcmRpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBzZXJ2ZXIgYXNzaWduZWQgdW5pcXVlIHJvb20gaWQuXHJcbiAgICogcmV0dXJucyBvbmNlIGEgc2lkIGhhcyBiZWVuIGlzc3VlZCBieSB0aGUgc2VydmVyLlxyXG4gICAqL1xyXG4gIGdldFNpZCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnJvb21JbmZvICYmIHRoaXMucm9vbUluZm8uc2lkICE9PSAnJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb21JbmZvLnNpZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZVJvb21VcGRhdGUgPSByb29tSW5mbyA9PiB7XHJcbiAgICAgICAgICBpZiAocm9vbUluZm8uc2lkICE9PSAnJykge1xyXG4gICAgICAgICAgICB0aGlzLmVuZ2luZS5vZmYoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgaGFuZGxlUm9vbVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIHJlc29sdmUocm9vbUluZm8uc2lkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xyXG4gICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmVuZ2luZS5vZmYoRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgaGFuZGxlUm9vbVVwZGF0ZSk7XHJcbiAgICAgICAgICByZWplY3QoJ1Jvb20gZGlzY29ubmVjdGVkIGJlZm9yZSByb29tIHNlcnZlciBpZCB3YXMgYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8qKiB1c2VyIGFzc2lnbmVkIG5hbWUsIGRlcml2ZWQgZnJvbSBKV1QgdG9rZW4gKi9cclxuICBnZXQgbmFtZSgpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xyXG4gIH1cclxuICAvKiogcm9vbSBtZXRhZGF0YSAqL1xyXG4gIGdldCBtZXRhZGF0YSgpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0YWRhdGE7XHJcbiAgfVxyXG4gIGdldCBudW1QYXJ0aWNpcGFudHMoKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1QYXJ0aWNpcGFudHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgfVxyXG4gIGdldCBudW1QdWJsaXNoZXJzKCkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUHVibGlzaGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICB9XHJcbiAgbWF5YmVDcmVhdGVFbmdpbmUoKSB7XHJcbiAgICBpZiAodGhpcy5lbmdpbmUgJiYgIXRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZW5naW5lID0gbmV3IFJUQ0VuZ2luZSh0aGlzLm9wdGlvbnMpO1xyXG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB0aGlzLmhhbmRsZVJvb21VcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQpLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSkub24oRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpLm9uKEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgdGhpcy5vblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcik7XHJcbiAgICB9KS5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIHJlYXNvbiA9PiB7XHJcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcclxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkFjdGl2ZVNwZWFrZXJzVXBkYXRlLCB0aGlzLmhhbmRsZUFjdGl2ZVNwZWFrZXJzVXBkYXRlKS5vbihFbmdpbmVFdmVudC5EYXRhUGFja2V0UmVjZWl2ZWQsIHRoaXMuaGFuZGxlRGF0YVBhY2tldCkub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcclxuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcclxuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5TaWduYWxSZWNvbm5lY3RpbmcpKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxSZWNvbm5lY3RpbmcpO1xyXG4gICAgICB9XHJcbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN1bWVkLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZXN1bWVkIHNpZ25hbCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcclxuICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zKCk7XHJcbiAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkRXZlbnRzKCk7XHJcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkpIHtcclxuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcclxuICAgICAgfVxyXG4gICAgfSkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgKCkgPT4ge1xyXG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZykge1xyXG4gICAgICAgIHRoaXMuc2VuZFN5bmNTdGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KS5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgdGhpcy5oYW5kbGVTaWduYWxSZXN0YXJ0ZWQpLm9uKEVuZ2luZUV2ZW50Lk9mZmxpbmUsICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xyXG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcclxuICAgICAgfVxyXG4gICAgfSkub24oRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCAoc3RhdHVzLCBraW5kKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xyXG4gICAgfSkub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHN1YnNjcmliZWRTaWQgPT4ge1xyXG4gICAgICBjb25zdCB0cmFja1B1YmxpY2F0aW9uID0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25zKCkuZmluZChfcmVmMiA9PiB7XHJcbiAgICAgICAgbGV0IHtcclxuICAgICAgICAgIHRyYWNrU2lkXHJcbiAgICAgICAgfSA9IF9yZWYyO1xyXG4gICAgICAgIHJldHVybiB0cmFja1NpZCA9PT0gc3Vic2NyaWJlZFNpZDtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICghdHJhY2tQdWJsaWNhdGlvbikge1xyXG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmaW5kIGxvY2FsIHRyYWNrIHN1YnNjcmlwdGlvbiBmb3Igc3Vic2NyaWJlZCBldmVudCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrUHVibGljYXRpb24pO1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tQdWJsaWNhdGlvbiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJvb21Nb3ZlZCwgcm9vbU1vdmVkID0+IHtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jvb20gbW92ZWQnLCByb29tTW92ZWQpO1xyXG4gICAgICBpZiAocm9vbU1vdmVkLnJvb20pIHtcclxuICAgICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUocm9vbU1vdmVkLnJvb20pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50LCBpZGVudGl0eSkgPT4ge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaWRlbnRpdHksIHBhcnRpY2lwYW50KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTW92ZWQsIHJvb21Nb3ZlZC5yb29tLm5hbWUpO1xyXG4gICAgICBpZiAocm9vbU1vdmVkLnBhcnRpY2lwYW50KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMoW3Jvb21Nb3ZlZC5wYXJ0aWNpcGFudCwgLi4ucm9vbU1vdmVkLm90aGVyUGFydGljaXBhbnRzXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQYXJ0aWNpcGFudFVwZGF0ZXMocm9vbU1vdmVkLm90aGVyUGFydGljaXBhbnRzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50KSB7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXR1cEVuZ2luZSh0aGlzLmVuZ2luZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xyXG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXHJcbiAgICogSW4gcGFydGljdWxhciwgaXQgcmVxdWVzdHMgZGV2aWNlIHBlcm1pc3Npb25zIGJ5IGRlZmF1bHQgaWYgbmVlZGVkXHJcbiAgICogYW5kIG1ha2VzIHN1cmUgdGhlIHJldHVybmVkIGRldmljZSBkb2VzIG5vdCBjb25zaXN0IG9mIGR1bW15IGRldmljZXNcclxuICAgKiBAcGFyYW0ga2luZFxyXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgbG9jYWwgZGV2aWNlc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRMb2NhbERldmljZXMoa2luZCkge1xyXG4gICAgbGV0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcclxuICAgIHJldHVybiBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyhraW5kLCByZXF1ZXN0UGVybWlzc2lvbnMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBwcmVwYXJlQ29ubmVjdGlvbiBzaG91bGQgYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgbG9hZGVkLCBpbiBvcmRlclxyXG4gICAqIHRvIHNwZWVkIHVwIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIFRoaXMgZnVuY3Rpb24gd2lsbFxyXG4gICAqIC0gcGVyZm9ybSBETlMgcmVzb2x1dGlvbiBhbmQgcHJlLXdhcm0gdGhlIEROUyBjYWNoZVxyXG4gICAqIC0gZXN0YWJsaXNoIFRMUyBjb25uZWN0aW9uIGFuZCBjYWNoZSBUTFMga2V5c1xyXG4gICAqXHJcbiAgICogV2l0aCBMaXZlS2l0IENsb3VkLCBpdCB3aWxsIGFsc28gZGV0ZXJtaW5lIHRoZSBiZXN0IGVkZ2UgZGF0YSBjZW50ZXIgZm9yXHJcbiAgICogdGhlIGN1cnJlbnQgY2xpZW50IHRvIGNvbm5lY3QgdG8gaWYgYSB0b2tlbiBpcyBwcm92aWRlZC5cclxuICAgKi9cclxuICBwcmVwYXJlQ29ubmVjdGlvbih1cmwsIHRva2VuKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmIChpc0Nsb3VkKG5ldyBVUkwodXJsKSkgJiYgdG9rZW4pIHtcclxuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XHJcbiAgICAgICAgICBjb25zdCByZWdpb25VcmwgPSB5aWVsZCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XHJcbiAgICAgICAgICAvLyB3ZSB3aWxsIG5vdCByZXBsYWNlIHRoZSByZWdpb25VcmwgaWYgYW4gYXR0ZW1wdCBoYWQgYWxyZWFkeSBzdGFydGVkXHJcbiAgICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcclxuICAgICAgICAgIGlmIChyZWdpb25VcmwgJiYgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lvblVybCA9IHJlZ2lvblVybDtcclxuICAgICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHtcclxuICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5aWVsZCBmZXRjaCh0b0h0dHBVcmwodXJsKSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJ1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHByZXBhcmUgY29ubmVjdGlvbicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgZXJyb3I6IGVcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxyXG4gICAqIEBwYXJhbSBpZGVudGl0eVxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGlkZW50aXR5KSB7XHJcbiAgICBpZiAodGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSBpZGVudGl0eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpZGVudGl0eSk7XHJcbiAgfVxyXG4gIGNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKSB7XHJcbiAgICB0aGlzLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbCBmb3IgdGVzdGluZ1xyXG4gICAqL1xyXG4gIHNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8sIGFyZykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiB7fTtcclxuICAgICAgbGV0IHJlcTtcclxuICAgICAgc3dpdGNoIChzY2VuYXJpbykge1xyXG4gICAgICAgIGNhc2UgJ3NpZ25hbC1yZWNvbm5lY3QnOlxyXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXHJcbiAgICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgZGlzY29ubmVjdCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3BlYWtlcic6XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ3NwZWFrZXJVcGRhdGUnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiAzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbm9kZS1mYWlsdXJlJzpcclxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcclxuICAgICAgICAgICAgc2NlbmFyaW86IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnbm9kZUZhaWx1cmUnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc2VydmVyLWxlYXZlJzpcclxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcclxuICAgICAgICAgICAgc2NlbmFyaW86IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnc2VydmVyTGVhdmUnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbWlncmF0aW9uJzpcclxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcclxuICAgICAgICAgICAgc2NlbmFyaW86IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnbWlncmF0aW9uJyxcclxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3Jlc3VtZS1yZWNvbm5lY3QnOlxyXG4gICAgICAgICAgdGhpcy5lbmdpbmUuZmFpbE5leHQoKTtcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxyXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUnOlxyXG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZScsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUtbm8tbWVzc2FnZXMnOlxyXG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZU5vTWVzc2FnZXMnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZnVsbC1yZWNvbm5lY3QnOlxyXG4gICAgICAgICAgdGhpcy5lbmdpbmUuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XHJcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcclxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBmdWxsLXJlY29ubmVjdCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZm9yY2UtdGNwJzpcclxuICAgICAgICBjYXNlICdmb3JjZS10bHMnOlxyXG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xyXG4gICAgICAgICAgICBzY2VuYXJpbzoge1xyXG4gICAgICAgICAgICAgIGNhc2U6ICdzd2l0Y2hDYW5kaWRhdGVQcm90b2NvbCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IHNjZW5hcmlvID09PSAnZm9yY2UtdGxzJyA/IDIgOiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb25MZWF2ZSA9IHRoaXMuZW5naW5lLmNsaWVudC5vbkxlYXZlO1xyXG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgICAgICAgIG9uTGVhdmUobmV3IExlYXZlUmVxdWVzdCh7XHJcbiAgICAgICAgICAgICAgICByZWFzb246IERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRCxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1RcclxuICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlci1iYW5kd2lkdGgnOlxyXG4gICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBhcmcgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3Vic2NyaWJlci1iYW5kd2lkdGggcmVxdWlyZXMgYSBudW1iZXIgYXMgYXJndW1lbnQnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcclxuICAgICAgICAgICAgc2NlbmFyaW86IHtcclxuICAgICAgICAgICAgICBjYXNlOiAnc3Vic2NyaWJlckJhbmR3aWR0aCcsXHJcbiAgICAgICAgICAgICAgdmFsdWU6IG51bWJlclRvQmlnSW50KGFyZylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsZWF2ZS1mdWxsLXJlY29ubmVjdCc6XHJcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XHJcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XHJcbiAgICAgICAgICAgICAgY2FzZTogJ2xlYXZlUmVxdWVzdEZ1bGxSZWNvbm5lY3QnLFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZXEpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFNpbXVsYXRlU2NlbmFyaW8ocmVxKTtcclxuICAgICAgICB5aWVsZCBwb3N0QWN0aW9uKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXVkaW8gcGxheWJhY2sgaXMgZW5hYmxlZFxyXG4gICAqL1xyXG4gIGdldCBjYW5QbGF5YmFja0F1ZGlvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXVkaW9FbmFibGVkO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdmlkZW8gcGxheWJhY2sgaXMgZW5hYmxlZFxyXG4gICAqL1xyXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ7XHJcbiAgfVxyXG4gIGdldEFjdGl2ZURldmljZShraW5kKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoa2luZCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxyXG4gICAqXHJcbiAgICogTm90ZTogc2V0dGluZyBBdWRpb091dHB1dCBpcyBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMuIFNlZSBbc2V0U2lua0lkXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5KVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGtpbmQgdXNlIGB2aWRlb2lucHV0YCBmb3IgY2FtZXJhIHRyYWNrLFxyXG4gICAqICBgYXVkaW9pbnB1dGAgZm9yIG1pY3JvcGhvbmUgdHJhY2ssXHJcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcclxuICAgKiBAcGFyYW0gZGV2aWNlSWRcclxuICAgKi9cclxuICBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZF8xLCBkZXZpY2VJZF8xKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoa2luZCwgZGV2aWNlSWQpIHtcclxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcbiAgICAgIGxldCBleGFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xyXG4gICAgICAgIHZhciBfaDtcclxuICAgICAgICBsZXQgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgbGV0IG5lZWRzVXBkYXRlV2l0aG91dFRyYWNrcyA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGRldmljZUNvbnN0cmFpbnQgPSBleGFjdCA/IHtcclxuICAgICAgICAgIGV4YWN0OiBkZXZpY2VJZFxyXG4gICAgICAgIH0gOiBkZXZpY2VJZDtcclxuICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XHJcbiAgICAgICAgICBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XHJcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2EgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpczMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZDtcclxuICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcclxuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3VjY2VzcyA9ICh5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHQgPT4ge1xyXG4gICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC5hdWRpb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XHJcbiAgICAgICAgICAgIH0pKSkuZXZlcnkodmFsID0+IHZhbCA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XHJcbiAgICAgICAgICBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XHJcbiAgICAgICAgICBjb25zdCBwcmV2RGV2aWNlSWQgPSAoX2IgPSBfdGhpczMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfdGhpczMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZDtcclxuICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcclxuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gKHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodCA9PiB7XHJcbiAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0LnZpZGVvVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREZXZpY2VJZChkZXZpY2VDb25zdHJhaW50KTtcclxuICAgICAgICAgICAgfSkpKS5ldmVyeSh2YWwgPT4gdmFsID09PSB0cnVlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSAnYXVkaW9vdXRwdXQnKSB7XHJcbiAgICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKCkgJiYgIV90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4IHx8IF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4ICYmIF90aGlzMy5hdWRpb0NvbnRleHQgJiYgISgnc2V0U2lua0lkJyBpbiBfdGhpczMuYXVkaW9Db250ZXh0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCBzZXRTaW5rSWQgbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XHJcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGRlZmF1bHRgIGZvciB3ZWIgYXVkaW8gb3V0cHV0IGRvZXNuJ3Qgd29yaywgc28gd2UgbmVlZCB0byBub3JtYWxpemUgdGhlIGlkIGJlZm9yZVxyXG4gICAgICAgICAgICBkZXZpY2VJZCA9IChfYyA9IHlpZWxkIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZCgnYXVkaW9vdXRwdXQnLCBkZXZpY2VJZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKF9kID0gKF9oID0gX3RoaXMzLm9wdGlvbnMpLmF1ZGlvT3V0cHV0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBfaC5hdWRpb091dHB1dCA9IHt9O1xyXG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9lID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XHJcbiAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XHJcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxyXG4gICAgICAgICAgICAgIChfZiA9IF90aGlzMy5hdWRpb0NvbnRleHQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zZXRTaW5rSWQoZGV2aWNlSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gc2V0IGF1ZGlvIG91dHB1dCBvbiBhbGwgYXVkaW8gZWxlbWVudHMsIGV2ZW4gaWYgd2ViQXVkaW9NaXggaXMgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGVjaG8gY2FuY2VsbGF0aW9uIG5vdCB3b3JraW5nIG9uIGNocm9tZSB3aXRoIG5vbi1kZWZhdWx0IG91dHB1dCBkZXZpY2VzXHJcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQwMjUyOTExI2NvbW1lbnQ3XHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKEFycmF5LmZyb20oX3RoaXMzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkubWFwKHAgPT4gcC5zZXRBdWRpb091dHB1dCh7XHJcbiAgICAgICAgICAgICAgZGV2aWNlSWRcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgfHwga2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xyXG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vdCBhY3RpdmUgdHJhY2tzIHlldCBvciB3ZSdyZSBzd2l0Y2hpbmcgYXVkaW9vdXRwdXQsIHdlIG5lZWQgdG8gbWFudWFsbHkgdXBkYXRlIHRoZSBhY3RpdmUgZGV2aWNlIG1hcCBoZXJlIGFzIGNoYW5naW5nIGF1ZGlvIG91dHB1dCB3b24ndCByZXN1bHQgaW4gYSB0cmFjayByZXN0YXJ0XHJcbiAgICAgICAgICBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGtpbmQsIGtpbmQgPT09ICdhdWRpb291dHB1dCcgJiYgKChfZyA9IF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuZGV2aWNlSWQpIHx8IGRldmljZUlkKTtcclxuICAgICAgICAgIF90aGlzMy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgICB9KCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCkge1xyXG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TmFtZUNoYW5nZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCB0aGlzLm9uTG9jYWxUcmFja1VubXV0ZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9uKFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCwgdGhpcy5zdGFydEF1ZGlvKS5vbihQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCB0aGlzLm9uTG9jYWxDaGF0TWVzc2FnZVNlbnQpLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcclxuICB9XHJcbiAgcmVjcmVhdGVFbmdpbmUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAoX2EgPSB0aGlzLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XHJcbiAgICAvKiBAdHMtaWdub3JlICovXHJcbiAgICB0aGlzLmVuZ2luZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xyXG4gICAgLy8gY2xlYXIgb3V0IGV4aXN0aW5nIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHNpbmNlIHRoZXkgbWF5IGhhdmUgYXR0YWNoZWRcclxuICAgIC8vIHRoZSBvbGQgZW5naW5lXHJcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xyXG4gICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XHJcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XHJcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XHJcbiAgfVxyXG4gIG9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKSB7XHJcbiAgICAvLyBkb24ndCBmaXJlIG9uU3Vic2NyaWJlZCB3aGVuIGNvbm5lY3RpbmdcclxuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxyXG4gICAgLy8gYXQgdGhhdCB0aW1lLCBJQ0UgY29ubmVjdGl2aXR5IGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCBzbyB0aGUgdHJhY2sgaXMgbm90XHJcbiAgICAvLyB0ZWNobmljYWxseSBzdWJzY3JpYmVkLlxyXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8IHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcclxuICAgICAgY29uc3QgcmVjb25uZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuUmVjb25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcclxuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XHJcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcclxuICAgICAgdGhpcy5sb2cud2Fybignc2tpcHBpbmcgaW5jb21pbmcgdHJhY2sgYWZ0ZXIgUm9vbSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XHJcbiAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIGluY29taW5nIHRyYWNrIGFzIGl0IGFscmVhZHkgZW5kZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXJ0cyA9IHVucGFja1N0cmVhbUlkKHN0cmVhbS5pZCk7XHJcbiAgICBjb25zdCBwYXJ0aWNpcGFudFNpZCA9IHBhcnRzWzBdO1xyXG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XHJcbiAgICBsZXQgdHJhY2tJZCA9IG1lZGlhVHJhY2suaWQ7XHJcbiAgICAvLyBmaXJlZm94IHdpbGwgZ2V0IHN0cmVhbUlkIChwSUR8dHJhY2tJZCkgaW5zdGVhZCBvZiAocElEfHN0cmVhbUlkKSBhcyBpdCBkb2Vzbid0IHN1cHBvcnQgc3luYyB0cmFja3MgYnkgc3RyZWFtXHJcbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cclxuICAgIGlmIChzdHJlYW1JZCAmJiBzdHJlYW1JZC5zdGFydHNXaXRoKCdUUicpKSB0cmFja0lkID0gc3RyZWFtSWQ7XHJcbiAgICBpZiAocGFydGljaXBhbnRTaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcclxuICAgICAgdGhpcy5sb2cud2FybigndHJpZWQgdG8gY3JlYXRlIFJlbW90ZVBhcnRpY2lwYW50IGZvciBsb2NhbCBwYXJ0aWNpcGFudCcsIHRoaXMubG9nQ29udGV4dCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAuc2lkID09PSBwYXJ0aWNpcGFudFNpZCk7XHJcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XHJcbiAgICAgIHRoaXMubG9nLmVycm9yKFwiVHJpZWQgdG8gYWRkIGEgdHJhY2sgZm9yIGEgcGFydGljaXBhbnQsIHRoYXQncyBub3QgcHJlc2VudC4gU2lkOiBcIi5jb25jYXQocGFydGljaXBhbnRTaWQpLCB0aGlzLmxvZ0NvbnRleHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0ge307XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBhcnRpY2lwYW50LmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHRyYWNrSWQsIHN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpO1xyXG4gIH1cclxuICBoYW5kbGVEaXNjb25uZWN0KCkge1xyXG4gICAgbGV0IHNob3VsZFN0b3BUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XHJcbiAgICBsZXQgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xyXG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XHJcbiAgICB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzLmNsZWFyKCk7XHJcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgcC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XHJcbiAgICAgICAgICBwLnVucHVibGlzaFRyYWNrKHB1Yi50cmFja1NpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGlmIChwdWIudHJhY2spIHtcclxuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51bnB1Ymxpc2hUcmFjayhwdWIudHJhY2ssIHNob3VsZFN0b3BUcmFja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkU3RvcFRyYWNrcykge1xyXG4gICAgICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV0YWNoKCk7XHJcbiAgICAgICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIChfYyA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0b3BNb25pdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Lm9mZihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkKTtcclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmNsZWFyKCk7XHJcbiAgICAgIHRoaXMuc2lkVG9JZGVudGl0eS5jbGVhcigpO1xyXG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XHJcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1dlYigpKSB7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmcmVlemUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcclxuICAgICAgICAoX2EgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24pO1xyXG4gICAgfVxyXG4gIH1cclxuICBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpZGVudGl0eSwgcGFydGljaXBhbnQpIHtcclxuICAgIHZhciBfYTtcclxuICAgIC8vIHJlbW92ZSBhbmQgc2VuZCBldmVudFxyXG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZGVsZXRlKGlkZW50aXR5KTtcclxuICAgIGlmICghcGFydGljaXBhbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWJsaWNhdGlvbiA9PiB7XHJcbiAgICAgIHBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCwgcGFydGljaXBhbnQpO1xyXG4gICAgcGFydGljaXBhbnQuc2V0RGlzY29ubmVjdGVkKCk7XHJcbiAgICAoX2EgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudC5pZGVudGl0eSk7XHJcbiAgfVxyXG4gIGhhbmRsZVN0cmVhbUhlYWRlcihzdHJlYW1IZWFkZXIsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgaWYgKHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLmNhc2UgPT09ICdieXRlSGVhZGVyJykge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbUhhbmRsZXJDYWxsYmFjayA9IHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLmdldChzdHJlYW1IZWFkZXIudG9waWMpO1xyXG4gICAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnaWdub3JpbmcgaW5jb21pbmcgYnl0ZSBzdHJlYW0gZHVlIHRvIG5vIGhhbmRsZXIgZm9yIHRvcGljJywgc3RyZWFtSGVhZGVyLnRvcGljKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXI7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgIGlkOiBzdHJlYW1IZWFkZXIuc3RyZWFtSWQsXHJcbiAgICAgICAgICBuYW1lOiAoX2EgPSBzdHJlYW1IZWFkZXIuY29udGVudEhlYWRlci52YWx1ZS5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndW5rbm93bicsXHJcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxyXG4gICAgICAgICAgc2l6ZTogc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoID8gTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICB0b3BpYzogc3RyZWFtSGVhZGVyLnRvcGljLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudGltZXN0YW1wKSxcclxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHN0cmVhbUhlYWRlci5hdHRyaWJ1dGVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xyXG4gICAgICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xyXG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcclxuICAgICAgICAgICAgdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMuc2V0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwge1xyXG4gICAgICAgICAgICAgIGluZm8sXHJcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcclxuICAgICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKG5ldyBCeXRlU3RyZWFtUmVhZGVyKGluZm8sIHN0cmVhbSwgYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSksIHtcclxuICAgICAgICAgIGlkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIuY2FzZSA9PT0gJ3RleHRIZWFkZXInKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtSGFuZGxlckNhbGxiYWNrID0gdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZ2V0KHN0cmVhbUhlYWRlci50b3BpYyk7XHJcbiAgICAgICAgaWYgKCFzdHJlYW1IYW5kbGVyQ2FsbGJhY2spIHtcclxuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdpZ25vcmluZyBpbmNvbWluZyB0ZXh0IHN0cmVhbSBkdWUgdG8gbm8gaGFuZGxlciBmb3IgdG9waWMnLCBzdHJlYW1IZWFkZXIudG9waWMpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjtcclxuICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcclxuICAgICAgICAgIG1pbWVUeXBlOiBzdHJlYW1IZWFkZXIubWltZVR5cGUsXHJcbiAgICAgICAgICBzaXplOiBzdHJlYW1IZWFkZXIudG90YWxMZW5ndGggPyBOdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IE51bWJlcihzdHJlYW1IZWFkZXIudGltZXN0YW1wKSxcclxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHN0cmVhbUhlYWRlci5hdHRyaWJ1dGVzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xyXG4gICAgICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xyXG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcclxuICAgICAgICAgICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuc2V0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwge1xyXG4gICAgICAgICAgICAgIGluZm8sXHJcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcclxuICAgICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKG5ldyBUZXh0U3RyZWFtUmVhZGVyKGluZm8sIHN0cmVhbSwgYmlnSW50VG9OdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSksIHtcclxuICAgICAgICAgIGlkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBoYW5kbGVTdHJlYW1DaHVuayhjaHVuaykge1xyXG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XHJcbiAgICBpZiAoZmlsZUJ1ZmZlcikge1xyXG4gICAgICBpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZ2V0KGNodW5rLnN0cmVhbUlkKTtcclxuICAgIGlmICh0ZXh0QnVmZmVyKSB7XHJcbiAgICAgIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlU3RyZWFtVHJhaWxlcih0cmFpbGVyKSB7XHJcbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZ2V0KHRyYWlsZXIuc3RyZWFtSWQpO1xyXG4gICAgaWYgKHRleHRCdWZmZXIpIHtcclxuICAgICAgdGV4dEJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcclxuICAgICAgdGV4dEJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5nZXQodHJhaWxlci5zdHJlYW1JZCk7XHJcbiAgICBpZiAoZmlsZUJ1ZmZlcikge1xyXG4gICAgICB7XHJcbiAgICAgICAgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzKSwgdHJhaWxlci5hdHRyaWJ1dGVzKTtcclxuICAgICAgICBmaWxlQnVmZmVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcclxuICAgICAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5kZWxldGUodHJhaWxlci5zdHJlYW1JZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLyoqXHJcbiAgICogYXR0ZW1wdCB0byBzZWxlY3QgdGhlIGRlZmF1bHQgZGV2aWNlcyBpZiB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBkZXZpY2VzIGFyZSBubyBsb25nZXIgYXZhaWxhYmxlIGFmdGVyIGEgZGV2aWNlIGNoYW5nZSBldmVudFxyXG4gICAqL1xyXG4gIHNlbGVjdERlZmF1bHREZXZpY2VzKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgIGNvbnN0IHByZXZpb3VzRGV2aWNlcyA9IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5wcmV2aW91c0RldmljZXM7XHJcbiAgICAgIC8vIGNoZWNrIGZvciBhdmFpbGFibGUgZGV2aWNlcywgYnV0IGRvbid0IHJlcXVlc3QgcGVybWlzc2lvbnMgaW4gb3JkZXIgdG8gYXZvaWQgcHJvbXB0cyBmb3Iga2luZHMgdGhhdCBoYXZlbid0IGJlZW4gdXNlZCBiZWZvcmVcclxuICAgICAgY29uc3QgYXZhaWxhYmxlRGV2aWNlcyA9IHlpZWxkIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXREZXZpY2VzKHVuZGVmaW5lZCwgZmFsc2UpO1xyXG4gICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xyXG4gICAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcclxuICAgICAgICBmb3IgKGxldCBhdmFpbGFibGVEZXZpY2Ugb2YgYXZhaWxhYmxlRGV2aWNlcykge1xyXG4gICAgICAgICAgY29uc3QgcHJldmlvdXNEZXZpY2UgPSBwcmV2aW91c0RldmljZXMuZmluZChpbmZvID0+IGluZm8uZGV2aWNlSWQgPT09IGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XHJcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXZpY2UgJiYgcHJldmlvdXNEZXZpY2UubGFiZWwgIT09ICcnICYmIHByZXZpb3VzRGV2aWNlLmtpbmQgPT09IGF2YWlsYWJsZURldmljZS5raW5kICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSBhdmFpbGFibGVEZXZpY2UubGFiZWwpIHtcclxuICAgICAgICAgICAgLy8gbGFiZWwgaGFzIGNoYW5nZWQgb24gZGV2aWNlIHRoZSBzYW1lIGRldmljZUlkLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGRlZmF1bHQgZGV2aWNlIGhhcyBjaGFuZ2VkIG9uIHRoZSBPUyBsZXZlbFxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBY3RpdmVEZXZpY2UoYXZhaWxhYmxlRGV2aWNlLmtpbmQpID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAvLyBlbWl0IGFuIGFjdGl2ZSBkZXZpY2UgY2hhbmdlIGV2ZW50IG9ubHkgaWYgdGhlIHNlbGVjdGVkIG91dHB1dCBkZXZpY2UgaXMgYWN0dWFsbHkgb24gYGRlZmF1bHRgXHJcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBhdmFpbGFibGVEZXZpY2Uua2luZCwgYXZhaWxhYmxlRGV2aWNlLmRldmljZUlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBraW5kcyA9IFsnYXVkaW9vdXRwdXQnLCAnYXVkaW9pbnB1dCcsICd2aWRlb2lucHV0J107XHJcbiAgICAgIGZvciAobGV0IGtpbmQgb2Yga2luZHMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTb3VyY2UgPSBraW5kVG9Tb3VyY2Uoa2luZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UHVibGljYXRpb24gPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbih0YXJnZXRTb3VyY2UpO1xyXG4gICAgICAgIGlmICh0YXJnZXRQdWJsaWNhdGlvbiAmJiAoKF9hID0gdGFyZ2V0UHVibGljYXRpb24udHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1VzZXJQcm92aWRlZCkpIHtcclxuICAgICAgICAgIC8vIGlmIHRoZSB0cmFjayBpcyB1c2VyIHByb3ZpZGVkLCB3ZSBkb24ndCB3YW50IHRvIHN3aXRjaCBkZXZpY2VzIG9uIGJlaGFsZiBvZiB0aGUgdXNlclxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRldmljZXNPZktpbmQgPSBhdmFpbGFibGVEZXZpY2VzLmZpbHRlcihkID0+IGQua2luZCA9PT0ga2luZCk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlRGV2aWNlID0gdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCk7XHJcbiAgICAgICAgaWYgKGFjdGl2ZURldmljZSA9PT0gKChfYiA9IHByZXZpb3VzRGV2aWNlcy5maWx0ZXIoaW5mbyA9PiBpbmZvLmtpbmQgPT09IGtpbmQpWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV2aWNlSWQpKSB7XHJcbiAgICAgICAgICAvLyBpbiAgU2FmYXJpIHRoZSBmaXJzdCBkZXZpY2UgaXMgYWx3YXlzIHRoZSBkZWZhdWx0LCBzbyB3ZSBhc3N1bWUgYSB1c2VyIG9uIHRoZSBkZWZhdWx0IGRldmljZSB3b3VsZCBsaWtlIHRvIHN3aXRjaCB0byB0aGUgZGVmYXVsdCBvbmNlIGl0IGNoYW5nZXNcclxuICAgICAgICAgIC8vIEZGIGRvZXNuJ3QgZW1pdCBhbiBldmVudCB3aGVuIHRoZSBkZWZhdWx0IGRldmljZSBjaGFuZ2VzLCBzbyB3ZSBwZXJmb3JtIHRoZSBzYW1lIGJlc3QgZWZmb3J0IGFuZCBzd2l0Y2ggdG8gdGhlIG5ldyBkZXZpY2Ugb25jZSBjb25uZWN0ZWQgYW5kIGlmIGl0J3MgdGhlIGZpcnN0IGluIHRoZSBhcnJheVxyXG4gICAgICAgICAgaWYgKGRldmljZXNPZktpbmQubGVuZ3RoID4gMCAmJiAoKF9jID0gZGV2aWNlc09mS2luZFswXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRldmljZUlkKSAhPT0gYWN0aXZlRGV2aWNlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmQsIGRldmljZXNPZktpbmRbMF0uZGV2aWNlSWQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpb2lucHV0JyAmJiAhaXNTYWZhcmlCYXNlZCgpIHx8IGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xyXG4gICAgICAgICAgLy8gYWlycG9kcyBvbiBTYWZhcmkgbmVlZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhdWRpb2lucHV0IGFzIHRoZSB0cmFjayBkb2Vzbid0IGVuZCBhcyBzb29uIGFzIHlvdSB0YWtlIHRoZW0gb3V0XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3dpdGNoIHRvIGZpcnN0IGF2YWlsYWJsZSBkZXZpY2UgaWYgcHJldmlvdXNseSBhY3RpdmUgZGV2aWNlIGlzIG5vdCBhdmFpbGFibGUgYW55IG1vcmVcclxuICAgICAgICBpZiAoZGV2aWNlc09mS2luZC5sZW5ndGggPiAwICYmICFkZXZpY2VzT2ZLaW5kLmZpbmQoZGV2aWNlSW5mbyA9PiBkZXZpY2VJbmZvLmRldmljZUlkID09PSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKSkgJiYgKFxyXG4gICAgICAgIC8vIGF2b2lkIHN3aXRjaGluZyBhdWRpbyBvdXRwdXQgb24gc2FmYXJpIHdpdGhvdXQgZXhwbGljaXQgdXNlciBhY3Rpb24gYXMgaXQgbGVhZHMgdG8gc2xvd2VkIGRvd24gYXVkaW8gcGxheWJhY2tcclxuICAgICAgICBraW5kICE9PSAnYXVkaW9vdXRwdXQnIHx8ICFpc1NhZmFyaUJhc2VkKCkpKSB7XHJcbiAgICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBhY3F1aXJlQXVkaW9Db250ZXh0KCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXggIT09ICdib29sZWFuJyAmJiB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXguYXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgLy8gb3ZlcnJpZGUgYXVkaW8gY29udGV4dCB3aXRoIGN1c3RvbSBhdWRpbyBjb250ZXh0IGlmIHN1cHBsaWVkIGJ5IHVzZXJcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IHRoaXMub3B0aW9ucy53ZWJBdWRpb01peC5hdWRpb0NvbnRleHQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYXVkaW9Db250ZXh0IHx8IHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgIC8vIGJ5IHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgaXQgcmVkdWNlcyBsYWcgb24gYXVkaW8gZWxlbWVudHNcclxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODExNDI5L2h0bWw1LWF1ZGlvLXRhZy1vbi1zYWZhcmktaGFzLWEtZGVsYXkvNTQxMTk4NTQjNTQxMTk4NTRcclxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IChfYSA9IGdldE5ld0F1ZGlvQ29udGV4dCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCkge1xyXG4gICAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4gcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XHJcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcclxuICAgICAgICAvLyBmb3IgaU9TIGEgbmV3bHkgY3JlYXRlZCBBdWRpb0NvbnRleHQgaXMgYWx3YXlzIGluIGBzdXNwZW5kZWRgIHN0YXRlLlxyXG4gICAgICAgIC8vIHdlIHRyeSBvdXIgYmVzdCB0byByZXN1bWUgdGhlIGNvbnRleHQgaGVyZSwgaWYgdGhhdCBkb2Vzbid0IHdvcmssIHdlIGp1c3QgY29udGludWUgd2l0aCByZWd1bGFyIHByb2Nlc3NpbmdcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFt0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKSwgc2xlZXAoMjAwKV0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ0NvdWxkIG5vdCByZXN1bWUgYXVkaW8gY29udGV4dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgICAgICBlcnJvcjogZVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBuZXdDb250ZXh0SXNSdW5uaW5nID0gKChfYiA9IHRoaXMuYXVkaW9Db250ZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGUpID09PSAncnVubmluZyc7XHJcbiAgICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcclxuICAgICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IG5ld0NvbnRleHRJc1J1bm5pbmc7XHJcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgbmV3Q29udGV4dElzUnVubmluZyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgbGV0IHBhcnRpY2lwYW50O1xyXG4gICAgaWYgKGluZm8pIHtcclxuICAgICAgcGFydGljaXBhbnQgPSBSZW1vdGVQYXJ0aWNpcGFudC5mcm9tUGFydGljaXBhbnRJbmZvKHRoaXMuZW5naW5lLmNsaWVudCwgaW5mbywge1xyXG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxyXG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCAnJywgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcclxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcclxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcclxuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcclxuICAgIH1cclxuICAgIGlmICgoX2EgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXZpY2VJZCkge1xyXG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb091dHB1dCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiBcIi5jb25jYXQoZS5tZXNzYWdlKSwgdGhpcy5sb2dDb250ZXh0KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XHJcbiAgfVxyXG4gIGdldE9yQ3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHksIGluZm8pIHtcclxuICAgIGlmICh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5oYXMoaWRlbnRpdHkpKSB7XHJcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xyXG4gICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgIGNvbnN0IHdhc1VwZGF0ZWQgPSBleGlzdGluZ1BhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XHJcbiAgICAgICAgaWYgKHdhc1VwZGF0ZWQpIHtcclxuICAgICAgICAgIHRoaXMuc2lkVG9JZGVudGl0eS5zZXQoaW5mby5zaWQsIGluZm8uaWRlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZXhpc3RpbmdQYXJ0aWNpcGFudDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5jcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbyk7XHJcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5zZXQoaWRlbnRpdHksIHBhcnRpY2lwYW50KTtcclxuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5zZXQoaW5mby5zaWQsIGluZm8uaWRlbnRpdHkpO1xyXG4gICAgLy8gaWYgd2UgaGF2ZSB2YWxpZCBpbmZvIGFuZCB0aGUgcGFydGljaXBhbnQgd2Fzbid0IGluIHRoZSBtYXAgYmVmb3JlLCB3ZSBjYW4gYXNzdW1lIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdcclxuICAgIC8vIGZpcmluZyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGBQYXJ0aWNpcGFudENvbm5lY3RlZGAgZmlyZXMgYmVmb3JlIHRoZSBpbml0aWFsIHRyYWNrIGV2ZW50c1xyXG4gICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRDb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcclxuICAgIC8vIGFsc28gZm9yd2FyZCBldmVudHNcclxuICAgIC8vIHRyYWNrUHVibGlzaGVkIGlzIG9ubHkgZmlyZWQgZm9yIHRyYWNrcyBhZGRlZCBhZnRlciBib3RoIGxvY2FsIHBhcnRpY2lwYW50XHJcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxyXG4gICAgcGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5UcmFja1B1Ymxpc2hlZCwgdHJhY2tQdWJsaWNhdGlvbiA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCB0cmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaWJlZCwgKHRyYWNrLCBwdWJsaWNhdGlvbikgPT4ge1xyXG4gICAgICAvLyBtb25pdG9yIHBsYXliYWNrIHN0YXR1c1xyXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xyXG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xyXG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKTtcclxuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XHJcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xyXG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24gPT4ge1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCBwdWIgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCBwdWIgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5ID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zLCBwYXJ0aWNpcGFudCk7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XHJcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHViLCBzdGF0dXMsIHBhcnRpY2lwYW50KTtcclxuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsICh0cmFja1NpZCwgZXJyb3IpID0+IHtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgdHJhY2tTaWQsIHBhcnRpY2lwYW50LCBlcnJvcik7XHJcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIChwdWIsIHN0YXR1cykgPT4ge1xyXG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCBwdWIsIHN0YXR1cywgcGFydGljaXBhbnQpO1xyXG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5BY3RpdmUsICgpID0+IHtcclxuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRBY3RpdmUsIHBhcnRpY2lwYW50KTtcclxuICAgICAgaWYgKHBhcnRpY2lwYW50LmtpbmQgPT09IFBhcnRpY2lwYW50SW5mb19LaW5kLkFHRU5UKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEFjdGl2ZUFnZW50KHBhcnRpY2lwYW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyB1cGRhdGUgaW5mbyBhdCB0aGUgZW5kIGFmdGVyIGNhbGxiYWNrcyBoYXZlIGJlZW4gc2V0IHVwXHJcbiAgICBpZiAoaW5mbykge1xyXG4gICAgICBwYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xyXG4gIH1cclxuICBzZW5kU3luY1N0YXRlKCkge1xyXG4gICAgY29uc3QgcmVtb3RlVHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIHBhcnRpY2lwYW50KSA9PiB7XHJcbiAgICAgIGFjYy5wdXNoKC4uLnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25zKCkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBsb2NhbFRyYWNrcyA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9ucyBkaXJlY3RseSBpbnN0ZWFkIG9mIHRoZSB0eXBlIGNhc3RcclxuICAgIHRoaXMuZW5naW5lLnNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzLCBsb2NhbFRyYWNrcyk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIEFmdGVyIHJlc3VtaW5nLCB3ZSdsbCBuZWVkIHRvIG5vdGlmeSB0aGUgc2VydmVyIG9mIHRoZSBjdXJyZW50XHJcbiAgICogc3Vic2NyaXB0aW9uIHNldHRpbmdzLlxyXG4gICAqL1xyXG4gIHVwZGF0ZVN1YnNjcmlwdGlvbnMoKSB7XHJcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcclxuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgaWYgKHB1Yi5pc1N1YnNjcmliZWQgJiYgaXNSZW1vdGVQdWIocHViKSkge1xyXG4gICAgICAgICAgcHViLmVtaXRUcmFja1VwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBnZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHNpZCkge1xyXG4gICAgY29uc3QgaWRlbnRpdHkgPSB0aGlzLnNpZFRvSWRlbnRpdHkuZ2V0KHNpZCk7XHJcbiAgICBpZiAoaWRlbnRpdHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpZGVudGl0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpIHtcclxuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XHJcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCA9IENyaXRpY2FsVGltZXJzLnNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAvLyBlbnN1cmUgd2UgZGlkbid0IHRlYXIgaXQgZG93blxyXG4gICAgICAhdGhpcy5lbmdpbmUgfHxcclxuICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcclxuICAgICAgdGhpcy5lbmdpbmUuaXNDbG9zZWQgfHxcclxuICAgICAgLy8gdHJhbnNwb3J0cyBmYWlsZWQgd2l0aG91dCBub3RpZnlpbmcgZW5naW5lXHJcbiAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSkge1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcclxuICAgICAgICB0aGlzLmxvZy53YXJuKCdkZXRlY3RlZCBjb25uZWN0aW9uIHN0YXRlIG1pc21hdGNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XHJcbiAgICAgICAgICBudW1GYWlsdXJlczogY29uc2VjdXRpdmVGYWlsdXJlcyxcclxuICAgICAgICAgIGVuZ2luZTogdGhpcy5lbmdpbmUgPyB7XHJcbiAgICAgICAgICAgIGNsb3NlZDogdGhpcy5lbmdpbmUuaXNDbG9zZWQsXHJcbiAgICAgICAgICAgIHRyYW5zcG9ydHNDb25uZWN0ZWQ6IHRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpXHJcbiAgICAgICAgICB9IDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIGlmIChjb25zZWN1dGl2ZUZhaWx1cmVzID49IDMpIHtcclxuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcclxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgRGlzY29ubmVjdFJlYXNvbi5TVEFURV9NSVNNQVRDSCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xyXG4gICAgICB9XHJcbiAgICB9LCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5KTtcclxuICB9XHJcbiAgY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xyXG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKSB7XHJcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwodGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKHN0YXRlKSB7XHJcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcclxuICAgICAgLy8gdW5jaGFuZ2VkXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgdGhpcy5zdGF0ZSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgZW1pdEJ1ZmZlcmVkRXZlbnRzKCkge1xyXG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cy5mb3JFYWNoKF9yZWYzID0+IHtcclxuICAgICAgbGV0IFtldiwgYXJnc10gPSBfcmVmMztcclxuICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xyXG4gIH1cclxuICBlbWl0V2hlbkNvbm5lY3RlZChldmVudCkge1xyXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcclxuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAhdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUucGVuZGluZ1JlY29ubmVjdCkge1xyXG4gICAgICAvLyBpbiBjYXNlIHRoZSByb29tIGlzIHJlY29ubmVjdGluZywgYnVmZmVyIHRoZSBldmVudHMgYnkgZmlyaW5nIHRoZW0gbGF0ZXIgYWZ0ZXIgZW1pdHRpbmcgUm9vbUV2ZW50LlJlY29ubmVjdGVkXHJcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMucHVzaChbZXZlbnQsIGFyZ3NdKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXHJcbiAgICogTm8gYWN0dWFsIGNvbm5lY3Rpb24gdG8gYSBzZXJ2ZXIgd2lsbCBiZSBlc3RhYmxpc2hlZCwgYWxsIHN0YXRlIGlzXHJcbiAgICogQGV4cGVyaW1lbnRhbFxyXG4gICAqL1xyXG4gIHNpbXVsYXRlUGFydGljaXBhbnRzKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgdmlkZW86IHRydWUsXHJcbiAgICAgICAgdXNlUmVhbFRyYWNrczogZmFsc2VcclxuICAgICAgfSwgb3B0aW9ucy5wdWJsaXNoKTtcclxuICAgICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgY291bnQ6IDksXHJcbiAgICAgICAgYXVkaW86IGZhbHNlLFxyXG4gICAgICAgIHZpZGVvOiB0cnVlLFxyXG4gICAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXVxyXG4gICAgICB9LCBvcHRpb25zLnBhcnRpY2lwYW50cyk7XHJcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xyXG4gICAgICB0aGlzLnJvb21JbmZvID0gbmV3IFJvb20kMSh7XHJcbiAgICAgICAgc2lkOiAnUk1fU0lNVUxBVEVEJyxcclxuICAgICAgICBuYW1lOiAnc2ltdWxhdGVkLXJvb20nLFxyXG4gICAgICAgIGVtcHR5VGltZW91dDogMCxcclxuICAgICAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXHJcbiAgICAgICAgY3JlYXRpb25UaW1lOiBwcm90b0ludDY0LnBhcnNlKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSxcclxuICAgICAgICBtZXRhZGF0YTogJycsXHJcbiAgICAgICAgbnVtUGFydGljaXBhbnRzOiAxLFxyXG4gICAgICAgIG51bVB1Ymxpc2hlcnM6IDEsXHJcbiAgICAgICAgdHVyblBhc3N3b3JkOiAnJyxcclxuICAgICAgICBlbmFibGVkQ29kZWNzOiBbXSxcclxuICAgICAgICBhY3RpdmVSZWNvcmRpbmc6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhuZXcgUGFydGljaXBhbnRJbmZvKHtcclxuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXHJcbiAgICAgICAgbmFtZTogJ2xvY2FsLW5hbWUnXHJcbiAgICAgIH0pKTtcclxuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcclxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQpO1xyXG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3RlZCk7XHJcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcclxuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLnZpZGVvKSB7XHJcbiAgICAgICAgY29uc3QgY2FtUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLlZpZGVvLCBuZXcgVHJhY2tJbmZvKHtcclxuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxyXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcclxuICAgICAgICAgIG5hbWU6ICd2aWRlby1kdW1teSdcclxuICAgICAgICB9KSwgbmV3IExvY2FsVmlkZW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XHJcbiAgICAgICAgICB2aWRlbzogdHJ1ZVxyXG4gICAgICAgIH0pKS5nZXRWaWRlb1RyYWNrcygpWzBdIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2EgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSwgMTYwLCB0cnVlLCB0cnVlKSwgdW5kZWZpbmVkLCBmYWxzZSwge1xyXG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICAgIH0pLCB7XHJcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcclxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hZGRUcmFja1B1YmxpY2F0aW9uKGNhbVB1Yik7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBjYW1QdWIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy5hdWRpbykge1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLkF1ZGlvLCBuZXcgVHJhY2tJbmZvKHtcclxuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcclxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cclxuICAgICAgICB9KSwgbmV3IExvY2FsQXVkaW9UcmFjayhwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzID8gKHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcclxuICAgICAgICAgIGF1ZGlvOiB0cnVlXHJcbiAgICAgICAgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF0gOiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcclxuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxyXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcclxuICAgICAgICB9KSwge1xyXG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXHJcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWRkVHJhY2tQdWJsaWNhdGlvbihhdWRpb1B1Yik7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudE9wdGlvbnMuY291bnQgLSAxOyBpICs9IDEpIHtcclxuICAgICAgICBsZXQgaW5mbyA9IG5ldyBQYXJ0aWNpcGFudEluZm8oe1xyXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgIGlkZW50aXR5OiBcInNpbXVsYXRlZC1cIi5jb25jYXQoaSksXHJcbiAgICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcclxuICAgICAgICAgIHRyYWNrczogW10sXHJcbiAgICAgICAgICBqb2luZWRBdDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XHJcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy52aWRlbykge1xyXG4gICAgICAgICAgY29uc3QgZHVtbXlWaWRlbyA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9iID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1tpICUgcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvcy5sZW5ndGhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKSwgMTYwLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gbmV3IFRyYWNrSW5mbyh7XHJcbiAgICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxyXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVZpZGVvLCB2aWRlb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVZpZGVvXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcclxuICAgICAgICAgIGluZm8udHJhY2tzID0gWy4uLmluZm8udHJhY2tzLCB2aWRlb1RyYWNrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xyXG4gICAgICAgICAgY29uc3QgZHVtbXlUcmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xyXG4gICAgICAgICAgY29uc3QgYXVkaW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xyXG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXHJcbiAgICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJT1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKGR1bW15VHJhY2ssIGF1ZGlvVHJhY2suc2lkLCBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VHJhY2tdKSwgbmV3IFJUQ1J0cFJlY2VpdmVyKCkpO1xyXG4gICAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIGF1ZGlvVHJhY2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwLnVwZGF0ZUluZm8oaW5mbyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyAvKiogQGludGVybmFsICovXHJcbiAgZW1pdChldmVudCkge1xyXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcclxuICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcclxuICAgIH1cclxuICAgIC8vIGFjdGl2ZSBzcGVha2VyIHVwZGF0ZXMgYXJlIHRvbyBzcGFtbXlcclxuICAgIGlmIChldmVudCAhPT0gUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCAmJiBldmVudCAhPT0gUm9vbUV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCkge1xyXG4gICAgICAvLyBvbmx5IGV4dHJhY3QgbG9nQ29udGV4dCBmcm9tIGFyZ3VtZW50cyBpbiBvcmRlciB0byBhdm9pZCBsb2dnaW5nIHRoZSB3aG9sZSBvYmplY3QgdHJlZVxyXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBcmdzID0gbWFwQXJncyhhcmdzKS5maWx0ZXIoYXJnID0+IGFyZyAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJyb29tIGV2ZW50IFwiLmNvbmNhdChldmVudCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xyXG4gICAgICAgIGV2ZW50LFxyXG4gICAgICAgIGFyZ3M6IG1pbmltaXplZEFyZ3NcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gIH1cclxufVxyXG5Sb29tLmNsZWFudXBSZWdpc3RyeSA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGNsZWFudXAgPT4ge1xyXG4gIGNsZWFudXAoKTtcclxufSk7XHJcbmZ1bmN0aW9uIG1hcEFyZ3MoYXJncykge1xyXG4gIHJldHVybiBhcmdzLm1hcChhcmcgPT4ge1xyXG4gICAgaWYgKCFhcmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgICByZXR1cm4gbWFwQXJncyhhcmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJldHVybiAnbG9nQ29udGV4dCcgaW4gYXJnID8gYXJnLmxvZ0NvbnRleHQgOiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJnO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBmcm9tIEpTT04gU2NoZW1hIHVzaW5nIHF1aWNrdHlwZSwgZG8gbm90IG1vZGlmeSBpdCBkaXJlY3RseS5cclxuLy8gVGhlIGNvZGUgZ2VuZXJhdGlvbiBsaXZlcyBhdCBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC9hdHRyaWJ1dGUtZGVmaW5pdGlvbnNcclxuLy9cclxuLy8gVG8gcGFyc2UgdGhpcyBkYXRhOlxyXG4vL1xyXG4vLyAgIGltcG9ydCB7IENvbnZlcnQsIEFnZW50QXR0cmlidXRlcywgVHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXMgfSBmcm9tIFwiLi9maWxlXCI7XHJcbi8vXHJcbi8vICAgY29uc3QgYWdlbnRBdHRyaWJ1dGVzID0gQ29udmVydC50b0FnZW50QXR0cmlidXRlcyhqc29uKTtcclxuLy8gICBjb25zdCB0cmFuc2NyaXB0aW9uQXR0cmlidXRlcyA9IENvbnZlcnQudG9UcmFuc2NyaXB0aW9uQXR0cmlidXRlcyhqc29uKTtcclxuLy8gQ29udmVydHMgSlNPTiBzdHJpbmdzIHRvL2Zyb20geW91ciB0eXBlc1xyXG5jbGFzcyBDb252ZXJ0IHtcclxuICBzdGF0aWMgdG9BZ2VudEF0dHJpYnV0ZXMoanNvbikge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XHJcbiAgfVxyXG4gIHN0YXRpYyBhZ2VudEF0dHJpYnV0ZXNUb0pzb24odmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgfVxyXG4gIHN0YXRpYyB0b1RyYW5zY3JpcHRpb25BdHRyaWJ1dGVzKGpzb24pIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xyXG4gIH1cclxuICBzdGF0aWMgdHJhbnNjcmlwdGlvbkF0dHJpYnV0ZXNUb0pzb24odmFsdWUpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgYXR0cmlidXRlVHlwaW5ncyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgQ29udmVydDogQ29udmVydFxyXG59KTtcclxuXHJcbnZhciBDaGVja1N0YXR1cztcclxuKGZ1bmN0aW9uIChDaGVja1N0YXR1cykge1xyXG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XHJcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJSVU5OSU5HXCJdID0gMV0gPSBcIlJVTk5JTkdcIjtcclxuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNLSVBQRURcIl0gPSAyXSA9IFwiU0tJUFBFRFwiO1xyXG4gIENoZWNrU3RhdHVzW0NoZWNrU3RhdHVzW1wiU1VDQ0VTU1wiXSA9IDNdID0gXCJTVUNDRVNTXCI7XHJcbiAgQ2hlY2tTdGF0dXNbQ2hlY2tTdGF0dXNbXCJGQUlMRURcIl0gPSA0XSA9IFwiRkFJTEVEXCI7XHJcbn0pKENoZWNrU3RhdHVzIHx8IChDaGVja1N0YXR1cyA9IHt9KSk7XHJcbmNsYXNzIENoZWNrZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuc3RhdHVzID0gQ2hlY2tTdGF0dXMuSURMRTtcclxuICAgIHRoaXMubG9ncyA9IFtdO1xyXG4gICAgdGhpcy5vcHRpb25zID0ge307XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIHRoaXMucm9vbSA9IG5ldyBSb29tKG9wdGlvbnMucm9vbU9wdGlvbnMpO1xyXG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdGlvbnMuY29ubmVjdE9wdGlvbnM7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gIH1cclxuICBydW4ob25Db21wbGV0ZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5JRExFKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NoZWNrIGlzIHJ1bm5pbmcgYWxyZWFkeScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0U3RhdHVzKENoZWNrU3RhdHVzLlJVTk5JTkcpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXJyb3JzQXNXYXJuaW5ncykge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcihlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICAvLyBzbGVlcCBmb3IgYSBiaXQgdG8gZW5zdXJlIGRpc2Nvbm5lY3RcclxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuU0tJUFBFRCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHRoaXMuaXNTdWNjZXNzKCkgPyBDaGVja1N0YXR1cy5TVUNDRVNTIDogQ2hlY2tTdGF0dXMuRkFJTEVEKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgIG9uQ29tcGxldGUoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmZvKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaXNTdWNjZXNzKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLmxvZ3Muc29tZShsID0+IGwubGV2ZWwgPT09ICdlcnJvcicpO1xyXG4gIH1cclxuICBjb25uZWN0KHVybCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgaWYgKHRoaXMucm9vbS5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb207XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICB1cmwgPSB0aGlzLnVybDtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCB0aGlzLnJvb20uY29ubmVjdCh1cmwsIHRoaXMudG9rZW4sIHRoaXMuY29ubmVjdE9wdGlvbnMpO1xyXG4gICAgICByZXR1cm4gdGhpcy5yb29tO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBpZiAodGhpcy5yb29tICYmIHRoaXMucm9vbS5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xyXG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgLy8gd2FpdCBmb3IgaXQgdG8gZ28gdGhyb3VnaFxyXG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNraXAoKSB7XHJcbiAgICB0aGlzLnNldFN0YXR1cyhDaGVja1N0YXR1cy5TS0lQUEVEKTtcclxuICB9XHJcbiAgc3dpdGNoUHJvdG9jb2wocHJvdG9jb2wpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGxldCBoYXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgbGV0IGhhc1JlY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCAoKSA9PiB7XHJcbiAgICAgICAgaGFzUmVjb25uZWN0aW5nID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucm9vbS5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xyXG4gICAgICAgIGhhc1JlY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMucm9vbS5zaW11bGF0ZVNjZW5hcmlvKFwiZm9yY2UtXCIuY29uY2F0KHByb3RvY29sKSk7XHJcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XHJcbiAgICAgIGlmICghaGFzUmVjb25uZWN0aW5nKSB7XHJcbiAgICAgICAgLy8gbm8gbmVlZCB0byB3YWl0IGZvciByZWNvbm5lY3Rpb25cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gd2FpdCBmb3IgMTAgc2Vjb25kcyBmb3IgcmVjb25uZWN0aW9uXHJcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgMTAwMDA7XHJcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgdGltZW91dCkge1xyXG4gICAgICAgIGlmIChoYXNSZWNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5aWVsZCBzbGVlcCgxMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZWNvbm5lY3QgdXNpbmcgXCIuY29uY2F0KHByb3RvY29sLCBcIiBwcm90b2NvbCBhZnRlciAxMCBzZWNvbmRzXCIpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBhcHBlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubG9ncy5wdXNoKHtcclxuICAgICAgbGV2ZWw6ICdpbmZvJyxcclxuICAgICAgbWVzc2FnZVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcclxuICB9XHJcbiAgYXBwZW5kV2FybmluZyhtZXNzYWdlKSB7XHJcbiAgICB0aGlzLmxvZ3MucHVzaCh7XHJcbiAgICAgIGxldmVsOiAnd2FybmluZycsXHJcbiAgICAgIG1lc3NhZ2VcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XHJcbiAgfVxyXG4gIGFwcGVuZEVycm9yKG1lc3NhZ2UpIHtcclxuICAgIHRoaXMubG9ncy5wdXNoKHtcclxuICAgICAgbGV2ZWw6ICdlcnJvcicsXHJcbiAgICAgIG1lc3NhZ2VcclxuICAgIH0pO1xyXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XHJcbiAgfVxyXG4gIHNldFN0YXR1cyhzdGF0dXMpIHtcclxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XHJcbiAgfVxyXG4gIGdldCBlbmdpbmUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5naW5lO1xyXG4gIH1cclxuICBnZXRJbmZvKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbG9nczogdGhpcy5sb2dzLFxyXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBmb3IgY29ubmVjdGlvbnMgcXVhbGl0eSB0byBjbG9zZXN0cyBDbG91ZCByZWdpb25zIGFuZCBkZXRlcm1pbmluZyB0aGUgYmVzdCBxdWFsaXR5XHJcbiAqL1xyXG5jbGFzcyBDbG91ZFJlZ2lvbkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdDbG91ZCByZWdpb25zJztcclxuICB9XHJcbiAgcGVyZm9ybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHJlZ2lvblByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHRoaXMudXJsLCB0aGlzLnRva2VuKTtcclxuICAgICAgaWYgKCFyZWdpb25Qcm92aWRlci5pc0Nsb3VkKCkpIHtcclxuICAgICAgICB0aGlzLnNraXAoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVnaW9uU3RhdHMgPSBbXTtcclxuICAgICAgY29uc3Qgc2VlblVybHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgcmVnaW9uUHJvdmlkZXIuZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcclxuICAgICAgICBpZiAoIXJlZ2lvblVybCkge1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWVuVXJscy5oYXMocmVnaW9uVXJsKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZW5VcmxzLmFkZChyZWdpb25VcmwpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nsb3VkUmVnaW9uKHJlZ2lvblVybCk7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiXCIuY29uY2F0KHN0YXRzLnJlZ2lvbiwgXCIgUlRUOiBcIikuY29uY2F0KHN0YXRzLnJ0dCwgXCJtcywgZHVyYXRpb246IFwiKS5jb25jYXQoc3RhdHMuZHVyYXRpb24sIFwibXNcIikpO1xyXG4gICAgICAgIHJlZ2lvblN0YXRzLnB1c2goc3RhdHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJlZ2lvblN0YXRzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gKGEuZHVyYXRpb24gLSBiLmR1cmF0aW9uKSAqIDAuNSArIChhLnJ0dCAtIGIucnR0KSAqIDAuNTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IGJlc3RSZWdpb24gPSByZWdpb25TdGF0c1swXTtcclxuICAgICAgdGhpcy5iZXN0U3RhdHMgPSBiZXN0UmVnaW9uO1xyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJiZXN0IENsb3VkIHJlZ2lvbjogXCIuY29uY2F0KGJlc3RSZWdpb24ucmVnaW9uKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0SW5mbygpIHtcclxuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XHJcbiAgICBpbmZvLmRhdGEgPSB0aGlzLmJlc3RTdGF0cztcclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH1cclxuICBjaGVja0Nsb3VkUmVnaW9uKHVybCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgeWllbGQgdGhpcy5jb25uZWN0KHVybCk7XHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09ICd0Y3AnKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVnaW9uID0gKF9hID0gdGhpcy5yb29tLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWdpb247XHJcbiAgICAgIGlmICghcmVnaW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpb24gbm90IGZvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgd3JpdGVyID0geWllbGQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuc3RyZWFtVGV4dCh7XHJcbiAgICAgICAgdG9waWM6ICd0ZXN0J1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAwMDsgLy8gZWFjaCBjaHVuayBpcyBhYm91dCAxMDAwIGJ5dGVzXHJcbiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IDEwMDAwMDA7IC8vIGFwcHJveGltYXRlbHkgMU1CIG9mIGRhdGFcclxuICAgICAgY29uc3QgbnVtQ2h1bmtzID0gdG90YWxTaXplIC8gY2h1bmtTaXplOyAvLyB3aWxsIHlpZWxkIDEwMDAgY2h1bmtzXHJcbiAgICAgIGNvbnN0IGNodW5rRGF0YSA9ICdBJy5yZXBlYXQoY2h1bmtTaXplKTsgLy8gY3JlYXRlIGEgc3RyaW5nIG9mIDEwMDAgJ0EnIGNoYXJhY3RlcnNcclxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaHVua3M7IGkrKykge1xyXG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZShjaHVua0RhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xyXG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2IgPSB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnB1Ymxpc2hlci5nZXRTdGF0cygpO1xyXG4gICAgICBjb25zdCByZWdpb25TdGF0cyA9IHtcclxuICAgICAgICByZWdpb246IHJlZ2lvbixcclxuICAgICAgICBydHQ6IDEwMDAwLFxyXG4gICAgICAgIGR1cmF0aW9uOiBlbmRUaW1lIC0gc3RhcnRUaW1lXHJcbiAgICAgIH07XHJcbiAgICAgIHN0YXRzID09PSBudWxsIHx8IHN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicgJiYgc3RhdC5ub21pbmF0ZWQpIHtcclxuICAgICAgICAgIHJlZ2lvblN0YXRzLnJ0dCA9IHN0YXQuY3VycmVudFJvdW5kVHJpcFRpbWUgKiAxMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gcmVnaW9uU3RhdHM7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IFRFU1RfRFVSQVRJT04gPSAxMDAwMDtcclxuY2xhc3MgQ29ubmVjdGlvblByb3RvY29sQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcclxuICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ0Nvbm5lY3Rpb24gdmlhIFVEUCB2cyBUQ1AnO1xyXG4gIH1cclxuICBwZXJmb3JtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgdWRwU3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ29ubmVjdGlvblByb3RvY29sKCd1ZHAnKTtcclxuICAgICAgY29uc3QgdGNwU3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ29ubmVjdGlvblByb3RvY29sKCd0Y3AnKTtcclxuICAgICAgdGhpcy5iZXN0U3RhdHMgPSB1ZHBTdGF0cztcclxuICAgICAgLy8gdWRwIHNob3VsZCBpcyB0aGUgYmV0dGVyIHByb3RvY29sIHR5cGljYWxseS4gaG93ZXZlciwgd2UnZCBwcmVmZXIgVENQIHdoZW4gZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIHRydWU6XHJcbiAgICAgIC8vIDEuIHRoZSBiYW5kd2lkdGggbGltaXRhdGlvbiBpcyB3b3JzZSBvbiBVRFAgYnkgNTAwbXNcclxuICAgICAgLy8gMi4gdGhlIHBhY2tldCBsb3NzIGlzIGhpZ2hlciBvbiBVRFAgYnkgMSVcclxuICAgICAgaWYgKHVkcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAtIHRjcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCA+IDAuNSB8fCAodWRwU3RhdHMucGFja2V0c0xvc3QgLSB0Y3BTdGF0cy5wYWNrZXRzTG9zdCkgLyB1ZHBTdGF0cy5wYWNrZXRzU2VudCA+IDAuMDEpIHtcclxuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB0Y3AnKTtcclxuICAgICAgICB0aGlzLmJlc3RTdGF0cyA9IHRjcFN0YXRzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnYmVzdCBjb25uZWN0aW9uIHF1YWxpdHkgdmlhIHVkcCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5iZXN0U3RhdHM7XHJcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInVwc3RyZWFtIGJpdHJhdGU6IFwiLmNvbmNhdCgoc3RhdHMuYml0cmF0ZVRvdGFsIC8gc3RhdHMuY291bnQgLyAxMDAwIC8gMTAwMCkudG9GaXhlZCgyKSwgXCIgbWJwc1wiKSk7XHJcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIlJUVDogXCIuY29uY2F0KChzdGF0cy5ydHRUb3RhbCAvIHN0YXRzLmNvdW50ICogMTAwMCkudG9GaXhlZCgyKSwgXCIgbXNcIikpO1xyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJqaXR0ZXI6IFwiLmNvbmNhdCgoc3RhdHMuaml0dGVyVG90YWwgLyBzdGF0cy5jb3VudCAqIDEwMDApLnRvRml4ZWQoMiksIFwiIG1zXCIpKTtcclxuICAgICAgaWYgKHN0YXRzLnBhY2tldHNMb3N0ID4gMCkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcInBhY2tldHMgbG9zdDogXCIuY29uY2F0KChzdGF0cy5wYWNrZXRzTG9zdCAvIHN0YXRzLnBhY2tldHNTZW50ICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggPiAxKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiYmFuZHdpZHRoIGxpbWl0ZWQgXCIuY29uY2F0KChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggLyAoVEVTVF9EVVJBVElPTiAvIDEwMDApICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5jcHUgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiY3B1IGxpbWl0ZWQgXCIuY29uY2F0KChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5jcHUgLyAoVEVTVF9EVVJBVElPTiAvIDEwMDApICogMTAwKS50b0ZpeGVkKDIpLCBcIiVcIikpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZ2V0SW5mbygpIHtcclxuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XHJcbiAgICBpbmZvLmRhdGEgPSB0aGlzLmJlc3RTdGF0cztcclxuICAgIHJldHVybiBpbmZvO1xyXG4gIH1cclxuICBjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbChwcm90b2NvbCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gJ3RjcCcpIHtcclxuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd0Y3AnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd1ZHAnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBjcmVhdGUgYSBjYW52YXMgd2l0aCBhbmltYXRlZCBjb250ZW50XHJcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICBjYW52YXMud2lkdGggPSAxMjgwO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gNzIwO1xyXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgY2FudmFzIGNvbnRleHQnKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgaHVlID0gMDtcclxuICAgICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcclxuICAgICAgICBodWUgPSAoaHVlICsgMSkgJSAzNjA7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiaHNsKFwiLmNvbmNhdChodWUsIFwiLCAxMDAlLCA1MCUpXCIpO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgfTtcclxuICAgICAgYW5pbWF0ZSgpO1xyXG4gICAgICAvLyBjcmVhdGUgdmlkZW8gdHJhY2sgZnJvbSBjYW52YXNcclxuICAgICAgY29uc3Qgc3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oMzApOyAvLyAzMGZwc1xyXG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgIC8vIHB1Ymxpc2ggdG8gcm9vbVxyXG4gICAgICBjb25zdCBwdWIgPSB5aWVsZCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodmlkZW9UcmFjaywge1xyXG4gICAgICAgIHNpbXVsY2FzdDogZmFsc2UsXHJcbiAgICAgICAgZGVncmFkYXRpb25QcmVmZXJlbmNlOiAnbWFpbnRhaW4tcmVzb2x1dGlvbicsXHJcbiAgICAgICAgdmlkZW9FbmNvZGluZzoge1xyXG4gICAgICAgICAgbWF4Qml0cmF0ZTogMjAwMDAwMFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrO1xyXG4gICAgICBjb25zdCBwcm90b2NvbFN0YXRzID0ge1xyXG4gICAgICAgIHByb3RvY29sLFxyXG4gICAgICAgIHBhY2tldHNMb3N0OiAwLFxyXG4gICAgICAgIHBhY2tldHNTZW50OiAwLFxyXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB7fSxcclxuICAgICAgICBydHRUb3RhbDogMCxcclxuICAgICAgICBqaXR0ZXJUb3RhbDogMCxcclxuICAgICAgICBiaXRyYXRlVG90YWw6IDAsXHJcbiAgICAgICAgY291bnQ6IDBcclxuICAgICAgfTtcclxuICAgICAgLy8gZ2F0aGVyIHN0YXRzIG9uY2UgYSBzZWNvbmRcclxuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0cmFjay5nZXRSVENTdGF0c1JlcG9ydCgpO1xyXG4gICAgICAgIHN0YXRzID09PSBudWxsIHx8IHN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xyXG4gICAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcclxuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5wYWNrZXRzU2VudCA9IHN0YXQucGFja2V0c1NlbnQ7XHJcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMgPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zO1xyXG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLmJpdHJhdGVUb3RhbCArPSBzdGF0LnRhcmdldEJpdHJhdGU7XHJcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuY291bnQrKztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdC50eXBlID09PSAncmVtb3RlLWluYm91bmQtcnRwJykge1xyXG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNMb3N0ID0gc3RhdC5wYWNrZXRzTG9zdDtcclxuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5ydHRUb3RhbCArPSBzdGF0LnJvdW5kVHJpcFRpbWU7XHJcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuaml0dGVyVG90YWwgKz0gc3RhdC5qaXR0ZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pLCAxMDAwKTtcclxuICAgICAgLy8gd2FpdCBhIGJpdCB0byBnYXRoZXIgc3RhdHNcclxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIFRFU1RfRFVSQVRJT04pKTtcclxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgIHZpZGVvVHJhY2suc3RvcCgpO1xyXG4gICAgICBjYW52YXMucmVtb3ZlKCk7XHJcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgICByZXR1cm4gcHJvdG9jb2xTdGF0cztcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgUHVibGlzaEF1ZGlvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcclxuICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIGF1ZGlvJztcclxuICB9XHJcbiAgcGVyZm9ybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYTtcclxuICAgICAgY29uc3Qgcm9vbSA9IHlpZWxkIHRoaXMuY29ubmVjdCgpO1xyXG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpO1xyXG4gICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgZGV0ZWN0U2lsZW5jZSh0cmFjaywgMTAwMCk7XHJcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGV0ZWN0IGF1ZGlvIGZyb20gbWljcm9waG9uZScpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnZGV0ZWN0ZWQgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XHJcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xyXG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcclxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcclxuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XHJcbiAgICAgIGlmICghc3RhdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XHJcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgKHN0YXQua2luZCA9PT0gJ2F1ZGlvJyB8fCAhc3RhdC5raW5kICYmIHN0YXQubWVkaWFUeXBlID09PSAnYXVkaW8nKSkge1xyXG4gICAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcInB1Ymxpc2hlZCBcIi5jb25jYXQobnVtUGFja2V0cywgXCIgYXVkaW8gcGFja2V0c1wiKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFB1Ymxpc2hWaWRlb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdDYW4gcHVibGlzaCB2aWRlbyc7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2E7XHJcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcclxuICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCBjcmVhdGVMb2NhbFZpZGVvVHJhY2soKTtcclxuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBmcm9tIGNhbWVyYVxyXG4gICAgICB5aWVsZCB0aGlzLmNoZWNrRm9yVmlkZW8odHJhY2subWVkaWFTdHJlYW1UcmFjayk7XHJcbiAgICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xyXG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcclxuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcclxuICAgICAgLy8gdmVyaWZ5IFJUQyBzdGF0cyB0aGF0IGl0J3MgcHVibGlzaGluZ1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XHJcbiAgICAgIGlmICghc3RhdHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgbnVtUGFja2V0cyA9IDA7XHJcbiAgICAgIHN0YXRzLmZvckVhY2goc3RhdCA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgKHN0YXQua2luZCA9PT0gJ3ZpZGVvJyB8fCAhc3RhdC5raW5kICYmIHN0YXQubWVkaWFUeXBlID09PSAndmlkZW8nKSkge1xyXG4gICAgICAgICAgbnVtUGFja2V0cyArPSBzdGF0LnBhY2tldHNTZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChudW1QYWNrZXRzID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHBhY2tldHMgYXJlIHNlbnQnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJwdWJsaXNoZWQgXCIuY29uY2F0KG51bVBhY2tldHMsIFwiIHZpZGVvIHBhY2tldHNcIikpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrRm9yVmlkZW8odHJhY2spIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gICAgICBzdHJlYW0uYWRkVHJhY2sodHJhY2suY2xvbmUoKSk7XHJcbiAgICAgIC8vIENyZWF0ZSB2aWRlbyBlbGVtZW50IHRvIGNoZWNrIGZyYW1lc1xyXG4gICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcclxuICAgICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xyXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICB2aWRlby5vbnBsYXkgPSAoKSA9PiB7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IChfYiA9IChfYSA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aWRlby52aWRlb1dpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxMjgwO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAoX2QgPSAoX2MgPSBzZXR0aW5ncy5oZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHZpZGVvLnZpZGVvSGVpZ2h0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiA3MjA7XHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgLy8gRHJhdyB2aWRlbyBmcmFtZSB0byBjYW52YXNcclxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIEdldCBpbWFnZSBkYXRhIGFuZCBjaGVjayBpZiBhbGwgcGl4ZWxzIGFyZSBibGFja1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICAgICAgbGV0IGlzQWxsQmxhY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMCB8fCBkYXRhW2kgKyAxXSAhPT0gMCB8fCBkYXRhW2kgKyAyXSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaXNBbGxCbGFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0FsbEJsYWNrKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcignY2FtZXJhIGFwcGVhcnMgdG8gYmUgcHJvZHVjaW5nIG9ubHkgYmxhY2sgZnJhbWVzJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdyZWNlaXZlZCB2aWRlbyBmcmFtZXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9LCAxMDAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZpZGVvLnBsYXkoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHZpZGVvLnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBSZWNvbm5lY3RDaGVjayBleHRlbmRzIENoZWNrZXIge1xyXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnUmVzdW1pbmcgY29ubmVjdGlvbiBhZnRlciBpbnRlcnJ1cHRpb24nO1xyXG4gIH1cclxuICBwZXJmb3JtKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgdmFyIF9hO1xyXG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XHJcbiAgICAgIGxldCByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSBmYWxzZTtcclxuICAgICAgbGV0IHJlY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgIGxldCByZWNvbm5lY3RSZXNvbHZlcjtcclxuICAgICAgY29uc3QgcmVjb25uZWN0VGltZW91dCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XHJcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIgPSByZXNvbHZlO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgaGFuZGxlUmVjb25uZWN0aW5nID0gKCkgPT4ge1xyXG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgIH07XHJcbiAgICAgIHJvb20ub24oUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZywgaGFuZGxlUmVjb25uZWN0aW5nKS5vbihSb29tRXZlbnQuUmVjb25uZWN0aW5nLCBoYW5kbGVSZWNvbm5lY3RpbmcpLm9uKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgKCkgPT4ge1xyXG4gICAgICAgIHJlY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICByZWNvbm5lY3RSZXNvbHZlcih0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIChfYSA9IHJvb20uZW5naW5lLmNsaWVudC53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XHJcbiAgICAgIGNvbnN0IG9uQ2xvc2UgPSByb29tLmVuZ2luZS5jbGllbnQub25DbG9zZTtcclxuICAgICAgaWYgKG9uQ2xvc2UpIHtcclxuICAgICAgICBvbkNsb3NlKCcnKTtcclxuICAgICAgfVxyXG4gICAgICB5aWVsZCByZWNvbm5lY3RUaW1lb3V0O1xyXG4gICAgICBpZiAoIXJlY29ubmVjdGluZ1RyaWdnZXJlZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBhdHRlbXB0IHRvIHJlY29ubmVjdCcpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFyZWNvbm5lY3RlZCB8fCByb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdyZWNvbm5lY3Rpb24gaXMgb25seSBwb3NzaWJsZSBpbiBSZWRpcy1iYXNlZCBjb25maWd1cmF0aW9ucycpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFibGUgdG8gcmVjb25uZWN0Jyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgVFVSTkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XHJcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xyXG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICBjb25zdCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XHJcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xyXG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXHJcbiAgICAgICAgbWF4UmV0cmllczogMCxcclxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcclxuICAgICAgfSk7XHJcbiAgICAgIGxldCBoYXNUTFMgPSBmYWxzZTtcclxuICAgICAgbGV0IGhhc1RVUk4gPSBmYWxzZTtcclxuICAgICAgbGV0IGhhc1NUVU4gPSBmYWxzZTtcclxuICAgICAgZm9yIChsZXQgaWNlU2VydmVyIG9mIGpvaW5SZXMuaWNlU2VydmVycykge1xyXG4gICAgICAgIGZvciAobGV0IHVybCBvZiBpY2VTZXJ2ZXIudXJscykge1xyXG4gICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuOicpKSB7XHJcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xyXG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm5zOicpKSB7XHJcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xyXG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcclxuICAgICAgICAgICAgaGFzVExTID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnc3R1bjonKSkge1xyXG4gICAgICAgICAgICBoYXNTVFVOID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFoYXNTVFVOKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBTVFVOIHNlcnZlcnMgY29uZmlndXJlZCBvbiBzZXJ2ZXIgc2lkZS4nKTtcclxuICAgICAgfSBlbHNlIGlmIChoYXNUVVJOICYmICFoYXNUTFMpIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1RVUk4gaXMgY29uZmlndXJlZCBzZXJ2ZXIgc2lkZSwgYnV0IFRVUk4vVExTIGlzIHVuYXZhaWxhYmxlLicpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xyXG4gICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydGNDb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pY2VTZXJ2ZXJzKSB8fCBoYXNUVVJOKSB7XHJcbiAgICAgICAgeWllbGQgdGhpcy5yb29tLmNvbm5lY3QodGhpcy51cmwsIHRoaXMudG9rZW4sIHtcclxuICAgICAgICAgIHJ0Y0NvbmZpZzoge1xyXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdyZWxheSdcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFRVUk4gc2VydmVycyBjb25maWd1cmVkLicpO1xyXG4gICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgV2ViUlRDQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcclxuICBnZXQgZGVzY3JpcHRpb24oKSB7XHJcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XHJcbiAgfVxyXG4gIHBlcmZvcm0oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICBsZXQgaGFzVGNwID0gZmFsc2U7XHJcbiAgICAgIGxldCBoYXNJcHY0VWRwID0gZmFsc2U7XHJcbiAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJldlRyaWNrbGUgPSB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGU7XHJcbiAgICAgICAgdGhpcy5yb29tLmVuZ2luZS5jbGllbnQub25Ucmlja2xlID0gKHNkLCB0YXJnZXQpID0+IHtcclxuICAgICAgICAgIGlmIChzZC5jYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShzZCk7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBcIlwiLmNvbmNhdChjYW5kaWRhdGUucHJvdG9jb2wsIFwiIFwiKS5jb25jYXQoY2FuZGlkYXRlLmFkZHJlc3MsIFwiOlwiKS5jb25jYXQoY2FuZGlkYXRlLnBvcnQsIFwiIFwiKS5jb25jYXQoY2FuZGlkYXRlLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlLmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyAocHJpdmF0ZSknO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgIGhhc1RjcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnIChwYXNzaXZlKSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcclxuICAgICAgICAgICAgICAgICAgaGFzSXB2NFVkcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShzdHIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHByZXZUcmlja2xlKSB7XHJcbiAgICAgICAgICAgIHByZXZUcmlja2xlKHNkLCB0YXJnZXQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyKSB7XHJcbiAgICAgICAgICB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlci5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSBldiA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldiBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcImVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogXCIuY29uY2F0KGV2LmVycm9yQ29kZSwgXCIgXCIpLmNvbmNhdChldi5lcnJvclRleHQsIFwiIFwiKS5jb25jYXQoZXYudXJsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcclxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ25vdyB0aGUgcm9vbSBpcyBjb25uZWN0ZWQnKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdwb3J0cyBuZWVkIHRvIGJlIG9wZW4gb24gZmlyZXdhbGwgaW4gb3JkZXIgdG8gY29ubmVjdC4nKTtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFoYXNUY3ApIHtcclxuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBub3QgY29uZmlndXJlZCBmb3IgSUNFL1RDUCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaGFzSXB2NFVkcCkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gcHVibGljIElQdjQgVURQIGNhbmRpZGF0ZXMgd2VyZSBmb3VuZC4gWW91ciBzZXJ2ZXIgaXMgbGlrZWx5IG5vdCBjb25maWd1cmVkIGNvcnJlY3RseScpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzcykge1xyXG4gIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLicpO1xyXG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDQpIHtcclxuICAgIGlmIChwYXJ0c1swXSA9PT0gJzEwJykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxOTInICYmIHBhcnRzWzFdID09PSAnMTY4Jykge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxNzInKSB7XHJcbiAgICAgIGNvbnN0IHNlY29uZCA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XHJcbiAgICAgIGlmIChzZWNvbmQgPj0gMTYgJiYgc2Vjb25kIDw9IDMxKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5jbGFzcyBXZWJTb2NrZXRDaGVjayBleHRlbmRzIENoZWNrZXIge1xyXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcclxuICB9XHJcbiAgcGVyZm9ybSgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICBpZiAodGhpcy51cmwuc3RhcnRzV2l0aCgnd3M6JykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnaHR0cDonKSkge1xyXG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIGluc2VjdXJlLCBjbGllbnRzIG1heSBibG9jayBjb25uZWN0aW9ucyB0byBpdCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBzaWduYWxDbGllbnQgPSBuZXcgU2lnbmFsQ2xpZW50KCk7XHJcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xyXG4gICAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXHJcbiAgICAgICAgbWF4UmV0cmllczogMCxcclxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgd2Vic29ja2V0VGltZW91dDogMTUwMDBcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkNvbm5lY3RlZCB0byBzZXJ2ZXIsIHZlcnNpb24gXCIuY29uY2F0KGpvaW5SZXMuc2VydmVyVmVyc2lvbiwgXCIuXCIpKTtcclxuICAgICAgaWYgKCgoX2EgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lZGl0aW9uKSA9PT0gU2VydmVySW5mb19FZGl0aW9uLkNsb3VkICYmICgoX2IgPSBqb2luUmVzLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpb24pKSB7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiTGl2ZUtpdCBDbG91ZDogXCIuY29uY2F0KChfYyA9IGpvaW5SZXMuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lvbikpO1xyXG4gICAgICB9XHJcbiAgICAgIHlpZWxkIHNpZ25hbENsaWVudC5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBDb25uZWN0aW9uQ2hlY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IodXJsLCB0b2tlbikge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgdGhpcy5jaGVja1Jlc3VsdHMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnVybCA9IHVybDtcclxuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG4gIGdldE5leHRDaGVja0lkKCkge1xyXG4gICAgY29uc3QgbmV4dElkID0gdGhpcy5jaGVja1Jlc3VsdHMuc2l6ZTtcclxuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChuZXh0SWQsIHtcclxuICAgICAgbG9nczogW10sXHJcbiAgICAgIHN0YXR1czogQ2hlY2tTdGF0dXMuSURMRSxcclxuICAgICAgbmFtZTogJycsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnJ1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV4dElkO1xyXG4gIH1cclxuICB1cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKSB7XHJcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQoY2hlY2tJZCwgaW5mbyk7XHJcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XHJcbiAgfVxyXG4gIGlzU3VjY2VzcygpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKS5ldmVyeShyID0+IHIuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5GQUlMRUQpO1xyXG4gIH1cclxuICBnZXRSZXN1bHRzKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xyXG4gIH1cclxuICBjcmVhdGVBbmRSdW5DaGVjayhjaGVjaykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgY29uc3QgY2hlY2tJZCA9IHRoaXMuZ2V0TmV4dENoZWNrSWQoKTtcclxuICAgICAgY29uc3QgdGVzdCA9IG5ldyBjaGVjayh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5vcHRpb25zKTtcclxuICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gaW5mbyA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDaGVjayhjaGVja0lkLCBpbmZvKTtcclxuICAgICAgfTtcclxuICAgICAgdGVzdC5vbigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcclxuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGVzdC5ydW4oKTtcclxuICAgICAgdGVzdC5vZmYoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tXZWJzb2NrZXQoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJTb2NrZXRDaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tXZWJSVEMoKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJSVENDaGVjayk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgY2hlY2tUVVJOKCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soVFVSTkNoZWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja1JlY29ubmVjdCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFJlY29ubmVjdENoZWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja1B1Ymxpc2hBdWRpbygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hBdWRpb0NoZWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja1B1Ymxpc2hWaWRlbygpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hWaWRlb0NoZWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGNvbnN0IGluZm8gPSB5aWVsZCB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKENvbm5lY3Rpb25Qcm90b2NvbENoZWNrKTtcclxuICAgICAgaWYgKGluZm8uZGF0YSAmJiAncHJvdG9jb2wnIGluIGluZm8uZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gaW5mby5kYXRhO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5wcm90b2NvbCA9IHN0YXRzLnByb3RvY29sO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNoZWNrQ2xvdWRSZWdpb24oKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDbG91ZFJlZ2lvbkNoZWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyeSB0byBhbmFseXplIHRoZSBsb2NhbCB0cmFjayB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIG9mIGEgdHJhY2suXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZXJlIGlzIG5vIHByb3BlcnR5IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMgdG8gZGV0ZWN0IHdoZXRoZXIgYSB2aWRlbyB0cmFjayBvcmlnaW5hdGVkIGZyb20gYSB1c2VyLSBvciBlbnZpcm9ubWVudC1mYWNpbmcgY2FtZXJhIGRldmljZS5cclxuICogRm9yIHRoaXMgcmVhc29uLCB3ZSB1c2UgdGhlIGBmYWNpbmdNb2RlYCBwcm9wZXJ0eSB3aGVuIGF2YWlsYWJsZSwgYnV0IHdpbGwgZmFsbCBiYWNrIG9uIGEgc3RyaW5nLWJhc2VkIGFuYWx5c2lzIG9mIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cclxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tDb25zdHJhaW50cy9mYWNpbmdNb2RlIHwgTUROIGRvY3Mgb24gZmFjaW5nTW9kZX1cclxuICogQGV4cGVyaW1lbnRhbFxyXG4gKi9cclxuZnVuY3Rpb24gZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrKGxvY2FsVHJhY2spIHtcclxuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgdmFyIF9hO1xyXG4gIGNvbnN0IHRyYWNrID0gaXNMb2NhbFRyYWNrKGxvY2FsVHJhY2spID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcclxuICBjb25zdCB0cmFja1NldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcclxuICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgZmFjaW5nTW9kZTogKF9hID0gb3B0aW9ucy5kZWZhdWx0RmFjaW5nTW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3VzZXInLFxyXG4gICAgY29uZmlkZW5jZTogJ2xvdydcclxuICB9O1xyXG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxyXG4gIGlmICgnZmFjaW5nTW9kZScgaW4gdHJhY2tTZXR0aW5ncykge1xyXG4gICAgY29uc3QgcmF3RmFjaW5nTW9kZSA9IHRyYWNrU2V0dGluZ3MuZmFjaW5nTW9kZTtcclxuICAgIGxpdmVraXRMb2dnZXIudHJhY2UoJ3Jhd0ZhY2luZ01vZGUnLCB7XHJcbiAgICAgIHJhd0ZhY2luZ01vZGVcclxuICAgIH0pO1xyXG4gICAgaWYgKHJhd0ZhY2luZ01vZGUgJiYgdHlwZW9mIHJhd0ZhY2luZ01vZGUgPT09ICdzdHJpbmcnICYmIGlzRmFjaW5nTW9kZVZhbHVlKHJhd0ZhY2luZ01vZGUpKSB7XHJcbiAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICBmYWNpbmdNb2RlOiByYXdGYWNpbmdNb2RlLFxyXG4gICAgICAgIGNvbmZpZGVuY2U6ICdoaWdoJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyAyLiBJZiB3ZSBkb24ndCBoYXZlIGEgaGlnaCBjb25maWRlbmNlIHdlIHRyeSB0byBnZXQgdGhlIGZhY2luZyBtb2RlIGZyb20gdGhlIGRldmljZSBsYWJlbC5cclxuICBpZiAoWydsb3cnLCAnbWVkaXVtJ10uaW5jbHVkZXMocmVzdWx0LmNvbmZpZGVuY2UpKSB7XHJcbiAgICBsaXZla2l0TG9nZ2VyLnRyYWNlKFwiVHJ5IHRvIGdldCBmYWNpbmcgbW9kZSBmcm9tIGRldmljZSBsYWJlbDogKFwiLmNvbmNhdCh0cmFjay5sYWJlbCwgXCIpXCIpKTtcclxuICAgIGNvbnN0IGxhYmVsQW5hbHlzaXNSZXN1bHQgPSBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKHRyYWNrLmxhYmVsKTtcclxuICAgIGlmIChsYWJlbEFuYWx5c2lzUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXAoW1snb2JzIHZpcnR1YWwgY2FtZXJhJywge1xyXG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXHJcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcclxufV1dKTtcclxuY29uc3Qga25vd25EZXZpY2VMYWJlbFNlY3Rpb25zID0gbmV3IE1hcChbWydpcGhvbmUnLCB7XHJcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcclxuICBjb25maWRlbmNlOiAnbWVkaXVtJ1xyXG59XSwgWydpcGFkJywge1xyXG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXHJcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcclxufV1dKTtcclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gYW5hbHl6ZSB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXHJcbiAqXHJcbiAqIEBleHBlcmltZW50YWxcclxuICovXHJcbmZ1bmN0aW9uIGZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwoZGV2aWNlTGFiZWwpIHtcclxuICB2YXIgX2E7XHJcbiAgY29uc3QgbGFiZWwgPSBkZXZpY2VMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKTtcclxuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXHJcbiAgaWYgKGxhYmVsID09PSAnJykge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgd2lkZWx5IGtub3duIGRldmljZSBsYWJlbHMuXHJcbiAgaWYgKGtub3duRGV2aWNlTGFiZWxzLmhhcyhsYWJlbCkpIHtcclxuICAgIHJldHVybiBrbm93bkRldmljZUxhYmVscy5nZXQobGFiZWwpO1xyXG4gIH1cclxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxyXG4gIHJldHVybiAoX2EgPSBBcnJheS5mcm9tKGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucy5lbnRyaWVzKCkpLmZpbmQoX3JlZiA9PiB7XHJcbiAgICBsZXQgW3NlY3Rpb25dID0gX3JlZjtcclxuICAgIHJldHVybiBsYWJlbC5pbmNsdWRlcyhzZWN0aW9uKTtcclxuICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xyXG59XHJcbmZ1bmN0aW9uIGlzRmFjaW5nTW9kZVZhbHVlKGl0ZW0pIHtcclxuICBjb25zdCBhbGxvd2VkVmFsdWVzID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcclxuICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMoaXRlbSk7XHJcbn1cclxuXHJcbmV4cG9ydCB7IEF1ZGlvUHJlc2V0cywgQmFja3VwQ29kZWNQb2xpY3ksIEJhc2VLZXlQcm92aWRlciwgQ2hlY2tTdGF0dXMsIENoZWNrZXIsIENvbm5lY3Rpb25DaGVjaywgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24sIENvbm5lY3Rpb25RdWFsaXR5LCBDb25uZWN0aW9uU3RhdGUsIENyaXRpY2FsVGltZXJzLCBDcnlwdG9yRXJyb3IsIENyeXB0b3JFcnJvclJlYXNvbiwgQ3J5cHRvckV2ZW50LCBEYXRhUGFja2V0X0tpbmQsIERlZmF1bHRSZWNvbm5lY3RQb2xpY3ksIERldmljZVVuc3VwcG9ydGVkRXJyb3IsIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25FdmVudCwgRW5naW5lRXZlbnQsIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyLCBLZXlIYW5kbGVyRXZlbnQsIEtleVByb3ZpZGVyRXZlbnQsIExpdmVraXRFcnJvciwgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFBhcnRpY2lwYW50LCBMb2NhbFRyYWNrLCBMb2NhbFRyYWNrUHVibGljYXRpb24sIExvY2FsVHJhY2tSZWNvcmRlciwgTG9jYWxWaWRlb1RyYWNrLCBMb2dMZXZlbCwgTG9nZ2VyTmFtZXMsIE1lZGlhRGV2aWNlRmFpbHVyZSwgXyBhcyBNdXRleCwgTmVnb3RpYXRpb25FcnJvciwgUGFydGljaXBhbnQsIFBhcnRpY2lwYW50RXZlbnQsIFBhcnRpY2lwYW50SW5mb19LaW5kIGFzIFBhcnRpY2lwYW50S2luZCwgUHVibGlzaERhdGFFcnJvciwgUHVibGlzaFRyYWNrRXJyb3IsIFJlbW90ZUF1ZGlvVHJhY2ssIFJlbW90ZVBhcnRpY2lwYW50LCBSZW1vdGVUcmFjaywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgUmVtb3RlVmlkZW9UcmFjaywgUm9vbSwgUm9vbUV2ZW50LCBScGNFcnJvciwgU2NyZWVuU2hhcmVQcmVzZXRzLCBTaWduYWxSZXF1ZXN0RXJyb3IsIFN1YnNjcmlwdGlvbkVycm9yLCBUcmFjaywgVHJhY2tFdmVudCwgVHJhY2tJbnZhbGlkRXJyb3IsIFRyYWNrUHVibGljYXRpb24sIFRyYWNrVHlwZSwgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSwgVW5zdXBwb3J0ZWRTZXJ2ZXIsIFZpZGVvUHJlc2V0LCBWaWRlb1ByZXNldHMsIFZpZGVvUHJlc2V0czQzLCBWaWRlb1F1YWxpdHksIGF0dGFjaFRvRWxlbWVudCwgYXR0cmlidXRlVHlwaW5ncyBhcyBhdHRyaWJ1dGVzLCBjb21wYXJlVmVyc2lvbnMsIGNyZWF0ZUF1ZGlvQW5hbHlzZXIsIGNyZWF0ZUUyRUVLZXksIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlciwgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nLCBjcmVhdGVMb2NhbEF1ZGlvVHJhY2ssIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzLCBjcmVhdGVMb2NhbFRyYWNrcywgY3JlYXRlTG9jYWxWaWRlb1RyYWNrLCBkZXJpdmVLZXlzLCBkZXRhY2hUcmFjaywgZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCwgZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrLCBnZXRCcm93c2VyLCBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2ssIGdldEVtcHR5VmlkZW9TdHJlYW1UcmFjaywgZ2V0TG9nZ2VyLCBpbXBvcnRLZXksIGlzQXVkaW9UcmFjaywgaXNCYWNrdXBDb2RlYywgaXNCcm93c2VyU3VwcG9ydGVkLCBpc0UyRUVTdXBwb3J0ZWQsIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCwgaXNMb2NhbFBhcnRpY2lwYW50LCBpc0xvY2FsVHJhY2ssIGlzUmVtb3RlUGFydGljaXBhbnQsIGlzUmVtb3RlVHJhY2ssIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkLCBpc1ZpZGVvRnJhbWUsIGlzVmlkZW9UcmFjaywgbmVlZHNSYnNwVW5lc2NhcGluZywgcGFyc2VSYnNwLCBwcm90b2NvbFZlcnNpb24sIHJhdGNoZXQsIHNldExvZ0V4dGVuc2lvbiwgc2V0TG9nTGV2ZWwsIHN1cHBvcnRzQVYxLCBzdXBwb3J0c0FkYXB0aXZlU3RyZWFtLCBzdXBwb3J0c0R5bmFjYXN0LCBzdXBwb3J0c1ZQOSwgdmVyc2lvbiwgdmlkZW9Db2RlY3MsIHdyaXRlUmJzcCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXZla2l0LWNsaWVudC5lc20ubWpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;