import * as r from "react";
import { u as k, r as j, a as x, b as X, c as A, d as Y, e as Z, f as T, g as K, h as ee, i as R, j as te, k as ne, m as se, G as ae, n as re, o as ce, p as N, q as oe, t as ie, v as W, w as G, x as Q, y as ue, l as w, z as de, A as le, B as F, C as fe, D as pe, E as be, F as me, H as Se, I as ge, J as ve, K as he, M as _, N as Me, O as ye, P as Pe, Q as ke, S as Te, T as Ee, U as we, V as Ae, W as $, X as Ce, Y as Ie, Z as Oe, _ as De, $ as Le, a0 as Re, a1 as Ne, a2 as Fe, a3 as Ve, a4 as _e, a5 as Be, a6 as ze, a7 as L, a8 as Ue, a9 as qe, aa as Je } from "./contexts-Cm1aSBTs.mjs";
import { m as E } from "./room-889cObLb.mjs";
import { ConnectionQuality as xe, ConnectionState as C, LocalTrackPublication as We, facingModeFromLocalTrack as Ge, Room as Qe, Track as v, createAudioAnalyser as V, ParticipantKind as B } from "livekit-client";
const $e = (e) => {
  const t = r.useRef(e);
  return r.useEffect(() => {
    t.current = e;
  }), t;
};
function He(e, t) {
  const n = Xe(), a = $e(t);
  return r.useLayoutEffect(() => {
    let s = !1;
    const c = e.current;
    if (!c) return;
    function o(u, i) {
      s || a.current(u, i);
    }
    return n == null || n.subscribe(c, o), () => {
      s = !0, n == null || n.unsubscribe(c, o);
    };
  }, [e.current, n, a]), n == null ? void 0 : n.observer;
}
function je() {
  let e = !1, t = [];
  const n = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const a = new ResizeObserver((s, c) => {
    t = t.concat(s), e || window.requestAnimationFrame(() => {
      const o = /* @__PURE__ */ new Set();
      for (let u = 0; u < t.length; u++) {
        if (o.has(t[u].target)) continue;
        o.add(t[u].target);
        const i = n.get(t[u].target);
        i == null || i.forEach((d) => d(t[u], c));
      }
      t = [], e = !1;
    }), e = !0;
  });
  return {
    observer: a,
    subscribe(s, c) {
      a.observe(s);
      const o = n.get(s) ?? [];
      o.push(c), n.set(s, o);
    },
    unsubscribe(s, c) {
      const o = n.get(s) ?? [];
      if (o.length === 1) {
        a.unobserve(s), n.delete(s);
        return;
      }
      const u = o.indexOf(c);
      u !== -1 && o.splice(u, 1), n.set(s, o);
    }
  };
}
let D;
const Xe = () => D || (D = je()), Ye = (e) => {
  const [t, n] = r.useState({ width: 0, height: 0 });
  r.useLayoutEffect(() => {
    if (e.current) {
      const { width: s, height: c } = e.current.getBoundingClientRect();
      n({ width: s, height: c });
    }
  }, [e.current]);
  const a = r.useCallback(
    (s) => n(s.contentRect),
    []
  );
  return He(e, a), t;
};
function b(e, t, n = !0) {
  const [a, s] = r.useState(t);
  return r.useEffect(() => {
    if (n && s(t), typeof window > "u" || !e) return;
    const c = e.subscribe(s);
    return () => c.unsubscribe();
  }, [e, n]), a;
}
function ht(e) {
  const t = (c) => typeof window < "u" ? window.matchMedia(c).matches : !1, [n, a] = r.useState(t(e));
  function s() {
    a(t(e));
  }
  return r.useEffect(() => {
    const c = window.matchMedia(e);
    return s(), c.addListener ? c.addListener(s) : c.addEventListener("change", s), () => {
      c.removeListener ? c.removeListener(s) : c.removeEventListener("change", s);
    };
  }, [e]), n;
}
function Mt(e) {
  const t = k(e), n = r.useCallback(async () => {
    await t.startAudio();
  }, [t]), a = r.useMemo(
    () => j(t),
    [t]
  ), { canPlayAudio: s } = b(a, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { canPlayAudio: s, startAudio: n };
}
function yt(e) {
  const { state: t, dispatch: n } = x().pin;
  return { buttonProps: r.useMemo(() => {
    const { className: s } = X();
    return E(e, {
      className: s,
      disabled: !(t != null && t.length),
      onClick: () => {
        n && n({ msg: "clear_pin" });
      }
    });
  }, [e, n, t]) };
}
function Pt(e = {}) {
  const t = A(e.participant), { className: n, connectionQualityObserver: a } = r.useMemo(
    () => Y(t),
    [t]
  ), s = b(a, xe.Unknown);
  return { className: n, quality: s };
}
function I(e) {
  const t = k(e), n = r.useMemo(() => Z(t), [t]);
  return b(n, t.state);
}
function kt(e, t) {
  const n = typeof e == "function" ? e : t, a = typeof e == "string" ? e : void 0, s = T(), { send: c, messageObservable: o, isSendingObservable: u } = r.useMemo(
    () => K(s, a, n),
    [s, a, n]
  ), i = b(o, void 0), d = b(u, !1);
  return {
    message: i,
    send: c,
    isSending: d
  };
}
function Tt(e) {
  const t = T(), n = I(t);
  return { buttonProps: r.useMemo(() => {
    const { className: s, disconnect: c } = ee(t);
    return E(e, {
      className: s,
      onClick: () => c(e.stopTracks ?? !0),
      disabled: n === C.Disconnected
    });
  }, [t, e, n]) };
}
function Ze(e) {
  if (e.publication instanceof We) {
    const t = e.publication.track;
    if (t) {
      const { facingMode: n } = Ge(t);
      return n;
    }
  }
  return "undefined";
}
function Et({ trackRef: e, props: t }) {
  const n = R(e), a = te(), { className: s } = r.useMemo(() => ne(), []), c = r.useMemo(() => se(n, a == null ? void 0 : a.pin.state), [n, a == null ? void 0 : a.pin.state]);
  return { mergedProps: r.useMemo(
    () => E(t, {
      className: s,
      onClick: (u) => {
        var i, d, f, l, p;
        (i = t.onClick) == null || i.call(t, u), c ? (f = a == null ? void 0 : (d = a.pin).dispatch) == null || f.call(d, {
          msg: "clear_pin"
        }) : (p = a == null ? void 0 : (l = a.pin).dispatch) == null || p.call(l, {
          msg: "set_pin",
          trackReference: n
        });
      }
    }),
    [t, s, n, c, a == null ? void 0 : a.pin]
  ), inFocus: c };
}
function wt(e, t, n = {}) {
  const a = n.gridLayouts ?? ae, { width: s, height: c } = Ye(e), o = re(a, t, s, c);
  return r.useEffect(() => {
    e.current && o && (e.current.style.setProperty("--lk-col-count", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty("--lk-row-count", o == null ? void 0 : o.rows.toString()));
  }, [e, o]), {
    layout: o,
    containerWidth: s,
    containerHeight: c
  };
}
function z(e, t = {}) {
  var u, i;
  const n = typeof e == "string" ? t.participant : e.participant, a = A(n), s = typeof e == "string" ? { participant: a, source: e } : e, [c, o] = r.useState(
    !!((u = s.publication) != null && u.isMuted || (i = a.getTrackPublication(s.source)) != null && i.isMuted)
  );
  return r.useEffect(() => {
    const d = ce(s).subscribe(o);
    return () => d.unsubscribe();
  }, [N(s)]), c;
}
function Ke(e) {
  const t = A(e), n = r.useMemo(() => oe(t), [t]);
  return b(n, t.isSpeaking);
}
function et(e = {}) {
  const t = k(e.room), [n, a] = r.useState(t.localParticipant), [s, c] = r.useState(
    n.isMicrophoneEnabled
  ), [o, u] = r.useState(
    n.isMicrophoneEnabled
  ), [i, d] = r.useState(
    n.lastMicrophoneError
  ), [f, l] = r.useState(n.lastCameraError), [p, S] = r.useState(
    n.isMicrophoneEnabled
  ), [g, m] = r.useState(
    void 0
  ), [y, h] = r.useState(void 0), P = (M) => {
    u(M.isCameraEnabled), c(M.isMicrophoneEnabled), S(M.isScreenShareEnabled), h(M.cameraTrack), m(M.microphoneTrack), d(M.participant.lastMicrophoneError), l(M.participant.lastCameraError), a(M.participant);
  };
  return r.useEffect(() => {
    const M = ie(t.localParticipant).subscribe(P);
    return () => M.unsubscribe();
  }, [t]), {
    isMicrophoneEnabled: s,
    isScreenShareEnabled: p,
    isCameraEnabled: o,
    microphoneTrack: g,
    cameraTrack: y,
    lastMicrophoneError: i,
    lastCameraError: f,
    localParticipant: n
  };
}
function At() {
  const e = T(), t = r.useMemo(
    () => W(e.localParticipant),
    [e]
  );
  return b(t, e.localParticipant.permissions);
}
function Ct({
  kind: e,
  room: t,
  track: n,
  requestPermissions: a,
  onError: s
}) {
  const c = G(), o = r.useMemo(() => t ?? c ?? new Qe(), [t, c]), u = r.useMemo(
    () => Q(e, s, a),
    [e, a, s]
  ), i = b(u, []), [d, f] = r.useState(
    (o == null ? void 0 : o.getActiveDevice(e)) ?? "default"
  ), { className: l, activeDeviceObservable: p, setActiveMediaDevice: S } = r.useMemo(
    () => ue(e, o),
    [e, o, n]
  );
  return r.useEffect(() => {
    const g = p.subscribe((m) => {
      m && (w.info("setCurrentDeviceId", m), f(m));
    });
    return () => {
      g == null || g.unsubscribe();
    };
  }, [p]), { devices: i, className: l, activeDeviceId: d, setActiveMediaDevice: S };
}
function It({
  kind: e,
  onError: t
}) {
  const n = r.useMemo(
    () => Q(e, t),
    [e, t]
  );
  return b(n, []);
}
function tt(e, t, n = {}) {
  const a = r.useRef([]), s = r.useRef(-1), c = t !== s.current, o = typeof n.customSortFunction == "function" ? n.customSortFunction(e) : de(e);
  let u = [...o];
  if (c === !1)
    try {
      u = le(a.current, o, t);
    } catch (i) {
      w.error("Error while running updatePages(): ", i);
    }
  return c ? a.current = o : a.current = u, s.current = t, u;
}
function Ot(e, t) {
  const [n, a] = r.useState(1), s = Math.max(Math.ceil(t.length / e), 1);
  n > s && a(s);
  const c = n * e, o = c - e, u = (l) => {
    a((p) => l === "next" ? p === s ? p : p + 1 : p === 1 ? p : p - 1);
  }, i = (l) => {
    l > s ? a(s) : l < 1 ? a(1) : a(l);
  }, f = tt(t, e).slice(o, c);
  return {
    totalPageCount: s,
    nextPage: () => u("next"),
    prevPage: () => u("previous"),
    setPage: i,
    firstItemIndex: o,
    lastItemIndex: c,
    tracks: f,
    currentPage: n
  };
}
function Dt(e = {}) {
  let t = F();
  e.participant && (t = e.participant);
  const n = r.useMemo(() => fe(t), [t]), { identity: a, name: s, metadata: c } = b(n, {
    name: t == null ? void 0 : t.name,
    identity: t == null ? void 0 : t.identity,
    metadata: t == null ? void 0 : t.metadata
  });
  return { identity: a, name: s, metadata: c };
}
function Lt(e = {}) {
  const t = A(e.participant), n = r.useMemo(() => W(t), [t]);
  return b(n, t.permissions);
}
function Rt({
  trackRef: e,
  onParticipantClick: t,
  disableSpeakingIndicator: n,
  htmlProps: a
}) {
  const s = R(e), c = r.useMemo(() => {
    const { className: p } = pe();
    return E(a, {
      className: p,
      onClick: (S) => {
        var g;
        if ((g = a.onClick) == null || g.call(a, S), typeof t == "function") {
          const m = s.publication ?? s.participant.getTrackPublication(s.source);
          t({ participant: s.participant, track: m });
        }
      }
    });
  }, [
    a,
    t,
    s.publication,
    s.source,
    s.participant
  ]), o = s.participant.getTrackPublication(v.Source.Microphone), u = r.useMemo(() => ({
    participant: s.participant,
    source: v.Source.Microphone,
    publication: o
  }), [o, s.participant]), i = z(s), d = z(u), f = Ke(s.participant), l = Ze(s);
  return {
    elementProps: {
      "data-lk-audio-muted": d,
      "data-lk-video-muted": i,
      "data-lk-speaking": n === !0 ? !1 : f,
      "data-lk-local-participant": s.participant.isLocal,
      "data-lk-source": s.source,
      "data-lk-facing-mode": l,
      ...c
    }
  };
}
function H(e = {}) {
  const t = k(e.room), [n, a] = r.useState([]);
  return r.useEffect(() => {
    const s = be(t, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(a);
    return () => s.unsubscribe();
  }, [t, JSON.stringify(e.updateOnlyOn)]), n;
}
function Nt(e = {}) {
  const t = H(e), { localParticipant: n } = et(e);
  return r.useMemo(
    () => [n, ...t],
    [n, t]
  );
}
function Ft(e) {
  return e = me(e), r.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Vt(e, t = {}) {
  const n = T(), [a] = r.useState(t.updateOnlyOn), s = r.useMemo(() => typeof e == "string" ? Se(n, e, {
    additionalEvents: a
  }) : ge(n, e, {
    additionalEvents: a
  }), [n, JSON.stringify(e), a]), [c, o] = r.useState({
    p: void 0
  });
  return r.useEffect(() => {
    const u = s.subscribe((i) => o({ p: i }));
    return () => u.unsubscribe();
  }, [s]), c.p;
}
function _t(e = {}) {
  const t = k(e.room), n = r.useMemo(() => ve(t), [t]), { name: a, metadata: s } = b(n, {
    name: t.name,
    metadata: t.metadata
  });
  return { name: a, metadata: s };
}
function nt() {
  const e = T(), t = r.useMemo(() => he(e), [e]);
  return b(t, e.activeSpeakers);
}
function Bt(e) {
  const [t, n] = r.useState(
    _(e)
  ), a = nt();
  return r.useEffect(() => {
    n(_(e));
  }, [a, e]), t;
}
function zt({ room: e, props: t }) {
  const n = k(e), { className: a, roomAudioPlaybackAllowedObservable: s, handleStartAudioPlayback: c } = r.useMemo(
    () => Me(),
    []
  ), o = r.useMemo(
    () => s(n),
    [n, s]
  ), { canPlayAudio: u } = b(o, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { mergedProps: r.useMemo(
    () => E(t, {
      className: a,
      onClick: () => {
        c(n);
      },
      style: { display: u ? "none" : "block" }
    }),
    [t, a, u, c, n]
  ), canPlayAudio: u };
}
function Ut({ room: e, props: t }) {
  const n = k(e), { className: a, roomVideoPlaybackAllowedObservable: s, handleStartVideoPlayback: c } = r.useMemo(
    () => ye(),
    []
  ), o = r.useMemo(
    () => s(n),
    [n, s]
  ), { canPlayVideo: u } = b(o, {
    canPlayVideo: n.canPlaybackVideo
  });
  return { mergedProps: r.useMemo(
    () => E(t, {
      className: a,
      onClick: () => {
        c(n);
      },
      style: { display: u ? "none" : "block" }
    }),
    [t, a, u, c, n]
  ), canPlayVideo: u };
}
function qt(e, t = {}) {
  const n = r.useRef(null), a = r.useRef(null), s = t.minSwipeDistance ?? 50, c = (i) => {
    a.current = null, n.current = i.targetTouches[0].clientX;
  }, o = (i) => {
    a.current = i.targetTouches[0].clientX;
  }, u = r.useCallback(() => {
    if (!n.current || !a.current)
      return;
    const i = n.current - a.current, d = i > s, f = i < -s;
    d && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe();
  }, [s, t]);
  r.useEffect(() => {
    const i = e.current;
    return i && (i.addEventListener("touchstart", c, { passive: !0 }), i.addEventListener("touchmove", o, { passive: !0 }), i.addEventListener("touchend", u, { passive: !0 })), () => {
      i && (i.removeEventListener("touchstart", c), i.removeEventListener("touchmove", o), i.removeEventListener("touchend", u));
    };
  }, [e, u]);
}
function Jt({ props: e }) {
  const { dispatch: t, state: n } = x().widget, { className: a } = r.useMemo(() => Pe(), []);
  return { mergedProps: r.useMemo(() => E(e, {
    className: a,
    onClick: () => {
      t && t({ msg: "toggle_chat" });
    },
    "aria-pressed": n != null && n.showChat ? "true" : "false",
    "data-lk-unread-msgs": n ? n.unreadMessages < 10 ? n.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, a, t, n]) };
}
function xt(e, t, n = {}) {
  const [a, s] = r.useState(void 0);
  return r.useEffect(() => {
    var o;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0)
      return;
    (async () => {
      w.debug("fetching token");
      const u = new URLSearchParams({ ...n.userInfo, roomName: t }), i = await fetch(`${e}?${u.toString()}`);
      if (!i.ok) {
        w.error(
          `Could not fetch token. Server responded with status ${i.status}: ${i.statusText}`
        );
        return;
      }
      const { accessToken: d } = await i.json();
      s(d);
    })();
  }, [e, t, JSON.stringify(n)]), a;
}
function Wt(e) {
  var c, o;
  const t = R(e), { className: n, mediaMutedObserver: a } = r.useMemo(
    () => ke(t),
    [N(t)]
  );
  return { isMuted: b(
    a,
    !!((c = t.publication) != null && c.isMuted || (o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)
  ), className: n };
}
function Gt({
  source: e,
  onChange: t,
  initialState: n,
  captureOptions: a,
  publishOptions: s,
  onDeviceError: c,
  ...o
}) {
  var P;
  const u = G(), i = (P = u == null ? void 0 : u.localParticipant) == null ? void 0 : P.getTrackPublication(e), d = r.useRef(!1), { toggle: f, className: l, pendingObserver: p, enabledObserver: S } = r.useMemo(
    () => u ? Te(e, u, a, s, c) : Ee(),
    [u, e, JSON.stringify(a), s]
  ), g = b(p, !1), m = b(S, n ?? !!(i != null && i.isEnabled));
  r.useEffect(() => {
    t == null || t(m, d.current), d.current = !1;
  }, [m, t]), r.useEffect(() => {
    n !== void 0 && (w.debug("forcing initial toggle state", e, n), f(n));
  }, []);
  const y = r.useMemo(() => E(o, { className: l }), [o, l]), h = r.useCallback(
    (M) => {
      var O;
      d.current = !0, f().catch(() => d.current = !1), (O = o.onClick) == null || O.call(o, M);
    },
    [o, f]
  );
  return {
    toggle: f,
    enabled: m,
    pending: g,
    track: i,
    buttonProps: {
      ...y,
      "aria-pressed": m,
      "data-lk-source": e,
      "data-lk-enabled": m,
      disabled: g,
      onClick: h
    }
  };
}
function Qt(e = [
  v.Source.Camera,
  v.Source.Microphone,
  v.Source.ScreenShare,
  v.Source.ScreenShareAudio,
  v.Source.Unknown
], t = {}) {
  const n = k(t.room), [a, s] = r.useState([]), [c, o] = r.useState([]), u = r.useMemo(() => e.map((d) => we(d) ? d.source : d), [JSON.stringify(e)]);
  return r.useEffect(() => {
    const d = Ae(n, u, {
      additionalRoomEvents: t.updateOnlyOn,
      onlySubscribed: t.onlySubscribed
    }).subscribe(({ trackReferences: f, participants: l }) => {
      w.debug("setting track bundles", f, l), s(f), o(l);
    });
    return () => d.unsubscribe();
  }, [
    n,
    JSON.stringify(t.onlySubscribed),
    JSON.stringify(t.updateOnlyOn),
    JSON.stringify(e)
  ]), r.useMemo(() => {
    if ($(e)) {
      const d = at(e, c), f = Array.from(a);
      return c.forEach((l) => {
        d.has(l.identity) && (d.get(l.identity) ?? []).forEach((S) => {
          if (a.find(
            ({ participant: m, publication: y }) => l.identity === m.identity && y.source === S
          ))
            return;
          w.debug(
            `Add ${S} placeholder for participant ${l.identity}.`
          );
          const g = {
            participant: l,
            source: S
          };
          f.push(g);
        });
      }), f;
    } else
      return a;
  }, [a, c, e]);
}
function st(e, t) {
  const n = new Set(e);
  for (const a of t)
    n.delete(a);
  return n;
}
function at(e, t) {
  const n = /* @__PURE__ */ new Map();
  if ($(e)) {
    const a = e.filter((s) => s.withPlaceholder).map((s) => s.source);
    t.forEach((s) => {
      const c = s.getTrackPublications().map((u) => {
        var i;
        return (i = u.track) == null ? void 0 : i.source;
      }).filter((u) => u !== void 0), o = Array.from(
        st(new Set(a), new Set(c))
      );
      o.length > 0 && n.set(s.identity, o);
    });
  }
  return n;
}
function rt(e) {
  const [t, n] = r.useState(Ce(e)), { trackObserver: a } = r.useMemo(() => Ie(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return r.useEffect(() => {
    const s = a.subscribe((c) => {
      n(c);
    });
    return () => s == null ? void 0 : s.unsubscribe();
  }, [a]), {
    participant: e.participant,
    source: e.source ?? v.Source.Unknown,
    publication: t
  };
}
function $t(e, t) {
  const n = A(t);
  return rt({ name: e, participant: n });
}
function Ht(e) {
  const t = T(), n = I(t), a = r.useMemo(
    () => n === C.Disconnected,
    [n]
  ), s = r.useMemo(
    () => Oe(t, e),
    [t, e, a]
  ), c = b(s.isSendingObservable, !1), o = b(s.messageObservable, []);
  return { send: s.send, chatMessages: o, isSending: c };
}
function jt(e = {}) {
  const [t, n] = r.useState(
    De(e.defaults, e.preventLoad ?? !1)
  ), a = r.useCallback((i) => {
    n((d) => ({ ...d, audioEnabled: i }));
  }, []), s = r.useCallback((i) => {
    n((d) => ({ ...d, videoEnabled: i }));
  }, []), c = r.useCallback((i) => {
    n((d) => ({ ...d, audioDeviceId: i }));
  }, []), o = r.useCallback((i) => {
    n((d) => ({ ...d, videoDeviceId: i }));
  }, []), u = r.useCallback((i) => {
    n((d) => ({ ...d, username: i }));
  }, []);
  return r.useEffect(() => {
    Le(t, e.preventSave ?? !1);
  }, [t, e.preventSave]), {
    userChoices: t,
    saveAudioInputEnabled: a,
    saveVideoInputEnabled: s,
    saveAudioInputDeviceId: c,
    saveVideoInputDeviceId: o,
    saveUsername: u
  };
}
function Xt(e, t = {}) {
  const n = A(e), a = k(t.room), s = r.useMemo(() => Re(a, n), [a, n]);
  return b(
    s,
    n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted)
  );
}
function Yt(e, t = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const n = Ne(e) ? e.publication.track : e, [a, s] = r.useState(0);
  return r.useEffect(() => {
    if (!n || !n.mediaStream)
      return;
    const { cleanup: c, analyser: o } = V(n, t), u = o.frequencyBinCount, i = new Uint8Array(u), f = setInterval(() => {
      o.getByteFrequencyData(i);
      let l = 0;
      for (let p = 0; p < i.length; p++) {
        const S = i[p];
        l += S * S;
      }
      s(Math.sqrt(l / i.length) / 255);
    }, 1e3 / 30);
    return () => {
      c(), clearInterval(f);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), a;
}
const ct = (e) => {
  const t = (n) => {
    let c = 1 - Math.max(-100, Math.min(-10, n)) * -1 / 100;
    return c = Math.sqrt(c), c;
  };
  return e.map((n) => n === -1 / 0 ? 0 : t(n));
}, ot = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function Zt(e, t = {}) {
  var o;
  const n = e instanceof v ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track, a = { ...ot, ...t }, [s, c] = r.useState(
    new Array(a.bands).fill(0)
  );
  return r.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: u, cleanup: i } = V(n, a.analyserOptions), d = u.frequencyBinCount, f = new Float32Array(d), p = setInterval(() => {
      u.getFloatFrequencyData(f);
      let S = new Float32Array(f.length);
      for (let h = 0; h < f.length; h++)
        S[h] = f[h];
      S = S.slice(t.loPass, t.hiPass);
      const g = ct(S), m = Math.ceil(g.length / a.bands), y = [];
      for (let h = 0; h < a.bands; h++) {
        const P = g.slice(h * m, (h + 1) * m).reduce((M, O) => M += O, 0);
        y.push(P / m);
      }
      c(y);
    }, a.updateInterval);
    return () => {
      i(), clearInterval(p);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), s;
}
const it = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function Kt(e, t = {}) {
  var f;
  const n = e instanceof v ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track, a = { ...it, ...t }, s = r.useRef(new Float32Array()), c = r.useRef(performance.now()), o = r.useRef(0), [u, i] = r.useState([]), d = r.useCallback((l) => {
    i(
      Array.from(
        dt(l, a.barCount).map((p) => Math.sqrt(p) * a.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return r.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: l, cleanup: p } = V(n, {
      fftSize: U(a.barCount)
    }), S = U(a.barCount), g = new Float32Array(S), m = () => {
      if (y = requestAnimationFrame(m), l.getFloatTimeDomainData(g), s.current.map((h, P) => h + g[P]), o.current += 1, performance.now() - c.current >= a.updateInterval) {
        const h = g.map((P) => P / o.current);
        d(h), c.current = performance.now(), o.current = 0;
      }
    };
    let y = requestAnimationFrame(m);
    return () => {
      p(), cancelAnimationFrame(y);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), d]), {
    bars: u
  };
}
function U(e) {
  return e < 32 ? 32 : ut(e);
}
function ut(e) {
  let t = 2;
  for (; e >>= 1; )
    t <<= 1;
  return t;
}
function dt(e, t) {
  const n = Math.floor(e.length / t), a = new Float32Array(t);
  for (let s = 0; s < t; s++) {
    const c = n * s;
    let o = 0;
    for (let u = 0; u < n; u++)
      o = o + Math.abs(e[c + u]);
    a[s] = o / n;
  }
  return a;
}
function q(e, t) {
  const n = T(), a = F(), s = t ? n.getParticipantByIdentity(t) : a, c = r.useMemo(
    () => s ? Fe(s, { sources: e }) : void 0,
    [s == null ? void 0 : s.sid, s == null ? void 0 : s.identity, JSON.stringify(e)]
  );
  return b(c, []);
}
function lt(e) {
  var n, a, s;
  const t = r.useMemo(
    () => {
      var c;
      return (c = e == null ? void 0 : e.publication) != null && c.track ? Ve(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]
  );
  return b(t, {
    timestamp: Date.now(),
    rtpTimestamp: (s = (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track) == null ? void 0 : s.rtpTimestamp
  });
}
const ft = {
  bufferSize: 100
  // maxAge: 2_000,
};
function pt(e, t) {
  const n = { ...ft, ...t }, [a, s] = r.useState([]), c = lt(e), o = (u) => {
    var i;
    (i = n.onTranscription) == null || i.call(n, u), s(
      (d) => Be(
        d,
        // when first receiving a segment, add the current media timestamp to it
        u.map((f) => ze(f, c)),
        n.bufferSize
      )
    );
  };
  return r.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const u = _e(e.publication).subscribe((i) => {
      o(...i);
    });
    return () => {
      u.unsubscribe();
    };
  }, [e && N(e), o]), { segments: a };
}
function bt(e = {}) {
  const t = F(), n = e.participant ?? t, a = r.useMemo(
    // weird typescript constraint
    () => n ? L(n) : L(n),
    [n]
  );
  return b(a, {
    attributes: n == null ? void 0 : n.attributes
  });
}
function en(e, t = {}) {
  const n = A(t.participant), [a, s] = r.useState(n.attributes[e]);
  return r.useEffect(() => {
    if (!n)
      return;
    const c = L(n).subscribe((o) => {
      o.changed[e] !== void 0 && s(o.attributes[e]);
    });
    return () => {
      c.unsubscribe();
    };
  }, [n, e]), a;
}
const J = "lk.agent.state";
function tn() {
  const e = H(), t = e.find(
    (l) => l.kind === B.AGENT && !("lk.publish_on_behalf" in l.attributes)
  ), n = e.find(
    (l) => l.kind === B.AGENT && l.attributes["lk.publish_on_behalf"] === (t == null ? void 0 : t.identity)
  ), a = q(
    [v.Source.Microphone, v.Source.Camera],
    t == null ? void 0 : t.identity
  ), s = q(
    [v.Source.Microphone, v.Source.Camera],
    n == null ? void 0 : n.identity
  ), c = a.find((l) => l.source === v.Source.Microphone) ?? s.find((l) => l.source === v.Source.Microphone), o = a.find((l) => l.source === v.Source.Camera) ?? s.find((l) => l.source === v.Source.Camera), { segments: u } = pt(c), i = I(), { attributes: d } = bt({ participant: t }), f = r.useMemo(() => i === C.Disconnected ? "disconnected" : i === C.Connecting || !t || !(d != null && d[J]) ? "connecting" : d[J], [d, t, i]);
  return {
    agent: t,
    state: f,
    audioTrack: c,
    videoTrack: o,
    agentTranscriptions: u,
    agentAttributes: d
  };
}
function nn(e) {
  const t = k(e), n = I(t), a = r.useMemo(() => Ue(t), [t, n]);
  return b(a, t.isRecording);
}
function mt(e) {
  const t = T(), a = I(t) === C.Disconnected, s = r.useMemo(() => qe(t, e), [t, e]);
  return { textStreams: b(a ? void 0 : s, []) };
}
function sn(e) {
  const { participantIdentities: t, trackSids: n } = e ?? {}, { textStreams: a } = mt(Je.TRANSCRIPTION);
  return r.useMemo(
    () => a.filter(
      (c) => t ? t.includes(c.participantInfo.identity) : !0
    ).filter(
      (c) => {
        var o;
        return n ? n.includes(((o = c.streamInfo.attributes) == null ? void 0 : o["lk.transcribed_track_id"]) ?? "") : !0;
      }
    ),
    [a, t, n]
  );
}
export {
  At as A,
  Ft as B,
  et as C,
  Mt as D,
  kt as E,
  Ze as F,
  z as G,
  Ke as H,
  Dt as I,
  Lt as J,
  Nt as K,
  Vt as L,
  H as M,
  Bt as N,
  nt as O,
  xt as P,
  $t as Q,
  Yt as R,
  Kt as S,
  q as T,
  pt as U,
  tn as V,
  bt as W,
  en as X,
  nn as Y,
  mt as Z,
  sn as _,
  I as a,
  Jt as b,
  Tt as c,
  Et as d,
  Ct as e,
  zt as f,
  Ut as g,
  Gt as h,
  Pt as i,
  b as j,
  Wt as k,
  Rt as l,
  Xt as m,
  wt as n,
  Ot as o,
  qt as p,
  Ye as q,
  tt as r,
  Zt as s,
  Qt as t,
  yt as u,
  _t as v,
  Ht as w,
  jt as x,
  It as y,
  ht as z
};
//# sourceMappingURL=hooks-OJtwh4jO.mjs.map
