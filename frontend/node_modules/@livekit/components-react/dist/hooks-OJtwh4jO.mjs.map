{"version":3,"file":"hooks-OJtwh4jO.mjs","sources":["../src/hooks/internal/useResizeObserver.ts","../src/hooks/internal/useObservableState.ts","../src/hooks/internal/useMediaQuery.ts","../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useConnectionQualityIndicator.ts","../src/hooks/useConnectionStatus.ts","../src/hooks/useDataChannel.ts","../src/hooks/useDisconnectButton.ts","../src/hooks/useFacingMode.ts","../src/hooks/useFocusToggle.ts","../src/hooks/useGridLayout.ts","../src/hooks/useIsMuted.ts","../src/hooks/useIsSpeaking.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useLocalParticipantPermissions.ts","../src/hooks/useMediaDeviceSelect.ts","../src/hooks/useMediaDevices.ts","../src/hooks/useVisualStableUpdate.ts","../src/hooks/usePagination.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useParticipantTile.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/usePinnedTracks.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useStartAudio.ts","../src/hooks/useStartVideo.ts","../src/hooks/useSwipe.ts","../src/hooks/useChatToggle.ts","../src/hooks/useToken.ts","../src/hooks/useTrackMutedIndicator.ts","../src/hooks/useTrackToggle.ts","../src/hooks/useTracks.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useChat.ts","../src/hooks/usePersistentUserChoices.ts","../src/hooks/useIsEncrypted.ts","../src/hooks/useTrackVolume.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\n\nconst useLatest = <T>(current: T) => {\n  const storedValue = React.useRef(current);\n  React.useEffect(() => {\n    storedValue.current = current;\n  });\n  return storedValue;\n};\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(\n  observable: Observable<T> | undefined,\n  startWith: T,\n  resetWhenObservableChanges = true,\n) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    if (resetWhenObservableChanges) {\n      setState(startWith);\n    }\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable, resetWhenObservableChanges]);\n  return state;\n}\n","import * as React from 'react';\n/**\n * Implementation used from https://github.com/juliencrn/usehooks-ts\n *\n * @internal\n */\nexport function useMediaQuery(query: string): boolean {\n  const getMatches = (query: string): boolean => {\n    // Prevents SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  };\n\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\n\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n\n  React.useEffect(() => {\n    const matchMedia = window.matchMedia(query);\n\n    // Triggered at the first client-side load and if query changes\n    handleChange();\n\n    // Listen matchMedia\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener('change', handleChange);\n    }\n\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener('change', handleChange);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n\n  return matches;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport { ConnectionQuality } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, ConnectionQuality.Unknown);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton(buttonProps);\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\n  }, [trackReference, layoutContext?.pin.state]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (inFocus) {\n            layoutContext?.pin.dispatch?.({\n              msg: 'clear_pin',\n            });\n          } else {\n            layoutContext?.pin.dispatch?.({\n              msg: 'set_pin',\n              trackReference,\n            });\n          }\n        },\n      }),\n    [props, className, trackReference, inFocus, layoutContext?.pin],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n  options: {\n    gridLayouts?: GridLayoutDefinition[];\n  } = {},\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\n  const { width, height } = useSize(gridElement);\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n    containerWidth: width,\n    containerHeight: height,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example With a track reference\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n *\n * @example With a track source / participant\n * ```tsx\n * const isMuted = useIsMuted('camera', { participant });\n * ```\n *\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\n * @param options - Additional options when using a `Track.Source`\n * @returns boolean indicating if the track is muted\n *\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\n\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\n    roomFallback?.getActiveDevice(kind) ?? 'default',\n  );\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, roomFallback),\n    [kind, roomFallback, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      if (!deviceId) {\n        return;\n      }\n      log.info('setCurrentDeviceId', deviceId);\n      setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({\n  kind,\n  onError,\n}: {\n  kind: MediaDeviceKind;\n  onError?: (e: Error) => void;\n}) {\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError),\n    [kind, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\nimport { Track } from 'livekit-client';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrackPublication(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\n  const micRef = React.useMemo(() => {\n    return {\n      participant: trackReference.participant,\n      source: Track.Source.Microphone,\n      publication: micTrack,\n    };\n  }, [micTrack, trackReference.participant]);\n  const isVideoMuted = useIsMuted(trackReference);\n  const isAudioMuted = useIsMuted(micRef);\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { useObservableState } from './internal';\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(trackReference),\n    [getTrackReferenceId(trackReference)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(\n      trackReference.publication?.isMuted ||\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\n    ),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  publishOptions,\n  onDeviceError,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const room = useMaybeRoomContext();\n  const track = room?.localParticipant?.getTrackPublication(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () =>\n      room\n        ? setupMediaToggle<T>(source, room, captureOptions, publishOptions, onDeviceError)\n        : setupManualToggle(),\n    [room, source, JSON.stringify(captureOptions), publishOptions],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().catch(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n    ? TrackReferenceOrPlaceholder[]\n    : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [\n    room,\n    JSON.stringify(options.onlySubscribed),\n    JSON.stringify(options.updateOnlyOn),\n    JSON.stringify(sources),\n  ]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTrackPublications()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal/useObservableState';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n *\n * @remarks\n * Message history is not persisted and will be lost if the component is refreshed.\n * You may want to persist message history in the browser, a cache or a database.\n *\n * @returns An object containing:\n * - `chatMessages` - Array of received chat messages\n * - `send` - Function to send a new message\n * - `isSending` - Boolean indicating if a message is currently being sent\n *\n * @example\n * ```tsx\n * function ChatComponent() {\n *   const { chatMessages, send, isSending } = useChat();\n *\n *   return (\n *     <div>\n *       {chatMessages.map((msg) => (\n *         <div key={msg.timestamp}>\n *           {msg.from?.identity}: {msg.message}\n *         </div>\n *       ))}\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\n *         Send Message\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * @public\n */\nexport function useChat(options?: ChatOptions) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n  const isDisconnected = React.useMemo(\n    () => connectionState === ConnectionState.Disconnected,\n    [connectionState],\n  ); // used to reset the messages on room disconnect\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\n    () => setupChat(room, options),\n    [room, options, isDisconnected],\n  );\n  const isSending = useObservableState(setup.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\n\n  return { send: setup.send, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant } from 'livekit-client';\nimport type { Participant, Room } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport interface UseIsEncryptedOptions {\n  room?: Room;\n}\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\n  const p = useEnsureParticipant(participant);\n\n  const room = useEnsureRoom(options.room);\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport function useTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n}\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport function useMultibandTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...multibandDefaults, ...options };\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\n    new Array(opts.bands).fill(0),\n  );\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(options.loPass, options.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\n      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands); // we want logarithmic chunking here\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        const summedVolumes = normalizedFrequencies\n          .slice(i * chunkSize, (i + 1) * chunkSize)\n          .reduce((acc, val) => (acc += val), 0);\n        chunks.push(summedVolumes / chunkSize);\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n}\n\n/**\n * @alpha\n */\nexport interface AudioWaveformOptions {\n  barCount?: number;\n  volMultiplier?: number;\n  updateInterval?: number;\n}\n\nconst waveformDefaults = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20,\n} as const satisfies AudioWaveformOptions;\n\n/**\n * @alpha\n */\nexport function useAudioWaveform(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: AudioWaveformOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...waveformDefaults, ...options };\n\n  const aggregateWave = React.useRef(new Float32Array());\n  const timeRef = React.useRef(performance.now());\n  const updates = React.useRef(0);\n  const [bars, setBars] = React.useState<number[]>([]);\n\n  const onUpdate = React.useCallback((wave: Float32Array) => {\n    setBars(\n      Array.from(\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ),\n    );\n  }, []);\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, {\n      fftSize: getFFTSizeValue(opts.barCount),\n    });\n\n    const bufferLength = getFFTSizeValue(opts.barCount);\n    const dataArray = new Float32Array(bufferLength);\n\n    const update = () => {\n      updateWaveform = requestAnimationFrame(update);\n      analyser.getFloatTimeDomainData(dataArray);\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\n      updates.current += 1;\n\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\n        const newData = dataArray.map((v) => v / updates.current);\n        onUpdate(newData);\n        timeRef.current = performance.now();\n        updates.current = 0;\n      }\n    };\n\n    let updateWaveform = requestAnimationFrame(update);\n\n    return () => {\n      cleanup();\n      cancelAnimationFrame(updateWaveform);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\n\n  return {\n    bars,\n  };\n}\n\nfunction getFFTSizeValue(x: number) {\n  if (x < 32) return 32;\n  else return pow2ceil(x);\n}\n\n// function sigmoid(x: number, k = 2, s = 0) {\n//   return 1 / (1 + Math.exp(-(x - s) / k));\n// }\n\nfunction pow2ceil(v: number) {\n  let p = 2;\n  while ((v >>= 1)) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction filterData(audioData: Float32Array, numSamples: number) {\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\n  const filteredData = new Float32Array(numSamples);\n  for (let i = 0; i < numSamples; i++) {\n    const blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\n  }\n  return filteredData;\n}\n\n// function normalizeData(audioData: Float32Array) {\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\n//   return audioData.map((n) => n * multiplier);\n// }\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Track } from 'livekit-client';\nimport { useMaybeParticipantContext, useRoomContext } from '../context';\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks(\n  sources: Track.Source[],\n  participantIdentity?: string,\n): TrackReference[] {\n  const room = useRoomContext();\n  const participantContext = useMaybeParticipantContext();\n  const p = participantIdentity\n    ? room.getParticipantByIdentity(participantIdentity)\n    : participantContext;\n  const observable = React.useMemo(\n    () => (p ? participantTracksObservable(p, { sources }) : undefined),\n    [p?.sid, p?.identity, JSON.stringify(sources)],\n  );\n\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\n\n/**\n * @beta\n */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'initializing'\n  | 'listening'\n  | 'thinking'\n  | 'speaking';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = 'lk.agent.state';\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) => p.kind === ParticipantKind.AGENT && !('lk.publish_on_behalf' in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT && p.attributes['lk.publish_on_behalf'] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useRoomContext } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string) {\n  const room = useRoomContext();\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic } from '@livekit/components-core';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION);\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(stream.streamInfo.attributes?.['lk.transcribed_track_id'] ?? '')\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n"],"names":["useLatest","current","storedValue","React","useResizeObserver","target","callback","resizeObserver","getResizeObserver","storedCallback","didUnsubscribe","targetEl","cb","entry","observer","createResizeObserver","ticking","allEntries","callbacks","entries","obs","triggered","i","cbs","cbIndex","_resizeObserver","useSize","size","setSize","width","height","resizeCallback","useObservableState","observable","startWith","resetWhenObservableChanges","state","setState","subscription","useMediaQuery","query","getMatches","matches","setMatches","handleChange","matchMedia","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","roomAudioPlaybackAllowedObservable","canPlayAudio","useClearPinButton","props","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useConnectionQualityIndicator","options","p","useEnsureParticipant","connectionQualityObserver","setupConnectionQualityIndicator","quality","ConnectionQuality","useConnectionState","r","connectionStateObserver","useDataChannel","topicOrCallback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","useDisconnectButton","connectionState","disconnect","setupDisconnectButton","ConnectionState","useFacingMode","trackReference","LocalTrackPublication","localTrack","facingMode","facingModeFromLocalTrack","useFocusToggle","trackRef","useEnsureTrackRef","layoutContext","useMaybeLayoutContext","setupFocusToggle","inFocus","isTrackReferencePinned","event","_a","_c","_b","_e","_d","useGridLayout","gridElement","trackCount","gridLayouts","GRID_LAYOUTS","layout","selectGridLayout","useIsMuted","sourceOrTrackRef","passedParticipant","ref","isMuted","setIsMuted","listener","mutedObserver","getTrackReferenceId","useIsSpeaking","participant","createIsSpeakingObserver","useLocalParticipant","localParticipant","setLocalParticipant","isMicrophoneEnabled","setIsMicrophoneEnabled","isCameraEnabled","setIsCameraEnabled","lastMicrophoneError","setLastMicrophoneError","lastCameraError","setLastCameraError","isScreenShareEnabled","setIsScreenShareEnabled","microphoneTrack","setMicrophoneTrack","cameraTrack","setCameraTrack","handleUpdate","media","observeParticipantMedia","useLocalParticipantPermissions","permissionObserver","participantPermissionObserver","useMediaDeviceSelect","kind","track","requestPermissions","onError","roomContext","useMaybeRoomContext","roomFallback","Room","deviceObserver","createMediaDeviceObserver","devices","currentDeviceId","setCurrentDeviceId","activeDeviceObservable","setActiveMediaDevice","setupDeviceSelector","deviceId","log","useMediaDevices","useVisualStableUpdate","trackReferences","maxItemsOnPage","lastTrackRefs","lastMaxItemsOnPage","layoutChanged","sortedTrackRefs","sortTrackReferences","updatedTrackRefs","updatePages","error","usePagination","itemPerPage","currentPage","setCurrentPage","totalPageCount","lastItemIndex","firstItemIndex","changePage","direction","goToPage","num","tracksOnPage","useParticipantInfo","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useParticipantTile","onParticipantClick","disableSpeakingIndicator","htmlProps","mergedProps","setupParticipantTile","micTrack","Track","micRef","isVideoMuted","isAudioMuted","isSpeaking","useRemoteParticipants","participants","setParticipants","connectedParticipantsObserver","useParticipants","remoteParticipants","usePinnedTracks","useEnsureLayoutContext","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useStartAudio","handleStartAudioPlayback","setupStartAudio","useStartVideo","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","setupStartVideo","canPlayVideo","useSwipe","element","touchStart","touchEnd","minSwipeDistance","onTouchStart","onTouchMove","onTouchEnd","distance","isLeftSwipe","isRightSwipe","elementCopy","useChatToggle","setupChatToggle","useToken","tokenEndpoint","roomName","token","setToken","params","res","accessToken","useTrackMutedIndicator","mediaMutedObserver","setupTrackMutedIndicator","useTrackToggle","source","onChange","initialState","captureOptions","publishOptions","onDeviceError","rest","userInteractionRef","toggle","pendingObserver","enabledObserver","setupMediaToggle","setupManualToggle","pending","enabled","newProps","clickHandler","evt","useTracks","sources","setTrackReferences","sources_","s","isSourceWitOptions","trackReferencesObservable","isSourcesWithOptions","requirePlaceholder","requiredPlaceholders","trackReferencesWithPlaceholders","placeholderSource","publication","placeholder","difference","setA","setB","_difference","elem","placeholderMap","sourcesThatNeedPlaceholder","sourceWithOption","sourcesOfSubscribedTracks","pub","trackSource","placeholderNeededForThisParticipant","useTrackRefBySourceOrName","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","useTrackByName","useChat","isDisconnected","setup","setupChat","chatMessages","usePersistentUserChoices","userChoices","setSettings","loadUserChoices","saveAudioInputEnabled","isEnabled","prev","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","username","saveUserChoices","useIsEncrypted","encryptionStatusObservable","useTrackVolume","trackOrTrackReference","isTrackReference","volume","setVolume","cleanup","analyser","createAudioAnalyser","bufferLength","dataArray","interval","sum","a","normalizeFrequencies","frequencies","normalizeDb","value","db","multibandDefaults","useMultibandTrackVolume","opts","frequencyBands","setFrequencyBands","normalizedFrequencies","chunkSize","chunks","summedVolumes","acc","val","waveformDefaults","useAudioWaveform","aggregateWave","timeRef","updates","bars","setBars","onUpdate","wave","filterData","v","getFFTSizeValue","update","updateWaveform","newData","x","pow2ceil","audioData","numSamples","blockSize","filteredData","blockStart","j","useParticipantTracks","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","trackSyncTimeObserver","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","addTimestampsToTranscription","trackTranscriptionObserver","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","state_attribute","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","attributes","useIsRecording","recordingStatusObservable","useTextStream","textStreamData","setupTextStream","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream"],"mappings":"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"}