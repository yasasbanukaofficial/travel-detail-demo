{"version":3,"file":"shared-DimS3cEB.js","sources":["../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useDataChannel.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useToken.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts","../src/hooks/useTextStream.ts","../src/hooks/useTranscriptions.ts"],"sourcesContent":["import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\nimport type { DisconnectReason } from 'livekit-client';\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\nimport * as React from 'react';\nimport type { HTMLAttributes } from 'react';\n\nimport type { LiveKitRoomProps } from '../components';\nimport { mergeProps } from '../mergeProps';\nimport { roomOptionsStringifyReplacer } from '../utils';\n\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\n  connect: true,\n  audio: false,\n  video: false,\n};\n\n/**\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\n *\n * @example\n * ```tsx\n * const { room, htmlProps } = useLiveKitRoom();\n * return <div {...htmlProps}>...</div>;\n * ```\n * @public\n */\nexport function useLiveKitRoom<T extends HTMLElement>(\n  props: LiveKitRoomProps,\n): {\n  room: Room | undefined;\n  htmlProps: HTMLAttributes<T>;\n} {\n  const {\n    token,\n    serverUrl,\n    options,\n    room: passedRoom,\n    connectOptions,\n    connect,\n    audio,\n    video,\n    screen,\n    onConnected,\n    onDisconnected,\n    onError,\n    onMediaDeviceFailure,\n    onEncryptionError,\n    simulateParticipants,\n    ...rest\n  } = { ...defaultRoomProps, ...props };\n  if (options && passedRoom) {\n    log.warn(\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\n    );\n  }\n\n  const [room, setRoom] = React.useState<Room | undefined>();\n\n  const shouldConnect = React.useRef(connect);\n\n  React.useEffect(() => {\n    setRoom(passedRoom ?? new Room(options));\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\n\n  const htmlProps = React.useMemo(() => {\n    const { className } = setupLiveKitRoom();\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\n  }, [rest]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const onSignalConnected = () => {\n      const localP = room.localParticipant;\n\n      log.debug('trying to publish local tracks');\n      Promise.all([\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\n      ]).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    };\n\n    const handleMediaDeviceError = (e: Error, kind: MediaDeviceKind) => {\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\n      onMediaDeviceFailure?.(mediaDeviceFailure, kind);\n    };\n    const handleEncryptionError = (e: Error) => {\n      onEncryptionError?.(e);\n    };\n    const handleDisconnected = (reason?: DisconnectReason) => {\n      onDisconnected?.(reason);\n    };\n    const handleConnected = () => {\n      onConnected?.();\n    };\n\n    room\n      .on(RoomEvent.SignalConnected, onSignalConnected)\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\n      .on(RoomEvent.Disconnected, handleDisconnected)\n      .on(RoomEvent.Connected, handleConnected);\n\n    return () => {\n      room\n        .off(RoomEvent.SignalConnected, onSignalConnected)\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\n        .off(RoomEvent.Disconnected, handleDisconnected)\n        .off(RoomEvent.Connected, handleConnected);\n    };\n  }, [\n    room,\n    audio,\n    video,\n    screen,\n    onError,\n    onEncryptionError,\n    onMediaDeviceFailure,\n    onConnected,\n    onDisconnected,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n\n    if (simulateParticipants) {\n      room.simulateParticipants({\n        participants: {\n          count: simulateParticipants,\n        },\n        publish: {\n          audio: true,\n          useRealTracks: true,\n        },\n      });\n      return;\n    }\n\n    if (connect) {\n      shouldConnect.current = true;\n      log.debug('connecting');\n      if (!token) {\n        log.debug('no token yet');\n        return;\n      }\n      if (!serverUrl) {\n        log.warn('no livekit url provided');\n        onError?.(Error('no livekit url provided'));\n        return;\n      }\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\n        log.warn(e);\n        if (shouldConnect.current === true) {\n          onError?.(e as Error);\n        }\n      });\n    } else {\n      log.debug('disconnecting because connect is false');\n      shouldConnect.current = false;\n      room.disconnect();\n    }\n  }, [\n    connect,\n    token,\n    JSON.stringify(connectOptions),\n    room,\n    onError,\n    serverUrl,\n    simulateParticipants,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    return () => {\n      log.info('disconnecting on onmount');\n      room.disconnect();\n    };\n  }, [room]);\n\n  return { room, htmlProps };\n}\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Track } from 'livekit-client';\nimport { useMaybeParticipantContext, useRoomContext } from '../context';\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks(\n  sources: Track.Source[],\n  participantIdentity?: string,\n): TrackReference[] {\n  const room = useRoomContext();\n  const participantContext = useMaybeParticipantContext();\n  const p = participantIdentity\n    ? room.getParticipantByIdentity(participantIdentity)\n    : participantContext;\n  const observable = React.useMemo(\n    () => (p ? participantTracksObservable(p, { sources }) : undefined),\n    [p?.sid, p?.identity, JSON.stringify(sources)],\n  );\n\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\n\n/**\n * @beta\n */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'initializing'\n  | 'listening'\n  | 'thinking'\n  | 'speaking';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = 'lk.agent.state';\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) => p.kind === ParticipantKind.AGENT && !('lk.publish_on_behalf' in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT && p.attributes['lk.publish_on_behalf'] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useRoomContext } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string) {\n  const room = useRoomContext();\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic } from '@livekit/components-core';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION);\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(stream.streamInfo.attributes?.['lk.transcribed_track_id'] ?? '')\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n"],"names":["useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","React","observable","roomAudioPlaybackAllowedObservable","canPlayAudio","useObservableState","useClearPinButton","props","state","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useDataChannel","topicOrCallback","callback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","defaultRoomProps","useLiveKitRoom","token","serverUrl","options","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","log","setRoom","shouldConnect","Room","roomOptionsStringifyReplacer","htmlProps","setupLiveKitRoom","onSignalConnected","localP","e","handleMediaDeviceError","kind","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useParticipantInfo","p","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useEnsureParticipant","permissionObserver","participantPermissionObserver","useRemoteParticipants","participants","setParticipants","listener","connectedParticipantsObserver","useParticipants","remoteParticipants","localParticipant","useLocalParticipant","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useToken","tokenEndpoint","roomName","setToken","_a","params","res","accessToken","useTrackRefBySourceOrName","source","publication","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","subscription","Track","useTrackByName","participant","useParticipantTracks","sources","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","ref","trackSyncTimeObserver","_c","_b","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","trackRef","opts","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","s","addTimestampsToTranscription","trackTranscriptionObserver","evt","getTrackReferenceId","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","val","state_attribute","useVoiceAssistant","agent","ParticipantKind","worker","agentTracks","workerTracks","audioTrack","t","videoTrack","agentTranscriptions","connectionState","useConnectionState","attributes","ConnectionState","useIsRecording","r","recordingStatusObservable","useTextStream","isDisconnected","textStreamData","setupTextStream","textStreamObservable","useTranscriptions","participantIdentities","trackSids","textStreams","DataTopic","stream"],"mappings":"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"}